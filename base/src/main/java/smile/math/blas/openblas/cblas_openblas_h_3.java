// Generated by jextract

package smile.math.blas.openblas;

import java.lang.invoke.*;
import java.lang.foreign.*;
import java.nio.ByteOrder;
import java.util.*;
import java.util.function.*;
import java.util.stream.*;

import static java.lang.foreign.ValueLayout.*;
import static java.lang.foreign.MemoryLayout.PathElement.*;

public class cblas_openblas_h_3 extends cblas_openblas_h_4 {

    cblas_openblas_h_3() {
        // Should not be called directly
    }

    private static class dgeqrt3_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("dgeqrt3_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dgeqrt3_(const int *m, const int *n, double *A, const int *lda, double *T, const int *ldt, int *info)
     * }
     */
    public static FunctionDescriptor dgeqrt3_$descriptor() {
        return dgeqrt3_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dgeqrt3_(const int *m, const int *n, double *A, const int *lda, double *T, const int *ldt, int *info)
     * }
     */
    public static MethodHandle dgeqrt3_$handle() {
        return dgeqrt3_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dgeqrt3_(const int *m, const int *n, double *A, const int *lda, double *T, const int *ldt, int *info)
     * }
     */
    public static MemorySegment dgeqrt3_$address() {
        return dgeqrt3_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dgeqrt3_(const int *m, const int *n, double *A, const int *lda, double *T, const int *ldt, int *info)
     * }
     */
    public static void dgeqrt3_(MemorySegment m, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment T, MemorySegment ldt, MemorySegment info) {
        var mh$ = dgeqrt3_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dgeqrt3_", m, n, A, lda, T, ldt, info);
            }
            mh$.invokeExact(m, n, A, lda, T, ldt, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sgeqrt3_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("sgeqrt3_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void sgeqrt3_(const int *m, const int *n, float *A, const int *lda, float *T, const int *ldt, int *info)
     * }
     */
    public static FunctionDescriptor sgeqrt3_$descriptor() {
        return sgeqrt3_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void sgeqrt3_(const int *m, const int *n, float *A, const int *lda, float *T, const int *ldt, int *info)
     * }
     */
    public static MethodHandle sgeqrt3_$handle() {
        return sgeqrt3_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void sgeqrt3_(const int *m, const int *n, float *A, const int *lda, float *T, const int *ldt, int *info)
     * }
     */
    public static MemorySegment sgeqrt3_$address() {
        return sgeqrt3_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void sgeqrt3_(const int *m, const int *n, float *A, const int *lda, float *T, const int *ldt, int *info)
     * }
     */
    public static void sgeqrt3_(MemorySegment m, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment T, MemorySegment ldt, MemorySegment info) {
        var mh$ = sgeqrt3_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sgeqrt3_", m, n, A, lda, T, ldt, info);
            }
            mh$.invokeExact(m, n, A, lda, T, ldt, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zgeqrt3_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("zgeqrt3_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zgeqrt3_(const int *m, const int *n, _Complex double *A, const int *lda, _Complex double *T, const int *ldt, int *info)
     * }
     */
    public static FunctionDescriptor zgeqrt3_$descriptor() {
        return zgeqrt3_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zgeqrt3_(const int *m, const int *n, _Complex double *A, const int *lda, _Complex double *T, const int *ldt, int *info)
     * }
     */
    public static MethodHandle zgeqrt3_$handle() {
        return zgeqrt3_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zgeqrt3_(const int *m, const int *n, _Complex double *A, const int *lda, _Complex double *T, const int *ldt, int *info)
     * }
     */
    public static MemorySegment zgeqrt3_$address() {
        return zgeqrt3_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zgeqrt3_(const int *m, const int *n, _Complex double *A, const int *lda, _Complex double *T, const int *ldt, int *info)
     * }
     */
    public static void zgeqrt3_(MemorySegment m, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment T, MemorySegment ldt, MemorySegment info) {
        var mh$ = zgeqrt3_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zgeqrt3_", m, n, A, lda, T, ldt, info);
            }
            mh$.invokeExact(m, n, A, lda, T, ldt, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cgerfs_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cgerfs_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cgerfs_(const char *trans, const int *n, const int *nrhs, const _Complex float *A, const int *lda, const _Complex float *AF, const int *ldaf, const int *ipiv, const _Complex float *B, const int *ldb, _Complex float *X, const int *ldx, float *ferr, float *berr, _Complex float *work, float *rwork, int *info, size_t)
     * }
     */
    public static FunctionDescriptor cgerfs_$descriptor() {
        return cgerfs_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cgerfs_(const char *trans, const int *n, const int *nrhs, const _Complex float *A, const int *lda, const _Complex float *AF, const int *ldaf, const int *ipiv, const _Complex float *B, const int *ldb, _Complex float *X, const int *ldx, float *ferr, float *berr, _Complex float *work, float *rwork, int *info, size_t)
     * }
     */
    public static MethodHandle cgerfs_$handle() {
        return cgerfs_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cgerfs_(const char *trans, const int *n, const int *nrhs, const _Complex float *A, const int *lda, const _Complex float *AF, const int *ldaf, const int *ipiv, const _Complex float *B, const int *ldb, _Complex float *X, const int *ldx, float *ferr, float *berr, _Complex float *work, float *rwork, int *info, size_t)
     * }
     */
    public static MemorySegment cgerfs_$address() {
        return cgerfs_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cgerfs_(const char *trans, const int *n, const int *nrhs, const _Complex float *A, const int *lda, const _Complex float *AF, const int *ldaf, const int *ipiv, const _Complex float *B, const int *ldb, _Complex float *X, const int *ldx, float *ferr, float *berr, _Complex float *work, float *rwork, int *info, size_t)
     * }
     */
    public static void cgerfs_(MemorySegment trans, MemorySegment n, MemorySegment nrhs, MemorySegment A, MemorySegment lda, MemorySegment AF, MemorySegment ldaf, MemorySegment ipiv, MemorySegment B, MemorySegment ldb, MemorySegment X, MemorySegment ldx, MemorySegment ferr, MemorySegment berr, MemorySegment work, MemorySegment rwork, MemorySegment info, long x17) {
        var mh$ = cgerfs_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cgerfs_", trans, n, nrhs, A, lda, AF, ldaf, ipiv, B, ldb, X, ldx, ferr, berr, work, rwork, info, x17);
            }
            mh$.invokeExact(trans, n, nrhs, A, lda, AF, ldaf, ipiv, B, ldb, X, ldx, ferr, berr, work, rwork, info, x17);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dgerfs_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("dgerfs_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dgerfs_(const char *trans, const int *n, const int *nrhs, const double *A, const int *lda, const double *AF, const int *ldaf, const int *ipiv, const double *B, const int *ldb, double *X, const int *ldx, double *ferr, double *berr, double *work, int *iwork, int *info, size_t)
     * }
     */
    public static FunctionDescriptor dgerfs_$descriptor() {
        return dgerfs_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dgerfs_(const char *trans, const int *n, const int *nrhs, const double *A, const int *lda, const double *AF, const int *ldaf, const int *ipiv, const double *B, const int *ldb, double *X, const int *ldx, double *ferr, double *berr, double *work, int *iwork, int *info, size_t)
     * }
     */
    public static MethodHandle dgerfs_$handle() {
        return dgerfs_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dgerfs_(const char *trans, const int *n, const int *nrhs, const double *A, const int *lda, const double *AF, const int *ldaf, const int *ipiv, const double *B, const int *ldb, double *X, const int *ldx, double *ferr, double *berr, double *work, int *iwork, int *info, size_t)
     * }
     */
    public static MemorySegment dgerfs_$address() {
        return dgerfs_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dgerfs_(const char *trans, const int *n, const int *nrhs, const double *A, const int *lda, const double *AF, const int *ldaf, const int *ipiv, const double *B, const int *ldb, double *X, const int *ldx, double *ferr, double *berr, double *work, int *iwork, int *info, size_t)
     * }
     */
    public static void dgerfs_(MemorySegment trans, MemorySegment n, MemorySegment nrhs, MemorySegment A, MemorySegment lda, MemorySegment AF, MemorySegment ldaf, MemorySegment ipiv, MemorySegment B, MemorySegment ldb, MemorySegment X, MemorySegment ldx, MemorySegment ferr, MemorySegment berr, MemorySegment work, MemorySegment iwork, MemorySegment info, long x17) {
        var mh$ = dgerfs_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dgerfs_", trans, n, nrhs, A, lda, AF, ldaf, ipiv, B, ldb, X, ldx, ferr, berr, work, iwork, info, x17);
            }
            mh$.invokeExact(trans, n, nrhs, A, lda, AF, ldaf, ipiv, B, ldb, X, ldx, ferr, berr, work, iwork, info, x17);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sgerfs_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("sgerfs_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void sgerfs_(const char *trans, const int *n, const int *nrhs, const float *A, const int *lda, const float *AF, const int *ldaf, const int *ipiv, const float *B, const int *ldb, float *X, const int *ldx, float *ferr, float *berr, float *work, int *iwork, int *info, size_t)
     * }
     */
    public static FunctionDescriptor sgerfs_$descriptor() {
        return sgerfs_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void sgerfs_(const char *trans, const int *n, const int *nrhs, const float *A, const int *lda, const float *AF, const int *ldaf, const int *ipiv, const float *B, const int *ldb, float *X, const int *ldx, float *ferr, float *berr, float *work, int *iwork, int *info, size_t)
     * }
     */
    public static MethodHandle sgerfs_$handle() {
        return sgerfs_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void sgerfs_(const char *trans, const int *n, const int *nrhs, const float *A, const int *lda, const float *AF, const int *ldaf, const int *ipiv, const float *B, const int *ldb, float *X, const int *ldx, float *ferr, float *berr, float *work, int *iwork, int *info, size_t)
     * }
     */
    public static MemorySegment sgerfs_$address() {
        return sgerfs_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void sgerfs_(const char *trans, const int *n, const int *nrhs, const float *A, const int *lda, const float *AF, const int *ldaf, const int *ipiv, const float *B, const int *ldb, float *X, const int *ldx, float *ferr, float *berr, float *work, int *iwork, int *info, size_t)
     * }
     */
    public static void sgerfs_(MemorySegment trans, MemorySegment n, MemorySegment nrhs, MemorySegment A, MemorySegment lda, MemorySegment AF, MemorySegment ldaf, MemorySegment ipiv, MemorySegment B, MemorySegment ldb, MemorySegment X, MemorySegment ldx, MemorySegment ferr, MemorySegment berr, MemorySegment work, MemorySegment iwork, MemorySegment info, long x17) {
        var mh$ = sgerfs_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sgerfs_", trans, n, nrhs, A, lda, AF, ldaf, ipiv, B, ldb, X, ldx, ferr, berr, work, iwork, info, x17);
            }
            mh$.invokeExact(trans, n, nrhs, A, lda, AF, ldaf, ipiv, B, ldb, X, ldx, ferr, berr, work, iwork, info, x17);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zgerfs_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("zgerfs_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zgerfs_(const char *trans, const int *n, const int *nrhs, const _Complex double *A, const int *lda, const _Complex double *AF, const int *ldaf, const int *ipiv, const _Complex double *B, const int *ldb, _Complex double *X, const int *ldx, double *ferr, double *berr, _Complex double *work, double *rwork, int *info, size_t)
     * }
     */
    public static FunctionDescriptor zgerfs_$descriptor() {
        return zgerfs_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zgerfs_(const char *trans, const int *n, const int *nrhs, const _Complex double *A, const int *lda, const _Complex double *AF, const int *ldaf, const int *ipiv, const _Complex double *B, const int *ldb, _Complex double *X, const int *ldx, double *ferr, double *berr, _Complex double *work, double *rwork, int *info, size_t)
     * }
     */
    public static MethodHandle zgerfs_$handle() {
        return zgerfs_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zgerfs_(const char *trans, const int *n, const int *nrhs, const _Complex double *A, const int *lda, const _Complex double *AF, const int *ldaf, const int *ipiv, const _Complex double *B, const int *ldb, _Complex double *X, const int *ldx, double *ferr, double *berr, _Complex double *work, double *rwork, int *info, size_t)
     * }
     */
    public static MemorySegment zgerfs_$address() {
        return zgerfs_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zgerfs_(const char *trans, const int *n, const int *nrhs, const _Complex double *A, const int *lda, const _Complex double *AF, const int *ldaf, const int *ipiv, const _Complex double *B, const int *ldb, _Complex double *X, const int *ldx, double *ferr, double *berr, _Complex double *work, double *rwork, int *info, size_t)
     * }
     */
    public static void zgerfs_(MemorySegment trans, MemorySegment n, MemorySegment nrhs, MemorySegment A, MemorySegment lda, MemorySegment AF, MemorySegment ldaf, MemorySegment ipiv, MemorySegment B, MemorySegment ldb, MemorySegment X, MemorySegment ldx, MemorySegment ferr, MemorySegment berr, MemorySegment work, MemorySegment rwork, MemorySegment info, long x17) {
        var mh$ = zgerfs_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zgerfs_", trans, n, nrhs, A, lda, AF, ldaf, ipiv, B, ldb, X, ldx, ferr, berr, work, rwork, info, x17);
            }
            mh$.invokeExact(trans, n, nrhs, A, lda, AF, ldaf, ipiv, B, ldb, X, ldx, ferr, berr, work, rwork, info, x17);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cgerfsx_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cgerfsx_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cgerfsx_(const char *trans, const char *equed, const int *n, const int *nrhs, const _Complex float *A, const int *lda, const _Complex float *AF, const int *ldaf, const int *ipiv, const float *R, const float *C, const _Complex float *B, const int *ldb, _Complex float *X, const int *ldx, float *rcond, float *berr, const int *n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, const int *nparams, float *params, _Complex float *work, float *rwork, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor cgerfsx_$descriptor() {
        return cgerfsx_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cgerfsx_(const char *trans, const char *equed, const int *n, const int *nrhs, const _Complex float *A, const int *lda, const _Complex float *AF, const int *ldaf, const int *ipiv, const float *R, const float *C, const _Complex float *B, const int *ldb, _Complex float *X, const int *ldx, float *rcond, float *berr, const int *n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, const int *nparams, float *params, _Complex float *work, float *rwork, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle cgerfsx_$handle() {
        return cgerfsx_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cgerfsx_(const char *trans, const char *equed, const int *n, const int *nrhs, const _Complex float *A, const int *lda, const _Complex float *AF, const int *ldaf, const int *ipiv, const float *R, const float *C, const _Complex float *B, const int *ldb, _Complex float *X, const int *ldx, float *rcond, float *berr, const int *n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, const int *nparams, float *params, _Complex float *work, float *rwork, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment cgerfsx_$address() {
        return cgerfsx_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cgerfsx_(const char *trans, const char *equed, const int *n, const int *nrhs, const _Complex float *A, const int *lda, const _Complex float *AF, const int *ldaf, const int *ipiv, const float *R, const float *C, const _Complex float *B, const int *ldb, _Complex float *X, const int *ldx, float *rcond, float *berr, const int *n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, const int *nparams, float *params, _Complex float *work, float *rwork, int *info, size_t, size_t)
     * }
     */
    public static void cgerfsx_(MemorySegment trans, MemorySegment equed, MemorySegment n, MemorySegment nrhs, MemorySegment A, MemorySegment lda, MemorySegment AF, MemorySegment ldaf, MemorySegment ipiv, MemorySegment R, MemorySegment C, MemorySegment B, MemorySegment ldb, MemorySegment X, MemorySegment ldx, MemorySegment rcond, MemorySegment berr, MemorySegment n_err_bnds, MemorySegment err_bnds_norm, MemorySegment err_bnds_comp, MemorySegment nparams, MemorySegment params, MemorySegment work, MemorySegment rwork, MemorySegment info, long x25, long x26) {
        var mh$ = cgerfsx_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cgerfsx_", trans, equed, n, nrhs, A, lda, AF, ldaf, ipiv, R, C, B, ldb, X, ldx, rcond, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params, work, rwork, info, x25, x26);
            }
            mh$.invokeExact(trans, equed, n, nrhs, A, lda, AF, ldaf, ipiv, R, C, B, ldb, X, ldx, rcond, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params, work, rwork, info, x25, x26);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dgerfsx_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("dgerfsx_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dgerfsx_(const char *trans, const char *equed, const int *n, const int *nrhs, const double *A, const int *lda, const double *AF, const int *ldaf, const int *ipiv, const double *R, const double *C, const double *B, const int *ldb, double *X, const int *ldx, double *rcond, double *berr, const int *n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, const int *nparams, double *params, double *work, int *iwork, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor dgerfsx_$descriptor() {
        return dgerfsx_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dgerfsx_(const char *trans, const char *equed, const int *n, const int *nrhs, const double *A, const int *lda, const double *AF, const int *ldaf, const int *ipiv, const double *R, const double *C, const double *B, const int *ldb, double *X, const int *ldx, double *rcond, double *berr, const int *n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, const int *nparams, double *params, double *work, int *iwork, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle dgerfsx_$handle() {
        return dgerfsx_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dgerfsx_(const char *trans, const char *equed, const int *n, const int *nrhs, const double *A, const int *lda, const double *AF, const int *ldaf, const int *ipiv, const double *R, const double *C, const double *B, const int *ldb, double *X, const int *ldx, double *rcond, double *berr, const int *n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, const int *nparams, double *params, double *work, int *iwork, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment dgerfsx_$address() {
        return dgerfsx_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dgerfsx_(const char *trans, const char *equed, const int *n, const int *nrhs, const double *A, const int *lda, const double *AF, const int *ldaf, const int *ipiv, const double *R, const double *C, const double *B, const int *ldb, double *X, const int *ldx, double *rcond, double *berr, const int *n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, const int *nparams, double *params, double *work, int *iwork, int *info, size_t, size_t)
     * }
     */
    public static void dgerfsx_(MemorySegment trans, MemorySegment equed, MemorySegment n, MemorySegment nrhs, MemorySegment A, MemorySegment lda, MemorySegment AF, MemorySegment ldaf, MemorySegment ipiv, MemorySegment R, MemorySegment C, MemorySegment B, MemorySegment ldb, MemorySegment X, MemorySegment ldx, MemorySegment rcond, MemorySegment berr, MemorySegment n_err_bnds, MemorySegment err_bnds_norm, MemorySegment err_bnds_comp, MemorySegment nparams, MemorySegment params, MemorySegment work, MemorySegment iwork, MemorySegment info, long x25, long x26) {
        var mh$ = dgerfsx_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dgerfsx_", trans, equed, n, nrhs, A, lda, AF, ldaf, ipiv, R, C, B, ldb, X, ldx, rcond, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params, work, iwork, info, x25, x26);
            }
            mh$.invokeExact(trans, equed, n, nrhs, A, lda, AF, ldaf, ipiv, R, C, B, ldb, X, ldx, rcond, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params, work, iwork, info, x25, x26);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sgerfsx_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("sgerfsx_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void sgerfsx_(const char *trans, const char *equed, const int *n, const int *nrhs, const float *A, const int *lda, const float *AF, const int *ldaf, const int *ipiv, const float *R, const float *C, const float *B, const int *ldb, float *X, const int *ldx, float *rcond, float *berr, const int *n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, const int *nparams, float *params, float *work, int *iwork, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor sgerfsx_$descriptor() {
        return sgerfsx_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void sgerfsx_(const char *trans, const char *equed, const int *n, const int *nrhs, const float *A, const int *lda, const float *AF, const int *ldaf, const int *ipiv, const float *R, const float *C, const float *B, const int *ldb, float *X, const int *ldx, float *rcond, float *berr, const int *n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, const int *nparams, float *params, float *work, int *iwork, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle sgerfsx_$handle() {
        return sgerfsx_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void sgerfsx_(const char *trans, const char *equed, const int *n, const int *nrhs, const float *A, const int *lda, const float *AF, const int *ldaf, const int *ipiv, const float *R, const float *C, const float *B, const int *ldb, float *X, const int *ldx, float *rcond, float *berr, const int *n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, const int *nparams, float *params, float *work, int *iwork, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment sgerfsx_$address() {
        return sgerfsx_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void sgerfsx_(const char *trans, const char *equed, const int *n, const int *nrhs, const float *A, const int *lda, const float *AF, const int *ldaf, const int *ipiv, const float *R, const float *C, const float *B, const int *ldb, float *X, const int *ldx, float *rcond, float *berr, const int *n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, const int *nparams, float *params, float *work, int *iwork, int *info, size_t, size_t)
     * }
     */
    public static void sgerfsx_(MemorySegment trans, MemorySegment equed, MemorySegment n, MemorySegment nrhs, MemorySegment A, MemorySegment lda, MemorySegment AF, MemorySegment ldaf, MemorySegment ipiv, MemorySegment R, MemorySegment C, MemorySegment B, MemorySegment ldb, MemorySegment X, MemorySegment ldx, MemorySegment rcond, MemorySegment berr, MemorySegment n_err_bnds, MemorySegment err_bnds_norm, MemorySegment err_bnds_comp, MemorySegment nparams, MemorySegment params, MemorySegment work, MemorySegment iwork, MemorySegment info, long x25, long x26) {
        var mh$ = sgerfsx_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sgerfsx_", trans, equed, n, nrhs, A, lda, AF, ldaf, ipiv, R, C, B, ldb, X, ldx, rcond, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params, work, iwork, info, x25, x26);
            }
            mh$.invokeExact(trans, equed, n, nrhs, A, lda, AF, ldaf, ipiv, R, C, B, ldb, X, ldx, rcond, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params, work, iwork, info, x25, x26);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zgerfsx_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("zgerfsx_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zgerfsx_(const char *trans, const char *equed, const int *n, const int *nrhs, const _Complex double *A, const int *lda, const _Complex double *AF, const int *ldaf, const int *ipiv, const double *R, const double *C, const _Complex double *B, const int *ldb, _Complex double *X, const int *ldx, double *rcond, double *berr, const int *n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, const int *nparams, double *params, _Complex double *work, double *rwork, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor zgerfsx_$descriptor() {
        return zgerfsx_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zgerfsx_(const char *trans, const char *equed, const int *n, const int *nrhs, const _Complex double *A, const int *lda, const _Complex double *AF, const int *ldaf, const int *ipiv, const double *R, const double *C, const _Complex double *B, const int *ldb, _Complex double *X, const int *ldx, double *rcond, double *berr, const int *n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, const int *nparams, double *params, _Complex double *work, double *rwork, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle zgerfsx_$handle() {
        return zgerfsx_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zgerfsx_(const char *trans, const char *equed, const int *n, const int *nrhs, const _Complex double *A, const int *lda, const _Complex double *AF, const int *ldaf, const int *ipiv, const double *R, const double *C, const _Complex double *B, const int *ldb, _Complex double *X, const int *ldx, double *rcond, double *berr, const int *n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, const int *nparams, double *params, _Complex double *work, double *rwork, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment zgerfsx_$address() {
        return zgerfsx_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zgerfsx_(const char *trans, const char *equed, const int *n, const int *nrhs, const _Complex double *A, const int *lda, const _Complex double *AF, const int *ldaf, const int *ipiv, const double *R, const double *C, const _Complex double *B, const int *ldb, _Complex double *X, const int *ldx, double *rcond, double *berr, const int *n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, const int *nparams, double *params, _Complex double *work, double *rwork, int *info, size_t, size_t)
     * }
     */
    public static void zgerfsx_(MemorySegment trans, MemorySegment equed, MemorySegment n, MemorySegment nrhs, MemorySegment A, MemorySegment lda, MemorySegment AF, MemorySegment ldaf, MemorySegment ipiv, MemorySegment R, MemorySegment C, MemorySegment B, MemorySegment ldb, MemorySegment X, MemorySegment ldx, MemorySegment rcond, MemorySegment berr, MemorySegment n_err_bnds, MemorySegment err_bnds_norm, MemorySegment err_bnds_comp, MemorySegment nparams, MemorySegment params, MemorySegment work, MemorySegment rwork, MemorySegment info, long x25, long x26) {
        var mh$ = zgerfsx_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zgerfsx_", trans, equed, n, nrhs, A, lda, AF, ldaf, ipiv, R, C, B, ldb, X, ldx, rcond, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params, work, rwork, info, x25, x26);
            }
            mh$.invokeExact(trans, equed, n, nrhs, A, lda, AF, ldaf, ipiv, R, C, B, ldb, X, ldx, rcond, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params, work, rwork, info, x25, x26);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cgerq2_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cgerq2_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cgerq2_(const int *m, const int *n, _Complex float *A, const int *lda, _Complex float *tau, _Complex float *work, int *info)
     * }
     */
    public static FunctionDescriptor cgerq2_$descriptor() {
        return cgerq2_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cgerq2_(const int *m, const int *n, _Complex float *A, const int *lda, _Complex float *tau, _Complex float *work, int *info)
     * }
     */
    public static MethodHandle cgerq2_$handle() {
        return cgerq2_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cgerq2_(const int *m, const int *n, _Complex float *A, const int *lda, _Complex float *tau, _Complex float *work, int *info)
     * }
     */
    public static MemorySegment cgerq2_$address() {
        return cgerq2_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cgerq2_(const int *m, const int *n, _Complex float *A, const int *lda, _Complex float *tau, _Complex float *work, int *info)
     * }
     */
    public static void cgerq2_(MemorySegment m, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment tau, MemorySegment work, MemorySegment info) {
        var mh$ = cgerq2_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cgerq2_", m, n, A, lda, tau, work, info);
            }
            mh$.invokeExact(m, n, A, lda, tau, work, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dgerq2_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("dgerq2_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dgerq2_(const int *m, const int *n, double *A, const int *lda, double *tau, double *work, int *info)
     * }
     */
    public static FunctionDescriptor dgerq2_$descriptor() {
        return dgerq2_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dgerq2_(const int *m, const int *n, double *A, const int *lda, double *tau, double *work, int *info)
     * }
     */
    public static MethodHandle dgerq2_$handle() {
        return dgerq2_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dgerq2_(const int *m, const int *n, double *A, const int *lda, double *tau, double *work, int *info)
     * }
     */
    public static MemorySegment dgerq2_$address() {
        return dgerq2_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dgerq2_(const int *m, const int *n, double *A, const int *lda, double *tau, double *work, int *info)
     * }
     */
    public static void dgerq2_(MemorySegment m, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment tau, MemorySegment work, MemorySegment info) {
        var mh$ = dgerq2_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dgerq2_", m, n, A, lda, tau, work, info);
            }
            mh$.invokeExact(m, n, A, lda, tau, work, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sgerq2_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("sgerq2_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void sgerq2_(const int *m, const int *n, float *A, const int *lda, float *tau, float *work, int *info)
     * }
     */
    public static FunctionDescriptor sgerq2_$descriptor() {
        return sgerq2_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void sgerq2_(const int *m, const int *n, float *A, const int *lda, float *tau, float *work, int *info)
     * }
     */
    public static MethodHandle sgerq2_$handle() {
        return sgerq2_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void sgerq2_(const int *m, const int *n, float *A, const int *lda, float *tau, float *work, int *info)
     * }
     */
    public static MemorySegment sgerq2_$address() {
        return sgerq2_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void sgerq2_(const int *m, const int *n, float *A, const int *lda, float *tau, float *work, int *info)
     * }
     */
    public static void sgerq2_(MemorySegment m, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment tau, MemorySegment work, MemorySegment info) {
        var mh$ = sgerq2_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sgerq2_", m, n, A, lda, tau, work, info);
            }
            mh$.invokeExact(m, n, A, lda, tau, work, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zgerq2_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("zgerq2_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zgerq2_(const int *m, const int *n, _Complex double *A, const int *lda, _Complex double *tau, _Complex double *work, int *info)
     * }
     */
    public static FunctionDescriptor zgerq2_$descriptor() {
        return zgerq2_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zgerq2_(const int *m, const int *n, _Complex double *A, const int *lda, _Complex double *tau, _Complex double *work, int *info)
     * }
     */
    public static MethodHandle zgerq2_$handle() {
        return zgerq2_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zgerq2_(const int *m, const int *n, _Complex double *A, const int *lda, _Complex double *tau, _Complex double *work, int *info)
     * }
     */
    public static MemorySegment zgerq2_$address() {
        return zgerq2_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zgerq2_(const int *m, const int *n, _Complex double *A, const int *lda, _Complex double *tau, _Complex double *work, int *info)
     * }
     */
    public static void zgerq2_(MemorySegment m, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment tau, MemorySegment work, MemorySegment info) {
        var mh$ = zgerq2_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zgerq2_", m, n, A, lda, tau, work, info);
            }
            mh$.invokeExact(m, n, A, lda, tau, work, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cgerqf_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cgerqf_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cgerqf_(const int *m, const int *n, _Complex float *A, const int *lda, _Complex float *tau, _Complex float *work, const int *lwork, int *info)
     * }
     */
    public static FunctionDescriptor cgerqf_$descriptor() {
        return cgerqf_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cgerqf_(const int *m, const int *n, _Complex float *A, const int *lda, _Complex float *tau, _Complex float *work, const int *lwork, int *info)
     * }
     */
    public static MethodHandle cgerqf_$handle() {
        return cgerqf_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cgerqf_(const int *m, const int *n, _Complex float *A, const int *lda, _Complex float *tau, _Complex float *work, const int *lwork, int *info)
     * }
     */
    public static MemorySegment cgerqf_$address() {
        return cgerqf_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cgerqf_(const int *m, const int *n, _Complex float *A, const int *lda, _Complex float *tau, _Complex float *work, const int *lwork, int *info)
     * }
     */
    public static void cgerqf_(MemorySegment m, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment tau, MemorySegment work, MemorySegment lwork, MemorySegment info) {
        var mh$ = cgerqf_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cgerqf_", m, n, A, lda, tau, work, lwork, info);
            }
            mh$.invokeExact(m, n, A, lda, tau, work, lwork, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dgerqf_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("dgerqf_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dgerqf_(const int *m, const int *n, double *A, const int *lda, double *tau, double *work, const int *lwork, int *info)
     * }
     */
    public static FunctionDescriptor dgerqf_$descriptor() {
        return dgerqf_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dgerqf_(const int *m, const int *n, double *A, const int *lda, double *tau, double *work, const int *lwork, int *info)
     * }
     */
    public static MethodHandle dgerqf_$handle() {
        return dgerqf_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dgerqf_(const int *m, const int *n, double *A, const int *lda, double *tau, double *work, const int *lwork, int *info)
     * }
     */
    public static MemorySegment dgerqf_$address() {
        return dgerqf_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dgerqf_(const int *m, const int *n, double *A, const int *lda, double *tau, double *work, const int *lwork, int *info)
     * }
     */
    public static void dgerqf_(MemorySegment m, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment tau, MemorySegment work, MemorySegment lwork, MemorySegment info) {
        var mh$ = dgerqf_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dgerqf_", m, n, A, lda, tau, work, lwork, info);
            }
            mh$.invokeExact(m, n, A, lda, tau, work, lwork, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sgerqf_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("sgerqf_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void sgerqf_(const int *m, const int *n, float *A, const int *lda, float *tau, float *work, const int *lwork, int *info)
     * }
     */
    public static FunctionDescriptor sgerqf_$descriptor() {
        return sgerqf_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void sgerqf_(const int *m, const int *n, float *A, const int *lda, float *tau, float *work, const int *lwork, int *info)
     * }
     */
    public static MethodHandle sgerqf_$handle() {
        return sgerqf_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void sgerqf_(const int *m, const int *n, float *A, const int *lda, float *tau, float *work, const int *lwork, int *info)
     * }
     */
    public static MemorySegment sgerqf_$address() {
        return sgerqf_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void sgerqf_(const int *m, const int *n, float *A, const int *lda, float *tau, float *work, const int *lwork, int *info)
     * }
     */
    public static void sgerqf_(MemorySegment m, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment tau, MemorySegment work, MemorySegment lwork, MemorySegment info) {
        var mh$ = sgerqf_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sgerqf_", m, n, A, lda, tau, work, lwork, info);
            }
            mh$.invokeExact(m, n, A, lda, tau, work, lwork, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zgerqf_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("zgerqf_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zgerqf_(const int *m, const int *n, _Complex double *A, const int *lda, _Complex double *tau, _Complex double *work, const int *lwork, int *info)
     * }
     */
    public static FunctionDescriptor zgerqf_$descriptor() {
        return zgerqf_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zgerqf_(const int *m, const int *n, _Complex double *A, const int *lda, _Complex double *tau, _Complex double *work, const int *lwork, int *info)
     * }
     */
    public static MethodHandle zgerqf_$handle() {
        return zgerqf_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zgerqf_(const int *m, const int *n, _Complex double *A, const int *lda, _Complex double *tau, _Complex double *work, const int *lwork, int *info)
     * }
     */
    public static MemorySegment zgerqf_$address() {
        return zgerqf_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zgerqf_(const int *m, const int *n, _Complex double *A, const int *lda, _Complex double *tau, _Complex double *work, const int *lwork, int *info)
     * }
     */
    public static void zgerqf_(MemorySegment m, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment tau, MemorySegment work, MemorySegment lwork, MemorySegment info) {
        var mh$ = zgerqf_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zgerqf_", m, n, A, lda, tau, work, lwork, info);
            }
            mh$.invokeExact(m, n, A, lda, tau, work, lwork, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cgesdd_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cgesdd_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cgesdd_(const char *jobz, const int *m, const int *n, _Complex float *A, const int *lda, float *S, _Complex float *U, const int *ldu, _Complex float *VT, const int *ldvt, _Complex float *work, const int *lwork, float *rwork, int *iwork, int *info, size_t)
     * }
     */
    public static FunctionDescriptor cgesdd_$descriptor() {
        return cgesdd_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cgesdd_(const char *jobz, const int *m, const int *n, _Complex float *A, const int *lda, float *S, _Complex float *U, const int *ldu, _Complex float *VT, const int *ldvt, _Complex float *work, const int *lwork, float *rwork, int *iwork, int *info, size_t)
     * }
     */
    public static MethodHandle cgesdd_$handle() {
        return cgesdd_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cgesdd_(const char *jobz, const int *m, const int *n, _Complex float *A, const int *lda, float *S, _Complex float *U, const int *ldu, _Complex float *VT, const int *ldvt, _Complex float *work, const int *lwork, float *rwork, int *iwork, int *info, size_t)
     * }
     */
    public static MemorySegment cgesdd_$address() {
        return cgesdd_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cgesdd_(const char *jobz, const int *m, const int *n, _Complex float *A, const int *lda, float *S, _Complex float *U, const int *ldu, _Complex float *VT, const int *ldvt, _Complex float *work, const int *lwork, float *rwork, int *iwork, int *info, size_t)
     * }
     */
    public static void cgesdd_(MemorySegment jobz, MemorySegment m, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment S, MemorySegment U, MemorySegment ldu, MemorySegment VT, MemorySegment ldvt, MemorySegment work, MemorySegment lwork, MemorySegment rwork, MemorySegment iwork, MemorySegment info, long x15) {
        var mh$ = cgesdd_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cgesdd_", jobz, m, n, A, lda, S, U, ldu, VT, ldvt, work, lwork, rwork, iwork, info, x15);
            }
            mh$.invokeExact(jobz, m, n, A, lda, S, U, ldu, VT, ldvt, work, lwork, rwork, iwork, info, x15);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dgesdd_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("dgesdd_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dgesdd_(const char *jobz, const int *m, const int *n, double *A, const int *lda, double *S, double *U, const int *ldu, double *VT, const int *ldvt, double *work, const int *lwork, int *iwork, int *info, size_t)
     * }
     */
    public static FunctionDescriptor dgesdd_$descriptor() {
        return dgesdd_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dgesdd_(const char *jobz, const int *m, const int *n, double *A, const int *lda, double *S, double *U, const int *ldu, double *VT, const int *ldvt, double *work, const int *lwork, int *iwork, int *info, size_t)
     * }
     */
    public static MethodHandle dgesdd_$handle() {
        return dgesdd_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dgesdd_(const char *jobz, const int *m, const int *n, double *A, const int *lda, double *S, double *U, const int *ldu, double *VT, const int *ldvt, double *work, const int *lwork, int *iwork, int *info, size_t)
     * }
     */
    public static MemorySegment dgesdd_$address() {
        return dgesdd_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dgesdd_(const char *jobz, const int *m, const int *n, double *A, const int *lda, double *S, double *U, const int *ldu, double *VT, const int *ldvt, double *work, const int *lwork, int *iwork, int *info, size_t)
     * }
     */
    public static void dgesdd_(MemorySegment jobz, MemorySegment m, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment S, MemorySegment U, MemorySegment ldu, MemorySegment VT, MemorySegment ldvt, MemorySegment work, MemorySegment lwork, MemorySegment iwork, MemorySegment info, long x14) {
        var mh$ = dgesdd_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dgesdd_", jobz, m, n, A, lda, S, U, ldu, VT, ldvt, work, lwork, iwork, info, x14);
            }
            mh$.invokeExact(jobz, m, n, A, lda, S, U, ldu, VT, ldvt, work, lwork, iwork, info, x14);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sgesdd_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("sgesdd_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void sgesdd_(const char *jobz, const int *m, const int *n, float *A, const int *lda, float *S, float *U, const int *ldu, float *VT, const int *ldvt, float *work, const int *lwork, int *iwork, int *info, size_t)
     * }
     */
    public static FunctionDescriptor sgesdd_$descriptor() {
        return sgesdd_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void sgesdd_(const char *jobz, const int *m, const int *n, float *A, const int *lda, float *S, float *U, const int *ldu, float *VT, const int *ldvt, float *work, const int *lwork, int *iwork, int *info, size_t)
     * }
     */
    public static MethodHandle sgesdd_$handle() {
        return sgesdd_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void sgesdd_(const char *jobz, const int *m, const int *n, float *A, const int *lda, float *S, float *U, const int *ldu, float *VT, const int *ldvt, float *work, const int *lwork, int *iwork, int *info, size_t)
     * }
     */
    public static MemorySegment sgesdd_$address() {
        return sgesdd_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void sgesdd_(const char *jobz, const int *m, const int *n, float *A, const int *lda, float *S, float *U, const int *ldu, float *VT, const int *ldvt, float *work, const int *lwork, int *iwork, int *info, size_t)
     * }
     */
    public static void sgesdd_(MemorySegment jobz, MemorySegment m, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment S, MemorySegment U, MemorySegment ldu, MemorySegment VT, MemorySegment ldvt, MemorySegment work, MemorySegment lwork, MemorySegment iwork, MemorySegment info, long x14) {
        var mh$ = sgesdd_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sgesdd_", jobz, m, n, A, lda, S, U, ldu, VT, ldvt, work, lwork, iwork, info, x14);
            }
            mh$.invokeExact(jobz, m, n, A, lda, S, U, ldu, VT, ldvt, work, lwork, iwork, info, x14);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zgesdd_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("zgesdd_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zgesdd_(const char *jobz, const int *m, const int *n, _Complex double *A, const int *lda, double *S, _Complex double *U, const int *ldu, _Complex double *VT, const int *ldvt, _Complex double *work, const int *lwork, double *rwork, int *iwork, int *info, size_t)
     * }
     */
    public static FunctionDescriptor zgesdd_$descriptor() {
        return zgesdd_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zgesdd_(const char *jobz, const int *m, const int *n, _Complex double *A, const int *lda, double *S, _Complex double *U, const int *ldu, _Complex double *VT, const int *ldvt, _Complex double *work, const int *lwork, double *rwork, int *iwork, int *info, size_t)
     * }
     */
    public static MethodHandle zgesdd_$handle() {
        return zgesdd_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zgesdd_(const char *jobz, const int *m, const int *n, _Complex double *A, const int *lda, double *S, _Complex double *U, const int *ldu, _Complex double *VT, const int *ldvt, _Complex double *work, const int *lwork, double *rwork, int *iwork, int *info, size_t)
     * }
     */
    public static MemorySegment zgesdd_$address() {
        return zgesdd_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zgesdd_(const char *jobz, const int *m, const int *n, _Complex double *A, const int *lda, double *S, _Complex double *U, const int *ldu, _Complex double *VT, const int *ldvt, _Complex double *work, const int *lwork, double *rwork, int *iwork, int *info, size_t)
     * }
     */
    public static void zgesdd_(MemorySegment jobz, MemorySegment m, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment S, MemorySegment U, MemorySegment ldu, MemorySegment VT, MemorySegment ldvt, MemorySegment work, MemorySegment lwork, MemorySegment rwork, MemorySegment iwork, MemorySegment info, long x15) {
        var mh$ = zgesdd_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zgesdd_", jobz, m, n, A, lda, S, U, ldu, VT, ldvt, work, lwork, rwork, iwork, info, x15);
            }
            mh$.invokeExact(jobz, m, n, A, lda, S, U, ldu, VT, ldvt, work, lwork, rwork, iwork, info, x15);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cgesv_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cgesv_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cgesv_(const int *n, const int *nrhs, _Complex float *A, const int *lda, int *ipiv, _Complex float *B, const int *ldb, int *info)
     * }
     */
    public static FunctionDescriptor cgesv_$descriptor() {
        return cgesv_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cgesv_(const int *n, const int *nrhs, _Complex float *A, const int *lda, int *ipiv, _Complex float *B, const int *ldb, int *info)
     * }
     */
    public static MethodHandle cgesv_$handle() {
        return cgesv_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cgesv_(const int *n, const int *nrhs, _Complex float *A, const int *lda, int *ipiv, _Complex float *B, const int *ldb, int *info)
     * }
     */
    public static MemorySegment cgesv_$address() {
        return cgesv_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cgesv_(const int *n, const int *nrhs, _Complex float *A, const int *lda, int *ipiv, _Complex float *B, const int *ldb, int *info)
     * }
     */
    public static void cgesv_(MemorySegment n, MemorySegment nrhs, MemorySegment A, MemorySegment lda, MemorySegment ipiv, MemorySegment B, MemorySegment ldb, MemorySegment info) {
        var mh$ = cgesv_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cgesv_", n, nrhs, A, lda, ipiv, B, ldb, info);
            }
            mh$.invokeExact(n, nrhs, A, lda, ipiv, B, ldb, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dgesv_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("dgesv_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dgesv_(const int *n, const int *nrhs, double *A, const int *lda, int *ipiv, double *B, const int *ldb, int *info)
     * }
     */
    public static FunctionDescriptor dgesv_$descriptor() {
        return dgesv_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dgesv_(const int *n, const int *nrhs, double *A, const int *lda, int *ipiv, double *B, const int *ldb, int *info)
     * }
     */
    public static MethodHandle dgesv_$handle() {
        return dgesv_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dgesv_(const int *n, const int *nrhs, double *A, const int *lda, int *ipiv, double *B, const int *ldb, int *info)
     * }
     */
    public static MemorySegment dgesv_$address() {
        return dgesv_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dgesv_(const int *n, const int *nrhs, double *A, const int *lda, int *ipiv, double *B, const int *ldb, int *info)
     * }
     */
    public static void dgesv_(MemorySegment n, MemorySegment nrhs, MemorySegment A, MemorySegment lda, MemorySegment ipiv, MemorySegment B, MemorySegment ldb, MemorySegment info) {
        var mh$ = dgesv_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dgesv_", n, nrhs, A, lda, ipiv, B, ldb, info);
            }
            mh$.invokeExact(n, nrhs, A, lda, ipiv, B, ldb, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sgesv_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("sgesv_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void sgesv_(const int *n, const int *nrhs, float *A, const int *lda, int *ipiv, float *B, const int *ldb, int *info)
     * }
     */
    public static FunctionDescriptor sgesv_$descriptor() {
        return sgesv_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void sgesv_(const int *n, const int *nrhs, float *A, const int *lda, int *ipiv, float *B, const int *ldb, int *info)
     * }
     */
    public static MethodHandle sgesv_$handle() {
        return sgesv_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void sgesv_(const int *n, const int *nrhs, float *A, const int *lda, int *ipiv, float *B, const int *ldb, int *info)
     * }
     */
    public static MemorySegment sgesv_$address() {
        return sgesv_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void sgesv_(const int *n, const int *nrhs, float *A, const int *lda, int *ipiv, float *B, const int *ldb, int *info)
     * }
     */
    public static void sgesv_(MemorySegment n, MemorySegment nrhs, MemorySegment A, MemorySegment lda, MemorySegment ipiv, MemorySegment B, MemorySegment ldb, MemorySegment info) {
        var mh$ = sgesv_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sgesv_", n, nrhs, A, lda, ipiv, B, ldb, info);
            }
            mh$.invokeExact(n, nrhs, A, lda, ipiv, B, ldb, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zgesv_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("zgesv_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zgesv_(const int *n, const int *nrhs, _Complex double *A, const int *lda, int *ipiv, _Complex double *B, const int *ldb, int *info)
     * }
     */
    public static FunctionDescriptor zgesv_$descriptor() {
        return zgesv_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zgesv_(const int *n, const int *nrhs, _Complex double *A, const int *lda, int *ipiv, _Complex double *B, const int *ldb, int *info)
     * }
     */
    public static MethodHandle zgesv_$handle() {
        return zgesv_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zgesv_(const int *n, const int *nrhs, _Complex double *A, const int *lda, int *ipiv, _Complex double *B, const int *ldb, int *info)
     * }
     */
    public static MemorySegment zgesv_$address() {
        return zgesv_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zgesv_(const int *n, const int *nrhs, _Complex double *A, const int *lda, int *ipiv, _Complex double *B, const int *ldb, int *info)
     * }
     */
    public static void zgesv_(MemorySegment n, MemorySegment nrhs, MemorySegment A, MemorySegment lda, MemorySegment ipiv, MemorySegment B, MemorySegment ldb, MemorySegment info) {
        var mh$ = zgesv_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zgesv_", n, nrhs, A, lda, ipiv, B, ldb, info);
            }
            mh$.invokeExact(n, nrhs, A, lda, ipiv, B, ldb, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dsgesv_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("dsgesv_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dsgesv_(const int *n, const int *nrhs, double *A, const int *lda, int *ipiv, const double *B, const int *ldb, double *X, const int *ldx, double *work, float *swork, int *iter, int *info)
     * }
     */
    public static FunctionDescriptor dsgesv_$descriptor() {
        return dsgesv_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dsgesv_(const int *n, const int *nrhs, double *A, const int *lda, int *ipiv, const double *B, const int *ldb, double *X, const int *ldx, double *work, float *swork, int *iter, int *info)
     * }
     */
    public static MethodHandle dsgesv_$handle() {
        return dsgesv_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dsgesv_(const int *n, const int *nrhs, double *A, const int *lda, int *ipiv, const double *B, const int *ldb, double *X, const int *ldx, double *work, float *swork, int *iter, int *info)
     * }
     */
    public static MemorySegment dsgesv_$address() {
        return dsgesv_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dsgesv_(const int *n, const int *nrhs, double *A, const int *lda, int *ipiv, const double *B, const int *ldb, double *X, const int *ldx, double *work, float *swork, int *iter, int *info)
     * }
     */
    public static void dsgesv_(MemorySegment n, MemorySegment nrhs, MemorySegment A, MemorySegment lda, MemorySegment ipiv, MemorySegment B, MemorySegment ldb, MemorySegment X, MemorySegment ldx, MemorySegment work, MemorySegment swork, MemorySegment iter, MemorySegment info) {
        var mh$ = dsgesv_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dsgesv_", n, nrhs, A, lda, ipiv, B, ldb, X, ldx, work, swork, iter, info);
            }
            mh$.invokeExact(n, nrhs, A, lda, ipiv, B, ldb, X, ldx, work, swork, iter, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zcgesv_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("zcgesv_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zcgesv_(const int *n, const int *nrhs, _Complex double *A, const int *lda, int *ipiv, const _Complex double *B, const int *ldb, _Complex double *X, const int *ldx, _Complex double *work, _Complex float *swork, double *rwork, int *iter, int *info)
     * }
     */
    public static FunctionDescriptor zcgesv_$descriptor() {
        return zcgesv_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zcgesv_(const int *n, const int *nrhs, _Complex double *A, const int *lda, int *ipiv, const _Complex double *B, const int *ldb, _Complex double *X, const int *ldx, _Complex double *work, _Complex float *swork, double *rwork, int *iter, int *info)
     * }
     */
    public static MethodHandle zcgesv_$handle() {
        return zcgesv_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zcgesv_(const int *n, const int *nrhs, _Complex double *A, const int *lda, int *ipiv, const _Complex double *B, const int *ldb, _Complex double *X, const int *ldx, _Complex double *work, _Complex float *swork, double *rwork, int *iter, int *info)
     * }
     */
    public static MemorySegment zcgesv_$address() {
        return zcgesv_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zcgesv_(const int *n, const int *nrhs, _Complex double *A, const int *lda, int *ipiv, const _Complex double *B, const int *ldb, _Complex double *X, const int *ldx, _Complex double *work, _Complex float *swork, double *rwork, int *iter, int *info)
     * }
     */
    public static void zcgesv_(MemorySegment n, MemorySegment nrhs, MemorySegment A, MemorySegment lda, MemorySegment ipiv, MemorySegment B, MemorySegment ldb, MemorySegment X, MemorySegment ldx, MemorySegment work, MemorySegment swork, MemorySegment rwork, MemorySegment iter, MemorySegment info) {
        var mh$ = zcgesv_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zcgesv_", n, nrhs, A, lda, ipiv, B, ldb, X, ldx, work, swork, rwork, iter, info);
            }
            mh$.invokeExact(n, nrhs, A, lda, ipiv, B, ldb, X, ldx, work, swork, rwork, iter, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cgesvd_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cgesvd_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cgesvd_(const char *jobu, const char *jobvt, const int *m, const int *n, _Complex float *A, const int *lda, float *S, _Complex float *U, const int *ldu, _Complex float *VT, const int *ldvt, _Complex float *work, const int *lwork, float *rwork, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor cgesvd_$descriptor() {
        return cgesvd_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cgesvd_(const char *jobu, const char *jobvt, const int *m, const int *n, _Complex float *A, const int *lda, float *S, _Complex float *U, const int *ldu, _Complex float *VT, const int *ldvt, _Complex float *work, const int *lwork, float *rwork, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle cgesvd_$handle() {
        return cgesvd_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cgesvd_(const char *jobu, const char *jobvt, const int *m, const int *n, _Complex float *A, const int *lda, float *S, _Complex float *U, const int *ldu, _Complex float *VT, const int *ldvt, _Complex float *work, const int *lwork, float *rwork, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment cgesvd_$address() {
        return cgesvd_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cgesvd_(const char *jobu, const char *jobvt, const int *m, const int *n, _Complex float *A, const int *lda, float *S, _Complex float *U, const int *ldu, _Complex float *VT, const int *ldvt, _Complex float *work, const int *lwork, float *rwork, int *info, size_t, size_t)
     * }
     */
    public static void cgesvd_(MemorySegment jobu, MemorySegment jobvt, MemorySegment m, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment S, MemorySegment U, MemorySegment ldu, MemorySegment VT, MemorySegment ldvt, MemorySegment work, MemorySegment lwork, MemorySegment rwork, MemorySegment info, long x15, long x16) {
        var mh$ = cgesvd_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cgesvd_", jobu, jobvt, m, n, A, lda, S, U, ldu, VT, ldvt, work, lwork, rwork, info, x15, x16);
            }
            mh$.invokeExact(jobu, jobvt, m, n, A, lda, S, U, ldu, VT, ldvt, work, lwork, rwork, info, x15, x16);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dgesvd_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("dgesvd_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dgesvd_(const char *jobu, const char *jobvt, const int *m, const int *n, double *A, const int *lda, double *S, double *U, const int *ldu, double *VT, const int *ldvt, double *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor dgesvd_$descriptor() {
        return dgesvd_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dgesvd_(const char *jobu, const char *jobvt, const int *m, const int *n, double *A, const int *lda, double *S, double *U, const int *ldu, double *VT, const int *ldvt, double *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle dgesvd_$handle() {
        return dgesvd_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dgesvd_(const char *jobu, const char *jobvt, const int *m, const int *n, double *A, const int *lda, double *S, double *U, const int *ldu, double *VT, const int *ldvt, double *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment dgesvd_$address() {
        return dgesvd_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dgesvd_(const char *jobu, const char *jobvt, const int *m, const int *n, double *A, const int *lda, double *S, double *U, const int *ldu, double *VT, const int *ldvt, double *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static void dgesvd_(MemorySegment jobu, MemorySegment jobvt, MemorySegment m, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment S, MemorySegment U, MemorySegment ldu, MemorySegment VT, MemorySegment ldvt, MemorySegment work, MemorySegment lwork, MemorySegment info, long x14, long x15) {
        var mh$ = dgesvd_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dgesvd_", jobu, jobvt, m, n, A, lda, S, U, ldu, VT, ldvt, work, lwork, info, x14, x15);
            }
            mh$.invokeExact(jobu, jobvt, m, n, A, lda, S, U, ldu, VT, ldvt, work, lwork, info, x14, x15);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sgesvd_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("sgesvd_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void sgesvd_(const char *jobu, const char *jobvt, const int *m, const int *n, float *A, const int *lda, float *S, float *U, const int *ldu, float *VT, const int *ldvt, float *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor sgesvd_$descriptor() {
        return sgesvd_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void sgesvd_(const char *jobu, const char *jobvt, const int *m, const int *n, float *A, const int *lda, float *S, float *U, const int *ldu, float *VT, const int *ldvt, float *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle sgesvd_$handle() {
        return sgesvd_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void sgesvd_(const char *jobu, const char *jobvt, const int *m, const int *n, float *A, const int *lda, float *S, float *U, const int *ldu, float *VT, const int *ldvt, float *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment sgesvd_$address() {
        return sgesvd_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void sgesvd_(const char *jobu, const char *jobvt, const int *m, const int *n, float *A, const int *lda, float *S, float *U, const int *ldu, float *VT, const int *ldvt, float *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static void sgesvd_(MemorySegment jobu, MemorySegment jobvt, MemorySegment m, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment S, MemorySegment U, MemorySegment ldu, MemorySegment VT, MemorySegment ldvt, MemorySegment work, MemorySegment lwork, MemorySegment info, long x14, long x15) {
        var mh$ = sgesvd_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sgesvd_", jobu, jobvt, m, n, A, lda, S, U, ldu, VT, ldvt, work, lwork, info, x14, x15);
            }
            mh$.invokeExact(jobu, jobvt, m, n, A, lda, S, U, ldu, VT, ldvt, work, lwork, info, x14, x15);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zgesvd_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("zgesvd_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zgesvd_(const char *jobu, const char *jobvt, const int *m, const int *n, _Complex double *A, const int *lda, double *S, _Complex double *U, const int *ldu, _Complex double *VT, const int *ldvt, _Complex double *work, const int *lwork, double *rwork, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor zgesvd_$descriptor() {
        return zgesvd_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zgesvd_(const char *jobu, const char *jobvt, const int *m, const int *n, _Complex double *A, const int *lda, double *S, _Complex double *U, const int *ldu, _Complex double *VT, const int *ldvt, _Complex double *work, const int *lwork, double *rwork, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle zgesvd_$handle() {
        return zgesvd_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zgesvd_(const char *jobu, const char *jobvt, const int *m, const int *n, _Complex double *A, const int *lda, double *S, _Complex double *U, const int *ldu, _Complex double *VT, const int *ldvt, _Complex double *work, const int *lwork, double *rwork, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment zgesvd_$address() {
        return zgesvd_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zgesvd_(const char *jobu, const char *jobvt, const int *m, const int *n, _Complex double *A, const int *lda, double *S, _Complex double *U, const int *ldu, _Complex double *VT, const int *ldvt, _Complex double *work, const int *lwork, double *rwork, int *info, size_t, size_t)
     * }
     */
    public static void zgesvd_(MemorySegment jobu, MemorySegment jobvt, MemorySegment m, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment S, MemorySegment U, MemorySegment ldu, MemorySegment VT, MemorySegment ldvt, MemorySegment work, MemorySegment lwork, MemorySegment rwork, MemorySegment info, long x15, long x16) {
        var mh$ = zgesvd_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zgesvd_", jobu, jobvt, m, n, A, lda, S, U, ldu, VT, ldvt, work, lwork, rwork, info, x15, x16);
            }
            mh$.invokeExact(jobu, jobvt, m, n, A, lda, S, U, ldu, VT, ldvt, work, lwork, rwork, info, x15, x16);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cgesvdq_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cgesvdq_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cgesvdq_(const char *joba, const char *jobp, const char *jobr, const char *jobu, const char *jobv, const int *m, const int *n, _Complex float *A, const int *lda, float *S, _Complex float *U, const int *ldu, _Complex float *V, const int *ldv, int *numrank, int *iwork, const int *liwork, _Complex float *cwork, int *lcwork, float *rwork, const int *lrwork, int *info, size_t, size_t, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor cgesvdq_$descriptor() {
        return cgesvdq_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cgesvdq_(const char *joba, const char *jobp, const char *jobr, const char *jobu, const char *jobv, const int *m, const int *n, _Complex float *A, const int *lda, float *S, _Complex float *U, const int *ldu, _Complex float *V, const int *ldv, int *numrank, int *iwork, const int *liwork, _Complex float *cwork, int *lcwork, float *rwork, const int *lrwork, int *info, size_t, size_t, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle cgesvdq_$handle() {
        return cgesvdq_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cgesvdq_(const char *joba, const char *jobp, const char *jobr, const char *jobu, const char *jobv, const int *m, const int *n, _Complex float *A, const int *lda, float *S, _Complex float *U, const int *ldu, _Complex float *V, const int *ldv, int *numrank, int *iwork, const int *liwork, _Complex float *cwork, int *lcwork, float *rwork, const int *lrwork, int *info, size_t, size_t, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment cgesvdq_$address() {
        return cgesvdq_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cgesvdq_(const char *joba, const char *jobp, const char *jobr, const char *jobu, const char *jobv, const int *m, const int *n, _Complex float *A, const int *lda, float *S, _Complex float *U, const int *ldu, _Complex float *V, const int *ldv, int *numrank, int *iwork, const int *liwork, _Complex float *cwork, int *lcwork, float *rwork, const int *lrwork, int *info, size_t, size_t, size_t, size_t, size_t)
     * }
     */
    public static void cgesvdq_(MemorySegment joba, MemorySegment jobp, MemorySegment jobr, MemorySegment jobu, MemorySegment jobv, MemorySegment m, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment S, MemorySegment U, MemorySegment ldu, MemorySegment V, MemorySegment ldv, MemorySegment numrank, MemorySegment iwork, MemorySegment liwork, MemorySegment cwork, MemorySegment lcwork, MemorySegment rwork, MemorySegment lrwork, MemorySegment info, long x22, long x23, long x24, long x25, long x26) {
        var mh$ = cgesvdq_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cgesvdq_", joba, jobp, jobr, jobu, jobv, m, n, A, lda, S, U, ldu, V, ldv, numrank, iwork, liwork, cwork, lcwork, rwork, lrwork, info, x22, x23, x24, x25, x26);
            }
            mh$.invokeExact(joba, jobp, jobr, jobu, jobv, m, n, A, lda, S, U, ldu, V, ldv, numrank, iwork, liwork, cwork, lcwork, rwork, lrwork, info, x22, x23, x24, x25, x26);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dgesvdq_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("dgesvdq_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dgesvdq_(const char *joba, const char *jobp, const char *jobr, const char *jobu, const char *jobv, const int *m, const int *n, double *A, const int *lda, double *S, double *U, const int *ldu, double *V, const int *ldv, int *numrank, int *iwork, const int *liwork, double *work, int *lwork, double *rwork, const int *lrwork, int *info, size_t, size_t, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor dgesvdq_$descriptor() {
        return dgesvdq_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dgesvdq_(const char *joba, const char *jobp, const char *jobr, const char *jobu, const char *jobv, const int *m, const int *n, double *A, const int *lda, double *S, double *U, const int *ldu, double *V, const int *ldv, int *numrank, int *iwork, const int *liwork, double *work, int *lwork, double *rwork, const int *lrwork, int *info, size_t, size_t, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle dgesvdq_$handle() {
        return dgesvdq_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dgesvdq_(const char *joba, const char *jobp, const char *jobr, const char *jobu, const char *jobv, const int *m, const int *n, double *A, const int *lda, double *S, double *U, const int *ldu, double *V, const int *ldv, int *numrank, int *iwork, const int *liwork, double *work, int *lwork, double *rwork, const int *lrwork, int *info, size_t, size_t, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment dgesvdq_$address() {
        return dgesvdq_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dgesvdq_(const char *joba, const char *jobp, const char *jobr, const char *jobu, const char *jobv, const int *m, const int *n, double *A, const int *lda, double *S, double *U, const int *ldu, double *V, const int *ldv, int *numrank, int *iwork, const int *liwork, double *work, int *lwork, double *rwork, const int *lrwork, int *info, size_t, size_t, size_t, size_t, size_t)
     * }
     */
    public static void dgesvdq_(MemorySegment joba, MemorySegment jobp, MemorySegment jobr, MemorySegment jobu, MemorySegment jobv, MemorySegment m, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment S, MemorySegment U, MemorySegment ldu, MemorySegment V, MemorySegment ldv, MemorySegment numrank, MemorySegment iwork, MemorySegment liwork, MemorySegment work, MemorySegment lwork, MemorySegment rwork, MemorySegment lrwork, MemorySegment info, long x22, long x23, long x24, long x25, long x26) {
        var mh$ = dgesvdq_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dgesvdq_", joba, jobp, jobr, jobu, jobv, m, n, A, lda, S, U, ldu, V, ldv, numrank, iwork, liwork, work, lwork, rwork, lrwork, info, x22, x23, x24, x25, x26);
            }
            mh$.invokeExact(joba, jobp, jobr, jobu, jobv, m, n, A, lda, S, U, ldu, V, ldv, numrank, iwork, liwork, work, lwork, rwork, lrwork, info, x22, x23, x24, x25, x26);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sgesvdq_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("sgesvdq_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void sgesvdq_(const char *joba, const char *jobp, const char *jobr, const char *jobu, const char *jobv, const int *m, const int *n, float *A, const int *lda, float *S, float *U, const int *ldu, float *V, const int *ldv, int *numrank, int *iwork, const int *liwork, float *work, int *lwork, float *rwork, const int *lrwork, int *info, size_t, size_t, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor sgesvdq_$descriptor() {
        return sgesvdq_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void sgesvdq_(const char *joba, const char *jobp, const char *jobr, const char *jobu, const char *jobv, const int *m, const int *n, float *A, const int *lda, float *S, float *U, const int *ldu, float *V, const int *ldv, int *numrank, int *iwork, const int *liwork, float *work, int *lwork, float *rwork, const int *lrwork, int *info, size_t, size_t, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle sgesvdq_$handle() {
        return sgesvdq_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void sgesvdq_(const char *joba, const char *jobp, const char *jobr, const char *jobu, const char *jobv, const int *m, const int *n, float *A, const int *lda, float *S, float *U, const int *ldu, float *V, const int *ldv, int *numrank, int *iwork, const int *liwork, float *work, int *lwork, float *rwork, const int *lrwork, int *info, size_t, size_t, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment sgesvdq_$address() {
        return sgesvdq_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void sgesvdq_(const char *joba, const char *jobp, const char *jobr, const char *jobu, const char *jobv, const int *m, const int *n, float *A, const int *lda, float *S, float *U, const int *ldu, float *V, const int *ldv, int *numrank, int *iwork, const int *liwork, float *work, int *lwork, float *rwork, const int *lrwork, int *info, size_t, size_t, size_t, size_t, size_t)
     * }
     */
    public static void sgesvdq_(MemorySegment joba, MemorySegment jobp, MemorySegment jobr, MemorySegment jobu, MemorySegment jobv, MemorySegment m, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment S, MemorySegment U, MemorySegment ldu, MemorySegment V, MemorySegment ldv, MemorySegment numrank, MemorySegment iwork, MemorySegment liwork, MemorySegment work, MemorySegment lwork, MemorySegment rwork, MemorySegment lrwork, MemorySegment info, long x22, long x23, long x24, long x25, long x26) {
        var mh$ = sgesvdq_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sgesvdq_", joba, jobp, jobr, jobu, jobv, m, n, A, lda, S, U, ldu, V, ldv, numrank, iwork, liwork, work, lwork, rwork, lrwork, info, x22, x23, x24, x25, x26);
            }
            mh$.invokeExact(joba, jobp, jobr, jobu, jobv, m, n, A, lda, S, U, ldu, V, ldv, numrank, iwork, liwork, work, lwork, rwork, lrwork, info, x22, x23, x24, x25, x26);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zgesvdq_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("zgesvdq_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zgesvdq_(const char *joba, const char *jobp, const char *jobr, const char *jobu, const char *jobv, const int *m, const int *n, _Complex double *A, const int *lda, double *S, _Complex double *U, const int *ldu, _Complex double *V, const int *ldv, int *numrank, int *iwork, const int *liwork, _Complex double *cwork, int *lcwork, double *rwork, const int *lrwork, int *info, size_t, size_t, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor zgesvdq_$descriptor() {
        return zgesvdq_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zgesvdq_(const char *joba, const char *jobp, const char *jobr, const char *jobu, const char *jobv, const int *m, const int *n, _Complex double *A, const int *lda, double *S, _Complex double *U, const int *ldu, _Complex double *V, const int *ldv, int *numrank, int *iwork, const int *liwork, _Complex double *cwork, int *lcwork, double *rwork, const int *lrwork, int *info, size_t, size_t, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle zgesvdq_$handle() {
        return zgesvdq_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zgesvdq_(const char *joba, const char *jobp, const char *jobr, const char *jobu, const char *jobv, const int *m, const int *n, _Complex double *A, const int *lda, double *S, _Complex double *U, const int *ldu, _Complex double *V, const int *ldv, int *numrank, int *iwork, const int *liwork, _Complex double *cwork, int *lcwork, double *rwork, const int *lrwork, int *info, size_t, size_t, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment zgesvdq_$address() {
        return zgesvdq_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zgesvdq_(const char *joba, const char *jobp, const char *jobr, const char *jobu, const char *jobv, const int *m, const int *n, _Complex double *A, const int *lda, double *S, _Complex double *U, const int *ldu, _Complex double *V, const int *ldv, int *numrank, int *iwork, const int *liwork, _Complex double *cwork, int *lcwork, double *rwork, const int *lrwork, int *info, size_t, size_t, size_t, size_t, size_t)
     * }
     */
    public static void zgesvdq_(MemorySegment joba, MemorySegment jobp, MemorySegment jobr, MemorySegment jobu, MemorySegment jobv, MemorySegment m, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment S, MemorySegment U, MemorySegment ldu, MemorySegment V, MemorySegment ldv, MemorySegment numrank, MemorySegment iwork, MemorySegment liwork, MemorySegment cwork, MemorySegment lcwork, MemorySegment rwork, MemorySegment lrwork, MemorySegment info, long x22, long x23, long x24, long x25, long x26) {
        var mh$ = zgesvdq_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zgesvdq_", joba, jobp, jobr, jobu, jobv, m, n, A, lda, S, U, ldu, V, ldv, numrank, iwork, liwork, cwork, lcwork, rwork, lrwork, info, x22, x23, x24, x25, x26);
            }
            mh$.invokeExact(joba, jobp, jobr, jobu, jobv, m, n, A, lda, S, U, ldu, V, ldv, numrank, iwork, liwork, cwork, lcwork, rwork, lrwork, info, x22, x23, x24, x25, x26);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cgesvdx_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cgesvdx_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cgesvdx_(const char *jobu, const char *jobvt, const char *range, const int *m, const int *n, _Complex float *A, const int *lda, const float *vl, const float *vu, const int *il, const int *iu, int *ns, float *S, _Complex float *U, const int *ldu, _Complex float *VT, const int *ldvt, _Complex float *work, const int *lwork, float *rwork, int *iwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor cgesvdx_$descriptor() {
        return cgesvdx_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cgesvdx_(const char *jobu, const char *jobvt, const char *range, const int *m, const int *n, _Complex float *A, const int *lda, const float *vl, const float *vu, const int *il, const int *iu, int *ns, float *S, _Complex float *U, const int *ldu, _Complex float *VT, const int *ldvt, _Complex float *work, const int *lwork, float *rwork, int *iwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle cgesvdx_$handle() {
        return cgesvdx_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cgesvdx_(const char *jobu, const char *jobvt, const char *range, const int *m, const int *n, _Complex float *A, const int *lda, const float *vl, const float *vu, const int *il, const int *iu, int *ns, float *S, _Complex float *U, const int *ldu, _Complex float *VT, const int *ldvt, _Complex float *work, const int *lwork, float *rwork, int *iwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment cgesvdx_$address() {
        return cgesvdx_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cgesvdx_(const char *jobu, const char *jobvt, const char *range, const int *m, const int *n, _Complex float *A, const int *lda, const float *vl, const float *vu, const int *il, const int *iu, int *ns, float *S, _Complex float *U, const int *ldu, _Complex float *VT, const int *ldvt, _Complex float *work, const int *lwork, float *rwork, int *iwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static void cgesvdx_(MemorySegment jobu, MemorySegment jobvt, MemorySegment range, MemorySegment m, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment vl, MemorySegment vu, MemorySegment il, MemorySegment iu, MemorySegment ns, MemorySegment S, MemorySegment U, MemorySegment ldu, MemorySegment VT, MemorySegment ldvt, MemorySegment work, MemorySegment lwork, MemorySegment rwork, MemorySegment iwork, MemorySegment info, long x22, long x23, long x24) {
        var mh$ = cgesvdx_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cgesvdx_", jobu, jobvt, range, m, n, A, lda, vl, vu, il, iu, ns, S, U, ldu, VT, ldvt, work, lwork, rwork, iwork, info, x22, x23, x24);
            }
            mh$.invokeExact(jobu, jobvt, range, m, n, A, lda, vl, vu, il, iu, ns, S, U, ldu, VT, ldvt, work, lwork, rwork, iwork, info, x22, x23, x24);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dgesvdx_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("dgesvdx_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dgesvdx_(const char *jobu, const char *jobvt, const char *range, const int *m, const int *n, double *A, const int *lda, const double *vl, const double *vu, const int *il, const int *iu, int *ns, double *S, double *U, const int *ldu, double *VT, const int *ldvt, double *work, const int *lwork, int *iwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor dgesvdx_$descriptor() {
        return dgesvdx_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dgesvdx_(const char *jobu, const char *jobvt, const char *range, const int *m, const int *n, double *A, const int *lda, const double *vl, const double *vu, const int *il, const int *iu, int *ns, double *S, double *U, const int *ldu, double *VT, const int *ldvt, double *work, const int *lwork, int *iwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle dgesvdx_$handle() {
        return dgesvdx_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dgesvdx_(const char *jobu, const char *jobvt, const char *range, const int *m, const int *n, double *A, const int *lda, const double *vl, const double *vu, const int *il, const int *iu, int *ns, double *S, double *U, const int *ldu, double *VT, const int *ldvt, double *work, const int *lwork, int *iwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment dgesvdx_$address() {
        return dgesvdx_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dgesvdx_(const char *jobu, const char *jobvt, const char *range, const int *m, const int *n, double *A, const int *lda, const double *vl, const double *vu, const int *il, const int *iu, int *ns, double *S, double *U, const int *ldu, double *VT, const int *ldvt, double *work, const int *lwork, int *iwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static void dgesvdx_(MemorySegment jobu, MemorySegment jobvt, MemorySegment range, MemorySegment m, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment vl, MemorySegment vu, MemorySegment il, MemorySegment iu, MemorySegment ns, MemorySegment S, MemorySegment U, MemorySegment ldu, MemorySegment VT, MemorySegment ldvt, MemorySegment work, MemorySegment lwork, MemorySegment iwork, MemorySegment info, long x21, long x22, long x23) {
        var mh$ = dgesvdx_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dgesvdx_", jobu, jobvt, range, m, n, A, lda, vl, vu, il, iu, ns, S, U, ldu, VT, ldvt, work, lwork, iwork, info, x21, x22, x23);
            }
            mh$.invokeExact(jobu, jobvt, range, m, n, A, lda, vl, vu, il, iu, ns, S, U, ldu, VT, ldvt, work, lwork, iwork, info, x21, x22, x23);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sgesvdx_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("sgesvdx_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void sgesvdx_(const char *jobu, const char *jobvt, const char *range, const int *m, const int *n, float *A, const int *lda, const float *vl, const float *vu, const int *il, const int *iu, int *ns, float *S, float *U, const int *ldu, float *VT, const int *ldvt, float *work, const int *lwork, int *iwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor sgesvdx_$descriptor() {
        return sgesvdx_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void sgesvdx_(const char *jobu, const char *jobvt, const char *range, const int *m, const int *n, float *A, const int *lda, const float *vl, const float *vu, const int *il, const int *iu, int *ns, float *S, float *U, const int *ldu, float *VT, const int *ldvt, float *work, const int *lwork, int *iwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle sgesvdx_$handle() {
        return sgesvdx_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void sgesvdx_(const char *jobu, const char *jobvt, const char *range, const int *m, const int *n, float *A, const int *lda, const float *vl, const float *vu, const int *il, const int *iu, int *ns, float *S, float *U, const int *ldu, float *VT, const int *ldvt, float *work, const int *lwork, int *iwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment sgesvdx_$address() {
        return sgesvdx_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void sgesvdx_(const char *jobu, const char *jobvt, const char *range, const int *m, const int *n, float *A, const int *lda, const float *vl, const float *vu, const int *il, const int *iu, int *ns, float *S, float *U, const int *ldu, float *VT, const int *ldvt, float *work, const int *lwork, int *iwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static void sgesvdx_(MemorySegment jobu, MemorySegment jobvt, MemorySegment range, MemorySegment m, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment vl, MemorySegment vu, MemorySegment il, MemorySegment iu, MemorySegment ns, MemorySegment S, MemorySegment U, MemorySegment ldu, MemorySegment VT, MemorySegment ldvt, MemorySegment work, MemorySegment lwork, MemorySegment iwork, MemorySegment info, long x21, long x22, long x23) {
        var mh$ = sgesvdx_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sgesvdx_", jobu, jobvt, range, m, n, A, lda, vl, vu, il, iu, ns, S, U, ldu, VT, ldvt, work, lwork, iwork, info, x21, x22, x23);
            }
            mh$.invokeExact(jobu, jobvt, range, m, n, A, lda, vl, vu, il, iu, ns, S, U, ldu, VT, ldvt, work, lwork, iwork, info, x21, x22, x23);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zgesvdx_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("zgesvdx_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zgesvdx_(const char *jobu, const char *jobvt, const char *range, const int *m, const int *n, _Complex double *A, const int *lda, const double *vl, const double *vu, const int *il, const int *iu, int *ns, double *S, _Complex double *U, const int *ldu, _Complex double *VT, const int *ldvt, _Complex double *work, const int *lwork, double *rwork, int *iwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor zgesvdx_$descriptor() {
        return zgesvdx_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zgesvdx_(const char *jobu, const char *jobvt, const char *range, const int *m, const int *n, _Complex double *A, const int *lda, const double *vl, const double *vu, const int *il, const int *iu, int *ns, double *S, _Complex double *U, const int *ldu, _Complex double *VT, const int *ldvt, _Complex double *work, const int *lwork, double *rwork, int *iwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle zgesvdx_$handle() {
        return zgesvdx_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zgesvdx_(const char *jobu, const char *jobvt, const char *range, const int *m, const int *n, _Complex double *A, const int *lda, const double *vl, const double *vu, const int *il, const int *iu, int *ns, double *S, _Complex double *U, const int *ldu, _Complex double *VT, const int *ldvt, _Complex double *work, const int *lwork, double *rwork, int *iwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment zgesvdx_$address() {
        return zgesvdx_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zgesvdx_(const char *jobu, const char *jobvt, const char *range, const int *m, const int *n, _Complex double *A, const int *lda, const double *vl, const double *vu, const int *il, const int *iu, int *ns, double *S, _Complex double *U, const int *ldu, _Complex double *VT, const int *ldvt, _Complex double *work, const int *lwork, double *rwork, int *iwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static void zgesvdx_(MemorySegment jobu, MemorySegment jobvt, MemorySegment range, MemorySegment m, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment vl, MemorySegment vu, MemorySegment il, MemorySegment iu, MemorySegment ns, MemorySegment S, MemorySegment U, MemorySegment ldu, MemorySegment VT, MemorySegment ldvt, MemorySegment work, MemorySegment lwork, MemorySegment rwork, MemorySegment iwork, MemorySegment info, long x22, long x23, long x24) {
        var mh$ = zgesvdx_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zgesvdx_", jobu, jobvt, range, m, n, A, lda, vl, vu, il, iu, ns, S, U, ldu, VT, ldvt, work, lwork, rwork, iwork, info, x22, x23, x24);
            }
            mh$.invokeExact(jobu, jobvt, range, m, n, A, lda, vl, vu, il, iu, ns, S, U, ldu, VT, ldvt, work, lwork, rwork, iwork, info, x22, x23, x24);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cgesvj_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cgesvj_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cgesvj_(const char *joba, const char *jobu, const char *jobv, const int *m, const int *n, _Complex float *A, const int *lda, float *SVA, const int *mv, _Complex float *V, const int *ldv, _Complex float *cwork, const int *lwork, float *rwork, const int *lrwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor cgesvj_$descriptor() {
        return cgesvj_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cgesvj_(const char *joba, const char *jobu, const char *jobv, const int *m, const int *n, _Complex float *A, const int *lda, float *SVA, const int *mv, _Complex float *V, const int *ldv, _Complex float *cwork, const int *lwork, float *rwork, const int *lrwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle cgesvj_$handle() {
        return cgesvj_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cgesvj_(const char *joba, const char *jobu, const char *jobv, const int *m, const int *n, _Complex float *A, const int *lda, float *SVA, const int *mv, _Complex float *V, const int *ldv, _Complex float *cwork, const int *lwork, float *rwork, const int *lrwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment cgesvj_$address() {
        return cgesvj_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cgesvj_(const char *joba, const char *jobu, const char *jobv, const int *m, const int *n, _Complex float *A, const int *lda, float *SVA, const int *mv, _Complex float *V, const int *ldv, _Complex float *cwork, const int *lwork, float *rwork, const int *lrwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static void cgesvj_(MemorySegment joba, MemorySegment jobu, MemorySegment jobv, MemorySegment m, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment SVA, MemorySegment mv, MemorySegment V, MemorySegment ldv, MemorySegment cwork, MemorySegment lwork, MemorySegment rwork, MemorySegment lrwork, MemorySegment info, long x16, long x17, long x18) {
        var mh$ = cgesvj_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cgesvj_", joba, jobu, jobv, m, n, A, lda, SVA, mv, V, ldv, cwork, lwork, rwork, lrwork, info, x16, x17, x18);
            }
            mh$.invokeExact(joba, jobu, jobv, m, n, A, lda, SVA, mv, V, ldv, cwork, lwork, rwork, lrwork, info, x16, x17, x18);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dgesvj_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("dgesvj_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dgesvj_(const char *joba, const char *jobu, const char *jobv, const int *m, const int *n, double *A, const int *lda, double *SVA, const int *mv, double *V, const int *ldv, double *work, const int *lwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor dgesvj_$descriptor() {
        return dgesvj_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dgesvj_(const char *joba, const char *jobu, const char *jobv, const int *m, const int *n, double *A, const int *lda, double *SVA, const int *mv, double *V, const int *ldv, double *work, const int *lwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle dgesvj_$handle() {
        return dgesvj_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dgesvj_(const char *joba, const char *jobu, const char *jobv, const int *m, const int *n, double *A, const int *lda, double *SVA, const int *mv, double *V, const int *ldv, double *work, const int *lwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment dgesvj_$address() {
        return dgesvj_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dgesvj_(const char *joba, const char *jobu, const char *jobv, const int *m, const int *n, double *A, const int *lda, double *SVA, const int *mv, double *V, const int *ldv, double *work, const int *lwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static void dgesvj_(MemorySegment joba, MemorySegment jobu, MemorySegment jobv, MemorySegment m, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment SVA, MemorySegment mv, MemorySegment V, MemorySegment ldv, MemorySegment work, MemorySegment lwork, MemorySegment info, long x14, long x15, long x16) {
        var mh$ = dgesvj_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dgesvj_", joba, jobu, jobv, m, n, A, lda, SVA, mv, V, ldv, work, lwork, info, x14, x15, x16);
            }
            mh$.invokeExact(joba, jobu, jobv, m, n, A, lda, SVA, mv, V, ldv, work, lwork, info, x14, x15, x16);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sgesvj_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("sgesvj_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void sgesvj_(const char *joba, const char *jobu, const char *jobv, const int *m, const int *n, float *A, const int *lda, float *SVA, const int *mv, float *V, const int *ldv, float *work, const int *lwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor sgesvj_$descriptor() {
        return sgesvj_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void sgesvj_(const char *joba, const char *jobu, const char *jobv, const int *m, const int *n, float *A, const int *lda, float *SVA, const int *mv, float *V, const int *ldv, float *work, const int *lwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle sgesvj_$handle() {
        return sgesvj_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void sgesvj_(const char *joba, const char *jobu, const char *jobv, const int *m, const int *n, float *A, const int *lda, float *SVA, const int *mv, float *V, const int *ldv, float *work, const int *lwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment sgesvj_$address() {
        return sgesvj_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void sgesvj_(const char *joba, const char *jobu, const char *jobv, const int *m, const int *n, float *A, const int *lda, float *SVA, const int *mv, float *V, const int *ldv, float *work, const int *lwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static void sgesvj_(MemorySegment joba, MemorySegment jobu, MemorySegment jobv, MemorySegment m, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment SVA, MemorySegment mv, MemorySegment V, MemorySegment ldv, MemorySegment work, MemorySegment lwork, MemorySegment info, long x14, long x15, long x16) {
        var mh$ = sgesvj_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sgesvj_", joba, jobu, jobv, m, n, A, lda, SVA, mv, V, ldv, work, lwork, info, x14, x15, x16);
            }
            mh$.invokeExact(joba, jobu, jobv, m, n, A, lda, SVA, mv, V, ldv, work, lwork, info, x14, x15, x16);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zgesvj_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("zgesvj_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zgesvj_(const char *joba, const char *jobu, const char *jobv, const int *m, const int *n, _Complex double *A, const int *lda, double *SVA, const int *mv, _Complex double *V, const int *ldv, _Complex double *cwork, const int *lwork, double *rwork, const int *lrwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor zgesvj_$descriptor() {
        return zgesvj_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zgesvj_(const char *joba, const char *jobu, const char *jobv, const int *m, const int *n, _Complex double *A, const int *lda, double *SVA, const int *mv, _Complex double *V, const int *ldv, _Complex double *cwork, const int *lwork, double *rwork, const int *lrwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle zgesvj_$handle() {
        return zgesvj_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zgesvj_(const char *joba, const char *jobu, const char *jobv, const int *m, const int *n, _Complex double *A, const int *lda, double *SVA, const int *mv, _Complex double *V, const int *ldv, _Complex double *cwork, const int *lwork, double *rwork, const int *lrwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment zgesvj_$address() {
        return zgesvj_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zgesvj_(const char *joba, const char *jobu, const char *jobv, const int *m, const int *n, _Complex double *A, const int *lda, double *SVA, const int *mv, _Complex double *V, const int *ldv, _Complex double *cwork, const int *lwork, double *rwork, const int *lrwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static void zgesvj_(MemorySegment joba, MemorySegment jobu, MemorySegment jobv, MemorySegment m, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment SVA, MemorySegment mv, MemorySegment V, MemorySegment ldv, MemorySegment cwork, MemorySegment lwork, MemorySegment rwork, MemorySegment lrwork, MemorySegment info, long x16, long x17, long x18) {
        var mh$ = zgesvj_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zgesvj_", joba, jobu, jobv, m, n, A, lda, SVA, mv, V, ldv, cwork, lwork, rwork, lrwork, info, x16, x17, x18);
            }
            mh$.invokeExact(joba, jobu, jobv, m, n, A, lda, SVA, mv, V, ldv, cwork, lwork, rwork, lrwork, info, x16, x17, x18);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cgesvx_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cgesvx_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cgesvx_(const char *fact, const char *trans, const int *n, const int *nrhs, _Complex float *A, const int *lda, _Complex float *AF, const int *ldaf, int *ipiv, char *equed, float *R, float *C, _Complex float *B, const int *ldb, _Complex float *X, const int *ldx, float *rcond, float *ferr, float *berr, _Complex float *work, float *rwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor cgesvx_$descriptor() {
        return cgesvx_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cgesvx_(const char *fact, const char *trans, const int *n, const int *nrhs, _Complex float *A, const int *lda, _Complex float *AF, const int *ldaf, int *ipiv, char *equed, float *R, float *C, _Complex float *B, const int *ldb, _Complex float *X, const int *ldx, float *rcond, float *ferr, float *berr, _Complex float *work, float *rwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle cgesvx_$handle() {
        return cgesvx_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cgesvx_(const char *fact, const char *trans, const int *n, const int *nrhs, _Complex float *A, const int *lda, _Complex float *AF, const int *ldaf, int *ipiv, char *equed, float *R, float *C, _Complex float *B, const int *ldb, _Complex float *X, const int *ldx, float *rcond, float *ferr, float *berr, _Complex float *work, float *rwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment cgesvx_$address() {
        return cgesvx_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cgesvx_(const char *fact, const char *trans, const int *n, const int *nrhs, _Complex float *A, const int *lda, _Complex float *AF, const int *ldaf, int *ipiv, char *equed, float *R, float *C, _Complex float *B, const int *ldb, _Complex float *X, const int *ldx, float *rcond, float *ferr, float *berr, _Complex float *work, float *rwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static void cgesvx_(MemorySegment fact, MemorySegment trans, MemorySegment n, MemorySegment nrhs, MemorySegment A, MemorySegment lda, MemorySegment AF, MemorySegment ldaf, MemorySegment ipiv, MemorySegment equed, MemorySegment R, MemorySegment C, MemorySegment B, MemorySegment ldb, MemorySegment X, MemorySegment ldx, MemorySegment rcond, MemorySegment ferr, MemorySegment berr, MemorySegment work, MemorySegment rwork, MemorySegment info, long x22, long x23, long x24) {
        var mh$ = cgesvx_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cgesvx_", fact, trans, n, nrhs, A, lda, AF, ldaf, ipiv, equed, R, C, B, ldb, X, ldx, rcond, ferr, berr, work, rwork, info, x22, x23, x24);
            }
            mh$.invokeExact(fact, trans, n, nrhs, A, lda, AF, ldaf, ipiv, equed, R, C, B, ldb, X, ldx, rcond, ferr, berr, work, rwork, info, x22, x23, x24);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dgesvx_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("dgesvx_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dgesvx_(const char *fact, const char *trans, const int *n, const int *nrhs, double *A, const int *lda, double *AF, const int *ldaf, int *ipiv, char *equed, double *R, double *C, double *B, const int *ldb, double *X, const int *ldx, double *rcond, double *ferr, double *berr, double *work, int *iwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor dgesvx_$descriptor() {
        return dgesvx_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dgesvx_(const char *fact, const char *trans, const int *n, const int *nrhs, double *A, const int *lda, double *AF, const int *ldaf, int *ipiv, char *equed, double *R, double *C, double *B, const int *ldb, double *X, const int *ldx, double *rcond, double *ferr, double *berr, double *work, int *iwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle dgesvx_$handle() {
        return dgesvx_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dgesvx_(const char *fact, const char *trans, const int *n, const int *nrhs, double *A, const int *lda, double *AF, const int *ldaf, int *ipiv, char *equed, double *R, double *C, double *B, const int *ldb, double *X, const int *ldx, double *rcond, double *ferr, double *berr, double *work, int *iwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment dgesvx_$address() {
        return dgesvx_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dgesvx_(const char *fact, const char *trans, const int *n, const int *nrhs, double *A, const int *lda, double *AF, const int *ldaf, int *ipiv, char *equed, double *R, double *C, double *B, const int *ldb, double *X, const int *ldx, double *rcond, double *ferr, double *berr, double *work, int *iwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static void dgesvx_(MemorySegment fact, MemorySegment trans, MemorySegment n, MemorySegment nrhs, MemorySegment A, MemorySegment lda, MemorySegment AF, MemorySegment ldaf, MemorySegment ipiv, MemorySegment equed, MemorySegment R, MemorySegment C, MemorySegment B, MemorySegment ldb, MemorySegment X, MemorySegment ldx, MemorySegment rcond, MemorySegment ferr, MemorySegment berr, MemorySegment work, MemorySegment iwork, MemorySegment info, long x22, long x23, long x24) {
        var mh$ = dgesvx_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dgesvx_", fact, trans, n, nrhs, A, lda, AF, ldaf, ipiv, equed, R, C, B, ldb, X, ldx, rcond, ferr, berr, work, iwork, info, x22, x23, x24);
            }
            mh$.invokeExact(fact, trans, n, nrhs, A, lda, AF, ldaf, ipiv, equed, R, C, B, ldb, X, ldx, rcond, ferr, berr, work, iwork, info, x22, x23, x24);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sgesvx_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("sgesvx_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void sgesvx_(const char *fact, const char *trans, const int *n, const int *nrhs, float *A, const int *lda, float *AF, const int *ldaf, int *ipiv, char *equed, float *R, float *C, float *B, const int *ldb, float *X, const int *ldx, float *rcond, float *ferr, float *berr, float *work, int *iwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor sgesvx_$descriptor() {
        return sgesvx_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void sgesvx_(const char *fact, const char *trans, const int *n, const int *nrhs, float *A, const int *lda, float *AF, const int *ldaf, int *ipiv, char *equed, float *R, float *C, float *B, const int *ldb, float *X, const int *ldx, float *rcond, float *ferr, float *berr, float *work, int *iwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle sgesvx_$handle() {
        return sgesvx_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void sgesvx_(const char *fact, const char *trans, const int *n, const int *nrhs, float *A, const int *lda, float *AF, const int *ldaf, int *ipiv, char *equed, float *R, float *C, float *B, const int *ldb, float *X, const int *ldx, float *rcond, float *ferr, float *berr, float *work, int *iwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment sgesvx_$address() {
        return sgesvx_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void sgesvx_(const char *fact, const char *trans, const int *n, const int *nrhs, float *A, const int *lda, float *AF, const int *ldaf, int *ipiv, char *equed, float *R, float *C, float *B, const int *ldb, float *X, const int *ldx, float *rcond, float *ferr, float *berr, float *work, int *iwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static void sgesvx_(MemorySegment fact, MemorySegment trans, MemorySegment n, MemorySegment nrhs, MemorySegment A, MemorySegment lda, MemorySegment AF, MemorySegment ldaf, MemorySegment ipiv, MemorySegment equed, MemorySegment R, MemorySegment C, MemorySegment B, MemorySegment ldb, MemorySegment X, MemorySegment ldx, MemorySegment rcond, MemorySegment ferr, MemorySegment berr, MemorySegment work, MemorySegment iwork, MemorySegment info, long x22, long x23, long x24) {
        var mh$ = sgesvx_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sgesvx_", fact, trans, n, nrhs, A, lda, AF, ldaf, ipiv, equed, R, C, B, ldb, X, ldx, rcond, ferr, berr, work, iwork, info, x22, x23, x24);
            }
            mh$.invokeExact(fact, trans, n, nrhs, A, lda, AF, ldaf, ipiv, equed, R, C, B, ldb, X, ldx, rcond, ferr, berr, work, iwork, info, x22, x23, x24);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zgesvx_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("zgesvx_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zgesvx_(const char *fact, const char *trans, const int *n, const int *nrhs, _Complex double *A, const int *lda, _Complex double *AF, const int *ldaf, int *ipiv, char *equed, double *R, double *C, _Complex double *B, const int *ldb, _Complex double *X, const int *ldx, double *rcond, double *ferr, double *berr, _Complex double *work, double *rwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor zgesvx_$descriptor() {
        return zgesvx_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zgesvx_(const char *fact, const char *trans, const int *n, const int *nrhs, _Complex double *A, const int *lda, _Complex double *AF, const int *ldaf, int *ipiv, char *equed, double *R, double *C, _Complex double *B, const int *ldb, _Complex double *X, const int *ldx, double *rcond, double *ferr, double *berr, _Complex double *work, double *rwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle zgesvx_$handle() {
        return zgesvx_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zgesvx_(const char *fact, const char *trans, const int *n, const int *nrhs, _Complex double *A, const int *lda, _Complex double *AF, const int *ldaf, int *ipiv, char *equed, double *R, double *C, _Complex double *B, const int *ldb, _Complex double *X, const int *ldx, double *rcond, double *ferr, double *berr, _Complex double *work, double *rwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment zgesvx_$address() {
        return zgesvx_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zgesvx_(const char *fact, const char *trans, const int *n, const int *nrhs, _Complex double *A, const int *lda, _Complex double *AF, const int *ldaf, int *ipiv, char *equed, double *R, double *C, _Complex double *B, const int *ldb, _Complex double *X, const int *ldx, double *rcond, double *ferr, double *berr, _Complex double *work, double *rwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static void zgesvx_(MemorySegment fact, MemorySegment trans, MemorySegment n, MemorySegment nrhs, MemorySegment A, MemorySegment lda, MemorySegment AF, MemorySegment ldaf, MemorySegment ipiv, MemorySegment equed, MemorySegment R, MemorySegment C, MemorySegment B, MemorySegment ldb, MemorySegment X, MemorySegment ldx, MemorySegment rcond, MemorySegment ferr, MemorySegment berr, MemorySegment work, MemorySegment rwork, MemorySegment info, long x22, long x23, long x24) {
        var mh$ = zgesvx_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zgesvx_", fact, trans, n, nrhs, A, lda, AF, ldaf, ipiv, equed, R, C, B, ldb, X, ldx, rcond, ferr, berr, work, rwork, info, x22, x23, x24);
            }
            mh$.invokeExact(fact, trans, n, nrhs, A, lda, AF, ldaf, ipiv, equed, R, C, B, ldb, X, ldx, rcond, ferr, berr, work, rwork, info, x22, x23, x24);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cgesvxx_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cgesvxx_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cgesvxx_(const char *fact, const char *trans, const int *n, const int *nrhs, _Complex float *A, const int *lda, _Complex float *AF, const int *ldaf, int *ipiv, char *equed, float *R, float *C, _Complex float *B, const int *ldb, _Complex float *X, const int *ldx, float *rcond, float *rpvgrw, float *berr, const int *n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, const int *nparams, float *params, _Complex float *work, float *rwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor cgesvxx_$descriptor() {
        return cgesvxx_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cgesvxx_(const char *fact, const char *trans, const int *n, const int *nrhs, _Complex float *A, const int *lda, _Complex float *AF, const int *ldaf, int *ipiv, char *equed, float *R, float *C, _Complex float *B, const int *ldb, _Complex float *X, const int *ldx, float *rcond, float *rpvgrw, float *berr, const int *n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, const int *nparams, float *params, _Complex float *work, float *rwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle cgesvxx_$handle() {
        return cgesvxx_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cgesvxx_(const char *fact, const char *trans, const int *n, const int *nrhs, _Complex float *A, const int *lda, _Complex float *AF, const int *ldaf, int *ipiv, char *equed, float *R, float *C, _Complex float *B, const int *ldb, _Complex float *X, const int *ldx, float *rcond, float *rpvgrw, float *berr, const int *n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, const int *nparams, float *params, _Complex float *work, float *rwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment cgesvxx_$address() {
        return cgesvxx_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cgesvxx_(const char *fact, const char *trans, const int *n, const int *nrhs, _Complex float *A, const int *lda, _Complex float *AF, const int *ldaf, int *ipiv, char *equed, float *R, float *C, _Complex float *B, const int *ldb, _Complex float *X, const int *ldx, float *rcond, float *rpvgrw, float *berr, const int *n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, const int *nparams, float *params, _Complex float *work, float *rwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static void cgesvxx_(MemorySegment fact, MemorySegment trans, MemorySegment n, MemorySegment nrhs, MemorySegment A, MemorySegment lda, MemorySegment AF, MemorySegment ldaf, MemorySegment ipiv, MemorySegment equed, MemorySegment R, MemorySegment C, MemorySegment B, MemorySegment ldb, MemorySegment X, MemorySegment ldx, MemorySegment rcond, MemorySegment rpvgrw, MemorySegment berr, MemorySegment n_err_bnds, MemorySegment err_bnds_norm, MemorySegment err_bnds_comp, MemorySegment nparams, MemorySegment params, MemorySegment work, MemorySegment rwork, MemorySegment info, long x27, long x28, long x29) {
        var mh$ = cgesvxx_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cgesvxx_", fact, trans, n, nrhs, A, lda, AF, ldaf, ipiv, equed, R, C, B, ldb, X, ldx, rcond, rpvgrw, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params, work, rwork, info, x27, x28, x29);
            }
            mh$.invokeExact(fact, trans, n, nrhs, A, lda, AF, ldaf, ipiv, equed, R, C, B, ldb, X, ldx, rcond, rpvgrw, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params, work, rwork, info, x27, x28, x29);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dgesvxx_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("dgesvxx_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dgesvxx_(const char *fact, const char *trans, const int *n, const int *nrhs, double *A, const int *lda, double *AF, const int *ldaf, int *ipiv, char *equed, double *R, double *C, double *B, const int *ldb, double *X, const int *ldx, double *rcond, double *rpvgrw, double *berr, const int *n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, const int *nparams, double *params, double *work, int *iwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor dgesvxx_$descriptor() {
        return dgesvxx_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dgesvxx_(const char *fact, const char *trans, const int *n, const int *nrhs, double *A, const int *lda, double *AF, const int *ldaf, int *ipiv, char *equed, double *R, double *C, double *B, const int *ldb, double *X, const int *ldx, double *rcond, double *rpvgrw, double *berr, const int *n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, const int *nparams, double *params, double *work, int *iwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle dgesvxx_$handle() {
        return dgesvxx_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dgesvxx_(const char *fact, const char *trans, const int *n, const int *nrhs, double *A, const int *lda, double *AF, const int *ldaf, int *ipiv, char *equed, double *R, double *C, double *B, const int *ldb, double *X, const int *ldx, double *rcond, double *rpvgrw, double *berr, const int *n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, const int *nparams, double *params, double *work, int *iwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment dgesvxx_$address() {
        return dgesvxx_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dgesvxx_(const char *fact, const char *trans, const int *n, const int *nrhs, double *A, const int *lda, double *AF, const int *ldaf, int *ipiv, char *equed, double *R, double *C, double *B, const int *ldb, double *X, const int *ldx, double *rcond, double *rpvgrw, double *berr, const int *n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, const int *nparams, double *params, double *work, int *iwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static void dgesvxx_(MemorySegment fact, MemorySegment trans, MemorySegment n, MemorySegment nrhs, MemorySegment A, MemorySegment lda, MemorySegment AF, MemorySegment ldaf, MemorySegment ipiv, MemorySegment equed, MemorySegment R, MemorySegment C, MemorySegment B, MemorySegment ldb, MemorySegment X, MemorySegment ldx, MemorySegment rcond, MemorySegment rpvgrw, MemorySegment berr, MemorySegment n_err_bnds, MemorySegment err_bnds_norm, MemorySegment err_bnds_comp, MemorySegment nparams, MemorySegment params, MemorySegment work, MemorySegment iwork, MemorySegment info, long x27, long x28, long x29) {
        var mh$ = dgesvxx_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dgesvxx_", fact, trans, n, nrhs, A, lda, AF, ldaf, ipiv, equed, R, C, B, ldb, X, ldx, rcond, rpvgrw, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params, work, iwork, info, x27, x28, x29);
            }
            mh$.invokeExact(fact, trans, n, nrhs, A, lda, AF, ldaf, ipiv, equed, R, C, B, ldb, X, ldx, rcond, rpvgrw, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params, work, iwork, info, x27, x28, x29);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sgesvxx_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("sgesvxx_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void sgesvxx_(const char *fact, const char *trans, const int *n, const int *nrhs, float *A, const int *lda, float *AF, const int *ldaf, int *ipiv, char *equed, float *R, float *C, float *B, const int *ldb, float *X, const int *ldx, float *rcond, float *rpvgrw, float *berr, const int *n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, const int *nparams, float *params, float *work, int *iwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor sgesvxx_$descriptor() {
        return sgesvxx_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void sgesvxx_(const char *fact, const char *trans, const int *n, const int *nrhs, float *A, const int *lda, float *AF, const int *ldaf, int *ipiv, char *equed, float *R, float *C, float *B, const int *ldb, float *X, const int *ldx, float *rcond, float *rpvgrw, float *berr, const int *n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, const int *nparams, float *params, float *work, int *iwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle sgesvxx_$handle() {
        return sgesvxx_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void sgesvxx_(const char *fact, const char *trans, const int *n, const int *nrhs, float *A, const int *lda, float *AF, const int *ldaf, int *ipiv, char *equed, float *R, float *C, float *B, const int *ldb, float *X, const int *ldx, float *rcond, float *rpvgrw, float *berr, const int *n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, const int *nparams, float *params, float *work, int *iwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment sgesvxx_$address() {
        return sgesvxx_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void sgesvxx_(const char *fact, const char *trans, const int *n, const int *nrhs, float *A, const int *lda, float *AF, const int *ldaf, int *ipiv, char *equed, float *R, float *C, float *B, const int *ldb, float *X, const int *ldx, float *rcond, float *rpvgrw, float *berr, const int *n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, const int *nparams, float *params, float *work, int *iwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static void sgesvxx_(MemorySegment fact, MemorySegment trans, MemorySegment n, MemorySegment nrhs, MemorySegment A, MemorySegment lda, MemorySegment AF, MemorySegment ldaf, MemorySegment ipiv, MemorySegment equed, MemorySegment R, MemorySegment C, MemorySegment B, MemorySegment ldb, MemorySegment X, MemorySegment ldx, MemorySegment rcond, MemorySegment rpvgrw, MemorySegment berr, MemorySegment n_err_bnds, MemorySegment err_bnds_norm, MemorySegment err_bnds_comp, MemorySegment nparams, MemorySegment params, MemorySegment work, MemorySegment iwork, MemorySegment info, long x27, long x28, long x29) {
        var mh$ = sgesvxx_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sgesvxx_", fact, trans, n, nrhs, A, lda, AF, ldaf, ipiv, equed, R, C, B, ldb, X, ldx, rcond, rpvgrw, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params, work, iwork, info, x27, x28, x29);
            }
            mh$.invokeExact(fact, trans, n, nrhs, A, lda, AF, ldaf, ipiv, equed, R, C, B, ldb, X, ldx, rcond, rpvgrw, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params, work, iwork, info, x27, x28, x29);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zgesvxx_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("zgesvxx_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zgesvxx_(const char *fact, const char *trans, const int *n, const int *nrhs, _Complex double *A, const int *lda, _Complex double *AF, const int *ldaf, int *ipiv, char *equed, double *R, double *C, _Complex double *B, const int *ldb, _Complex double *X, const int *ldx, double *rcond, double *rpvgrw, double *berr, const int *n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, const int *nparams, double *params, _Complex double *work, double *rwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor zgesvxx_$descriptor() {
        return zgesvxx_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zgesvxx_(const char *fact, const char *trans, const int *n, const int *nrhs, _Complex double *A, const int *lda, _Complex double *AF, const int *ldaf, int *ipiv, char *equed, double *R, double *C, _Complex double *B, const int *ldb, _Complex double *X, const int *ldx, double *rcond, double *rpvgrw, double *berr, const int *n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, const int *nparams, double *params, _Complex double *work, double *rwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle zgesvxx_$handle() {
        return zgesvxx_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zgesvxx_(const char *fact, const char *trans, const int *n, const int *nrhs, _Complex double *A, const int *lda, _Complex double *AF, const int *ldaf, int *ipiv, char *equed, double *R, double *C, _Complex double *B, const int *ldb, _Complex double *X, const int *ldx, double *rcond, double *rpvgrw, double *berr, const int *n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, const int *nparams, double *params, _Complex double *work, double *rwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment zgesvxx_$address() {
        return zgesvxx_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zgesvxx_(const char *fact, const char *trans, const int *n, const int *nrhs, _Complex double *A, const int *lda, _Complex double *AF, const int *ldaf, int *ipiv, char *equed, double *R, double *C, _Complex double *B, const int *ldb, _Complex double *X, const int *ldx, double *rcond, double *rpvgrw, double *berr, const int *n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, const int *nparams, double *params, _Complex double *work, double *rwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static void zgesvxx_(MemorySegment fact, MemorySegment trans, MemorySegment n, MemorySegment nrhs, MemorySegment A, MemorySegment lda, MemorySegment AF, MemorySegment ldaf, MemorySegment ipiv, MemorySegment equed, MemorySegment R, MemorySegment C, MemorySegment B, MemorySegment ldb, MemorySegment X, MemorySegment ldx, MemorySegment rcond, MemorySegment rpvgrw, MemorySegment berr, MemorySegment n_err_bnds, MemorySegment err_bnds_norm, MemorySegment err_bnds_comp, MemorySegment nparams, MemorySegment params, MemorySegment work, MemorySegment rwork, MemorySegment info, long x27, long x28, long x29) {
        var mh$ = zgesvxx_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zgesvxx_", fact, trans, n, nrhs, A, lda, AF, ldaf, ipiv, equed, R, C, B, ldb, X, ldx, rcond, rpvgrw, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params, work, rwork, info, x27, x28, x29);
            }
            mh$.invokeExact(fact, trans, n, nrhs, A, lda, AF, ldaf, ipiv, equed, R, C, B, ldb, X, ldx, rcond, rpvgrw, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params, work, rwork, info, x27, x28, x29);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cgetf2_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cgetf2_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cgetf2_(const int *m, const int *n, _Complex float *A, const int *lda, int *ipiv, int *info)
     * }
     */
    public static FunctionDescriptor cgetf2_$descriptor() {
        return cgetf2_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cgetf2_(const int *m, const int *n, _Complex float *A, const int *lda, int *ipiv, int *info)
     * }
     */
    public static MethodHandle cgetf2_$handle() {
        return cgetf2_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cgetf2_(const int *m, const int *n, _Complex float *A, const int *lda, int *ipiv, int *info)
     * }
     */
    public static MemorySegment cgetf2_$address() {
        return cgetf2_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cgetf2_(const int *m, const int *n, _Complex float *A, const int *lda, int *ipiv, int *info)
     * }
     */
    public static void cgetf2_(MemorySegment m, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment ipiv, MemorySegment info) {
        var mh$ = cgetf2_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cgetf2_", m, n, A, lda, ipiv, info);
            }
            mh$.invokeExact(m, n, A, lda, ipiv, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dgetf2_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("dgetf2_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dgetf2_(const int *m, const int *n, double *A, const int *lda, int *ipiv, int *info)
     * }
     */
    public static FunctionDescriptor dgetf2_$descriptor() {
        return dgetf2_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dgetf2_(const int *m, const int *n, double *A, const int *lda, int *ipiv, int *info)
     * }
     */
    public static MethodHandle dgetf2_$handle() {
        return dgetf2_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dgetf2_(const int *m, const int *n, double *A, const int *lda, int *ipiv, int *info)
     * }
     */
    public static MemorySegment dgetf2_$address() {
        return dgetf2_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dgetf2_(const int *m, const int *n, double *A, const int *lda, int *ipiv, int *info)
     * }
     */
    public static void dgetf2_(MemorySegment m, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment ipiv, MemorySegment info) {
        var mh$ = dgetf2_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dgetf2_", m, n, A, lda, ipiv, info);
            }
            mh$.invokeExact(m, n, A, lda, ipiv, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sgetf2_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("sgetf2_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void sgetf2_(const int *m, const int *n, float *A, const int *lda, int *ipiv, int *info)
     * }
     */
    public static FunctionDescriptor sgetf2_$descriptor() {
        return sgetf2_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void sgetf2_(const int *m, const int *n, float *A, const int *lda, int *ipiv, int *info)
     * }
     */
    public static MethodHandle sgetf2_$handle() {
        return sgetf2_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void sgetf2_(const int *m, const int *n, float *A, const int *lda, int *ipiv, int *info)
     * }
     */
    public static MemorySegment sgetf2_$address() {
        return sgetf2_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void sgetf2_(const int *m, const int *n, float *A, const int *lda, int *ipiv, int *info)
     * }
     */
    public static void sgetf2_(MemorySegment m, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment ipiv, MemorySegment info) {
        var mh$ = sgetf2_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sgetf2_", m, n, A, lda, ipiv, info);
            }
            mh$.invokeExact(m, n, A, lda, ipiv, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zgetf2_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("zgetf2_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zgetf2_(const int *m, const int *n, _Complex double *A, const int *lda, int *ipiv, int *info)
     * }
     */
    public static FunctionDescriptor zgetf2_$descriptor() {
        return zgetf2_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zgetf2_(const int *m, const int *n, _Complex double *A, const int *lda, int *ipiv, int *info)
     * }
     */
    public static MethodHandle zgetf2_$handle() {
        return zgetf2_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zgetf2_(const int *m, const int *n, _Complex double *A, const int *lda, int *ipiv, int *info)
     * }
     */
    public static MemorySegment zgetf2_$address() {
        return zgetf2_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zgetf2_(const int *m, const int *n, _Complex double *A, const int *lda, int *ipiv, int *info)
     * }
     */
    public static void zgetf2_(MemorySegment m, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment ipiv, MemorySegment info) {
        var mh$ = zgetf2_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zgetf2_", m, n, A, lda, ipiv, info);
            }
            mh$.invokeExact(m, n, A, lda, ipiv, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cgetrf_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cgetrf_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cgetrf_(const int *m, const int *n, _Complex float *A, const int *lda, int *ipiv, int *info)
     * }
     */
    public static FunctionDescriptor cgetrf_$descriptor() {
        return cgetrf_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cgetrf_(const int *m, const int *n, _Complex float *A, const int *lda, int *ipiv, int *info)
     * }
     */
    public static MethodHandle cgetrf_$handle() {
        return cgetrf_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cgetrf_(const int *m, const int *n, _Complex float *A, const int *lda, int *ipiv, int *info)
     * }
     */
    public static MemorySegment cgetrf_$address() {
        return cgetrf_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cgetrf_(const int *m, const int *n, _Complex float *A, const int *lda, int *ipiv, int *info)
     * }
     */
    public static void cgetrf_(MemorySegment m, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment ipiv, MemorySegment info) {
        var mh$ = cgetrf_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cgetrf_", m, n, A, lda, ipiv, info);
            }
            mh$.invokeExact(m, n, A, lda, ipiv, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dgetrf_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("dgetrf_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dgetrf_(const int *m, const int *n, double *A, const int *lda, int *ipiv, int *info)
     * }
     */
    public static FunctionDescriptor dgetrf_$descriptor() {
        return dgetrf_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dgetrf_(const int *m, const int *n, double *A, const int *lda, int *ipiv, int *info)
     * }
     */
    public static MethodHandle dgetrf_$handle() {
        return dgetrf_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dgetrf_(const int *m, const int *n, double *A, const int *lda, int *ipiv, int *info)
     * }
     */
    public static MemorySegment dgetrf_$address() {
        return dgetrf_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dgetrf_(const int *m, const int *n, double *A, const int *lda, int *ipiv, int *info)
     * }
     */
    public static void dgetrf_(MemorySegment m, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment ipiv, MemorySegment info) {
        var mh$ = dgetrf_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dgetrf_", m, n, A, lda, ipiv, info);
            }
            mh$.invokeExact(m, n, A, lda, ipiv, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sgetrf_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("sgetrf_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void sgetrf_(const int *m, const int *n, float *A, const int *lda, int *ipiv, int *info)
     * }
     */
    public static FunctionDescriptor sgetrf_$descriptor() {
        return sgetrf_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void sgetrf_(const int *m, const int *n, float *A, const int *lda, int *ipiv, int *info)
     * }
     */
    public static MethodHandle sgetrf_$handle() {
        return sgetrf_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void sgetrf_(const int *m, const int *n, float *A, const int *lda, int *ipiv, int *info)
     * }
     */
    public static MemorySegment sgetrf_$address() {
        return sgetrf_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void sgetrf_(const int *m, const int *n, float *A, const int *lda, int *ipiv, int *info)
     * }
     */
    public static void sgetrf_(MemorySegment m, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment ipiv, MemorySegment info) {
        var mh$ = sgetrf_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sgetrf_", m, n, A, lda, ipiv, info);
            }
            mh$.invokeExact(m, n, A, lda, ipiv, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zgetrf_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("zgetrf_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zgetrf_(const int *m, const int *n, _Complex double *A, const int *lda, int *ipiv, int *info)
     * }
     */
    public static FunctionDescriptor zgetrf_$descriptor() {
        return zgetrf_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zgetrf_(const int *m, const int *n, _Complex double *A, const int *lda, int *ipiv, int *info)
     * }
     */
    public static MethodHandle zgetrf_$handle() {
        return zgetrf_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zgetrf_(const int *m, const int *n, _Complex double *A, const int *lda, int *ipiv, int *info)
     * }
     */
    public static MemorySegment zgetrf_$address() {
        return zgetrf_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zgetrf_(const int *m, const int *n, _Complex double *A, const int *lda, int *ipiv, int *info)
     * }
     */
    public static void zgetrf_(MemorySegment m, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment ipiv, MemorySegment info) {
        var mh$ = zgetrf_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zgetrf_", m, n, A, lda, ipiv, info);
            }
            mh$.invokeExact(m, n, A, lda, ipiv, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cgetrf2_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cgetrf2_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cgetrf2_(const int *m, const int *n, _Complex float *A, const int *lda, int *ipiv, int *info)
     * }
     */
    public static FunctionDescriptor cgetrf2_$descriptor() {
        return cgetrf2_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cgetrf2_(const int *m, const int *n, _Complex float *A, const int *lda, int *ipiv, int *info)
     * }
     */
    public static MethodHandle cgetrf2_$handle() {
        return cgetrf2_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cgetrf2_(const int *m, const int *n, _Complex float *A, const int *lda, int *ipiv, int *info)
     * }
     */
    public static MemorySegment cgetrf2_$address() {
        return cgetrf2_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cgetrf2_(const int *m, const int *n, _Complex float *A, const int *lda, int *ipiv, int *info)
     * }
     */
    public static void cgetrf2_(MemorySegment m, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment ipiv, MemorySegment info) {
        var mh$ = cgetrf2_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cgetrf2_", m, n, A, lda, ipiv, info);
            }
            mh$.invokeExact(m, n, A, lda, ipiv, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dgetrf2_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("dgetrf2_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dgetrf2_(const int *m, const int *n, double *A, const int *lda, int *ipiv, int *info)
     * }
     */
    public static FunctionDescriptor dgetrf2_$descriptor() {
        return dgetrf2_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dgetrf2_(const int *m, const int *n, double *A, const int *lda, int *ipiv, int *info)
     * }
     */
    public static MethodHandle dgetrf2_$handle() {
        return dgetrf2_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dgetrf2_(const int *m, const int *n, double *A, const int *lda, int *ipiv, int *info)
     * }
     */
    public static MemorySegment dgetrf2_$address() {
        return dgetrf2_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dgetrf2_(const int *m, const int *n, double *A, const int *lda, int *ipiv, int *info)
     * }
     */
    public static void dgetrf2_(MemorySegment m, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment ipiv, MemorySegment info) {
        var mh$ = dgetrf2_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dgetrf2_", m, n, A, lda, ipiv, info);
            }
            mh$.invokeExact(m, n, A, lda, ipiv, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sgetrf2_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("sgetrf2_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void sgetrf2_(const int *m, const int *n, float *A, const int *lda, int *ipiv, int *info)
     * }
     */
    public static FunctionDescriptor sgetrf2_$descriptor() {
        return sgetrf2_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void sgetrf2_(const int *m, const int *n, float *A, const int *lda, int *ipiv, int *info)
     * }
     */
    public static MethodHandle sgetrf2_$handle() {
        return sgetrf2_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void sgetrf2_(const int *m, const int *n, float *A, const int *lda, int *ipiv, int *info)
     * }
     */
    public static MemorySegment sgetrf2_$address() {
        return sgetrf2_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void sgetrf2_(const int *m, const int *n, float *A, const int *lda, int *ipiv, int *info)
     * }
     */
    public static void sgetrf2_(MemorySegment m, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment ipiv, MemorySegment info) {
        var mh$ = sgetrf2_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sgetrf2_", m, n, A, lda, ipiv, info);
            }
            mh$.invokeExact(m, n, A, lda, ipiv, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zgetrf2_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("zgetrf2_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zgetrf2_(const int *m, const int *n, _Complex double *A, const int *lda, int *ipiv, int *info)
     * }
     */
    public static FunctionDescriptor zgetrf2_$descriptor() {
        return zgetrf2_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zgetrf2_(const int *m, const int *n, _Complex double *A, const int *lda, int *ipiv, int *info)
     * }
     */
    public static MethodHandle zgetrf2_$handle() {
        return zgetrf2_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zgetrf2_(const int *m, const int *n, _Complex double *A, const int *lda, int *ipiv, int *info)
     * }
     */
    public static MemorySegment zgetrf2_$address() {
        return zgetrf2_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zgetrf2_(const int *m, const int *n, _Complex double *A, const int *lda, int *ipiv, int *info)
     * }
     */
    public static void zgetrf2_(MemorySegment m, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment ipiv, MemorySegment info) {
        var mh$ = zgetrf2_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zgetrf2_", m, n, A, lda, ipiv, info);
            }
            mh$.invokeExact(m, n, A, lda, ipiv, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cgetri_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cgetri_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cgetri_(const int *n, _Complex float *A, const int *lda, const int *ipiv, _Complex float *work, const int *lwork, int *info)
     * }
     */
    public static FunctionDescriptor cgetri_$descriptor() {
        return cgetri_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cgetri_(const int *n, _Complex float *A, const int *lda, const int *ipiv, _Complex float *work, const int *lwork, int *info)
     * }
     */
    public static MethodHandle cgetri_$handle() {
        return cgetri_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cgetri_(const int *n, _Complex float *A, const int *lda, const int *ipiv, _Complex float *work, const int *lwork, int *info)
     * }
     */
    public static MemorySegment cgetri_$address() {
        return cgetri_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cgetri_(const int *n, _Complex float *A, const int *lda, const int *ipiv, _Complex float *work, const int *lwork, int *info)
     * }
     */
    public static void cgetri_(MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment ipiv, MemorySegment work, MemorySegment lwork, MemorySegment info) {
        var mh$ = cgetri_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cgetri_", n, A, lda, ipiv, work, lwork, info);
            }
            mh$.invokeExact(n, A, lda, ipiv, work, lwork, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dgetri_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("dgetri_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dgetri_(const int *n, double *A, const int *lda, const int *ipiv, double *work, const int *lwork, int *info)
     * }
     */
    public static FunctionDescriptor dgetri_$descriptor() {
        return dgetri_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dgetri_(const int *n, double *A, const int *lda, const int *ipiv, double *work, const int *lwork, int *info)
     * }
     */
    public static MethodHandle dgetri_$handle() {
        return dgetri_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dgetri_(const int *n, double *A, const int *lda, const int *ipiv, double *work, const int *lwork, int *info)
     * }
     */
    public static MemorySegment dgetri_$address() {
        return dgetri_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dgetri_(const int *n, double *A, const int *lda, const int *ipiv, double *work, const int *lwork, int *info)
     * }
     */
    public static void dgetri_(MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment ipiv, MemorySegment work, MemorySegment lwork, MemorySegment info) {
        var mh$ = dgetri_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dgetri_", n, A, lda, ipiv, work, lwork, info);
            }
            mh$.invokeExact(n, A, lda, ipiv, work, lwork, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sgetri_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("sgetri_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void sgetri_(const int *n, float *A, const int *lda, const int *ipiv, float *work, const int *lwork, int *info)
     * }
     */
    public static FunctionDescriptor sgetri_$descriptor() {
        return sgetri_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void sgetri_(const int *n, float *A, const int *lda, const int *ipiv, float *work, const int *lwork, int *info)
     * }
     */
    public static MethodHandle sgetri_$handle() {
        return sgetri_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void sgetri_(const int *n, float *A, const int *lda, const int *ipiv, float *work, const int *lwork, int *info)
     * }
     */
    public static MemorySegment sgetri_$address() {
        return sgetri_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void sgetri_(const int *n, float *A, const int *lda, const int *ipiv, float *work, const int *lwork, int *info)
     * }
     */
    public static void sgetri_(MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment ipiv, MemorySegment work, MemorySegment lwork, MemorySegment info) {
        var mh$ = sgetri_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sgetri_", n, A, lda, ipiv, work, lwork, info);
            }
            mh$.invokeExact(n, A, lda, ipiv, work, lwork, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zgetri_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("zgetri_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zgetri_(const int *n, _Complex double *A, const int *lda, const int *ipiv, _Complex double *work, const int *lwork, int *info)
     * }
     */
    public static FunctionDescriptor zgetri_$descriptor() {
        return zgetri_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zgetri_(const int *n, _Complex double *A, const int *lda, const int *ipiv, _Complex double *work, const int *lwork, int *info)
     * }
     */
    public static MethodHandle zgetri_$handle() {
        return zgetri_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zgetri_(const int *n, _Complex double *A, const int *lda, const int *ipiv, _Complex double *work, const int *lwork, int *info)
     * }
     */
    public static MemorySegment zgetri_$address() {
        return zgetri_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zgetri_(const int *n, _Complex double *A, const int *lda, const int *ipiv, _Complex double *work, const int *lwork, int *info)
     * }
     */
    public static void zgetri_(MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment ipiv, MemorySegment work, MemorySegment lwork, MemorySegment info) {
        var mh$ = zgetri_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zgetri_", n, A, lda, ipiv, work, lwork, info);
            }
            mh$.invokeExact(n, A, lda, ipiv, work, lwork, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cgetrs_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cgetrs_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cgetrs_(const char *trans, const int *n, const int *nrhs, const _Complex float *A, const int *lda, const int *ipiv, _Complex float *B, const int *ldb, int *info, size_t)
     * }
     */
    public static FunctionDescriptor cgetrs_$descriptor() {
        return cgetrs_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cgetrs_(const char *trans, const int *n, const int *nrhs, const _Complex float *A, const int *lda, const int *ipiv, _Complex float *B, const int *ldb, int *info, size_t)
     * }
     */
    public static MethodHandle cgetrs_$handle() {
        return cgetrs_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cgetrs_(const char *trans, const int *n, const int *nrhs, const _Complex float *A, const int *lda, const int *ipiv, _Complex float *B, const int *ldb, int *info, size_t)
     * }
     */
    public static MemorySegment cgetrs_$address() {
        return cgetrs_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cgetrs_(const char *trans, const int *n, const int *nrhs, const _Complex float *A, const int *lda, const int *ipiv, _Complex float *B, const int *ldb, int *info, size_t)
     * }
     */
    public static void cgetrs_(MemorySegment trans, MemorySegment n, MemorySegment nrhs, MemorySegment A, MemorySegment lda, MemorySegment ipiv, MemorySegment B, MemorySegment ldb, MemorySegment info, long x9) {
        var mh$ = cgetrs_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cgetrs_", trans, n, nrhs, A, lda, ipiv, B, ldb, info, x9);
            }
            mh$.invokeExact(trans, n, nrhs, A, lda, ipiv, B, ldb, info, x9);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dgetrs_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("dgetrs_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dgetrs_(const char *trans, const int *n, const int *nrhs, const double *A, const int *lda, const int *ipiv, double *B, const int *ldb, int *info, size_t)
     * }
     */
    public static FunctionDescriptor dgetrs_$descriptor() {
        return dgetrs_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dgetrs_(const char *trans, const int *n, const int *nrhs, const double *A, const int *lda, const int *ipiv, double *B, const int *ldb, int *info, size_t)
     * }
     */
    public static MethodHandle dgetrs_$handle() {
        return dgetrs_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dgetrs_(const char *trans, const int *n, const int *nrhs, const double *A, const int *lda, const int *ipiv, double *B, const int *ldb, int *info, size_t)
     * }
     */
    public static MemorySegment dgetrs_$address() {
        return dgetrs_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dgetrs_(const char *trans, const int *n, const int *nrhs, const double *A, const int *lda, const int *ipiv, double *B, const int *ldb, int *info, size_t)
     * }
     */
    public static void dgetrs_(MemorySegment trans, MemorySegment n, MemorySegment nrhs, MemorySegment A, MemorySegment lda, MemorySegment ipiv, MemorySegment B, MemorySegment ldb, MemorySegment info, long x9) {
        var mh$ = dgetrs_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dgetrs_", trans, n, nrhs, A, lda, ipiv, B, ldb, info, x9);
            }
            mh$.invokeExact(trans, n, nrhs, A, lda, ipiv, B, ldb, info, x9);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sgetrs_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("sgetrs_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void sgetrs_(const char *trans, const int *n, const int *nrhs, const float *A, const int *lda, const int *ipiv, float *B, const int *ldb, int *info, size_t)
     * }
     */
    public static FunctionDescriptor sgetrs_$descriptor() {
        return sgetrs_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void sgetrs_(const char *trans, const int *n, const int *nrhs, const float *A, const int *lda, const int *ipiv, float *B, const int *ldb, int *info, size_t)
     * }
     */
    public static MethodHandle sgetrs_$handle() {
        return sgetrs_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void sgetrs_(const char *trans, const int *n, const int *nrhs, const float *A, const int *lda, const int *ipiv, float *B, const int *ldb, int *info, size_t)
     * }
     */
    public static MemorySegment sgetrs_$address() {
        return sgetrs_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void sgetrs_(const char *trans, const int *n, const int *nrhs, const float *A, const int *lda, const int *ipiv, float *B, const int *ldb, int *info, size_t)
     * }
     */
    public static void sgetrs_(MemorySegment trans, MemorySegment n, MemorySegment nrhs, MemorySegment A, MemorySegment lda, MemorySegment ipiv, MemorySegment B, MemorySegment ldb, MemorySegment info, long x9) {
        var mh$ = sgetrs_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sgetrs_", trans, n, nrhs, A, lda, ipiv, B, ldb, info, x9);
            }
            mh$.invokeExact(trans, n, nrhs, A, lda, ipiv, B, ldb, info, x9);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zgetrs_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("zgetrs_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zgetrs_(const char *trans, const int *n, const int *nrhs, const _Complex double *A, const int *lda, const int *ipiv, _Complex double *B, const int *ldb, int *info, size_t)
     * }
     */
    public static FunctionDescriptor zgetrs_$descriptor() {
        return zgetrs_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zgetrs_(const char *trans, const int *n, const int *nrhs, const _Complex double *A, const int *lda, const int *ipiv, _Complex double *B, const int *ldb, int *info, size_t)
     * }
     */
    public static MethodHandle zgetrs_$handle() {
        return zgetrs_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zgetrs_(const char *trans, const int *n, const int *nrhs, const _Complex double *A, const int *lda, const int *ipiv, _Complex double *B, const int *ldb, int *info, size_t)
     * }
     */
    public static MemorySegment zgetrs_$address() {
        return zgetrs_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zgetrs_(const char *trans, const int *n, const int *nrhs, const _Complex double *A, const int *lda, const int *ipiv, _Complex double *B, const int *ldb, int *info, size_t)
     * }
     */
    public static void zgetrs_(MemorySegment trans, MemorySegment n, MemorySegment nrhs, MemorySegment A, MemorySegment lda, MemorySegment ipiv, MemorySegment B, MemorySegment ldb, MemorySegment info, long x9) {
        var mh$ = zgetrs_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zgetrs_", trans, n, nrhs, A, lda, ipiv, B, ldb, info, x9);
            }
            mh$.invokeExact(trans, n, nrhs, A, lda, ipiv, B, ldb, info, x9);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cgetsls_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cgetsls_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cgetsls_(const char *trans, const int *m, const int *n, const int *nrhs, _Complex float *A, const int *lda, _Complex float *B, const int *ldb, _Complex float *work, const int *lwork, int *info, size_t)
     * }
     */
    public static FunctionDescriptor cgetsls_$descriptor() {
        return cgetsls_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cgetsls_(const char *trans, const int *m, const int *n, const int *nrhs, _Complex float *A, const int *lda, _Complex float *B, const int *ldb, _Complex float *work, const int *lwork, int *info, size_t)
     * }
     */
    public static MethodHandle cgetsls_$handle() {
        return cgetsls_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cgetsls_(const char *trans, const int *m, const int *n, const int *nrhs, _Complex float *A, const int *lda, _Complex float *B, const int *ldb, _Complex float *work, const int *lwork, int *info, size_t)
     * }
     */
    public static MemorySegment cgetsls_$address() {
        return cgetsls_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cgetsls_(const char *trans, const int *m, const int *n, const int *nrhs, _Complex float *A, const int *lda, _Complex float *B, const int *ldb, _Complex float *work, const int *lwork, int *info, size_t)
     * }
     */
    public static void cgetsls_(MemorySegment trans, MemorySegment m, MemorySegment n, MemorySegment nrhs, MemorySegment A, MemorySegment lda, MemorySegment B, MemorySegment ldb, MemorySegment work, MemorySegment lwork, MemorySegment info, long x11) {
        var mh$ = cgetsls_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cgetsls_", trans, m, n, nrhs, A, lda, B, ldb, work, lwork, info, x11);
            }
            mh$.invokeExact(trans, m, n, nrhs, A, lda, B, ldb, work, lwork, info, x11);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dgetsls_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("dgetsls_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dgetsls_(const char *trans, const int *m, const int *n, const int *nrhs, double *A, const int *lda, double *B, const int *ldb, double *work, const int *lwork, int *info, size_t)
     * }
     */
    public static FunctionDescriptor dgetsls_$descriptor() {
        return dgetsls_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dgetsls_(const char *trans, const int *m, const int *n, const int *nrhs, double *A, const int *lda, double *B, const int *ldb, double *work, const int *lwork, int *info, size_t)
     * }
     */
    public static MethodHandle dgetsls_$handle() {
        return dgetsls_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dgetsls_(const char *trans, const int *m, const int *n, const int *nrhs, double *A, const int *lda, double *B, const int *ldb, double *work, const int *lwork, int *info, size_t)
     * }
     */
    public static MemorySegment dgetsls_$address() {
        return dgetsls_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dgetsls_(const char *trans, const int *m, const int *n, const int *nrhs, double *A, const int *lda, double *B, const int *ldb, double *work, const int *lwork, int *info, size_t)
     * }
     */
    public static void dgetsls_(MemorySegment trans, MemorySegment m, MemorySegment n, MemorySegment nrhs, MemorySegment A, MemorySegment lda, MemorySegment B, MemorySegment ldb, MemorySegment work, MemorySegment lwork, MemorySegment info, long x11) {
        var mh$ = dgetsls_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dgetsls_", trans, m, n, nrhs, A, lda, B, ldb, work, lwork, info, x11);
            }
            mh$.invokeExact(trans, m, n, nrhs, A, lda, B, ldb, work, lwork, info, x11);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sgetsls_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("sgetsls_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void sgetsls_(const char *trans, const int *m, const int *n, const int *nrhs, float *A, const int *lda, float *B, const int *ldb, float *work, const int *lwork, int *info, size_t)
     * }
     */
    public static FunctionDescriptor sgetsls_$descriptor() {
        return sgetsls_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void sgetsls_(const char *trans, const int *m, const int *n, const int *nrhs, float *A, const int *lda, float *B, const int *ldb, float *work, const int *lwork, int *info, size_t)
     * }
     */
    public static MethodHandle sgetsls_$handle() {
        return sgetsls_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void sgetsls_(const char *trans, const int *m, const int *n, const int *nrhs, float *A, const int *lda, float *B, const int *ldb, float *work, const int *lwork, int *info, size_t)
     * }
     */
    public static MemorySegment sgetsls_$address() {
        return sgetsls_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void sgetsls_(const char *trans, const int *m, const int *n, const int *nrhs, float *A, const int *lda, float *B, const int *ldb, float *work, const int *lwork, int *info, size_t)
     * }
     */
    public static void sgetsls_(MemorySegment trans, MemorySegment m, MemorySegment n, MemorySegment nrhs, MemorySegment A, MemorySegment lda, MemorySegment B, MemorySegment ldb, MemorySegment work, MemorySegment lwork, MemorySegment info, long x11) {
        var mh$ = sgetsls_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sgetsls_", trans, m, n, nrhs, A, lda, B, ldb, work, lwork, info, x11);
            }
            mh$.invokeExact(trans, m, n, nrhs, A, lda, B, ldb, work, lwork, info, x11);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zgetsls_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("zgetsls_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zgetsls_(const char *trans, const int *m, const int *n, const int *nrhs, _Complex double *A, const int *lda, _Complex double *B, const int *ldb, _Complex double *work, const int *lwork, int *info, size_t)
     * }
     */
    public static FunctionDescriptor zgetsls_$descriptor() {
        return zgetsls_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zgetsls_(const char *trans, const int *m, const int *n, const int *nrhs, _Complex double *A, const int *lda, _Complex double *B, const int *ldb, _Complex double *work, const int *lwork, int *info, size_t)
     * }
     */
    public static MethodHandle zgetsls_$handle() {
        return zgetsls_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zgetsls_(const char *trans, const int *m, const int *n, const int *nrhs, _Complex double *A, const int *lda, _Complex double *B, const int *ldb, _Complex double *work, const int *lwork, int *info, size_t)
     * }
     */
    public static MemorySegment zgetsls_$address() {
        return zgetsls_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zgetsls_(const char *trans, const int *m, const int *n, const int *nrhs, _Complex double *A, const int *lda, _Complex double *B, const int *ldb, _Complex double *work, const int *lwork, int *info, size_t)
     * }
     */
    public static void zgetsls_(MemorySegment trans, MemorySegment m, MemorySegment n, MemorySegment nrhs, MemorySegment A, MemorySegment lda, MemorySegment B, MemorySegment ldb, MemorySegment work, MemorySegment lwork, MemorySegment info, long x11) {
        var mh$ = zgetsls_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zgetsls_", trans, m, n, nrhs, A, lda, B, ldb, work, lwork, info, x11);
            }
            mh$.invokeExact(trans, m, n, nrhs, A, lda, B, ldb, work, lwork, info, x11);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cgetsqrhrt_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cgetsqrhrt_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cgetsqrhrt_(const int *m, const int *n, const int *mb1, const int *nb1, const int *nb2, _Complex float *A, const int *lda, _Complex float *T, const int *ldt, _Complex float *work, const int *lwork, int *info)
     * }
     */
    public static FunctionDescriptor cgetsqrhrt_$descriptor() {
        return cgetsqrhrt_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cgetsqrhrt_(const int *m, const int *n, const int *mb1, const int *nb1, const int *nb2, _Complex float *A, const int *lda, _Complex float *T, const int *ldt, _Complex float *work, const int *lwork, int *info)
     * }
     */
    public static MethodHandle cgetsqrhrt_$handle() {
        return cgetsqrhrt_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cgetsqrhrt_(const int *m, const int *n, const int *mb1, const int *nb1, const int *nb2, _Complex float *A, const int *lda, _Complex float *T, const int *ldt, _Complex float *work, const int *lwork, int *info)
     * }
     */
    public static MemorySegment cgetsqrhrt_$address() {
        return cgetsqrhrt_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cgetsqrhrt_(const int *m, const int *n, const int *mb1, const int *nb1, const int *nb2, _Complex float *A, const int *lda, _Complex float *T, const int *ldt, _Complex float *work, const int *lwork, int *info)
     * }
     */
    public static void cgetsqrhrt_(MemorySegment m, MemorySegment n, MemorySegment mb1, MemorySegment nb1, MemorySegment nb2, MemorySegment A, MemorySegment lda, MemorySegment T, MemorySegment ldt, MemorySegment work, MemorySegment lwork, MemorySegment info) {
        var mh$ = cgetsqrhrt_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cgetsqrhrt_", m, n, mb1, nb1, nb2, A, lda, T, ldt, work, lwork, info);
            }
            mh$.invokeExact(m, n, mb1, nb1, nb2, A, lda, T, ldt, work, lwork, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dgetsqrhrt_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("dgetsqrhrt_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dgetsqrhrt_(const int *m, const int *n, const int *mb1, const int *nb1, const int *nb2, double *A, const int *lda, double *T, const int *ldt, double *work, const int *lwork, int *info)
     * }
     */
    public static FunctionDescriptor dgetsqrhrt_$descriptor() {
        return dgetsqrhrt_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dgetsqrhrt_(const int *m, const int *n, const int *mb1, const int *nb1, const int *nb2, double *A, const int *lda, double *T, const int *ldt, double *work, const int *lwork, int *info)
     * }
     */
    public static MethodHandle dgetsqrhrt_$handle() {
        return dgetsqrhrt_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dgetsqrhrt_(const int *m, const int *n, const int *mb1, const int *nb1, const int *nb2, double *A, const int *lda, double *T, const int *ldt, double *work, const int *lwork, int *info)
     * }
     */
    public static MemorySegment dgetsqrhrt_$address() {
        return dgetsqrhrt_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dgetsqrhrt_(const int *m, const int *n, const int *mb1, const int *nb1, const int *nb2, double *A, const int *lda, double *T, const int *ldt, double *work, const int *lwork, int *info)
     * }
     */
    public static void dgetsqrhrt_(MemorySegment m, MemorySegment n, MemorySegment mb1, MemorySegment nb1, MemorySegment nb2, MemorySegment A, MemorySegment lda, MemorySegment T, MemorySegment ldt, MemorySegment work, MemorySegment lwork, MemorySegment info) {
        var mh$ = dgetsqrhrt_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dgetsqrhrt_", m, n, mb1, nb1, nb2, A, lda, T, ldt, work, lwork, info);
            }
            mh$.invokeExact(m, n, mb1, nb1, nb2, A, lda, T, ldt, work, lwork, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sgetsqrhrt_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("sgetsqrhrt_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void sgetsqrhrt_(const int *m, const int *n, const int *mb1, const int *nb1, const int *nb2, float *A, const int *lda, float *T, const int *ldt, float *work, const int *lwork, int *info)
     * }
     */
    public static FunctionDescriptor sgetsqrhrt_$descriptor() {
        return sgetsqrhrt_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void sgetsqrhrt_(const int *m, const int *n, const int *mb1, const int *nb1, const int *nb2, float *A, const int *lda, float *T, const int *ldt, float *work, const int *lwork, int *info)
     * }
     */
    public static MethodHandle sgetsqrhrt_$handle() {
        return sgetsqrhrt_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void sgetsqrhrt_(const int *m, const int *n, const int *mb1, const int *nb1, const int *nb2, float *A, const int *lda, float *T, const int *ldt, float *work, const int *lwork, int *info)
     * }
     */
    public static MemorySegment sgetsqrhrt_$address() {
        return sgetsqrhrt_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void sgetsqrhrt_(const int *m, const int *n, const int *mb1, const int *nb1, const int *nb2, float *A, const int *lda, float *T, const int *ldt, float *work, const int *lwork, int *info)
     * }
     */
    public static void sgetsqrhrt_(MemorySegment m, MemorySegment n, MemorySegment mb1, MemorySegment nb1, MemorySegment nb2, MemorySegment A, MemorySegment lda, MemorySegment T, MemorySegment ldt, MemorySegment work, MemorySegment lwork, MemorySegment info) {
        var mh$ = sgetsqrhrt_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sgetsqrhrt_", m, n, mb1, nb1, nb2, A, lda, T, ldt, work, lwork, info);
            }
            mh$.invokeExact(m, n, mb1, nb1, nb2, A, lda, T, ldt, work, lwork, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zgetsqrhrt_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("zgetsqrhrt_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zgetsqrhrt_(const int *m, const int *n, const int *mb1, const int *nb1, const int *nb2, _Complex double *A, const int *lda, _Complex double *T, const int *ldt, _Complex double *work, const int *lwork, int *info)
     * }
     */
    public static FunctionDescriptor zgetsqrhrt_$descriptor() {
        return zgetsqrhrt_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zgetsqrhrt_(const int *m, const int *n, const int *mb1, const int *nb1, const int *nb2, _Complex double *A, const int *lda, _Complex double *T, const int *ldt, _Complex double *work, const int *lwork, int *info)
     * }
     */
    public static MethodHandle zgetsqrhrt_$handle() {
        return zgetsqrhrt_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zgetsqrhrt_(const int *m, const int *n, const int *mb1, const int *nb1, const int *nb2, _Complex double *A, const int *lda, _Complex double *T, const int *ldt, _Complex double *work, const int *lwork, int *info)
     * }
     */
    public static MemorySegment zgetsqrhrt_$address() {
        return zgetsqrhrt_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zgetsqrhrt_(const int *m, const int *n, const int *mb1, const int *nb1, const int *nb2, _Complex double *A, const int *lda, _Complex double *T, const int *ldt, _Complex double *work, const int *lwork, int *info)
     * }
     */
    public static void zgetsqrhrt_(MemorySegment m, MemorySegment n, MemorySegment mb1, MemorySegment nb1, MemorySegment nb2, MemorySegment A, MemorySegment lda, MemorySegment T, MemorySegment ldt, MemorySegment work, MemorySegment lwork, MemorySegment info) {
        var mh$ = zgetsqrhrt_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zgetsqrhrt_", m, n, mb1, nb1, nb2, A, lda, T, ldt, work, lwork, info);
            }
            mh$.invokeExact(m, n, mb1, nb1, nb2, A, lda, T, ldt, work, lwork, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cggbak_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cggbak_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cggbak_(const char *job, const char *side, const int *n, const int *ilo, const int *ihi, const float *lscale, const float *rscale, const int *m, _Complex float *V, const int *ldv, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor cggbak_$descriptor() {
        return cggbak_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cggbak_(const char *job, const char *side, const int *n, const int *ilo, const int *ihi, const float *lscale, const float *rscale, const int *m, _Complex float *V, const int *ldv, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle cggbak_$handle() {
        return cggbak_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cggbak_(const char *job, const char *side, const int *n, const int *ilo, const int *ihi, const float *lscale, const float *rscale, const int *m, _Complex float *V, const int *ldv, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment cggbak_$address() {
        return cggbak_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cggbak_(const char *job, const char *side, const int *n, const int *ilo, const int *ihi, const float *lscale, const float *rscale, const int *m, _Complex float *V, const int *ldv, int *info, size_t, size_t)
     * }
     */
    public static void cggbak_(MemorySegment job, MemorySegment side, MemorySegment n, MemorySegment ilo, MemorySegment ihi, MemorySegment lscale, MemorySegment rscale, MemorySegment m, MemorySegment V, MemorySegment ldv, MemorySegment info, long x11, long x12) {
        var mh$ = cggbak_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cggbak_", job, side, n, ilo, ihi, lscale, rscale, m, V, ldv, info, x11, x12);
            }
            mh$.invokeExact(job, side, n, ilo, ihi, lscale, rscale, m, V, ldv, info, x11, x12);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dggbak_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("dggbak_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dggbak_(const char *job, const char *side, const int *n, const int *ilo, const int *ihi, const double *lscale, const double *rscale, const int *m, double *V, const int *ldv, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor dggbak_$descriptor() {
        return dggbak_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dggbak_(const char *job, const char *side, const int *n, const int *ilo, const int *ihi, const double *lscale, const double *rscale, const int *m, double *V, const int *ldv, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle dggbak_$handle() {
        return dggbak_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dggbak_(const char *job, const char *side, const int *n, const int *ilo, const int *ihi, const double *lscale, const double *rscale, const int *m, double *V, const int *ldv, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment dggbak_$address() {
        return dggbak_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dggbak_(const char *job, const char *side, const int *n, const int *ilo, const int *ihi, const double *lscale, const double *rscale, const int *m, double *V, const int *ldv, int *info, size_t, size_t)
     * }
     */
    public static void dggbak_(MemorySegment job, MemorySegment side, MemorySegment n, MemorySegment ilo, MemorySegment ihi, MemorySegment lscale, MemorySegment rscale, MemorySegment m, MemorySegment V, MemorySegment ldv, MemorySegment info, long x11, long x12) {
        var mh$ = dggbak_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dggbak_", job, side, n, ilo, ihi, lscale, rscale, m, V, ldv, info, x11, x12);
            }
            mh$.invokeExact(job, side, n, ilo, ihi, lscale, rscale, m, V, ldv, info, x11, x12);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sggbak_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("sggbak_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void sggbak_(const char *job, const char *side, const int *n, const int *ilo, const int *ihi, const float *lscale, const float *rscale, const int *m, float *V, const int *ldv, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor sggbak_$descriptor() {
        return sggbak_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void sggbak_(const char *job, const char *side, const int *n, const int *ilo, const int *ihi, const float *lscale, const float *rscale, const int *m, float *V, const int *ldv, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle sggbak_$handle() {
        return sggbak_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void sggbak_(const char *job, const char *side, const int *n, const int *ilo, const int *ihi, const float *lscale, const float *rscale, const int *m, float *V, const int *ldv, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment sggbak_$address() {
        return sggbak_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void sggbak_(const char *job, const char *side, const int *n, const int *ilo, const int *ihi, const float *lscale, const float *rscale, const int *m, float *V, const int *ldv, int *info, size_t, size_t)
     * }
     */
    public static void sggbak_(MemorySegment job, MemorySegment side, MemorySegment n, MemorySegment ilo, MemorySegment ihi, MemorySegment lscale, MemorySegment rscale, MemorySegment m, MemorySegment V, MemorySegment ldv, MemorySegment info, long x11, long x12) {
        var mh$ = sggbak_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sggbak_", job, side, n, ilo, ihi, lscale, rscale, m, V, ldv, info, x11, x12);
            }
            mh$.invokeExact(job, side, n, ilo, ihi, lscale, rscale, m, V, ldv, info, x11, x12);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zggbak_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("zggbak_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zggbak_(const char *job, const char *side, const int *n, const int *ilo, const int *ihi, const double *lscale, const double *rscale, const int *m, _Complex double *V, const int *ldv, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor zggbak_$descriptor() {
        return zggbak_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zggbak_(const char *job, const char *side, const int *n, const int *ilo, const int *ihi, const double *lscale, const double *rscale, const int *m, _Complex double *V, const int *ldv, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle zggbak_$handle() {
        return zggbak_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zggbak_(const char *job, const char *side, const int *n, const int *ilo, const int *ihi, const double *lscale, const double *rscale, const int *m, _Complex double *V, const int *ldv, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment zggbak_$address() {
        return zggbak_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zggbak_(const char *job, const char *side, const int *n, const int *ilo, const int *ihi, const double *lscale, const double *rscale, const int *m, _Complex double *V, const int *ldv, int *info, size_t, size_t)
     * }
     */
    public static void zggbak_(MemorySegment job, MemorySegment side, MemorySegment n, MemorySegment ilo, MemorySegment ihi, MemorySegment lscale, MemorySegment rscale, MemorySegment m, MemorySegment V, MemorySegment ldv, MemorySegment info, long x11, long x12) {
        var mh$ = zggbak_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zggbak_", job, side, n, ilo, ihi, lscale, rscale, m, V, ldv, info, x11, x12);
            }
            mh$.invokeExact(job, side, n, ilo, ihi, lscale, rscale, m, V, ldv, info, x11, x12);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cggbal_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cggbal_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cggbal_(const char *job, const int *n, _Complex float *A, const int *lda, _Complex float *B, const int *ldb, int *ilo, int *ihi, float *lscale, float *rscale, float *work, int *info, size_t)
     * }
     */
    public static FunctionDescriptor cggbal_$descriptor() {
        return cggbal_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cggbal_(const char *job, const int *n, _Complex float *A, const int *lda, _Complex float *B, const int *ldb, int *ilo, int *ihi, float *lscale, float *rscale, float *work, int *info, size_t)
     * }
     */
    public static MethodHandle cggbal_$handle() {
        return cggbal_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cggbal_(const char *job, const int *n, _Complex float *A, const int *lda, _Complex float *B, const int *ldb, int *ilo, int *ihi, float *lscale, float *rscale, float *work, int *info, size_t)
     * }
     */
    public static MemorySegment cggbal_$address() {
        return cggbal_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cggbal_(const char *job, const int *n, _Complex float *A, const int *lda, _Complex float *B, const int *ldb, int *ilo, int *ihi, float *lscale, float *rscale, float *work, int *info, size_t)
     * }
     */
    public static void cggbal_(MemorySegment job, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment B, MemorySegment ldb, MemorySegment ilo, MemorySegment ihi, MemorySegment lscale, MemorySegment rscale, MemorySegment work, MemorySegment info, long x12) {
        var mh$ = cggbal_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cggbal_", job, n, A, lda, B, ldb, ilo, ihi, lscale, rscale, work, info, x12);
            }
            mh$.invokeExact(job, n, A, lda, B, ldb, ilo, ihi, lscale, rscale, work, info, x12);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dggbal_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("dggbal_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dggbal_(const char *job, const int *n, double *A, const int *lda, double *B, const int *ldb, int *ilo, int *ihi, double *lscale, double *rscale, double *work, int *info, size_t)
     * }
     */
    public static FunctionDescriptor dggbal_$descriptor() {
        return dggbal_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dggbal_(const char *job, const int *n, double *A, const int *lda, double *B, const int *ldb, int *ilo, int *ihi, double *lscale, double *rscale, double *work, int *info, size_t)
     * }
     */
    public static MethodHandle dggbal_$handle() {
        return dggbal_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dggbal_(const char *job, const int *n, double *A, const int *lda, double *B, const int *ldb, int *ilo, int *ihi, double *lscale, double *rscale, double *work, int *info, size_t)
     * }
     */
    public static MemorySegment dggbal_$address() {
        return dggbal_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dggbal_(const char *job, const int *n, double *A, const int *lda, double *B, const int *ldb, int *ilo, int *ihi, double *lscale, double *rscale, double *work, int *info, size_t)
     * }
     */
    public static void dggbal_(MemorySegment job, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment B, MemorySegment ldb, MemorySegment ilo, MemorySegment ihi, MemorySegment lscale, MemorySegment rscale, MemorySegment work, MemorySegment info, long x12) {
        var mh$ = dggbal_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dggbal_", job, n, A, lda, B, ldb, ilo, ihi, lscale, rscale, work, info, x12);
            }
            mh$.invokeExact(job, n, A, lda, B, ldb, ilo, ihi, lscale, rscale, work, info, x12);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sggbal_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("sggbal_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void sggbal_(const char *job, const int *n, float *A, const int *lda, float *B, const int *ldb, int *ilo, int *ihi, float *lscale, float *rscale, float *work, int *info, size_t)
     * }
     */
    public static FunctionDescriptor sggbal_$descriptor() {
        return sggbal_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void sggbal_(const char *job, const int *n, float *A, const int *lda, float *B, const int *ldb, int *ilo, int *ihi, float *lscale, float *rscale, float *work, int *info, size_t)
     * }
     */
    public static MethodHandle sggbal_$handle() {
        return sggbal_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void sggbal_(const char *job, const int *n, float *A, const int *lda, float *B, const int *ldb, int *ilo, int *ihi, float *lscale, float *rscale, float *work, int *info, size_t)
     * }
     */
    public static MemorySegment sggbal_$address() {
        return sggbal_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void sggbal_(const char *job, const int *n, float *A, const int *lda, float *B, const int *ldb, int *ilo, int *ihi, float *lscale, float *rscale, float *work, int *info, size_t)
     * }
     */
    public static void sggbal_(MemorySegment job, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment B, MemorySegment ldb, MemorySegment ilo, MemorySegment ihi, MemorySegment lscale, MemorySegment rscale, MemorySegment work, MemorySegment info, long x12) {
        var mh$ = sggbal_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sggbal_", job, n, A, lda, B, ldb, ilo, ihi, lscale, rscale, work, info, x12);
            }
            mh$.invokeExact(job, n, A, lda, B, ldb, ilo, ihi, lscale, rscale, work, info, x12);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zggbal_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("zggbal_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zggbal_(const char *job, const int *n, _Complex double *A, const int *lda, _Complex double *B, const int *ldb, int *ilo, int *ihi, double *lscale, double *rscale, double *work, int *info, size_t)
     * }
     */
    public static FunctionDescriptor zggbal_$descriptor() {
        return zggbal_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zggbal_(const char *job, const int *n, _Complex double *A, const int *lda, _Complex double *B, const int *ldb, int *ilo, int *ihi, double *lscale, double *rscale, double *work, int *info, size_t)
     * }
     */
    public static MethodHandle zggbal_$handle() {
        return zggbal_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zggbal_(const char *job, const int *n, _Complex double *A, const int *lda, _Complex double *B, const int *ldb, int *ilo, int *ihi, double *lscale, double *rscale, double *work, int *info, size_t)
     * }
     */
    public static MemorySegment zggbal_$address() {
        return zggbal_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zggbal_(const char *job, const int *n, _Complex double *A, const int *lda, _Complex double *B, const int *ldb, int *ilo, int *ihi, double *lscale, double *rscale, double *work, int *info, size_t)
     * }
     */
    public static void zggbal_(MemorySegment job, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment B, MemorySegment ldb, MemorySegment ilo, MemorySegment ihi, MemorySegment lscale, MemorySegment rscale, MemorySegment work, MemorySegment info, long x12) {
        var mh$ = zggbal_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zggbal_", job, n, A, lda, B, ldb, ilo, ihi, lscale, rscale, work, info, x12);
            }
            mh$.invokeExact(job, n, A, lda, B, ldb, ilo, ihi, lscale, rscale, work, info, x12);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cgges_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cgges_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cgges_(const char *jobvsl, const char *jobvsr, const char *sort, LAPACK_C_SELECT2 selctg, const int *n, _Complex float *A, const int *lda, _Complex float *B, const int *ldb, int *sdim, _Complex float *alpha, _Complex float *beta, _Complex float *VSL, const int *ldvsl, _Complex float *VSR, const int *ldvsr, _Complex float *work, const int *lwork, float *rwork, int *BWORK, int *info, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor cgges_$descriptor() {
        return cgges_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cgges_(const char *jobvsl, const char *jobvsr, const char *sort, LAPACK_C_SELECT2 selctg, const int *n, _Complex float *A, const int *lda, _Complex float *B, const int *ldb, int *sdim, _Complex float *alpha, _Complex float *beta, _Complex float *VSL, const int *ldvsl, _Complex float *VSR, const int *ldvsr, _Complex float *work, const int *lwork, float *rwork, int *BWORK, int *info, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle cgges_$handle() {
        return cgges_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cgges_(const char *jobvsl, const char *jobvsr, const char *sort, LAPACK_C_SELECT2 selctg, const int *n, _Complex float *A, const int *lda, _Complex float *B, const int *ldb, int *sdim, _Complex float *alpha, _Complex float *beta, _Complex float *VSL, const int *ldvsl, _Complex float *VSR, const int *ldvsr, _Complex float *work, const int *lwork, float *rwork, int *BWORK, int *info, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment cgges_$address() {
        return cgges_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cgges_(const char *jobvsl, const char *jobvsr, const char *sort, LAPACK_C_SELECT2 selctg, const int *n, _Complex float *A, const int *lda, _Complex float *B, const int *ldb, int *sdim, _Complex float *alpha, _Complex float *beta, _Complex float *VSL, const int *ldvsl, _Complex float *VSR, const int *ldvsr, _Complex float *work, const int *lwork, float *rwork, int *BWORK, int *info, size_t, size_t, size_t)
     * }
     */
    public static void cgges_(MemorySegment jobvsl, MemorySegment jobvsr, MemorySegment sort, MemorySegment selctg, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment B, MemorySegment ldb, MemorySegment sdim, MemorySegment alpha, MemorySegment beta, MemorySegment VSL, MemorySegment ldvsl, MemorySegment VSR, MemorySegment ldvsr, MemorySegment work, MemorySegment lwork, MemorySegment rwork, MemorySegment BWORK, MemorySegment info, long x21, long x22, long x23) {
        var mh$ = cgges_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cgges_", jobvsl, jobvsr, sort, selctg, n, A, lda, B, ldb, sdim, alpha, beta, VSL, ldvsl, VSR, ldvsr, work, lwork, rwork, BWORK, info, x21, x22, x23);
            }
            mh$.invokeExact(jobvsl, jobvsr, sort, selctg, n, A, lda, B, ldb, sdim, alpha, beta, VSL, ldvsl, VSR, ldvsr, work, lwork, rwork, BWORK, info, x21, x22, x23);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dgges_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("dgges_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dgges_(const char *jobvsl, const char *jobvsr, const char *sort, LAPACK_D_SELECT3 selctg, const int *n, double *A, const int *lda, double *B, const int *ldb, int *sdim, double *alphar, double *alphai, double *beta, double *VSL, const int *ldvsl, double *VSR, const int *ldvsr, double *work, const int *lwork, int *BWORK, int *info, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor dgges_$descriptor() {
        return dgges_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dgges_(const char *jobvsl, const char *jobvsr, const char *sort, LAPACK_D_SELECT3 selctg, const int *n, double *A, const int *lda, double *B, const int *ldb, int *sdim, double *alphar, double *alphai, double *beta, double *VSL, const int *ldvsl, double *VSR, const int *ldvsr, double *work, const int *lwork, int *BWORK, int *info, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle dgges_$handle() {
        return dgges_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dgges_(const char *jobvsl, const char *jobvsr, const char *sort, LAPACK_D_SELECT3 selctg, const int *n, double *A, const int *lda, double *B, const int *ldb, int *sdim, double *alphar, double *alphai, double *beta, double *VSL, const int *ldvsl, double *VSR, const int *ldvsr, double *work, const int *lwork, int *BWORK, int *info, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment dgges_$address() {
        return dgges_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dgges_(const char *jobvsl, const char *jobvsr, const char *sort, LAPACK_D_SELECT3 selctg, const int *n, double *A, const int *lda, double *B, const int *ldb, int *sdim, double *alphar, double *alphai, double *beta, double *VSL, const int *ldvsl, double *VSR, const int *ldvsr, double *work, const int *lwork, int *BWORK, int *info, size_t, size_t, size_t)
     * }
     */
    public static void dgges_(MemorySegment jobvsl, MemorySegment jobvsr, MemorySegment sort, MemorySegment selctg, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment B, MemorySegment ldb, MemorySegment sdim, MemorySegment alphar, MemorySegment alphai, MemorySegment beta, MemorySegment VSL, MemorySegment ldvsl, MemorySegment VSR, MemorySegment ldvsr, MemorySegment work, MemorySegment lwork, MemorySegment BWORK, MemorySegment info, long x21, long x22, long x23) {
        var mh$ = dgges_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dgges_", jobvsl, jobvsr, sort, selctg, n, A, lda, B, ldb, sdim, alphar, alphai, beta, VSL, ldvsl, VSR, ldvsr, work, lwork, BWORK, info, x21, x22, x23);
            }
            mh$.invokeExact(jobvsl, jobvsr, sort, selctg, n, A, lda, B, ldb, sdim, alphar, alphai, beta, VSL, ldvsl, VSR, ldvsr, work, lwork, BWORK, info, x21, x22, x23);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sgges_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("sgges_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void sgges_(const char *jobvsl, const char *jobvsr, const char *sort, LAPACK_S_SELECT3 selctg, const int *n, float *A, const int *lda, float *B, const int *ldb, int *sdim, float *alphar, float *alphai, float *beta, float *VSL, const int *ldvsl, float *VSR, const int *ldvsr, float *work, const int *lwork, int *BWORK, int *info, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor sgges_$descriptor() {
        return sgges_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void sgges_(const char *jobvsl, const char *jobvsr, const char *sort, LAPACK_S_SELECT3 selctg, const int *n, float *A, const int *lda, float *B, const int *ldb, int *sdim, float *alphar, float *alphai, float *beta, float *VSL, const int *ldvsl, float *VSR, const int *ldvsr, float *work, const int *lwork, int *BWORK, int *info, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle sgges_$handle() {
        return sgges_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void sgges_(const char *jobvsl, const char *jobvsr, const char *sort, LAPACK_S_SELECT3 selctg, const int *n, float *A, const int *lda, float *B, const int *ldb, int *sdim, float *alphar, float *alphai, float *beta, float *VSL, const int *ldvsl, float *VSR, const int *ldvsr, float *work, const int *lwork, int *BWORK, int *info, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment sgges_$address() {
        return sgges_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void sgges_(const char *jobvsl, const char *jobvsr, const char *sort, LAPACK_S_SELECT3 selctg, const int *n, float *A, const int *lda, float *B, const int *ldb, int *sdim, float *alphar, float *alphai, float *beta, float *VSL, const int *ldvsl, float *VSR, const int *ldvsr, float *work, const int *lwork, int *BWORK, int *info, size_t, size_t, size_t)
     * }
     */
    public static void sgges_(MemorySegment jobvsl, MemorySegment jobvsr, MemorySegment sort, MemorySegment selctg, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment B, MemorySegment ldb, MemorySegment sdim, MemorySegment alphar, MemorySegment alphai, MemorySegment beta, MemorySegment VSL, MemorySegment ldvsl, MemorySegment VSR, MemorySegment ldvsr, MemorySegment work, MemorySegment lwork, MemorySegment BWORK, MemorySegment info, long x21, long x22, long x23) {
        var mh$ = sgges_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sgges_", jobvsl, jobvsr, sort, selctg, n, A, lda, B, ldb, sdim, alphar, alphai, beta, VSL, ldvsl, VSR, ldvsr, work, lwork, BWORK, info, x21, x22, x23);
            }
            mh$.invokeExact(jobvsl, jobvsr, sort, selctg, n, A, lda, B, ldb, sdim, alphar, alphai, beta, VSL, ldvsl, VSR, ldvsr, work, lwork, BWORK, info, x21, x22, x23);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zgges_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("zgges_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zgges_(const char *jobvsl, const char *jobvsr, const char *sort, LAPACK_Z_SELECT2 selctg, const int *n, _Complex double *A, const int *lda, _Complex double *B, const int *ldb, int *sdim, _Complex double *alpha, _Complex double *beta, _Complex double *VSL, const int *ldvsl, _Complex double *VSR, const int *ldvsr, _Complex double *work, const int *lwork, double *rwork, int *BWORK, int *info, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor zgges_$descriptor() {
        return zgges_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zgges_(const char *jobvsl, const char *jobvsr, const char *sort, LAPACK_Z_SELECT2 selctg, const int *n, _Complex double *A, const int *lda, _Complex double *B, const int *ldb, int *sdim, _Complex double *alpha, _Complex double *beta, _Complex double *VSL, const int *ldvsl, _Complex double *VSR, const int *ldvsr, _Complex double *work, const int *lwork, double *rwork, int *BWORK, int *info, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle zgges_$handle() {
        return zgges_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zgges_(const char *jobvsl, const char *jobvsr, const char *sort, LAPACK_Z_SELECT2 selctg, const int *n, _Complex double *A, const int *lda, _Complex double *B, const int *ldb, int *sdim, _Complex double *alpha, _Complex double *beta, _Complex double *VSL, const int *ldvsl, _Complex double *VSR, const int *ldvsr, _Complex double *work, const int *lwork, double *rwork, int *BWORK, int *info, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment zgges_$address() {
        return zgges_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zgges_(const char *jobvsl, const char *jobvsr, const char *sort, LAPACK_Z_SELECT2 selctg, const int *n, _Complex double *A, const int *lda, _Complex double *B, const int *ldb, int *sdim, _Complex double *alpha, _Complex double *beta, _Complex double *VSL, const int *ldvsl, _Complex double *VSR, const int *ldvsr, _Complex double *work, const int *lwork, double *rwork, int *BWORK, int *info, size_t, size_t, size_t)
     * }
     */
    public static void zgges_(MemorySegment jobvsl, MemorySegment jobvsr, MemorySegment sort, MemorySegment selctg, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment B, MemorySegment ldb, MemorySegment sdim, MemorySegment alpha, MemorySegment beta, MemorySegment VSL, MemorySegment ldvsl, MemorySegment VSR, MemorySegment ldvsr, MemorySegment work, MemorySegment lwork, MemorySegment rwork, MemorySegment BWORK, MemorySegment info, long x21, long x22, long x23) {
        var mh$ = zgges_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zgges_", jobvsl, jobvsr, sort, selctg, n, A, lda, B, ldb, sdim, alpha, beta, VSL, ldvsl, VSR, ldvsr, work, lwork, rwork, BWORK, info, x21, x22, x23);
            }
            mh$.invokeExact(jobvsl, jobvsr, sort, selctg, n, A, lda, B, ldb, sdim, alpha, beta, VSL, ldvsl, VSR, ldvsr, work, lwork, rwork, BWORK, info, x21, x22, x23);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cgges3_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cgges3_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cgges3_(const char *jobvsl, const char *jobvsr, const char *sort, LAPACK_C_SELECT2 selctg, const int *n, _Complex float *A, const int *lda, _Complex float *B, const int *ldb, int *sdim, _Complex float *alpha, _Complex float *beta, _Complex float *VSL, const int *ldvsl, _Complex float *VSR, const int *ldvsr, _Complex float *work, const int *lwork, float *rwork, int *BWORK, int *info, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor cgges3_$descriptor() {
        return cgges3_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cgges3_(const char *jobvsl, const char *jobvsr, const char *sort, LAPACK_C_SELECT2 selctg, const int *n, _Complex float *A, const int *lda, _Complex float *B, const int *ldb, int *sdim, _Complex float *alpha, _Complex float *beta, _Complex float *VSL, const int *ldvsl, _Complex float *VSR, const int *ldvsr, _Complex float *work, const int *lwork, float *rwork, int *BWORK, int *info, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle cgges3_$handle() {
        return cgges3_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cgges3_(const char *jobvsl, const char *jobvsr, const char *sort, LAPACK_C_SELECT2 selctg, const int *n, _Complex float *A, const int *lda, _Complex float *B, const int *ldb, int *sdim, _Complex float *alpha, _Complex float *beta, _Complex float *VSL, const int *ldvsl, _Complex float *VSR, const int *ldvsr, _Complex float *work, const int *lwork, float *rwork, int *BWORK, int *info, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment cgges3_$address() {
        return cgges3_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cgges3_(const char *jobvsl, const char *jobvsr, const char *sort, LAPACK_C_SELECT2 selctg, const int *n, _Complex float *A, const int *lda, _Complex float *B, const int *ldb, int *sdim, _Complex float *alpha, _Complex float *beta, _Complex float *VSL, const int *ldvsl, _Complex float *VSR, const int *ldvsr, _Complex float *work, const int *lwork, float *rwork, int *BWORK, int *info, size_t, size_t, size_t)
     * }
     */
    public static void cgges3_(MemorySegment jobvsl, MemorySegment jobvsr, MemorySegment sort, MemorySegment selctg, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment B, MemorySegment ldb, MemorySegment sdim, MemorySegment alpha, MemorySegment beta, MemorySegment VSL, MemorySegment ldvsl, MemorySegment VSR, MemorySegment ldvsr, MemorySegment work, MemorySegment lwork, MemorySegment rwork, MemorySegment BWORK, MemorySegment info, long x21, long x22, long x23) {
        var mh$ = cgges3_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cgges3_", jobvsl, jobvsr, sort, selctg, n, A, lda, B, ldb, sdim, alpha, beta, VSL, ldvsl, VSR, ldvsr, work, lwork, rwork, BWORK, info, x21, x22, x23);
            }
            mh$.invokeExact(jobvsl, jobvsr, sort, selctg, n, A, lda, B, ldb, sdim, alpha, beta, VSL, ldvsl, VSR, ldvsr, work, lwork, rwork, BWORK, info, x21, x22, x23);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dgges3_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("dgges3_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dgges3_(const char *jobvsl, const char *jobvsr, const char *sort, LAPACK_D_SELECT3 selctg, const int *n, double *A, const int *lda, double *B, const int *ldb, int *sdim, double *alphar, double *alphai, double *beta, double *VSL, const int *ldvsl, double *VSR, const int *ldvsr, double *work, const int *lwork, int *BWORK, int *info, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor dgges3_$descriptor() {
        return dgges3_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dgges3_(const char *jobvsl, const char *jobvsr, const char *sort, LAPACK_D_SELECT3 selctg, const int *n, double *A, const int *lda, double *B, const int *ldb, int *sdim, double *alphar, double *alphai, double *beta, double *VSL, const int *ldvsl, double *VSR, const int *ldvsr, double *work, const int *lwork, int *BWORK, int *info, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle dgges3_$handle() {
        return dgges3_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dgges3_(const char *jobvsl, const char *jobvsr, const char *sort, LAPACK_D_SELECT3 selctg, const int *n, double *A, const int *lda, double *B, const int *ldb, int *sdim, double *alphar, double *alphai, double *beta, double *VSL, const int *ldvsl, double *VSR, const int *ldvsr, double *work, const int *lwork, int *BWORK, int *info, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment dgges3_$address() {
        return dgges3_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dgges3_(const char *jobvsl, const char *jobvsr, const char *sort, LAPACK_D_SELECT3 selctg, const int *n, double *A, const int *lda, double *B, const int *ldb, int *sdim, double *alphar, double *alphai, double *beta, double *VSL, const int *ldvsl, double *VSR, const int *ldvsr, double *work, const int *lwork, int *BWORK, int *info, size_t, size_t, size_t)
     * }
     */
    public static void dgges3_(MemorySegment jobvsl, MemorySegment jobvsr, MemorySegment sort, MemorySegment selctg, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment B, MemorySegment ldb, MemorySegment sdim, MemorySegment alphar, MemorySegment alphai, MemorySegment beta, MemorySegment VSL, MemorySegment ldvsl, MemorySegment VSR, MemorySegment ldvsr, MemorySegment work, MemorySegment lwork, MemorySegment BWORK, MemorySegment info, long x21, long x22, long x23) {
        var mh$ = dgges3_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dgges3_", jobvsl, jobvsr, sort, selctg, n, A, lda, B, ldb, sdim, alphar, alphai, beta, VSL, ldvsl, VSR, ldvsr, work, lwork, BWORK, info, x21, x22, x23);
            }
            mh$.invokeExact(jobvsl, jobvsr, sort, selctg, n, A, lda, B, ldb, sdim, alphar, alphai, beta, VSL, ldvsl, VSR, ldvsr, work, lwork, BWORK, info, x21, x22, x23);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sgges3_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("sgges3_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void sgges3_(const char *jobvsl, const char *jobvsr, const char *sort, LAPACK_S_SELECT3 selctg, const int *n, float *A, const int *lda, float *B, const int *ldb, int *sdim, float *alphar, float *alphai, float *beta, float *VSL, const int *ldvsl, float *VSR, const int *ldvsr, float *work, const int *lwork, int *BWORK, int *info, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor sgges3_$descriptor() {
        return sgges3_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void sgges3_(const char *jobvsl, const char *jobvsr, const char *sort, LAPACK_S_SELECT3 selctg, const int *n, float *A, const int *lda, float *B, const int *ldb, int *sdim, float *alphar, float *alphai, float *beta, float *VSL, const int *ldvsl, float *VSR, const int *ldvsr, float *work, const int *lwork, int *BWORK, int *info, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle sgges3_$handle() {
        return sgges3_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void sgges3_(const char *jobvsl, const char *jobvsr, const char *sort, LAPACK_S_SELECT3 selctg, const int *n, float *A, const int *lda, float *B, const int *ldb, int *sdim, float *alphar, float *alphai, float *beta, float *VSL, const int *ldvsl, float *VSR, const int *ldvsr, float *work, const int *lwork, int *BWORK, int *info, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment sgges3_$address() {
        return sgges3_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void sgges3_(const char *jobvsl, const char *jobvsr, const char *sort, LAPACK_S_SELECT3 selctg, const int *n, float *A, const int *lda, float *B, const int *ldb, int *sdim, float *alphar, float *alphai, float *beta, float *VSL, const int *ldvsl, float *VSR, const int *ldvsr, float *work, const int *lwork, int *BWORK, int *info, size_t, size_t, size_t)
     * }
     */
    public static void sgges3_(MemorySegment jobvsl, MemorySegment jobvsr, MemorySegment sort, MemorySegment selctg, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment B, MemorySegment ldb, MemorySegment sdim, MemorySegment alphar, MemorySegment alphai, MemorySegment beta, MemorySegment VSL, MemorySegment ldvsl, MemorySegment VSR, MemorySegment ldvsr, MemorySegment work, MemorySegment lwork, MemorySegment BWORK, MemorySegment info, long x21, long x22, long x23) {
        var mh$ = sgges3_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sgges3_", jobvsl, jobvsr, sort, selctg, n, A, lda, B, ldb, sdim, alphar, alphai, beta, VSL, ldvsl, VSR, ldvsr, work, lwork, BWORK, info, x21, x22, x23);
            }
            mh$.invokeExact(jobvsl, jobvsr, sort, selctg, n, A, lda, B, ldb, sdim, alphar, alphai, beta, VSL, ldvsl, VSR, ldvsr, work, lwork, BWORK, info, x21, x22, x23);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zgges3_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("zgges3_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zgges3_(const char *jobvsl, const char *jobvsr, const char *sort, LAPACK_Z_SELECT2 selctg, const int *n, _Complex double *A, const int *lda, _Complex double *B, const int *ldb, int *sdim, _Complex double *alpha, _Complex double *beta, _Complex double *VSL, const int *ldvsl, _Complex double *VSR, const int *ldvsr, _Complex double *work, const int *lwork, double *rwork, int *BWORK, int *info, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor zgges3_$descriptor() {
        return zgges3_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zgges3_(const char *jobvsl, const char *jobvsr, const char *sort, LAPACK_Z_SELECT2 selctg, const int *n, _Complex double *A, const int *lda, _Complex double *B, const int *ldb, int *sdim, _Complex double *alpha, _Complex double *beta, _Complex double *VSL, const int *ldvsl, _Complex double *VSR, const int *ldvsr, _Complex double *work, const int *lwork, double *rwork, int *BWORK, int *info, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle zgges3_$handle() {
        return zgges3_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zgges3_(const char *jobvsl, const char *jobvsr, const char *sort, LAPACK_Z_SELECT2 selctg, const int *n, _Complex double *A, const int *lda, _Complex double *B, const int *ldb, int *sdim, _Complex double *alpha, _Complex double *beta, _Complex double *VSL, const int *ldvsl, _Complex double *VSR, const int *ldvsr, _Complex double *work, const int *lwork, double *rwork, int *BWORK, int *info, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment zgges3_$address() {
        return zgges3_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zgges3_(const char *jobvsl, const char *jobvsr, const char *sort, LAPACK_Z_SELECT2 selctg, const int *n, _Complex double *A, const int *lda, _Complex double *B, const int *ldb, int *sdim, _Complex double *alpha, _Complex double *beta, _Complex double *VSL, const int *ldvsl, _Complex double *VSR, const int *ldvsr, _Complex double *work, const int *lwork, double *rwork, int *BWORK, int *info, size_t, size_t, size_t)
     * }
     */
    public static void zgges3_(MemorySegment jobvsl, MemorySegment jobvsr, MemorySegment sort, MemorySegment selctg, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment B, MemorySegment ldb, MemorySegment sdim, MemorySegment alpha, MemorySegment beta, MemorySegment VSL, MemorySegment ldvsl, MemorySegment VSR, MemorySegment ldvsr, MemorySegment work, MemorySegment lwork, MemorySegment rwork, MemorySegment BWORK, MemorySegment info, long x21, long x22, long x23) {
        var mh$ = zgges3_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zgges3_", jobvsl, jobvsr, sort, selctg, n, A, lda, B, ldb, sdim, alpha, beta, VSL, ldvsl, VSR, ldvsr, work, lwork, rwork, BWORK, info, x21, x22, x23);
            }
            mh$.invokeExact(jobvsl, jobvsr, sort, selctg, n, A, lda, B, ldb, sdim, alpha, beta, VSL, ldvsl, VSR, ldvsr, work, lwork, rwork, BWORK, info, x21, x22, x23);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cggesx_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cggesx_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cggesx_(const char *jobvsl, const char *jobvsr, const char *sort, LAPACK_C_SELECT2 selctg, const char *sense, const int *n, _Complex float *A, const int *lda, _Complex float *B, const int *ldb, int *sdim, _Complex float *alpha, _Complex float *beta, _Complex float *VSL, const int *ldvsl, _Complex float *VSR, const int *ldvsr, float *rconde, float *rcondv, _Complex float *work, const int *lwork, float *rwork, int *iwork, const int *liwork, int *BWORK, int *info, size_t, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor cggesx_$descriptor() {
        return cggesx_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cggesx_(const char *jobvsl, const char *jobvsr, const char *sort, LAPACK_C_SELECT2 selctg, const char *sense, const int *n, _Complex float *A, const int *lda, _Complex float *B, const int *ldb, int *sdim, _Complex float *alpha, _Complex float *beta, _Complex float *VSL, const int *ldvsl, _Complex float *VSR, const int *ldvsr, float *rconde, float *rcondv, _Complex float *work, const int *lwork, float *rwork, int *iwork, const int *liwork, int *BWORK, int *info, size_t, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle cggesx_$handle() {
        return cggesx_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cggesx_(const char *jobvsl, const char *jobvsr, const char *sort, LAPACK_C_SELECT2 selctg, const char *sense, const int *n, _Complex float *A, const int *lda, _Complex float *B, const int *ldb, int *sdim, _Complex float *alpha, _Complex float *beta, _Complex float *VSL, const int *ldvsl, _Complex float *VSR, const int *ldvsr, float *rconde, float *rcondv, _Complex float *work, const int *lwork, float *rwork, int *iwork, const int *liwork, int *BWORK, int *info, size_t, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment cggesx_$address() {
        return cggesx_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cggesx_(const char *jobvsl, const char *jobvsr, const char *sort, LAPACK_C_SELECT2 selctg, const char *sense, const int *n, _Complex float *A, const int *lda, _Complex float *B, const int *ldb, int *sdim, _Complex float *alpha, _Complex float *beta, _Complex float *VSL, const int *ldvsl, _Complex float *VSR, const int *ldvsr, float *rconde, float *rcondv, _Complex float *work, const int *lwork, float *rwork, int *iwork, const int *liwork, int *BWORK, int *info, size_t, size_t, size_t, size_t)
     * }
     */
    public static void cggesx_(MemorySegment jobvsl, MemorySegment jobvsr, MemorySegment sort, MemorySegment selctg, MemorySegment sense, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment B, MemorySegment ldb, MemorySegment sdim, MemorySegment alpha, MemorySegment beta, MemorySegment VSL, MemorySegment ldvsl, MemorySegment VSR, MemorySegment ldvsr, MemorySegment rconde, MemorySegment rcondv, MemorySegment work, MemorySegment lwork, MemorySegment rwork, MemorySegment iwork, MemorySegment liwork, MemorySegment BWORK, MemorySegment info, long x26, long x27, long x28, long x29) {
        var mh$ = cggesx_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cggesx_", jobvsl, jobvsr, sort, selctg, sense, n, A, lda, B, ldb, sdim, alpha, beta, VSL, ldvsl, VSR, ldvsr, rconde, rcondv, work, lwork, rwork, iwork, liwork, BWORK, info, x26, x27, x28, x29);
            }
            mh$.invokeExact(jobvsl, jobvsr, sort, selctg, sense, n, A, lda, B, ldb, sdim, alpha, beta, VSL, ldvsl, VSR, ldvsr, rconde, rcondv, work, lwork, rwork, iwork, liwork, BWORK, info, x26, x27, x28, x29);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dggesx_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("dggesx_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dggesx_(const char *jobvsl, const char *jobvsr, const char *sort, LAPACK_D_SELECT3 selctg, const char *sense, const int *n, double *A, const int *lda, double *B, const int *ldb, int *sdim, double *alphar, double *alphai, double *beta, double *VSL, const int *ldvsl, double *VSR, const int *ldvsr, double *rconde, double *rcondv, double *work, const int *lwork, int *iwork, const int *liwork, int *BWORK, int *info, size_t, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor dggesx_$descriptor() {
        return dggesx_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dggesx_(const char *jobvsl, const char *jobvsr, const char *sort, LAPACK_D_SELECT3 selctg, const char *sense, const int *n, double *A, const int *lda, double *B, const int *ldb, int *sdim, double *alphar, double *alphai, double *beta, double *VSL, const int *ldvsl, double *VSR, const int *ldvsr, double *rconde, double *rcondv, double *work, const int *lwork, int *iwork, const int *liwork, int *BWORK, int *info, size_t, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle dggesx_$handle() {
        return dggesx_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dggesx_(const char *jobvsl, const char *jobvsr, const char *sort, LAPACK_D_SELECT3 selctg, const char *sense, const int *n, double *A, const int *lda, double *B, const int *ldb, int *sdim, double *alphar, double *alphai, double *beta, double *VSL, const int *ldvsl, double *VSR, const int *ldvsr, double *rconde, double *rcondv, double *work, const int *lwork, int *iwork, const int *liwork, int *BWORK, int *info, size_t, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment dggesx_$address() {
        return dggesx_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dggesx_(const char *jobvsl, const char *jobvsr, const char *sort, LAPACK_D_SELECT3 selctg, const char *sense, const int *n, double *A, const int *lda, double *B, const int *ldb, int *sdim, double *alphar, double *alphai, double *beta, double *VSL, const int *ldvsl, double *VSR, const int *ldvsr, double *rconde, double *rcondv, double *work, const int *lwork, int *iwork, const int *liwork, int *BWORK, int *info, size_t, size_t, size_t, size_t)
     * }
     */
    public static void dggesx_(MemorySegment jobvsl, MemorySegment jobvsr, MemorySegment sort, MemorySegment selctg, MemorySegment sense, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment B, MemorySegment ldb, MemorySegment sdim, MemorySegment alphar, MemorySegment alphai, MemorySegment beta, MemorySegment VSL, MemorySegment ldvsl, MemorySegment VSR, MemorySegment ldvsr, MemorySegment rconde, MemorySegment rcondv, MemorySegment work, MemorySegment lwork, MemorySegment iwork, MemorySegment liwork, MemorySegment BWORK, MemorySegment info, long x26, long x27, long x28, long x29) {
        var mh$ = dggesx_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dggesx_", jobvsl, jobvsr, sort, selctg, sense, n, A, lda, B, ldb, sdim, alphar, alphai, beta, VSL, ldvsl, VSR, ldvsr, rconde, rcondv, work, lwork, iwork, liwork, BWORK, info, x26, x27, x28, x29);
            }
            mh$.invokeExact(jobvsl, jobvsr, sort, selctg, sense, n, A, lda, B, ldb, sdim, alphar, alphai, beta, VSL, ldvsl, VSR, ldvsr, rconde, rcondv, work, lwork, iwork, liwork, BWORK, info, x26, x27, x28, x29);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sggesx_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("sggesx_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void sggesx_(const char *jobvsl, const char *jobvsr, const char *sort, LAPACK_S_SELECT3 selctg, const char *sense, const int *n, float *A, const int *lda, float *B, const int *ldb, int *sdim, float *alphar, float *alphai, float *beta, float *VSL, const int *ldvsl, float *VSR, const int *ldvsr, float *rconde, float *rcondv, float *work, const int *lwork, int *iwork, const int *liwork, int *BWORK, int *info, size_t, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor sggesx_$descriptor() {
        return sggesx_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void sggesx_(const char *jobvsl, const char *jobvsr, const char *sort, LAPACK_S_SELECT3 selctg, const char *sense, const int *n, float *A, const int *lda, float *B, const int *ldb, int *sdim, float *alphar, float *alphai, float *beta, float *VSL, const int *ldvsl, float *VSR, const int *ldvsr, float *rconde, float *rcondv, float *work, const int *lwork, int *iwork, const int *liwork, int *BWORK, int *info, size_t, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle sggesx_$handle() {
        return sggesx_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void sggesx_(const char *jobvsl, const char *jobvsr, const char *sort, LAPACK_S_SELECT3 selctg, const char *sense, const int *n, float *A, const int *lda, float *B, const int *ldb, int *sdim, float *alphar, float *alphai, float *beta, float *VSL, const int *ldvsl, float *VSR, const int *ldvsr, float *rconde, float *rcondv, float *work, const int *lwork, int *iwork, const int *liwork, int *BWORK, int *info, size_t, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment sggesx_$address() {
        return sggesx_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void sggesx_(const char *jobvsl, const char *jobvsr, const char *sort, LAPACK_S_SELECT3 selctg, const char *sense, const int *n, float *A, const int *lda, float *B, const int *ldb, int *sdim, float *alphar, float *alphai, float *beta, float *VSL, const int *ldvsl, float *VSR, const int *ldvsr, float *rconde, float *rcondv, float *work, const int *lwork, int *iwork, const int *liwork, int *BWORK, int *info, size_t, size_t, size_t, size_t)
     * }
     */
    public static void sggesx_(MemorySegment jobvsl, MemorySegment jobvsr, MemorySegment sort, MemorySegment selctg, MemorySegment sense, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment B, MemorySegment ldb, MemorySegment sdim, MemorySegment alphar, MemorySegment alphai, MemorySegment beta, MemorySegment VSL, MemorySegment ldvsl, MemorySegment VSR, MemorySegment ldvsr, MemorySegment rconde, MemorySegment rcondv, MemorySegment work, MemorySegment lwork, MemorySegment iwork, MemorySegment liwork, MemorySegment BWORK, MemorySegment info, long x26, long x27, long x28, long x29) {
        var mh$ = sggesx_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sggesx_", jobvsl, jobvsr, sort, selctg, sense, n, A, lda, B, ldb, sdim, alphar, alphai, beta, VSL, ldvsl, VSR, ldvsr, rconde, rcondv, work, lwork, iwork, liwork, BWORK, info, x26, x27, x28, x29);
            }
            mh$.invokeExact(jobvsl, jobvsr, sort, selctg, sense, n, A, lda, B, ldb, sdim, alphar, alphai, beta, VSL, ldvsl, VSR, ldvsr, rconde, rcondv, work, lwork, iwork, liwork, BWORK, info, x26, x27, x28, x29);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zggesx_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("zggesx_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zggesx_(const char *jobvsl, const char *jobvsr, const char *sort, LAPACK_Z_SELECT2 selctg, const char *sense, const int *n, _Complex double *A, const int *lda, _Complex double *B, const int *ldb, int *sdim, _Complex double *alpha, _Complex double *beta, _Complex double *VSL, const int *ldvsl, _Complex double *VSR, const int *ldvsr, double *rconde, double *rcondv, _Complex double *work, const int *lwork, double *rwork, int *iwork, const int *liwork, int *BWORK, int *info, size_t, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor zggesx_$descriptor() {
        return zggesx_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zggesx_(const char *jobvsl, const char *jobvsr, const char *sort, LAPACK_Z_SELECT2 selctg, const char *sense, const int *n, _Complex double *A, const int *lda, _Complex double *B, const int *ldb, int *sdim, _Complex double *alpha, _Complex double *beta, _Complex double *VSL, const int *ldvsl, _Complex double *VSR, const int *ldvsr, double *rconde, double *rcondv, _Complex double *work, const int *lwork, double *rwork, int *iwork, const int *liwork, int *BWORK, int *info, size_t, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle zggesx_$handle() {
        return zggesx_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zggesx_(const char *jobvsl, const char *jobvsr, const char *sort, LAPACK_Z_SELECT2 selctg, const char *sense, const int *n, _Complex double *A, const int *lda, _Complex double *B, const int *ldb, int *sdim, _Complex double *alpha, _Complex double *beta, _Complex double *VSL, const int *ldvsl, _Complex double *VSR, const int *ldvsr, double *rconde, double *rcondv, _Complex double *work, const int *lwork, double *rwork, int *iwork, const int *liwork, int *BWORK, int *info, size_t, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment zggesx_$address() {
        return zggesx_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zggesx_(const char *jobvsl, const char *jobvsr, const char *sort, LAPACK_Z_SELECT2 selctg, const char *sense, const int *n, _Complex double *A, const int *lda, _Complex double *B, const int *ldb, int *sdim, _Complex double *alpha, _Complex double *beta, _Complex double *VSL, const int *ldvsl, _Complex double *VSR, const int *ldvsr, double *rconde, double *rcondv, _Complex double *work, const int *lwork, double *rwork, int *iwork, const int *liwork, int *BWORK, int *info, size_t, size_t, size_t, size_t)
     * }
     */
    public static void zggesx_(MemorySegment jobvsl, MemorySegment jobvsr, MemorySegment sort, MemorySegment selctg, MemorySegment sense, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment B, MemorySegment ldb, MemorySegment sdim, MemorySegment alpha, MemorySegment beta, MemorySegment VSL, MemorySegment ldvsl, MemorySegment VSR, MemorySegment ldvsr, MemorySegment rconde, MemorySegment rcondv, MemorySegment work, MemorySegment lwork, MemorySegment rwork, MemorySegment iwork, MemorySegment liwork, MemorySegment BWORK, MemorySegment info, long x26, long x27, long x28, long x29) {
        var mh$ = zggesx_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zggesx_", jobvsl, jobvsr, sort, selctg, sense, n, A, lda, B, ldb, sdim, alpha, beta, VSL, ldvsl, VSR, ldvsr, rconde, rcondv, work, lwork, rwork, iwork, liwork, BWORK, info, x26, x27, x28, x29);
            }
            mh$.invokeExact(jobvsl, jobvsr, sort, selctg, sense, n, A, lda, B, ldb, sdim, alpha, beta, VSL, ldvsl, VSR, ldvsr, rconde, rcondv, work, lwork, rwork, iwork, liwork, BWORK, info, x26, x27, x28, x29);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cggev_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cggev_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cggev_(const char *jobvl, const char *jobvr, const int *n, _Complex float *A, const int *lda, _Complex float *B, const int *ldb, _Complex float *alpha, _Complex float *beta, _Complex float *VL, const int *ldvl, _Complex float *VR, const int *ldvr, _Complex float *work, const int *lwork, float *rwork, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor cggev_$descriptor() {
        return cggev_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cggev_(const char *jobvl, const char *jobvr, const int *n, _Complex float *A, const int *lda, _Complex float *B, const int *ldb, _Complex float *alpha, _Complex float *beta, _Complex float *VL, const int *ldvl, _Complex float *VR, const int *ldvr, _Complex float *work, const int *lwork, float *rwork, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle cggev_$handle() {
        return cggev_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cggev_(const char *jobvl, const char *jobvr, const int *n, _Complex float *A, const int *lda, _Complex float *B, const int *ldb, _Complex float *alpha, _Complex float *beta, _Complex float *VL, const int *ldvl, _Complex float *VR, const int *ldvr, _Complex float *work, const int *lwork, float *rwork, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment cggev_$address() {
        return cggev_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cggev_(const char *jobvl, const char *jobvr, const int *n, _Complex float *A, const int *lda, _Complex float *B, const int *ldb, _Complex float *alpha, _Complex float *beta, _Complex float *VL, const int *ldvl, _Complex float *VR, const int *ldvr, _Complex float *work, const int *lwork, float *rwork, int *info, size_t, size_t)
     * }
     */
    public static void cggev_(MemorySegment jobvl, MemorySegment jobvr, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment B, MemorySegment ldb, MemorySegment alpha, MemorySegment beta, MemorySegment VL, MemorySegment ldvl, MemorySegment VR, MemorySegment ldvr, MemorySegment work, MemorySegment lwork, MemorySegment rwork, MemorySegment info, long x17, long x18) {
        var mh$ = cggev_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cggev_", jobvl, jobvr, n, A, lda, B, ldb, alpha, beta, VL, ldvl, VR, ldvr, work, lwork, rwork, info, x17, x18);
            }
            mh$.invokeExact(jobvl, jobvr, n, A, lda, B, ldb, alpha, beta, VL, ldvl, VR, ldvr, work, lwork, rwork, info, x17, x18);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dggev_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("dggev_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dggev_(const char *jobvl, const char *jobvr, const int *n, double *A, const int *lda, double *B, const int *ldb, double *alphar, double *alphai, double *beta, double *VL, const int *ldvl, double *VR, const int *ldvr, double *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor dggev_$descriptor() {
        return dggev_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dggev_(const char *jobvl, const char *jobvr, const int *n, double *A, const int *lda, double *B, const int *ldb, double *alphar, double *alphai, double *beta, double *VL, const int *ldvl, double *VR, const int *ldvr, double *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle dggev_$handle() {
        return dggev_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dggev_(const char *jobvl, const char *jobvr, const int *n, double *A, const int *lda, double *B, const int *ldb, double *alphar, double *alphai, double *beta, double *VL, const int *ldvl, double *VR, const int *ldvr, double *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment dggev_$address() {
        return dggev_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dggev_(const char *jobvl, const char *jobvr, const int *n, double *A, const int *lda, double *B, const int *ldb, double *alphar, double *alphai, double *beta, double *VL, const int *ldvl, double *VR, const int *ldvr, double *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static void dggev_(MemorySegment jobvl, MemorySegment jobvr, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment B, MemorySegment ldb, MemorySegment alphar, MemorySegment alphai, MemorySegment beta, MemorySegment VL, MemorySegment ldvl, MemorySegment VR, MemorySegment ldvr, MemorySegment work, MemorySegment lwork, MemorySegment info, long x17, long x18) {
        var mh$ = dggev_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dggev_", jobvl, jobvr, n, A, lda, B, ldb, alphar, alphai, beta, VL, ldvl, VR, ldvr, work, lwork, info, x17, x18);
            }
            mh$.invokeExact(jobvl, jobvr, n, A, lda, B, ldb, alphar, alphai, beta, VL, ldvl, VR, ldvr, work, lwork, info, x17, x18);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sggev_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("sggev_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void sggev_(const char *jobvl, const char *jobvr, const int *n, float *A, const int *lda, float *B, const int *ldb, float *alphar, float *alphai, float *beta, float *VL, const int *ldvl, float *VR, const int *ldvr, float *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor sggev_$descriptor() {
        return sggev_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void sggev_(const char *jobvl, const char *jobvr, const int *n, float *A, const int *lda, float *B, const int *ldb, float *alphar, float *alphai, float *beta, float *VL, const int *ldvl, float *VR, const int *ldvr, float *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle sggev_$handle() {
        return sggev_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void sggev_(const char *jobvl, const char *jobvr, const int *n, float *A, const int *lda, float *B, const int *ldb, float *alphar, float *alphai, float *beta, float *VL, const int *ldvl, float *VR, const int *ldvr, float *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment sggev_$address() {
        return sggev_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void sggev_(const char *jobvl, const char *jobvr, const int *n, float *A, const int *lda, float *B, const int *ldb, float *alphar, float *alphai, float *beta, float *VL, const int *ldvl, float *VR, const int *ldvr, float *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static void sggev_(MemorySegment jobvl, MemorySegment jobvr, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment B, MemorySegment ldb, MemorySegment alphar, MemorySegment alphai, MemorySegment beta, MemorySegment VL, MemorySegment ldvl, MemorySegment VR, MemorySegment ldvr, MemorySegment work, MemorySegment lwork, MemorySegment info, long x17, long x18) {
        var mh$ = sggev_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sggev_", jobvl, jobvr, n, A, lda, B, ldb, alphar, alphai, beta, VL, ldvl, VR, ldvr, work, lwork, info, x17, x18);
            }
            mh$.invokeExact(jobvl, jobvr, n, A, lda, B, ldb, alphar, alphai, beta, VL, ldvl, VR, ldvr, work, lwork, info, x17, x18);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zggev_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("zggev_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zggev_(const char *jobvl, const char *jobvr, const int *n, _Complex double *A, const int *lda, _Complex double *B, const int *ldb, _Complex double *alpha, _Complex double *beta, _Complex double *VL, const int *ldvl, _Complex double *VR, const int *ldvr, _Complex double *work, const int *lwork, double *rwork, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor zggev_$descriptor() {
        return zggev_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zggev_(const char *jobvl, const char *jobvr, const int *n, _Complex double *A, const int *lda, _Complex double *B, const int *ldb, _Complex double *alpha, _Complex double *beta, _Complex double *VL, const int *ldvl, _Complex double *VR, const int *ldvr, _Complex double *work, const int *lwork, double *rwork, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle zggev_$handle() {
        return zggev_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zggev_(const char *jobvl, const char *jobvr, const int *n, _Complex double *A, const int *lda, _Complex double *B, const int *ldb, _Complex double *alpha, _Complex double *beta, _Complex double *VL, const int *ldvl, _Complex double *VR, const int *ldvr, _Complex double *work, const int *lwork, double *rwork, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment zggev_$address() {
        return zggev_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zggev_(const char *jobvl, const char *jobvr, const int *n, _Complex double *A, const int *lda, _Complex double *B, const int *ldb, _Complex double *alpha, _Complex double *beta, _Complex double *VL, const int *ldvl, _Complex double *VR, const int *ldvr, _Complex double *work, const int *lwork, double *rwork, int *info, size_t, size_t)
     * }
     */
    public static void zggev_(MemorySegment jobvl, MemorySegment jobvr, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment B, MemorySegment ldb, MemorySegment alpha, MemorySegment beta, MemorySegment VL, MemorySegment ldvl, MemorySegment VR, MemorySegment ldvr, MemorySegment work, MemorySegment lwork, MemorySegment rwork, MemorySegment info, long x17, long x18) {
        var mh$ = zggev_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zggev_", jobvl, jobvr, n, A, lda, B, ldb, alpha, beta, VL, ldvl, VR, ldvr, work, lwork, rwork, info, x17, x18);
            }
            mh$.invokeExact(jobvl, jobvr, n, A, lda, B, ldb, alpha, beta, VL, ldvl, VR, ldvr, work, lwork, rwork, info, x17, x18);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cggev3_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cggev3_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cggev3_(const char *jobvl, const char *jobvr, const int *n, _Complex float *A, const int *lda, _Complex float *B, const int *ldb, _Complex float *alpha, _Complex float *beta, _Complex float *VL, const int *ldvl, _Complex float *VR, const int *ldvr, _Complex float *work, const int *lwork, float *rwork, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor cggev3_$descriptor() {
        return cggev3_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cggev3_(const char *jobvl, const char *jobvr, const int *n, _Complex float *A, const int *lda, _Complex float *B, const int *ldb, _Complex float *alpha, _Complex float *beta, _Complex float *VL, const int *ldvl, _Complex float *VR, const int *ldvr, _Complex float *work, const int *lwork, float *rwork, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle cggev3_$handle() {
        return cggev3_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cggev3_(const char *jobvl, const char *jobvr, const int *n, _Complex float *A, const int *lda, _Complex float *B, const int *ldb, _Complex float *alpha, _Complex float *beta, _Complex float *VL, const int *ldvl, _Complex float *VR, const int *ldvr, _Complex float *work, const int *lwork, float *rwork, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment cggev3_$address() {
        return cggev3_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cggev3_(const char *jobvl, const char *jobvr, const int *n, _Complex float *A, const int *lda, _Complex float *B, const int *ldb, _Complex float *alpha, _Complex float *beta, _Complex float *VL, const int *ldvl, _Complex float *VR, const int *ldvr, _Complex float *work, const int *lwork, float *rwork, int *info, size_t, size_t)
     * }
     */
    public static void cggev3_(MemorySegment jobvl, MemorySegment jobvr, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment B, MemorySegment ldb, MemorySegment alpha, MemorySegment beta, MemorySegment VL, MemorySegment ldvl, MemorySegment VR, MemorySegment ldvr, MemorySegment work, MemorySegment lwork, MemorySegment rwork, MemorySegment info, long x17, long x18) {
        var mh$ = cggev3_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cggev3_", jobvl, jobvr, n, A, lda, B, ldb, alpha, beta, VL, ldvl, VR, ldvr, work, lwork, rwork, info, x17, x18);
            }
            mh$.invokeExact(jobvl, jobvr, n, A, lda, B, ldb, alpha, beta, VL, ldvl, VR, ldvr, work, lwork, rwork, info, x17, x18);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dggev3_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("dggev3_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dggev3_(const char *jobvl, const char *jobvr, const int *n, double *A, const int *lda, double *B, const int *ldb, double *alphar, double *alphai, double *beta, double *VL, const int *ldvl, double *VR, const int *ldvr, double *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor dggev3_$descriptor() {
        return dggev3_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dggev3_(const char *jobvl, const char *jobvr, const int *n, double *A, const int *lda, double *B, const int *ldb, double *alphar, double *alphai, double *beta, double *VL, const int *ldvl, double *VR, const int *ldvr, double *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle dggev3_$handle() {
        return dggev3_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dggev3_(const char *jobvl, const char *jobvr, const int *n, double *A, const int *lda, double *B, const int *ldb, double *alphar, double *alphai, double *beta, double *VL, const int *ldvl, double *VR, const int *ldvr, double *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment dggev3_$address() {
        return dggev3_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dggev3_(const char *jobvl, const char *jobvr, const int *n, double *A, const int *lda, double *B, const int *ldb, double *alphar, double *alphai, double *beta, double *VL, const int *ldvl, double *VR, const int *ldvr, double *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static void dggev3_(MemorySegment jobvl, MemorySegment jobvr, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment B, MemorySegment ldb, MemorySegment alphar, MemorySegment alphai, MemorySegment beta, MemorySegment VL, MemorySegment ldvl, MemorySegment VR, MemorySegment ldvr, MemorySegment work, MemorySegment lwork, MemorySegment info, long x17, long x18) {
        var mh$ = dggev3_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dggev3_", jobvl, jobvr, n, A, lda, B, ldb, alphar, alphai, beta, VL, ldvl, VR, ldvr, work, lwork, info, x17, x18);
            }
            mh$.invokeExact(jobvl, jobvr, n, A, lda, B, ldb, alphar, alphai, beta, VL, ldvl, VR, ldvr, work, lwork, info, x17, x18);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sggev3_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("sggev3_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void sggev3_(const char *jobvl, const char *jobvr, const int *n, float *A, const int *lda, float *B, const int *ldb, float *alphar, float *alphai, float *beta, float *VL, const int *ldvl, float *VR, const int *ldvr, float *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor sggev3_$descriptor() {
        return sggev3_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void sggev3_(const char *jobvl, const char *jobvr, const int *n, float *A, const int *lda, float *B, const int *ldb, float *alphar, float *alphai, float *beta, float *VL, const int *ldvl, float *VR, const int *ldvr, float *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle sggev3_$handle() {
        return sggev3_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void sggev3_(const char *jobvl, const char *jobvr, const int *n, float *A, const int *lda, float *B, const int *ldb, float *alphar, float *alphai, float *beta, float *VL, const int *ldvl, float *VR, const int *ldvr, float *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment sggev3_$address() {
        return sggev3_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void sggev3_(const char *jobvl, const char *jobvr, const int *n, float *A, const int *lda, float *B, const int *ldb, float *alphar, float *alphai, float *beta, float *VL, const int *ldvl, float *VR, const int *ldvr, float *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static void sggev3_(MemorySegment jobvl, MemorySegment jobvr, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment B, MemorySegment ldb, MemorySegment alphar, MemorySegment alphai, MemorySegment beta, MemorySegment VL, MemorySegment ldvl, MemorySegment VR, MemorySegment ldvr, MemorySegment work, MemorySegment lwork, MemorySegment info, long x17, long x18) {
        var mh$ = sggev3_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sggev3_", jobvl, jobvr, n, A, lda, B, ldb, alphar, alphai, beta, VL, ldvl, VR, ldvr, work, lwork, info, x17, x18);
            }
            mh$.invokeExact(jobvl, jobvr, n, A, lda, B, ldb, alphar, alphai, beta, VL, ldvl, VR, ldvr, work, lwork, info, x17, x18);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zggev3_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("zggev3_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zggev3_(const char *jobvl, const char *jobvr, const int *n, _Complex double *A, const int *lda, _Complex double *B, const int *ldb, _Complex double *alpha, _Complex double *beta, _Complex double *VL, const int *ldvl, _Complex double *VR, const int *ldvr, _Complex double *work, const int *lwork, double *rwork, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor zggev3_$descriptor() {
        return zggev3_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zggev3_(const char *jobvl, const char *jobvr, const int *n, _Complex double *A, const int *lda, _Complex double *B, const int *ldb, _Complex double *alpha, _Complex double *beta, _Complex double *VL, const int *ldvl, _Complex double *VR, const int *ldvr, _Complex double *work, const int *lwork, double *rwork, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle zggev3_$handle() {
        return zggev3_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zggev3_(const char *jobvl, const char *jobvr, const int *n, _Complex double *A, const int *lda, _Complex double *B, const int *ldb, _Complex double *alpha, _Complex double *beta, _Complex double *VL, const int *ldvl, _Complex double *VR, const int *ldvr, _Complex double *work, const int *lwork, double *rwork, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment zggev3_$address() {
        return zggev3_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zggev3_(const char *jobvl, const char *jobvr, const int *n, _Complex double *A, const int *lda, _Complex double *B, const int *ldb, _Complex double *alpha, _Complex double *beta, _Complex double *VL, const int *ldvl, _Complex double *VR, const int *ldvr, _Complex double *work, const int *lwork, double *rwork, int *info, size_t, size_t)
     * }
     */
    public static void zggev3_(MemorySegment jobvl, MemorySegment jobvr, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment B, MemorySegment ldb, MemorySegment alpha, MemorySegment beta, MemorySegment VL, MemorySegment ldvl, MemorySegment VR, MemorySegment ldvr, MemorySegment work, MemorySegment lwork, MemorySegment rwork, MemorySegment info, long x17, long x18) {
        var mh$ = zggev3_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zggev3_", jobvl, jobvr, n, A, lda, B, ldb, alpha, beta, VL, ldvl, VR, ldvr, work, lwork, rwork, info, x17, x18);
            }
            mh$.invokeExact(jobvl, jobvr, n, A, lda, B, ldb, alpha, beta, VL, ldvl, VR, ldvr, work, lwork, rwork, info, x17, x18);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cggevx_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cggevx_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cggevx_(const char *balanc, const char *jobvl, const char *jobvr, const char *sense, const int *n, _Complex float *A, const int *lda, _Complex float *B, const int *ldb, _Complex float *alpha, _Complex float *beta, _Complex float *VL, const int *ldvl, _Complex float *VR, const int *ldvr, int *ilo, int *ihi, float *lscale, float *rscale, float *abnrm, float *bbnrm, float *rconde, float *rcondv, _Complex float *work, const int *lwork, float *rwork, int *iwork, int *BWORK, int *info, size_t, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor cggevx_$descriptor() {
        return cggevx_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cggevx_(const char *balanc, const char *jobvl, const char *jobvr, const char *sense, const int *n, _Complex float *A, const int *lda, _Complex float *B, const int *ldb, _Complex float *alpha, _Complex float *beta, _Complex float *VL, const int *ldvl, _Complex float *VR, const int *ldvr, int *ilo, int *ihi, float *lscale, float *rscale, float *abnrm, float *bbnrm, float *rconde, float *rcondv, _Complex float *work, const int *lwork, float *rwork, int *iwork, int *BWORK, int *info, size_t, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle cggevx_$handle() {
        return cggevx_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cggevx_(const char *balanc, const char *jobvl, const char *jobvr, const char *sense, const int *n, _Complex float *A, const int *lda, _Complex float *B, const int *ldb, _Complex float *alpha, _Complex float *beta, _Complex float *VL, const int *ldvl, _Complex float *VR, const int *ldvr, int *ilo, int *ihi, float *lscale, float *rscale, float *abnrm, float *bbnrm, float *rconde, float *rcondv, _Complex float *work, const int *lwork, float *rwork, int *iwork, int *BWORK, int *info, size_t, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment cggevx_$address() {
        return cggevx_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cggevx_(const char *balanc, const char *jobvl, const char *jobvr, const char *sense, const int *n, _Complex float *A, const int *lda, _Complex float *B, const int *ldb, _Complex float *alpha, _Complex float *beta, _Complex float *VL, const int *ldvl, _Complex float *VR, const int *ldvr, int *ilo, int *ihi, float *lscale, float *rscale, float *abnrm, float *bbnrm, float *rconde, float *rcondv, _Complex float *work, const int *lwork, float *rwork, int *iwork, int *BWORK, int *info, size_t, size_t, size_t, size_t)
     * }
     */
    public static void cggevx_(MemorySegment balanc, MemorySegment jobvl, MemorySegment jobvr, MemorySegment sense, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment B, MemorySegment ldb, MemorySegment alpha, MemorySegment beta, MemorySegment VL, MemorySegment ldvl, MemorySegment VR, MemorySegment ldvr, MemorySegment ilo, MemorySegment ihi, MemorySegment lscale, MemorySegment rscale, MemorySegment abnrm, MemorySegment bbnrm, MemorySegment rconde, MemorySegment rcondv, MemorySegment work, MemorySegment lwork, MemorySegment rwork, MemorySegment iwork, MemorySegment BWORK, MemorySegment info, long x29, long x30, long x31, long x32) {
        var mh$ = cggevx_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cggevx_", balanc, jobvl, jobvr, sense, n, A, lda, B, ldb, alpha, beta, VL, ldvl, VR, ldvr, ilo, ihi, lscale, rscale, abnrm, bbnrm, rconde, rcondv, work, lwork, rwork, iwork, BWORK, info, x29, x30, x31, x32);
            }
            mh$.invokeExact(balanc, jobvl, jobvr, sense, n, A, lda, B, ldb, alpha, beta, VL, ldvl, VR, ldvr, ilo, ihi, lscale, rscale, abnrm, bbnrm, rconde, rcondv, work, lwork, rwork, iwork, BWORK, info, x29, x30, x31, x32);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dggevx_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("dggevx_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dggevx_(const char *balanc, const char *jobvl, const char *jobvr, const char *sense, const int *n, double *A, const int *lda, double *B, const int *ldb, double *alphar, double *alphai, double *beta, double *VL, const int *ldvl, double *VR, const int *ldvr, int *ilo, int *ihi, double *lscale, double *rscale, double *abnrm, double *bbnrm, double *rconde, double *rcondv, double *work, const int *lwork, int *iwork, int *BWORK, int *info, size_t, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor dggevx_$descriptor() {
        return dggevx_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dggevx_(const char *balanc, const char *jobvl, const char *jobvr, const char *sense, const int *n, double *A, const int *lda, double *B, const int *ldb, double *alphar, double *alphai, double *beta, double *VL, const int *ldvl, double *VR, const int *ldvr, int *ilo, int *ihi, double *lscale, double *rscale, double *abnrm, double *bbnrm, double *rconde, double *rcondv, double *work, const int *lwork, int *iwork, int *BWORK, int *info, size_t, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle dggevx_$handle() {
        return dggevx_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dggevx_(const char *balanc, const char *jobvl, const char *jobvr, const char *sense, const int *n, double *A, const int *lda, double *B, const int *ldb, double *alphar, double *alphai, double *beta, double *VL, const int *ldvl, double *VR, const int *ldvr, int *ilo, int *ihi, double *lscale, double *rscale, double *abnrm, double *bbnrm, double *rconde, double *rcondv, double *work, const int *lwork, int *iwork, int *BWORK, int *info, size_t, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment dggevx_$address() {
        return dggevx_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dggevx_(const char *balanc, const char *jobvl, const char *jobvr, const char *sense, const int *n, double *A, const int *lda, double *B, const int *ldb, double *alphar, double *alphai, double *beta, double *VL, const int *ldvl, double *VR, const int *ldvr, int *ilo, int *ihi, double *lscale, double *rscale, double *abnrm, double *bbnrm, double *rconde, double *rcondv, double *work, const int *lwork, int *iwork, int *BWORK, int *info, size_t, size_t, size_t, size_t)
     * }
     */
    public static void dggevx_(MemorySegment balanc, MemorySegment jobvl, MemorySegment jobvr, MemorySegment sense, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment B, MemorySegment ldb, MemorySegment alphar, MemorySegment alphai, MemorySegment beta, MemorySegment VL, MemorySegment ldvl, MemorySegment VR, MemorySegment ldvr, MemorySegment ilo, MemorySegment ihi, MemorySegment lscale, MemorySegment rscale, MemorySegment abnrm, MemorySegment bbnrm, MemorySegment rconde, MemorySegment rcondv, MemorySegment work, MemorySegment lwork, MemorySegment iwork, MemorySegment BWORK, MemorySegment info, long x29, long x30, long x31, long x32) {
        var mh$ = dggevx_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dggevx_", balanc, jobvl, jobvr, sense, n, A, lda, B, ldb, alphar, alphai, beta, VL, ldvl, VR, ldvr, ilo, ihi, lscale, rscale, abnrm, bbnrm, rconde, rcondv, work, lwork, iwork, BWORK, info, x29, x30, x31, x32);
            }
            mh$.invokeExact(balanc, jobvl, jobvr, sense, n, A, lda, B, ldb, alphar, alphai, beta, VL, ldvl, VR, ldvr, ilo, ihi, lscale, rscale, abnrm, bbnrm, rconde, rcondv, work, lwork, iwork, BWORK, info, x29, x30, x31, x32);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sggevx_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("sggevx_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void sggevx_(const char *balanc, const char *jobvl, const char *jobvr, const char *sense, const int *n, float *A, const int *lda, float *B, const int *ldb, float *alphar, float *alphai, float *beta, float *VL, const int *ldvl, float *VR, const int *ldvr, int *ilo, int *ihi, float *lscale, float *rscale, float *abnrm, float *bbnrm, float *rconde, float *rcondv, float *work, const int *lwork, int *iwork, int *BWORK, int *info, size_t, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor sggevx_$descriptor() {
        return sggevx_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void sggevx_(const char *balanc, const char *jobvl, const char *jobvr, const char *sense, const int *n, float *A, const int *lda, float *B, const int *ldb, float *alphar, float *alphai, float *beta, float *VL, const int *ldvl, float *VR, const int *ldvr, int *ilo, int *ihi, float *lscale, float *rscale, float *abnrm, float *bbnrm, float *rconde, float *rcondv, float *work, const int *lwork, int *iwork, int *BWORK, int *info, size_t, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle sggevx_$handle() {
        return sggevx_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void sggevx_(const char *balanc, const char *jobvl, const char *jobvr, const char *sense, const int *n, float *A, const int *lda, float *B, const int *ldb, float *alphar, float *alphai, float *beta, float *VL, const int *ldvl, float *VR, const int *ldvr, int *ilo, int *ihi, float *lscale, float *rscale, float *abnrm, float *bbnrm, float *rconde, float *rcondv, float *work, const int *lwork, int *iwork, int *BWORK, int *info, size_t, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment sggevx_$address() {
        return sggevx_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void sggevx_(const char *balanc, const char *jobvl, const char *jobvr, const char *sense, const int *n, float *A, const int *lda, float *B, const int *ldb, float *alphar, float *alphai, float *beta, float *VL, const int *ldvl, float *VR, const int *ldvr, int *ilo, int *ihi, float *lscale, float *rscale, float *abnrm, float *bbnrm, float *rconde, float *rcondv, float *work, const int *lwork, int *iwork, int *BWORK, int *info, size_t, size_t, size_t, size_t)
     * }
     */
    public static void sggevx_(MemorySegment balanc, MemorySegment jobvl, MemorySegment jobvr, MemorySegment sense, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment B, MemorySegment ldb, MemorySegment alphar, MemorySegment alphai, MemorySegment beta, MemorySegment VL, MemorySegment ldvl, MemorySegment VR, MemorySegment ldvr, MemorySegment ilo, MemorySegment ihi, MemorySegment lscale, MemorySegment rscale, MemorySegment abnrm, MemorySegment bbnrm, MemorySegment rconde, MemorySegment rcondv, MemorySegment work, MemorySegment lwork, MemorySegment iwork, MemorySegment BWORK, MemorySegment info, long x29, long x30, long x31, long x32) {
        var mh$ = sggevx_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sggevx_", balanc, jobvl, jobvr, sense, n, A, lda, B, ldb, alphar, alphai, beta, VL, ldvl, VR, ldvr, ilo, ihi, lscale, rscale, abnrm, bbnrm, rconde, rcondv, work, lwork, iwork, BWORK, info, x29, x30, x31, x32);
            }
            mh$.invokeExact(balanc, jobvl, jobvr, sense, n, A, lda, B, ldb, alphar, alphai, beta, VL, ldvl, VR, ldvr, ilo, ihi, lscale, rscale, abnrm, bbnrm, rconde, rcondv, work, lwork, iwork, BWORK, info, x29, x30, x31, x32);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zggevx_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("zggevx_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zggevx_(const char *balanc, const char *jobvl, const char *jobvr, const char *sense, const int *n, _Complex double *A, const int *lda, _Complex double *B, const int *ldb, _Complex double *alpha, _Complex double *beta, _Complex double *VL, const int *ldvl, _Complex double *VR, const int *ldvr, int *ilo, int *ihi, double *lscale, double *rscale, double *abnrm, double *bbnrm, double *rconde, double *rcondv, _Complex double *work, const int *lwork, double *rwork, int *iwork, int *BWORK, int *info, size_t, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor zggevx_$descriptor() {
        return zggevx_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zggevx_(const char *balanc, const char *jobvl, const char *jobvr, const char *sense, const int *n, _Complex double *A, const int *lda, _Complex double *B, const int *ldb, _Complex double *alpha, _Complex double *beta, _Complex double *VL, const int *ldvl, _Complex double *VR, const int *ldvr, int *ilo, int *ihi, double *lscale, double *rscale, double *abnrm, double *bbnrm, double *rconde, double *rcondv, _Complex double *work, const int *lwork, double *rwork, int *iwork, int *BWORK, int *info, size_t, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle zggevx_$handle() {
        return zggevx_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zggevx_(const char *balanc, const char *jobvl, const char *jobvr, const char *sense, const int *n, _Complex double *A, const int *lda, _Complex double *B, const int *ldb, _Complex double *alpha, _Complex double *beta, _Complex double *VL, const int *ldvl, _Complex double *VR, const int *ldvr, int *ilo, int *ihi, double *lscale, double *rscale, double *abnrm, double *bbnrm, double *rconde, double *rcondv, _Complex double *work, const int *lwork, double *rwork, int *iwork, int *BWORK, int *info, size_t, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment zggevx_$address() {
        return zggevx_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zggevx_(const char *balanc, const char *jobvl, const char *jobvr, const char *sense, const int *n, _Complex double *A, const int *lda, _Complex double *B, const int *ldb, _Complex double *alpha, _Complex double *beta, _Complex double *VL, const int *ldvl, _Complex double *VR, const int *ldvr, int *ilo, int *ihi, double *lscale, double *rscale, double *abnrm, double *bbnrm, double *rconde, double *rcondv, _Complex double *work, const int *lwork, double *rwork, int *iwork, int *BWORK, int *info, size_t, size_t, size_t, size_t)
     * }
     */
    public static void zggevx_(MemorySegment balanc, MemorySegment jobvl, MemorySegment jobvr, MemorySegment sense, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment B, MemorySegment ldb, MemorySegment alpha, MemorySegment beta, MemorySegment VL, MemorySegment ldvl, MemorySegment VR, MemorySegment ldvr, MemorySegment ilo, MemorySegment ihi, MemorySegment lscale, MemorySegment rscale, MemorySegment abnrm, MemorySegment bbnrm, MemorySegment rconde, MemorySegment rcondv, MemorySegment work, MemorySegment lwork, MemorySegment rwork, MemorySegment iwork, MemorySegment BWORK, MemorySegment info, long x29, long x30, long x31, long x32) {
        var mh$ = zggevx_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zggevx_", balanc, jobvl, jobvr, sense, n, A, lda, B, ldb, alpha, beta, VL, ldvl, VR, ldvr, ilo, ihi, lscale, rscale, abnrm, bbnrm, rconde, rcondv, work, lwork, rwork, iwork, BWORK, info, x29, x30, x31, x32);
            }
            mh$.invokeExact(balanc, jobvl, jobvr, sense, n, A, lda, B, ldb, alpha, beta, VL, ldvl, VR, ldvr, ilo, ihi, lscale, rscale, abnrm, bbnrm, rconde, rcondv, work, lwork, rwork, iwork, BWORK, info, x29, x30, x31, x32);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cggglm_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cggglm_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cggglm_(const int *n, const int *m, const int *p, _Complex float *A, const int *lda, _Complex float *B, const int *ldb, _Complex float *D, _Complex float *X, _Complex float *Y, _Complex float *work, const int *lwork, int *info)
     * }
     */
    public static FunctionDescriptor cggglm_$descriptor() {
        return cggglm_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cggglm_(const int *n, const int *m, const int *p, _Complex float *A, const int *lda, _Complex float *B, const int *ldb, _Complex float *D, _Complex float *X, _Complex float *Y, _Complex float *work, const int *lwork, int *info)
     * }
     */
    public static MethodHandle cggglm_$handle() {
        return cggglm_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cggglm_(const int *n, const int *m, const int *p, _Complex float *A, const int *lda, _Complex float *B, const int *ldb, _Complex float *D, _Complex float *X, _Complex float *Y, _Complex float *work, const int *lwork, int *info)
     * }
     */
    public static MemorySegment cggglm_$address() {
        return cggglm_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cggglm_(const int *n, const int *m, const int *p, _Complex float *A, const int *lda, _Complex float *B, const int *ldb, _Complex float *D, _Complex float *X, _Complex float *Y, _Complex float *work, const int *lwork, int *info)
     * }
     */
    public static void cggglm_(MemorySegment n, MemorySegment m, MemorySegment p, MemorySegment A, MemorySegment lda, MemorySegment B, MemorySegment ldb, MemorySegment D, MemorySegment X, MemorySegment Y, MemorySegment work, MemorySegment lwork, MemorySegment info) {
        var mh$ = cggglm_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cggglm_", n, m, p, A, lda, B, ldb, D, X, Y, work, lwork, info);
            }
            mh$.invokeExact(n, m, p, A, lda, B, ldb, D, X, Y, work, lwork, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dggglm_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("dggglm_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dggglm_(const int *n, const int *m, const int *p, double *A, const int *lda, double *B, const int *ldb, double *D, double *X, double *Y, double *work, const int *lwork, int *info)
     * }
     */
    public static FunctionDescriptor dggglm_$descriptor() {
        return dggglm_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dggglm_(const int *n, const int *m, const int *p, double *A, const int *lda, double *B, const int *ldb, double *D, double *X, double *Y, double *work, const int *lwork, int *info)
     * }
     */
    public static MethodHandle dggglm_$handle() {
        return dggglm_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dggglm_(const int *n, const int *m, const int *p, double *A, const int *lda, double *B, const int *ldb, double *D, double *X, double *Y, double *work, const int *lwork, int *info)
     * }
     */
    public static MemorySegment dggglm_$address() {
        return dggglm_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dggglm_(const int *n, const int *m, const int *p, double *A, const int *lda, double *B, const int *ldb, double *D, double *X, double *Y, double *work, const int *lwork, int *info)
     * }
     */
    public static void dggglm_(MemorySegment n, MemorySegment m, MemorySegment p, MemorySegment A, MemorySegment lda, MemorySegment B, MemorySegment ldb, MemorySegment D, MemorySegment X, MemorySegment Y, MemorySegment work, MemorySegment lwork, MemorySegment info) {
        var mh$ = dggglm_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dggglm_", n, m, p, A, lda, B, ldb, D, X, Y, work, lwork, info);
            }
            mh$.invokeExact(n, m, p, A, lda, B, ldb, D, X, Y, work, lwork, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sggglm_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("sggglm_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void sggglm_(const int *n, const int *m, const int *p, float *A, const int *lda, float *B, const int *ldb, float *D, float *X, float *Y, float *work, const int *lwork, int *info)
     * }
     */
    public static FunctionDescriptor sggglm_$descriptor() {
        return sggglm_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void sggglm_(const int *n, const int *m, const int *p, float *A, const int *lda, float *B, const int *ldb, float *D, float *X, float *Y, float *work, const int *lwork, int *info)
     * }
     */
    public static MethodHandle sggglm_$handle() {
        return sggglm_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void sggglm_(const int *n, const int *m, const int *p, float *A, const int *lda, float *B, const int *ldb, float *D, float *X, float *Y, float *work, const int *lwork, int *info)
     * }
     */
    public static MemorySegment sggglm_$address() {
        return sggglm_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void sggglm_(const int *n, const int *m, const int *p, float *A, const int *lda, float *B, const int *ldb, float *D, float *X, float *Y, float *work, const int *lwork, int *info)
     * }
     */
    public static void sggglm_(MemorySegment n, MemorySegment m, MemorySegment p, MemorySegment A, MemorySegment lda, MemorySegment B, MemorySegment ldb, MemorySegment D, MemorySegment X, MemorySegment Y, MemorySegment work, MemorySegment lwork, MemorySegment info) {
        var mh$ = sggglm_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sggglm_", n, m, p, A, lda, B, ldb, D, X, Y, work, lwork, info);
            }
            mh$.invokeExact(n, m, p, A, lda, B, ldb, D, X, Y, work, lwork, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zggglm_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("zggglm_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zggglm_(const int *n, const int *m, const int *p, _Complex double *A, const int *lda, _Complex double *B, const int *ldb, _Complex double *D, _Complex double *X, _Complex double *Y, _Complex double *work, const int *lwork, int *info)
     * }
     */
    public static FunctionDescriptor zggglm_$descriptor() {
        return zggglm_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zggglm_(const int *n, const int *m, const int *p, _Complex double *A, const int *lda, _Complex double *B, const int *ldb, _Complex double *D, _Complex double *X, _Complex double *Y, _Complex double *work, const int *lwork, int *info)
     * }
     */
    public static MethodHandle zggglm_$handle() {
        return zggglm_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zggglm_(const int *n, const int *m, const int *p, _Complex double *A, const int *lda, _Complex double *B, const int *ldb, _Complex double *D, _Complex double *X, _Complex double *Y, _Complex double *work, const int *lwork, int *info)
     * }
     */
    public static MemorySegment zggglm_$address() {
        return zggglm_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zggglm_(const int *n, const int *m, const int *p, _Complex double *A, const int *lda, _Complex double *B, const int *ldb, _Complex double *D, _Complex double *X, _Complex double *Y, _Complex double *work, const int *lwork, int *info)
     * }
     */
    public static void zggglm_(MemorySegment n, MemorySegment m, MemorySegment p, MemorySegment A, MemorySegment lda, MemorySegment B, MemorySegment ldb, MemorySegment D, MemorySegment X, MemorySegment Y, MemorySegment work, MemorySegment lwork, MemorySegment info) {
        var mh$ = zggglm_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zggglm_", n, m, p, A, lda, B, ldb, D, X, Y, work, lwork, info);
            }
            mh$.invokeExact(n, m, p, A, lda, B, ldb, D, X, Y, work, lwork, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cgghd3_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cgghd3_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cgghd3_(const char *compq, const char *compz, const int *n, const int *ilo, const int *ihi, _Complex float *A, const int *lda, _Complex float *B, const int *ldb, _Complex float *Q, const int *ldq, _Complex float *Z, const int *ldz, _Complex float *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor cgghd3_$descriptor() {
        return cgghd3_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cgghd3_(const char *compq, const char *compz, const int *n, const int *ilo, const int *ihi, _Complex float *A, const int *lda, _Complex float *B, const int *ldb, _Complex float *Q, const int *ldq, _Complex float *Z, const int *ldz, _Complex float *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle cgghd3_$handle() {
        return cgghd3_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cgghd3_(const char *compq, const char *compz, const int *n, const int *ilo, const int *ihi, _Complex float *A, const int *lda, _Complex float *B, const int *ldb, _Complex float *Q, const int *ldq, _Complex float *Z, const int *ldz, _Complex float *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment cgghd3_$address() {
        return cgghd3_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cgghd3_(const char *compq, const char *compz, const int *n, const int *ilo, const int *ihi, _Complex float *A, const int *lda, _Complex float *B, const int *ldb, _Complex float *Q, const int *ldq, _Complex float *Z, const int *ldz, _Complex float *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static void cgghd3_(MemorySegment compq, MemorySegment compz, MemorySegment n, MemorySegment ilo, MemorySegment ihi, MemorySegment A, MemorySegment lda, MemorySegment B, MemorySegment ldb, MemorySegment Q, MemorySegment ldq, MemorySegment Z, MemorySegment ldz, MemorySegment work, MemorySegment lwork, MemorySegment info, long x16, long x17) {
        var mh$ = cgghd3_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cgghd3_", compq, compz, n, ilo, ihi, A, lda, B, ldb, Q, ldq, Z, ldz, work, lwork, info, x16, x17);
            }
            mh$.invokeExact(compq, compz, n, ilo, ihi, A, lda, B, ldb, Q, ldq, Z, ldz, work, lwork, info, x16, x17);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dgghd3_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("dgghd3_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dgghd3_(const char *compq, const char *compz, const int *n, const int *ilo, const int *ihi, double *A, const int *lda, double *B, const int *ldb, double *Q, const int *ldq, double *Z, const int *ldz, double *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor dgghd3_$descriptor() {
        return dgghd3_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dgghd3_(const char *compq, const char *compz, const int *n, const int *ilo, const int *ihi, double *A, const int *lda, double *B, const int *ldb, double *Q, const int *ldq, double *Z, const int *ldz, double *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle dgghd3_$handle() {
        return dgghd3_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dgghd3_(const char *compq, const char *compz, const int *n, const int *ilo, const int *ihi, double *A, const int *lda, double *B, const int *ldb, double *Q, const int *ldq, double *Z, const int *ldz, double *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment dgghd3_$address() {
        return dgghd3_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dgghd3_(const char *compq, const char *compz, const int *n, const int *ilo, const int *ihi, double *A, const int *lda, double *B, const int *ldb, double *Q, const int *ldq, double *Z, const int *ldz, double *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static void dgghd3_(MemorySegment compq, MemorySegment compz, MemorySegment n, MemorySegment ilo, MemorySegment ihi, MemorySegment A, MemorySegment lda, MemorySegment B, MemorySegment ldb, MemorySegment Q, MemorySegment ldq, MemorySegment Z, MemorySegment ldz, MemorySegment work, MemorySegment lwork, MemorySegment info, long x16, long x17) {
        var mh$ = dgghd3_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dgghd3_", compq, compz, n, ilo, ihi, A, lda, B, ldb, Q, ldq, Z, ldz, work, lwork, info, x16, x17);
            }
            mh$.invokeExact(compq, compz, n, ilo, ihi, A, lda, B, ldb, Q, ldq, Z, ldz, work, lwork, info, x16, x17);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sgghd3_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("sgghd3_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void sgghd3_(const char *compq, const char *compz, const int *n, const int *ilo, const int *ihi, float *A, const int *lda, float *B, const int *ldb, float *Q, const int *ldq, float *Z, const int *ldz, float *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor sgghd3_$descriptor() {
        return sgghd3_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void sgghd3_(const char *compq, const char *compz, const int *n, const int *ilo, const int *ihi, float *A, const int *lda, float *B, const int *ldb, float *Q, const int *ldq, float *Z, const int *ldz, float *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle sgghd3_$handle() {
        return sgghd3_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void sgghd3_(const char *compq, const char *compz, const int *n, const int *ilo, const int *ihi, float *A, const int *lda, float *B, const int *ldb, float *Q, const int *ldq, float *Z, const int *ldz, float *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment sgghd3_$address() {
        return sgghd3_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void sgghd3_(const char *compq, const char *compz, const int *n, const int *ilo, const int *ihi, float *A, const int *lda, float *B, const int *ldb, float *Q, const int *ldq, float *Z, const int *ldz, float *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static void sgghd3_(MemorySegment compq, MemorySegment compz, MemorySegment n, MemorySegment ilo, MemorySegment ihi, MemorySegment A, MemorySegment lda, MemorySegment B, MemorySegment ldb, MemorySegment Q, MemorySegment ldq, MemorySegment Z, MemorySegment ldz, MemorySegment work, MemorySegment lwork, MemorySegment info, long x16, long x17) {
        var mh$ = sgghd3_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sgghd3_", compq, compz, n, ilo, ihi, A, lda, B, ldb, Q, ldq, Z, ldz, work, lwork, info, x16, x17);
            }
            mh$.invokeExact(compq, compz, n, ilo, ihi, A, lda, B, ldb, Q, ldq, Z, ldz, work, lwork, info, x16, x17);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zgghd3_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("zgghd3_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zgghd3_(const char *compq, const char *compz, const int *n, const int *ilo, const int *ihi, _Complex double *A, const int *lda, _Complex double *B, const int *ldb, _Complex double *Q, const int *ldq, _Complex double *Z, const int *ldz, _Complex double *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor zgghd3_$descriptor() {
        return zgghd3_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zgghd3_(const char *compq, const char *compz, const int *n, const int *ilo, const int *ihi, _Complex double *A, const int *lda, _Complex double *B, const int *ldb, _Complex double *Q, const int *ldq, _Complex double *Z, const int *ldz, _Complex double *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle zgghd3_$handle() {
        return zgghd3_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zgghd3_(const char *compq, const char *compz, const int *n, const int *ilo, const int *ihi, _Complex double *A, const int *lda, _Complex double *B, const int *ldb, _Complex double *Q, const int *ldq, _Complex double *Z, const int *ldz, _Complex double *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment zgghd3_$address() {
        return zgghd3_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zgghd3_(const char *compq, const char *compz, const int *n, const int *ilo, const int *ihi, _Complex double *A, const int *lda, _Complex double *B, const int *ldb, _Complex double *Q, const int *ldq, _Complex double *Z, const int *ldz, _Complex double *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static void zgghd3_(MemorySegment compq, MemorySegment compz, MemorySegment n, MemorySegment ilo, MemorySegment ihi, MemorySegment A, MemorySegment lda, MemorySegment B, MemorySegment ldb, MemorySegment Q, MemorySegment ldq, MemorySegment Z, MemorySegment ldz, MemorySegment work, MemorySegment lwork, MemorySegment info, long x16, long x17) {
        var mh$ = zgghd3_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zgghd3_", compq, compz, n, ilo, ihi, A, lda, B, ldb, Q, ldq, Z, ldz, work, lwork, info, x16, x17);
            }
            mh$.invokeExact(compq, compz, n, ilo, ihi, A, lda, B, ldb, Q, ldq, Z, ldz, work, lwork, info, x16, x17);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cgghrd_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cgghrd_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cgghrd_(const char *compq, const char *compz, const int *n, const int *ilo, const int *ihi, _Complex float *A, const int *lda, _Complex float *B, const int *ldb, _Complex float *Q, const int *ldq, _Complex float *Z, const int *ldz, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor cgghrd_$descriptor() {
        return cgghrd_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cgghrd_(const char *compq, const char *compz, const int *n, const int *ilo, const int *ihi, _Complex float *A, const int *lda, _Complex float *B, const int *ldb, _Complex float *Q, const int *ldq, _Complex float *Z, const int *ldz, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle cgghrd_$handle() {
        return cgghrd_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cgghrd_(const char *compq, const char *compz, const int *n, const int *ilo, const int *ihi, _Complex float *A, const int *lda, _Complex float *B, const int *ldb, _Complex float *Q, const int *ldq, _Complex float *Z, const int *ldz, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment cgghrd_$address() {
        return cgghrd_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cgghrd_(const char *compq, const char *compz, const int *n, const int *ilo, const int *ihi, _Complex float *A, const int *lda, _Complex float *B, const int *ldb, _Complex float *Q, const int *ldq, _Complex float *Z, const int *ldz, int *info, size_t, size_t)
     * }
     */
    public static void cgghrd_(MemorySegment compq, MemorySegment compz, MemorySegment n, MemorySegment ilo, MemorySegment ihi, MemorySegment A, MemorySegment lda, MemorySegment B, MemorySegment ldb, MemorySegment Q, MemorySegment ldq, MemorySegment Z, MemorySegment ldz, MemorySegment info, long x14, long x15) {
        var mh$ = cgghrd_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cgghrd_", compq, compz, n, ilo, ihi, A, lda, B, ldb, Q, ldq, Z, ldz, info, x14, x15);
            }
            mh$.invokeExact(compq, compz, n, ilo, ihi, A, lda, B, ldb, Q, ldq, Z, ldz, info, x14, x15);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dgghrd_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("dgghrd_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dgghrd_(const char *compq, const char *compz, const int *n, const int *ilo, const int *ihi, double *A, const int *lda, double *B, const int *ldb, double *Q, const int *ldq, double *Z, const int *ldz, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor dgghrd_$descriptor() {
        return dgghrd_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dgghrd_(const char *compq, const char *compz, const int *n, const int *ilo, const int *ihi, double *A, const int *lda, double *B, const int *ldb, double *Q, const int *ldq, double *Z, const int *ldz, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle dgghrd_$handle() {
        return dgghrd_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dgghrd_(const char *compq, const char *compz, const int *n, const int *ilo, const int *ihi, double *A, const int *lda, double *B, const int *ldb, double *Q, const int *ldq, double *Z, const int *ldz, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment dgghrd_$address() {
        return dgghrd_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dgghrd_(const char *compq, const char *compz, const int *n, const int *ilo, const int *ihi, double *A, const int *lda, double *B, const int *ldb, double *Q, const int *ldq, double *Z, const int *ldz, int *info, size_t, size_t)
     * }
     */
    public static void dgghrd_(MemorySegment compq, MemorySegment compz, MemorySegment n, MemorySegment ilo, MemorySegment ihi, MemorySegment A, MemorySegment lda, MemorySegment B, MemorySegment ldb, MemorySegment Q, MemorySegment ldq, MemorySegment Z, MemorySegment ldz, MemorySegment info, long x14, long x15) {
        var mh$ = dgghrd_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dgghrd_", compq, compz, n, ilo, ihi, A, lda, B, ldb, Q, ldq, Z, ldz, info, x14, x15);
            }
            mh$.invokeExact(compq, compz, n, ilo, ihi, A, lda, B, ldb, Q, ldq, Z, ldz, info, x14, x15);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sgghrd_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("sgghrd_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void sgghrd_(const char *compq, const char *compz, const int *n, const int *ilo, const int *ihi, float *A, const int *lda, float *B, const int *ldb, float *Q, const int *ldq, float *Z, const int *ldz, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor sgghrd_$descriptor() {
        return sgghrd_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void sgghrd_(const char *compq, const char *compz, const int *n, const int *ilo, const int *ihi, float *A, const int *lda, float *B, const int *ldb, float *Q, const int *ldq, float *Z, const int *ldz, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle sgghrd_$handle() {
        return sgghrd_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void sgghrd_(const char *compq, const char *compz, const int *n, const int *ilo, const int *ihi, float *A, const int *lda, float *B, const int *ldb, float *Q, const int *ldq, float *Z, const int *ldz, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment sgghrd_$address() {
        return sgghrd_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void sgghrd_(const char *compq, const char *compz, const int *n, const int *ilo, const int *ihi, float *A, const int *lda, float *B, const int *ldb, float *Q, const int *ldq, float *Z, const int *ldz, int *info, size_t, size_t)
     * }
     */
    public static void sgghrd_(MemorySegment compq, MemorySegment compz, MemorySegment n, MemorySegment ilo, MemorySegment ihi, MemorySegment A, MemorySegment lda, MemorySegment B, MemorySegment ldb, MemorySegment Q, MemorySegment ldq, MemorySegment Z, MemorySegment ldz, MemorySegment info, long x14, long x15) {
        var mh$ = sgghrd_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sgghrd_", compq, compz, n, ilo, ihi, A, lda, B, ldb, Q, ldq, Z, ldz, info, x14, x15);
            }
            mh$.invokeExact(compq, compz, n, ilo, ihi, A, lda, B, ldb, Q, ldq, Z, ldz, info, x14, x15);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zgghrd_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("zgghrd_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zgghrd_(const char *compq, const char *compz, const int *n, const int *ilo, const int *ihi, _Complex double *A, const int *lda, _Complex double *B, const int *ldb, _Complex double *Q, const int *ldq, _Complex double *Z, const int *ldz, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor zgghrd_$descriptor() {
        return zgghrd_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zgghrd_(const char *compq, const char *compz, const int *n, const int *ilo, const int *ihi, _Complex double *A, const int *lda, _Complex double *B, const int *ldb, _Complex double *Q, const int *ldq, _Complex double *Z, const int *ldz, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle zgghrd_$handle() {
        return zgghrd_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zgghrd_(const char *compq, const char *compz, const int *n, const int *ilo, const int *ihi, _Complex double *A, const int *lda, _Complex double *B, const int *ldb, _Complex double *Q, const int *ldq, _Complex double *Z, const int *ldz, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment zgghrd_$address() {
        return zgghrd_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zgghrd_(const char *compq, const char *compz, const int *n, const int *ilo, const int *ihi, _Complex double *A, const int *lda, _Complex double *B, const int *ldb, _Complex double *Q, const int *ldq, _Complex double *Z, const int *ldz, int *info, size_t, size_t)
     * }
     */
    public static void zgghrd_(MemorySegment compq, MemorySegment compz, MemorySegment n, MemorySegment ilo, MemorySegment ihi, MemorySegment A, MemorySegment lda, MemorySegment B, MemorySegment ldb, MemorySegment Q, MemorySegment ldq, MemorySegment Z, MemorySegment ldz, MemorySegment info, long x14, long x15) {
        var mh$ = zgghrd_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zgghrd_", compq, compz, n, ilo, ihi, A, lda, B, ldb, Q, ldq, Z, ldz, info, x14, x15);
            }
            mh$.invokeExact(compq, compz, n, ilo, ihi, A, lda, B, ldb, Q, ldq, Z, ldz, info, x14, x15);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cgglse_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cgglse_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cgglse_(const int *m, const int *n, const int *p, _Complex float *A, const int *lda, _Complex float *B, const int *ldb, _Complex float *C, _Complex float *D, _Complex float *X, _Complex float *work, const int *lwork, int *info)
     * }
     */
    public static FunctionDescriptor cgglse_$descriptor() {
        return cgglse_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cgglse_(const int *m, const int *n, const int *p, _Complex float *A, const int *lda, _Complex float *B, const int *ldb, _Complex float *C, _Complex float *D, _Complex float *X, _Complex float *work, const int *lwork, int *info)
     * }
     */
    public static MethodHandle cgglse_$handle() {
        return cgglse_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cgglse_(const int *m, const int *n, const int *p, _Complex float *A, const int *lda, _Complex float *B, const int *ldb, _Complex float *C, _Complex float *D, _Complex float *X, _Complex float *work, const int *lwork, int *info)
     * }
     */
    public static MemorySegment cgglse_$address() {
        return cgglse_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cgglse_(const int *m, const int *n, const int *p, _Complex float *A, const int *lda, _Complex float *B, const int *ldb, _Complex float *C, _Complex float *D, _Complex float *X, _Complex float *work, const int *lwork, int *info)
     * }
     */
    public static void cgglse_(MemorySegment m, MemorySegment n, MemorySegment p, MemorySegment A, MemorySegment lda, MemorySegment B, MemorySegment ldb, MemorySegment C, MemorySegment D, MemorySegment X, MemorySegment work, MemorySegment lwork, MemorySegment info) {
        var mh$ = cgglse_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cgglse_", m, n, p, A, lda, B, ldb, C, D, X, work, lwork, info);
            }
            mh$.invokeExact(m, n, p, A, lda, B, ldb, C, D, X, work, lwork, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dgglse_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("dgglse_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dgglse_(const int *m, const int *n, const int *p, double *A, const int *lda, double *B, const int *ldb, double *C, double *D, double *X, double *work, const int *lwork, int *info)
     * }
     */
    public static FunctionDescriptor dgglse_$descriptor() {
        return dgglse_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dgglse_(const int *m, const int *n, const int *p, double *A, const int *lda, double *B, const int *ldb, double *C, double *D, double *X, double *work, const int *lwork, int *info)
     * }
     */
    public static MethodHandle dgglse_$handle() {
        return dgglse_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dgglse_(const int *m, const int *n, const int *p, double *A, const int *lda, double *B, const int *ldb, double *C, double *D, double *X, double *work, const int *lwork, int *info)
     * }
     */
    public static MemorySegment dgglse_$address() {
        return dgglse_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dgglse_(const int *m, const int *n, const int *p, double *A, const int *lda, double *B, const int *ldb, double *C, double *D, double *X, double *work, const int *lwork, int *info)
     * }
     */
    public static void dgglse_(MemorySegment m, MemorySegment n, MemorySegment p, MemorySegment A, MemorySegment lda, MemorySegment B, MemorySegment ldb, MemorySegment C, MemorySegment D, MemorySegment X, MemorySegment work, MemorySegment lwork, MemorySegment info) {
        var mh$ = dgglse_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dgglse_", m, n, p, A, lda, B, ldb, C, D, X, work, lwork, info);
            }
            mh$.invokeExact(m, n, p, A, lda, B, ldb, C, D, X, work, lwork, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sgglse_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("sgglse_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void sgglse_(const int *m, const int *n, const int *p, float *A, const int *lda, float *B, const int *ldb, float *C, float *D, float *X, float *work, const int *lwork, int *info)
     * }
     */
    public static FunctionDescriptor sgglse_$descriptor() {
        return sgglse_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void sgglse_(const int *m, const int *n, const int *p, float *A, const int *lda, float *B, const int *ldb, float *C, float *D, float *X, float *work, const int *lwork, int *info)
     * }
     */
    public static MethodHandle sgglse_$handle() {
        return sgglse_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void sgglse_(const int *m, const int *n, const int *p, float *A, const int *lda, float *B, const int *ldb, float *C, float *D, float *X, float *work, const int *lwork, int *info)
     * }
     */
    public static MemorySegment sgglse_$address() {
        return sgglse_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void sgglse_(const int *m, const int *n, const int *p, float *A, const int *lda, float *B, const int *ldb, float *C, float *D, float *X, float *work, const int *lwork, int *info)
     * }
     */
    public static void sgglse_(MemorySegment m, MemorySegment n, MemorySegment p, MemorySegment A, MemorySegment lda, MemorySegment B, MemorySegment ldb, MemorySegment C, MemorySegment D, MemorySegment X, MemorySegment work, MemorySegment lwork, MemorySegment info) {
        var mh$ = sgglse_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sgglse_", m, n, p, A, lda, B, ldb, C, D, X, work, lwork, info);
            }
            mh$.invokeExact(m, n, p, A, lda, B, ldb, C, D, X, work, lwork, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zgglse_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("zgglse_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zgglse_(const int *m, const int *n, const int *p, _Complex double *A, const int *lda, _Complex double *B, const int *ldb, _Complex double *C, _Complex double *D, _Complex double *X, _Complex double *work, const int *lwork, int *info)
     * }
     */
    public static FunctionDescriptor zgglse_$descriptor() {
        return zgglse_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zgglse_(const int *m, const int *n, const int *p, _Complex double *A, const int *lda, _Complex double *B, const int *ldb, _Complex double *C, _Complex double *D, _Complex double *X, _Complex double *work, const int *lwork, int *info)
     * }
     */
    public static MethodHandle zgglse_$handle() {
        return zgglse_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zgglse_(const int *m, const int *n, const int *p, _Complex double *A, const int *lda, _Complex double *B, const int *ldb, _Complex double *C, _Complex double *D, _Complex double *X, _Complex double *work, const int *lwork, int *info)
     * }
     */
    public static MemorySegment zgglse_$address() {
        return zgglse_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zgglse_(const int *m, const int *n, const int *p, _Complex double *A, const int *lda, _Complex double *B, const int *ldb, _Complex double *C, _Complex double *D, _Complex double *X, _Complex double *work, const int *lwork, int *info)
     * }
     */
    public static void zgglse_(MemorySegment m, MemorySegment n, MemorySegment p, MemorySegment A, MemorySegment lda, MemorySegment B, MemorySegment ldb, MemorySegment C, MemorySegment D, MemorySegment X, MemorySegment work, MemorySegment lwork, MemorySegment info) {
        var mh$ = zgglse_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zgglse_", m, n, p, A, lda, B, ldb, C, D, X, work, lwork, info);
            }
            mh$.invokeExact(m, n, p, A, lda, B, ldb, C, D, X, work, lwork, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cggqrf_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cggqrf_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cggqrf_(const int *n, const int *m, const int *p, _Complex float *A, const int *lda, _Complex float *taua, _Complex float *B, const int *ldb, _Complex float *taub, _Complex float *work, const int *lwork, int *info)
     * }
     */
    public static FunctionDescriptor cggqrf_$descriptor() {
        return cggqrf_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cggqrf_(const int *n, const int *m, const int *p, _Complex float *A, const int *lda, _Complex float *taua, _Complex float *B, const int *ldb, _Complex float *taub, _Complex float *work, const int *lwork, int *info)
     * }
     */
    public static MethodHandle cggqrf_$handle() {
        return cggqrf_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cggqrf_(const int *n, const int *m, const int *p, _Complex float *A, const int *lda, _Complex float *taua, _Complex float *B, const int *ldb, _Complex float *taub, _Complex float *work, const int *lwork, int *info)
     * }
     */
    public static MemorySegment cggqrf_$address() {
        return cggqrf_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cggqrf_(const int *n, const int *m, const int *p, _Complex float *A, const int *lda, _Complex float *taua, _Complex float *B, const int *ldb, _Complex float *taub, _Complex float *work, const int *lwork, int *info)
     * }
     */
    public static void cggqrf_(MemorySegment n, MemorySegment m, MemorySegment p, MemorySegment A, MemorySegment lda, MemorySegment taua, MemorySegment B, MemorySegment ldb, MemorySegment taub, MemorySegment work, MemorySegment lwork, MemorySegment info) {
        var mh$ = cggqrf_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cggqrf_", n, m, p, A, lda, taua, B, ldb, taub, work, lwork, info);
            }
            mh$.invokeExact(n, m, p, A, lda, taua, B, ldb, taub, work, lwork, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dggqrf_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("dggqrf_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dggqrf_(const int *n, const int *m, const int *p, double *A, const int *lda, double *taua, double *B, const int *ldb, double *taub, double *work, const int *lwork, int *info)
     * }
     */
    public static FunctionDescriptor dggqrf_$descriptor() {
        return dggqrf_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dggqrf_(const int *n, const int *m, const int *p, double *A, const int *lda, double *taua, double *B, const int *ldb, double *taub, double *work, const int *lwork, int *info)
     * }
     */
    public static MethodHandle dggqrf_$handle() {
        return dggqrf_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dggqrf_(const int *n, const int *m, const int *p, double *A, const int *lda, double *taua, double *B, const int *ldb, double *taub, double *work, const int *lwork, int *info)
     * }
     */
    public static MemorySegment dggqrf_$address() {
        return dggqrf_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dggqrf_(const int *n, const int *m, const int *p, double *A, const int *lda, double *taua, double *B, const int *ldb, double *taub, double *work, const int *lwork, int *info)
     * }
     */
    public static void dggqrf_(MemorySegment n, MemorySegment m, MemorySegment p, MemorySegment A, MemorySegment lda, MemorySegment taua, MemorySegment B, MemorySegment ldb, MemorySegment taub, MemorySegment work, MemorySegment lwork, MemorySegment info) {
        var mh$ = dggqrf_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dggqrf_", n, m, p, A, lda, taua, B, ldb, taub, work, lwork, info);
            }
            mh$.invokeExact(n, m, p, A, lda, taua, B, ldb, taub, work, lwork, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sggqrf_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("sggqrf_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void sggqrf_(const int *n, const int *m, const int *p, float *A, const int *lda, float *taua, float *B, const int *ldb, float *taub, float *work, const int *lwork, int *info)
     * }
     */
    public static FunctionDescriptor sggqrf_$descriptor() {
        return sggqrf_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void sggqrf_(const int *n, const int *m, const int *p, float *A, const int *lda, float *taua, float *B, const int *ldb, float *taub, float *work, const int *lwork, int *info)
     * }
     */
    public static MethodHandle sggqrf_$handle() {
        return sggqrf_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void sggqrf_(const int *n, const int *m, const int *p, float *A, const int *lda, float *taua, float *B, const int *ldb, float *taub, float *work, const int *lwork, int *info)
     * }
     */
    public static MemorySegment sggqrf_$address() {
        return sggqrf_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void sggqrf_(const int *n, const int *m, const int *p, float *A, const int *lda, float *taua, float *B, const int *ldb, float *taub, float *work, const int *lwork, int *info)
     * }
     */
    public static void sggqrf_(MemorySegment n, MemorySegment m, MemorySegment p, MemorySegment A, MemorySegment lda, MemorySegment taua, MemorySegment B, MemorySegment ldb, MemorySegment taub, MemorySegment work, MemorySegment lwork, MemorySegment info) {
        var mh$ = sggqrf_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sggqrf_", n, m, p, A, lda, taua, B, ldb, taub, work, lwork, info);
            }
            mh$.invokeExact(n, m, p, A, lda, taua, B, ldb, taub, work, lwork, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zggqrf_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("zggqrf_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zggqrf_(const int *n, const int *m, const int *p, _Complex double *A, const int *lda, _Complex double *taua, _Complex double *B, const int *ldb, _Complex double *taub, _Complex double *work, const int *lwork, int *info)
     * }
     */
    public static FunctionDescriptor zggqrf_$descriptor() {
        return zggqrf_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zggqrf_(const int *n, const int *m, const int *p, _Complex double *A, const int *lda, _Complex double *taua, _Complex double *B, const int *ldb, _Complex double *taub, _Complex double *work, const int *lwork, int *info)
     * }
     */
    public static MethodHandle zggqrf_$handle() {
        return zggqrf_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zggqrf_(const int *n, const int *m, const int *p, _Complex double *A, const int *lda, _Complex double *taua, _Complex double *B, const int *ldb, _Complex double *taub, _Complex double *work, const int *lwork, int *info)
     * }
     */
    public static MemorySegment zggqrf_$address() {
        return zggqrf_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zggqrf_(const int *n, const int *m, const int *p, _Complex double *A, const int *lda, _Complex double *taua, _Complex double *B, const int *ldb, _Complex double *taub, _Complex double *work, const int *lwork, int *info)
     * }
     */
    public static void zggqrf_(MemorySegment n, MemorySegment m, MemorySegment p, MemorySegment A, MemorySegment lda, MemorySegment taua, MemorySegment B, MemorySegment ldb, MemorySegment taub, MemorySegment work, MemorySegment lwork, MemorySegment info) {
        var mh$ = zggqrf_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zggqrf_", n, m, p, A, lda, taua, B, ldb, taub, work, lwork, info);
            }
            mh$.invokeExact(n, m, p, A, lda, taua, B, ldb, taub, work, lwork, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cggrqf_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cggrqf_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cggrqf_(const int *m, const int *p, const int *n, _Complex float *A, const int *lda, _Complex float *taua, _Complex float *B, const int *ldb, _Complex float *taub, _Complex float *work, const int *lwork, int *info)
     * }
     */
    public static FunctionDescriptor cggrqf_$descriptor() {
        return cggrqf_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cggrqf_(const int *m, const int *p, const int *n, _Complex float *A, const int *lda, _Complex float *taua, _Complex float *B, const int *ldb, _Complex float *taub, _Complex float *work, const int *lwork, int *info)
     * }
     */
    public static MethodHandle cggrqf_$handle() {
        return cggrqf_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cggrqf_(const int *m, const int *p, const int *n, _Complex float *A, const int *lda, _Complex float *taua, _Complex float *B, const int *ldb, _Complex float *taub, _Complex float *work, const int *lwork, int *info)
     * }
     */
    public static MemorySegment cggrqf_$address() {
        return cggrqf_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cggrqf_(const int *m, const int *p, const int *n, _Complex float *A, const int *lda, _Complex float *taua, _Complex float *B, const int *ldb, _Complex float *taub, _Complex float *work, const int *lwork, int *info)
     * }
     */
    public static void cggrqf_(MemorySegment m, MemorySegment p, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment taua, MemorySegment B, MemorySegment ldb, MemorySegment taub, MemorySegment work, MemorySegment lwork, MemorySegment info) {
        var mh$ = cggrqf_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cggrqf_", m, p, n, A, lda, taua, B, ldb, taub, work, lwork, info);
            }
            mh$.invokeExact(m, p, n, A, lda, taua, B, ldb, taub, work, lwork, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dggrqf_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("dggrqf_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dggrqf_(const int *m, const int *p, const int *n, double *A, const int *lda, double *taua, double *B, const int *ldb, double *taub, double *work, const int *lwork, int *info)
     * }
     */
    public static FunctionDescriptor dggrqf_$descriptor() {
        return dggrqf_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dggrqf_(const int *m, const int *p, const int *n, double *A, const int *lda, double *taua, double *B, const int *ldb, double *taub, double *work, const int *lwork, int *info)
     * }
     */
    public static MethodHandle dggrqf_$handle() {
        return dggrqf_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dggrqf_(const int *m, const int *p, const int *n, double *A, const int *lda, double *taua, double *B, const int *ldb, double *taub, double *work, const int *lwork, int *info)
     * }
     */
    public static MemorySegment dggrqf_$address() {
        return dggrqf_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dggrqf_(const int *m, const int *p, const int *n, double *A, const int *lda, double *taua, double *B, const int *ldb, double *taub, double *work, const int *lwork, int *info)
     * }
     */
    public static void dggrqf_(MemorySegment m, MemorySegment p, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment taua, MemorySegment B, MemorySegment ldb, MemorySegment taub, MemorySegment work, MemorySegment lwork, MemorySegment info) {
        var mh$ = dggrqf_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dggrqf_", m, p, n, A, lda, taua, B, ldb, taub, work, lwork, info);
            }
            mh$.invokeExact(m, p, n, A, lda, taua, B, ldb, taub, work, lwork, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sggrqf_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("sggrqf_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void sggrqf_(const int *m, const int *p, const int *n, float *A, const int *lda, float *taua, float *B, const int *ldb, float *taub, float *work, const int *lwork, int *info)
     * }
     */
    public static FunctionDescriptor sggrqf_$descriptor() {
        return sggrqf_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void sggrqf_(const int *m, const int *p, const int *n, float *A, const int *lda, float *taua, float *B, const int *ldb, float *taub, float *work, const int *lwork, int *info)
     * }
     */
    public static MethodHandle sggrqf_$handle() {
        return sggrqf_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void sggrqf_(const int *m, const int *p, const int *n, float *A, const int *lda, float *taua, float *B, const int *ldb, float *taub, float *work, const int *lwork, int *info)
     * }
     */
    public static MemorySegment sggrqf_$address() {
        return sggrqf_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void sggrqf_(const int *m, const int *p, const int *n, float *A, const int *lda, float *taua, float *B, const int *ldb, float *taub, float *work, const int *lwork, int *info)
     * }
     */
    public static void sggrqf_(MemorySegment m, MemorySegment p, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment taua, MemorySegment B, MemorySegment ldb, MemorySegment taub, MemorySegment work, MemorySegment lwork, MemorySegment info) {
        var mh$ = sggrqf_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sggrqf_", m, p, n, A, lda, taua, B, ldb, taub, work, lwork, info);
            }
            mh$.invokeExact(m, p, n, A, lda, taua, B, ldb, taub, work, lwork, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zggrqf_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("zggrqf_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zggrqf_(const int *m, const int *p, const int *n, _Complex double *A, const int *lda, _Complex double *taua, _Complex double *B, const int *ldb, _Complex double *taub, _Complex double *work, const int *lwork, int *info)
     * }
     */
    public static FunctionDescriptor zggrqf_$descriptor() {
        return zggrqf_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zggrqf_(const int *m, const int *p, const int *n, _Complex double *A, const int *lda, _Complex double *taua, _Complex double *B, const int *ldb, _Complex double *taub, _Complex double *work, const int *lwork, int *info)
     * }
     */
    public static MethodHandle zggrqf_$handle() {
        return zggrqf_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zggrqf_(const int *m, const int *p, const int *n, _Complex double *A, const int *lda, _Complex double *taua, _Complex double *B, const int *ldb, _Complex double *taub, _Complex double *work, const int *lwork, int *info)
     * }
     */
    public static MemorySegment zggrqf_$address() {
        return zggrqf_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zggrqf_(const int *m, const int *p, const int *n, _Complex double *A, const int *lda, _Complex double *taua, _Complex double *B, const int *ldb, _Complex double *taub, _Complex double *work, const int *lwork, int *info)
     * }
     */
    public static void zggrqf_(MemorySegment m, MemorySegment p, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment taua, MemorySegment B, MemorySegment ldb, MemorySegment taub, MemorySegment work, MemorySegment lwork, MemorySegment info) {
        var mh$ = zggrqf_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zggrqf_", m, p, n, A, lda, taua, B, ldb, taub, work, lwork, info);
            }
            mh$.invokeExact(m, p, n, A, lda, taua, B, ldb, taub, work, lwork, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cggsvd_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cggsvd_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int cggsvd_(const char *jobu, const char *jobv, const char *jobq, const int *m, const int *n, const int *p, int *k, int *l, _Complex float *a, const int *lda, _Complex float *b, const int *ldb, float *alpha, float *beta, _Complex float *u, const int *ldu, _Complex float *v, const int *ldv, _Complex float *q, const int *ldq, _Complex float *work, float *rwork, int *iwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor cggsvd_$descriptor() {
        return cggsvd_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int cggsvd_(const char *jobu, const char *jobv, const char *jobq, const int *m, const int *n, const int *p, int *k, int *l, _Complex float *a, const int *lda, _Complex float *b, const int *ldb, float *alpha, float *beta, _Complex float *u, const int *ldu, _Complex float *v, const int *ldv, _Complex float *q, const int *ldq, _Complex float *work, float *rwork, int *iwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle cggsvd_$handle() {
        return cggsvd_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int cggsvd_(const char *jobu, const char *jobv, const char *jobq, const int *m, const int *n, const int *p, int *k, int *l, _Complex float *a, const int *lda, _Complex float *b, const int *ldb, float *alpha, float *beta, _Complex float *u, const int *ldu, _Complex float *v, const int *ldv, _Complex float *q, const int *ldq, _Complex float *work, float *rwork, int *iwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment cggsvd_$address() {
        return cggsvd_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int cggsvd_(const char *jobu, const char *jobv, const char *jobq, const int *m, const int *n, const int *p, int *k, int *l, _Complex float *a, const int *lda, _Complex float *b, const int *ldb, float *alpha, float *beta, _Complex float *u, const int *ldu, _Complex float *v, const int *ldv, _Complex float *q, const int *ldq, _Complex float *work, float *rwork, int *iwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static int cggsvd_(MemorySegment jobu, MemorySegment jobv, MemorySegment jobq, MemorySegment m, MemorySegment n, MemorySegment p, MemorySegment k, MemorySegment l, MemorySegment a, MemorySegment lda, MemorySegment b, MemorySegment ldb, MemorySegment alpha, MemorySegment beta, MemorySegment u, MemorySegment ldu, MemorySegment v, MemorySegment ldv, MemorySegment q, MemorySegment ldq, MemorySegment work, MemorySegment rwork, MemorySegment iwork, MemorySegment info, long x24, long x25, long x26) {
        var mh$ = cggsvd_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cggsvd_", jobu, jobv, jobq, m, n, p, k, l, a, lda, b, ldb, alpha, beta, u, ldu, v, ldv, q, ldq, work, rwork, iwork, info, x24, x25, x26);
            }
            return (int)mh$.invokeExact(jobu, jobv, jobq, m, n, p, k, l, a, lda, b, ldb, alpha, beta, u, ldu, v, ldv, q, ldq, work, rwork, iwork, info, x24, x25, x26);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sggsvd_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("sggsvd_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int sggsvd_(const char *jobu, const char *jobv, const char *jobq, const int *m, const int *n, const int *p, int *k, int *l, float *a, const int *lda, float *b, const int *ldb, float *alpha, float *beta, float *u, const int *ldu, float *v, const int *ldv, float *q, const int *ldq, float *work, int *iwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor sggsvd_$descriptor() {
        return sggsvd_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int sggsvd_(const char *jobu, const char *jobv, const char *jobq, const int *m, const int *n, const int *p, int *k, int *l, float *a, const int *lda, float *b, const int *ldb, float *alpha, float *beta, float *u, const int *ldu, float *v, const int *ldv, float *q, const int *ldq, float *work, int *iwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle sggsvd_$handle() {
        return sggsvd_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int sggsvd_(const char *jobu, const char *jobv, const char *jobq, const int *m, const int *n, const int *p, int *k, int *l, float *a, const int *lda, float *b, const int *ldb, float *alpha, float *beta, float *u, const int *ldu, float *v, const int *ldv, float *q, const int *ldq, float *work, int *iwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment sggsvd_$address() {
        return sggsvd_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int sggsvd_(const char *jobu, const char *jobv, const char *jobq, const int *m, const int *n, const int *p, int *k, int *l, float *a, const int *lda, float *b, const int *ldb, float *alpha, float *beta, float *u, const int *ldu, float *v, const int *ldv, float *q, const int *ldq, float *work, int *iwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static int sggsvd_(MemorySegment jobu, MemorySegment jobv, MemorySegment jobq, MemorySegment m, MemorySegment n, MemorySegment p, MemorySegment k, MemorySegment l, MemorySegment a, MemorySegment lda, MemorySegment b, MemorySegment ldb, MemorySegment alpha, MemorySegment beta, MemorySegment u, MemorySegment ldu, MemorySegment v, MemorySegment ldv, MemorySegment q, MemorySegment ldq, MemorySegment work, MemorySegment iwork, MemorySegment info, long x23, long x24, long x25) {
        var mh$ = sggsvd_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sggsvd_", jobu, jobv, jobq, m, n, p, k, l, a, lda, b, ldb, alpha, beta, u, ldu, v, ldv, q, ldq, work, iwork, info, x23, x24, x25);
            }
            return (int)mh$.invokeExact(jobu, jobv, jobq, m, n, p, k, l, a, lda, b, ldb, alpha, beta, u, ldu, v, ldv, q, ldq, work, iwork, info, x23, x24, x25);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dggsvd_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("dggsvd_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int dggsvd_(const char *jobu, const char *jobv, const char *jobq, const int *m, const int *n, const int *p, int *k, int *l, double *a, const int *lda, double *b, const int *ldb, double *alpha, double *beta, double *u, const int *ldu, double *v, const int *ldv, double *q, const int *ldq, double *work, int *iwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor dggsvd_$descriptor() {
        return dggsvd_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int dggsvd_(const char *jobu, const char *jobv, const char *jobq, const int *m, const int *n, const int *p, int *k, int *l, double *a, const int *lda, double *b, const int *ldb, double *alpha, double *beta, double *u, const int *ldu, double *v, const int *ldv, double *q, const int *ldq, double *work, int *iwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle dggsvd_$handle() {
        return dggsvd_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int dggsvd_(const char *jobu, const char *jobv, const char *jobq, const int *m, const int *n, const int *p, int *k, int *l, double *a, const int *lda, double *b, const int *ldb, double *alpha, double *beta, double *u, const int *ldu, double *v, const int *ldv, double *q, const int *ldq, double *work, int *iwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment dggsvd_$address() {
        return dggsvd_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int dggsvd_(const char *jobu, const char *jobv, const char *jobq, const int *m, const int *n, const int *p, int *k, int *l, double *a, const int *lda, double *b, const int *ldb, double *alpha, double *beta, double *u, const int *ldu, double *v, const int *ldv, double *q, const int *ldq, double *work, int *iwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static int dggsvd_(MemorySegment jobu, MemorySegment jobv, MemorySegment jobq, MemorySegment m, MemorySegment n, MemorySegment p, MemorySegment k, MemorySegment l, MemorySegment a, MemorySegment lda, MemorySegment b, MemorySegment ldb, MemorySegment alpha, MemorySegment beta, MemorySegment u, MemorySegment ldu, MemorySegment v, MemorySegment ldv, MemorySegment q, MemorySegment ldq, MemorySegment work, MemorySegment iwork, MemorySegment info, long x23, long x24, long x25) {
        var mh$ = dggsvd_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dggsvd_", jobu, jobv, jobq, m, n, p, k, l, a, lda, b, ldb, alpha, beta, u, ldu, v, ldv, q, ldq, work, iwork, info, x23, x24, x25);
            }
            return (int)mh$.invokeExact(jobu, jobv, jobq, m, n, p, k, l, a, lda, b, ldb, alpha, beta, u, ldu, v, ldv, q, ldq, work, iwork, info, x23, x24, x25);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zggsvd_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("zggsvd_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int zggsvd_(const char *jobu, const char *jobv, const char *jobq, const int *m, const int *n, const int *p, int *k, int *l, _Complex double *a, const int *lda, _Complex double *b, const int *ldb, double *alpha, double *beta, _Complex double *u, const int *ldu, _Complex double *v, const int *ldv, _Complex double *q, const int *ldq, _Complex double *work, double *rwork, int *iwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor zggsvd_$descriptor() {
        return zggsvd_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int zggsvd_(const char *jobu, const char *jobv, const char *jobq, const int *m, const int *n, const int *p, int *k, int *l, _Complex double *a, const int *lda, _Complex double *b, const int *ldb, double *alpha, double *beta, _Complex double *u, const int *ldu, _Complex double *v, const int *ldv, _Complex double *q, const int *ldq, _Complex double *work, double *rwork, int *iwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle zggsvd_$handle() {
        return zggsvd_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int zggsvd_(const char *jobu, const char *jobv, const char *jobq, const int *m, const int *n, const int *p, int *k, int *l, _Complex double *a, const int *lda, _Complex double *b, const int *ldb, double *alpha, double *beta, _Complex double *u, const int *ldu, _Complex double *v, const int *ldv, _Complex double *q, const int *ldq, _Complex double *work, double *rwork, int *iwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment zggsvd_$address() {
        return zggsvd_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int zggsvd_(const char *jobu, const char *jobv, const char *jobq, const int *m, const int *n, const int *p, int *k, int *l, _Complex double *a, const int *lda, _Complex double *b, const int *ldb, double *alpha, double *beta, _Complex double *u, const int *ldu, _Complex double *v, const int *ldv, _Complex double *q, const int *ldq, _Complex double *work, double *rwork, int *iwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static int zggsvd_(MemorySegment jobu, MemorySegment jobv, MemorySegment jobq, MemorySegment m, MemorySegment n, MemorySegment p, MemorySegment k, MemorySegment l, MemorySegment a, MemorySegment lda, MemorySegment b, MemorySegment ldb, MemorySegment alpha, MemorySegment beta, MemorySegment u, MemorySegment ldu, MemorySegment v, MemorySegment ldv, MemorySegment q, MemorySegment ldq, MemorySegment work, MemorySegment rwork, MemorySegment iwork, MemorySegment info, long x24, long x25, long x26) {
        var mh$ = zggsvd_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zggsvd_", jobu, jobv, jobq, m, n, p, k, l, a, lda, b, ldb, alpha, beta, u, ldu, v, ldv, q, ldq, work, rwork, iwork, info, x24, x25, x26);
            }
            return (int)mh$.invokeExact(jobu, jobv, jobq, m, n, p, k, l, a, lda, b, ldb, alpha, beta, u, ldu, v, ldv, q, ldq, work, rwork, iwork, info, x24, x25, x26);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cggsvd3_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cggsvd3_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cggsvd3_(const char *jobu, const char *jobv, const char *jobq, const int *m, const int *n, const int *p, int *k, int *l, _Complex float *A, const int *lda, _Complex float *B, const int *ldb, float *alpha, float *beta, _Complex float *U, const int *ldu, _Complex float *V, const int *ldv, _Complex float *Q, const int *ldq, _Complex float *work, const int *lwork, float *rwork, int *iwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor cggsvd3_$descriptor() {
        return cggsvd3_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cggsvd3_(const char *jobu, const char *jobv, const char *jobq, const int *m, const int *n, const int *p, int *k, int *l, _Complex float *A, const int *lda, _Complex float *B, const int *ldb, float *alpha, float *beta, _Complex float *U, const int *ldu, _Complex float *V, const int *ldv, _Complex float *Q, const int *ldq, _Complex float *work, const int *lwork, float *rwork, int *iwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle cggsvd3_$handle() {
        return cggsvd3_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cggsvd3_(const char *jobu, const char *jobv, const char *jobq, const int *m, const int *n, const int *p, int *k, int *l, _Complex float *A, const int *lda, _Complex float *B, const int *ldb, float *alpha, float *beta, _Complex float *U, const int *ldu, _Complex float *V, const int *ldv, _Complex float *Q, const int *ldq, _Complex float *work, const int *lwork, float *rwork, int *iwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment cggsvd3_$address() {
        return cggsvd3_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cggsvd3_(const char *jobu, const char *jobv, const char *jobq, const int *m, const int *n, const int *p, int *k, int *l, _Complex float *A, const int *lda, _Complex float *B, const int *ldb, float *alpha, float *beta, _Complex float *U, const int *ldu, _Complex float *V, const int *ldv, _Complex float *Q, const int *ldq, _Complex float *work, const int *lwork, float *rwork, int *iwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static void cggsvd3_(MemorySegment jobu, MemorySegment jobv, MemorySegment jobq, MemorySegment m, MemorySegment n, MemorySegment p, MemorySegment k, MemorySegment l, MemorySegment A, MemorySegment lda, MemorySegment B, MemorySegment ldb, MemorySegment alpha, MemorySegment beta, MemorySegment U, MemorySegment ldu, MemorySegment V, MemorySegment ldv, MemorySegment Q, MemorySegment ldq, MemorySegment work, MemorySegment lwork, MemorySegment rwork, MemorySegment iwork, MemorySegment info, long x25, long x26, long x27) {
        var mh$ = cggsvd3_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cggsvd3_", jobu, jobv, jobq, m, n, p, k, l, A, lda, B, ldb, alpha, beta, U, ldu, V, ldv, Q, ldq, work, lwork, rwork, iwork, info, x25, x26, x27);
            }
            mh$.invokeExact(jobu, jobv, jobq, m, n, p, k, l, A, lda, B, ldb, alpha, beta, U, ldu, V, ldv, Q, ldq, work, lwork, rwork, iwork, info, x25, x26, x27);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dggsvd3_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("dggsvd3_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dggsvd3_(const char *jobu, const char *jobv, const char *jobq, const int *m, const int *n, const int *p, int *k, int *l, double *A, const int *lda, double *B, const int *ldb, double *alpha, double *beta, double *U, const int *ldu, double *V, const int *ldv, double *Q, const int *ldq, double *work, const int *lwork, int *iwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor dggsvd3_$descriptor() {
        return dggsvd3_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dggsvd3_(const char *jobu, const char *jobv, const char *jobq, const int *m, const int *n, const int *p, int *k, int *l, double *A, const int *lda, double *B, const int *ldb, double *alpha, double *beta, double *U, const int *ldu, double *V, const int *ldv, double *Q, const int *ldq, double *work, const int *lwork, int *iwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle dggsvd3_$handle() {
        return dggsvd3_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dggsvd3_(const char *jobu, const char *jobv, const char *jobq, const int *m, const int *n, const int *p, int *k, int *l, double *A, const int *lda, double *B, const int *ldb, double *alpha, double *beta, double *U, const int *ldu, double *V, const int *ldv, double *Q, const int *ldq, double *work, const int *lwork, int *iwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment dggsvd3_$address() {
        return dggsvd3_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dggsvd3_(const char *jobu, const char *jobv, const char *jobq, const int *m, const int *n, const int *p, int *k, int *l, double *A, const int *lda, double *B, const int *ldb, double *alpha, double *beta, double *U, const int *ldu, double *V, const int *ldv, double *Q, const int *ldq, double *work, const int *lwork, int *iwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static void dggsvd3_(MemorySegment jobu, MemorySegment jobv, MemorySegment jobq, MemorySegment m, MemorySegment n, MemorySegment p, MemorySegment k, MemorySegment l, MemorySegment A, MemorySegment lda, MemorySegment B, MemorySegment ldb, MemorySegment alpha, MemorySegment beta, MemorySegment U, MemorySegment ldu, MemorySegment V, MemorySegment ldv, MemorySegment Q, MemorySegment ldq, MemorySegment work, MemorySegment lwork, MemorySegment iwork, MemorySegment info, long x24, long x25, long x26) {
        var mh$ = dggsvd3_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dggsvd3_", jobu, jobv, jobq, m, n, p, k, l, A, lda, B, ldb, alpha, beta, U, ldu, V, ldv, Q, ldq, work, lwork, iwork, info, x24, x25, x26);
            }
            mh$.invokeExact(jobu, jobv, jobq, m, n, p, k, l, A, lda, B, ldb, alpha, beta, U, ldu, V, ldv, Q, ldq, work, lwork, iwork, info, x24, x25, x26);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sggsvd3_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("sggsvd3_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void sggsvd3_(const char *jobu, const char *jobv, const char *jobq, const int *m, const int *n, const int *p, int *k, int *l, float *A, const int *lda, float *B, const int *ldb, float *alpha, float *beta, float *U, const int *ldu, float *V, const int *ldv, float *Q, const int *ldq, float *work, const int *lwork, int *iwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor sggsvd3_$descriptor() {
        return sggsvd3_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void sggsvd3_(const char *jobu, const char *jobv, const char *jobq, const int *m, const int *n, const int *p, int *k, int *l, float *A, const int *lda, float *B, const int *ldb, float *alpha, float *beta, float *U, const int *ldu, float *V, const int *ldv, float *Q, const int *ldq, float *work, const int *lwork, int *iwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle sggsvd3_$handle() {
        return sggsvd3_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void sggsvd3_(const char *jobu, const char *jobv, const char *jobq, const int *m, const int *n, const int *p, int *k, int *l, float *A, const int *lda, float *B, const int *ldb, float *alpha, float *beta, float *U, const int *ldu, float *V, const int *ldv, float *Q, const int *ldq, float *work, const int *lwork, int *iwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment sggsvd3_$address() {
        return sggsvd3_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void sggsvd3_(const char *jobu, const char *jobv, const char *jobq, const int *m, const int *n, const int *p, int *k, int *l, float *A, const int *lda, float *B, const int *ldb, float *alpha, float *beta, float *U, const int *ldu, float *V, const int *ldv, float *Q, const int *ldq, float *work, const int *lwork, int *iwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static void sggsvd3_(MemorySegment jobu, MemorySegment jobv, MemorySegment jobq, MemorySegment m, MemorySegment n, MemorySegment p, MemorySegment k, MemorySegment l, MemorySegment A, MemorySegment lda, MemorySegment B, MemorySegment ldb, MemorySegment alpha, MemorySegment beta, MemorySegment U, MemorySegment ldu, MemorySegment V, MemorySegment ldv, MemorySegment Q, MemorySegment ldq, MemorySegment work, MemorySegment lwork, MemorySegment iwork, MemorySegment info, long x24, long x25, long x26) {
        var mh$ = sggsvd3_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sggsvd3_", jobu, jobv, jobq, m, n, p, k, l, A, lda, B, ldb, alpha, beta, U, ldu, V, ldv, Q, ldq, work, lwork, iwork, info, x24, x25, x26);
            }
            mh$.invokeExact(jobu, jobv, jobq, m, n, p, k, l, A, lda, B, ldb, alpha, beta, U, ldu, V, ldv, Q, ldq, work, lwork, iwork, info, x24, x25, x26);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zggsvd3_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("zggsvd3_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zggsvd3_(const char *jobu, const char *jobv, const char *jobq, const int *m, const int *n, const int *p, int *k, int *l, _Complex double *A, const int *lda, _Complex double *B, const int *ldb, double *alpha, double *beta, _Complex double *U, const int *ldu, _Complex double *V, const int *ldv, _Complex double *Q, const int *ldq, _Complex double *work, const int *lwork, double *rwork, int *iwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor zggsvd3_$descriptor() {
        return zggsvd3_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zggsvd3_(const char *jobu, const char *jobv, const char *jobq, const int *m, const int *n, const int *p, int *k, int *l, _Complex double *A, const int *lda, _Complex double *B, const int *ldb, double *alpha, double *beta, _Complex double *U, const int *ldu, _Complex double *V, const int *ldv, _Complex double *Q, const int *ldq, _Complex double *work, const int *lwork, double *rwork, int *iwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle zggsvd3_$handle() {
        return zggsvd3_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zggsvd3_(const char *jobu, const char *jobv, const char *jobq, const int *m, const int *n, const int *p, int *k, int *l, _Complex double *A, const int *lda, _Complex double *B, const int *ldb, double *alpha, double *beta, _Complex double *U, const int *ldu, _Complex double *V, const int *ldv, _Complex double *Q, const int *ldq, _Complex double *work, const int *lwork, double *rwork, int *iwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment zggsvd3_$address() {
        return zggsvd3_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zggsvd3_(const char *jobu, const char *jobv, const char *jobq, const int *m, const int *n, const int *p, int *k, int *l, _Complex double *A, const int *lda, _Complex double *B, const int *ldb, double *alpha, double *beta, _Complex double *U, const int *ldu, _Complex double *V, const int *ldv, _Complex double *Q, const int *ldq, _Complex double *work, const int *lwork, double *rwork, int *iwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static void zggsvd3_(MemorySegment jobu, MemorySegment jobv, MemorySegment jobq, MemorySegment m, MemorySegment n, MemorySegment p, MemorySegment k, MemorySegment l, MemorySegment A, MemorySegment lda, MemorySegment B, MemorySegment ldb, MemorySegment alpha, MemorySegment beta, MemorySegment U, MemorySegment ldu, MemorySegment V, MemorySegment ldv, MemorySegment Q, MemorySegment ldq, MemorySegment work, MemorySegment lwork, MemorySegment rwork, MemorySegment iwork, MemorySegment info, long x25, long x26, long x27) {
        var mh$ = zggsvd3_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zggsvd3_", jobu, jobv, jobq, m, n, p, k, l, A, lda, B, ldb, alpha, beta, U, ldu, V, ldv, Q, ldq, work, lwork, rwork, iwork, info, x25, x26, x27);
            }
            mh$.invokeExact(jobu, jobv, jobq, m, n, p, k, l, A, lda, B, ldb, alpha, beta, U, ldu, V, ldv, Q, ldq, work, lwork, rwork, iwork, info, x25, x26, x27);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sggsvp_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("sggsvp_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int sggsvp_(const char *jobu, const char *jobv, const char *jobq, const int *m, const int *p, const int *n, float *a, const int *lda, float *b, const int *ldb, float *tola, float *tolb, int *k, int *l, float *u, const int *ldu, float *v, const int *ldv, float *q, const int *ldq, int *iwork, float *tau, float *work, int *info, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor sggsvp_$descriptor() {
        return sggsvp_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int sggsvp_(const char *jobu, const char *jobv, const char *jobq, const int *m, const int *p, const int *n, float *a, const int *lda, float *b, const int *ldb, float *tola, float *tolb, int *k, int *l, float *u, const int *ldu, float *v, const int *ldv, float *q, const int *ldq, int *iwork, float *tau, float *work, int *info, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle sggsvp_$handle() {
        return sggsvp_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int sggsvp_(const char *jobu, const char *jobv, const char *jobq, const int *m, const int *p, const int *n, float *a, const int *lda, float *b, const int *ldb, float *tola, float *tolb, int *k, int *l, float *u, const int *ldu, float *v, const int *ldv, float *q, const int *ldq, int *iwork, float *tau, float *work, int *info, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment sggsvp_$address() {
        return sggsvp_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int sggsvp_(const char *jobu, const char *jobv, const char *jobq, const int *m, const int *p, const int *n, float *a, const int *lda, float *b, const int *ldb, float *tola, float *tolb, int *k, int *l, float *u, const int *ldu, float *v, const int *ldv, float *q, const int *ldq, int *iwork, float *tau, float *work, int *info, size_t, size_t, size_t)
     * }
     */
    public static int sggsvp_(MemorySegment jobu, MemorySegment jobv, MemorySegment jobq, MemorySegment m, MemorySegment p, MemorySegment n, MemorySegment a, MemorySegment lda, MemorySegment b, MemorySegment ldb, MemorySegment tola, MemorySegment tolb, MemorySegment k, MemorySegment l, MemorySegment u, MemorySegment ldu, MemorySegment v, MemorySegment ldv, MemorySegment q, MemorySegment ldq, MemorySegment iwork, MemorySegment tau, MemorySegment work, MemorySegment info, long x24, long x25, long x26) {
        var mh$ = sggsvp_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sggsvp_", jobu, jobv, jobq, m, p, n, a, lda, b, ldb, tola, tolb, k, l, u, ldu, v, ldv, q, ldq, iwork, tau, work, info, x24, x25, x26);
            }
            return (int)mh$.invokeExact(jobu, jobv, jobq, m, p, n, a, lda, b, ldb, tola, tolb, k, l, u, ldu, v, ldv, q, ldq, iwork, tau, work, info, x24, x25, x26);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dggsvp_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("dggsvp_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int dggsvp_(const char *jobu, const char *jobv, const char *jobq, const int *m, const int *p, const int *n, double *a, const int *lda, double *b, const int *ldb, double *tola, double *tolb, int *k, int *l, double *u, const int *ldu, double *v, const int *ldv, double *q, const int *ldq, int *iwork, double *tau, double *work, int *info, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor dggsvp_$descriptor() {
        return dggsvp_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int dggsvp_(const char *jobu, const char *jobv, const char *jobq, const int *m, const int *p, const int *n, double *a, const int *lda, double *b, const int *ldb, double *tola, double *tolb, int *k, int *l, double *u, const int *ldu, double *v, const int *ldv, double *q, const int *ldq, int *iwork, double *tau, double *work, int *info, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle dggsvp_$handle() {
        return dggsvp_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int dggsvp_(const char *jobu, const char *jobv, const char *jobq, const int *m, const int *p, const int *n, double *a, const int *lda, double *b, const int *ldb, double *tola, double *tolb, int *k, int *l, double *u, const int *ldu, double *v, const int *ldv, double *q, const int *ldq, int *iwork, double *tau, double *work, int *info, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment dggsvp_$address() {
        return dggsvp_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int dggsvp_(const char *jobu, const char *jobv, const char *jobq, const int *m, const int *p, const int *n, double *a, const int *lda, double *b, const int *ldb, double *tola, double *tolb, int *k, int *l, double *u, const int *ldu, double *v, const int *ldv, double *q, const int *ldq, int *iwork, double *tau, double *work, int *info, size_t, size_t, size_t)
     * }
     */
    public static int dggsvp_(MemorySegment jobu, MemorySegment jobv, MemorySegment jobq, MemorySegment m, MemorySegment p, MemorySegment n, MemorySegment a, MemorySegment lda, MemorySegment b, MemorySegment ldb, MemorySegment tola, MemorySegment tolb, MemorySegment k, MemorySegment l, MemorySegment u, MemorySegment ldu, MemorySegment v, MemorySegment ldv, MemorySegment q, MemorySegment ldq, MemorySegment iwork, MemorySegment tau, MemorySegment work, MemorySegment info, long x24, long x25, long x26) {
        var mh$ = dggsvp_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dggsvp_", jobu, jobv, jobq, m, p, n, a, lda, b, ldb, tola, tolb, k, l, u, ldu, v, ldv, q, ldq, iwork, tau, work, info, x24, x25, x26);
            }
            return (int)mh$.invokeExact(jobu, jobv, jobq, m, p, n, a, lda, b, ldb, tola, tolb, k, l, u, ldu, v, ldv, q, ldq, iwork, tau, work, info, x24, x25, x26);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cggsvp_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cggsvp_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int cggsvp_(const char *jobu, const char *jobv, const char *jobq, const int *m, const int *p, const int *n, _Complex float *a, const int *lda, _Complex float *b, const int *ldb, float *tola, float *tolb, int *k, int *l, _Complex float *u, const int *ldu, _Complex float *v, const int *ldv, _Complex float *q, const int *ldq, int *iwork, float *rwork, _Complex float *tau, _Complex float *work, int *info, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor cggsvp_$descriptor() {
        return cggsvp_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int cggsvp_(const char *jobu, const char *jobv, const char *jobq, const int *m, const int *p, const int *n, _Complex float *a, const int *lda, _Complex float *b, const int *ldb, float *tola, float *tolb, int *k, int *l, _Complex float *u, const int *ldu, _Complex float *v, const int *ldv, _Complex float *q, const int *ldq, int *iwork, float *rwork, _Complex float *tau, _Complex float *work, int *info, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle cggsvp_$handle() {
        return cggsvp_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int cggsvp_(const char *jobu, const char *jobv, const char *jobq, const int *m, const int *p, const int *n, _Complex float *a, const int *lda, _Complex float *b, const int *ldb, float *tola, float *tolb, int *k, int *l, _Complex float *u, const int *ldu, _Complex float *v, const int *ldv, _Complex float *q, const int *ldq, int *iwork, float *rwork, _Complex float *tau, _Complex float *work, int *info, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment cggsvp_$address() {
        return cggsvp_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int cggsvp_(const char *jobu, const char *jobv, const char *jobq, const int *m, const int *p, const int *n, _Complex float *a, const int *lda, _Complex float *b, const int *ldb, float *tola, float *tolb, int *k, int *l, _Complex float *u, const int *ldu, _Complex float *v, const int *ldv, _Complex float *q, const int *ldq, int *iwork, float *rwork, _Complex float *tau, _Complex float *work, int *info, size_t, size_t, size_t)
     * }
     */
    public static int cggsvp_(MemorySegment jobu, MemorySegment jobv, MemorySegment jobq, MemorySegment m, MemorySegment p, MemorySegment n, MemorySegment a, MemorySegment lda, MemorySegment b, MemorySegment ldb, MemorySegment tola, MemorySegment tolb, MemorySegment k, MemorySegment l, MemorySegment u, MemorySegment ldu, MemorySegment v, MemorySegment ldv, MemorySegment q, MemorySegment ldq, MemorySegment iwork, MemorySegment rwork, MemorySegment tau, MemorySegment work, MemorySegment info, long x25, long x26, long x27) {
        var mh$ = cggsvp_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cggsvp_", jobu, jobv, jobq, m, p, n, a, lda, b, ldb, tola, tolb, k, l, u, ldu, v, ldv, q, ldq, iwork, rwork, tau, work, info, x25, x26, x27);
            }
            return (int)mh$.invokeExact(jobu, jobv, jobq, m, p, n, a, lda, b, ldb, tola, tolb, k, l, u, ldu, v, ldv, q, ldq, iwork, rwork, tau, work, info, x25, x26, x27);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zggsvp_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("zggsvp_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int zggsvp_(const char *jobu, const char *jobv, const char *jobq, const int *m, const int *p, const int *n, _Complex double *a, const int *lda, _Complex double *b, const int *ldb, double *tola, double *tolb, int *k, int *l, _Complex double *u, const int *ldu, _Complex double *v, const int *ldv, _Complex double *q, const int *ldq, int *iwork, double *rwork, _Complex double *tau, _Complex double *work, int *info, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor zggsvp_$descriptor() {
        return zggsvp_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int zggsvp_(const char *jobu, const char *jobv, const char *jobq, const int *m, const int *p, const int *n, _Complex double *a, const int *lda, _Complex double *b, const int *ldb, double *tola, double *tolb, int *k, int *l, _Complex double *u, const int *ldu, _Complex double *v, const int *ldv, _Complex double *q, const int *ldq, int *iwork, double *rwork, _Complex double *tau, _Complex double *work, int *info, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle zggsvp_$handle() {
        return zggsvp_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int zggsvp_(const char *jobu, const char *jobv, const char *jobq, const int *m, const int *p, const int *n, _Complex double *a, const int *lda, _Complex double *b, const int *ldb, double *tola, double *tolb, int *k, int *l, _Complex double *u, const int *ldu, _Complex double *v, const int *ldv, _Complex double *q, const int *ldq, int *iwork, double *rwork, _Complex double *tau, _Complex double *work, int *info, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment zggsvp_$address() {
        return zggsvp_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int zggsvp_(const char *jobu, const char *jobv, const char *jobq, const int *m, const int *p, const int *n, _Complex double *a, const int *lda, _Complex double *b, const int *ldb, double *tola, double *tolb, int *k, int *l, _Complex double *u, const int *ldu, _Complex double *v, const int *ldv, _Complex double *q, const int *ldq, int *iwork, double *rwork, _Complex double *tau, _Complex double *work, int *info, size_t, size_t, size_t)
     * }
     */
    public static int zggsvp_(MemorySegment jobu, MemorySegment jobv, MemorySegment jobq, MemorySegment m, MemorySegment p, MemorySegment n, MemorySegment a, MemorySegment lda, MemorySegment b, MemorySegment ldb, MemorySegment tola, MemorySegment tolb, MemorySegment k, MemorySegment l, MemorySegment u, MemorySegment ldu, MemorySegment v, MemorySegment ldv, MemorySegment q, MemorySegment ldq, MemorySegment iwork, MemorySegment rwork, MemorySegment tau, MemorySegment work, MemorySegment info, long x25, long x26, long x27) {
        var mh$ = zggsvp_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zggsvp_", jobu, jobv, jobq, m, p, n, a, lda, b, ldb, tola, tolb, k, l, u, ldu, v, ldv, q, ldq, iwork, rwork, tau, work, info, x25, x26, x27);
            }
            return (int)mh$.invokeExact(jobu, jobv, jobq, m, p, n, a, lda, b, ldb, tola, tolb, k, l, u, ldu, v, ldv, q, ldq, iwork, rwork, tau, work, info, x25, x26, x27);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cggsvp3_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cggsvp3_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cggsvp3_(const char *jobu, const char *jobv, const char *jobq, const int *m, const int *p, const int *n, _Complex float *A, const int *lda, _Complex float *B, const int *ldb, const float *tola, const float *tolb, int *k, int *l, _Complex float *U, const int *ldu, _Complex float *V, const int *ldv, _Complex float *Q, const int *ldq, int *iwork, float *rwork, _Complex float *tau, _Complex float *work, const int *lwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor cggsvp3_$descriptor() {
        return cggsvp3_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cggsvp3_(const char *jobu, const char *jobv, const char *jobq, const int *m, const int *p, const int *n, _Complex float *A, const int *lda, _Complex float *B, const int *ldb, const float *tola, const float *tolb, int *k, int *l, _Complex float *U, const int *ldu, _Complex float *V, const int *ldv, _Complex float *Q, const int *ldq, int *iwork, float *rwork, _Complex float *tau, _Complex float *work, const int *lwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle cggsvp3_$handle() {
        return cggsvp3_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cggsvp3_(const char *jobu, const char *jobv, const char *jobq, const int *m, const int *p, const int *n, _Complex float *A, const int *lda, _Complex float *B, const int *ldb, const float *tola, const float *tolb, int *k, int *l, _Complex float *U, const int *ldu, _Complex float *V, const int *ldv, _Complex float *Q, const int *ldq, int *iwork, float *rwork, _Complex float *tau, _Complex float *work, const int *lwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment cggsvp3_$address() {
        return cggsvp3_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cggsvp3_(const char *jobu, const char *jobv, const char *jobq, const int *m, const int *p, const int *n, _Complex float *A, const int *lda, _Complex float *B, const int *ldb, const float *tola, const float *tolb, int *k, int *l, _Complex float *U, const int *ldu, _Complex float *V, const int *ldv, _Complex float *Q, const int *ldq, int *iwork, float *rwork, _Complex float *tau, _Complex float *work, const int *lwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static void cggsvp3_(MemorySegment jobu, MemorySegment jobv, MemorySegment jobq, MemorySegment m, MemorySegment p, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment B, MemorySegment ldb, MemorySegment tola, MemorySegment tolb, MemorySegment k, MemorySegment l, MemorySegment U, MemorySegment ldu, MemorySegment V, MemorySegment ldv, MemorySegment Q, MemorySegment ldq, MemorySegment iwork, MemorySegment rwork, MemorySegment tau, MemorySegment work, MemorySegment lwork, MemorySegment info, long x26, long x27, long x28) {
        var mh$ = cggsvp3_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cggsvp3_", jobu, jobv, jobq, m, p, n, A, lda, B, ldb, tola, tolb, k, l, U, ldu, V, ldv, Q, ldq, iwork, rwork, tau, work, lwork, info, x26, x27, x28);
            }
            mh$.invokeExact(jobu, jobv, jobq, m, p, n, A, lda, B, ldb, tola, tolb, k, l, U, ldu, V, ldv, Q, ldq, iwork, rwork, tau, work, lwork, info, x26, x27, x28);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dggsvp3_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("dggsvp3_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dggsvp3_(const char *jobu, const char *jobv, const char *jobq, const int *m, const int *p, const int *n, double *A, const int *lda, double *B, const int *ldb, const double *tola, const double *tolb, int *k, int *l, double *U, const int *ldu, double *V, const int *ldv, double *Q, const int *ldq, int *iwork, double *tau, double *work, const int *lwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor dggsvp3_$descriptor() {
        return dggsvp3_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dggsvp3_(const char *jobu, const char *jobv, const char *jobq, const int *m, const int *p, const int *n, double *A, const int *lda, double *B, const int *ldb, const double *tola, const double *tolb, int *k, int *l, double *U, const int *ldu, double *V, const int *ldv, double *Q, const int *ldq, int *iwork, double *tau, double *work, const int *lwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle dggsvp3_$handle() {
        return dggsvp3_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dggsvp3_(const char *jobu, const char *jobv, const char *jobq, const int *m, const int *p, const int *n, double *A, const int *lda, double *B, const int *ldb, const double *tola, const double *tolb, int *k, int *l, double *U, const int *ldu, double *V, const int *ldv, double *Q, const int *ldq, int *iwork, double *tau, double *work, const int *lwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment dggsvp3_$address() {
        return dggsvp3_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dggsvp3_(const char *jobu, const char *jobv, const char *jobq, const int *m, const int *p, const int *n, double *A, const int *lda, double *B, const int *ldb, const double *tola, const double *tolb, int *k, int *l, double *U, const int *ldu, double *V, const int *ldv, double *Q, const int *ldq, int *iwork, double *tau, double *work, const int *lwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static void dggsvp3_(MemorySegment jobu, MemorySegment jobv, MemorySegment jobq, MemorySegment m, MemorySegment p, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment B, MemorySegment ldb, MemorySegment tola, MemorySegment tolb, MemorySegment k, MemorySegment l, MemorySegment U, MemorySegment ldu, MemorySegment V, MemorySegment ldv, MemorySegment Q, MemorySegment ldq, MemorySegment iwork, MemorySegment tau, MemorySegment work, MemorySegment lwork, MemorySegment info, long x25, long x26, long x27) {
        var mh$ = dggsvp3_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dggsvp3_", jobu, jobv, jobq, m, p, n, A, lda, B, ldb, tola, tolb, k, l, U, ldu, V, ldv, Q, ldq, iwork, tau, work, lwork, info, x25, x26, x27);
            }
            mh$.invokeExact(jobu, jobv, jobq, m, p, n, A, lda, B, ldb, tola, tolb, k, l, U, ldu, V, ldv, Q, ldq, iwork, tau, work, lwork, info, x25, x26, x27);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sggsvp3_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("sggsvp3_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void sggsvp3_(const char *jobu, const char *jobv, const char *jobq, const int *m, const int *p, const int *n, float *A, const int *lda, float *B, const int *ldb, const float *tola, const float *tolb, int *k, int *l, float *U, const int *ldu, float *V, const int *ldv, float *Q, const int *ldq, int *iwork, float *tau, float *work, const int *lwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor sggsvp3_$descriptor() {
        return sggsvp3_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void sggsvp3_(const char *jobu, const char *jobv, const char *jobq, const int *m, const int *p, const int *n, float *A, const int *lda, float *B, const int *ldb, const float *tola, const float *tolb, int *k, int *l, float *U, const int *ldu, float *V, const int *ldv, float *Q, const int *ldq, int *iwork, float *tau, float *work, const int *lwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle sggsvp3_$handle() {
        return sggsvp3_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void sggsvp3_(const char *jobu, const char *jobv, const char *jobq, const int *m, const int *p, const int *n, float *A, const int *lda, float *B, const int *ldb, const float *tola, const float *tolb, int *k, int *l, float *U, const int *ldu, float *V, const int *ldv, float *Q, const int *ldq, int *iwork, float *tau, float *work, const int *lwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment sggsvp3_$address() {
        return sggsvp3_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void sggsvp3_(const char *jobu, const char *jobv, const char *jobq, const int *m, const int *p, const int *n, float *A, const int *lda, float *B, const int *ldb, const float *tola, const float *tolb, int *k, int *l, float *U, const int *ldu, float *V, const int *ldv, float *Q, const int *ldq, int *iwork, float *tau, float *work, const int *lwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static void sggsvp3_(MemorySegment jobu, MemorySegment jobv, MemorySegment jobq, MemorySegment m, MemorySegment p, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment B, MemorySegment ldb, MemorySegment tola, MemorySegment tolb, MemorySegment k, MemorySegment l, MemorySegment U, MemorySegment ldu, MemorySegment V, MemorySegment ldv, MemorySegment Q, MemorySegment ldq, MemorySegment iwork, MemorySegment tau, MemorySegment work, MemorySegment lwork, MemorySegment info, long x25, long x26, long x27) {
        var mh$ = sggsvp3_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sggsvp3_", jobu, jobv, jobq, m, p, n, A, lda, B, ldb, tola, tolb, k, l, U, ldu, V, ldv, Q, ldq, iwork, tau, work, lwork, info, x25, x26, x27);
            }
            mh$.invokeExact(jobu, jobv, jobq, m, p, n, A, lda, B, ldb, tola, tolb, k, l, U, ldu, V, ldv, Q, ldq, iwork, tau, work, lwork, info, x25, x26, x27);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zggsvp3_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("zggsvp3_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zggsvp3_(const char *jobu, const char *jobv, const char *jobq, const int *m, const int *p, const int *n, _Complex double *A, const int *lda, _Complex double *B, const int *ldb, const double *tola, const double *tolb, int *k, int *l, _Complex double *U, const int *ldu, _Complex double *V, const int *ldv, _Complex double *Q, const int *ldq, int *iwork, double *rwork, _Complex double *tau, _Complex double *work, const int *lwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor zggsvp3_$descriptor() {
        return zggsvp3_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zggsvp3_(const char *jobu, const char *jobv, const char *jobq, const int *m, const int *p, const int *n, _Complex double *A, const int *lda, _Complex double *B, const int *ldb, const double *tola, const double *tolb, int *k, int *l, _Complex double *U, const int *ldu, _Complex double *V, const int *ldv, _Complex double *Q, const int *ldq, int *iwork, double *rwork, _Complex double *tau, _Complex double *work, const int *lwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle zggsvp3_$handle() {
        return zggsvp3_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zggsvp3_(const char *jobu, const char *jobv, const char *jobq, const int *m, const int *p, const int *n, _Complex double *A, const int *lda, _Complex double *B, const int *ldb, const double *tola, const double *tolb, int *k, int *l, _Complex double *U, const int *ldu, _Complex double *V, const int *ldv, _Complex double *Q, const int *ldq, int *iwork, double *rwork, _Complex double *tau, _Complex double *work, const int *lwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment zggsvp3_$address() {
        return zggsvp3_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zggsvp3_(const char *jobu, const char *jobv, const char *jobq, const int *m, const int *p, const int *n, _Complex double *A, const int *lda, _Complex double *B, const int *ldb, const double *tola, const double *tolb, int *k, int *l, _Complex double *U, const int *ldu, _Complex double *V, const int *ldv, _Complex double *Q, const int *ldq, int *iwork, double *rwork, _Complex double *tau, _Complex double *work, const int *lwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static void zggsvp3_(MemorySegment jobu, MemorySegment jobv, MemorySegment jobq, MemorySegment m, MemorySegment p, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment B, MemorySegment ldb, MemorySegment tola, MemorySegment tolb, MemorySegment k, MemorySegment l, MemorySegment U, MemorySegment ldu, MemorySegment V, MemorySegment ldv, MemorySegment Q, MemorySegment ldq, MemorySegment iwork, MemorySegment rwork, MemorySegment tau, MemorySegment work, MemorySegment lwork, MemorySegment info, long x26, long x27, long x28) {
        var mh$ = zggsvp3_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zggsvp3_", jobu, jobv, jobq, m, p, n, A, lda, B, ldb, tola, tolb, k, l, U, ldu, V, ldv, Q, ldq, iwork, rwork, tau, work, lwork, info, x26, x27, x28);
            }
            mh$.invokeExact(jobu, jobv, jobq, m, p, n, A, lda, B, ldb, tola, tolb, k, l, U, ldu, V, ldv, Q, ldq, iwork, rwork, tau, work, lwork, info, x26, x27, x28);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cgtcon_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cgtcon_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cgtcon_(const char *norm, const int *n, const _Complex float *DL, const _Complex float *D, const _Complex float *DU, const _Complex float *DU2, const int *ipiv, const float *anorm, float *rcond, _Complex float *work, int *info, size_t)
     * }
     */
    public static FunctionDescriptor cgtcon_$descriptor() {
        return cgtcon_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cgtcon_(const char *norm, const int *n, const _Complex float *DL, const _Complex float *D, const _Complex float *DU, const _Complex float *DU2, const int *ipiv, const float *anorm, float *rcond, _Complex float *work, int *info, size_t)
     * }
     */
    public static MethodHandle cgtcon_$handle() {
        return cgtcon_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cgtcon_(const char *norm, const int *n, const _Complex float *DL, const _Complex float *D, const _Complex float *DU, const _Complex float *DU2, const int *ipiv, const float *anorm, float *rcond, _Complex float *work, int *info, size_t)
     * }
     */
    public static MemorySegment cgtcon_$address() {
        return cgtcon_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cgtcon_(const char *norm, const int *n, const _Complex float *DL, const _Complex float *D, const _Complex float *DU, const _Complex float *DU2, const int *ipiv, const float *anorm, float *rcond, _Complex float *work, int *info, size_t)
     * }
     */
    public static void cgtcon_(MemorySegment norm, MemorySegment n, MemorySegment DL, MemorySegment D, MemorySegment DU, MemorySegment DU2, MemorySegment ipiv, MemorySegment anorm, MemorySegment rcond, MemorySegment work, MemorySegment info, long x11) {
        var mh$ = cgtcon_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cgtcon_", norm, n, DL, D, DU, DU2, ipiv, anorm, rcond, work, info, x11);
            }
            mh$.invokeExact(norm, n, DL, D, DU, DU2, ipiv, anorm, rcond, work, info, x11);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dgtcon_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("dgtcon_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dgtcon_(const char *norm, const int *n, const double *DL, const double *D, const double *DU, const double *DU2, const int *ipiv, const double *anorm, double *rcond, double *work, int *iwork, int *info, size_t)
     * }
     */
    public static FunctionDescriptor dgtcon_$descriptor() {
        return dgtcon_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dgtcon_(const char *norm, const int *n, const double *DL, const double *D, const double *DU, const double *DU2, const int *ipiv, const double *anorm, double *rcond, double *work, int *iwork, int *info, size_t)
     * }
     */
    public static MethodHandle dgtcon_$handle() {
        return dgtcon_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dgtcon_(const char *norm, const int *n, const double *DL, const double *D, const double *DU, const double *DU2, const int *ipiv, const double *anorm, double *rcond, double *work, int *iwork, int *info, size_t)
     * }
     */
    public static MemorySegment dgtcon_$address() {
        return dgtcon_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dgtcon_(const char *norm, const int *n, const double *DL, const double *D, const double *DU, const double *DU2, const int *ipiv, const double *anorm, double *rcond, double *work, int *iwork, int *info, size_t)
     * }
     */
    public static void dgtcon_(MemorySegment norm, MemorySegment n, MemorySegment DL, MemorySegment D, MemorySegment DU, MemorySegment DU2, MemorySegment ipiv, MemorySegment anorm, MemorySegment rcond, MemorySegment work, MemorySegment iwork, MemorySegment info, long x12) {
        var mh$ = dgtcon_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dgtcon_", norm, n, DL, D, DU, DU2, ipiv, anorm, rcond, work, iwork, info, x12);
            }
            mh$.invokeExact(norm, n, DL, D, DU, DU2, ipiv, anorm, rcond, work, iwork, info, x12);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sgtcon_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("sgtcon_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void sgtcon_(const char *norm, const int *n, const float *DL, const float *D, const float *DU, const float *DU2, const int *ipiv, const float *anorm, float *rcond, float *work, int *iwork, int *info, size_t)
     * }
     */
    public static FunctionDescriptor sgtcon_$descriptor() {
        return sgtcon_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void sgtcon_(const char *norm, const int *n, const float *DL, const float *D, const float *DU, const float *DU2, const int *ipiv, const float *anorm, float *rcond, float *work, int *iwork, int *info, size_t)
     * }
     */
    public static MethodHandle sgtcon_$handle() {
        return sgtcon_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void sgtcon_(const char *norm, const int *n, const float *DL, const float *D, const float *DU, const float *DU2, const int *ipiv, const float *anorm, float *rcond, float *work, int *iwork, int *info, size_t)
     * }
     */
    public static MemorySegment sgtcon_$address() {
        return sgtcon_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void sgtcon_(const char *norm, const int *n, const float *DL, const float *D, const float *DU, const float *DU2, const int *ipiv, const float *anorm, float *rcond, float *work, int *iwork, int *info, size_t)
     * }
     */
    public static void sgtcon_(MemorySegment norm, MemorySegment n, MemorySegment DL, MemorySegment D, MemorySegment DU, MemorySegment DU2, MemorySegment ipiv, MemorySegment anorm, MemorySegment rcond, MemorySegment work, MemorySegment iwork, MemorySegment info, long x12) {
        var mh$ = sgtcon_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sgtcon_", norm, n, DL, D, DU, DU2, ipiv, anorm, rcond, work, iwork, info, x12);
            }
            mh$.invokeExact(norm, n, DL, D, DU, DU2, ipiv, anorm, rcond, work, iwork, info, x12);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zgtcon_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("zgtcon_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zgtcon_(const char *norm, const int *n, const _Complex double *DL, const _Complex double *D, const _Complex double *DU, const _Complex double *DU2, const int *ipiv, const double *anorm, double *rcond, _Complex double *work, int *info, size_t)
     * }
     */
    public static FunctionDescriptor zgtcon_$descriptor() {
        return zgtcon_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zgtcon_(const char *norm, const int *n, const _Complex double *DL, const _Complex double *D, const _Complex double *DU, const _Complex double *DU2, const int *ipiv, const double *anorm, double *rcond, _Complex double *work, int *info, size_t)
     * }
     */
    public static MethodHandle zgtcon_$handle() {
        return zgtcon_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zgtcon_(const char *norm, const int *n, const _Complex double *DL, const _Complex double *D, const _Complex double *DU, const _Complex double *DU2, const int *ipiv, const double *anorm, double *rcond, _Complex double *work, int *info, size_t)
     * }
     */
    public static MemorySegment zgtcon_$address() {
        return zgtcon_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zgtcon_(const char *norm, const int *n, const _Complex double *DL, const _Complex double *D, const _Complex double *DU, const _Complex double *DU2, const int *ipiv, const double *anorm, double *rcond, _Complex double *work, int *info, size_t)
     * }
     */
    public static void zgtcon_(MemorySegment norm, MemorySegment n, MemorySegment DL, MemorySegment D, MemorySegment DU, MemorySegment DU2, MemorySegment ipiv, MemorySegment anorm, MemorySegment rcond, MemorySegment work, MemorySegment info, long x11) {
        var mh$ = zgtcon_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zgtcon_", norm, n, DL, D, DU, DU2, ipiv, anorm, rcond, work, info, x11);
            }
            mh$.invokeExact(norm, n, DL, D, DU, DU2, ipiv, anorm, rcond, work, info, x11);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cgtrfs_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cgtrfs_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cgtrfs_(const char *trans, const int *n, const int *nrhs, const _Complex float *DL, const _Complex float *D, const _Complex float *DU, const _Complex float *DLF, const _Complex float *DF, const _Complex float *DUF, const _Complex float *DU2, const int *ipiv, const _Complex float *B, const int *ldb, _Complex float *X, const int *ldx, float *ferr, float *berr, _Complex float *work, float *rwork, int *info, size_t)
     * }
     */
    public static FunctionDescriptor cgtrfs_$descriptor() {
        return cgtrfs_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cgtrfs_(const char *trans, const int *n, const int *nrhs, const _Complex float *DL, const _Complex float *D, const _Complex float *DU, const _Complex float *DLF, const _Complex float *DF, const _Complex float *DUF, const _Complex float *DU2, const int *ipiv, const _Complex float *B, const int *ldb, _Complex float *X, const int *ldx, float *ferr, float *berr, _Complex float *work, float *rwork, int *info, size_t)
     * }
     */
    public static MethodHandle cgtrfs_$handle() {
        return cgtrfs_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cgtrfs_(const char *trans, const int *n, const int *nrhs, const _Complex float *DL, const _Complex float *D, const _Complex float *DU, const _Complex float *DLF, const _Complex float *DF, const _Complex float *DUF, const _Complex float *DU2, const int *ipiv, const _Complex float *B, const int *ldb, _Complex float *X, const int *ldx, float *ferr, float *berr, _Complex float *work, float *rwork, int *info, size_t)
     * }
     */
    public static MemorySegment cgtrfs_$address() {
        return cgtrfs_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cgtrfs_(const char *trans, const int *n, const int *nrhs, const _Complex float *DL, const _Complex float *D, const _Complex float *DU, const _Complex float *DLF, const _Complex float *DF, const _Complex float *DUF, const _Complex float *DU2, const int *ipiv, const _Complex float *B, const int *ldb, _Complex float *X, const int *ldx, float *ferr, float *berr, _Complex float *work, float *rwork, int *info, size_t)
     * }
     */
    public static void cgtrfs_(MemorySegment trans, MemorySegment n, MemorySegment nrhs, MemorySegment DL, MemorySegment D, MemorySegment DU, MemorySegment DLF, MemorySegment DF, MemorySegment DUF, MemorySegment DU2, MemorySegment ipiv, MemorySegment B, MemorySegment ldb, MemorySegment X, MemorySegment ldx, MemorySegment ferr, MemorySegment berr, MemorySegment work, MemorySegment rwork, MemorySegment info, long x20) {
        var mh$ = cgtrfs_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cgtrfs_", trans, n, nrhs, DL, D, DU, DLF, DF, DUF, DU2, ipiv, B, ldb, X, ldx, ferr, berr, work, rwork, info, x20);
            }
            mh$.invokeExact(trans, n, nrhs, DL, D, DU, DLF, DF, DUF, DU2, ipiv, B, ldb, X, ldx, ferr, berr, work, rwork, info, x20);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dgtrfs_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("dgtrfs_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dgtrfs_(const char *trans, const int *n, const int *nrhs, const double *DL, const double *D, const double *DU, const double *DLF, const double *DF, const double *DUF, const double *DU2, const int *ipiv, const double *B, const int *ldb, double *X, const int *ldx, double *ferr, double *berr, double *work, int *iwork, int *info, size_t)
     * }
     */
    public static FunctionDescriptor dgtrfs_$descriptor() {
        return dgtrfs_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dgtrfs_(const char *trans, const int *n, const int *nrhs, const double *DL, const double *D, const double *DU, const double *DLF, const double *DF, const double *DUF, const double *DU2, const int *ipiv, const double *B, const int *ldb, double *X, const int *ldx, double *ferr, double *berr, double *work, int *iwork, int *info, size_t)
     * }
     */
    public static MethodHandle dgtrfs_$handle() {
        return dgtrfs_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dgtrfs_(const char *trans, const int *n, const int *nrhs, const double *DL, const double *D, const double *DU, const double *DLF, const double *DF, const double *DUF, const double *DU2, const int *ipiv, const double *B, const int *ldb, double *X, const int *ldx, double *ferr, double *berr, double *work, int *iwork, int *info, size_t)
     * }
     */
    public static MemorySegment dgtrfs_$address() {
        return dgtrfs_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dgtrfs_(const char *trans, const int *n, const int *nrhs, const double *DL, const double *D, const double *DU, const double *DLF, const double *DF, const double *DUF, const double *DU2, const int *ipiv, const double *B, const int *ldb, double *X, const int *ldx, double *ferr, double *berr, double *work, int *iwork, int *info, size_t)
     * }
     */
    public static void dgtrfs_(MemorySegment trans, MemorySegment n, MemorySegment nrhs, MemorySegment DL, MemorySegment D, MemorySegment DU, MemorySegment DLF, MemorySegment DF, MemorySegment DUF, MemorySegment DU2, MemorySegment ipiv, MemorySegment B, MemorySegment ldb, MemorySegment X, MemorySegment ldx, MemorySegment ferr, MemorySegment berr, MemorySegment work, MemorySegment iwork, MemorySegment info, long x20) {
        var mh$ = dgtrfs_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dgtrfs_", trans, n, nrhs, DL, D, DU, DLF, DF, DUF, DU2, ipiv, B, ldb, X, ldx, ferr, berr, work, iwork, info, x20);
            }
            mh$.invokeExact(trans, n, nrhs, DL, D, DU, DLF, DF, DUF, DU2, ipiv, B, ldb, X, ldx, ferr, berr, work, iwork, info, x20);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sgtrfs_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("sgtrfs_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void sgtrfs_(const char *trans, const int *n, const int *nrhs, const float *DL, const float *D, const float *DU, const float *DLF, const float *DF, const float *DUF, const float *DU2, const int *ipiv, const float *B, const int *ldb, float *X, const int *ldx, float *ferr, float *berr, float *work, int *iwork, int *info, size_t)
     * }
     */
    public static FunctionDescriptor sgtrfs_$descriptor() {
        return sgtrfs_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void sgtrfs_(const char *trans, const int *n, const int *nrhs, const float *DL, const float *D, const float *DU, const float *DLF, const float *DF, const float *DUF, const float *DU2, const int *ipiv, const float *B, const int *ldb, float *X, const int *ldx, float *ferr, float *berr, float *work, int *iwork, int *info, size_t)
     * }
     */
    public static MethodHandle sgtrfs_$handle() {
        return sgtrfs_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void sgtrfs_(const char *trans, const int *n, const int *nrhs, const float *DL, const float *D, const float *DU, const float *DLF, const float *DF, const float *DUF, const float *DU2, const int *ipiv, const float *B, const int *ldb, float *X, const int *ldx, float *ferr, float *berr, float *work, int *iwork, int *info, size_t)
     * }
     */
    public static MemorySegment sgtrfs_$address() {
        return sgtrfs_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void sgtrfs_(const char *trans, const int *n, const int *nrhs, const float *DL, const float *D, const float *DU, const float *DLF, const float *DF, const float *DUF, const float *DU2, const int *ipiv, const float *B, const int *ldb, float *X, const int *ldx, float *ferr, float *berr, float *work, int *iwork, int *info, size_t)
     * }
     */
    public static void sgtrfs_(MemorySegment trans, MemorySegment n, MemorySegment nrhs, MemorySegment DL, MemorySegment D, MemorySegment DU, MemorySegment DLF, MemorySegment DF, MemorySegment DUF, MemorySegment DU2, MemorySegment ipiv, MemorySegment B, MemorySegment ldb, MemorySegment X, MemorySegment ldx, MemorySegment ferr, MemorySegment berr, MemorySegment work, MemorySegment iwork, MemorySegment info, long x20) {
        var mh$ = sgtrfs_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sgtrfs_", trans, n, nrhs, DL, D, DU, DLF, DF, DUF, DU2, ipiv, B, ldb, X, ldx, ferr, berr, work, iwork, info, x20);
            }
            mh$.invokeExact(trans, n, nrhs, DL, D, DU, DLF, DF, DUF, DU2, ipiv, B, ldb, X, ldx, ferr, berr, work, iwork, info, x20);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zgtrfs_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("zgtrfs_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zgtrfs_(const char *trans, const int *n, const int *nrhs, const _Complex double *DL, const _Complex double *D, const _Complex double *DU, const _Complex double *DLF, const _Complex double *DF, const _Complex double *DUF, const _Complex double *DU2, const int *ipiv, const _Complex double *B, const int *ldb, _Complex double *X, const int *ldx, double *ferr, double *berr, _Complex double *work, double *rwork, int *info, size_t)
     * }
     */
    public static FunctionDescriptor zgtrfs_$descriptor() {
        return zgtrfs_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zgtrfs_(const char *trans, const int *n, const int *nrhs, const _Complex double *DL, const _Complex double *D, const _Complex double *DU, const _Complex double *DLF, const _Complex double *DF, const _Complex double *DUF, const _Complex double *DU2, const int *ipiv, const _Complex double *B, const int *ldb, _Complex double *X, const int *ldx, double *ferr, double *berr, _Complex double *work, double *rwork, int *info, size_t)
     * }
     */
    public static MethodHandle zgtrfs_$handle() {
        return zgtrfs_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zgtrfs_(const char *trans, const int *n, const int *nrhs, const _Complex double *DL, const _Complex double *D, const _Complex double *DU, const _Complex double *DLF, const _Complex double *DF, const _Complex double *DUF, const _Complex double *DU2, const int *ipiv, const _Complex double *B, const int *ldb, _Complex double *X, const int *ldx, double *ferr, double *berr, _Complex double *work, double *rwork, int *info, size_t)
     * }
     */
    public static MemorySegment zgtrfs_$address() {
        return zgtrfs_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zgtrfs_(const char *trans, const int *n, const int *nrhs, const _Complex double *DL, const _Complex double *D, const _Complex double *DU, const _Complex double *DLF, const _Complex double *DF, const _Complex double *DUF, const _Complex double *DU2, const int *ipiv, const _Complex double *B, const int *ldb, _Complex double *X, const int *ldx, double *ferr, double *berr, _Complex double *work, double *rwork, int *info, size_t)
     * }
     */
    public static void zgtrfs_(MemorySegment trans, MemorySegment n, MemorySegment nrhs, MemorySegment DL, MemorySegment D, MemorySegment DU, MemorySegment DLF, MemorySegment DF, MemorySegment DUF, MemorySegment DU2, MemorySegment ipiv, MemorySegment B, MemorySegment ldb, MemorySegment X, MemorySegment ldx, MemorySegment ferr, MemorySegment berr, MemorySegment work, MemorySegment rwork, MemorySegment info, long x20) {
        var mh$ = zgtrfs_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zgtrfs_", trans, n, nrhs, DL, D, DU, DLF, DF, DUF, DU2, ipiv, B, ldb, X, ldx, ferr, berr, work, rwork, info, x20);
            }
            mh$.invokeExact(trans, n, nrhs, DL, D, DU, DLF, DF, DUF, DU2, ipiv, B, ldb, X, ldx, ferr, berr, work, rwork, info, x20);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cgtsv_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cgtsv_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cgtsv_(const int *n, const int *nrhs, _Complex float *DL, _Complex float *D, _Complex float *DU, _Complex float *B, const int *ldb, int *info)
     * }
     */
    public static FunctionDescriptor cgtsv_$descriptor() {
        return cgtsv_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cgtsv_(const int *n, const int *nrhs, _Complex float *DL, _Complex float *D, _Complex float *DU, _Complex float *B, const int *ldb, int *info)
     * }
     */
    public static MethodHandle cgtsv_$handle() {
        return cgtsv_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cgtsv_(const int *n, const int *nrhs, _Complex float *DL, _Complex float *D, _Complex float *DU, _Complex float *B, const int *ldb, int *info)
     * }
     */
    public static MemorySegment cgtsv_$address() {
        return cgtsv_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cgtsv_(const int *n, const int *nrhs, _Complex float *DL, _Complex float *D, _Complex float *DU, _Complex float *B, const int *ldb, int *info)
     * }
     */
    public static void cgtsv_(MemorySegment n, MemorySegment nrhs, MemorySegment DL, MemorySegment D, MemorySegment DU, MemorySegment B, MemorySegment ldb, MemorySegment info) {
        var mh$ = cgtsv_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cgtsv_", n, nrhs, DL, D, DU, B, ldb, info);
            }
            mh$.invokeExact(n, nrhs, DL, D, DU, B, ldb, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dgtsv_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("dgtsv_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dgtsv_(const int *n, const int *nrhs, double *DL, double *D, double *DU, double *B, const int *ldb, int *info)
     * }
     */
    public static FunctionDescriptor dgtsv_$descriptor() {
        return dgtsv_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dgtsv_(const int *n, const int *nrhs, double *DL, double *D, double *DU, double *B, const int *ldb, int *info)
     * }
     */
    public static MethodHandle dgtsv_$handle() {
        return dgtsv_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dgtsv_(const int *n, const int *nrhs, double *DL, double *D, double *DU, double *B, const int *ldb, int *info)
     * }
     */
    public static MemorySegment dgtsv_$address() {
        return dgtsv_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dgtsv_(const int *n, const int *nrhs, double *DL, double *D, double *DU, double *B, const int *ldb, int *info)
     * }
     */
    public static void dgtsv_(MemorySegment n, MemorySegment nrhs, MemorySegment DL, MemorySegment D, MemorySegment DU, MemorySegment B, MemorySegment ldb, MemorySegment info) {
        var mh$ = dgtsv_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dgtsv_", n, nrhs, DL, D, DU, B, ldb, info);
            }
            mh$.invokeExact(n, nrhs, DL, D, DU, B, ldb, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sgtsv_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("sgtsv_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void sgtsv_(const int *n, const int *nrhs, float *DL, float *D, float *DU, float *B, const int *ldb, int *info)
     * }
     */
    public static FunctionDescriptor sgtsv_$descriptor() {
        return sgtsv_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void sgtsv_(const int *n, const int *nrhs, float *DL, float *D, float *DU, float *B, const int *ldb, int *info)
     * }
     */
    public static MethodHandle sgtsv_$handle() {
        return sgtsv_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void sgtsv_(const int *n, const int *nrhs, float *DL, float *D, float *DU, float *B, const int *ldb, int *info)
     * }
     */
    public static MemorySegment sgtsv_$address() {
        return sgtsv_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void sgtsv_(const int *n, const int *nrhs, float *DL, float *D, float *DU, float *B, const int *ldb, int *info)
     * }
     */
    public static void sgtsv_(MemorySegment n, MemorySegment nrhs, MemorySegment DL, MemorySegment D, MemorySegment DU, MemorySegment B, MemorySegment ldb, MemorySegment info) {
        var mh$ = sgtsv_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sgtsv_", n, nrhs, DL, D, DU, B, ldb, info);
            }
            mh$.invokeExact(n, nrhs, DL, D, DU, B, ldb, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zgtsv_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("zgtsv_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zgtsv_(const int *n, const int *nrhs, _Complex double *DL, _Complex double *D, _Complex double *DU, _Complex double *B, const int *ldb, int *info)
     * }
     */
    public static FunctionDescriptor zgtsv_$descriptor() {
        return zgtsv_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zgtsv_(const int *n, const int *nrhs, _Complex double *DL, _Complex double *D, _Complex double *DU, _Complex double *B, const int *ldb, int *info)
     * }
     */
    public static MethodHandle zgtsv_$handle() {
        return zgtsv_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zgtsv_(const int *n, const int *nrhs, _Complex double *DL, _Complex double *D, _Complex double *DU, _Complex double *B, const int *ldb, int *info)
     * }
     */
    public static MemorySegment zgtsv_$address() {
        return zgtsv_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zgtsv_(const int *n, const int *nrhs, _Complex double *DL, _Complex double *D, _Complex double *DU, _Complex double *B, const int *ldb, int *info)
     * }
     */
    public static void zgtsv_(MemorySegment n, MemorySegment nrhs, MemorySegment DL, MemorySegment D, MemorySegment DU, MemorySegment B, MemorySegment ldb, MemorySegment info) {
        var mh$ = zgtsv_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zgtsv_", n, nrhs, DL, D, DU, B, ldb, info);
            }
            mh$.invokeExact(n, nrhs, DL, D, DU, B, ldb, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cgtsvx_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cgtsvx_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cgtsvx_(const char *fact, const char *trans, const int *n, const int *nrhs, const _Complex float *DL, const _Complex float *D, const _Complex float *DU, _Complex float *DLF, _Complex float *DF, _Complex float *DUF, _Complex float *DU2, int *ipiv, const _Complex float *B, const int *ldb, _Complex float *X, const int *ldx, float *rcond, float *ferr, float *berr, _Complex float *work, float *rwork, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor cgtsvx_$descriptor() {
        return cgtsvx_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cgtsvx_(const char *fact, const char *trans, const int *n, const int *nrhs, const _Complex float *DL, const _Complex float *D, const _Complex float *DU, _Complex float *DLF, _Complex float *DF, _Complex float *DUF, _Complex float *DU2, int *ipiv, const _Complex float *B, const int *ldb, _Complex float *X, const int *ldx, float *rcond, float *ferr, float *berr, _Complex float *work, float *rwork, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle cgtsvx_$handle() {
        return cgtsvx_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cgtsvx_(const char *fact, const char *trans, const int *n, const int *nrhs, const _Complex float *DL, const _Complex float *D, const _Complex float *DU, _Complex float *DLF, _Complex float *DF, _Complex float *DUF, _Complex float *DU2, int *ipiv, const _Complex float *B, const int *ldb, _Complex float *X, const int *ldx, float *rcond, float *ferr, float *berr, _Complex float *work, float *rwork, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment cgtsvx_$address() {
        return cgtsvx_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cgtsvx_(const char *fact, const char *trans, const int *n, const int *nrhs, const _Complex float *DL, const _Complex float *D, const _Complex float *DU, _Complex float *DLF, _Complex float *DF, _Complex float *DUF, _Complex float *DU2, int *ipiv, const _Complex float *B, const int *ldb, _Complex float *X, const int *ldx, float *rcond, float *ferr, float *berr, _Complex float *work, float *rwork, int *info, size_t, size_t)
     * }
     */
    public static void cgtsvx_(MemorySegment fact, MemorySegment trans, MemorySegment n, MemorySegment nrhs, MemorySegment DL, MemorySegment D, MemorySegment DU, MemorySegment DLF, MemorySegment DF, MemorySegment DUF, MemorySegment DU2, MemorySegment ipiv, MemorySegment B, MemorySegment ldb, MemorySegment X, MemorySegment ldx, MemorySegment rcond, MemorySegment ferr, MemorySegment berr, MemorySegment work, MemorySegment rwork, MemorySegment info, long x22, long x23) {
        var mh$ = cgtsvx_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cgtsvx_", fact, trans, n, nrhs, DL, D, DU, DLF, DF, DUF, DU2, ipiv, B, ldb, X, ldx, rcond, ferr, berr, work, rwork, info, x22, x23);
            }
            mh$.invokeExact(fact, trans, n, nrhs, DL, D, DU, DLF, DF, DUF, DU2, ipiv, B, ldb, X, ldx, rcond, ferr, berr, work, rwork, info, x22, x23);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dgtsvx_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("dgtsvx_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dgtsvx_(const char *fact, const char *trans, const int *n, const int *nrhs, const double *DL, const double *D, const double *DU, double *DLF, double *DF, double *DUF, double *DU2, int *ipiv, const double *B, const int *ldb, double *X, const int *ldx, double *rcond, double *ferr, double *berr, double *work, int *iwork, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor dgtsvx_$descriptor() {
        return dgtsvx_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dgtsvx_(const char *fact, const char *trans, const int *n, const int *nrhs, const double *DL, const double *D, const double *DU, double *DLF, double *DF, double *DUF, double *DU2, int *ipiv, const double *B, const int *ldb, double *X, const int *ldx, double *rcond, double *ferr, double *berr, double *work, int *iwork, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle dgtsvx_$handle() {
        return dgtsvx_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dgtsvx_(const char *fact, const char *trans, const int *n, const int *nrhs, const double *DL, const double *D, const double *DU, double *DLF, double *DF, double *DUF, double *DU2, int *ipiv, const double *B, const int *ldb, double *X, const int *ldx, double *rcond, double *ferr, double *berr, double *work, int *iwork, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment dgtsvx_$address() {
        return dgtsvx_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dgtsvx_(const char *fact, const char *trans, const int *n, const int *nrhs, const double *DL, const double *D, const double *DU, double *DLF, double *DF, double *DUF, double *DU2, int *ipiv, const double *B, const int *ldb, double *X, const int *ldx, double *rcond, double *ferr, double *berr, double *work, int *iwork, int *info, size_t, size_t)
     * }
     */
    public static void dgtsvx_(MemorySegment fact, MemorySegment trans, MemorySegment n, MemorySegment nrhs, MemorySegment DL, MemorySegment D, MemorySegment DU, MemorySegment DLF, MemorySegment DF, MemorySegment DUF, MemorySegment DU2, MemorySegment ipiv, MemorySegment B, MemorySegment ldb, MemorySegment X, MemorySegment ldx, MemorySegment rcond, MemorySegment ferr, MemorySegment berr, MemorySegment work, MemorySegment iwork, MemorySegment info, long x22, long x23) {
        var mh$ = dgtsvx_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dgtsvx_", fact, trans, n, nrhs, DL, D, DU, DLF, DF, DUF, DU2, ipiv, B, ldb, X, ldx, rcond, ferr, berr, work, iwork, info, x22, x23);
            }
            mh$.invokeExact(fact, trans, n, nrhs, DL, D, DU, DLF, DF, DUF, DU2, ipiv, B, ldb, X, ldx, rcond, ferr, berr, work, iwork, info, x22, x23);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sgtsvx_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("sgtsvx_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void sgtsvx_(const char *fact, const char *trans, const int *n, const int *nrhs, const float *DL, const float *D, const float *DU, float *DLF, float *DF, float *DUF, float *DU2, int *ipiv, const float *B, const int *ldb, float *X, const int *ldx, float *rcond, float *ferr, float *berr, float *work, int *iwork, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor sgtsvx_$descriptor() {
        return sgtsvx_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void sgtsvx_(const char *fact, const char *trans, const int *n, const int *nrhs, const float *DL, const float *D, const float *DU, float *DLF, float *DF, float *DUF, float *DU2, int *ipiv, const float *B, const int *ldb, float *X, const int *ldx, float *rcond, float *ferr, float *berr, float *work, int *iwork, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle sgtsvx_$handle() {
        return sgtsvx_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void sgtsvx_(const char *fact, const char *trans, const int *n, const int *nrhs, const float *DL, const float *D, const float *DU, float *DLF, float *DF, float *DUF, float *DU2, int *ipiv, const float *B, const int *ldb, float *X, const int *ldx, float *rcond, float *ferr, float *berr, float *work, int *iwork, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment sgtsvx_$address() {
        return sgtsvx_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void sgtsvx_(const char *fact, const char *trans, const int *n, const int *nrhs, const float *DL, const float *D, const float *DU, float *DLF, float *DF, float *DUF, float *DU2, int *ipiv, const float *B, const int *ldb, float *X, const int *ldx, float *rcond, float *ferr, float *berr, float *work, int *iwork, int *info, size_t, size_t)
     * }
     */
    public static void sgtsvx_(MemorySegment fact, MemorySegment trans, MemorySegment n, MemorySegment nrhs, MemorySegment DL, MemorySegment D, MemorySegment DU, MemorySegment DLF, MemorySegment DF, MemorySegment DUF, MemorySegment DU2, MemorySegment ipiv, MemorySegment B, MemorySegment ldb, MemorySegment X, MemorySegment ldx, MemorySegment rcond, MemorySegment ferr, MemorySegment berr, MemorySegment work, MemorySegment iwork, MemorySegment info, long x22, long x23) {
        var mh$ = sgtsvx_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sgtsvx_", fact, trans, n, nrhs, DL, D, DU, DLF, DF, DUF, DU2, ipiv, B, ldb, X, ldx, rcond, ferr, berr, work, iwork, info, x22, x23);
            }
            mh$.invokeExact(fact, trans, n, nrhs, DL, D, DU, DLF, DF, DUF, DU2, ipiv, B, ldb, X, ldx, rcond, ferr, berr, work, iwork, info, x22, x23);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zgtsvx_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("zgtsvx_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zgtsvx_(const char *fact, const char *trans, const int *n, const int *nrhs, const _Complex double *DL, const _Complex double *D, const _Complex double *DU, _Complex double *DLF, _Complex double *DF, _Complex double *DUF, _Complex double *DU2, int *ipiv, const _Complex double *B, const int *ldb, _Complex double *X, const int *ldx, double *rcond, double *ferr, double *berr, _Complex double *work, double *rwork, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor zgtsvx_$descriptor() {
        return zgtsvx_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zgtsvx_(const char *fact, const char *trans, const int *n, const int *nrhs, const _Complex double *DL, const _Complex double *D, const _Complex double *DU, _Complex double *DLF, _Complex double *DF, _Complex double *DUF, _Complex double *DU2, int *ipiv, const _Complex double *B, const int *ldb, _Complex double *X, const int *ldx, double *rcond, double *ferr, double *berr, _Complex double *work, double *rwork, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle zgtsvx_$handle() {
        return zgtsvx_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zgtsvx_(const char *fact, const char *trans, const int *n, const int *nrhs, const _Complex double *DL, const _Complex double *D, const _Complex double *DU, _Complex double *DLF, _Complex double *DF, _Complex double *DUF, _Complex double *DU2, int *ipiv, const _Complex double *B, const int *ldb, _Complex double *X, const int *ldx, double *rcond, double *ferr, double *berr, _Complex double *work, double *rwork, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment zgtsvx_$address() {
        return zgtsvx_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zgtsvx_(const char *fact, const char *trans, const int *n, const int *nrhs, const _Complex double *DL, const _Complex double *D, const _Complex double *DU, _Complex double *DLF, _Complex double *DF, _Complex double *DUF, _Complex double *DU2, int *ipiv, const _Complex double *B, const int *ldb, _Complex double *X, const int *ldx, double *rcond, double *ferr, double *berr, _Complex double *work, double *rwork, int *info, size_t, size_t)
     * }
     */
    public static void zgtsvx_(MemorySegment fact, MemorySegment trans, MemorySegment n, MemorySegment nrhs, MemorySegment DL, MemorySegment D, MemorySegment DU, MemorySegment DLF, MemorySegment DF, MemorySegment DUF, MemorySegment DU2, MemorySegment ipiv, MemorySegment B, MemorySegment ldb, MemorySegment X, MemorySegment ldx, MemorySegment rcond, MemorySegment ferr, MemorySegment berr, MemorySegment work, MemorySegment rwork, MemorySegment info, long x22, long x23) {
        var mh$ = zgtsvx_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zgtsvx_", fact, trans, n, nrhs, DL, D, DU, DLF, DF, DUF, DU2, ipiv, B, ldb, X, ldx, rcond, ferr, berr, work, rwork, info, x22, x23);
            }
            mh$.invokeExact(fact, trans, n, nrhs, DL, D, DU, DLF, DF, DUF, DU2, ipiv, B, ldb, X, ldx, rcond, ferr, berr, work, rwork, info, x22, x23);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cgttrf_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cgttrf_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cgttrf_(const int *n, _Complex float *DL, _Complex float *D, _Complex float *DU, _Complex float *DU2, int *ipiv, int *info)
     * }
     */
    public static FunctionDescriptor cgttrf_$descriptor() {
        return cgttrf_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cgttrf_(const int *n, _Complex float *DL, _Complex float *D, _Complex float *DU, _Complex float *DU2, int *ipiv, int *info)
     * }
     */
    public static MethodHandle cgttrf_$handle() {
        return cgttrf_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cgttrf_(const int *n, _Complex float *DL, _Complex float *D, _Complex float *DU, _Complex float *DU2, int *ipiv, int *info)
     * }
     */
    public static MemorySegment cgttrf_$address() {
        return cgttrf_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cgttrf_(const int *n, _Complex float *DL, _Complex float *D, _Complex float *DU, _Complex float *DU2, int *ipiv, int *info)
     * }
     */
    public static void cgttrf_(MemorySegment n, MemorySegment DL, MemorySegment D, MemorySegment DU, MemorySegment DU2, MemorySegment ipiv, MemorySegment info) {
        var mh$ = cgttrf_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cgttrf_", n, DL, D, DU, DU2, ipiv, info);
            }
            mh$.invokeExact(n, DL, D, DU, DU2, ipiv, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dgttrf_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("dgttrf_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dgttrf_(const int *n, double *DL, double *D, double *DU, double *DU2, int *ipiv, int *info)
     * }
     */
    public static FunctionDescriptor dgttrf_$descriptor() {
        return dgttrf_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dgttrf_(const int *n, double *DL, double *D, double *DU, double *DU2, int *ipiv, int *info)
     * }
     */
    public static MethodHandle dgttrf_$handle() {
        return dgttrf_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dgttrf_(const int *n, double *DL, double *D, double *DU, double *DU2, int *ipiv, int *info)
     * }
     */
    public static MemorySegment dgttrf_$address() {
        return dgttrf_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dgttrf_(const int *n, double *DL, double *D, double *DU, double *DU2, int *ipiv, int *info)
     * }
     */
    public static void dgttrf_(MemorySegment n, MemorySegment DL, MemorySegment D, MemorySegment DU, MemorySegment DU2, MemorySegment ipiv, MemorySegment info) {
        var mh$ = dgttrf_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dgttrf_", n, DL, D, DU, DU2, ipiv, info);
            }
            mh$.invokeExact(n, DL, D, DU, DU2, ipiv, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sgttrf_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("sgttrf_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void sgttrf_(const int *n, float *DL, float *D, float *DU, float *DU2, int *ipiv, int *info)
     * }
     */
    public static FunctionDescriptor sgttrf_$descriptor() {
        return sgttrf_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void sgttrf_(const int *n, float *DL, float *D, float *DU, float *DU2, int *ipiv, int *info)
     * }
     */
    public static MethodHandle sgttrf_$handle() {
        return sgttrf_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void sgttrf_(const int *n, float *DL, float *D, float *DU, float *DU2, int *ipiv, int *info)
     * }
     */
    public static MemorySegment sgttrf_$address() {
        return sgttrf_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void sgttrf_(const int *n, float *DL, float *D, float *DU, float *DU2, int *ipiv, int *info)
     * }
     */
    public static void sgttrf_(MemorySegment n, MemorySegment DL, MemorySegment D, MemorySegment DU, MemorySegment DU2, MemorySegment ipiv, MemorySegment info) {
        var mh$ = sgttrf_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sgttrf_", n, DL, D, DU, DU2, ipiv, info);
            }
            mh$.invokeExact(n, DL, D, DU, DU2, ipiv, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zgttrf_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("zgttrf_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zgttrf_(const int *n, _Complex double *DL, _Complex double *D, _Complex double *DU, _Complex double *DU2, int *ipiv, int *info)
     * }
     */
    public static FunctionDescriptor zgttrf_$descriptor() {
        return zgttrf_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zgttrf_(const int *n, _Complex double *DL, _Complex double *D, _Complex double *DU, _Complex double *DU2, int *ipiv, int *info)
     * }
     */
    public static MethodHandle zgttrf_$handle() {
        return zgttrf_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zgttrf_(const int *n, _Complex double *DL, _Complex double *D, _Complex double *DU, _Complex double *DU2, int *ipiv, int *info)
     * }
     */
    public static MemorySegment zgttrf_$address() {
        return zgttrf_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zgttrf_(const int *n, _Complex double *DL, _Complex double *D, _Complex double *DU, _Complex double *DU2, int *ipiv, int *info)
     * }
     */
    public static void zgttrf_(MemorySegment n, MemorySegment DL, MemorySegment D, MemorySegment DU, MemorySegment DU2, MemorySegment ipiv, MemorySegment info) {
        var mh$ = zgttrf_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zgttrf_", n, DL, D, DU, DU2, ipiv, info);
            }
            mh$.invokeExact(n, DL, D, DU, DU2, ipiv, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cgttrs_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cgttrs_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cgttrs_(const char *trans, const int *n, const int *nrhs, const _Complex float *DL, const _Complex float *D, const _Complex float *DU, const _Complex float *DU2, const int *ipiv, _Complex float *B, const int *ldb, int *info, size_t)
     * }
     */
    public static FunctionDescriptor cgttrs_$descriptor() {
        return cgttrs_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cgttrs_(const char *trans, const int *n, const int *nrhs, const _Complex float *DL, const _Complex float *D, const _Complex float *DU, const _Complex float *DU2, const int *ipiv, _Complex float *B, const int *ldb, int *info, size_t)
     * }
     */
    public static MethodHandle cgttrs_$handle() {
        return cgttrs_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cgttrs_(const char *trans, const int *n, const int *nrhs, const _Complex float *DL, const _Complex float *D, const _Complex float *DU, const _Complex float *DU2, const int *ipiv, _Complex float *B, const int *ldb, int *info, size_t)
     * }
     */
    public static MemorySegment cgttrs_$address() {
        return cgttrs_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cgttrs_(const char *trans, const int *n, const int *nrhs, const _Complex float *DL, const _Complex float *D, const _Complex float *DU, const _Complex float *DU2, const int *ipiv, _Complex float *B, const int *ldb, int *info, size_t)
     * }
     */
    public static void cgttrs_(MemorySegment trans, MemorySegment n, MemorySegment nrhs, MemorySegment DL, MemorySegment D, MemorySegment DU, MemorySegment DU2, MemorySegment ipiv, MemorySegment B, MemorySegment ldb, MemorySegment info, long x11) {
        var mh$ = cgttrs_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cgttrs_", trans, n, nrhs, DL, D, DU, DU2, ipiv, B, ldb, info, x11);
            }
            mh$.invokeExact(trans, n, nrhs, DL, D, DU, DU2, ipiv, B, ldb, info, x11);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dgttrs_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("dgttrs_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dgttrs_(const char *trans, const int *n, const int *nrhs, const double *DL, const double *D, const double *DU, const double *DU2, const int *ipiv, double *B, const int *ldb, int *info, size_t)
     * }
     */
    public static FunctionDescriptor dgttrs_$descriptor() {
        return dgttrs_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dgttrs_(const char *trans, const int *n, const int *nrhs, const double *DL, const double *D, const double *DU, const double *DU2, const int *ipiv, double *B, const int *ldb, int *info, size_t)
     * }
     */
    public static MethodHandle dgttrs_$handle() {
        return dgttrs_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dgttrs_(const char *trans, const int *n, const int *nrhs, const double *DL, const double *D, const double *DU, const double *DU2, const int *ipiv, double *B, const int *ldb, int *info, size_t)
     * }
     */
    public static MemorySegment dgttrs_$address() {
        return dgttrs_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dgttrs_(const char *trans, const int *n, const int *nrhs, const double *DL, const double *D, const double *DU, const double *DU2, const int *ipiv, double *B, const int *ldb, int *info, size_t)
     * }
     */
    public static void dgttrs_(MemorySegment trans, MemorySegment n, MemorySegment nrhs, MemorySegment DL, MemorySegment D, MemorySegment DU, MemorySegment DU2, MemorySegment ipiv, MemorySegment B, MemorySegment ldb, MemorySegment info, long x11) {
        var mh$ = dgttrs_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dgttrs_", trans, n, nrhs, DL, D, DU, DU2, ipiv, B, ldb, info, x11);
            }
            mh$.invokeExact(trans, n, nrhs, DL, D, DU, DU2, ipiv, B, ldb, info, x11);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sgttrs_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("sgttrs_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void sgttrs_(const char *trans, const int *n, const int *nrhs, const float *DL, const float *D, const float *DU, const float *DU2, const int *ipiv, float *B, const int *ldb, int *info, size_t)
     * }
     */
    public static FunctionDescriptor sgttrs_$descriptor() {
        return sgttrs_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void sgttrs_(const char *trans, const int *n, const int *nrhs, const float *DL, const float *D, const float *DU, const float *DU2, const int *ipiv, float *B, const int *ldb, int *info, size_t)
     * }
     */
    public static MethodHandle sgttrs_$handle() {
        return sgttrs_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void sgttrs_(const char *trans, const int *n, const int *nrhs, const float *DL, const float *D, const float *DU, const float *DU2, const int *ipiv, float *B, const int *ldb, int *info, size_t)
     * }
     */
    public static MemorySegment sgttrs_$address() {
        return sgttrs_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void sgttrs_(const char *trans, const int *n, const int *nrhs, const float *DL, const float *D, const float *DU, const float *DU2, const int *ipiv, float *B, const int *ldb, int *info, size_t)
     * }
     */
    public static void sgttrs_(MemorySegment trans, MemorySegment n, MemorySegment nrhs, MemorySegment DL, MemorySegment D, MemorySegment DU, MemorySegment DU2, MemorySegment ipiv, MemorySegment B, MemorySegment ldb, MemorySegment info, long x11) {
        var mh$ = sgttrs_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sgttrs_", trans, n, nrhs, DL, D, DU, DU2, ipiv, B, ldb, info, x11);
            }
            mh$.invokeExact(trans, n, nrhs, DL, D, DU, DU2, ipiv, B, ldb, info, x11);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zgttrs_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("zgttrs_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zgttrs_(const char *trans, const int *n, const int *nrhs, const _Complex double *DL, const _Complex double *D, const _Complex double *DU, const _Complex double *DU2, const int *ipiv, _Complex double *B, const int *ldb, int *info, size_t)
     * }
     */
    public static FunctionDescriptor zgttrs_$descriptor() {
        return zgttrs_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zgttrs_(const char *trans, const int *n, const int *nrhs, const _Complex double *DL, const _Complex double *D, const _Complex double *DU, const _Complex double *DU2, const int *ipiv, _Complex double *B, const int *ldb, int *info, size_t)
     * }
     */
    public static MethodHandle zgttrs_$handle() {
        return zgttrs_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zgttrs_(const char *trans, const int *n, const int *nrhs, const _Complex double *DL, const _Complex double *D, const _Complex double *DU, const _Complex double *DU2, const int *ipiv, _Complex double *B, const int *ldb, int *info, size_t)
     * }
     */
    public static MemorySegment zgttrs_$address() {
        return zgttrs_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zgttrs_(const char *trans, const int *n, const int *nrhs, const _Complex double *DL, const _Complex double *D, const _Complex double *DU, const _Complex double *DU2, const int *ipiv, _Complex double *B, const int *ldb, int *info, size_t)
     * }
     */
    public static void zgttrs_(MemorySegment trans, MemorySegment n, MemorySegment nrhs, MemorySegment DL, MemorySegment D, MemorySegment DU, MemorySegment DU2, MemorySegment ipiv, MemorySegment B, MemorySegment ldb, MemorySegment info, long x11) {
        var mh$ = zgttrs_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zgttrs_", trans, n, nrhs, DL, D, DU, DU2, ipiv, B, ldb, info, x11);
            }
            mh$.invokeExact(trans, n, nrhs, DL, D, DU, DU2, ipiv, B, ldb, info, x11);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class chbev_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("chbev_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void chbev_(const char *jobz, const char *uplo, const int *n, const int *kd, _Complex float *AB, const int *ldab, float *W, _Complex float *Z, const int *ldz, _Complex float *work, float *rwork, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor chbev_$descriptor() {
        return chbev_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void chbev_(const char *jobz, const char *uplo, const int *n, const int *kd, _Complex float *AB, const int *ldab, float *W, _Complex float *Z, const int *ldz, _Complex float *work, float *rwork, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle chbev_$handle() {
        return chbev_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void chbev_(const char *jobz, const char *uplo, const int *n, const int *kd, _Complex float *AB, const int *ldab, float *W, _Complex float *Z, const int *ldz, _Complex float *work, float *rwork, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment chbev_$address() {
        return chbev_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void chbev_(const char *jobz, const char *uplo, const int *n, const int *kd, _Complex float *AB, const int *ldab, float *W, _Complex float *Z, const int *ldz, _Complex float *work, float *rwork, int *info, size_t, size_t)
     * }
     */
    public static void chbev_(MemorySegment jobz, MemorySegment uplo, MemorySegment n, MemorySegment kd, MemorySegment AB, MemorySegment ldab, MemorySegment W, MemorySegment Z, MemorySegment ldz, MemorySegment work, MemorySegment rwork, MemorySegment info, long x12, long x13) {
        var mh$ = chbev_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("chbev_", jobz, uplo, n, kd, AB, ldab, W, Z, ldz, work, rwork, info, x12, x13);
            }
            mh$.invokeExact(jobz, uplo, n, kd, AB, ldab, W, Z, ldz, work, rwork, info, x12, x13);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zhbev_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("zhbev_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zhbev_(const char *jobz, const char *uplo, const int *n, const int *kd, _Complex double *AB, const int *ldab, double *W, _Complex double *Z, const int *ldz, _Complex double *work, double *rwork, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor zhbev_$descriptor() {
        return zhbev_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zhbev_(const char *jobz, const char *uplo, const int *n, const int *kd, _Complex double *AB, const int *ldab, double *W, _Complex double *Z, const int *ldz, _Complex double *work, double *rwork, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle zhbev_$handle() {
        return zhbev_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zhbev_(const char *jobz, const char *uplo, const int *n, const int *kd, _Complex double *AB, const int *ldab, double *W, _Complex double *Z, const int *ldz, _Complex double *work, double *rwork, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment zhbev_$address() {
        return zhbev_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zhbev_(const char *jobz, const char *uplo, const int *n, const int *kd, _Complex double *AB, const int *ldab, double *W, _Complex double *Z, const int *ldz, _Complex double *work, double *rwork, int *info, size_t, size_t)
     * }
     */
    public static void zhbev_(MemorySegment jobz, MemorySegment uplo, MemorySegment n, MemorySegment kd, MemorySegment AB, MemorySegment ldab, MemorySegment W, MemorySegment Z, MemorySegment ldz, MemorySegment work, MemorySegment rwork, MemorySegment info, long x12, long x13) {
        var mh$ = zhbev_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zhbev_", jobz, uplo, n, kd, AB, ldab, W, Z, ldz, work, rwork, info, x12, x13);
            }
            mh$.invokeExact(jobz, uplo, n, kd, AB, ldab, W, Z, ldz, work, rwork, info, x12, x13);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class chbev_2stage_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("chbev_2stage_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void chbev_2stage_(const char *jobz, const char *uplo, const int *n, const int *kd, _Complex float *AB, const int *ldab, float *W, _Complex float *Z, const int *ldz, _Complex float *work, const int *lwork, float *rwork, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor chbev_2stage_$descriptor() {
        return chbev_2stage_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void chbev_2stage_(const char *jobz, const char *uplo, const int *n, const int *kd, _Complex float *AB, const int *ldab, float *W, _Complex float *Z, const int *ldz, _Complex float *work, const int *lwork, float *rwork, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle chbev_2stage_$handle() {
        return chbev_2stage_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void chbev_2stage_(const char *jobz, const char *uplo, const int *n, const int *kd, _Complex float *AB, const int *ldab, float *W, _Complex float *Z, const int *ldz, _Complex float *work, const int *lwork, float *rwork, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment chbev_2stage_$address() {
        return chbev_2stage_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void chbev_2stage_(const char *jobz, const char *uplo, const int *n, const int *kd, _Complex float *AB, const int *ldab, float *W, _Complex float *Z, const int *ldz, _Complex float *work, const int *lwork, float *rwork, int *info, size_t, size_t)
     * }
     */
    public static void chbev_2stage_(MemorySegment jobz, MemorySegment uplo, MemorySegment n, MemorySegment kd, MemorySegment AB, MemorySegment ldab, MemorySegment W, MemorySegment Z, MemorySegment ldz, MemorySegment work, MemorySegment lwork, MemorySegment rwork, MemorySegment info, long x13, long x14) {
        var mh$ = chbev_2stage_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("chbev_2stage_", jobz, uplo, n, kd, AB, ldab, W, Z, ldz, work, lwork, rwork, info, x13, x14);
            }
            mh$.invokeExact(jobz, uplo, n, kd, AB, ldab, W, Z, ldz, work, lwork, rwork, info, x13, x14);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zhbev_2stage_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("zhbev_2stage_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zhbev_2stage_(const char *jobz, const char *uplo, const int *n, const int *kd, _Complex double *AB, const int *ldab, double *W, _Complex double *Z, const int *ldz, _Complex double *work, const int *lwork, double *rwork, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor zhbev_2stage_$descriptor() {
        return zhbev_2stage_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zhbev_2stage_(const char *jobz, const char *uplo, const int *n, const int *kd, _Complex double *AB, const int *ldab, double *W, _Complex double *Z, const int *ldz, _Complex double *work, const int *lwork, double *rwork, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle zhbev_2stage_$handle() {
        return zhbev_2stage_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zhbev_2stage_(const char *jobz, const char *uplo, const int *n, const int *kd, _Complex double *AB, const int *ldab, double *W, _Complex double *Z, const int *ldz, _Complex double *work, const int *lwork, double *rwork, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment zhbev_2stage_$address() {
        return zhbev_2stage_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zhbev_2stage_(const char *jobz, const char *uplo, const int *n, const int *kd, _Complex double *AB, const int *ldab, double *W, _Complex double *Z, const int *ldz, _Complex double *work, const int *lwork, double *rwork, int *info, size_t, size_t)
     * }
     */
    public static void zhbev_2stage_(MemorySegment jobz, MemorySegment uplo, MemorySegment n, MemorySegment kd, MemorySegment AB, MemorySegment ldab, MemorySegment W, MemorySegment Z, MemorySegment ldz, MemorySegment work, MemorySegment lwork, MemorySegment rwork, MemorySegment info, long x13, long x14) {
        var mh$ = zhbev_2stage_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zhbev_2stage_", jobz, uplo, n, kd, AB, ldab, W, Z, ldz, work, lwork, rwork, info, x13, x14);
            }
            mh$.invokeExact(jobz, uplo, n, kd, AB, ldab, W, Z, ldz, work, lwork, rwork, info, x13, x14);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class chbevd_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("chbevd_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void chbevd_(const char *jobz, const char *uplo, const int *n, const int *kd, _Complex float *AB, const int *ldab, float *W, _Complex float *Z, const int *ldz, _Complex float *work, const int *lwork, float *rwork, const int *lrwork, int *iwork, const int *liwork, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor chbevd_$descriptor() {
        return chbevd_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void chbevd_(const char *jobz, const char *uplo, const int *n, const int *kd, _Complex float *AB, const int *ldab, float *W, _Complex float *Z, const int *ldz, _Complex float *work, const int *lwork, float *rwork, const int *lrwork, int *iwork, const int *liwork, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle chbevd_$handle() {
        return chbevd_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void chbevd_(const char *jobz, const char *uplo, const int *n, const int *kd, _Complex float *AB, const int *ldab, float *W, _Complex float *Z, const int *ldz, _Complex float *work, const int *lwork, float *rwork, const int *lrwork, int *iwork, const int *liwork, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment chbevd_$address() {
        return chbevd_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void chbevd_(const char *jobz, const char *uplo, const int *n, const int *kd, _Complex float *AB, const int *ldab, float *W, _Complex float *Z, const int *ldz, _Complex float *work, const int *lwork, float *rwork, const int *lrwork, int *iwork, const int *liwork, int *info, size_t, size_t)
     * }
     */
    public static void chbevd_(MemorySegment jobz, MemorySegment uplo, MemorySegment n, MemorySegment kd, MemorySegment AB, MemorySegment ldab, MemorySegment W, MemorySegment Z, MemorySegment ldz, MemorySegment work, MemorySegment lwork, MemorySegment rwork, MemorySegment lrwork, MemorySegment iwork, MemorySegment liwork, MemorySegment info, long x16, long x17) {
        var mh$ = chbevd_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("chbevd_", jobz, uplo, n, kd, AB, ldab, W, Z, ldz, work, lwork, rwork, lrwork, iwork, liwork, info, x16, x17);
            }
            mh$.invokeExact(jobz, uplo, n, kd, AB, ldab, W, Z, ldz, work, lwork, rwork, lrwork, iwork, liwork, info, x16, x17);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zhbevd_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("zhbevd_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zhbevd_(const char *jobz, const char *uplo, const int *n, const int *kd, _Complex double *AB, const int *ldab, double *W, _Complex double *Z, const int *ldz, _Complex double *work, const int *lwork, double *rwork, const int *lrwork, int *iwork, const int *liwork, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor zhbevd_$descriptor() {
        return zhbevd_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zhbevd_(const char *jobz, const char *uplo, const int *n, const int *kd, _Complex double *AB, const int *ldab, double *W, _Complex double *Z, const int *ldz, _Complex double *work, const int *lwork, double *rwork, const int *lrwork, int *iwork, const int *liwork, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle zhbevd_$handle() {
        return zhbevd_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zhbevd_(const char *jobz, const char *uplo, const int *n, const int *kd, _Complex double *AB, const int *ldab, double *W, _Complex double *Z, const int *ldz, _Complex double *work, const int *lwork, double *rwork, const int *lrwork, int *iwork, const int *liwork, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment zhbevd_$address() {
        return zhbevd_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zhbevd_(const char *jobz, const char *uplo, const int *n, const int *kd, _Complex double *AB, const int *ldab, double *W, _Complex double *Z, const int *ldz, _Complex double *work, const int *lwork, double *rwork, const int *lrwork, int *iwork, const int *liwork, int *info, size_t, size_t)
     * }
     */
    public static void zhbevd_(MemorySegment jobz, MemorySegment uplo, MemorySegment n, MemorySegment kd, MemorySegment AB, MemorySegment ldab, MemorySegment W, MemorySegment Z, MemorySegment ldz, MemorySegment work, MemorySegment lwork, MemorySegment rwork, MemorySegment lrwork, MemorySegment iwork, MemorySegment liwork, MemorySegment info, long x16, long x17) {
        var mh$ = zhbevd_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zhbevd_", jobz, uplo, n, kd, AB, ldab, W, Z, ldz, work, lwork, rwork, lrwork, iwork, liwork, info, x16, x17);
            }
            mh$.invokeExact(jobz, uplo, n, kd, AB, ldab, W, Z, ldz, work, lwork, rwork, lrwork, iwork, liwork, info, x16, x17);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class chbevd_2stage_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("chbevd_2stage_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void chbevd_2stage_(const char *jobz, const char *uplo, const int *n, const int *kd, _Complex float *AB, const int *ldab, float *W, _Complex float *Z, const int *ldz, _Complex float *work, const int *lwork, float *rwork, const int *lrwork, int *iwork, const int *liwork, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor chbevd_2stage_$descriptor() {
        return chbevd_2stage_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void chbevd_2stage_(const char *jobz, const char *uplo, const int *n, const int *kd, _Complex float *AB, const int *ldab, float *W, _Complex float *Z, const int *ldz, _Complex float *work, const int *lwork, float *rwork, const int *lrwork, int *iwork, const int *liwork, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle chbevd_2stage_$handle() {
        return chbevd_2stage_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void chbevd_2stage_(const char *jobz, const char *uplo, const int *n, const int *kd, _Complex float *AB, const int *ldab, float *W, _Complex float *Z, const int *ldz, _Complex float *work, const int *lwork, float *rwork, const int *lrwork, int *iwork, const int *liwork, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment chbevd_2stage_$address() {
        return chbevd_2stage_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void chbevd_2stage_(const char *jobz, const char *uplo, const int *n, const int *kd, _Complex float *AB, const int *ldab, float *W, _Complex float *Z, const int *ldz, _Complex float *work, const int *lwork, float *rwork, const int *lrwork, int *iwork, const int *liwork, int *info, size_t, size_t)
     * }
     */
    public static void chbevd_2stage_(MemorySegment jobz, MemorySegment uplo, MemorySegment n, MemorySegment kd, MemorySegment AB, MemorySegment ldab, MemorySegment W, MemorySegment Z, MemorySegment ldz, MemorySegment work, MemorySegment lwork, MemorySegment rwork, MemorySegment lrwork, MemorySegment iwork, MemorySegment liwork, MemorySegment info, long x16, long x17) {
        var mh$ = chbevd_2stage_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("chbevd_2stage_", jobz, uplo, n, kd, AB, ldab, W, Z, ldz, work, lwork, rwork, lrwork, iwork, liwork, info, x16, x17);
            }
            mh$.invokeExact(jobz, uplo, n, kd, AB, ldab, W, Z, ldz, work, lwork, rwork, lrwork, iwork, liwork, info, x16, x17);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zhbevd_2stage_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("zhbevd_2stage_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zhbevd_2stage_(const char *jobz, const char *uplo, const int *n, const int *kd, _Complex double *AB, const int *ldab, double *W, _Complex double *Z, const int *ldz, _Complex double *work, const int *lwork, double *rwork, const int *lrwork, int *iwork, const int *liwork, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor zhbevd_2stage_$descriptor() {
        return zhbevd_2stage_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zhbevd_2stage_(const char *jobz, const char *uplo, const int *n, const int *kd, _Complex double *AB, const int *ldab, double *W, _Complex double *Z, const int *ldz, _Complex double *work, const int *lwork, double *rwork, const int *lrwork, int *iwork, const int *liwork, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle zhbevd_2stage_$handle() {
        return zhbevd_2stage_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zhbevd_2stage_(const char *jobz, const char *uplo, const int *n, const int *kd, _Complex double *AB, const int *ldab, double *W, _Complex double *Z, const int *ldz, _Complex double *work, const int *lwork, double *rwork, const int *lrwork, int *iwork, const int *liwork, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment zhbevd_2stage_$address() {
        return zhbevd_2stage_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zhbevd_2stage_(const char *jobz, const char *uplo, const int *n, const int *kd, _Complex double *AB, const int *ldab, double *W, _Complex double *Z, const int *ldz, _Complex double *work, const int *lwork, double *rwork, const int *lrwork, int *iwork, const int *liwork, int *info, size_t, size_t)
     * }
     */
    public static void zhbevd_2stage_(MemorySegment jobz, MemorySegment uplo, MemorySegment n, MemorySegment kd, MemorySegment AB, MemorySegment ldab, MemorySegment W, MemorySegment Z, MemorySegment ldz, MemorySegment work, MemorySegment lwork, MemorySegment rwork, MemorySegment lrwork, MemorySegment iwork, MemorySegment liwork, MemorySegment info, long x16, long x17) {
        var mh$ = zhbevd_2stage_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zhbevd_2stage_", jobz, uplo, n, kd, AB, ldab, W, Z, ldz, work, lwork, rwork, lrwork, iwork, liwork, info, x16, x17);
            }
            mh$.invokeExact(jobz, uplo, n, kd, AB, ldab, W, Z, ldz, work, lwork, rwork, lrwork, iwork, liwork, info, x16, x17);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class chbevx_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("chbevx_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void chbevx_(const char *jobz, const char *range, const char *uplo, const int *n, const int *kd, _Complex float *AB, const int *ldab, _Complex float *Q, const int *ldq, const float *vl, const float *vu, const int *il, const int *iu, const float *abstol, int *m, float *W, _Complex float *Z, const int *ldz, _Complex float *work, float *rwork, int *iwork, int *IFAIL, int *info, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor chbevx_$descriptor() {
        return chbevx_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void chbevx_(const char *jobz, const char *range, const char *uplo, const int *n, const int *kd, _Complex float *AB, const int *ldab, _Complex float *Q, const int *ldq, const float *vl, const float *vu, const int *il, const int *iu, const float *abstol, int *m, float *W, _Complex float *Z, const int *ldz, _Complex float *work, float *rwork, int *iwork, int *IFAIL, int *info, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle chbevx_$handle() {
        return chbevx_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void chbevx_(const char *jobz, const char *range, const char *uplo, const int *n, const int *kd, _Complex float *AB, const int *ldab, _Complex float *Q, const int *ldq, const float *vl, const float *vu, const int *il, const int *iu, const float *abstol, int *m, float *W, _Complex float *Z, const int *ldz, _Complex float *work, float *rwork, int *iwork, int *IFAIL, int *info, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment chbevx_$address() {
        return chbevx_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void chbevx_(const char *jobz, const char *range, const char *uplo, const int *n, const int *kd, _Complex float *AB, const int *ldab, _Complex float *Q, const int *ldq, const float *vl, const float *vu, const int *il, const int *iu, const float *abstol, int *m, float *W, _Complex float *Z, const int *ldz, _Complex float *work, float *rwork, int *iwork, int *IFAIL, int *info, size_t, size_t, size_t)
     * }
     */
    public static void chbevx_(MemorySegment jobz, MemorySegment range, MemorySegment uplo, MemorySegment n, MemorySegment kd, MemorySegment AB, MemorySegment ldab, MemorySegment Q, MemorySegment ldq, MemorySegment vl, MemorySegment vu, MemorySegment il, MemorySegment iu, MemorySegment abstol, MemorySegment m, MemorySegment W, MemorySegment Z, MemorySegment ldz, MemorySegment work, MemorySegment rwork, MemorySegment iwork, MemorySegment IFAIL, MemorySegment info, long x23, long x24, long x25) {
        var mh$ = chbevx_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("chbevx_", jobz, range, uplo, n, kd, AB, ldab, Q, ldq, vl, vu, il, iu, abstol, m, W, Z, ldz, work, rwork, iwork, IFAIL, info, x23, x24, x25);
            }
            mh$.invokeExact(jobz, range, uplo, n, kd, AB, ldab, Q, ldq, vl, vu, il, iu, abstol, m, W, Z, ldz, work, rwork, iwork, IFAIL, info, x23, x24, x25);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zhbevx_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("zhbevx_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zhbevx_(const char *jobz, const char *range, const char *uplo, const int *n, const int *kd, _Complex double *AB, const int *ldab, _Complex double *Q, const int *ldq, const double *vl, const double *vu, const int *il, const int *iu, const double *abstol, int *m, double *W, _Complex double *Z, const int *ldz, _Complex double *work, double *rwork, int *iwork, int *IFAIL, int *info, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor zhbevx_$descriptor() {
        return zhbevx_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zhbevx_(const char *jobz, const char *range, const char *uplo, const int *n, const int *kd, _Complex double *AB, const int *ldab, _Complex double *Q, const int *ldq, const double *vl, const double *vu, const int *il, const int *iu, const double *abstol, int *m, double *W, _Complex double *Z, const int *ldz, _Complex double *work, double *rwork, int *iwork, int *IFAIL, int *info, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle zhbevx_$handle() {
        return zhbevx_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zhbevx_(const char *jobz, const char *range, const char *uplo, const int *n, const int *kd, _Complex double *AB, const int *ldab, _Complex double *Q, const int *ldq, const double *vl, const double *vu, const int *il, const int *iu, const double *abstol, int *m, double *W, _Complex double *Z, const int *ldz, _Complex double *work, double *rwork, int *iwork, int *IFAIL, int *info, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment zhbevx_$address() {
        return zhbevx_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zhbevx_(const char *jobz, const char *range, const char *uplo, const int *n, const int *kd, _Complex double *AB, const int *ldab, _Complex double *Q, const int *ldq, const double *vl, const double *vu, const int *il, const int *iu, const double *abstol, int *m, double *W, _Complex double *Z, const int *ldz, _Complex double *work, double *rwork, int *iwork, int *IFAIL, int *info, size_t, size_t, size_t)
     * }
     */
    public static void zhbevx_(MemorySegment jobz, MemorySegment range, MemorySegment uplo, MemorySegment n, MemorySegment kd, MemorySegment AB, MemorySegment ldab, MemorySegment Q, MemorySegment ldq, MemorySegment vl, MemorySegment vu, MemorySegment il, MemorySegment iu, MemorySegment abstol, MemorySegment m, MemorySegment W, MemorySegment Z, MemorySegment ldz, MemorySegment work, MemorySegment rwork, MemorySegment iwork, MemorySegment IFAIL, MemorySegment info, long x23, long x24, long x25) {
        var mh$ = zhbevx_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zhbevx_", jobz, range, uplo, n, kd, AB, ldab, Q, ldq, vl, vu, il, iu, abstol, m, W, Z, ldz, work, rwork, iwork, IFAIL, info, x23, x24, x25);
            }
            mh$.invokeExact(jobz, range, uplo, n, kd, AB, ldab, Q, ldq, vl, vu, il, iu, abstol, m, W, Z, ldz, work, rwork, iwork, IFAIL, info, x23, x24, x25);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class chbevx_2stage_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("chbevx_2stage_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void chbevx_2stage_(const char *jobz, const char *range, const char *uplo, const int *n, const int *kd, _Complex float *AB, const int *ldab, _Complex float *Q, const int *ldq, const float *vl, const float *vu, const int *il, const int *iu, const float *abstol, int *m, float *W, _Complex float *Z, const int *ldz, _Complex float *work, const int *lwork, float *rwork, int *iwork, int *IFAIL, int *info, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor chbevx_2stage_$descriptor() {
        return chbevx_2stage_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void chbevx_2stage_(const char *jobz, const char *range, const char *uplo, const int *n, const int *kd, _Complex float *AB, const int *ldab, _Complex float *Q, const int *ldq, const float *vl, const float *vu, const int *il, const int *iu, const float *abstol, int *m, float *W, _Complex float *Z, const int *ldz, _Complex float *work, const int *lwork, float *rwork, int *iwork, int *IFAIL, int *info, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle chbevx_2stage_$handle() {
        return chbevx_2stage_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void chbevx_2stage_(const char *jobz, const char *range, const char *uplo, const int *n, const int *kd, _Complex float *AB, const int *ldab, _Complex float *Q, const int *ldq, const float *vl, const float *vu, const int *il, const int *iu, const float *abstol, int *m, float *W, _Complex float *Z, const int *ldz, _Complex float *work, const int *lwork, float *rwork, int *iwork, int *IFAIL, int *info, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment chbevx_2stage_$address() {
        return chbevx_2stage_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void chbevx_2stage_(const char *jobz, const char *range, const char *uplo, const int *n, const int *kd, _Complex float *AB, const int *ldab, _Complex float *Q, const int *ldq, const float *vl, const float *vu, const int *il, const int *iu, const float *abstol, int *m, float *W, _Complex float *Z, const int *ldz, _Complex float *work, const int *lwork, float *rwork, int *iwork, int *IFAIL, int *info, size_t, size_t, size_t)
     * }
     */
    public static void chbevx_2stage_(MemorySegment jobz, MemorySegment range, MemorySegment uplo, MemorySegment n, MemorySegment kd, MemorySegment AB, MemorySegment ldab, MemorySegment Q, MemorySegment ldq, MemorySegment vl, MemorySegment vu, MemorySegment il, MemorySegment iu, MemorySegment abstol, MemorySegment m, MemorySegment W, MemorySegment Z, MemorySegment ldz, MemorySegment work, MemorySegment lwork, MemorySegment rwork, MemorySegment iwork, MemorySegment IFAIL, MemorySegment info, long x24, long x25, long x26) {
        var mh$ = chbevx_2stage_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("chbevx_2stage_", jobz, range, uplo, n, kd, AB, ldab, Q, ldq, vl, vu, il, iu, abstol, m, W, Z, ldz, work, lwork, rwork, iwork, IFAIL, info, x24, x25, x26);
            }
            mh$.invokeExact(jobz, range, uplo, n, kd, AB, ldab, Q, ldq, vl, vu, il, iu, abstol, m, W, Z, ldz, work, lwork, rwork, iwork, IFAIL, info, x24, x25, x26);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zhbevx_2stage_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("zhbevx_2stage_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zhbevx_2stage_(const char *jobz, const char *range, const char *uplo, const int *n, const int *kd, _Complex double *AB, const int *ldab, _Complex double *Q, const int *ldq, const double *vl, const double *vu, const int *il, const int *iu, const double *abstol, int *m, double *W, _Complex double *Z, const int *ldz, _Complex double *work, const int *lwork, double *rwork, int *iwork, int *IFAIL, int *info, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor zhbevx_2stage_$descriptor() {
        return zhbevx_2stage_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zhbevx_2stage_(const char *jobz, const char *range, const char *uplo, const int *n, const int *kd, _Complex double *AB, const int *ldab, _Complex double *Q, const int *ldq, const double *vl, const double *vu, const int *il, const int *iu, const double *abstol, int *m, double *W, _Complex double *Z, const int *ldz, _Complex double *work, const int *lwork, double *rwork, int *iwork, int *IFAIL, int *info, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle zhbevx_2stage_$handle() {
        return zhbevx_2stage_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zhbevx_2stage_(const char *jobz, const char *range, const char *uplo, const int *n, const int *kd, _Complex double *AB, const int *ldab, _Complex double *Q, const int *ldq, const double *vl, const double *vu, const int *il, const int *iu, const double *abstol, int *m, double *W, _Complex double *Z, const int *ldz, _Complex double *work, const int *lwork, double *rwork, int *iwork, int *IFAIL, int *info, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment zhbevx_2stage_$address() {
        return zhbevx_2stage_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zhbevx_2stage_(const char *jobz, const char *range, const char *uplo, const int *n, const int *kd, _Complex double *AB, const int *ldab, _Complex double *Q, const int *ldq, const double *vl, const double *vu, const int *il, const int *iu, const double *abstol, int *m, double *W, _Complex double *Z, const int *ldz, _Complex double *work, const int *lwork, double *rwork, int *iwork, int *IFAIL, int *info, size_t, size_t, size_t)
     * }
     */
    public static void zhbevx_2stage_(MemorySegment jobz, MemorySegment range, MemorySegment uplo, MemorySegment n, MemorySegment kd, MemorySegment AB, MemorySegment ldab, MemorySegment Q, MemorySegment ldq, MemorySegment vl, MemorySegment vu, MemorySegment il, MemorySegment iu, MemorySegment abstol, MemorySegment m, MemorySegment W, MemorySegment Z, MemorySegment ldz, MemorySegment work, MemorySegment lwork, MemorySegment rwork, MemorySegment iwork, MemorySegment IFAIL, MemorySegment info, long x24, long x25, long x26) {
        var mh$ = zhbevx_2stage_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zhbevx_2stage_", jobz, range, uplo, n, kd, AB, ldab, Q, ldq, vl, vu, il, iu, abstol, m, W, Z, ldz, work, lwork, rwork, iwork, IFAIL, info, x24, x25, x26);
            }
            mh$.invokeExact(jobz, range, uplo, n, kd, AB, ldab, Q, ldq, vl, vu, il, iu, abstol, m, W, Z, ldz, work, lwork, rwork, iwork, IFAIL, info, x24, x25, x26);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class chbgst_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("chbgst_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void chbgst_(const char *vect, const char *uplo, const int *n, const int *ka, const int *kb, _Complex float *AB, const int *ldab, const _Complex float *BB, const int *ldbb, _Complex float *X, const int *ldx, _Complex float *work, float *rwork, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor chbgst_$descriptor() {
        return chbgst_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void chbgst_(const char *vect, const char *uplo, const int *n, const int *ka, const int *kb, _Complex float *AB, const int *ldab, const _Complex float *BB, const int *ldbb, _Complex float *X, const int *ldx, _Complex float *work, float *rwork, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle chbgst_$handle() {
        return chbgst_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void chbgst_(const char *vect, const char *uplo, const int *n, const int *ka, const int *kb, _Complex float *AB, const int *ldab, const _Complex float *BB, const int *ldbb, _Complex float *X, const int *ldx, _Complex float *work, float *rwork, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment chbgst_$address() {
        return chbgst_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void chbgst_(const char *vect, const char *uplo, const int *n, const int *ka, const int *kb, _Complex float *AB, const int *ldab, const _Complex float *BB, const int *ldbb, _Complex float *X, const int *ldx, _Complex float *work, float *rwork, int *info, size_t, size_t)
     * }
     */
    public static void chbgst_(MemorySegment vect, MemorySegment uplo, MemorySegment n, MemorySegment ka, MemorySegment kb, MemorySegment AB, MemorySegment ldab, MemorySegment BB, MemorySegment ldbb, MemorySegment X, MemorySegment ldx, MemorySegment work, MemorySegment rwork, MemorySegment info, long x14, long x15) {
        var mh$ = chbgst_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("chbgst_", vect, uplo, n, ka, kb, AB, ldab, BB, ldbb, X, ldx, work, rwork, info, x14, x15);
            }
            mh$.invokeExact(vect, uplo, n, ka, kb, AB, ldab, BB, ldbb, X, ldx, work, rwork, info, x14, x15);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zhbgst_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("zhbgst_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zhbgst_(const char *vect, const char *uplo, const int *n, const int *ka, const int *kb, _Complex double *AB, const int *ldab, const _Complex double *BB, const int *ldbb, _Complex double *X, const int *ldx, _Complex double *work, double *rwork, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor zhbgst_$descriptor() {
        return zhbgst_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zhbgst_(const char *vect, const char *uplo, const int *n, const int *ka, const int *kb, _Complex double *AB, const int *ldab, const _Complex double *BB, const int *ldbb, _Complex double *X, const int *ldx, _Complex double *work, double *rwork, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle zhbgst_$handle() {
        return zhbgst_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zhbgst_(const char *vect, const char *uplo, const int *n, const int *ka, const int *kb, _Complex double *AB, const int *ldab, const _Complex double *BB, const int *ldbb, _Complex double *X, const int *ldx, _Complex double *work, double *rwork, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment zhbgst_$address() {
        return zhbgst_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zhbgst_(const char *vect, const char *uplo, const int *n, const int *ka, const int *kb, _Complex double *AB, const int *ldab, const _Complex double *BB, const int *ldbb, _Complex double *X, const int *ldx, _Complex double *work, double *rwork, int *info, size_t, size_t)
     * }
     */
    public static void zhbgst_(MemorySegment vect, MemorySegment uplo, MemorySegment n, MemorySegment ka, MemorySegment kb, MemorySegment AB, MemorySegment ldab, MemorySegment BB, MemorySegment ldbb, MemorySegment X, MemorySegment ldx, MemorySegment work, MemorySegment rwork, MemorySegment info, long x14, long x15) {
        var mh$ = zhbgst_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zhbgst_", vect, uplo, n, ka, kb, AB, ldab, BB, ldbb, X, ldx, work, rwork, info, x14, x15);
            }
            mh$.invokeExact(vect, uplo, n, ka, kb, AB, ldab, BB, ldbb, X, ldx, work, rwork, info, x14, x15);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class chbgv_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("chbgv_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void chbgv_(const char *jobz, const char *uplo, const int *n, const int *ka, const int *kb, _Complex float *AB, const int *ldab, _Complex float *BB, const int *ldbb, float *W, _Complex float *Z, const int *ldz, _Complex float *work, float *rwork, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor chbgv_$descriptor() {
        return chbgv_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void chbgv_(const char *jobz, const char *uplo, const int *n, const int *ka, const int *kb, _Complex float *AB, const int *ldab, _Complex float *BB, const int *ldbb, float *W, _Complex float *Z, const int *ldz, _Complex float *work, float *rwork, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle chbgv_$handle() {
        return chbgv_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void chbgv_(const char *jobz, const char *uplo, const int *n, const int *ka, const int *kb, _Complex float *AB, const int *ldab, _Complex float *BB, const int *ldbb, float *W, _Complex float *Z, const int *ldz, _Complex float *work, float *rwork, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment chbgv_$address() {
        return chbgv_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void chbgv_(const char *jobz, const char *uplo, const int *n, const int *ka, const int *kb, _Complex float *AB, const int *ldab, _Complex float *BB, const int *ldbb, float *W, _Complex float *Z, const int *ldz, _Complex float *work, float *rwork, int *info, size_t, size_t)
     * }
     */
    public static void chbgv_(MemorySegment jobz, MemorySegment uplo, MemorySegment n, MemorySegment ka, MemorySegment kb, MemorySegment AB, MemorySegment ldab, MemorySegment BB, MemorySegment ldbb, MemorySegment W, MemorySegment Z, MemorySegment ldz, MemorySegment work, MemorySegment rwork, MemorySegment info, long x15, long x16) {
        var mh$ = chbgv_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("chbgv_", jobz, uplo, n, ka, kb, AB, ldab, BB, ldbb, W, Z, ldz, work, rwork, info, x15, x16);
            }
            mh$.invokeExact(jobz, uplo, n, ka, kb, AB, ldab, BB, ldbb, W, Z, ldz, work, rwork, info, x15, x16);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zhbgv_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("zhbgv_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zhbgv_(const char *jobz, const char *uplo, const int *n, const int *ka, const int *kb, _Complex double *AB, const int *ldab, _Complex double *BB, const int *ldbb, double *W, _Complex double *Z, const int *ldz, _Complex double *work, double *rwork, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor zhbgv_$descriptor() {
        return zhbgv_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zhbgv_(const char *jobz, const char *uplo, const int *n, const int *ka, const int *kb, _Complex double *AB, const int *ldab, _Complex double *BB, const int *ldbb, double *W, _Complex double *Z, const int *ldz, _Complex double *work, double *rwork, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle zhbgv_$handle() {
        return zhbgv_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zhbgv_(const char *jobz, const char *uplo, const int *n, const int *ka, const int *kb, _Complex double *AB, const int *ldab, _Complex double *BB, const int *ldbb, double *W, _Complex double *Z, const int *ldz, _Complex double *work, double *rwork, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment zhbgv_$address() {
        return zhbgv_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zhbgv_(const char *jobz, const char *uplo, const int *n, const int *ka, const int *kb, _Complex double *AB, const int *ldab, _Complex double *BB, const int *ldbb, double *W, _Complex double *Z, const int *ldz, _Complex double *work, double *rwork, int *info, size_t, size_t)
     * }
     */
    public static void zhbgv_(MemorySegment jobz, MemorySegment uplo, MemorySegment n, MemorySegment ka, MemorySegment kb, MemorySegment AB, MemorySegment ldab, MemorySegment BB, MemorySegment ldbb, MemorySegment W, MemorySegment Z, MemorySegment ldz, MemorySegment work, MemorySegment rwork, MemorySegment info, long x15, long x16) {
        var mh$ = zhbgv_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zhbgv_", jobz, uplo, n, ka, kb, AB, ldab, BB, ldbb, W, Z, ldz, work, rwork, info, x15, x16);
            }
            mh$.invokeExact(jobz, uplo, n, ka, kb, AB, ldab, BB, ldbb, W, Z, ldz, work, rwork, info, x15, x16);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class chbgvd_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("chbgvd_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void chbgvd_(const char *jobz, const char *uplo, const int *n, const int *ka, const int *kb, _Complex float *AB, const int *ldab, _Complex float *BB, const int *ldbb, float *W, _Complex float *Z, const int *ldz, _Complex float *work, const int *lwork, float *rwork, const int *lrwork, int *iwork, const int *liwork, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor chbgvd_$descriptor() {
        return chbgvd_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void chbgvd_(const char *jobz, const char *uplo, const int *n, const int *ka, const int *kb, _Complex float *AB, const int *ldab, _Complex float *BB, const int *ldbb, float *W, _Complex float *Z, const int *ldz, _Complex float *work, const int *lwork, float *rwork, const int *lrwork, int *iwork, const int *liwork, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle chbgvd_$handle() {
        return chbgvd_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void chbgvd_(const char *jobz, const char *uplo, const int *n, const int *ka, const int *kb, _Complex float *AB, const int *ldab, _Complex float *BB, const int *ldbb, float *W, _Complex float *Z, const int *ldz, _Complex float *work, const int *lwork, float *rwork, const int *lrwork, int *iwork, const int *liwork, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment chbgvd_$address() {
        return chbgvd_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void chbgvd_(const char *jobz, const char *uplo, const int *n, const int *ka, const int *kb, _Complex float *AB, const int *ldab, _Complex float *BB, const int *ldbb, float *W, _Complex float *Z, const int *ldz, _Complex float *work, const int *lwork, float *rwork, const int *lrwork, int *iwork, const int *liwork, int *info, size_t, size_t)
     * }
     */
    public static void chbgvd_(MemorySegment jobz, MemorySegment uplo, MemorySegment n, MemorySegment ka, MemorySegment kb, MemorySegment AB, MemorySegment ldab, MemorySegment BB, MemorySegment ldbb, MemorySegment W, MemorySegment Z, MemorySegment ldz, MemorySegment work, MemorySegment lwork, MemorySegment rwork, MemorySegment lrwork, MemorySegment iwork, MemorySegment liwork, MemorySegment info, long x19, long x20) {
        var mh$ = chbgvd_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("chbgvd_", jobz, uplo, n, ka, kb, AB, ldab, BB, ldbb, W, Z, ldz, work, lwork, rwork, lrwork, iwork, liwork, info, x19, x20);
            }
            mh$.invokeExact(jobz, uplo, n, ka, kb, AB, ldab, BB, ldbb, W, Z, ldz, work, lwork, rwork, lrwork, iwork, liwork, info, x19, x20);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zhbgvd_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("zhbgvd_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zhbgvd_(const char *jobz, const char *uplo, const int *n, const int *ka, const int *kb, _Complex double *AB, const int *ldab, _Complex double *BB, const int *ldbb, double *W, _Complex double *Z, const int *ldz, _Complex double *work, const int *lwork, double *rwork, const int *lrwork, int *iwork, const int *liwork, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor zhbgvd_$descriptor() {
        return zhbgvd_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zhbgvd_(const char *jobz, const char *uplo, const int *n, const int *ka, const int *kb, _Complex double *AB, const int *ldab, _Complex double *BB, const int *ldbb, double *W, _Complex double *Z, const int *ldz, _Complex double *work, const int *lwork, double *rwork, const int *lrwork, int *iwork, const int *liwork, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle zhbgvd_$handle() {
        return zhbgvd_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zhbgvd_(const char *jobz, const char *uplo, const int *n, const int *ka, const int *kb, _Complex double *AB, const int *ldab, _Complex double *BB, const int *ldbb, double *W, _Complex double *Z, const int *ldz, _Complex double *work, const int *lwork, double *rwork, const int *lrwork, int *iwork, const int *liwork, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment zhbgvd_$address() {
        return zhbgvd_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zhbgvd_(const char *jobz, const char *uplo, const int *n, const int *ka, const int *kb, _Complex double *AB, const int *ldab, _Complex double *BB, const int *ldbb, double *W, _Complex double *Z, const int *ldz, _Complex double *work, const int *lwork, double *rwork, const int *lrwork, int *iwork, const int *liwork, int *info, size_t, size_t)
     * }
     */
    public static void zhbgvd_(MemorySegment jobz, MemorySegment uplo, MemorySegment n, MemorySegment ka, MemorySegment kb, MemorySegment AB, MemorySegment ldab, MemorySegment BB, MemorySegment ldbb, MemorySegment W, MemorySegment Z, MemorySegment ldz, MemorySegment work, MemorySegment lwork, MemorySegment rwork, MemorySegment lrwork, MemorySegment iwork, MemorySegment liwork, MemorySegment info, long x19, long x20) {
        var mh$ = zhbgvd_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zhbgvd_", jobz, uplo, n, ka, kb, AB, ldab, BB, ldbb, W, Z, ldz, work, lwork, rwork, lrwork, iwork, liwork, info, x19, x20);
            }
            mh$.invokeExact(jobz, uplo, n, ka, kb, AB, ldab, BB, ldbb, W, Z, ldz, work, lwork, rwork, lrwork, iwork, liwork, info, x19, x20);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class chbgvx_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("chbgvx_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void chbgvx_(const char *jobz, const char *range, const char *uplo, const int *n, const int *ka, const int *kb, _Complex float *AB, const int *ldab, _Complex float *BB, const int *ldbb, _Complex float *Q, const int *ldq, const float *vl, const float *vu, const int *il, const int *iu, const float *abstol, int *m, float *W, _Complex float *Z, const int *ldz, _Complex float *work, float *rwork, int *iwork, int *IFAIL, int *info, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor chbgvx_$descriptor() {
        return chbgvx_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void chbgvx_(const char *jobz, const char *range, const char *uplo, const int *n, const int *ka, const int *kb, _Complex float *AB, const int *ldab, _Complex float *BB, const int *ldbb, _Complex float *Q, const int *ldq, const float *vl, const float *vu, const int *il, const int *iu, const float *abstol, int *m, float *W, _Complex float *Z, const int *ldz, _Complex float *work, float *rwork, int *iwork, int *IFAIL, int *info, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle chbgvx_$handle() {
        return chbgvx_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void chbgvx_(const char *jobz, const char *range, const char *uplo, const int *n, const int *ka, const int *kb, _Complex float *AB, const int *ldab, _Complex float *BB, const int *ldbb, _Complex float *Q, const int *ldq, const float *vl, const float *vu, const int *il, const int *iu, const float *abstol, int *m, float *W, _Complex float *Z, const int *ldz, _Complex float *work, float *rwork, int *iwork, int *IFAIL, int *info, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment chbgvx_$address() {
        return chbgvx_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void chbgvx_(const char *jobz, const char *range, const char *uplo, const int *n, const int *ka, const int *kb, _Complex float *AB, const int *ldab, _Complex float *BB, const int *ldbb, _Complex float *Q, const int *ldq, const float *vl, const float *vu, const int *il, const int *iu, const float *abstol, int *m, float *W, _Complex float *Z, const int *ldz, _Complex float *work, float *rwork, int *iwork, int *IFAIL, int *info, size_t, size_t, size_t)
     * }
     */
    public static void chbgvx_(MemorySegment jobz, MemorySegment range, MemorySegment uplo, MemorySegment n, MemorySegment ka, MemorySegment kb, MemorySegment AB, MemorySegment ldab, MemorySegment BB, MemorySegment ldbb, MemorySegment Q, MemorySegment ldq, MemorySegment vl, MemorySegment vu, MemorySegment il, MemorySegment iu, MemorySegment abstol, MemorySegment m, MemorySegment W, MemorySegment Z, MemorySegment ldz, MemorySegment work, MemorySegment rwork, MemorySegment iwork, MemorySegment IFAIL, MemorySegment info, long x26, long x27, long x28) {
        var mh$ = chbgvx_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("chbgvx_", jobz, range, uplo, n, ka, kb, AB, ldab, BB, ldbb, Q, ldq, vl, vu, il, iu, abstol, m, W, Z, ldz, work, rwork, iwork, IFAIL, info, x26, x27, x28);
            }
            mh$.invokeExact(jobz, range, uplo, n, ka, kb, AB, ldab, BB, ldbb, Q, ldq, vl, vu, il, iu, abstol, m, W, Z, ldz, work, rwork, iwork, IFAIL, info, x26, x27, x28);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zhbgvx_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("zhbgvx_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zhbgvx_(const char *jobz, const char *range, const char *uplo, const int *n, const int *ka, const int *kb, _Complex double *AB, const int *ldab, _Complex double *BB, const int *ldbb, _Complex double *Q, const int *ldq, const double *vl, const double *vu, const int *il, const int *iu, const double *abstol, int *m, double *W, _Complex double *Z, const int *ldz, _Complex double *work, double *rwork, int *iwork, int *IFAIL, int *info, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor zhbgvx_$descriptor() {
        return zhbgvx_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zhbgvx_(const char *jobz, const char *range, const char *uplo, const int *n, const int *ka, const int *kb, _Complex double *AB, const int *ldab, _Complex double *BB, const int *ldbb, _Complex double *Q, const int *ldq, const double *vl, const double *vu, const int *il, const int *iu, const double *abstol, int *m, double *W, _Complex double *Z, const int *ldz, _Complex double *work, double *rwork, int *iwork, int *IFAIL, int *info, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle zhbgvx_$handle() {
        return zhbgvx_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zhbgvx_(const char *jobz, const char *range, const char *uplo, const int *n, const int *ka, const int *kb, _Complex double *AB, const int *ldab, _Complex double *BB, const int *ldbb, _Complex double *Q, const int *ldq, const double *vl, const double *vu, const int *il, const int *iu, const double *abstol, int *m, double *W, _Complex double *Z, const int *ldz, _Complex double *work, double *rwork, int *iwork, int *IFAIL, int *info, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment zhbgvx_$address() {
        return zhbgvx_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zhbgvx_(const char *jobz, const char *range, const char *uplo, const int *n, const int *ka, const int *kb, _Complex double *AB, const int *ldab, _Complex double *BB, const int *ldbb, _Complex double *Q, const int *ldq, const double *vl, const double *vu, const int *il, const int *iu, const double *abstol, int *m, double *W, _Complex double *Z, const int *ldz, _Complex double *work, double *rwork, int *iwork, int *IFAIL, int *info, size_t, size_t, size_t)
     * }
     */
    public static void zhbgvx_(MemorySegment jobz, MemorySegment range, MemorySegment uplo, MemorySegment n, MemorySegment ka, MemorySegment kb, MemorySegment AB, MemorySegment ldab, MemorySegment BB, MemorySegment ldbb, MemorySegment Q, MemorySegment ldq, MemorySegment vl, MemorySegment vu, MemorySegment il, MemorySegment iu, MemorySegment abstol, MemorySegment m, MemorySegment W, MemorySegment Z, MemorySegment ldz, MemorySegment work, MemorySegment rwork, MemorySegment iwork, MemorySegment IFAIL, MemorySegment info, long x26, long x27, long x28) {
        var mh$ = zhbgvx_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zhbgvx_", jobz, range, uplo, n, ka, kb, AB, ldab, BB, ldbb, Q, ldq, vl, vu, il, iu, abstol, m, W, Z, ldz, work, rwork, iwork, IFAIL, info, x26, x27, x28);
            }
            mh$.invokeExact(jobz, range, uplo, n, ka, kb, AB, ldab, BB, ldbb, Q, ldq, vl, vu, il, iu, abstol, m, W, Z, ldz, work, rwork, iwork, IFAIL, info, x26, x27, x28);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class chbtrd_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("chbtrd_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void chbtrd_(const char *vect, const char *uplo, const int *n, const int *kd, _Complex float *AB, const int *ldab, float *D, float *E, _Complex float *Q, const int *ldq, _Complex float *work, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor chbtrd_$descriptor() {
        return chbtrd_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void chbtrd_(const char *vect, const char *uplo, const int *n, const int *kd, _Complex float *AB, const int *ldab, float *D, float *E, _Complex float *Q, const int *ldq, _Complex float *work, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle chbtrd_$handle() {
        return chbtrd_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void chbtrd_(const char *vect, const char *uplo, const int *n, const int *kd, _Complex float *AB, const int *ldab, float *D, float *E, _Complex float *Q, const int *ldq, _Complex float *work, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment chbtrd_$address() {
        return chbtrd_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void chbtrd_(const char *vect, const char *uplo, const int *n, const int *kd, _Complex float *AB, const int *ldab, float *D, float *E, _Complex float *Q, const int *ldq, _Complex float *work, int *info, size_t, size_t)
     * }
     */
    public static void chbtrd_(MemorySegment vect, MemorySegment uplo, MemorySegment n, MemorySegment kd, MemorySegment AB, MemorySegment ldab, MemorySegment D, MemorySegment E, MemorySegment Q, MemorySegment ldq, MemorySegment work, MemorySegment info, long x12, long x13) {
        var mh$ = chbtrd_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("chbtrd_", vect, uplo, n, kd, AB, ldab, D, E, Q, ldq, work, info, x12, x13);
            }
            mh$.invokeExact(vect, uplo, n, kd, AB, ldab, D, E, Q, ldq, work, info, x12, x13);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zhbtrd_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("zhbtrd_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zhbtrd_(const char *vect, const char *uplo, const int *n, const int *kd, _Complex double *AB, const int *ldab, double *D, double *E, _Complex double *Q, const int *ldq, _Complex double *work, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor zhbtrd_$descriptor() {
        return zhbtrd_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zhbtrd_(const char *vect, const char *uplo, const int *n, const int *kd, _Complex double *AB, const int *ldab, double *D, double *E, _Complex double *Q, const int *ldq, _Complex double *work, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle zhbtrd_$handle() {
        return zhbtrd_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zhbtrd_(const char *vect, const char *uplo, const int *n, const int *kd, _Complex double *AB, const int *ldab, double *D, double *E, _Complex double *Q, const int *ldq, _Complex double *work, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment zhbtrd_$address() {
        return zhbtrd_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zhbtrd_(const char *vect, const char *uplo, const int *n, const int *kd, _Complex double *AB, const int *ldab, double *D, double *E, _Complex double *Q, const int *ldq, _Complex double *work, int *info, size_t, size_t)
     * }
     */
    public static void zhbtrd_(MemorySegment vect, MemorySegment uplo, MemorySegment n, MemorySegment kd, MemorySegment AB, MemorySegment ldab, MemorySegment D, MemorySegment E, MemorySegment Q, MemorySegment ldq, MemorySegment work, MemorySegment info, long x12, long x13) {
        var mh$ = zhbtrd_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zhbtrd_", vect, uplo, n, kd, AB, ldab, D, E, Q, ldq, work, info, x12, x13);
            }
            mh$.invokeExact(vect, uplo, n, kd, AB, ldab, D, E, Q, ldq, work, info, x12, x13);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class checon_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("checon_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void checon_(const char *uplo, const int *n, const _Complex float *A, const int *lda, const int *ipiv, const float *anorm, float *rcond, _Complex float *work, int *info, size_t)
     * }
     */
    public static FunctionDescriptor checon_$descriptor() {
        return checon_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void checon_(const char *uplo, const int *n, const _Complex float *A, const int *lda, const int *ipiv, const float *anorm, float *rcond, _Complex float *work, int *info, size_t)
     * }
     */
    public static MethodHandle checon_$handle() {
        return checon_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void checon_(const char *uplo, const int *n, const _Complex float *A, const int *lda, const int *ipiv, const float *anorm, float *rcond, _Complex float *work, int *info, size_t)
     * }
     */
    public static MemorySegment checon_$address() {
        return checon_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void checon_(const char *uplo, const int *n, const _Complex float *A, const int *lda, const int *ipiv, const float *anorm, float *rcond, _Complex float *work, int *info, size_t)
     * }
     */
    public static void checon_(MemorySegment uplo, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment ipiv, MemorySegment anorm, MemorySegment rcond, MemorySegment work, MemorySegment info, long x9) {
        var mh$ = checon_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("checon_", uplo, n, A, lda, ipiv, anorm, rcond, work, info, x9);
            }
            mh$.invokeExact(uplo, n, A, lda, ipiv, anorm, rcond, work, info, x9);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zhecon_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("zhecon_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zhecon_(const char *uplo, const int *n, const _Complex double *A, const int *lda, const int *ipiv, const double *anorm, double *rcond, _Complex double *work, int *info, size_t)
     * }
     */
    public static FunctionDescriptor zhecon_$descriptor() {
        return zhecon_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zhecon_(const char *uplo, const int *n, const _Complex double *A, const int *lda, const int *ipiv, const double *anorm, double *rcond, _Complex double *work, int *info, size_t)
     * }
     */
    public static MethodHandle zhecon_$handle() {
        return zhecon_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zhecon_(const char *uplo, const int *n, const _Complex double *A, const int *lda, const int *ipiv, const double *anorm, double *rcond, _Complex double *work, int *info, size_t)
     * }
     */
    public static MemorySegment zhecon_$address() {
        return zhecon_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zhecon_(const char *uplo, const int *n, const _Complex double *A, const int *lda, const int *ipiv, const double *anorm, double *rcond, _Complex double *work, int *info, size_t)
     * }
     */
    public static void zhecon_(MemorySegment uplo, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment ipiv, MemorySegment anorm, MemorySegment rcond, MemorySegment work, MemorySegment info, long x9) {
        var mh$ = zhecon_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zhecon_", uplo, n, A, lda, ipiv, anorm, rcond, work, info, x9);
            }
            mh$.invokeExact(uplo, n, A, lda, ipiv, anorm, rcond, work, info, x9);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class checon_3_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("checon_3_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void checon_3_(const char *uplo, const int *n, const _Complex float *A, const int *lda, const _Complex float *E, const int *ipiv, const float *anorm, float *rcond, _Complex float *work, int *info, size_t)
     * }
     */
    public static FunctionDescriptor checon_3_$descriptor() {
        return checon_3_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void checon_3_(const char *uplo, const int *n, const _Complex float *A, const int *lda, const _Complex float *E, const int *ipiv, const float *anorm, float *rcond, _Complex float *work, int *info, size_t)
     * }
     */
    public static MethodHandle checon_3_$handle() {
        return checon_3_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void checon_3_(const char *uplo, const int *n, const _Complex float *A, const int *lda, const _Complex float *E, const int *ipiv, const float *anorm, float *rcond, _Complex float *work, int *info, size_t)
     * }
     */
    public static MemorySegment checon_3_$address() {
        return checon_3_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void checon_3_(const char *uplo, const int *n, const _Complex float *A, const int *lda, const _Complex float *E, const int *ipiv, const float *anorm, float *rcond, _Complex float *work, int *info, size_t)
     * }
     */
    public static void checon_3_(MemorySegment uplo, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment E, MemorySegment ipiv, MemorySegment anorm, MemorySegment rcond, MemorySegment work, MemorySegment info, long x10) {
        var mh$ = checon_3_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("checon_3_", uplo, n, A, lda, E, ipiv, anorm, rcond, work, info, x10);
            }
            mh$.invokeExact(uplo, n, A, lda, E, ipiv, anorm, rcond, work, info, x10);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zhecon_3_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("zhecon_3_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zhecon_3_(const char *uplo, const int *n, const _Complex double *A, const int *lda, const _Complex double *E, const int *ipiv, const double *anorm, double *rcond, _Complex double *work, int *info, size_t)
     * }
     */
    public static FunctionDescriptor zhecon_3_$descriptor() {
        return zhecon_3_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zhecon_3_(const char *uplo, const int *n, const _Complex double *A, const int *lda, const _Complex double *E, const int *ipiv, const double *anorm, double *rcond, _Complex double *work, int *info, size_t)
     * }
     */
    public static MethodHandle zhecon_3_$handle() {
        return zhecon_3_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zhecon_3_(const char *uplo, const int *n, const _Complex double *A, const int *lda, const _Complex double *E, const int *ipiv, const double *anorm, double *rcond, _Complex double *work, int *info, size_t)
     * }
     */
    public static MemorySegment zhecon_3_$address() {
        return zhecon_3_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zhecon_3_(const char *uplo, const int *n, const _Complex double *A, const int *lda, const _Complex double *E, const int *ipiv, const double *anorm, double *rcond, _Complex double *work, int *info, size_t)
     * }
     */
    public static void zhecon_3_(MemorySegment uplo, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment E, MemorySegment ipiv, MemorySegment anorm, MemorySegment rcond, MemorySegment work, MemorySegment info, long x10) {
        var mh$ = zhecon_3_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zhecon_3_", uplo, n, A, lda, E, ipiv, anorm, rcond, work, info, x10);
            }
            mh$.invokeExact(uplo, n, A, lda, E, ipiv, anorm, rcond, work, info, x10);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cheequb_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cheequb_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cheequb_(const char *uplo, const int *n, const _Complex float *A, const int *lda, float *S, float *scond, float *amax, _Complex float *work, int *info, size_t)
     * }
     */
    public static FunctionDescriptor cheequb_$descriptor() {
        return cheequb_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cheequb_(const char *uplo, const int *n, const _Complex float *A, const int *lda, float *S, float *scond, float *amax, _Complex float *work, int *info, size_t)
     * }
     */
    public static MethodHandle cheequb_$handle() {
        return cheequb_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cheequb_(const char *uplo, const int *n, const _Complex float *A, const int *lda, float *S, float *scond, float *amax, _Complex float *work, int *info, size_t)
     * }
     */
    public static MemorySegment cheequb_$address() {
        return cheequb_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cheequb_(const char *uplo, const int *n, const _Complex float *A, const int *lda, float *S, float *scond, float *amax, _Complex float *work, int *info, size_t)
     * }
     */
    public static void cheequb_(MemorySegment uplo, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment S, MemorySegment scond, MemorySegment amax, MemorySegment work, MemorySegment info, long x9) {
        var mh$ = cheequb_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cheequb_", uplo, n, A, lda, S, scond, amax, work, info, x9);
            }
            mh$.invokeExact(uplo, n, A, lda, S, scond, amax, work, info, x9);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zheequb_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("zheequb_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zheequb_(const char *uplo, const int *n, const _Complex double *A, const int *lda, double *S, double *scond, double *amax, _Complex double *work, int *info, size_t)
     * }
     */
    public static FunctionDescriptor zheequb_$descriptor() {
        return zheequb_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zheequb_(const char *uplo, const int *n, const _Complex double *A, const int *lda, double *S, double *scond, double *amax, _Complex double *work, int *info, size_t)
     * }
     */
    public static MethodHandle zheequb_$handle() {
        return zheequb_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zheequb_(const char *uplo, const int *n, const _Complex double *A, const int *lda, double *S, double *scond, double *amax, _Complex double *work, int *info, size_t)
     * }
     */
    public static MemorySegment zheequb_$address() {
        return zheequb_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zheequb_(const char *uplo, const int *n, const _Complex double *A, const int *lda, double *S, double *scond, double *amax, _Complex double *work, int *info, size_t)
     * }
     */
    public static void zheequb_(MemorySegment uplo, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment S, MemorySegment scond, MemorySegment amax, MemorySegment work, MemorySegment info, long x9) {
        var mh$ = zheequb_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zheequb_", uplo, n, A, lda, S, scond, amax, work, info, x9);
            }
            mh$.invokeExact(uplo, n, A, lda, S, scond, amax, work, info, x9);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cheev_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cheev_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cheev_(const char *jobz, const char *uplo, const int *n, _Complex float *A, const int *lda, float *W, _Complex float *work, const int *lwork, float *rwork, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor cheev_$descriptor() {
        return cheev_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cheev_(const char *jobz, const char *uplo, const int *n, _Complex float *A, const int *lda, float *W, _Complex float *work, const int *lwork, float *rwork, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle cheev_$handle() {
        return cheev_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cheev_(const char *jobz, const char *uplo, const int *n, _Complex float *A, const int *lda, float *W, _Complex float *work, const int *lwork, float *rwork, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment cheev_$address() {
        return cheev_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cheev_(const char *jobz, const char *uplo, const int *n, _Complex float *A, const int *lda, float *W, _Complex float *work, const int *lwork, float *rwork, int *info, size_t, size_t)
     * }
     */
    public static void cheev_(MemorySegment jobz, MemorySegment uplo, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment W, MemorySegment work, MemorySegment lwork, MemorySegment rwork, MemorySegment info, long x10, long x11) {
        var mh$ = cheev_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cheev_", jobz, uplo, n, A, lda, W, work, lwork, rwork, info, x10, x11);
            }
            mh$.invokeExact(jobz, uplo, n, A, lda, W, work, lwork, rwork, info, x10, x11);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zheev_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("zheev_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zheev_(const char *jobz, const char *uplo, const int *n, _Complex double *A, const int *lda, double *W, _Complex double *work, const int *lwork, double *rwork, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor zheev_$descriptor() {
        return zheev_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zheev_(const char *jobz, const char *uplo, const int *n, _Complex double *A, const int *lda, double *W, _Complex double *work, const int *lwork, double *rwork, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle zheev_$handle() {
        return zheev_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zheev_(const char *jobz, const char *uplo, const int *n, _Complex double *A, const int *lda, double *W, _Complex double *work, const int *lwork, double *rwork, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment zheev_$address() {
        return zheev_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zheev_(const char *jobz, const char *uplo, const int *n, _Complex double *A, const int *lda, double *W, _Complex double *work, const int *lwork, double *rwork, int *info, size_t, size_t)
     * }
     */
    public static void zheev_(MemorySegment jobz, MemorySegment uplo, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment W, MemorySegment work, MemorySegment lwork, MemorySegment rwork, MemorySegment info, long x10, long x11) {
        var mh$ = zheev_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zheev_", jobz, uplo, n, A, lda, W, work, lwork, rwork, info, x10, x11);
            }
            mh$.invokeExact(jobz, uplo, n, A, lda, W, work, lwork, rwork, info, x10, x11);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cheev_2stage_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cheev_2stage_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cheev_2stage_(const char *jobz, const char *uplo, const int *n, _Complex float *A, const int *lda, float *W, _Complex float *work, const int *lwork, float *rwork, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor cheev_2stage_$descriptor() {
        return cheev_2stage_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cheev_2stage_(const char *jobz, const char *uplo, const int *n, _Complex float *A, const int *lda, float *W, _Complex float *work, const int *lwork, float *rwork, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle cheev_2stage_$handle() {
        return cheev_2stage_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cheev_2stage_(const char *jobz, const char *uplo, const int *n, _Complex float *A, const int *lda, float *W, _Complex float *work, const int *lwork, float *rwork, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment cheev_2stage_$address() {
        return cheev_2stage_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cheev_2stage_(const char *jobz, const char *uplo, const int *n, _Complex float *A, const int *lda, float *W, _Complex float *work, const int *lwork, float *rwork, int *info, size_t, size_t)
     * }
     */
    public static void cheev_2stage_(MemorySegment jobz, MemorySegment uplo, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment W, MemorySegment work, MemorySegment lwork, MemorySegment rwork, MemorySegment info, long x10, long x11) {
        var mh$ = cheev_2stage_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cheev_2stage_", jobz, uplo, n, A, lda, W, work, lwork, rwork, info, x10, x11);
            }
            mh$.invokeExact(jobz, uplo, n, A, lda, W, work, lwork, rwork, info, x10, x11);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zheev_2stage_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("zheev_2stage_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zheev_2stage_(const char *jobz, const char *uplo, const int *n, _Complex double *A, const int *lda, double *W, _Complex double *work, const int *lwork, double *rwork, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor zheev_2stage_$descriptor() {
        return zheev_2stage_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zheev_2stage_(const char *jobz, const char *uplo, const int *n, _Complex double *A, const int *lda, double *W, _Complex double *work, const int *lwork, double *rwork, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle zheev_2stage_$handle() {
        return zheev_2stage_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zheev_2stage_(const char *jobz, const char *uplo, const int *n, _Complex double *A, const int *lda, double *W, _Complex double *work, const int *lwork, double *rwork, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment zheev_2stage_$address() {
        return zheev_2stage_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zheev_2stage_(const char *jobz, const char *uplo, const int *n, _Complex double *A, const int *lda, double *W, _Complex double *work, const int *lwork, double *rwork, int *info, size_t, size_t)
     * }
     */
    public static void zheev_2stage_(MemorySegment jobz, MemorySegment uplo, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment W, MemorySegment work, MemorySegment lwork, MemorySegment rwork, MemorySegment info, long x10, long x11) {
        var mh$ = zheev_2stage_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zheev_2stage_", jobz, uplo, n, A, lda, W, work, lwork, rwork, info, x10, x11);
            }
            mh$.invokeExact(jobz, uplo, n, A, lda, W, work, lwork, rwork, info, x10, x11);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cheevd_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cheevd_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cheevd_(const char *jobz, const char *uplo, const int *n, _Complex float *A, const int *lda, float *W, _Complex float *work, const int *lwork, float *rwork, const int *lrwork, int *iwork, const int *liwork, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor cheevd_$descriptor() {
        return cheevd_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cheevd_(const char *jobz, const char *uplo, const int *n, _Complex float *A, const int *lda, float *W, _Complex float *work, const int *lwork, float *rwork, const int *lrwork, int *iwork, const int *liwork, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle cheevd_$handle() {
        return cheevd_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cheevd_(const char *jobz, const char *uplo, const int *n, _Complex float *A, const int *lda, float *W, _Complex float *work, const int *lwork, float *rwork, const int *lrwork, int *iwork, const int *liwork, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment cheevd_$address() {
        return cheevd_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cheevd_(const char *jobz, const char *uplo, const int *n, _Complex float *A, const int *lda, float *W, _Complex float *work, const int *lwork, float *rwork, const int *lrwork, int *iwork, const int *liwork, int *info, size_t, size_t)
     * }
     */
    public static void cheevd_(MemorySegment jobz, MemorySegment uplo, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment W, MemorySegment work, MemorySegment lwork, MemorySegment rwork, MemorySegment lrwork, MemorySegment iwork, MemorySegment liwork, MemorySegment info, long x13, long x14) {
        var mh$ = cheevd_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cheevd_", jobz, uplo, n, A, lda, W, work, lwork, rwork, lrwork, iwork, liwork, info, x13, x14);
            }
            mh$.invokeExact(jobz, uplo, n, A, lda, W, work, lwork, rwork, lrwork, iwork, liwork, info, x13, x14);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zheevd_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("zheevd_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zheevd_(const char *jobz, const char *uplo, const int *n, _Complex double *A, const int *lda, double *W, _Complex double *work, const int *lwork, double *rwork, const int *lrwork, int *iwork, const int *liwork, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor zheevd_$descriptor() {
        return zheevd_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zheevd_(const char *jobz, const char *uplo, const int *n, _Complex double *A, const int *lda, double *W, _Complex double *work, const int *lwork, double *rwork, const int *lrwork, int *iwork, const int *liwork, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle zheevd_$handle() {
        return zheevd_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zheevd_(const char *jobz, const char *uplo, const int *n, _Complex double *A, const int *lda, double *W, _Complex double *work, const int *lwork, double *rwork, const int *lrwork, int *iwork, const int *liwork, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment zheevd_$address() {
        return zheevd_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zheevd_(const char *jobz, const char *uplo, const int *n, _Complex double *A, const int *lda, double *W, _Complex double *work, const int *lwork, double *rwork, const int *lrwork, int *iwork, const int *liwork, int *info, size_t, size_t)
     * }
     */
    public static void zheevd_(MemorySegment jobz, MemorySegment uplo, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment W, MemorySegment work, MemorySegment lwork, MemorySegment rwork, MemorySegment lrwork, MemorySegment iwork, MemorySegment liwork, MemorySegment info, long x13, long x14) {
        var mh$ = zheevd_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zheevd_", jobz, uplo, n, A, lda, W, work, lwork, rwork, lrwork, iwork, liwork, info, x13, x14);
            }
            mh$.invokeExact(jobz, uplo, n, A, lda, W, work, lwork, rwork, lrwork, iwork, liwork, info, x13, x14);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cheevd_2stage_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cheevd_2stage_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cheevd_2stage_(const char *jobz, const char *uplo, const int *n, _Complex float *A, const int *lda, float *W, _Complex float *work, const int *lwork, float *rwork, const int *lrwork, int *iwork, const int *liwork, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor cheevd_2stage_$descriptor() {
        return cheevd_2stage_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cheevd_2stage_(const char *jobz, const char *uplo, const int *n, _Complex float *A, const int *lda, float *W, _Complex float *work, const int *lwork, float *rwork, const int *lrwork, int *iwork, const int *liwork, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle cheevd_2stage_$handle() {
        return cheevd_2stage_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cheevd_2stage_(const char *jobz, const char *uplo, const int *n, _Complex float *A, const int *lda, float *W, _Complex float *work, const int *lwork, float *rwork, const int *lrwork, int *iwork, const int *liwork, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment cheevd_2stage_$address() {
        return cheevd_2stage_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cheevd_2stage_(const char *jobz, const char *uplo, const int *n, _Complex float *A, const int *lda, float *W, _Complex float *work, const int *lwork, float *rwork, const int *lrwork, int *iwork, const int *liwork, int *info, size_t, size_t)
     * }
     */
    public static void cheevd_2stage_(MemorySegment jobz, MemorySegment uplo, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment W, MemorySegment work, MemorySegment lwork, MemorySegment rwork, MemorySegment lrwork, MemorySegment iwork, MemorySegment liwork, MemorySegment info, long x13, long x14) {
        var mh$ = cheevd_2stage_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cheevd_2stage_", jobz, uplo, n, A, lda, W, work, lwork, rwork, lrwork, iwork, liwork, info, x13, x14);
            }
            mh$.invokeExact(jobz, uplo, n, A, lda, W, work, lwork, rwork, lrwork, iwork, liwork, info, x13, x14);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zheevd_2stage_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("zheevd_2stage_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zheevd_2stage_(const char *jobz, const char *uplo, const int *n, _Complex double *A, const int *lda, double *W, _Complex double *work, const int *lwork, double *rwork, const int *lrwork, int *iwork, const int *liwork, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor zheevd_2stage_$descriptor() {
        return zheevd_2stage_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zheevd_2stage_(const char *jobz, const char *uplo, const int *n, _Complex double *A, const int *lda, double *W, _Complex double *work, const int *lwork, double *rwork, const int *lrwork, int *iwork, const int *liwork, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle zheevd_2stage_$handle() {
        return zheevd_2stage_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zheevd_2stage_(const char *jobz, const char *uplo, const int *n, _Complex double *A, const int *lda, double *W, _Complex double *work, const int *lwork, double *rwork, const int *lrwork, int *iwork, const int *liwork, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment zheevd_2stage_$address() {
        return zheevd_2stage_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zheevd_2stage_(const char *jobz, const char *uplo, const int *n, _Complex double *A, const int *lda, double *W, _Complex double *work, const int *lwork, double *rwork, const int *lrwork, int *iwork, const int *liwork, int *info, size_t, size_t)
     * }
     */
    public static void zheevd_2stage_(MemorySegment jobz, MemorySegment uplo, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment W, MemorySegment work, MemorySegment lwork, MemorySegment rwork, MemorySegment lrwork, MemorySegment iwork, MemorySegment liwork, MemorySegment info, long x13, long x14) {
        var mh$ = zheevd_2stage_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zheevd_2stage_", jobz, uplo, n, A, lda, W, work, lwork, rwork, lrwork, iwork, liwork, info, x13, x14);
            }
            mh$.invokeExact(jobz, uplo, n, A, lda, W, work, lwork, rwork, lrwork, iwork, liwork, info, x13, x14);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cheevr_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cheevr_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cheevr_(const char *jobz, const char *range, const char *uplo, const int *n, _Complex float *A, const int *lda, const float *vl, const float *vu, const int *il, const int *iu, const float *abstol, int *m, float *W, _Complex float *Z, const int *ldz, int *ISUPPZ, _Complex float *work, const int *lwork, float *rwork, const int *lrwork, int *iwork, const int *liwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor cheevr_$descriptor() {
        return cheevr_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cheevr_(const char *jobz, const char *range, const char *uplo, const int *n, _Complex float *A, const int *lda, const float *vl, const float *vu, const int *il, const int *iu, const float *abstol, int *m, float *W, _Complex float *Z, const int *ldz, int *ISUPPZ, _Complex float *work, const int *lwork, float *rwork, const int *lrwork, int *iwork, const int *liwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle cheevr_$handle() {
        return cheevr_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cheevr_(const char *jobz, const char *range, const char *uplo, const int *n, _Complex float *A, const int *lda, const float *vl, const float *vu, const int *il, const int *iu, const float *abstol, int *m, float *W, _Complex float *Z, const int *ldz, int *ISUPPZ, _Complex float *work, const int *lwork, float *rwork, const int *lrwork, int *iwork, const int *liwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment cheevr_$address() {
        return cheevr_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cheevr_(const char *jobz, const char *range, const char *uplo, const int *n, _Complex float *A, const int *lda, const float *vl, const float *vu, const int *il, const int *iu, const float *abstol, int *m, float *W, _Complex float *Z, const int *ldz, int *ISUPPZ, _Complex float *work, const int *lwork, float *rwork, const int *lrwork, int *iwork, const int *liwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static void cheevr_(MemorySegment jobz, MemorySegment range, MemorySegment uplo, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment vl, MemorySegment vu, MemorySegment il, MemorySegment iu, MemorySegment abstol, MemorySegment m, MemorySegment W, MemorySegment Z, MemorySegment ldz, MemorySegment ISUPPZ, MemorySegment work, MemorySegment lwork, MemorySegment rwork, MemorySegment lrwork, MemorySegment iwork, MemorySegment liwork, MemorySegment info, long x23, long x24, long x25) {
        var mh$ = cheevr_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cheevr_", jobz, range, uplo, n, A, lda, vl, vu, il, iu, abstol, m, W, Z, ldz, ISUPPZ, work, lwork, rwork, lrwork, iwork, liwork, info, x23, x24, x25);
            }
            mh$.invokeExact(jobz, range, uplo, n, A, lda, vl, vu, il, iu, abstol, m, W, Z, ldz, ISUPPZ, work, lwork, rwork, lrwork, iwork, liwork, info, x23, x24, x25);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zheevr_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("zheevr_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zheevr_(const char *jobz, const char *range, const char *uplo, const int *n, _Complex double *A, const int *lda, const double *vl, const double *vu, const int *il, const int *iu, const double *abstol, int *m, double *W, _Complex double *Z, const int *ldz, int *ISUPPZ, _Complex double *work, const int *lwork, double *rwork, const int *lrwork, int *iwork, const int *liwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor zheevr_$descriptor() {
        return zheevr_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zheevr_(const char *jobz, const char *range, const char *uplo, const int *n, _Complex double *A, const int *lda, const double *vl, const double *vu, const int *il, const int *iu, const double *abstol, int *m, double *W, _Complex double *Z, const int *ldz, int *ISUPPZ, _Complex double *work, const int *lwork, double *rwork, const int *lrwork, int *iwork, const int *liwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle zheevr_$handle() {
        return zheevr_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zheevr_(const char *jobz, const char *range, const char *uplo, const int *n, _Complex double *A, const int *lda, const double *vl, const double *vu, const int *il, const int *iu, const double *abstol, int *m, double *W, _Complex double *Z, const int *ldz, int *ISUPPZ, _Complex double *work, const int *lwork, double *rwork, const int *lrwork, int *iwork, const int *liwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment zheevr_$address() {
        return zheevr_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zheevr_(const char *jobz, const char *range, const char *uplo, const int *n, _Complex double *A, const int *lda, const double *vl, const double *vu, const int *il, const int *iu, const double *abstol, int *m, double *W, _Complex double *Z, const int *ldz, int *ISUPPZ, _Complex double *work, const int *lwork, double *rwork, const int *lrwork, int *iwork, const int *liwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static void zheevr_(MemorySegment jobz, MemorySegment range, MemorySegment uplo, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment vl, MemorySegment vu, MemorySegment il, MemorySegment iu, MemorySegment abstol, MemorySegment m, MemorySegment W, MemorySegment Z, MemorySegment ldz, MemorySegment ISUPPZ, MemorySegment work, MemorySegment lwork, MemorySegment rwork, MemorySegment lrwork, MemorySegment iwork, MemorySegment liwork, MemorySegment info, long x23, long x24, long x25) {
        var mh$ = zheevr_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zheevr_", jobz, range, uplo, n, A, lda, vl, vu, il, iu, abstol, m, W, Z, ldz, ISUPPZ, work, lwork, rwork, lrwork, iwork, liwork, info, x23, x24, x25);
            }
            mh$.invokeExact(jobz, range, uplo, n, A, lda, vl, vu, il, iu, abstol, m, W, Z, ldz, ISUPPZ, work, lwork, rwork, lrwork, iwork, liwork, info, x23, x24, x25);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cheevr_2stage_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cheevr_2stage_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cheevr_2stage_(const char *jobz, const char *range, const char *uplo, const int *n, _Complex float *A, const int *lda, const float *vl, const float *vu, const int *il, const int *iu, const float *abstol, int *m, float *W, _Complex float *Z, const int *ldz, int *ISUPPZ, _Complex float *work, const int *lwork, float *rwork, const int *lrwork, int *iwork, const int *liwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor cheevr_2stage_$descriptor() {
        return cheevr_2stage_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cheevr_2stage_(const char *jobz, const char *range, const char *uplo, const int *n, _Complex float *A, const int *lda, const float *vl, const float *vu, const int *il, const int *iu, const float *abstol, int *m, float *W, _Complex float *Z, const int *ldz, int *ISUPPZ, _Complex float *work, const int *lwork, float *rwork, const int *lrwork, int *iwork, const int *liwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle cheevr_2stage_$handle() {
        return cheevr_2stage_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cheevr_2stage_(const char *jobz, const char *range, const char *uplo, const int *n, _Complex float *A, const int *lda, const float *vl, const float *vu, const int *il, const int *iu, const float *abstol, int *m, float *W, _Complex float *Z, const int *ldz, int *ISUPPZ, _Complex float *work, const int *lwork, float *rwork, const int *lrwork, int *iwork, const int *liwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment cheevr_2stage_$address() {
        return cheevr_2stage_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cheevr_2stage_(const char *jobz, const char *range, const char *uplo, const int *n, _Complex float *A, const int *lda, const float *vl, const float *vu, const int *il, const int *iu, const float *abstol, int *m, float *W, _Complex float *Z, const int *ldz, int *ISUPPZ, _Complex float *work, const int *lwork, float *rwork, const int *lrwork, int *iwork, const int *liwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static void cheevr_2stage_(MemorySegment jobz, MemorySegment range, MemorySegment uplo, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment vl, MemorySegment vu, MemorySegment il, MemorySegment iu, MemorySegment abstol, MemorySegment m, MemorySegment W, MemorySegment Z, MemorySegment ldz, MemorySegment ISUPPZ, MemorySegment work, MemorySegment lwork, MemorySegment rwork, MemorySegment lrwork, MemorySegment iwork, MemorySegment liwork, MemorySegment info, long x23, long x24, long x25) {
        var mh$ = cheevr_2stage_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cheevr_2stage_", jobz, range, uplo, n, A, lda, vl, vu, il, iu, abstol, m, W, Z, ldz, ISUPPZ, work, lwork, rwork, lrwork, iwork, liwork, info, x23, x24, x25);
            }
            mh$.invokeExact(jobz, range, uplo, n, A, lda, vl, vu, il, iu, abstol, m, W, Z, ldz, ISUPPZ, work, lwork, rwork, lrwork, iwork, liwork, info, x23, x24, x25);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zheevr_2stage_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("zheevr_2stage_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zheevr_2stage_(const char *jobz, const char *range, const char *uplo, const int *n, _Complex double *A, const int *lda, const double *vl, const double *vu, const int *il, const int *iu, const double *abstol, int *m, double *W, _Complex double *Z, const int *ldz, int *ISUPPZ, _Complex double *work, const int *lwork, double *rwork, const int *lrwork, int *iwork, const int *liwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor zheevr_2stage_$descriptor() {
        return zheevr_2stage_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zheevr_2stage_(const char *jobz, const char *range, const char *uplo, const int *n, _Complex double *A, const int *lda, const double *vl, const double *vu, const int *il, const int *iu, const double *abstol, int *m, double *W, _Complex double *Z, const int *ldz, int *ISUPPZ, _Complex double *work, const int *lwork, double *rwork, const int *lrwork, int *iwork, const int *liwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle zheevr_2stage_$handle() {
        return zheevr_2stage_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zheevr_2stage_(const char *jobz, const char *range, const char *uplo, const int *n, _Complex double *A, const int *lda, const double *vl, const double *vu, const int *il, const int *iu, const double *abstol, int *m, double *W, _Complex double *Z, const int *ldz, int *ISUPPZ, _Complex double *work, const int *lwork, double *rwork, const int *lrwork, int *iwork, const int *liwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment zheevr_2stage_$address() {
        return zheevr_2stage_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zheevr_2stage_(const char *jobz, const char *range, const char *uplo, const int *n, _Complex double *A, const int *lda, const double *vl, const double *vu, const int *il, const int *iu, const double *abstol, int *m, double *W, _Complex double *Z, const int *ldz, int *ISUPPZ, _Complex double *work, const int *lwork, double *rwork, const int *lrwork, int *iwork, const int *liwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static void zheevr_2stage_(MemorySegment jobz, MemorySegment range, MemorySegment uplo, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment vl, MemorySegment vu, MemorySegment il, MemorySegment iu, MemorySegment abstol, MemorySegment m, MemorySegment W, MemorySegment Z, MemorySegment ldz, MemorySegment ISUPPZ, MemorySegment work, MemorySegment lwork, MemorySegment rwork, MemorySegment lrwork, MemorySegment iwork, MemorySegment liwork, MemorySegment info, long x23, long x24, long x25) {
        var mh$ = zheevr_2stage_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zheevr_2stage_", jobz, range, uplo, n, A, lda, vl, vu, il, iu, abstol, m, W, Z, ldz, ISUPPZ, work, lwork, rwork, lrwork, iwork, liwork, info, x23, x24, x25);
            }
            mh$.invokeExact(jobz, range, uplo, n, A, lda, vl, vu, il, iu, abstol, m, W, Z, ldz, ISUPPZ, work, lwork, rwork, lrwork, iwork, liwork, info, x23, x24, x25);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cheevx_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cheevx_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cheevx_(const char *jobz, const char *range, const char *uplo, const int *n, _Complex float *A, const int *lda, const float *vl, const float *vu, const int *il, const int *iu, const float *abstol, int *m, float *W, _Complex float *Z, const int *ldz, _Complex float *work, const int *lwork, float *rwork, int *iwork, int *IFAIL, int *info, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor cheevx_$descriptor() {
        return cheevx_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cheevx_(const char *jobz, const char *range, const char *uplo, const int *n, _Complex float *A, const int *lda, const float *vl, const float *vu, const int *il, const int *iu, const float *abstol, int *m, float *W, _Complex float *Z, const int *ldz, _Complex float *work, const int *lwork, float *rwork, int *iwork, int *IFAIL, int *info, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle cheevx_$handle() {
        return cheevx_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cheevx_(const char *jobz, const char *range, const char *uplo, const int *n, _Complex float *A, const int *lda, const float *vl, const float *vu, const int *il, const int *iu, const float *abstol, int *m, float *W, _Complex float *Z, const int *ldz, _Complex float *work, const int *lwork, float *rwork, int *iwork, int *IFAIL, int *info, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment cheevx_$address() {
        return cheevx_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cheevx_(const char *jobz, const char *range, const char *uplo, const int *n, _Complex float *A, const int *lda, const float *vl, const float *vu, const int *il, const int *iu, const float *abstol, int *m, float *W, _Complex float *Z, const int *ldz, _Complex float *work, const int *lwork, float *rwork, int *iwork, int *IFAIL, int *info, size_t, size_t, size_t)
     * }
     */
    public static void cheevx_(MemorySegment jobz, MemorySegment range, MemorySegment uplo, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment vl, MemorySegment vu, MemorySegment il, MemorySegment iu, MemorySegment abstol, MemorySegment m, MemorySegment W, MemorySegment Z, MemorySegment ldz, MemorySegment work, MemorySegment lwork, MemorySegment rwork, MemorySegment iwork, MemorySegment IFAIL, MemorySegment info, long x21, long x22, long x23) {
        var mh$ = cheevx_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cheevx_", jobz, range, uplo, n, A, lda, vl, vu, il, iu, abstol, m, W, Z, ldz, work, lwork, rwork, iwork, IFAIL, info, x21, x22, x23);
            }
            mh$.invokeExact(jobz, range, uplo, n, A, lda, vl, vu, il, iu, abstol, m, W, Z, ldz, work, lwork, rwork, iwork, IFAIL, info, x21, x22, x23);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zheevx_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("zheevx_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zheevx_(const char *jobz, const char *range, const char *uplo, const int *n, _Complex double *A, const int *lda, const double *vl, const double *vu, const int *il, const int *iu, const double *abstol, int *m, double *W, _Complex double *Z, const int *ldz, _Complex double *work, const int *lwork, double *rwork, int *iwork, int *IFAIL, int *info, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor zheevx_$descriptor() {
        return zheevx_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zheevx_(const char *jobz, const char *range, const char *uplo, const int *n, _Complex double *A, const int *lda, const double *vl, const double *vu, const int *il, const int *iu, const double *abstol, int *m, double *W, _Complex double *Z, const int *ldz, _Complex double *work, const int *lwork, double *rwork, int *iwork, int *IFAIL, int *info, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle zheevx_$handle() {
        return zheevx_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zheevx_(const char *jobz, const char *range, const char *uplo, const int *n, _Complex double *A, const int *lda, const double *vl, const double *vu, const int *il, const int *iu, const double *abstol, int *m, double *W, _Complex double *Z, const int *ldz, _Complex double *work, const int *lwork, double *rwork, int *iwork, int *IFAIL, int *info, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment zheevx_$address() {
        return zheevx_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zheevx_(const char *jobz, const char *range, const char *uplo, const int *n, _Complex double *A, const int *lda, const double *vl, const double *vu, const int *il, const int *iu, const double *abstol, int *m, double *W, _Complex double *Z, const int *ldz, _Complex double *work, const int *lwork, double *rwork, int *iwork, int *IFAIL, int *info, size_t, size_t, size_t)
     * }
     */
    public static void zheevx_(MemorySegment jobz, MemorySegment range, MemorySegment uplo, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment vl, MemorySegment vu, MemorySegment il, MemorySegment iu, MemorySegment abstol, MemorySegment m, MemorySegment W, MemorySegment Z, MemorySegment ldz, MemorySegment work, MemorySegment lwork, MemorySegment rwork, MemorySegment iwork, MemorySegment IFAIL, MemorySegment info, long x21, long x22, long x23) {
        var mh$ = zheevx_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zheevx_", jobz, range, uplo, n, A, lda, vl, vu, il, iu, abstol, m, W, Z, ldz, work, lwork, rwork, iwork, IFAIL, info, x21, x22, x23);
            }
            mh$.invokeExact(jobz, range, uplo, n, A, lda, vl, vu, il, iu, abstol, m, W, Z, ldz, work, lwork, rwork, iwork, IFAIL, info, x21, x22, x23);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cheevx_2stage_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cheevx_2stage_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cheevx_2stage_(const char *jobz, const char *range, const char *uplo, const int *n, _Complex float *A, const int *lda, const float *vl, const float *vu, const int *il, const int *iu, const float *abstol, int *m, float *W, _Complex float *Z, const int *ldz, _Complex float *work, const int *lwork, float *rwork, int *iwork, int *IFAIL, int *info, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor cheevx_2stage_$descriptor() {
        return cheevx_2stage_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cheevx_2stage_(const char *jobz, const char *range, const char *uplo, const int *n, _Complex float *A, const int *lda, const float *vl, const float *vu, const int *il, const int *iu, const float *abstol, int *m, float *W, _Complex float *Z, const int *ldz, _Complex float *work, const int *lwork, float *rwork, int *iwork, int *IFAIL, int *info, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle cheevx_2stage_$handle() {
        return cheevx_2stage_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cheevx_2stage_(const char *jobz, const char *range, const char *uplo, const int *n, _Complex float *A, const int *lda, const float *vl, const float *vu, const int *il, const int *iu, const float *abstol, int *m, float *W, _Complex float *Z, const int *ldz, _Complex float *work, const int *lwork, float *rwork, int *iwork, int *IFAIL, int *info, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment cheevx_2stage_$address() {
        return cheevx_2stage_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cheevx_2stage_(const char *jobz, const char *range, const char *uplo, const int *n, _Complex float *A, const int *lda, const float *vl, const float *vu, const int *il, const int *iu, const float *abstol, int *m, float *W, _Complex float *Z, const int *ldz, _Complex float *work, const int *lwork, float *rwork, int *iwork, int *IFAIL, int *info, size_t, size_t, size_t)
     * }
     */
    public static void cheevx_2stage_(MemorySegment jobz, MemorySegment range, MemorySegment uplo, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment vl, MemorySegment vu, MemorySegment il, MemorySegment iu, MemorySegment abstol, MemorySegment m, MemorySegment W, MemorySegment Z, MemorySegment ldz, MemorySegment work, MemorySegment lwork, MemorySegment rwork, MemorySegment iwork, MemorySegment IFAIL, MemorySegment info, long x21, long x22, long x23) {
        var mh$ = cheevx_2stage_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cheevx_2stage_", jobz, range, uplo, n, A, lda, vl, vu, il, iu, abstol, m, W, Z, ldz, work, lwork, rwork, iwork, IFAIL, info, x21, x22, x23);
            }
            mh$.invokeExact(jobz, range, uplo, n, A, lda, vl, vu, il, iu, abstol, m, W, Z, ldz, work, lwork, rwork, iwork, IFAIL, info, x21, x22, x23);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zheevx_2stage_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("zheevx_2stage_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zheevx_2stage_(const char *jobz, const char *range, const char *uplo, const int *n, _Complex double *A, const int *lda, const double *vl, const double *vu, const int *il, const int *iu, const double *abstol, int *m, double *W, _Complex double *Z, const int *ldz, _Complex double *work, const int *lwork, double *rwork, int *iwork, int *IFAIL, int *info, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor zheevx_2stage_$descriptor() {
        return zheevx_2stage_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zheevx_2stage_(const char *jobz, const char *range, const char *uplo, const int *n, _Complex double *A, const int *lda, const double *vl, const double *vu, const int *il, const int *iu, const double *abstol, int *m, double *W, _Complex double *Z, const int *ldz, _Complex double *work, const int *lwork, double *rwork, int *iwork, int *IFAIL, int *info, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle zheevx_2stage_$handle() {
        return zheevx_2stage_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zheevx_2stage_(const char *jobz, const char *range, const char *uplo, const int *n, _Complex double *A, const int *lda, const double *vl, const double *vu, const int *il, const int *iu, const double *abstol, int *m, double *W, _Complex double *Z, const int *ldz, _Complex double *work, const int *lwork, double *rwork, int *iwork, int *IFAIL, int *info, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment zheevx_2stage_$address() {
        return zheevx_2stage_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zheevx_2stage_(const char *jobz, const char *range, const char *uplo, const int *n, _Complex double *A, const int *lda, const double *vl, const double *vu, const int *il, const int *iu, const double *abstol, int *m, double *W, _Complex double *Z, const int *ldz, _Complex double *work, const int *lwork, double *rwork, int *iwork, int *IFAIL, int *info, size_t, size_t, size_t)
     * }
     */
    public static void zheevx_2stage_(MemorySegment jobz, MemorySegment range, MemorySegment uplo, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment vl, MemorySegment vu, MemorySegment il, MemorySegment iu, MemorySegment abstol, MemorySegment m, MemorySegment W, MemorySegment Z, MemorySegment ldz, MemorySegment work, MemorySegment lwork, MemorySegment rwork, MemorySegment iwork, MemorySegment IFAIL, MemorySegment info, long x21, long x22, long x23) {
        var mh$ = zheevx_2stage_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zheevx_2stage_", jobz, range, uplo, n, A, lda, vl, vu, il, iu, abstol, m, W, Z, ldz, work, lwork, rwork, iwork, IFAIL, info, x21, x22, x23);
            }
            mh$.invokeExact(jobz, range, uplo, n, A, lda, vl, vu, il, iu, abstol, m, W, Z, ldz, work, lwork, rwork, iwork, IFAIL, info, x21, x22, x23);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class chegst_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("chegst_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void chegst_(const int *itype, const char *uplo, const int *n, _Complex float *A, const int *lda, const _Complex float *B, const int *ldb, int *info, size_t)
     * }
     */
    public static FunctionDescriptor chegst_$descriptor() {
        return chegst_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void chegst_(const int *itype, const char *uplo, const int *n, _Complex float *A, const int *lda, const _Complex float *B, const int *ldb, int *info, size_t)
     * }
     */
    public static MethodHandle chegst_$handle() {
        return chegst_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void chegst_(const int *itype, const char *uplo, const int *n, _Complex float *A, const int *lda, const _Complex float *B, const int *ldb, int *info, size_t)
     * }
     */
    public static MemorySegment chegst_$address() {
        return chegst_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void chegst_(const int *itype, const char *uplo, const int *n, _Complex float *A, const int *lda, const _Complex float *B, const int *ldb, int *info, size_t)
     * }
     */
    public static void chegst_(MemorySegment itype, MemorySegment uplo, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment B, MemorySegment ldb, MemorySegment info, long x8) {
        var mh$ = chegst_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("chegst_", itype, uplo, n, A, lda, B, ldb, info, x8);
            }
            mh$.invokeExact(itype, uplo, n, A, lda, B, ldb, info, x8);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zhegst_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("zhegst_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zhegst_(const int *itype, const char *uplo, const int *n, _Complex double *A, const int *lda, const _Complex double *B, const int *ldb, int *info, size_t)
     * }
     */
    public static FunctionDescriptor zhegst_$descriptor() {
        return zhegst_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zhegst_(const int *itype, const char *uplo, const int *n, _Complex double *A, const int *lda, const _Complex double *B, const int *ldb, int *info, size_t)
     * }
     */
    public static MethodHandle zhegst_$handle() {
        return zhegst_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zhegst_(const int *itype, const char *uplo, const int *n, _Complex double *A, const int *lda, const _Complex double *B, const int *ldb, int *info, size_t)
     * }
     */
    public static MemorySegment zhegst_$address() {
        return zhegst_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zhegst_(const int *itype, const char *uplo, const int *n, _Complex double *A, const int *lda, const _Complex double *B, const int *ldb, int *info, size_t)
     * }
     */
    public static void zhegst_(MemorySegment itype, MemorySegment uplo, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment B, MemorySegment ldb, MemorySegment info, long x8) {
        var mh$ = zhegst_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zhegst_", itype, uplo, n, A, lda, B, ldb, info, x8);
            }
            mh$.invokeExact(itype, uplo, n, A, lda, B, ldb, info, x8);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class chegv_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("chegv_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void chegv_(const int *itype, const char *jobz, const char *uplo, const int *n, _Complex float *A, const int *lda, _Complex float *B, const int *ldb, float *W, _Complex float *work, const int *lwork, float *rwork, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor chegv_$descriptor() {
        return chegv_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void chegv_(const int *itype, const char *jobz, const char *uplo, const int *n, _Complex float *A, const int *lda, _Complex float *B, const int *ldb, float *W, _Complex float *work, const int *lwork, float *rwork, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle chegv_$handle() {
        return chegv_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void chegv_(const int *itype, const char *jobz, const char *uplo, const int *n, _Complex float *A, const int *lda, _Complex float *B, const int *ldb, float *W, _Complex float *work, const int *lwork, float *rwork, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment chegv_$address() {
        return chegv_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void chegv_(const int *itype, const char *jobz, const char *uplo, const int *n, _Complex float *A, const int *lda, _Complex float *B, const int *ldb, float *W, _Complex float *work, const int *lwork, float *rwork, int *info, size_t, size_t)
     * }
     */
    public static void chegv_(MemorySegment itype, MemorySegment jobz, MemorySegment uplo, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment B, MemorySegment ldb, MemorySegment W, MemorySegment work, MemorySegment lwork, MemorySegment rwork, MemorySegment info, long x13, long x14) {
        var mh$ = chegv_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("chegv_", itype, jobz, uplo, n, A, lda, B, ldb, W, work, lwork, rwork, info, x13, x14);
            }
            mh$.invokeExact(itype, jobz, uplo, n, A, lda, B, ldb, W, work, lwork, rwork, info, x13, x14);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zhegv_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("zhegv_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zhegv_(const int *itype, const char *jobz, const char *uplo, const int *n, _Complex double *A, const int *lda, _Complex double *B, const int *ldb, double *W, _Complex double *work, const int *lwork, double *rwork, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor zhegv_$descriptor() {
        return zhegv_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zhegv_(const int *itype, const char *jobz, const char *uplo, const int *n, _Complex double *A, const int *lda, _Complex double *B, const int *ldb, double *W, _Complex double *work, const int *lwork, double *rwork, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle zhegv_$handle() {
        return zhegv_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zhegv_(const int *itype, const char *jobz, const char *uplo, const int *n, _Complex double *A, const int *lda, _Complex double *B, const int *ldb, double *W, _Complex double *work, const int *lwork, double *rwork, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment zhegv_$address() {
        return zhegv_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zhegv_(const int *itype, const char *jobz, const char *uplo, const int *n, _Complex double *A, const int *lda, _Complex double *B, const int *ldb, double *W, _Complex double *work, const int *lwork, double *rwork, int *info, size_t, size_t)
     * }
     */
    public static void zhegv_(MemorySegment itype, MemorySegment jobz, MemorySegment uplo, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment B, MemorySegment ldb, MemorySegment W, MemorySegment work, MemorySegment lwork, MemorySegment rwork, MemorySegment info, long x13, long x14) {
        var mh$ = zhegv_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zhegv_", itype, jobz, uplo, n, A, lda, B, ldb, W, work, lwork, rwork, info, x13, x14);
            }
            mh$.invokeExact(itype, jobz, uplo, n, A, lda, B, ldb, W, work, lwork, rwork, info, x13, x14);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class chegv_2stage_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("chegv_2stage_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void chegv_2stage_(const int *itype, const char *jobz, const char *uplo, const int *n, _Complex float *A, const int *lda, _Complex float *B, const int *ldb, float *W, _Complex float *work, const int *lwork, float *rwork, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor chegv_2stage_$descriptor() {
        return chegv_2stage_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void chegv_2stage_(const int *itype, const char *jobz, const char *uplo, const int *n, _Complex float *A, const int *lda, _Complex float *B, const int *ldb, float *W, _Complex float *work, const int *lwork, float *rwork, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle chegv_2stage_$handle() {
        return chegv_2stage_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void chegv_2stage_(const int *itype, const char *jobz, const char *uplo, const int *n, _Complex float *A, const int *lda, _Complex float *B, const int *ldb, float *W, _Complex float *work, const int *lwork, float *rwork, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment chegv_2stage_$address() {
        return chegv_2stage_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void chegv_2stage_(const int *itype, const char *jobz, const char *uplo, const int *n, _Complex float *A, const int *lda, _Complex float *B, const int *ldb, float *W, _Complex float *work, const int *lwork, float *rwork, int *info, size_t, size_t)
     * }
     */
    public static void chegv_2stage_(MemorySegment itype, MemorySegment jobz, MemorySegment uplo, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment B, MemorySegment ldb, MemorySegment W, MemorySegment work, MemorySegment lwork, MemorySegment rwork, MemorySegment info, long x13, long x14) {
        var mh$ = chegv_2stage_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("chegv_2stage_", itype, jobz, uplo, n, A, lda, B, ldb, W, work, lwork, rwork, info, x13, x14);
            }
            mh$.invokeExact(itype, jobz, uplo, n, A, lda, B, ldb, W, work, lwork, rwork, info, x13, x14);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zhegv_2stage_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("zhegv_2stage_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zhegv_2stage_(const int *itype, const char *jobz, const char *uplo, const int *n, _Complex double *A, const int *lda, _Complex double *B, const int *ldb, double *W, _Complex double *work, const int *lwork, double *rwork, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor zhegv_2stage_$descriptor() {
        return zhegv_2stage_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zhegv_2stage_(const int *itype, const char *jobz, const char *uplo, const int *n, _Complex double *A, const int *lda, _Complex double *B, const int *ldb, double *W, _Complex double *work, const int *lwork, double *rwork, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle zhegv_2stage_$handle() {
        return zhegv_2stage_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zhegv_2stage_(const int *itype, const char *jobz, const char *uplo, const int *n, _Complex double *A, const int *lda, _Complex double *B, const int *ldb, double *W, _Complex double *work, const int *lwork, double *rwork, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment zhegv_2stage_$address() {
        return zhegv_2stage_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zhegv_2stage_(const int *itype, const char *jobz, const char *uplo, const int *n, _Complex double *A, const int *lda, _Complex double *B, const int *ldb, double *W, _Complex double *work, const int *lwork, double *rwork, int *info, size_t, size_t)
     * }
     */
    public static void zhegv_2stage_(MemorySegment itype, MemorySegment jobz, MemorySegment uplo, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment B, MemorySegment ldb, MemorySegment W, MemorySegment work, MemorySegment lwork, MemorySegment rwork, MemorySegment info, long x13, long x14) {
        var mh$ = zhegv_2stage_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zhegv_2stage_", itype, jobz, uplo, n, A, lda, B, ldb, W, work, lwork, rwork, info, x13, x14);
            }
            mh$.invokeExact(itype, jobz, uplo, n, A, lda, B, ldb, W, work, lwork, rwork, info, x13, x14);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class chegvd_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("chegvd_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void chegvd_(const int *itype, const char *jobz, const char *uplo, const int *n, _Complex float *A, const int *lda, _Complex float *B, const int *ldb, float *W, _Complex float *work, const int *lwork, float *rwork, const int *lrwork, int *iwork, const int *liwork, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor chegvd_$descriptor() {
        return chegvd_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void chegvd_(const int *itype, const char *jobz, const char *uplo, const int *n, _Complex float *A, const int *lda, _Complex float *B, const int *ldb, float *W, _Complex float *work, const int *lwork, float *rwork, const int *lrwork, int *iwork, const int *liwork, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle chegvd_$handle() {
        return chegvd_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void chegvd_(const int *itype, const char *jobz, const char *uplo, const int *n, _Complex float *A, const int *lda, _Complex float *B, const int *ldb, float *W, _Complex float *work, const int *lwork, float *rwork, const int *lrwork, int *iwork, const int *liwork, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment chegvd_$address() {
        return chegvd_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void chegvd_(const int *itype, const char *jobz, const char *uplo, const int *n, _Complex float *A, const int *lda, _Complex float *B, const int *ldb, float *W, _Complex float *work, const int *lwork, float *rwork, const int *lrwork, int *iwork, const int *liwork, int *info, size_t, size_t)
     * }
     */
    public static void chegvd_(MemorySegment itype, MemorySegment jobz, MemorySegment uplo, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment B, MemorySegment ldb, MemorySegment W, MemorySegment work, MemorySegment lwork, MemorySegment rwork, MemorySegment lrwork, MemorySegment iwork, MemorySegment liwork, MemorySegment info, long x16, long x17) {
        var mh$ = chegvd_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("chegvd_", itype, jobz, uplo, n, A, lda, B, ldb, W, work, lwork, rwork, lrwork, iwork, liwork, info, x16, x17);
            }
            mh$.invokeExact(itype, jobz, uplo, n, A, lda, B, ldb, W, work, lwork, rwork, lrwork, iwork, liwork, info, x16, x17);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zhegvd_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("zhegvd_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zhegvd_(const int *itype, const char *jobz, const char *uplo, const int *n, _Complex double *A, const int *lda, _Complex double *B, const int *ldb, double *W, _Complex double *work, const int *lwork, double *rwork, const int *lrwork, int *iwork, const int *liwork, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor zhegvd_$descriptor() {
        return zhegvd_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zhegvd_(const int *itype, const char *jobz, const char *uplo, const int *n, _Complex double *A, const int *lda, _Complex double *B, const int *ldb, double *W, _Complex double *work, const int *lwork, double *rwork, const int *lrwork, int *iwork, const int *liwork, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle zhegvd_$handle() {
        return zhegvd_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zhegvd_(const int *itype, const char *jobz, const char *uplo, const int *n, _Complex double *A, const int *lda, _Complex double *B, const int *ldb, double *W, _Complex double *work, const int *lwork, double *rwork, const int *lrwork, int *iwork, const int *liwork, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment zhegvd_$address() {
        return zhegvd_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zhegvd_(const int *itype, const char *jobz, const char *uplo, const int *n, _Complex double *A, const int *lda, _Complex double *B, const int *ldb, double *W, _Complex double *work, const int *lwork, double *rwork, const int *lrwork, int *iwork, const int *liwork, int *info, size_t, size_t)
     * }
     */
    public static void zhegvd_(MemorySegment itype, MemorySegment jobz, MemorySegment uplo, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment B, MemorySegment ldb, MemorySegment W, MemorySegment work, MemorySegment lwork, MemorySegment rwork, MemorySegment lrwork, MemorySegment iwork, MemorySegment liwork, MemorySegment info, long x16, long x17) {
        var mh$ = zhegvd_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zhegvd_", itype, jobz, uplo, n, A, lda, B, ldb, W, work, lwork, rwork, lrwork, iwork, liwork, info, x16, x17);
            }
            mh$.invokeExact(itype, jobz, uplo, n, A, lda, B, ldb, W, work, lwork, rwork, lrwork, iwork, liwork, info, x16, x17);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class chegvx_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("chegvx_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void chegvx_(const int *itype, const char *jobz, const char *range, const char *uplo, const int *n, _Complex float *A, const int *lda, _Complex float *B, const int *ldb, const float *vl, const float *vu, const int *il, const int *iu, const float *abstol, int *m, float *W, _Complex float *Z, const int *ldz, _Complex float *work, const int *lwork, float *rwork, int *iwork, int *IFAIL, int *info, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor chegvx_$descriptor() {
        return chegvx_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void chegvx_(const int *itype, const char *jobz, const char *range, const char *uplo, const int *n, _Complex float *A, const int *lda, _Complex float *B, const int *ldb, const float *vl, const float *vu, const int *il, const int *iu, const float *abstol, int *m, float *W, _Complex float *Z, const int *ldz, _Complex float *work, const int *lwork, float *rwork, int *iwork, int *IFAIL, int *info, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle chegvx_$handle() {
        return chegvx_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void chegvx_(const int *itype, const char *jobz, const char *range, const char *uplo, const int *n, _Complex float *A, const int *lda, _Complex float *B, const int *ldb, const float *vl, const float *vu, const int *il, const int *iu, const float *abstol, int *m, float *W, _Complex float *Z, const int *ldz, _Complex float *work, const int *lwork, float *rwork, int *iwork, int *IFAIL, int *info, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment chegvx_$address() {
        return chegvx_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void chegvx_(const int *itype, const char *jobz, const char *range, const char *uplo, const int *n, _Complex float *A, const int *lda, _Complex float *B, const int *ldb, const float *vl, const float *vu, const int *il, const int *iu, const float *abstol, int *m, float *W, _Complex float *Z, const int *ldz, _Complex float *work, const int *lwork, float *rwork, int *iwork, int *IFAIL, int *info, size_t, size_t, size_t)
     * }
     */
    public static void chegvx_(MemorySegment itype, MemorySegment jobz, MemorySegment range, MemorySegment uplo, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment B, MemorySegment ldb, MemorySegment vl, MemorySegment vu, MemorySegment il, MemorySegment iu, MemorySegment abstol, MemorySegment m, MemorySegment W, MemorySegment Z, MemorySegment ldz, MemorySegment work, MemorySegment lwork, MemorySegment rwork, MemorySegment iwork, MemorySegment IFAIL, MemorySegment info, long x24, long x25, long x26) {
        var mh$ = chegvx_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("chegvx_", itype, jobz, range, uplo, n, A, lda, B, ldb, vl, vu, il, iu, abstol, m, W, Z, ldz, work, lwork, rwork, iwork, IFAIL, info, x24, x25, x26);
            }
            mh$.invokeExact(itype, jobz, range, uplo, n, A, lda, B, ldb, vl, vu, il, iu, abstol, m, W, Z, ldz, work, lwork, rwork, iwork, IFAIL, info, x24, x25, x26);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zhegvx_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("zhegvx_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zhegvx_(const int *itype, const char *jobz, const char *range, const char *uplo, const int *n, _Complex double *A, const int *lda, _Complex double *B, const int *ldb, const double *vl, const double *vu, const int *il, const int *iu, const double *abstol, int *m, double *W, _Complex double *Z, const int *ldz, _Complex double *work, const int *lwork, double *rwork, int *iwork, int *IFAIL, int *info, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor zhegvx_$descriptor() {
        return zhegvx_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zhegvx_(const int *itype, const char *jobz, const char *range, const char *uplo, const int *n, _Complex double *A, const int *lda, _Complex double *B, const int *ldb, const double *vl, const double *vu, const int *il, const int *iu, const double *abstol, int *m, double *W, _Complex double *Z, const int *ldz, _Complex double *work, const int *lwork, double *rwork, int *iwork, int *IFAIL, int *info, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle zhegvx_$handle() {
        return zhegvx_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zhegvx_(const int *itype, const char *jobz, const char *range, const char *uplo, const int *n, _Complex double *A, const int *lda, _Complex double *B, const int *ldb, const double *vl, const double *vu, const int *il, const int *iu, const double *abstol, int *m, double *W, _Complex double *Z, const int *ldz, _Complex double *work, const int *lwork, double *rwork, int *iwork, int *IFAIL, int *info, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment zhegvx_$address() {
        return zhegvx_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zhegvx_(const int *itype, const char *jobz, const char *range, const char *uplo, const int *n, _Complex double *A, const int *lda, _Complex double *B, const int *ldb, const double *vl, const double *vu, const int *il, const int *iu, const double *abstol, int *m, double *W, _Complex double *Z, const int *ldz, _Complex double *work, const int *lwork, double *rwork, int *iwork, int *IFAIL, int *info, size_t, size_t, size_t)
     * }
     */
    public static void zhegvx_(MemorySegment itype, MemorySegment jobz, MemorySegment range, MemorySegment uplo, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment B, MemorySegment ldb, MemorySegment vl, MemorySegment vu, MemorySegment il, MemorySegment iu, MemorySegment abstol, MemorySegment m, MemorySegment W, MemorySegment Z, MemorySegment ldz, MemorySegment work, MemorySegment lwork, MemorySegment rwork, MemorySegment iwork, MemorySegment IFAIL, MemorySegment info, long x24, long x25, long x26) {
        var mh$ = zhegvx_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zhegvx_", itype, jobz, range, uplo, n, A, lda, B, ldb, vl, vu, il, iu, abstol, m, W, Z, ldz, work, lwork, rwork, iwork, IFAIL, info, x24, x25, x26);
            }
            mh$.invokeExact(itype, jobz, range, uplo, n, A, lda, B, ldb, vl, vu, il, iu, abstol, m, W, Z, ldz, work, lwork, rwork, iwork, IFAIL, info, x24, x25, x26);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cherfs_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cherfs_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cherfs_(const char *uplo, const int *n, const int *nrhs, const _Complex float *A, const int *lda, const _Complex float *AF, const int *ldaf, const int *ipiv, const _Complex float *B, const int *ldb, _Complex float *X, const int *ldx, float *ferr, float *berr, _Complex float *work, float *rwork, int *info, size_t)
     * }
     */
    public static FunctionDescriptor cherfs_$descriptor() {
        return cherfs_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cherfs_(const char *uplo, const int *n, const int *nrhs, const _Complex float *A, const int *lda, const _Complex float *AF, const int *ldaf, const int *ipiv, const _Complex float *B, const int *ldb, _Complex float *X, const int *ldx, float *ferr, float *berr, _Complex float *work, float *rwork, int *info, size_t)
     * }
     */
    public static MethodHandle cherfs_$handle() {
        return cherfs_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cherfs_(const char *uplo, const int *n, const int *nrhs, const _Complex float *A, const int *lda, const _Complex float *AF, const int *ldaf, const int *ipiv, const _Complex float *B, const int *ldb, _Complex float *X, const int *ldx, float *ferr, float *berr, _Complex float *work, float *rwork, int *info, size_t)
     * }
     */
    public static MemorySegment cherfs_$address() {
        return cherfs_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cherfs_(const char *uplo, const int *n, const int *nrhs, const _Complex float *A, const int *lda, const _Complex float *AF, const int *ldaf, const int *ipiv, const _Complex float *B, const int *ldb, _Complex float *X, const int *ldx, float *ferr, float *berr, _Complex float *work, float *rwork, int *info, size_t)
     * }
     */
    public static void cherfs_(MemorySegment uplo, MemorySegment n, MemorySegment nrhs, MemorySegment A, MemorySegment lda, MemorySegment AF, MemorySegment ldaf, MemorySegment ipiv, MemorySegment B, MemorySegment ldb, MemorySegment X, MemorySegment ldx, MemorySegment ferr, MemorySegment berr, MemorySegment work, MemorySegment rwork, MemorySegment info, long x17) {
        var mh$ = cherfs_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cherfs_", uplo, n, nrhs, A, lda, AF, ldaf, ipiv, B, ldb, X, ldx, ferr, berr, work, rwork, info, x17);
            }
            mh$.invokeExact(uplo, n, nrhs, A, lda, AF, ldaf, ipiv, B, ldb, X, ldx, ferr, berr, work, rwork, info, x17);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zherfs_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("zherfs_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zherfs_(const char *uplo, const int *n, const int *nrhs, const _Complex double *A, const int *lda, const _Complex double *AF, const int *ldaf, const int *ipiv, const _Complex double *B, const int *ldb, _Complex double *X, const int *ldx, double *ferr, double *berr, _Complex double *work, double *rwork, int *info, size_t)
     * }
     */
    public static FunctionDescriptor zherfs_$descriptor() {
        return zherfs_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zherfs_(const char *uplo, const int *n, const int *nrhs, const _Complex double *A, const int *lda, const _Complex double *AF, const int *ldaf, const int *ipiv, const _Complex double *B, const int *ldb, _Complex double *X, const int *ldx, double *ferr, double *berr, _Complex double *work, double *rwork, int *info, size_t)
     * }
     */
    public static MethodHandle zherfs_$handle() {
        return zherfs_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zherfs_(const char *uplo, const int *n, const int *nrhs, const _Complex double *A, const int *lda, const _Complex double *AF, const int *ldaf, const int *ipiv, const _Complex double *B, const int *ldb, _Complex double *X, const int *ldx, double *ferr, double *berr, _Complex double *work, double *rwork, int *info, size_t)
     * }
     */
    public static MemorySegment zherfs_$address() {
        return zherfs_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zherfs_(const char *uplo, const int *n, const int *nrhs, const _Complex double *A, const int *lda, const _Complex double *AF, const int *ldaf, const int *ipiv, const _Complex double *B, const int *ldb, _Complex double *X, const int *ldx, double *ferr, double *berr, _Complex double *work, double *rwork, int *info, size_t)
     * }
     */
    public static void zherfs_(MemorySegment uplo, MemorySegment n, MemorySegment nrhs, MemorySegment A, MemorySegment lda, MemorySegment AF, MemorySegment ldaf, MemorySegment ipiv, MemorySegment B, MemorySegment ldb, MemorySegment X, MemorySegment ldx, MemorySegment ferr, MemorySegment berr, MemorySegment work, MemorySegment rwork, MemorySegment info, long x17) {
        var mh$ = zherfs_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zherfs_", uplo, n, nrhs, A, lda, AF, ldaf, ipiv, B, ldb, X, ldx, ferr, berr, work, rwork, info, x17);
            }
            mh$.invokeExact(uplo, n, nrhs, A, lda, AF, ldaf, ipiv, B, ldb, X, ldx, ferr, berr, work, rwork, info, x17);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cherfsx_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cherfsx_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cherfsx_(const char *uplo, const char *equed, const int *n, const int *nrhs, const _Complex float *A, const int *lda, const _Complex float *AF, const int *ldaf, const int *ipiv, const float *S, const _Complex float *B, const int *ldb, _Complex float *X, const int *ldx, float *rcond, float *berr, const int *n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, const int *nparams, float *params, _Complex float *work, float *rwork, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor cherfsx_$descriptor() {
        return cherfsx_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cherfsx_(const char *uplo, const char *equed, const int *n, const int *nrhs, const _Complex float *A, const int *lda, const _Complex float *AF, const int *ldaf, const int *ipiv, const float *S, const _Complex float *B, const int *ldb, _Complex float *X, const int *ldx, float *rcond, float *berr, const int *n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, const int *nparams, float *params, _Complex float *work, float *rwork, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle cherfsx_$handle() {
        return cherfsx_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cherfsx_(const char *uplo, const char *equed, const int *n, const int *nrhs, const _Complex float *A, const int *lda, const _Complex float *AF, const int *ldaf, const int *ipiv, const float *S, const _Complex float *B, const int *ldb, _Complex float *X, const int *ldx, float *rcond, float *berr, const int *n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, const int *nparams, float *params, _Complex float *work, float *rwork, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment cherfsx_$address() {
        return cherfsx_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cherfsx_(const char *uplo, const char *equed, const int *n, const int *nrhs, const _Complex float *A, const int *lda, const _Complex float *AF, const int *ldaf, const int *ipiv, const float *S, const _Complex float *B, const int *ldb, _Complex float *X, const int *ldx, float *rcond, float *berr, const int *n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, const int *nparams, float *params, _Complex float *work, float *rwork, int *info, size_t, size_t)
     * }
     */
    public static void cherfsx_(MemorySegment uplo, MemorySegment equed, MemorySegment n, MemorySegment nrhs, MemorySegment A, MemorySegment lda, MemorySegment AF, MemorySegment ldaf, MemorySegment ipiv, MemorySegment S, MemorySegment B, MemorySegment ldb, MemorySegment X, MemorySegment ldx, MemorySegment rcond, MemorySegment berr, MemorySegment n_err_bnds, MemorySegment err_bnds_norm, MemorySegment err_bnds_comp, MemorySegment nparams, MemorySegment params, MemorySegment work, MemorySegment rwork, MemorySegment info, long x24, long x25) {
        var mh$ = cherfsx_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cherfsx_", uplo, equed, n, nrhs, A, lda, AF, ldaf, ipiv, S, B, ldb, X, ldx, rcond, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params, work, rwork, info, x24, x25);
            }
            mh$.invokeExact(uplo, equed, n, nrhs, A, lda, AF, ldaf, ipiv, S, B, ldb, X, ldx, rcond, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params, work, rwork, info, x24, x25);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zherfsx_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("zherfsx_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zherfsx_(const char *uplo, const char *equed, const int *n, const int *nrhs, const _Complex double *A, const int *lda, const _Complex double *AF, const int *ldaf, const int *ipiv, const double *S, const _Complex double *B, const int *ldb, _Complex double *X, const int *ldx, double *rcond, double *berr, const int *n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, const int *nparams, double *params, _Complex double *work, double *rwork, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor zherfsx_$descriptor() {
        return zherfsx_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zherfsx_(const char *uplo, const char *equed, const int *n, const int *nrhs, const _Complex double *A, const int *lda, const _Complex double *AF, const int *ldaf, const int *ipiv, const double *S, const _Complex double *B, const int *ldb, _Complex double *X, const int *ldx, double *rcond, double *berr, const int *n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, const int *nparams, double *params, _Complex double *work, double *rwork, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle zherfsx_$handle() {
        return zherfsx_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zherfsx_(const char *uplo, const char *equed, const int *n, const int *nrhs, const _Complex double *A, const int *lda, const _Complex double *AF, const int *ldaf, const int *ipiv, const double *S, const _Complex double *B, const int *ldb, _Complex double *X, const int *ldx, double *rcond, double *berr, const int *n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, const int *nparams, double *params, _Complex double *work, double *rwork, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment zherfsx_$address() {
        return zherfsx_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zherfsx_(const char *uplo, const char *equed, const int *n, const int *nrhs, const _Complex double *A, const int *lda, const _Complex double *AF, const int *ldaf, const int *ipiv, const double *S, const _Complex double *B, const int *ldb, _Complex double *X, const int *ldx, double *rcond, double *berr, const int *n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, const int *nparams, double *params, _Complex double *work, double *rwork, int *info, size_t, size_t)
     * }
     */
    public static void zherfsx_(MemorySegment uplo, MemorySegment equed, MemorySegment n, MemorySegment nrhs, MemorySegment A, MemorySegment lda, MemorySegment AF, MemorySegment ldaf, MemorySegment ipiv, MemorySegment S, MemorySegment B, MemorySegment ldb, MemorySegment X, MemorySegment ldx, MemorySegment rcond, MemorySegment berr, MemorySegment n_err_bnds, MemorySegment err_bnds_norm, MemorySegment err_bnds_comp, MemorySegment nparams, MemorySegment params, MemorySegment work, MemorySegment rwork, MemorySegment info, long x24, long x25) {
        var mh$ = zherfsx_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zherfsx_", uplo, equed, n, nrhs, A, lda, AF, ldaf, ipiv, S, B, ldb, X, ldx, rcond, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params, work, rwork, info, x24, x25);
            }
            mh$.invokeExact(uplo, equed, n, nrhs, A, lda, AF, ldaf, ipiv, S, B, ldb, X, ldx, rcond, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params, work, rwork, info, x24, x25);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class chesv_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("chesv_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void chesv_(const char *uplo, const int *n, const int *nrhs, _Complex float *A, const int *lda, int *ipiv, _Complex float *B, const int *ldb, _Complex float *work, const int *lwork, int *info, size_t)
     * }
     */
    public static FunctionDescriptor chesv_$descriptor() {
        return chesv_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void chesv_(const char *uplo, const int *n, const int *nrhs, _Complex float *A, const int *lda, int *ipiv, _Complex float *B, const int *ldb, _Complex float *work, const int *lwork, int *info, size_t)
     * }
     */
    public static MethodHandle chesv_$handle() {
        return chesv_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void chesv_(const char *uplo, const int *n, const int *nrhs, _Complex float *A, const int *lda, int *ipiv, _Complex float *B, const int *ldb, _Complex float *work, const int *lwork, int *info, size_t)
     * }
     */
    public static MemorySegment chesv_$address() {
        return chesv_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void chesv_(const char *uplo, const int *n, const int *nrhs, _Complex float *A, const int *lda, int *ipiv, _Complex float *B, const int *ldb, _Complex float *work, const int *lwork, int *info, size_t)
     * }
     */
    public static void chesv_(MemorySegment uplo, MemorySegment n, MemorySegment nrhs, MemorySegment A, MemorySegment lda, MemorySegment ipiv, MemorySegment B, MemorySegment ldb, MemorySegment work, MemorySegment lwork, MemorySegment info, long x11) {
        var mh$ = chesv_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("chesv_", uplo, n, nrhs, A, lda, ipiv, B, ldb, work, lwork, info, x11);
            }
            mh$.invokeExact(uplo, n, nrhs, A, lda, ipiv, B, ldb, work, lwork, info, x11);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zhesv_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("zhesv_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zhesv_(const char *uplo, const int *n, const int *nrhs, _Complex double *A, const int *lda, int *ipiv, _Complex double *B, const int *ldb, _Complex double *work, const int *lwork, int *info, size_t)
     * }
     */
    public static FunctionDescriptor zhesv_$descriptor() {
        return zhesv_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zhesv_(const char *uplo, const int *n, const int *nrhs, _Complex double *A, const int *lda, int *ipiv, _Complex double *B, const int *ldb, _Complex double *work, const int *lwork, int *info, size_t)
     * }
     */
    public static MethodHandle zhesv_$handle() {
        return zhesv_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zhesv_(const char *uplo, const int *n, const int *nrhs, _Complex double *A, const int *lda, int *ipiv, _Complex double *B, const int *ldb, _Complex double *work, const int *lwork, int *info, size_t)
     * }
     */
    public static MemorySegment zhesv_$address() {
        return zhesv_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zhesv_(const char *uplo, const int *n, const int *nrhs, _Complex double *A, const int *lda, int *ipiv, _Complex double *B, const int *ldb, _Complex double *work, const int *lwork, int *info, size_t)
     * }
     */
    public static void zhesv_(MemorySegment uplo, MemorySegment n, MemorySegment nrhs, MemorySegment A, MemorySegment lda, MemorySegment ipiv, MemorySegment B, MemorySegment ldb, MemorySegment work, MemorySegment lwork, MemorySegment info, long x11) {
        var mh$ = zhesv_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zhesv_", uplo, n, nrhs, A, lda, ipiv, B, ldb, work, lwork, info, x11);
            }
            mh$.invokeExact(uplo, n, nrhs, A, lda, ipiv, B, ldb, work, lwork, info, x11);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class chesv_aa_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("chesv_aa_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void chesv_aa_(const char *uplo, const int *n, const int *nrhs, _Complex float *A, const int *lda, int *ipiv, _Complex float *B, const int *ldb, _Complex float *work, const int *lwork, int *info, size_t)
     * }
     */
    public static FunctionDescriptor chesv_aa_$descriptor() {
        return chesv_aa_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void chesv_aa_(const char *uplo, const int *n, const int *nrhs, _Complex float *A, const int *lda, int *ipiv, _Complex float *B, const int *ldb, _Complex float *work, const int *lwork, int *info, size_t)
     * }
     */
    public static MethodHandle chesv_aa_$handle() {
        return chesv_aa_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void chesv_aa_(const char *uplo, const int *n, const int *nrhs, _Complex float *A, const int *lda, int *ipiv, _Complex float *B, const int *ldb, _Complex float *work, const int *lwork, int *info, size_t)
     * }
     */
    public static MemorySegment chesv_aa_$address() {
        return chesv_aa_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void chesv_aa_(const char *uplo, const int *n, const int *nrhs, _Complex float *A, const int *lda, int *ipiv, _Complex float *B, const int *ldb, _Complex float *work, const int *lwork, int *info, size_t)
     * }
     */
    public static void chesv_aa_(MemorySegment uplo, MemorySegment n, MemorySegment nrhs, MemorySegment A, MemorySegment lda, MemorySegment ipiv, MemorySegment B, MemorySegment ldb, MemorySegment work, MemorySegment lwork, MemorySegment info, long x11) {
        var mh$ = chesv_aa_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("chesv_aa_", uplo, n, nrhs, A, lda, ipiv, B, ldb, work, lwork, info, x11);
            }
            mh$.invokeExact(uplo, n, nrhs, A, lda, ipiv, B, ldb, work, lwork, info, x11);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zhesv_aa_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("zhesv_aa_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zhesv_aa_(const char *uplo, const int *n, const int *nrhs, _Complex double *A, const int *lda, int *ipiv, _Complex double *B, const int *ldb, _Complex double *work, const int *lwork, int *info, size_t)
     * }
     */
    public static FunctionDescriptor zhesv_aa_$descriptor() {
        return zhesv_aa_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zhesv_aa_(const char *uplo, const int *n, const int *nrhs, _Complex double *A, const int *lda, int *ipiv, _Complex double *B, const int *ldb, _Complex double *work, const int *lwork, int *info, size_t)
     * }
     */
    public static MethodHandle zhesv_aa_$handle() {
        return zhesv_aa_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zhesv_aa_(const char *uplo, const int *n, const int *nrhs, _Complex double *A, const int *lda, int *ipiv, _Complex double *B, const int *ldb, _Complex double *work, const int *lwork, int *info, size_t)
     * }
     */
    public static MemorySegment zhesv_aa_$address() {
        return zhesv_aa_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zhesv_aa_(const char *uplo, const int *n, const int *nrhs, _Complex double *A, const int *lda, int *ipiv, _Complex double *B, const int *ldb, _Complex double *work, const int *lwork, int *info, size_t)
     * }
     */
    public static void zhesv_aa_(MemorySegment uplo, MemorySegment n, MemorySegment nrhs, MemorySegment A, MemorySegment lda, MemorySegment ipiv, MemorySegment B, MemorySegment ldb, MemorySegment work, MemorySegment lwork, MemorySegment info, long x11) {
        var mh$ = zhesv_aa_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zhesv_aa_", uplo, n, nrhs, A, lda, ipiv, B, ldb, work, lwork, info, x11);
            }
            mh$.invokeExact(uplo, n, nrhs, A, lda, ipiv, B, ldb, work, lwork, info, x11);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class chesv_aa_2stage_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("chesv_aa_2stage_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void chesv_aa_2stage_(const char *uplo, const int *n, const int *nrhs, _Complex float *A, const int *lda, _Complex float *TB, const int *ltb, int *ipiv, int *ipiv2, _Complex float *B, const int *ldb, _Complex float *work, const int *lwork, int *info, size_t)
     * }
     */
    public static FunctionDescriptor chesv_aa_2stage_$descriptor() {
        return chesv_aa_2stage_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void chesv_aa_2stage_(const char *uplo, const int *n, const int *nrhs, _Complex float *A, const int *lda, _Complex float *TB, const int *ltb, int *ipiv, int *ipiv2, _Complex float *B, const int *ldb, _Complex float *work, const int *lwork, int *info, size_t)
     * }
     */
    public static MethodHandle chesv_aa_2stage_$handle() {
        return chesv_aa_2stage_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void chesv_aa_2stage_(const char *uplo, const int *n, const int *nrhs, _Complex float *A, const int *lda, _Complex float *TB, const int *ltb, int *ipiv, int *ipiv2, _Complex float *B, const int *ldb, _Complex float *work, const int *lwork, int *info, size_t)
     * }
     */
    public static MemorySegment chesv_aa_2stage_$address() {
        return chesv_aa_2stage_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void chesv_aa_2stage_(const char *uplo, const int *n, const int *nrhs, _Complex float *A, const int *lda, _Complex float *TB, const int *ltb, int *ipiv, int *ipiv2, _Complex float *B, const int *ldb, _Complex float *work, const int *lwork, int *info, size_t)
     * }
     */
    public static void chesv_aa_2stage_(MemorySegment uplo, MemorySegment n, MemorySegment nrhs, MemorySegment A, MemorySegment lda, MemorySegment TB, MemorySegment ltb, MemorySegment ipiv, MemorySegment ipiv2, MemorySegment B, MemorySegment ldb, MemorySegment work, MemorySegment lwork, MemorySegment info, long x14) {
        var mh$ = chesv_aa_2stage_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("chesv_aa_2stage_", uplo, n, nrhs, A, lda, TB, ltb, ipiv, ipiv2, B, ldb, work, lwork, info, x14);
            }
            mh$.invokeExact(uplo, n, nrhs, A, lda, TB, ltb, ipiv, ipiv2, B, ldb, work, lwork, info, x14);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zhesv_aa_2stage_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("zhesv_aa_2stage_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zhesv_aa_2stage_(const char *uplo, const int *n, const int *nrhs, _Complex double *A, const int *lda, _Complex double *TB, const int *ltb, int *ipiv, int *ipiv2, _Complex double *B, const int *ldb, _Complex double *work, const int *lwork, int *info, size_t)
     * }
     */
    public static FunctionDescriptor zhesv_aa_2stage_$descriptor() {
        return zhesv_aa_2stage_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zhesv_aa_2stage_(const char *uplo, const int *n, const int *nrhs, _Complex double *A, const int *lda, _Complex double *TB, const int *ltb, int *ipiv, int *ipiv2, _Complex double *B, const int *ldb, _Complex double *work, const int *lwork, int *info, size_t)
     * }
     */
    public static MethodHandle zhesv_aa_2stage_$handle() {
        return zhesv_aa_2stage_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zhesv_aa_2stage_(const char *uplo, const int *n, const int *nrhs, _Complex double *A, const int *lda, _Complex double *TB, const int *ltb, int *ipiv, int *ipiv2, _Complex double *B, const int *ldb, _Complex double *work, const int *lwork, int *info, size_t)
     * }
     */
    public static MemorySegment zhesv_aa_2stage_$address() {
        return zhesv_aa_2stage_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zhesv_aa_2stage_(const char *uplo, const int *n, const int *nrhs, _Complex double *A, const int *lda, _Complex double *TB, const int *ltb, int *ipiv, int *ipiv2, _Complex double *B, const int *ldb, _Complex double *work, const int *lwork, int *info, size_t)
     * }
     */
    public static void zhesv_aa_2stage_(MemorySegment uplo, MemorySegment n, MemorySegment nrhs, MemorySegment A, MemorySegment lda, MemorySegment TB, MemorySegment ltb, MemorySegment ipiv, MemorySegment ipiv2, MemorySegment B, MemorySegment ldb, MemorySegment work, MemorySegment lwork, MemorySegment info, long x14) {
        var mh$ = zhesv_aa_2stage_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zhesv_aa_2stage_", uplo, n, nrhs, A, lda, TB, ltb, ipiv, ipiv2, B, ldb, work, lwork, info, x14);
            }
            mh$.invokeExact(uplo, n, nrhs, A, lda, TB, ltb, ipiv, ipiv2, B, ldb, work, lwork, info, x14);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class chesv_rk_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("chesv_rk_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void chesv_rk_(const char *uplo, const int *n, const int *nrhs, _Complex float *A, const int *lda, _Complex float *E, int *ipiv, _Complex float *B, const int *ldb, _Complex float *work, const int *lwork, int *info, size_t)
     * }
     */
    public static FunctionDescriptor chesv_rk_$descriptor() {
        return chesv_rk_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void chesv_rk_(const char *uplo, const int *n, const int *nrhs, _Complex float *A, const int *lda, _Complex float *E, int *ipiv, _Complex float *B, const int *ldb, _Complex float *work, const int *lwork, int *info, size_t)
     * }
     */
    public static MethodHandle chesv_rk_$handle() {
        return chesv_rk_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void chesv_rk_(const char *uplo, const int *n, const int *nrhs, _Complex float *A, const int *lda, _Complex float *E, int *ipiv, _Complex float *B, const int *ldb, _Complex float *work, const int *lwork, int *info, size_t)
     * }
     */
    public static MemorySegment chesv_rk_$address() {
        return chesv_rk_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void chesv_rk_(const char *uplo, const int *n, const int *nrhs, _Complex float *A, const int *lda, _Complex float *E, int *ipiv, _Complex float *B, const int *ldb, _Complex float *work, const int *lwork, int *info, size_t)
     * }
     */
    public static void chesv_rk_(MemorySegment uplo, MemorySegment n, MemorySegment nrhs, MemorySegment A, MemorySegment lda, MemorySegment E, MemorySegment ipiv, MemorySegment B, MemorySegment ldb, MemorySegment work, MemorySegment lwork, MemorySegment info, long x12) {
        var mh$ = chesv_rk_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("chesv_rk_", uplo, n, nrhs, A, lda, E, ipiv, B, ldb, work, lwork, info, x12);
            }
            mh$.invokeExact(uplo, n, nrhs, A, lda, E, ipiv, B, ldb, work, lwork, info, x12);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zhesv_rk_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("zhesv_rk_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zhesv_rk_(const char *uplo, const int *n, const int *nrhs, _Complex double *A, const int *lda, _Complex double *E, int *ipiv, _Complex double *B, const int *ldb, _Complex double *work, const int *lwork, int *info, size_t)
     * }
     */
    public static FunctionDescriptor zhesv_rk_$descriptor() {
        return zhesv_rk_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zhesv_rk_(const char *uplo, const int *n, const int *nrhs, _Complex double *A, const int *lda, _Complex double *E, int *ipiv, _Complex double *B, const int *ldb, _Complex double *work, const int *lwork, int *info, size_t)
     * }
     */
    public static MethodHandle zhesv_rk_$handle() {
        return zhesv_rk_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zhesv_rk_(const char *uplo, const int *n, const int *nrhs, _Complex double *A, const int *lda, _Complex double *E, int *ipiv, _Complex double *B, const int *ldb, _Complex double *work, const int *lwork, int *info, size_t)
     * }
     */
    public static MemorySegment zhesv_rk_$address() {
        return zhesv_rk_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zhesv_rk_(const char *uplo, const int *n, const int *nrhs, _Complex double *A, const int *lda, _Complex double *E, int *ipiv, _Complex double *B, const int *ldb, _Complex double *work, const int *lwork, int *info, size_t)
     * }
     */
    public static void zhesv_rk_(MemorySegment uplo, MemorySegment n, MemorySegment nrhs, MemorySegment A, MemorySegment lda, MemorySegment E, MemorySegment ipiv, MemorySegment B, MemorySegment ldb, MemorySegment work, MemorySegment lwork, MemorySegment info, long x12) {
        var mh$ = zhesv_rk_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zhesv_rk_", uplo, n, nrhs, A, lda, E, ipiv, B, ldb, work, lwork, info, x12);
            }
            mh$.invokeExact(uplo, n, nrhs, A, lda, E, ipiv, B, ldb, work, lwork, info, x12);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class chesv_rook_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("chesv_rook_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void chesv_rook_(const char *uplo, const int *n, const int *nrhs, _Complex float *A, const int *lda, int *ipiv, _Complex float *B, const int *ldb, _Complex float *work, const int *lwork, int *info, size_t)
     * }
     */
    public static FunctionDescriptor chesv_rook_$descriptor() {
        return chesv_rook_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void chesv_rook_(const char *uplo, const int *n, const int *nrhs, _Complex float *A, const int *lda, int *ipiv, _Complex float *B, const int *ldb, _Complex float *work, const int *lwork, int *info, size_t)
     * }
     */
    public static MethodHandle chesv_rook_$handle() {
        return chesv_rook_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void chesv_rook_(const char *uplo, const int *n, const int *nrhs, _Complex float *A, const int *lda, int *ipiv, _Complex float *B, const int *ldb, _Complex float *work, const int *lwork, int *info, size_t)
     * }
     */
    public static MemorySegment chesv_rook_$address() {
        return chesv_rook_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void chesv_rook_(const char *uplo, const int *n, const int *nrhs, _Complex float *A, const int *lda, int *ipiv, _Complex float *B, const int *ldb, _Complex float *work, const int *lwork, int *info, size_t)
     * }
     */
    public static void chesv_rook_(MemorySegment uplo, MemorySegment n, MemorySegment nrhs, MemorySegment A, MemorySegment lda, MemorySegment ipiv, MemorySegment B, MemorySegment ldb, MemorySegment work, MemorySegment lwork, MemorySegment info, long x11) {
        var mh$ = chesv_rook_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("chesv_rook_", uplo, n, nrhs, A, lda, ipiv, B, ldb, work, lwork, info, x11);
            }
            mh$.invokeExact(uplo, n, nrhs, A, lda, ipiv, B, ldb, work, lwork, info, x11);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zhesv_rook_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("zhesv_rook_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zhesv_rook_(const char *uplo, const int *n, const int *nrhs, _Complex double *A, const int *lda, int *ipiv, _Complex double *B, const int *ldb, _Complex double *work, const int *lwork, int *info, size_t)
     * }
     */
    public static FunctionDescriptor zhesv_rook_$descriptor() {
        return zhesv_rook_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zhesv_rook_(const char *uplo, const int *n, const int *nrhs, _Complex double *A, const int *lda, int *ipiv, _Complex double *B, const int *ldb, _Complex double *work, const int *lwork, int *info, size_t)
     * }
     */
    public static MethodHandle zhesv_rook_$handle() {
        return zhesv_rook_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zhesv_rook_(const char *uplo, const int *n, const int *nrhs, _Complex double *A, const int *lda, int *ipiv, _Complex double *B, const int *ldb, _Complex double *work, const int *lwork, int *info, size_t)
     * }
     */
    public static MemorySegment zhesv_rook_$address() {
        return zhesv_rook_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zhesv_rook_(const char *uplo, const int *n, const int *nrhs, _Complex double *A, const int *lda, int *ipiv, _Complex double *B, const int *ldb, _Complex double *work, const int *lwork, int *info, size_t)
     * }
     */
    public static void zhesv_rook_(MemorySegment uplo, MemorySegment n, MemorySegment nrhs, MemorySegment A, MemorySegment lda, MemorySegment ipiv, MemorySegment B, MemorySegment ldb, MemorySegment work, MemorySegment lwork, MemorySegment info, long x11) {
        var mh$ = zhesv_rook_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zhesv_rook_", uplo, n, nrhs, A, lda, ipiv, B, ldb, work, lwork, info, x11);
            }
            mh$.invokeExact(uplo, n, nrhs, A, lda, ipiv, B, ldb, work, lwork, info, x11);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class chesvx_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("chesvx_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void chesvx_(const char *fact, const char *uplo, const int *n, const int *nrhs, const _Complex float *A, const int *lda, _Complex float *AF, const int *ldaf, int *ipiv, const _Complex float *B, const int *ldb, _Complex float *X, const int *ldx, float *rcond, float *ferr, float *berr, _Complex float *work, const int *lwork, float *rwork, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor chesvx_$descriptor() {
        return chesvx_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void chesvx_(const char *fact, const char *uplo, const int *n, const int *nrhs, const _Complex float *A, const int *lda, _Complex float *AF, const int *ldaf, int *ipiv, const _Complex float *B, const int *ldb, _Complex float *X, const int *ldx, float *rcond, float *ferr, float *berr, _Complex float *work, const int *lwork, float *rwork, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle chesvx_$handle() {
        return chesvx_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void chesvx_(const char *fact, const char *uplo, const int *n, const int *nrhs, const _Complex float *A, const int *lda, _Complex float *AF, const int *ldaf, int *ipiv, const _Complex float *B, const int *ldb, _Complex float *X, const int *ldx, float *rcond, float *ferr, float *berr, _Complex float *work, const int *lwork, float *rwork, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment chesvx_$address() {
        return chesvx_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void chesvx_(const char *fact, const char *uplo, const int *n, const int *nrhs, const _Complex float *A, const int *lda, _Complex float *AF, const int *ldaf, int *ipiv, const _Complex float *B, const int *ldb, _Complex float *X, const int *ldx, float *rcond, float *ferr, float *berr, _Complex float *work, const int *lwork, float *rwork, int *info, size_t, size_t)
     * }
     */
    public static void chesvx_(MemorySegment fact, MemorySegment uplo, MemorySegment n, MemorySegment nrhs, MemorySegment A, MemorySegment lda, MemorySegment AF, MemorySegment ldaf, MemorySegment ipiv, MemorySegment B, MemorySegment ldb, MemorySegment X, MemorySegment ldx, MemorySegment rcond, MemorySegment ferr, MemorySegment berr, MemorySegment work, MemorySegment lwork, MemorySegment rwork, MemorySegment info, long x20, long x21) {
        var mh$ = chesvx_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("chesvx_", fact, uplo, n, nrhs, A, lda, AF, ldaf, ipiv, B, ldb, X, ldx, rcond, ferr, berr, work, lwork, rwork, info, x20, x21);
            }
            mh$.invokeExact(fact, uplo, n, nrhs, A, lda, AF, ldaf, ipiv, B, ldb, X, ldx, rcond, ferr, berr, work, lwork, rwork, info, x20, x21);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zhesvx_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("zhesvx_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zhesvx_(const char *fact, const char *uplo, const int *n, const int *nrhs, const _Complex double *A, const int *lda, _Complex double *AF, const int *ldaf, int *ipiv, const _Complex double *B, const int *ldb, _Complex double *X, const int *ldx, double *rcond, double *ferr, double *berr, _Complex double *work, const int *lwork, double *rwork, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor zhesvx_$descriptor() {
        return zhesvx_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zhesvx_(const char *fact, const char *uplo, const int *n, const int *nrhs, const _Complex double *A, const int *lda, _Complex double *AF, const int *ldaf, int *ipiv, const _Complex double *B, const int *ldb, _Complex double *X, const int *ldx, double *rcond, double *ferr, double *berr, _Complex double *work, const int *lwork, double *rwork, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle zhesvx_$handle() {
        return zhesvx_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zhesvx_(const char *fact, const char *uplo, const int *n, const int *nrhs, const _Complex double *A, const int *lda, _Complex double *AF, const int *ldaf, int *ipiv, const _Complex double *B, const int *ldb, _Complex double *X, const int *ldx, double *rcond, double *ferr, double *berr, _Complex double *work, const int *lwork, double *rwork, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment zhesvx_$address() {
        return zhesvx_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zhesvx_(const char *fact, const char *uplo, const int *n, const int *nrhs, const _Complex double *A, const int *lda, _Complex double *AF, const int *ldaf, int *ipiv, const _Complex double *B, const int *ldb, _Complex double *X, const int *ldx, double *rcond, double *ferr, double *berr, _Complex double *work, const int *lwork, double *rwork, int *info, size_t, size_t)
     * }
     */
    public static void zhesvx_(MemorySegment fact, MemorySegment uplo, MemorySegment n, MemorySegment nrhs, MemorySegment A, MemorySegment lda, MemorySegment AF, MemorySegment ldaf, MemorySegment ipiv, MemorySegment B, MemorySegment ldb, MemorySegment X, MemorySegment ldx, MemorySegment rcond, MemorySegment ferr, MemorySegment berr, MemorySegment work, MemorySegment lwork, MemorySegment rwork, MemorySegment info, long x20, long x21) {
        var mh$ = zhesvx_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zhesvx_", fact, uplo, n, nrhs, A, lda, AF, ldaf, ipiv, B, ldb, X, ldx, rcond, ferr, berr, work, lwork, rwork, info, x20, x21);
            }
            mh$.invokeExact(fact, uplo, n, nrhs, A, lda, AF, ldaf, ipiv, B, ldb, X, ldx, rcond, ferr, berr, work, lwork, rwork, info, x20, x21);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class chesvxx_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("chesvxx_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void chesvxx_(const char *fact, const char *uplo, const int *n, const int *nrhs, _Complex float *A, const int *lda, _Complex float *AF, const int *ldaf, int *ipiv, char *equed, float *S, _Complex float *B, const int *ldb, _Complex float *X, const int *ldx, float *rcond, float *rpvgrw, float *berr, const int *n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, const int *nparams, float *params, _Complex float *work, float *rwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor chesvxx_$descriptor() {
        return chesvxx_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void chesvxx_(const char *fact, const char *uplo, const int *n, const int *nrhs, _Complex float *A, const int *lda, _Complex float *AF, const int *ldaf, int *ipiv, char *equed, float *S, _Complex float *B, const int *ldb, _Complex float *X, const int *ldx, float *rcond, float *rpvgrw, float *berr, const int *n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, const int *nparams, float *params, _Complex float *work, float *rwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle chesvxx_$handle() {
        return chesvxx_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void chesvxx_(const char *fact, const char *uplo, const int *n, const int *nrhs, _Complex float *A, const int *lda, _Complex float *AF, const int *ldaf, int *ipiv, char *equed, float *S, _Complex float *B, const int *ldb, _Complex float *X, const int *ldx, float *rcond, float *rpvgrw, float *berr, const int *n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, const int *nparams, float *params, _Complex float *work, float *rwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment chesvxx_$address() {
        return chesvxx_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void chesvxx_(const char *fact, const char *uplo, const int *n, const int *nrhs, _Complex float *A, const int *lda, _Complex float *AF, const int *ldaf, int *ipiv, char *equed, float *S, _Complex float *B, const int *ldb, _Complex float *X, const int *ldx, float *rcond, float *rpvgrw, float *berr, const int *n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, const int *nparams, float *params, _Complex float *work, float *rwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static void chesvxx_(MemorySegment fact, MemorySegment uplo, MemorySegment n, MemorySegment nrhs, MemorySegment A, MemorySegment lda, MemorySegment AF, MemorySegment ldaf, MemorySegment ipiv, MemorySegment equed, MemorySegment S, MemorySegment B, MemorySegment ldb, MemorySegment X, MemorySegment ldx, MemorySegment rcond, MemorySegment rpvgrw, MemorySegment berr, MemorySegment n_err_bnds, MemorySegment err_bnds_norm, MemorySegment err_bnds_comp, MemorySegment nparams, MemorySegment params, MemorySegment work, MemorySegment rwork, MemorySegment info, long x26, long x27, long x28) {
        var mh$ = chesvxx_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("chesvxx_", fact, uplo, n, nrhs, A, lda, AF, ldaf, ipiv, equed, S, B, ldb, X, ldx, rcond, rpvgrw, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params, work, rwork, info, x26, x27, x28);
            }
            mh$.invokeExact(fact, uplo, n, nrhs, A, lda, AF, ldaf, ipiv, equed, S, B, ldb, X, ldx, rcond, rpvgrw, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params, work, rwork, info, x26, x27, x28);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zhesvxx_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("zhesvxx_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zhesvxx_(const char *fact, const char *uplo, const int *n, const int *nrhs, _Complex double *A, const int *lda, _Complex double *AF, const int *ldaf, int *ipiv, char *equed, double *S, _Complex double *B, const int *ldb, _Complex double *X, const int *ldx, double *rcond, double *rpvgrw, double *berr, const int *n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, const int *nparams, double *params, _Complex double *work, double *rwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor zhesvxx_$descriptor() {
        return zhesvxx_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zhesvxx_(const char *fact, const char *uplo, const int *n, const int *nrhs, _Complex double *A, const int *lda, _Complex double *AF, const int *ldaf, int *ipiv, char *equed, double *S, _Complex double *B, const int *ldb, _Complex double *X, const int *ldx, double *rcond, double *rpvgrw, double *berr, const int *n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, const int *nparams, double *params, _Complex double *work, double *rwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle zhesvxx_$handle() {
        return zhesvxx_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zhesvxx_(const char *fact, const char *uplo, const int *n, const int *nrhs, _Complex double *A, const int *lda, _Complex double *AF, const int *ldaf, int *ipiv, char *equed, double *S, _Complex double *B, const int *ldb, _Complex double *X, const int *ldx, double *rcond, double *rpvgrw, double *berr, const int *n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, const int *nparams, double *params, _Complex double *work, double *rwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment zhesvxx_$address() {
        return zhesvxx_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zhesvxx_(const char *fact, const char *uplo, const int *n, const int *nrhs, _Complex double *A, const int *lda, _Complex double *AF, const int *ldaf, int *ipiv, char *equed, double *S, _Complex double *B, const int *ldb, _Complex double *X, const int *ldx, double *rcond, double *rpvgrw, double *berr, const int *n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, const int *nparams, double *params, _Complex double *work, double *rwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static void zhesvxx_(MemorySegment fact, MemorySegment uplo, MemorySegment n, MemorySegment nrhs, MemorySegment A, MemorySegment lda, MemorySegment AF, MemorySegment ldaf, MemorySegment ipiv, MemorySegment equed, MemorySegment S, MemorySegment B, MemorySegment ldb, MemorySegment X, MemorySegment ldx, MemorySegment rcond, MemorySegment rpvgrw, MemorySegment berr, MemorySegment n_err_bnds, MemorySegment err_bnds_norm, MemorySegment err_bnds_comp, MemorySegment nparams, MemorySegment params, MemorySegment work, MemorySegment rwork, MemorySegment info, long x26, long x27, long x28) {
        var mh$ = zhesvxx_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zhesvxx_", fact, uplo, n, nrhs, A, lda, AF, ldaf, ipiv, equed, S, B, ldb, X, ldx, rcond, rpvgrw, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params, work, rwork, info, x26, x27, x28);
            }
            mh$.invokeExact(fact, uplo, n, nrhs, A, lda, AF, ldaf, ipiv, equed, S, B, ldb, X, ldx, rcond, rpvgrw, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params, work, rwork, info, x26, x27, x28);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cheswapr_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cheswapr_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cheswapr_(const char *uplo, const int *n, _Complex float *A, const int *lda, const int *i1, const int *i2, size_t)
     * }
     */
    public static FunctionDescriptor cheswapr_$descriptor() {
        return cheswapr_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cheswapr_(const char *uplo, const int *n, _Complex float *A, const int *lda, const int *i1, const int *i2, size_t)
     * }
     */
    public static MethodHandle cheswapr_$handle() {
        return cheswapr_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cheswapr_(const char *uplo, const int *n, _Complex float *A, const int *lda, const int *i1, const int *i2, size_t)
     * }
     */
    public static MemorySegment cheswapr_$address() {
        return cheswapr_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cheswapr_(const char *uplo, const int *n, _Complex float *A, const int *lda, const int *i1, const int *i2, size_t)
     * }
     */
    public static void cheswapr_(MemorySegment uplo, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment i1, MemorySegment i2, long x6) {
        var mh$ = cheswapr_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cheswapr_", uplo, n, A, lda, i1, i2, x6);
            }
            mh$.invokeExact(uplo, n, A, lda, i1, i2, x6);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zheswapr_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("zheswapr_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zheswapr_(const char *uplo, const int *n, _Complex double *A, const int *lda, const int *i1, const int *i2, size_t)
     * }
     */
    public static FunctionDescriptor zheswapr_$descriptor() {
        return zheswapr_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zheswapr_(const char *uplo, const int *n, _Complex double *A, const int *lda, const int *i1, const int *i2, size_t)
     * }
     */
    public static MethodHandle zheswapr_$handle() {
        return zheswapr_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zheswapr_(const char *uplo, const int *n, _Complex double *A, const int *lda, const int *i1, const int *i2, size_t)
     * }
     */
    public static MemorySegment zheswapr_$address() {
        return zheswapr_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zheswapr_(const char *uplo, const int *n, _Complex double *A, const int *lda, const int *i1, const int *i2, size_t)
     * }
     */
    public static void zheswapr_(MemorySegment uplo, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment i1, MemorySegment i2, long x6) {
        var mh$ = zheswapr_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zheswapr_", uplo, n, A, lda, i1, i2, x6);
            }
            mh$.invokeExact(uplo, n, A, lda, i1, i2, x6);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class chetrd_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("chetrd_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void chetrd_(const char *uplo, const int *n, _Complex float *A, const int *lda, float *D, float *E, _Complex float *tau, _Complex float *work, const int *lwork, int *info, size_t)
     * }
     */
    public static FunctionDescriptor chetrd_$descriptor() {
        return chetrd_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void chetrd_(const char *uplo, const int *n, _Complex float *A, const int *lda, float *D, float *E, _Complex float *tau, _Complex float *work, const int *lwork, int *info, size_t)
     * }
     */
    public static MethodHandle chetrd_$handle() {
        return chetrd_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void chetrd_(const char *uplo, const int *n, _Complex float *A, const int *lda, float *D, float *E, _Complex float *tau, _Complex float *work, const int *lwork, int *info, size_t)
     * }
     */
    public static MemorySegment chetrd_$address() {
        return chetrd_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void chetrd_(const char *uplo, const int *n, _Complex float *A, const int *lda, float *D, float *E, _Complex float *tau, _Complex float *work, const int *lwork, int *info, size_t)
     * }
     */
    public static void chetrd_(MemorySegment uplo, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment D, MemorySegment E, MemorySegment tau, MemorySegment work, MemorySegment lwork, MemorySegment info, long x10) {
        var mh$ = chetrd_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("chetrd_", uplo, n, A, lda, D, E, tau, work, lwork, info, x10);
            }
            mh$.invokeExact(uplo, n, A, lda, D, E, tau, work, lwork, info, x10);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zhetrd_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("zhetrd_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zhetrd_(const char *uplo, const int *n, _Complex double *A, const int *lda, double *D, double *E, _Complex double *tau, _Complex double *work, const int *lwork, int *info, size_t)
     * }
     */
    public static FunctionDescriptor zhetrd_$descriptor() {
        return zhetrd_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zhetrd_(const char *uplo, const int *n, _Complex double *A, const int *lda, double *D, double *E, _Complex double *tau, _Complex double *work, const int *lwork, int *info, size_t)
     * }
     */
    public static MethodHandle zhetrd_$handle() {
        return zhetrd_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zhetrd_(const char *uplo, const int *n, _Complex double *A, const int *lda, double *D, double *E, _Complex double *tau, _Complex double *work, const int *lwork, int *info, size_t)
     * }
     */
    public static MemorySegment zhetrd_$address() {
        return zhetrd_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zhetrd_(const char *uplo, const int *n, _Complex double *A, const int *lda, double *D, double *E, _Complex double *tau, _Complex double *work, const int *lwork, int *info, size_t)
     * }
     */
    public static void zhetrd_(MemorySegment uplo, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment D, MemorySegment E, MemorySegment tau, MemorySegment work, MemorySegment lwork, MemorySegment info, long x10) {
        var mh$ = zhetrd_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zhetrd_", uplo, n, A, lda, D, E, tau, work, lwork, info, x10);
            }
            mh$.invokeExact(uplo, n, A, lda, D, E, tau, work, lwork, info, x10);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class chetrd_2stage_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("chetrd_2stage_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void chetrd_2stage_(const char *vect, const char *uplo, const int *n, _Complex float *A, const int *lda, float *D, float *E, _Complex float *tau, _Complex float *HOUS2, const int *lhous2, _Complex float *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor chetrd_2stage_$descriptor() {
        return chetrd_2stage_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void chetrd_2stage_(const char *vect, const char *uplo, const int *n, _Complex float *A, const int *lda, float *D, float *E, _Complex float *tau, _Complex float *HOUS2, const int *lhous2, _Complex float *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle chetrd_2stage_$handle() {
        return chetrd_2stage_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void chetrd_2stage_(const char *vect, const char *uplo, const int *n, _Complex float *A, const int *lda, float *D, float *E, _Complex float *tau, _Complex float *HOUS2, const int *lhous2, _Complex float *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment chetrd_2stage_$address() {
        return chetrd_2stage_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void chetrd_2stage_(const char *vect, const char *uplo, const int *n, _Complex float *A, const int *lda, float *D, float *E, _Complex float *tau, _Complex float *HOUS2, const int *lhous2, _Complex float *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static void chetrd_2stage_(MemorySegment vect, MemorySegment uplo, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment D, MemorySegment E, MemorySegment tau, MemorySegment HOUS2, MemorySegment lhous2, MemorySegment work, MemorySegment lwork, MemorySegment info, long x13, long x14) {
        var mh$ = chetrd_2stage_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("chetrd_2stage_", vect, uplo, n, A, lda, D, E, tau, HOUS2, lhous2, work, lwork, info, x13, x14);
            }
            mh$.invokeExact(vect, uplo, n, A, lda, D, E, tau, HOUS2, lhous2, work, lwork, info, x13, x14);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zhetrd_2stage_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("zhetrd_2stage_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zhetrd_2stage_(const char *vect, const char *uplo, const int *n, _Complex double *A, const int *lda, double *D, double *E, _Complex double *tau, _Complex double *HOUS2, const int *lhous2, _Complex double *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor zhetrd_2stage_$descriptor() {
        return zhetrd_2stage_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zhetrd_2stage_(const char *vect, const char *uplo, const int *n, _Complex double *A, const int *lda, double *D, double *E, _Complex double *tau, _Complex double *HOUS2, const int *lhous2, _Complex double *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle zhetrd_2stage_$handle() {
        return zhetrd_2stage_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zhetrd_2stage_(const char *vect, const char *uplo, const int *n, _Complex double *A, const int *lda, double *D, double *E, _Complex double *tau, _Complex double *HOUS2, const int *lhous2, _Complex double *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment zhetrd_2stage_$address() {
        return zhetrd_2stage_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zhetrd_2stage_(const char *vect, const char *uplo, const int *n, _Complex double *A, const int *lda, double *D, double *E, _Complex double *tau, _Complex double *HOUS2, const int *lhous2, _Complex double *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static void zhetrd_2stage_(MemorySegment vect, MemorySegment uplo, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment D, MemorySegment E, MemorySegment tau, MemorySegment HOUS2, MemorySegment lhous2, MemorySegment work, MemorySegment lwork, MemorySegment info, long x13, long x14) {
        var mh$ = zhetrd_2stage_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zhetrd_2stage_", vect, uplo, n, A, lda, D, E, tau, HOUS2, lhous2, work, lwork, info, x13, x14);
            }
            mh$.invokeExact(vect, uplo, n, A, lda, D, E, tau, HOUS2, lhous2, work, lwork, info, x13, x14);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class chetrf_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("chetrf_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void chetrf_(const char *uplo, const int *n, _Complex float *A, const int *lda, int *ipiv, _Complex float *work, const int *lwork, int *info, size_t)
     * }
     */
    public static FunctionDescriptor chetrf_$descriptor() {
        return chetrf_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void chetrf_(const char *uplo, const int *n, _Complex float *A, const int *lda, int *ipiv, _Complex float *work, const int *lwork, int *info, size_t)
     * }
     */
    public static MethodHandle chetrf_$handle() {
        return chetrf_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void chetrf_(const char *uplo, const int *n, _Complex float *A, const int *lda, int *ipiv, _Complex float *work, const int *lwork, int *info, size_t)
     * }
     */
    public static MemorySegment chetrf_$address() {
        return chetrf_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void chetrf_(const char *uplo, const int *n, _Complex float *A, const int *lda, int *ipiv, _Complex float *work, const int *lwork, int *info, size_t)
     * }
     */
    public static void chetrf_(MemorySegment uplo, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment ipiv, MemorySegment work, MemorySegment lwork, MemorySegment info, long x8) {
        var mh$ = chetrf_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("chetrf_", uplo, n, A, lda, ipiv, work, lwork, info, x8);
            }
            mh$.invokeExact(uplo, n, A, lda, ipiv, work, lwork, info, x8);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zhetrf_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("zhetrf_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zhetrf_(const char *uplo, const int *n, _Complex double *A, const int *lda, int *ipiv, _Complex double *work, const int *lwork, int *info, size_t)
     * }
     */
    public static FunctionDescriptor zhetrf_$descriptor() {
        return zhetrf_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zhetrf_(const char *uplo, const int *n, _Complex double *A, const int *lda, int *ipiv, _Complex double *work, const int *lwork, int *info, size_t)
     * }
     */
    public static MethodHandle zhetrf_$handle() {
        return zhetrf_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zhetrf_(const char *uplo, const int *n, _Complex double *A, const int *lda, int *ipiv, _Complex double *work, const int *lwork, int *info, size_t)
     * }
     */
    public static MemorySegment zhetrf_$address() {
        return zhetrf_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zhetrf_(const char *uplo, const int *n, _Complex double *A, const int *lda, int *ipiv, _Complex double *work, const int *lwork, int *info, size_t)
     * }
     */
    public static void zhetrf_(MemorySegment uplo, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment ipiv, MemorySegment work, MemorySegment lwork, MemorySegment info, long x8) {
        var mh$ = zhetrf_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zhetrf_", uplo, n, A, lda, ipiv, work, lwork, info, x8);
            }
            mh$.invokeExact(uplo, n, A, lda, ipiv, work, lwork, info, x8);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class chetrf_aa_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("chetrf_aa_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void chetrf_aa_(const char *uplo, const int *n, _Complex float *A, const int *lda, int *ipiv, _Complex float *work, const int *lwork, int *info, size_t)
     * }
     */
    public static FunctionDescriptor chetrf_aa_$descriptor() {
        return chetrf_aa_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void chetrf_aa_(const char *uplo, const int *n, _Complex float *A, const int *lda, int *ipiv, _Complex float *work, const int *lwork, int *info, size_t)
     * }
     */
    public static MethodHandle chetrf_aa_$handle() {
        return chetrf_aa_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void chetrf_aa_(const char *uplo, const int *n, _Complex float *A, const int *lda, int *ipiv, _Complex float *work, const int *lwork, int *info, size_t)
     * }
     */
    public static MemorySegment chetrf_aa_$address() {
        return chetrf_aa_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void chetrf_aa_(const char *uplo, const int *n, _Complex float *A, const int *lda, int *ipiv, _Complex float *work, const int *lwork, int *info, size_t)
     * }
     */
    public static void chetrf_aa_(MemorySegment uplo, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment ipiv, MemorySegment work, MemorySegment lwork, MemorySegment info, long x8) {
        var mh$ = chetrf_aa_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("chetrf_aa_", uplo, n, A, lda, ipiv, work, lwork, info, x8);
            }
            mh$.invokeExact(uplo, n, A, lda, ipiv, work, lwork, info, x8);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zhetrf_aa_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("zhetrf_aa_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zhetrf_aa_(const char *uplo, const int *n, _Complex double *A, const int *lda, int *ipiv, _Complex double *work, const int *lwork, int *info, size_t)
     * }
     */
    public static FunctionDescriptor zhetrf_aa_$descriptor() {
        return zhetrf_aa_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zhetrf_aa_(const char *uplo, const int *n, _Complex double *A, const int *lda, int *ipiv, _Complex double *work, const int *lwork, int *info, size_t)
     * }
     */
    public static MethodHandle zhetrf_aa_$handle() {
        return zhetrf_aa_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zhetrf_aa_(const char *uplo, const int *n, _Complex double *A, const int *lda, int *ipiv, _Complex double *work, const int *lwork, int *info, size_t)
     * }
     */
    public static MemorySegment zhetrf_aa_$address() {
        return zhetrf_aa_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zhetrf_aa_(const char *uplo, const int *n, _Complex double *A, const int *lda, int *ipiv, _Complex double *work, const int *lwork, int *info, size_t)
     * }
     */
    public static void zhetrf_aa_(MemorySegment uplo, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment ipiv, MemorySegment work, MemorySegment lwork, MemorySegment info, long x8) {
        var mh$ = zhetrf_aa_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zhetrf_aa_", uplo, n, A, lda, ipiv, work, lwork, info, x8);
            }
            mh$.invokeExact(uplo, n, A, lda, ipiv, work, lwork, info, x8);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class chetrf_aa_2stage_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("chetrf_aa_2stage_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void chetrf_aa_2stage_(const char *uplo, const int *n, _Complex float *A, const int *lda, _Complex float *TB, const int *ltb, int *ipiv, int *ipiv2, _Complex float *work, const int *lwork, int *info, size_t)
     * }
     */
    public static FunctionDescriptor chetrf_aa_2stage_$descriptor() {
        return chetrf_aa_2stage_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void chetrf_aa_2stage_(const char *uplo, const int *n, _Complex float *A, const int *lda, _Complex float *TB, const int *ltb, int *ipiv, int *ipiv2, _Complex float *work, const int *lwork, int *info, size_t)
     * }
     */
    public static MethodHandle chetrf_aa_2stage_$handle() {
        return chetrf_aa_2stage_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void chetrf_aa_2stage_(const char *uplo, const int *n, _Complex float *A, const int *lda, _Complex float *TB, const int *ltb, int *ipiv, int *ipiv2, _Complex float *work, const int *lwork, int *info, size_t)
     * }
     */
    public static MemorySegment chetrf_aa_2stage_$address() {
        return chetrf_aa_2stage_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void chetrf_aa_2stage_(const char *uplo, const int *n, _Complex float *A, const int *lda, _Complex float *TB, const int *ltb, int *ipiv, int *ipiv2, _Complex float *work, const int *lwork, int *info, size_t)
     * }
     */
    public static void chetrf_aa_2stage_(MemorySegment uplo, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment TB, MemorySegment ltb, MemorySegment ipiv, MemorySegment ipiv2, MemorySegment work, MemorySegment lwork, MemorySegment info, long x11) {
        var mh$ = chetrf_aa_2stage_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("chetrf_aa_2stage_", uplo, n, A, lda, TB, ltb, ipiv, ipiv2, work, lwork, info, x11);
            }
            mh$.invokeExact(uplo, n, A, lda, TB, ltb, ipiv, ipiv2, work, lwork, info, x11);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zhetrf_aa_2stage_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("zhetrf_aa_2stage_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zhetrf_aa_2stage_(const char *uplo, const int *n, _Complex double *A, const int *lda, _Complex double *TB, const int *ltb, int *ipiv, int *ipiv2, _Complex double *work, const int *lwork, int *info, size_t)
     * }
     */
    public static FunctionDescriptor zhetrf_aa_2stage_$descriptor() {
        return zhetrf_aa_2stage_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zhetrf_aa_2stage_(const char *uplo, const int *n, _Complex double *A, const int *lda, _Complex double *TB, const int *ltb, int *ipiv, int *ipiv2, _Complex double *work, const int *lwork, int *info, size_t)
     * }
     */
    public static MethodHandle zhetrf_aa_2stage_$handle() {
        return zhetrf_aa_2stage_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zhetrf_aa_2stage_(const char *uplo, const int *n, _Complex double *A, const int *lda, _Complex double *TB, const int *ltb, int *ipiv, int *ipiv2, _Complex double *work, const int *lwork, int *info, size_t)
     * }
     */
    public static MemorySegment zhetrf_aa_2stage_$address() {
        return zhetrf_aa_2stage_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zhetrf_aa_2stage_(const char *uplo, const int *n, _Complex double *A, const int *lda, _Complex double *TB, const int *ltb, int *ipiv, int *ipiv2, _Complex double *work, const int *lwork, int *info, size_t)
     * }
     */
    public static void zhetrf_aa_2stage_(MemorySegment uplo, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment TB, MemorySegment ltb, MemorySegment ipiv, MemorySegment ipiv2, MemorySegment work, MemorySegment lwork, MemorySegment info, long x11) {
        var mh$ = zhetrf_aa_2stage_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zhetrf_aa_2stage_", uplo, n, A, lda, TB, ltb, ipiv, ipiv2, work, lwork, info, x11);
            }
            mh$.invokeExact(uplo, n, A, lda, TB, ltb, ipiv, ipiv2, work, lwork, info, x11);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class chetrf_rk_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("chetrf_rk_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void chetrf_rk_(const char *uplo, const int *n, _Complex float *A, const int *lda, _Complex float *E, int *ipiv, _Complex float *work, const int *lwork, int *info, size_t)
     * }
     */
    public static FunctionDescriptor chetrf_rk_$descriptor() {
        return chetrf_rk_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void chetrf_rk_(const char *uplo, const int *n, _Complex float *A, const int *lda, _Complex float *E, int *ipiv, _Complex float *work, const int *lwork, int *info, size_t)
     * }
     */
    public static MethodHandle chetrf_rk_$handle() {
        return chetrf_rk_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void chetrf_rk_(const char *uplo, const int *n, _Complex float *A, const int *lda, _Complex float *E, int *ipiv, _Complex float *work, const int *lwork, int *info, size_t)
     * }
     */
    public static MemorySegment chetrf_rk_$address() {
        return chetrf_rk_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void chetrf_rk_(const char *uplo, const int *n, _Complex float *A, const int *lda, _Complex float *E, int *ipiv, _Complex float *work, const int *lwork, int *info, size_t)
     * }
     */
    public static void chetrf_rk_(MemorySegment uplo, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment E, MemorySegment ipiv, MemorySegment work, MemorySegment lwork, MemorySegment info, long x9) {
        var mh$ = chetrf_rk_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("chetrf_rk_", uplo, n, A, lda, E, ipiv, work, lwork, info, x9);
            }
            mh$.invokeExact(uplo, n, A, lda, E, ipiv, work, lwork, info, x9);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zhetrf_rk_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("zhetrf_rk_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zhetrf_rk_(const char *uplo, const int *n, _Complex double *A, const int *lda, _Complex double *E, int *ipiv, _Complex double *work, const int *lwork, int *info, size_t)
     * }
     */
    public static FunctionDescriptor zhetrf_rk_$descriptor() {
        return zhetrf_rk_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zhetrf_rk_(const char *uplo, const int *n, _Complex double *A, const int *lda, _Complex double *E, int *ipiv, _Complex double *work, const int *lwork, int *info, size_t)
     * }
     */
    public static MethodHandle zhetrf_rk_$handle() {
        return zhetrf_rk_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zhetrf_rk_(const char *uplo, const int *n, _Complex double *A, const int *lda, _Complex double *E, int *ipiv, _Complex double *work, const int *lwork, int *info, size_t)
     * }
     */
    public static MemorySegment zhetrf_rk_$address() {
        return zhetrf_rk_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zhetrf_rk_(const char *uplo, const int *n, _Complex double *A, const int *lda, _Complex double *E, int *ipiv, _Complex double *work, const int *lwork, int *info, size_t)
     * }
     */
    public static void zhetrf_rk_(MemorySegment uplo, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment E, MemorySegment ipiv, MemorySegment work, MemorySegment lwork, MemorySegment info, long x9) {
        var mh$ = zhetrf_rk_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zhetrf_rk_", uplo, n, A, lda, E, ipiv, work, lwork, info, x9);
            }
            mh$.invokeExact(uplo, n, A, lda, E, ipiv, work, lwork, info, x9);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class chetrf_rook_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("chetrf_rook_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void chetrf_rook_(const char *uplo, const int *n, _Complex float *A, const int *lda, int *ipiv, _Complex float *work, const int *lwork, int *info, size_t)
     * }
     */
    public static FunctionDescriptor chetrf_rook_$descriptor() {
        return chetrf_rook_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void chetrf_rook_(const char *uplo, const int *n, _Complex float *A, const int *lda, int *ipiv, _Complex float *work, const int *lwork, int *info, size_t)
     * }
     */
    public static MethodHandle chetrf_rook_$handle() {
        return chetrf_rook_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void chetrf_rook_(const char *uplo, const int *n, _Complex float *A, const int *lda, int *ipiv, _Complex float *work, const int *lwork, int *info, size_t)
     * }
     */
    public static MemorySegment chetrf_rook_$address() {
        return chetrf_rook_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void chetrf_rook_(const char *uplo, const int *n, _Complex float *A, const int *lda, int *ipiv, _Complex float *work, const int *lwork, int *info, size_t)
     * }
     */
    public static void chetrf_rook_(MemorySegment uplo, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment ipiv, MemorySegment work, MemorySegment lwork, MemorySegment info, long x8) {
        var mh$ = chetrf_rook_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("chetrf_rook_", uplo, n, A, lda, ipiv, work, lwork, info, x8);
            }
            mh$.invokeExact(uplo, n, A, lda, ipiv, work, lwork, info, x8);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zhetrf_rook_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("zhetrf_rook_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zhetrf_rook_(const char *uplo, const int *n, _Complex double *A, const int *lda, int *ipiv, _Complex double *work, const int *lwork, int *info, size_t)
     * }
     */
    public static FunctionDescriptor zhetrf_rook_$descriptor() {
        return zhetrf_rook_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zhetrf_rook_(const char *uplo, const int *n, _Complex double *A, const int *lda, int *ipiv, _Complex double *work, const int *lwork, int *info, size_t)
     * }
     */
    public static MethodHandle zhetrf_rook_$handle() {
        return zhetrf_rook_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zhetrf_rook_(const char *uplo, const int *n, _Complex double *A, const int *lda, int *ipiv, _Complex double *work, const int *lwork, int *info, size_t)
     * }
     */
    public static MemorySegment zhetrf_rook_$address() {
        return zhetrf_rook_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zhetrf_rook_(const char *uplo, const int *n, _Complex double *A, const int *lda, int *ipiv, _Complex double *work, const int *lwork, int *info, size_t)
     * }
     */
    public static void zhetrf_rook_(MemorySegment uplo, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment ipiv, MemorySegment work, MemorySegment lwork, MemorySegment info, long x8) {
        var mh$ = zhetrf_rook_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zhetrf_rook_", uplo, n, A, lda, ipiv, work, lwork, info, x8);
            }
            mh$.invokeExact(uplo, n, A, lda, ipiv, work, lwork, info, x8);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class chetri_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("chetri_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void chetri_(const char *uplo, const int *n, _Complex float *A, const int *lda, const int *ipiv, _Complex float *work, int *info, size_t)
     * }
     */
    public static FunctionDescriptor chetri_$descriptor() {
        return chetri_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void chetri_(const char *uplo, const int *n, _Complex float *A, const int *lda, const int *ipiv, _Complex float *work, int *info, size_t)
     * }
     */
    public static MethodHandle chetri_$handle() {
        return chetri_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void chetri_(const char *uplo, const int *n, _Complex float *A, const int *lda, const int *ipiv, _Complex float *work, int *info, size_t)
     * }
     */
    public static MemorySegment chetri_$address() {
        return chetri_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void chetri_(const char *uplo, const int *n, _Complex float *A, const int *lda, const int *ipiv, _Complex float *work, int *info, size_t)
     * }
     */
    public static void chetri_(MemorySegment uplo, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment ipiv, MemorySegment work, MemorySegment info, long x7) {
        var mh$ = chetri_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("chetri_", uplo, n, A, lda, ipiv, work, info, x7);
            }
            mh$.invokeExact(uplo, n, A, lda, ipiv, work, info, x7);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zhetri_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("zhetri_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zhetri_(const char *uplo, const int *n, _Complex double *A, const int *lda, const int *ipiv, _Complex double *work, int *info, size_t)
     * }
     */
    public static FunctionDescriptor zhetri_$descriptor() {
        return zhetri_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zhetri_(const char *uplo, const int *n, _Complex double *A, const int *lda, const int *ipiv, _Complex double *work, int *info, size_t)
     * }
     */
    public static MethodHandle zhetri_$handle() {
        return zhetri_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zhetri_(const char *uplo, const int *n, _Complex double *A, const int *lda, const int *ipiv, _Complex double *work, int *info, size_t)
     * }
     */
    public static MemorySegment zhetri_$address() {
        return zhetri_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zhetri_(const char *uplo, const int *n, _Complex double *A, const int *lda, const int *ipiv, _Complex double *work, int *info, size_t)
     * }
     */
    public static void zhetri_(MemorySegment uplo, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment ipiv, MemorySegment work, MemorySegment info, long x7) {
        var mh$ = zhetri_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zhetri_", uplo, n, A, lda, ipiv, work, info, x7);
            }
            mh$.invokeExact(uplo, n, A, lda, ipiv, work, info, x7);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class chetri2_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("chetri2_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void chetri2_(const char *uplo, const int *n, _Complex float *A, const int *lda, const int *ipiv, _Complex float *work, const int *lwork, int *info, size_t)
     * }
     */
    public static FunctionDescriptor chetri2_$descriptor() {
        return chetri2_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void chetri2_(const char *uplo, const int *n, _Complex float *A, const int *lda, const int *ipiv, _Complex float *work, const int *lwork, int *info, size_t)
     * }
     */
    public static MethodHandle chetri2_$handle() {
        return chetri2_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void chetri2_(const char *uplo, const int *n, _Complex float *A, const int *lda, const int *ipiv, _Complex float *work, const int *lwork, int *info, size_t)
     * }
     */
    public static MemorySegment chetri2_$address() {
        return chetri2_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void chetri2_(const char *uplo, const int *n, _Complex float *A, const int *lda, const int *ipiv, _Complex float *work, const int *lwork, int *info, size_t)
     * }
     */
    public static void chetri2_(MemorySegment uplo, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment ipiv, MemorySegment work, MemorySegment lwork, MemorySegment info, long x8) {
        var mh$ = chetri2_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("chetri2_", uplo, n, A, lda, ipiv, work, lwork, info, x8);
            }
            mh$.invokeExact(uplo, n, A, lda, ipiv, work, lwork, info, x8);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zhetri2_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("zhetri2_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zhetri2_(const char *uplo, const int *n, _Complex double *A, const int *lda, const int *ipiv, _Complex double *work, const int *lwork, int *info, size_t)
     * }
     */
    public static FunctionDescriptor zhetri2_$descriptor() {
        return zhetri2_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zhetri2_(const char *uplo, const int *n, _Complex double *A, const int *lda, const int *ipiv, _Complex double *work, const int *lwork, int *info, size_t)
     * }
     */
    public static MethodHandle zhetri2_$handle() {
        return zhetri2_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zhetri2_(const char *uplo, const int *n, _Complex double *A, const int *lda, const int *ipiv, _Complex double *work, const int *lwork, int *info, size_t)
     * }
     */
    public static MemorySegment zhetri2_$address() {
        return zhetri2_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zhetri2_(const char *uplo, const int *n, _Complex double *A, const int *lda, const int *ipiv, _Complex double *work, const int *lwork, int *info, size_t)
     * }
     */
    public static void zhetri2_(MemorySegment uplo, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment ipiv, MemorySegment work, MemorySegment lwork, MemorySegment info, long x8) {
        var mh$ = zhetri2_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zhetri2_", uplo, n, A, lda, ipiv, work, lwork, info, x8);
            }
            mh$.invokeExact(uplo, n, A, lda, ipiv, work, lwork, info, x8);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class chetri2x_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("chetri2x_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void chetri2x_(const char *uplo, const int *n, _Complex float *A, const int *lda, const int *ipiv, _Complex float *work, const int *nb, int *info, size_t)
     * }
     */
    public static FunctionDescriptor chetri2x_$descriptor() {
        return chetri2x_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void chetri2x_(const char *uplo, const int *n, _Complex float *A, const int *lda, const int *ipiv, _Complex float *work, const int *nb, int *info, size_t)
     * }
     */
    public static MethodHandle chetri2x_$handle() {
        return chetri2x_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void chetri2x_(const char *uplo, const int *n, _Complex float *A, const int *lda, const int *ipiv, _Complex float *work, const int *nb, int *info, size_t)
     * }
     */
    public static MemorySegment chetri2x_$address() {
        return chetri2x_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void chetri2x_(const char *uplo, const int *n, _Complex float *A, const int *lda, const int *ipiv, _Complex float *work, const int *nb, int *info, size_t)
     * }
     */
    public static void chetri2x_(MemorySegment uplo, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment ipiv, MemorySegment work, MemorySegment nb, MemorySegment info, long x8) {
        var mh$ = chetri2x_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("chetri2x_", uplo, n, A, lda, ipiv, work, nb, info, x8);
            }
            mh$.invokeExact(uplo, n, A, lda, ipiv, work, nb, info, x8);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zhetri2x_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("zhetri2x_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zhetri2x_(const char *uplo, const int *n, _Complex double *A, const int *lda, const int *ipiv, _Complex double *work, const int *nb, int *info, size_t)
     * }
     */
    public static FunctionDescriptor zhetri2x_$descriptor() {
        return zhetri2x_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zhetri2x_(const char *uplo, const int *n, _Complex double *A, const int *lda, const int *ipiv, _Complex double *work, const int *nb, int *info, size_t)
     * }
     */
    public static MethodHandle zhetri2x_$handle() {
        return zhetri2x_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zhetri2x_(const char *uplo, const int *n, _Complex double *A, const int *lda, const int *ipiv, _Complex double *work, const int *nb, int *info, size_t)
     * }
     */
    public static MemorySegment zhetri2x_$address() {
        return zhetri2x_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zhetri2x_(const char *uplo, const int *n, _Complex double *A, const int *lda, const int *ipiv, _Complex double *work, const int *nb, int *info, size_t)
     * }
     */
    public static void zhetri2x_(MemorySegment uplo, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment ipiv, MemorySegment work, MemorySegment nb, MemorySegment info, long x8) {
        var mh$ = zhetri2x_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zhetri2x_", uplo, n, A, lda, ipiv, work, nb, info, x8);
            }
            mh$.invokeExact(uplo, n, A, lda, ipiv, work, nb, info, x8);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class chetri_3_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("chetri_3_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void chetri_3_(const char *uplo, const int *n, _Complex float *A, const int *lda, const _Complex float *E, const int *ipiv, _Complex float *work, const int *lwork, int *info, size_t)
     * }
     */
    public static FunctionDescriptor chetri_3_$descriptor() {
        return chetri_3_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void chetri_3_(const char *uplo, const int *n, _Complex float *A, const int *lda, const _Complex float *E, const int *ipiv, _Complex float *work, const int *lwork, int *info, size_t)
     * }
     */
    public static MethodHandle chetri_3_$handle() {
        return chetri_3_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void chetri_3_(const char *uplo, const int *n, _Complex float *A, const int *lda, const _Complex float *E, const int *ipiv, _Complex float *work, const int *lwork, int *info, size_t)
     * }
     */
    public static MemorySegment chetri_3_$address() {
        return chetri_3_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void chetri_3_(const char *uplo, const int *n, _Complex float *A, const int *lda, const _Complex float *E, const int *ipiv, _Complex float *work, const int *lwork, int *info, size_t)
     * }
     */
    public static void chetri_3_(MemorySegment uplo, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment E, MemorySegment ipiv, MemorySegment work, MemorySegment lwork, MemorySegment info, long x9) {
        var mh$ = chetri_3_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("chetri_3_", uplo, n, A, lda, E, ipiv, work, lwork, info, x9);
            }
            mh$.invokeExact(uplo, n, A, lda, E, ipiv, work, lwork, info, x9);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zhetri_3_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("zhetri_3_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zhetri_3_(const char *uplo, const int *n, _Complex double *A, const int *lda, const _Complex double *E, const int *ipiv, _Complex double *work, const int *lwork, int *info, size_t)
     * }
     */
    public static FunctionDescriptor zhetri_3_$descriptor() {
        return zhetri_3_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zhetri_3_(const char *uplo, const int *n, _Complex double *A, const int *lda, const _Complex double *E, const int *ipiv, _Complex double *work, const int *lwork, int *info, size_t)
     * }
     */
    public static MethodHandle zhetri_3_$handle() {
        return zhetri_3_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zhetri_3_(const char *uplo, const int *n, _Complex double *A, const int *lda, const _Complex double *E, const int *ipiv, _Complex double *work, const int *lwork, int *info, size_t)
     * }
     */
    public static MemorySegment zhetri_3_$address() {
        return zhetri_3_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zhetri_3_(const char *uplo, const int *n, _Complex double *A, const int *lda, const _Complex double *E, const int *ipiv, _Complex double *work, const int *lwork, int *info, size_t)
     * }
     */
    public static void zhetri_3_(MemorySegment uplo, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment E, MemorySegment ipiv, MemorySegment work, MemorySegment lwork, MemorySegment info, long x9) {
        var mh$ = zhetri_3_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zhetri_3_", uplo, n, A, lda, E, ipiv, work, lwork, info, x9);
            }
            mh$.invokeExact(uplo, n, A, lda, E, ipiv, work, lwork, info, x9);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class chetrs_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("chetrs_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void chetrs_(const char *uplo, const int *n, const int *nrhs, const _Complex float *A, const int *lda, const int *ipiv, _Complex float *B, const int *ldb, int *info, size_t)
     * }
     */
    public static FunctionDescriptor chetrs_$descriptor() {
        return chetrs_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void chetrs_(const char *uplo, const int *n, const int *nrhs, const _Complex float *A, const int *lda, const int *ipiv, _Complex float *B, const int *ldb, int *info, size_t)
     * }
     */
    public static MethodHandle chetrs_$handle() {
        return chetrs_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void chetrs_(const char *uplo, const int *n, const int *nrhs, const _Complex float *A, const int *lda, const int *ipiv, _Complex float *B, const int *ldb, int *info, size_t)
     * }
     */
    public static MemorySegment chetrs_$address() {
        return chetrs_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void chetrs_(const char *uplo, const int *n, const int *nrhs, const _Complex float *A, const int *lda, const int *ipiv, _Complex float *B, const int *ldb, int *info, size_t)
     * }
     */
    public static void chetrs_(MemorySegment uplo, MemorySegment n, MemorySegment nrhs, MemorySegment A, MemorySegment lda, MemorySegment ipiv, MemorySegment B, MemorySegment ldb, MemorySegment info, long x9) {
        var mh$ = chetrs_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("chetrs_", uplo, n, nrhs, A, lda, ipiv, B, ldb, info, x9);
            }
            mh$.invokeExact(uplo, n, nrhs, A, lda, ipiv, B, ldb, info, x9);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zhetrs_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("zhetrs_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zhetrs_(const char *uplo, const int *n, const int *nrhs, const _Complex double *A, const int *lda, const int *ipiv, _Complex double *B, const int *ldb, int *info, size_t)
     * }
     */
    public static FunctionDescriptor zhetrs_$descriptor() {
        return zhetrs_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zhetrs_(const char *uplo, const int *n, const int *nrhs, const _Complex double *A, const int *lda, const int *ipiv, _Complex double *B, const int *ldb, int *info, size_t)
     * }
     */
    public static MethodHandle zhetrs_$handle() {
        return zhetrs_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zhetrs_(const char *uplo, const int *n, const int *nrhs, const _Complex double *A, const int *lda, const int *ipiv, _Complex double *B, const int *ldb, int *info, size_t)
     * }
     */
    public static MemorySegment zhetrs_$address() {
        return zhetrs_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zhetrs_(const char *uplo, const int *n, const int *nrhs, const _Complex double *A, const int *lda, const int *ipiv, _Complex double *B, const int *ldb, int *info, size_t)
     * }
     */
    public static void zhetrs_(MemorySegment uplo, MemorySegment n, MemorySegment nrhs, MemorySegment A, MemorySegment lda, MemorySegment ipiv, MemorySegment B, MemorySegment ldb, MemorySegment info, long x9) {
        var mh$ = zhetrs_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zhetrs_", uplo, n, nrhs, A, lda, ipiv, B, ldb, info, x9);
            }
            mh$.invokeExact(uplo, n, nrhs, A, lda, ipiv, B, ldb, info, x9);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class chetrs2_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("chetrs2_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void chetrs2_(const char *uplo, const int *n, const int *nrhs, const _Complex float *A, const int *lda, const int *ipiv, _Complex float *B, const int *ldb, _Complex float *work, int *info, size_t)
     * }
     */
    public static FunctionDescriptor chetrs2_$descriptor() {
        return chetrs2_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void chetrs2_(const char *uplo, const int *n, const int *nrhs, const _Complex float *A, const int *lda, const int *ipiv, _Complex float *B, const int *ldb, _Complex float *work, int *info, size_t)
     * }
     */
    public static MethodHandle chetrs2_$handle() {
        return chetrs2_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void chetrs2_(const char *uplo, const int *n, const int *nrhs, const _Complex float *A, const int *lda, const int *ipiv, _Complex float *B, const int *ldb, _Complex float *work, int *info, size_t)
     * }
     */
    public static MemorySegment chetrs2_$address() {
        return chetrs2_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void chetrs2_(const char *uplo, const int *n, const int *nrhs, const _Complex float *A, const int *lda, const int *ipiv, _Complex float *B, const int *ldb, _Complex float *work, int *info, size_t)
     * }
     */
    public static void chetrs2_(MemorySegment uplo, MemorySegment n, MemorySegment nrhs, MemorySegment A, MemorySegment lda, MemorySegment ipiv, MemorySegment B, MemorySegment ldb, MemorySegment work, MemorySegment info, long x10) {
        var mh$ = chetrs2_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("chetrs2_", uplo, n, nrhs, A, lda, ipiv, B, ldb, work, info, x10);
            }
            mh$.invokeExact(uplo, n, nrhs, A, lda, ipiv, B, ldb, work, info, x10);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zhetrs2_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("zhetrs2_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zhetrs2_(const char *uplo, const int *n, const int *nrhs, const _Complex double *A, const int *lda, const int *ipiv, _Complex double *B, const int *ldb, _Complex double *work, int *info, size_t)
     * }
     */
    public static FunctionDescriptor zhetrs2_$descriptor() {
        return zhetrs2_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zhetrs2_(const char *uplo, const int *n, const int *nrhs, const _Complex double *A, const int *lda, const int *ipiv, _Complex double *B, const int *ldb, _Complex double *work, int *info, size_t)
     * }
     */
    public static MethodHandle zhetrs2_$handle() {
        return zhetrs2_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zhetrs2_(const char *uplo, const int *n, const int *nrhs, const _Complex double *A, const int *lda, const int *ipiv, _Complex double *B, const int *ldb, _Complex double *work, int *info, size_t)
     * }
     */
    public static MemorySegment zhetrs2_$address() {
        return zhetrs2_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zhetrs2_(const char *uplo, const int *n, const int *nrhs, const _Complex double *A, const int *lda, const int *ipiv, _Complex double *B, const int *ldb, _Complex double *work, int *info, size_t)
     * }
     */
    public static void zhetrs2_(MemorySegment uplo, MemorySegment n, MemorySegment nrhs, MemorySegment A, MemorySegment lda, MemorySegment ipiv, MemorySegment B, MemorySegment ldb, MemorySegment work, MemorySegment info, long x10) {
        var mh$ = zhetrs2_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zhetrs2_", uplo, n, nrhs, A, lda, ipiv, B, ldb, work, info, x10);
            }
            mh$.invokeExact(uplo, n, nrhs, A, lda, ipiv, B, ldb, work, info, x10);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class chetrs_3_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("chetrs_3_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void chetrs_3_(const char *uplo, const int *n, const int *nrhs, const _Complex float *A, const int *lda, const _Complex float *E, const int *ipiv, _Complex float *B, const int *ldb, int *info, size_t)
     * }
     */
    public static FunctionDescriptor chetrs_3_$descriptor() {
        return chetrs_3_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void chetrs_3_(const char *uplo, const int *n, const int *nrhs, const _Complex float *A, const int *lda, const _Complex float *E, const int *ipiv, _Complex float *B, const int *ldb, int *info, size_t)
     * }
     */
    public static MethodHandle chetrs_3_$handle() {
        return chetrs_3_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void chetrs_3_(const char *uplo, const int *n, const int *nrhs, const _Complex float *A, const int *lda, const _Complex float *E, const int *ipiv, _Complex float *B, const int *ldb, int *info, size_t)
     * }
     */
    public static MemorySegment chetrs_3_$address() {
        return chetrs_3_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void chetrs_3_(const char *uplo, const int *n, const int *nrhs, const _Complex float *A, const int *lda, const _Complex float *E, const int *ipiv, _Complex float *B, const int *ldb, int *info, size_t)
     * }
     */
    public static void chetrs_3_(MemorySegment uplo, MemorySegment n, MemorySegment nrhs, MemorySegment A, MemorySegment lda, MemorySegment E, MemorySegment ipiv, MemorySegment B, MemorySegment ldb, MemorySegment info, long x10) {
        var mh$ = chetrs_3_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("chetrs_3_", uplo, n, nrhs, A, lda, E, ipiv, B, ldb, info, x10);
            }
            mh$.invokeExact(uplo, n, nrhs, A, lda, E, ipiv, B, ldb, info, x10);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zhetrs_3_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("zhetrs_3_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zhetrs_3_(const char *uplo, const int *n, const int *nrhs, const _Complex double *A, const int *lda, const _Complex double *E, const int *ipiv, _Complex double *B, const int *ldb, int *info, size_t)
     * }
     */
    public static FunctionDescriptor zhetrs_3_$descriptor() {
        return zhetrs_3_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zhetrs_3_(const char *uplo, const int *n, const int *nrhs, const _Complex double *A, const int *lda, const _Complex double *E, const int *ipiv, _Complex double *B, const int *ldb, int *info, size_t)
     * }
     */
    public static MethodHandle zhetrs_3_$handle() {
        return zhetrs_3_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zhetrs_3_(const char *uplo, const int *n, const int *nrhs, const _Complex double *A, const int *lda, const _Complex double *E, const int *ipiv, _Complex double *B, const int *ldb, int *info, size_t)
     * }
     */
    public static MemorySegment zhetrs_3_$address() {
        return zhetrs_3_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zhetrs_3_(const char *uplo, const int *n, const int *nrhs, const _Complex double *A, const int *lda, const _Complex double *E, const int *ipiv, _Complex double *B, const int *ldb, int *info, size_t)
     * }
     */
    public static void zhetrs_3_(MemorySegment uplo, MemorySegment n, MemorySegment nrhs, MemorySegment A, MemorySegment lda, MemorySegment E, MemorySegment ipiv, MemorySegment B, MemorySegment ldb, MemorySegment info, long x10) {
        var mh$ = zhetrs_3_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zhetrs_3_", uplo, n, nrhs, A, lda, E, ipiv, B, ldb, info, x10);
            }
            mh$.invokeExact(uplo, n, nrhs, A, lda, E, ipiv, B, ldb, info, x10);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class chetrs_aa_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("chetrs_aa_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void chetrs_aa_(const char *uplo, const int *n, const int *nrhs, const _Complex float *A, const int *lda, const int *ipiv, _Complex float *B, const int *ldb, _Complex float *work, const int *lwork, int *info, size_t)
     * }
     */
    public static FunctionDescriptor chetrs_aa_$descriptor() {
        return chetrs_aa_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void chetrs_aa_(const char *uplo, const int *n, const int *nrhs, const _Complex float *A, const int *lda, const int *ipiv, _Complex float *B, const int *ldb, _Complex float *work, const int *lwork, int *info, size_t)
     * }
     */
    public static MethodHandle chetrs_aa_$handle() {
        return chetrs_aa_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void chetrs_aa_(const char *uplo, const int *n, const int *nrhs, const _Complex float *A, const int *lda, const int *ipiv, _Complex float *B, const int *ldb, _Complex float *work, const int *lwork, int *info, size_t)
     * }
     */
    public static MemorySegment chetrs_aa_$address() {
        return chetrs_aa_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void chetrs_aa_(const char *uplo, const int *n, const int *nrhs, const _Complex float *A, const int *lda, const int *ipiv, _Complex float *B, const int *ldb, _Complex float *work, const int *lwork, int *info, size_t)
     * }
     */
    public static void chetrs_aa_(MemorySegment uplo, MemorySegment n, MemorySegment nrhs, MemorySegment A, MemorySegment lda, MemorySegment ipiv, MemorySegment B, MemorySegment ldb, MemorySegment work, MemorySegment lwork, MemorySegment info, long x11) {
        var mh$ = chetrs_aa_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("chetrs_aa_", uplo, n, nrhs, A, lda, ipiv, B, ldb, work, lwork, info, x11);
            }
            mh$.invokeExact(uplo, n, nrhs, A, lda, ipiv, B, ldb, work, lwork, info, x11);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zhetrs_aa_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("zhetrs_aa_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zhetrs_aa_(const char *uplo, const int *n, const int *nrhs, const _Complex double *A, const int *lda, const int *ipiv, _Complex double *B, const int *ldb, _Complex double *work, const int *lwork, int *info, size_t)
     * }
     */
    public static FunctionDescriptor zhetrs_aa_$descriptor() {
        return zhetrs_aa_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zhetrs_aa_(const char *uplo, const int *n, const int *nrhs, const _Complex double *A, const int *lda, const int *ipiv, _Complex double *B, const int *ldb, _Complex double *work, const int *lwork, int *info, size_t)
     * }
     */
    public static MethodHandle zhetrs_aa_$handle() {
        return zhetrs_aa_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zhetrs_aa_(const char *uplo, const int *n, const int *nrhs, const _Complex double *A, const int *lda, const int *ipiv, _Complex double *B, const int *ldb, _Complex double *work, const int *lwork, int *info, size_t)
     * }
     */
    public static MemorySegment zhetrs_aa_$address() {
        return zhetrs_aa_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zhetrs_aa_(const char *uplo, const int *n, const int *nrhs, const _Complex double *A, const int *lda, const int *ipiv, _Complex double *B, const int *ldb, _Complex double *work, const int *lwork, int *info, size_t)
     * }
     */
    public static void zhetrs_aa_(MemorySegment uplo, MemorySegment n, MemorySegment nrhs, MemorySegment A, MemorySegment lda, MemorySegment ipiv, MemorySegment B, MemorySegment ldb, MemorySegment work, MemorySegment lwork, MemorySegment info, long x11) {
        var mh$ = zhetrs_aa_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zhetrs_aa_", uplo, n, nrhs, A, lda, ipiv, B, ldb, work, lwork, info, x11);
            }
            mh$.invokeExact(uplo, n, nrhs, A, lda, ipiv, B, ldb, work, lwork, info, x11);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class chetrs_aa_2stage_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("chetrs_aa_2stage_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void chetrs_aa_2stage_(const char *uplo, const int *n, const int *nrhs, const _Complex float *A, const int *lda, _Complex float *TB, const int *ltb, const int *ipiv, const int *ipiv2, _Complex float *B, const int *ldb, int *info, size_t)
     * }
     */
    public static FunctionDescriptor chetrs_aa_2stage_$descriptor() {
        return chetrs_aa_2stage_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void chetrs_aa_2stage_(const char *uplo, const int *n, const int *nrhs, const _Complex float *A, const int *lda, _Complex float *TB, const int *ltb, const int *ipiv, const int *ipiv2, _Complex float *B, const int *ldb, int *info, size_t)
     * }
     */
    public static MethodHandle chetrs_aa_2stage_$handle() {
        return chetrs_aa_2stage_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void chetrs_aa_2stage_(const char *uplo, const int *n, const int *nrhs, const _Complex float *A, const int *lda, _Complex float *TB, const int *ltb, const int *ipiv, const int *ipiv2, _Complex float *B, const int *ldb, int *info, size_t)
     * }
     */
    public static MemorySegment chetrs_aa_2stage_$address() {
        return chetrs_aa_2stage_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void chetrs_aa_2stage_(const char *uplo, const int *n, const int *nrhs, const _Complex float *A, const int *lda, _Complex float *TB, const int *ltb, const int *ipiv, const int *ipiv2, _Complex float *B, const int *ldb, int *info, size_t)
     * }
     */
    public static void chetrs_aa_2stage_(MemorySegment uplo, MemorySegment n, MemorySegment nrhs, MemorySegment A, MemorySegment lda, MemorySegment TB, MemorySegment ltb, MemorySegment ipiv, MemorySegment ipiv2, MemorySegment B, MemorySegment ldb, MemorySegment info, long x12) {
        var mh$ = chetrs_aa_2stage_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("chetrs_aa_2stage_", uplo, n, nrhs, A, lda, TB, ltb, ipiv, ipiv2, B, ldb, info, x12);
            }
            mh$.invokeExact(uplo, n, nrhs, A, lda, TB, ltb, ipiv, ipiv2, B, ldb, info, x12);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zhetrs_aa_2stage_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("zhetrs_aa_2stage_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zhetrs_aa_2stage_(const char *uplo, const int *n, const int *nrhs, const _Complex double *A, const int *lda, _Complex double *TB, const int *ltb, const int *ipiv, const int *ipiv2, _Complex double *B, const int *ldb, int *info, size_t)
     * }
     */
    public static FunctionDescriptor zhetrs_aa_2stage_$descriptor() {
        return zhetrs_aa_2stage_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zhetrs_aa_2stage_(const char *uplo, const int *n, const int *nrhs, const _Complex double *A, const int *lda, _Complex double *TB, const int *ltb, const int *ipiv, const int *ipiv2, _Complex double *B, const int *ldb, int *info, size_t)
     * }
     */
    public static MethodHandle zhetrs_aa_2stage_$handle() {
        return zhetrs_aa_2stage_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zhetrs_aa_2stage_(const char *uplo, const int *n, const int *nrhs, const _Complex double *A, const int *lda, _Complex double *TB, const int *ltb, const int *ipiv, const int *ipiv2, _Complex double *B, const int *ldb, int *info, size_t)
     * }
     */
    public static MemorySegment zhetrs_aa_2stage_$address() {
        return zhetrs_aa_2stage_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zhetrs_aa_2stage_(const char *uplo, const int *n, const int *nrhs, const _Complex double *A, const int *lda, _Complex double *TB, const int *ltb, const int *ipiv, const int *ipiv2, _Complex double *B, const int *ldb, int *info, size_t)
     * }
     */
    public static void zhetrs_aa_2stage_(MemorySegment uplo, MemorySegment n, MemorySegment nrhs, MemorySegment A, MemorySegment lda, MemorySegment TB, MemorySegment ltb, MemorySegment ipiv, MemorySegment ipiv2, MemorySegment B, MemorySegment ldb, MemorySegment info, long x12) {
        var mh$ = zhetrs_aa_2stage_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zhetrs_aa_2stage_", uplo, n, nrhs, A, lda, TB, ltb, ipiv, ipiv2, B, ldb, info, x12);
            }
            mh$.invokeExact(uplo, n, nrhs, A, lda, TB, ltb, ipiv, ipiv2, B, ldb, info, x12);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class chetrs_rook_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("chetrs_rook_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void chetrs_rook_(const char *uplo, const int *n, const int *nrhs, const _Complex float *A, const int *lda, const int *ipiv, _Complex float *B, const int *ldb, int *info, size_t)
     * }
     */
    public static FunctionDescriptor chetrs_rook_$descriptor() {
        return chetrs_rook_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void chetrs_rook_(const char *uplo, const int *n, const int *nrhs, const _Complex float *A, const int *lda, const int *ipiv, _Complex float *B, const int *ldb, int *info, size_t)
     * }
     */
    public static MethodHandle chetrs_rook_$handle() {
        return chetrs_rook_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void chetrs_rook_(const char *uplo, const int *n, const int *nrhs, const _Complex float *A, const int *lda, const int *ipiv, _Complex float *B, const int *ldb, int *info, size_t)
     * }
     */
    public static MemorySegment chetrs_rook_$address() {
        return chetrs_rook_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void chetrs_rook_(const char *uplo, const int *n, const int *nrhs, const _Complex float *A, const int *lda, const int *ipiv, _Complex float *B, const int *ldb, int *info, size_t)
     * }
     */
    public static void chetrs_rook_(MemorySegment uplo, MemorySegment n, MemorySegment nrhs, MemorySegment A, MemorySegment lda, MemorySegment ipiv, MemorySegment B, MemorySegment ldb, MemorySegment info, long x9) {
        var mh$ = chetrs_rook_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("chetrs_rook_", uplo, n, nrhs, A, lda, ipiv, B, ldb, info, x9);
            }
            mh$.invokeExact(uplo, n, nrhs, A, lda, ipiv, B, ldb, info, x9);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zhetrs_rook_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("zhetrs_rook_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zhetrs_rook_(const char *uplo, const int *n, const int *nrhs, const _Complex double *A, const int *lda, const int *ipiv, _Complex double *B, const int *ldb, int *info, size_t)
     * }
     */
    public static FunctionDescriptor zhetrs_rook_$descriptor() {
        return zhetrs_rook_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zhetrs_rook_(const char *uplo, const int *n, const int *nrhs, const _Complex double *A, const int *lda, const int *ipiv, _Complex double *B, const int *ldb, int *info, size_t)
     * }
     */
    public static MethodHandle zhetrs_rook_$handle() {
        return zhetrs_rook_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zhetrs_rook_(const char *uplo, const int *n, const int *nrhs, const _Complex double *A, const int *lda, const int *ipiv, _Complex double *B, const int *ldb, int *info, size_t)
     * }
     */
    public static MemorySegment zhetrs_rook_$address() {
        return zhetrs_rook_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zhetrs_rook_(const char *uplo, const int *n, const int *nrhs, const _Complex double *A, const int *lda, const int *ipiv, _Complex double *B, const int *ldb, int *info, size_t)
     * }
     */
    public static void zhetrs_rook_(MemorySegment uplo, MemorySegment n, MemorySegment nrhs, MemorySegment A, MemorySegment lda, MemorySegment ipiv, MemorySegment B, MemorySegment ldb, MemorySegment info, long x9) {
        var mh$ = zhetrs_rook_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zhetrs_rook_", uplo, n, nrhs, A, lda, ipiv, B, ldb, info, x9);
            }
            mh$.invokeExact(uplo, n, nrhs, A, lda, ipiv, B, ldb, info, x9);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class chfrk_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("chfrk_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void chfrk_(const char *transr, const char *uplo, const char *trans, const int *n, const int *k, const float *alpha, const _Complex float *A, const int *lda, const float *beta, _Complex float *C, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor chfrk_$descriptor() {
        return chfrk_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void chfrk_(const char *transr, const char *uplo, const char *trans, const int *n, const int *k, const float *alpha, const _Complex float *A, const int *lda, const float *beta, _Complex float *C, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle chfrk_$handle() {
        return chfrk_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void chfrk_(const char *transr, const char *uplo, const char *trans, const int *n, const int *k, const float *alpha, const _Complex float *A, const int *lda, const float *beta, _Complex float *C, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment chfrk_$address() {
        return chfrk_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void chfrk_(const char *transr, const char *uplo, const char *trans, const int *n, const int *k, const float *alpha, const _Complex float *A, const int *lda, const float *beta, _Complex float *C, size_t, size_t, size_t)
     * }
     */
    public static void chfrk_(MemorySegment transr, MemorySegment uplo, MemorySegment trans, MemorySegment n, MemorySegment k, MemorySegment alpha, MemorySegment A, MemorySegment lda, MemorySegment beta, MemorySegment C, long x10, long x11, long x12) {
        var mh$ = chfrk_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("chfrk_", transr, uplo, trans, n, k, alpha, A, lda, beta, C, x10, x11, x12);
            }
            mh$.invokeExact(transr, uplo, trans, n, k, alpha, A, lda, beta, C, x10, x11, x12);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zhfrk_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("zhfrk_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zhfrk_(const char *transr, const char *uplo, const char *trans, const int *n, const int *k, const double *alpha, const _Complex double *A, const int *lda, const double *beta, _Complex double *C, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor zhfrk_$descriptor() {
        return zhfrk_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zhfrk_(const char *transr, const char *uplo, const char *trans, const int *n, const int *k, const double *alpha, const _Complex double *A, const int *lda, const double *beta, _Complex double *C, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle zhfrk_$handle() {
        return zhfrk_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zhfrk_(const char *transr, const char *uplo, const char *trans, const int *n, const int *k, const double *alpha, const _Complex double *A, const int *lda, const double *beta, _Complex double *C, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment zhfrk_$address() {
        return zhfrk_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zhfrk_(const char *transr, const char *uplo, const char *trans, const int *n, const int *k, const double *alpha, const _Complex double *A, const int *lda, const double *beta, _Complex double *C, size_t, size_t, size_t)
     * }
     */
    public static void zhfrk_(MemorySegment transr, MemorySegment uplo, MemorySegment trans, MemorySegment n, MemorySegment k, MemorySegment alpha, MemorySegment A, MemorySegment lda, MemorySegment beta, MemorySegment C, long x10, long x11, long x12) {
        var mh$ = zhfrk_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zhfrk_", transr, uplo, trans, n, k, alpha, A, lda, beta, C, x10, x11, x12);
            }
            mh$.invokeExact(transr, uplo, trans, n, k, alpha, A, lda, beta, C, x10, x11, x12);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class chgeqz_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("chgeqz_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void chgeqz_(const char *job, const char *compq, const char *compz, const int *n, const int *ilo, const int *ihi, _Complex float *H, const int *ldh, _Complex float *T, const int *ldt, _Complex float *alpha, _Complex float *beta, _Complex float *Q, const int *ldq, _Complex float *Z, const int *ldz, _Complex float *work, const int *lwork, float *rwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor chgeqz_$descriptor() {
        return chgeqz_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void chgeqz_(const char *job, const char *compq, const char *compz, const int *n, const int *ilo, const int *ihi, _Complex float *H, const int *ldh, _Complex float *T, const int *ldt, _Complex float *alpha, _Complex float *beta, _Complex float *Q, const int *ldq, _Complex float *Z, const int *ldz, _Complex float *work, const int *lwork, float *rwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle chgeqz_$handle() {
        return chgeqz_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void chgeqz_(const char *job, const char *compq, const char *compz, const int *n, const int *ilo, const int *ihi, _Complex float *H, const int *ldh, _Complex float *T, const int *ldt, _Complex float *alpha, _Complex float *beta, _Complex float *Q, const int *ldq, _Complex float *Z, const int *ldz, _Complex float *work, const int *lwork, float *rwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment chgeqz_$address() {
        return chgeqz_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void chgeqz_(const char *job, const char *compq, const char *compz, const int *n, const int *ilo, const int *ihi, _Complex float *H, const int *ldh, _Complex float *T, const int *ldt, _Complex float *alpha, _Complex float *beta, _Complex float *Q, const int *ldq, _Complex float *Z, const int *ldz, _Complex float *work, const int *lwork, float *rwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static void chgeqz_(MemorySegment job, MemorySegment compq, MemorySegment compz, MemorySegment n, MemorySegment ilo, MemorySegment ihi, MemorySegment H, MemorySegment ldh, MemorySegment T, MemorySegment ldt, MemorySegment alpha, MemorySegment beta, MemorySegment Q, MemorySegment ldq, MemorySegment Z, MemorySegment ldz, MemorySegment work, MemorySegment lwork, MemorySegment rwork, MemorySegment info, long x20, long x21, long x22) {
        var mh$ = chgeqz_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("chgeqz_", job, compq, compz, n, ilo, ihi, H, ldh, T, ldt, alpha, beta, Q, ldq, Z, ldz, work, lwork, rwork, info, x20, x21, x22);
            }
            mh$.invokeExact(job, compq, compz, n, ilo, ihi, H, ldh, T, ldt, alpha, beta, Q, ldq, Z, ldz, work, lwork, rwork, info, x20, x21, x22);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dhgeqz_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("dhgeqz_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dhgeqz_(const char *job, const char *compq, const char *compz, const int *n, const int *ilo, const int *ihi, double *H, const int *ldh, double *T, const int *ldt, double *alphar, double *alphai, double *beta, double *Q, const int *ldq, double *Z, const int *ldz, double *work, const int *lwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor dhgeqz_$descriptor() {
        return dhgeqz_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dhgeqz_(const char *job, const char *compq, const char *compz, const int *n, const int *ilo, const int *ihi, double *H, const int *ldh, double *T, const int *ldt, double *alphar, double *alphai, double *beta, double *Q, const int *ldq, double *Z, const int *ldz, double *work, const int *lwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle dhgeqz_$handle() {
        return dhgeqz_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dhgeqz_(const char *job, const char *compq, const char *compz, const int *n, const int *ilo, const int *ihi, double *H, const int *ldh, double *T, const int *ldt, double *alphar, double *alphai, double *beta, double *Q, const int *ldq, double *Z, const int *ldz, double *work, const int *lwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment dhgeqz_$address() {
        return dhgeqz_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dhgeqz_(const char *job, const char *compq, const char *compz, const int *n, const int *ilo, const int *ihi, double *H, const int *ldh, double *T, const int *ldt, double *alphar, double *alphai, double *beta, double *Q, const int *ldq, double *Z, const int *ldz, double *work, const int *lwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static void dhgeqz_(MemorySegment job, MemorySegment compq, MemorySegment compz, MemorySegment n, MemorySegment ilo, MemorySegment ihi, MemorySegment H, MemorySegment ldh, MemorySegment T, MemorySegment ldt, MemorySegment alphar, MemorySegment alphai, MemorySegment beta, MemorySegment Q, MemorySegment ldq, MemorySegment Z, MemorySegment ldz, MemorySegment work, MemorySegment lwork, MemorySegment info, long x20, long x21, long x22) {
        var mh$ = dhgeqz_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dhgeqz_", job, compq, compz, n, ilo, ihi, H, ldh, T, ldt, alphar, alphai, beta, Q, ldq, Z, ldz, work, lwork, info, x20, x21, x22);
            }
            mh$.invokeExact(job, compq, compz, n, ilo, ihi, H, ldh, T, ldt, alphar, alphai, beta, Q, ldq, Z, ldz, work, lwork, info, x20, x21, x22);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class shgeqz_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("shgeqz_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void shgeqz_(const char *job, const char *compq, const char *compz, const int *n, const int *ilo, const int *ihi, float *H, const int *ldh, float *T, const int *ldt, float *alphar, float *alphai, float *beta, float *Q, const int *ldq, float *Z, const int *ldz, float *work, const int *lwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor shgeqz_$descriptor() {
        return shgeqz_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void shgeqz_(const char *job, const char *compq, const char *compz, const int *n, const int *ilo, const int *ihi, float *H, const int *ldh, float *T, const int *ldt, float *alphar, float *alphai, float *beta, float *Q, const int *ldq, float *Z, const int *ldz, float *work, const int *lwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle shgeqz_$handle() {
        return shgeqz_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void shgeqz_(const char *job, const char *compq, const char *compz, const int *n, const int *ilo, const int *ihi, float *H, const int *ldh, float *T, const int *ldt, float *alphar, float *alphai, float *beta, float *Q, const int *ldq, float *Z, const int *ldz, float *work, const int *lwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment shgeqz_$address() {
        return shgeqz_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void shgeqz_(const char *job, const char *compq, const char *compz, const int *n, const int *ilo, const int *ihi, float *H, const int *ldh, float *T, const int *ldt, float *alphar, float *alphai, float *beta, float *Q, const int *ldq, float *Z, const int *ldz, float *work, const int *lwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static void shgeqz_(MemorySegment job, MemorySegment compq, MemorySegment compz, MemorySegment n, MemorySegment ilo, MemorySegment ihi, MemorySegment H, MemorySegment ldh, MemorySegment T, MemorySegment ldt, MemorySegment alphar, MemorySegment alphai, MemorySegment beta, MemorySegment Q, MemorySegment ldq, MemorySegment Z, MemorySegment ldz, MemorySegment work, MemorySegment lwork, MemorySegment info, long x20, long x21, long x22) {
        var mh$ = shgeqz_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("shgeqz_", job, compq, compz, n, ilo, ihi, H, ldh, T, ldt, alphar, alphai, beta, Q, ldq, Z, ldz, work, lwork, info, x20, x21, x22);
            }
            mh$.invokeExact(job, compq, compz, n, ilo, ihi, H, ldh, T, ldt, alphar, alphai, beta, Q, ldq, Z, ldz, work, lwork, info, x20, x21, x22);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zhgeqz_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("zhgeqz_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zhgeqz_(const char *job, const char *compq, const char *compz, const int *n, const int *ilo, const int *ihi, _Complex double *H, const int *ldh, _Complex double *T, const int *ldt, _Complex double *alpha, _Complex double *beta, _Complex double *Q, const int *ldq, _Complex double *Z, const int *ldz, _Complex double *work, const int *lwork, double *rwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor zhgeqz_$descriptor() {
        return zhgeqz_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zhgeqz_(const char *job, const char *compq, const char *compz, const int *n, const int *ilo, const int *ihi, _Complex double *H, const int *ldh, _Complex double *T, const int *ldt, _Complex double *alpha, _Complex double *beta, _Complex double *Q, const int *ldq, _Complex double *Z, const int *ldz, _Complex double *work, const int *lwork, double *rwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle zhgeqz_$handle() {
        return zhgeqz_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zhgeqz_(const char *job, const char *compq, const char *compz, const int *n, const int *ilo, const int *ihi, _Complex double *H, const int *ldh, _Complex double *T, const int *ldt, _Complex double *alpha, _Complex double *beta, _Complex double *Q, const int *ldq, _Complex double *Z, const int *ldz, _Complex double *work, const int *lwork, double *rwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment zhgeqz_$address() {
        return zhgeqz_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zhgeqz_(const char *job, const char *compq, const char *compz, const int *n, const int *ilo, const int *ihi, _Complex double *H, const int *ldh, _Complex double *T, const int *ldt, _Complex double *alpha, _Complex double *beta, _Complex double *Q, const int *ldq, _Complex double *Z, const int *ldz, _Complex double *work, const int *lwork, double *rwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static void zhgeqz_(MemorySegment job, MemorySegment compq, MemorySegment compz, MemorySegment n, MemorySegment ilo, MemorySegment ihi, MemorySegment H, MemorySegment ldh, MemorySegment T, MemorySegment ldt, MemorySegment alpha, MemorySegment beta, MemorySegment Q, MemorySegment ldq, MemorySegment Z, MemorySegment ldz, MemorySegment work, MemorySegment lwork, MemorySegment rwork, MemorySegment info, long x20, long x21, long x22) {
        var mh$ = zhgeqz_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zhgeqz_", job, compq, compz, n, ilo, ihi, H, ldh, T, ldt, alpha, beta, Q, ldq, Z, ldz, work, lwork, rwork, info, x20, x21, x22);
            }
            mh$.invokeExact(job, compq, compz, n, ilo, ihi, H, ldh, T, ldt, alpha, beta, Q, ldq, Z, ldz, work, lwork, rwork, info, x20, x21, x22);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class chpcon_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("chpcon_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void chpcon_(const char *uplo, const int *n, const _Complex float *AP, const int *ipiv, const float *anorm, float *rcond, _Complex float *work, int *info, size_t)
     * }
     */
    public static FunctionDescriptor chpcon_$descriptor() {
        return chpcon_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void chpcon_(const char *uplo, const int *n, const _Complex float *AP, const int *ipiv, const float *anorm, float *rcond, _Complex float *work, int *info, size_t)
     * }
     */
    public static MethodHandle chpcon_$handle() {
        return chpcon_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void chpcon_(const char *uplo, const int *n, const _Complex float *AP, const int *ipiv, const float *anorm, float *rcond, _Complex float *work, int *info, size_t)
     * }
     */
    public static MemorySegment chpcon_$address() {
        return chpcon_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void chpcon_(const char *uplo, const int *n, const _Complex float *AP, const int *ipiv, const float *anorm, float *rcond, _Complex float *work, int *info, size_t)
     * }
     */
    public static void chpcon_(MemorySegment uplo, MemorySegment n, MemorySegment AP, MemorySegment ipiv, MemorySegment anorm, MemorySegment rcond, MemorySegment work, MemorySegment info, long x8) {
        var mh$ = chpcon_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("chpcon_", uplo, n, AP, ipiv, anorm, rcond, work, info, x8);
            }
            mh$.invokeExact(uplo, n, AP, ipiv, anorm, rcond, work, info, x8);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zhpcon_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("zhpcon_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zhpcon_(const char *uplo, const int *n, const _Complex double *AP, const int *ipiv, const double *anorm, double *rcond, _Complex double *work, int *info, size_t)
     * }
     */
    public static FunctionDescriptor zhpcon_$descriptor() {
        return zhpcon_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zhpcon_(const char *uplo, const int *n, const _Complex double *AP, const int *ipiv, const double *anorm, double *rcond, _Complex double *work, int *info, size_t)
     * }
     */
    public static MethodHandle zhpcon_$handle() {
        return zhpcon_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zhpcon_(const char *uplo, const int *n, const _Complex double *AP, const int *ipiv, const double *anorm, double *rcond, _Complex double *work, int *info, size_t)
     * }
     */
    public static MemorySegment zhpcon_$address() {
        return zhpcon_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zhpcon_(const char *uplo, const int *n, const _Complex double *AP, const int *ipiv, const double *anorm, double *rcond, _Complex double *work, int *info, size_t)
     * }
     */
    public static void zhpcon_(MemorySegment uplo, MemorySegment n, MemorySegment AP, MemorySegment ipiv, MemorySegment anorm, MemorySegment rcond, MemorySegment work, MemorySegment info, long x8) {
        var mh$ = zhpcon_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zhpcon_", uplo, n, AP, ipiv, anorm, rcond, work, info, x8);
            }
            mh$.invokeExact(uplo, n, AP, ipiv, anorm, rcond, work, info, x8);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class chpev_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("chpev_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void chpev_(const char *jobz, const char *uplo, const int *n, _Complex float *AP, float *W, _Complex float *Z, const int *ldz, _Complex float *work, float *rwork, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor chpev_$descriptor() {
        return chpev_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void chpev_(const char *jobz, const char *uplo, const int *n, _Complex float *AP, float *W, _Complex float *Z, const int *ldz, _Complex float *work, float *rwork, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle chpev_$handle() {
        return chpev_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void chpev_(const char *jobz, const char *uplo, const int *n, _Complex float *AP, float *W, _Complex float *Z, const int *ldz, _Complex float *work, float *rwork, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment chpev_$address() {
        return chpev_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void chpev_(const char *jobz, const char *uplo, const int *n, _Complex float *AP, float *W, _Complex float *Z, const int *ldz, _Complex float *work, float *rwork, int *info, size_t, size_t)
     * }
     */
    public static void chpev_(MemorySegment jobz, MemorySegment uplo, MemorySegment n, MemorySegment AP, MemorySegment W, MemorySegment Z, MemorySegment ldz, MemorySegment work, MemorySegment rwork, MemorySegment info, long x10, long x11) {
        var mh$ = chpev_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("chpev_", jobz, uplo, n, AP, W, Z, ldz, work, rwork, info, x10, x11);
            }
            mh$.invokeExact(jobz, uplo, n, AP, W, Z, ldz, work, rwork, info, x10, x11);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zhpev_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("zhpev_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zhpev_(const char *jobz, const char *uplo, const int *n, _Complex double *AP, double *W, _Complex double *Z, const int *ldz, _Complex double *work, double *rwork, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor zhpev_$descriptor() {
        return zhpev_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zhpev_(const char *jobz, const char *uplo, const int *n, _Complex double *AP, double *W, _Complex double *Z, const int *ldz, _Complex double *work, double *rwork, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle zhpev_$handle() {
        return zhpev_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zhpev_(const char *jobz, const char *uplo, const int *n, _Complex double *AP, double *W, _Complex double *Z, const int *ldz, _Complex double *work, double *rwork, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment zhpev_$address() {
        return zhpev_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zhpev_(const char *jobz, const char *uplo, const int *n, _Complex double *AP, double *W, _Complex double *Z, const int *ldz, _Complex double *work, double *rwork, int *info, size_t, size_t)
     * }
     */
    public static void zhpev_(MemorySegment jobz, MemorySegment uplo, MemorySegment n, MemorySegment AP, MemorySegment W, MemorySegment Z, MemorySegment ldz, MemorySegment work, MemorySegment rwork, MemorySegment info, long x10, long x11) {
        var mh$ = zhpev_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zhpev_", jobz, uplo, n, AP, W, Z, ldz, work, rwork, info, x10, x11);
            }
            mh$.invokeExact(jobz, uplo, n, AP, W, Z, ldz, work, rwork, info, x10, x11);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class chpevd_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("chpevd_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void chpevd_(const char *jobz, const char *uplo, const int *n, _Complex float *AP, float *W, _Complex float *Z, const int *ldz, _Complex float *work, const int *lwork, float *rwork, const int *lrwork, int *iwork, const int *liwork, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor chpevd_$descriptor() {
        return chpevd_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void chpevd_(const char *jobz, const char *uplo, const int *n, _Complex float *AP, float *W, _Complex float *Z, const int *ldz, _Complex float *work, const int *lwork, float *rwork, const int *lrwork, int *iwork, const int *liwork, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle chpevd_$handle() {
        return chpevd_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void chpevd_(const char *jobz, const char *uplo, const int *n, _Complex float *AP, float *W, _Complex float *Z, const int *ldz, _Complex float *work, const int *lwork, float *rwork, const int *lrwork, int *iwork, const int *liwork, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment chpevd_$address() {
        return chpevd_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void chpevd_(const char *jobz, const char *uplo, const int *n, _Complex float *AP, float *W, _Complex float *Z, const int *ldz, _Complex float *work, const int *lwork, float *rwork, const int *lrwork, int *iwork, const int *liwork, int *info, size_t, size_t)
     * }
     */
    public static void chpevd_(MemorySegment jobz, MemorySegment uplo, MemorySegment n, MemorySegment AP, MemorySegment W, MemorySegment Z, MemorySegment ldz, MemorySegment work, MemorySegment lwork, MemorySegment rwork, MemorySegment lrwork, MemorySegment iwork, MemorySegment liwork, MemorySegment info, long x14, long x15) {
        var mh$ = chpevd_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("chpevd_", jobz, uplo, n, AP, W, Z, ldz, work, lwork, rwork, lrwork, iwork, liwork, info, x14, x15);
            }
            mh$.invokeExact(jobz, uplo, n, AP, W, Z, ldz, work, lwork, rwork, lrwork, iwork, liwork, info, x14, x15);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zhpevd_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("zhpevd_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zhpevd_(const char *jobz, const char *uplo, const int *n, _Complex double *AP, double *W, _Complex double *Z, const int *ldz, _Complex double *work, const int *lwork, double *rwork, const int *lrwork, int *iwork, const int *liwork, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor zhpevd_$descriptor() {
        return zhpevd_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zhpevd_(const char *jobz, const char *uplo, const int *n, _Complex double *AP, double *W, _Complex double *Z, const int *ldz, _Complex double *work, const int *lwork, double *rwork, const int *lrwork, int *iwork, const int *liwork, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle zhpevd_$handle() {
        return zhpevd_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zhpevd_(const char *jobz, const char *uplo, const int *n, _Complex double *AP, double *W, _Complex double *Z, const int *ldz, _Complex double *work, const int *lwork, double *rwork, const int *lrwork, int *iwork, const int *liwork, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment zhpevd_$address() {
        return zhpevd_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zhpevd_(const char *jobz, const char *uplo, const int *n, _Complex double *AP, double *W, _Complex double *Z, const int *ldz, _Complex double *work, const int *lwork, double *rwork, const int *lrwork, int *iwork, const int *liwork, int *info, size_t, size_t)
     * }
     */
    public static void zhpevd_(MemorySegment jobz, MemorySegment uplo, MemorySegment n, MemorySegment AP, MemorySegment W, MemorySegment Z, MemorySegment ldz, MemorySegment work, MemorySegment lwork, MemorySegment rwork, MemorySegment lrwork, MemorySegment iwork, MemorySegment liwork, MemorySegment info, long x14, long x15) {
        var mh$ = zhpevd_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zhpevd_", jobz, uplo, n, AP, W, Z, ldz, work, lwork, rwork, lrwork, iwork, liwork, info, x14, x15);
            }
            mh$.invokeExact(jobz, uplo, n, AP, W, Z, ldz, work, lwork, rwork, lrwork, iwork, liwork, info, x14, x15);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class chpevx_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("chpevx_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void chpevx_(const char *jobz, const char *range, const char *uplo, const int *n, _Complex float *AP, const float *vl, const float *vu, const int *il, const int *iu, const float *abstol, int *m, float *W, _Complex float *Z, const int *ldz, _Complex float *work, float *rwork, int *iwork, int *IFAIL, int *info, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor chpevx_$descriptor() {
        return chpevx_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void chpevx_(const char *jobz, const char *range, const char *uplo, const int *n, _Complex float *AP, const float *vl, const float *vu, const int *il, const int *iu, const float *abstol, int *m, float *W, _Complex float *Z, const int *ldz, _Complex float *work, float *rwork, int *iwork, int *IFAIL, int *info, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle chpevx_$handle() {
        return chpevx_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void chpevx_(const char *jobz, const char *range, const char *uplo, const int *n, _Complex float *AP, const float *vl, const float *vu, const int *il, const int *iu, const float *abstol, int *m, float *W, _Complex float *Z, const int *ldz, _Complex float *work, float *rwork, int *iwork, int *IFAIL, int *info, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment chpevx_$address() {
        return chpevx_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void chpevx_(const char *jobz, const char *range, const char *uplo, const int *n, _Complex float *AP, const float *vl, const float *vu, const int *il, const int *iu, const float *abstol, int *m, float *W, _Complex float *Z, const int *ldz, _Complex float *work, float *rwork, int *iwork, int *IFAIL, int *info, size_t, size_t, size_t)
     * }
     */
    public static void chpevx_(MemorySegment jobz, MemorySegment range, MemorySegment uplo, MemorySegment n, MemorySegment AP, MemorySegment vl, MemorySegment vu, MemorySegment il, MemorySegment iu, MemorySegment abstol, MemorySegment m, MemorySegment W, MemorySegment Z, MemorySegment ldz, MemorySegment work, MemorySegment rwork, MemorySegment iwork, MemorySegment IFAIL, MemorySegment info, long x19, long x20, long x21) {
        var mh$ = chpevx_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("chpevx_", jobz, range, uplo, n, AP, vl, vu, il, iu, abstol, m, W, Z, ldz, work, rwork, iwork, IFAIL, info, x19, x20, x21);
            }
            mh$.invokeExact(jobz, range, uplo, n, AP, vl, vu, il, iu, abstol, m, W, Z, ldz, work, rwork, iwork, IFAIL, info, x19, x20, x21);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zhpevx_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("zhpevx_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zhpevx_(const char *jobz, const char *range, const char *uplo, const int *n, _Complex double *AP, const double *vl, const double *vu, const int *il, const int *iu, const double *abstol, int *m, double *W, _Complex double *Z, const int *ldz, _Complex double *work, double *rwork, int *iwork, int *IFAIL, int *info, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor zhpevx_$descriptor() {
        return zhpevx_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zhpevx_(const char *jobz, const char *range, const char *uplo, const int *n, _Complex double *AP, const double *vl, const double *vu, const int *il, const int *iu, const double *abstol, int *m, double *W, _Complex double *Z, const int *ldz, _Complex double *work, double *rwork, int *iwork, int *IFAIL, int *info, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle zhpevx_$handle() {
        return zhpevx_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zhpevx_(const char *jobz, const char *range, const char *uplo, const int *n, _Complex double *AP, const double *vl, const double *vu, const int *il, const int *iu, const double *abstol, int *m, double *W, _Complex double *Z, const int *ldz, _Complex double *work, double *rwork, int *iwork, int *IFAIL, int *info, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment zhpevx_$address() {
        return zhpevx_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zhpevx_(const char *jobz, const char *range, const char *uplo, const int *n, _Complex double *AP, const double *vl, const double *vu, const int *il, const int *iu, const double *abstol, int *m, double *W, _Complex double *Z, const int *ldz, _Complex double *work, double *rwork, int *iwork, int *IFAIL, int *info, size_t, size_t, size_t)
     * }
     */
    public static void zhpevx_(MemorySegment jobz, MemorySegment range, MemorySegment uplo, MemorySegment n, MemorySegment AP, MemorySegment vl, MemorySegment vu, MemorySegment il, MemorySegment iu, MemorySegment abstol, MemorySegment m, MemorySegment W, MemorySegment Z, MemorySegment ldz, MemorySegment work, MemorySegment rwork, MemorySegment iwork, MemorySegment IFAIL, MemorySegment info, long x19, long x20, long x21) {
        var mh$ = zhpevx_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zhpevx_", jobz, range, uplo, n, AP, vl, vu, il, iu, abstol, m, W, Z, ldz, work, rwork, iwork, IFAIL, info, x19, x20, x21);
            }
            mh$.invokeExact(jobz, range, uplo, n, AP, vl, vu, il, iu, abstol, m, W, Z, ldz, work, rwork, iwork, IFAIL, info, x19, x20, x21);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class chpgst_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("chpgst_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void chpgst_(const int *itype, const char *uplo, const int *n, _Complex float *AP, const _Complex float *BP, int *info, size_t)
     * }
     */
    public static FunctionDescriptor chpgst_$descriptor() {
        return chpgst_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void chpgst_(const int *itype, const char *uplo, const int *n, _Complex float *AP, const _Complex float *BP, int *info, size_t)
     * }
     */
    public static MethodHandle chpgst_$handle() {
        return chpgst_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void chpgst_(const int *itype, const char *uplo, const int *n, _Complex float *AP, const _Complex float *BP, int *info, size_t)
     * }
     */
    public static MemorySegment chpgst_$address() {
        return chpgst_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void chpgst_(const int *itype, const char *uplo, const int *n, _Complex float *AP, const _Complex float *BP, int *info, size_t)
     * }
     */
    public static void chpgst_(MemorySegment itype, MemorySegment uplo, MemorySegment n, MemorySegment AP, MemorySegment BP, MemorySegment info, long x6) {
        var mh$ = chpgst_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("chpgst_", itype, uplo, n, AP, BP, info, x6);
            }
            mh$.invokeExact(itype, uplo, n, AP, BP, info, x6);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zhpgst_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("zhpgst_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zhpgst_(const int *itype, const char *uplo, const int *n, _Complex double *AP, const _Complex double *BP, int *info, size_t)
     * }
     */
    public static FunctionDescriptor zhpgst_$descriptor() {
        return zhpgst_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zhpgst_(const int *itype, const char *uplo, const int *n, _Complex double *AP, const _Complex double *BP, int *info, size_t)
     * }
     */
    public static MethodHandle zhpgst_$handle() {
        return zhpgst_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zhpgst_(const int *itype, const char *uplo, const int *n, _Complex double *AP, const _Complex double *BP, int *info, size_t)
     * }
     */
    public static MemorySegment zhpgst_$address() {
        return zhpgst_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zhpgst_(const int *itype, const char *uplo, const int *n, _Complex double *AP, const _Complex double *BP, int *info, size_t)
     * }
     */
    public static void zhpgst_(MemorySegment itype, MemorySegment uplo, MemorySegment n, MemorySegment AP, MemorySegment BP, MemorySegment info, long x6) {
        var mh$ = zhpgst_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zhpgst_", itype, uplo, n, AP, BP, info, x6);
            }
            mh$.invokeExact(itype, uplo, n, AP, BP, info, x6);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class chpgv_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("chpgv_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void chpgv_(const int *itype, const char *jobz, const char *uplo, const int *n, _Complex float *AP, _Complex float *BP, float *W, _Complex float *Z, const int *ldz, _Complex float *work, float *rwork, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor chpgv_$descriptor() {
        return chpgv_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void chpgv_(const int *itype, const char *jobz, const char *uplo, const int *n, _Complex float *AP, _Complex float *BP, float *W, _Complex float *Z, const int *ldz, _Complex float *work, float *rwork, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle chpgv_$handle() {
        return chpgv_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void chpgv_(const int *itype, const char *jobz, const char *uplo, const int *n, _Complex float *AP, _Complex float *BP, float *W, _Complex float *Z, const int *ldz, _Complex float *work, float *rwork, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment chpgv_$address() {
        return chpgv_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void chpgv_(const int *itype, const char *jobz, const char *uplo, const int *n, _Complex float *AP, _Complex float *BP, float *W, _Complex float *Z, const int *ldz, _Complex float *work, float *rwork, int *info, size_t, size_t)
     * }
     */
    public static void chpgv_(MemorySegment itype, MemorySegment jobz, MemorySegment uplo, MemorySegment n, MemorySegment AP, MemorySegment BP, MemorySegment W, MemorySegment Z, MemorySegment ldz, MemorySegment work, MemorySegment rwork, MemorySegment info, long x12, long x13) {
        var mh$ = chpgv_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("chpgv_", itype, jobz, uplo, n, AP, BP, W, Z, ldz, work, rwork, info, x12, x13);
            }
            mh$.invokeExact(itype, jobz, uplo, n, AP, BP, W, Z, ldz, work, rwork, info, x12, x13);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zhpgv_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("zhpgv_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zhpgv_(const int *itype, const char *jobz, const char *uplo, const int *n, _Complex double *AP, _Complex double *BP, double *W, _Complex double *Z, const int *ldz, _Complex double *work, double *rwork, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor zhpgv_$descriptor() {
        return zhpgv_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zhpgv_(const int *itype, const char *jobz, const char *uplo, const int *n, _Complex double *AP, _Complex double *BP, double *W, _Complex double *Z, const int *ldz, _Complex double *work, double *rwork, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle zhpgv_$handle() {
        return zhpgv_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zhpgv_(const int *itype, const char *jobz, const char *uplo, const int *n, _Complex double *AP, _Complex double *BP, double *W, _Complex double *Z, const int *ldz, _Complex double *work, double *rwork, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment zhpgv_$address() {
        return zhpgv_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zhpgv_(const int *itype, const char *jobz, const char *uplo, const int *n, _Complex double *AP, _Complex double *BP, double *W, _Complex double *Z, const int *ldz, _Complex double *work, double *rwork, int *info, size_t, size_t)
     * }
     */
    public static void zhpgv_(MemorySegment itype, MemorySegment jobz, MemorySegment uplo, MemorySegment n, MemorySegment AP, MemorySegment BP, MemorySegment W, MemorySegment Z, MemorySegment ldz, MemorySegment work, MemorySegment rwork, MemorySegment info, long x12, long x13) {
        var mh$ = zhpgv_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zhpgv_", itype, jobz, uplo, n, AP, BP, W, Z, ldz, work, rwork, info, x12, x13);
            }
            mh$.invokeExact(itype, jobz, uplo, n, AP, BP, W, Z, ldz, work, rwork, info, x12, x13);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class chpgvd_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("chpgvd_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void chpgvd_(const int *itype, const char *jobz, const char *uplo, const int *n, _Complex float *AP, _Complex float *BP, float *W, _Complex float *Z, const int *ldz, _Complex float *work, const int *lwork, float *rwork, const int *lrwork, int *iwork, const int *liwork, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor chpgvd_$descriptor() {
        return chpgvd_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void chpgvd_(const int *itype, const char *jobz, const char *uplo, const int *n, _Complex float *AP, _Complex float *BP, float *W, _Complex float *Z, const int *ldz, _Complex float *work, const int *lwork, float *rwork, const int *lrwork, int *iwork, const int *liwork, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle chpgvd_$handle() {
        return chpgvd_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void chpgvd_(const int *itype, const char *jobz, const char *uplo, const int *n, _Complex float *AP, _Complex float *BP, float *W, _Complex float *Z, const int *ldz, _Complex float *work, const int *lwork, float *rwork, const int *lrwork, int *iwork, const int *liwork, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment chpgvd_$address() {
        return chpgvd_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void chpgvd_(const int *itype, const char *jobz, const char *uplo, const int *n, _Complex float *AP, _Complex float *BP, float *W, _Complex float *Z, const int *ldz, _Complex float *work, const int *lwork, float *rwork, const int *lrwork, int *iwork, const int *liwork, int *info, size_t, size_t)
     * }
     */
    public static void chpgvd_(MemorySegment itype, MemorySegment jobz, MemorySegment uplo, MemorySegment n, MemorySegment AP, MemorySegment BP, MemorySegment W, MemorySegment Z, MemorySegment ldz, MemorySegment work, MemorySegment lwork, MemorySegment rwork, MemorySegment lrwork, MemorySegment iwork, MemorySegment liwork, MemorySegment info, long x16, long x17) {
        var mh$ = chpgvd_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("chpgvd_", itype, jobz, uplo, n, AP, BP, W, Z, ldz, work, lwork, rwork, lrwork, iwork, liwork, info, x16, x17);
            }
            mh$.invokeExact(itype, jobz, uplo, n, AP, BP, W, Z, ldz, work, lwork, rwork, lrwork, iwork, liwork, info, x16, x17);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zhpgvd_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("zhpgvd_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zhpgvd_(const int *itype, const char *jobz, const char *uplo, const int *n, _Complex double *AP, _Complex double *BP, double *W, _Complex double *Z, const int *ldz, _Complex double *work, const int *lwork, double *rwork, const int *lrwork, int *iwork, const int *liwork, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor zhpgvd_$descriptor() {
        return zhpgvd_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zhpgvd_(const int *itype, const char *jobz, const char *uplo, const int *n, _Complex double *AP, _Complex double *BP, double *W, _Complex double *Z, const int *ldz, _Complex double *work, const int *lwork, double *rwork, const int *lrwork, int *iwork, const int *liwork, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle zhpgvd_$handle() {
        return zhpgvd_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zhpgvd_(const int *itype, const char *jobz, const char *uplo, const int *n, _Complex double *AP, _Complex double *BP, double *W, _Complex double *Z, const int *ldz, _Complex double *work, const int *lwork, double *rwork, const int *lrwork, int *iwork, const int *liwork, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment zhpgvd_$address() {
        return zhpgvd_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zhpgvd_(const int *itype, const char *jobz, const char *uplo, const int *n, _Complex double *AP, _Complex double *BP, double *W, _Complex double *Z, const int *ldz, _Complex double *work, const int *lwork, double *rwork, const int *lrwork, int *iwork, const int *liwork, int *info, size_t, size_t)
     * }
     */
    public static void zhpgvd_(MemorySegment itype, MemorySegment jobz, MemorySegment uplo, MemorySegment n, MemorySegment AP, MemorySegment BP, MemorySegment W, MemorySegment Z, MemorySegment ldz, MemorySegment work, MemorySegment lwork, MemorySegment rwork, MemorySegment lrwork, MemorySegment iwork, MemorySegment liwork, MemorySegment info, long x16, long x17) {
        var mh$ = zhpgvd_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zhpgvd_", itype, jobz, uplo, n, AP, BP, W, Z, ldz, work, lwork, rwork, lrwork, iwork, liwork, info, x16, x17);
            }
            mh$.invokeExact(itype, jobz, uplo, n, AP, BP, W, Z, ldz, work, lwork, rwork, lrwork, iwork, liwork, info, x16, x17);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class chpgvx_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("chpgvx_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void chpgvx_(const int *itype, const char *jobz, const char *range, const char *uplo, const int *n, _Complex float *AP, _Complex float *BP, const float *vl, const float *vu, const int *il, const int *iu, const float *abstol, int *m, float *W, _Complex float *Z, const int *ldz, _Complex float *work, float *rwork, int *iwork, int *IFAIL, int *info, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor chpgvx_$descriptor() {
        return chpgvx_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void chpgvx_(const int *itype, const char *jobz, const char *range, const char *uplo, const int *n, _Complex float *AP, _Complex float *BP, const float *vl, const float *vu, const int *il, const int *iu, const float *abstol, int *m, float *W, _Complex float *Z, const int *ldz, _Complex float *work, float *rwork, int *iwork, int *IFAIL, int *info, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle chpgvx_$handle() {
        return chpgvx_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void chpgvx_(const int *itype, const char *jobz, const char *range, const char *uplo, const int *n, _Complex float *AP, _Complex float *BP, const float *vl, const float *vu, const int *il, const int *iu, const float *abstol, int *m, float *W, _Complex float *Z, const int *ldz, _Complex float *work, float *rwork, int *iwork, int *IFAIL, int *info, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment chpgvx_$address() {
        return chpgvx_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void chpgvx_(const int *itype, const char *jobz, const char *range, const char *uplo, const int *n, _Complex float *AP, _Complex float *BP, const float *vl, const float *vu, const int *il, const int *iu, const float *abstol, int *m, float *W, _Complex float *Z, const int *ldz, _Complex float *work, float *rwork, int *iwork, int *IFAIL, int *info, size_t, size_t, size_t)
     * }
     */
    public static void chpgvx_(MemorySegment itype, MemorySegment jobz, MemorySegment range, MemorySegment uplo, MemorySegment n, MemorySegment AP, MemorySegment BP, MemorySegment vl, MemorySegment vu, MemorySegment il, MemorySegment iu, MemorySegment abstol, MemorySegment m, MemorySegment W, MemorySegment Z, MemorySegment ldz, MemorySegment work, MemorySegment rwork, MemorySegment iwork, MemorySegment IFAIL, MemorySegment info, long x21, long x22, long x23) {
        var mh$ = chpgvx_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("chpgvx_", itype, jobz, range, uplo, n, AP, BP, vl, vu, il, iu, abstol, m, W, Z, ldz, work, rwork, iwork, IFAIL, info, x21, x22, x23);
            }
            mh$.invokeExact(itype, jobz, range, uplo, n, AP, BP, vl, vu, il, iu, abstol, m, W, Z, ldz, work, rwork, iwork, IFAIL, info, x21, x22, x23);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zhpgvx_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("zhpgvx_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zhpgvx_(const int *itype, const char *jobz, const char *range, const char *uplo, const int *n, _Complex double *AP, _Complex double *BP, const double *vl, const double *vu, const int *il, const int *iu, const double *abstol, int *m, double *W, _Complex double *Z, const int *ldz, _Complex double *work, double *rwork, int *iwork, int *IFAIL, int *info, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor zhpgvx_$descriptor() {
        return zhpgvx_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zhpgvx_(const int *itype, const char *jobz, const char *range, const char *uplo, const int *n, _Complex double *AP, _Complex double *BP, const double *vl, const double *vu, const int *il, const int *iu, const double *abstol, int *m, double *W, _Complex double *Z, const int *ldz, _Complex double *work, double *rwork, int *iwork, int *IFAIL, int *info, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle zhpgvx_$handle() {
        return zhpgvx_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zhpgvx_(const int *itype, const char *jobz, const char *range, const char *uplo, const int *n, _Complex double *AP, _Complex double *BP, const double *vl, const double *vu, const int *il, const int *iu, const double *abstol, int *m, double *W, _Complex double *Z, const int *ldz, _Complex double *work, double *rwork, int *iwork, int *IFAIL, int *info, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment zhpgvx_$address() {
        return zhpgvx_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zhpgvx_(const int *itype, const char *jobz, const char *range, const char *uplo, const int *n, _Complex double *AP, _Complex double *BP, const double *vl, const double *vu, const int *il, const int *iu, const double *abstol, int *m, double *W, _Complex double *Z, const int *ldz, _Complex double *work, double *rwork, int *iwork, int *IFAIL, int *info, size_t, size_t, size_t)
     * }
     */
    public static void zhpgvx_(MemorySegment itype, MemorySegment jobz, MemorySegment range, MemorySegment uplo, MemorySegment n, MemorySegment AP, MemorySegment BP, MemorySegment vl, MemorySegment vu, MemorySegment il, MemorySegment iu, MemorySegment abstol, MemorySegment m, MemorySegment W, MemorySegment Z, MemorySegment ldz, MemorySegment work, MemorySegment rwork, MemorySegment iwork, MemorySegment IFAIL, MemorySegment info, long x21, long x22, long x23) {
        var mh$ = zhpgvx_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zhpgvx_", itype, jobz, range, uplo, n, AP, BP, vl, vu, il, iu, abstol, m, W, Z, ldz, work, rwork, iwork, IFAIL, info, x21, x22, x23);
            }
            mh$.invokeExact(itype, jobz, range, uplo, n, AP, BP, vl, vu, il, iu, abstol, m, W, Z, ldz, work, rwork, iwork, IFAIL, info, x21, x22, x23);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class chprfs_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("chprfs_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void chprfs_(const char *uplo, const int *n, const int *nrhs, const _Complex float *AP, const _Complex float *AFP, const int *ipiv, const _Complex float *B, const int *ldb, _Complex float *X, const int *ldx, float *ferr, float *berr, _Complex float *work, float *rwork, int *info, size_t)
     * }
     */
    public static FunctionDescriptor chprfs_$descriptor() {
        return chprfs_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void chprfs_(const char *uplo, const int *n, const int *nrhs, const _Complex float *AP, const _Complex float *AFP, const int *ipiv, const _Complex float *B, const int *ldb, _Complex float *X, const int *ldx, float *ferr, float *berr, _Complex float *work, float *rwork, int *info, size_t)
     * }
     */
    public static MethodHandle chprfs_$handle() {
        return chprfs_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void chprfs_(const char *uplo, const int *n, const int *nrhs, const _Complex float *AP, const _Complex float *AFP, const int *ipiv, const _Complex float *B, const int *ldb, _Complex float *X, const int *ldx, float *ferr, float *berr, _Complex float *work, float *rwork, int *info, size_t)
     * }
     */
    public static MemorySegment chprfs_$address() {
        return chprfs_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void chprfs_(const char *uplo, const int *n, const int *nrhs, const _Complex float *AP, const _Complex float *AFP, const int *ipiv, const _Complex float *B, const int *ldb, _Complex float *X, const int *ldx, float *ferr, float *berr, _Complex float *work, float *rwork, int *info, size_t)
     * }
     */
    public static void chprfs_(MemorySegment uplo, MemorySegment n, MemorySegment nrhs, MemorySegment AP, MemorySegment AFP, MemorySegment ipiv, MemorySegment B, MemorySegment ldb, MemorySegment X, MemorySegment ldx, MemorySegment ferr, MemorySegment berr, MemorySegment work, MemorySegment rwork, MemorySegment info, long x15) {
        var mh$ = chprfs_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("chprfs_", uplo, n, nrhs, AP, AFP, ipiv, B, ldb, X, ldx, ferr, berr, work, rwork, info, x15);
            }
            mh$.invokeExact(uplo, n, nrhs, AP, AFP, ipiv, B, ldb, X, ldx, ferr, berr, work, rwork, info, x15);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zhprfs_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("zhprfs_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zhprfs_(const char *uplo, const int *n, const int *nrhs, const _Complex double *AP, const _Complex double *AFP, const int *ipiv, const _Complex double *B, const int *ldb, _Complex double *X, const int *ldx, double *ferr, double *berr, _Complex double *work, double *rwork, int *info, size_t)
     * }
     */
    public static FunctionDescriptor zhprfs_$descriptor() {
        return zhprfs_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zhprfs_(const char *uplo, const int *n, const int *nrhs, const _Complex double *AP, const _Complex double *AFP, const int *ipiv, const _Complex double *B, const int *ldb, _Complex double *X, const int *ldx, double *ferr, double *berr, _Complex double *work, double *rwork, int *info, size_t)
     * }
     */
    public static MethodHandle zhprfs_$handle() {
        return zhprfs_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zhprfs_(const char *uplo, const int *n, const int *nrhs, const _Complex double *AP, const _Complex double *AFP, const int *ipiv, const _Complex double *B, const int *ldb, _Complex double *X, const int *ldx, double *ferr, double *berr, _Complex double *work, double *rwork, int *info, size_t)
     * }
     */
    public static MemorySegment zhprfs_$address() {
        return zhprfs_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zhprfs_(const char *uplo, const int *n, const int *nrhs, const _Complex double *AP, const _Complex double *AFP, const int *ipiv, const _Complex double *B, const int *ldb, _Complex double *X, const int *ldx, double *ferr, double *berr, _Complex double *work, double *rwork, int *info, size_t)
     * }
     */
    public static void zhprfs_(MemorySegment uplo, MemorySegment n, MemorySegment nrhs, MemorySegment AP, MemorySegment AFP, MemorySegment ipiv, MemorySegment B, MemorySegment ldb, MemorySegment X, MemorySegment ldx, MemorySegment ferr, MemorySegment berr, MemorySegment work, MemorySegment rwork, MemorySegment info, long x15) {
        var mh$ = zhprfs_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zhprfs_", uplo, n, nrhs, AP, AFP, ipiv, B, ldb, X, ldx, ferr, berr, work, rwork, info, x15);
            }
            mh$.invokeExact(uplo, n, nrhs, AP, AFP, ipiv, B, ldb, X, ldx, ferr, berr, work, rwork, info, x15);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class chpsv_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("chpsv_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void chpsv_(const char *uplo, const int *n, const int *nrhs, _Complex float *AP, int *ipiv, _Complex float *B, const int *ldb, int *info, size_t)
     * }
     */
    public static FunctionDescriptor chpsv_$descriptor() {
        return chpsv_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void chpsv_(const char *uplo, const int *n, const int *nrhs, _Complex float *AP, int *ipiv, _Complex float *B, const int *ldb, int *info, size_t)
     * }
     */
    public static MethodHandle chpsv_$handle() {
        return chpsv_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void chpsv_(const char *uplo, const int *n, const int *nrhs, _Complex float *AP, int *ipiv, _Complex float *B, const int *ldb, int *info, size_t)
     * }
     */
    public static MemorySegment chpsv_$address() {
        return chpsv_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void chpsv_(const char *uplo, const int *n, const int *nrhs, _Complex float *AP, int *ipiv, _Complex float *B, const int *ldb, int *info, size_t)
     * }
     */
    public static void chpsv_(MemorySegment uplo, MemorySegment n, MemorySegment nrhs, MemorySegment AP, MemorySegment ipiv, MemorySegment B, MemorySegment ldb, MemorySegment info, long x8) {
        var mh$ = chpsv_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("chpsv_", uplo, n, nrhs, AP, ipiv, B, ldb, info, x8);
            }
            mh$.invokeExact(uplo, n, nrhs, AP, ipiv, B, ldb, info, x8);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zhpsv_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("zhpsv_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zhpsv_(const char *uplo, const int *n, const int *nrhs, _Complex double *AP, int *ipiv, _Complex double *B, const int *ldb, int *info, size_t)
     * }
     */
    public static FunctionDescriptor zhpsv_$descriptor() {
        return zhpsv_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zhpsv_(const char *uplo, const int *n, const int *nrhs, _Complex double *AP, int *ipiv, _Complex double *B, const int *ldb, int *info, size_t)
     * }
     */
    public static MethodHandle zhpsv_$handle() {
        return zhpsv_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zhpsv_(const char *uplo, const int *n, const int *nrhs, _Complex double *AP, int *ipiv, _Complex double *B, const int *ldb, int *info, size_t)
     * }
     */
    public static MemorySegment zhpsv_$address() {
        return zhpsv_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zhpsv_(const char *uplo, const int *n, const int *nrhs, _Complex double *AP, int *ipiv, _Complex double *B, const int *ldb, int *info, size_t)
     * }
     */
    public static void zhpsv_(MemorySegment uplo, MemorySegment n, MemorySegment nrhs, MemorySegment AP, MemorySegment ipiv, MemorySegment B, MemorySegment ldb, MemorySegment info, long x8) {
        var mh$ = zhpsv_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zhpsv_", uplo, n, nrhs, AP, ipiv, B, ldb, info, x8);
            }
            mh$.invokeExact(uplo, n, nrhs, AP, ipiv, B, ldb, info, x8);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class chpsvx_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("chpsvx_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void chpsvx_(const char *fact, const char *uplo, const int *n, const int *nrhs, const _Complex float *AP, _Complex float *AFP, int *ipiv, const _Complex float *B, const int *ldb, _Complex float *X, const int *ldx, float *rcond, float *ferr, float *berr, _Complex float *work, float *rwork, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor chpsvx_$descriptor() {
        return chpsvx_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void chpsvx_(const char *fact, const char *uplo, const int *n, const int *nrhs, const _Complex float *AP, _Complex float *AFP, int *ipiv, const _Complex float *B, const int *ldb, _Complex float *X, const int *ldx, float *rcond, float *ferr, float *berr, _Complex float *work, float *rwork, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle chpsvx_$handle() {
        return chpsvx_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void chpsvx_(const char *fact, const char *uplo, const int *n, const int *nrhs, const _Complex float *AP, _Complex float *AFP, int *ipiv, const _Complex float *B, const int *ldb, _Complex float *X, const int *ldx, float *rcond, float *ferr, float *berr, _Complex float *work, float *rwork, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment chpsvx_$address() {
        return chpsvx_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void chpsvx_(const char *fact, const char *uplo, const int *n, const int *nrhs, const _Complex float *AP, _Complex float *AFP, int *ipiv, const _Complex float *B, const int *ldb, _Complex float *X, const int *ldx, float *rcond, float *ferr, float *berr, _Complex float *work, float *rwork, int *info, size_t, size_t)
     * }
     */
    public static void chpsvx_(MemorySegment fact, MemorySegment uplo, MemorySegment n, MemorySegment nrhs, MemorySegment AP, MemorySegment AFP, MemorySegment ipiv, MemorySegment B, MemorySegment ldb, MemorySegment X, MemorySegment ldx, MemorySegment rcond, MemorySegment ferr, MemorySegment berr, MemorySegment work, MemorySegment rwork, MemorySegment info, long x17, long x18) {
        var mh$ = chpsvx_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("chpsvx_", fact, uplo, n, nrhs, AP, AFP, ipiv, B, ldb, X, ldx, rcond, ferr, berr, work, rwork, info, x17, x18);
            }
            mh$.invokeExact(fact, uplo, n, nrhs, AP, AFP, ipiv, B, ldb, X, ldx, rcond, ferr, berr, work, rwork, info, x17, x18);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zhpsvx_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("zhpsvx_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zhpsvx_(const char *fact, const char *uplo, const int *n, const int *nrhs, const _Complex double *AP, _Complex double *AFP, int *ipiv, const _Complex double *B, const int *ldb, _Complex double *X, const int *ldx, double *rcond, double *ferr, double *berr, _Complex double *work, double *rwork, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor zhpsvx_$descriptor() {
        return zhpsvx_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zhpsvx_(const char *fact, const char *uplo, const int *n, const int *nrhs, const _Complex double *AP, _Complex double *AFP, int *ipiv, const _Complex double *B, const int *ldb, _Complex double *X, const int *ldx, double *rcond, double *ferr, double *berr, _Complex double *work, double *rwork, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle zhpsvx_$handle() {
        return zhpsvx_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zhpsvx_(const char *fact, const char *uplo, const int *n, const int *nrhs, const _Complex double *AP, _Complex double *AFP, int *ipiv, const _Complex double *B, const int *ldb, _Complex double *X, const int *ldx, double *rcond, double *ferr, double *berr, _Complex double *work, double *rwork, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment zhpsvx_$address() {
        return zhpsvx_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zhpsvx_(const char *fact, const char *uplo, const int *n, const int *nrhs, const _Complex double *AP, _Complex double *AFP, int *ipiv, const _Complex double *B, const int *ldb, _Complex double *X, const int *ldx, double *rcond, double *ferr, double *berr, _Complex double *work, double *rwork, int *info, size_t, size_t)
     * }
     */
    public static void zhpsvx_(MemorySegment fact, MemorySegment uplo, MemorySegment n, MemorySegment nrhs, MemorySegment AP, MemorySegment AFP, MemorySegment ipiv, MemorySegment B, MemorySegment ldb, MemorySegment X, MemorySegment ldx, MemorySegment rcond, MemorySegment ferr, MemorySegment berr, MemorySegment work, MemorySegment rwork, MemorySegment info, long x17, long x18) {
        var mh$ = zhpsvx_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zhpsvx_", fact, uplo, n, nrhs, AP, AFP, ipiv, B, ldb, X, ldx, rcond, ferr, berr, work, rwork, info, x17, x18);
            }
            mh$.invokeExact(fact, uplo, n, nrhs, AP, AFP, ipiv, B, ldb, X, ldx, rcond, ferr, berr, work, rwork, info, x17, x18);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class chptrd_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("chptrd_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void chptrd_(const char *uplo, const int *n, _Complex float *AP, float *D, float *E, _Complex float *tau, int *info, size_t)
     * }
     */
    public static FunctionDescriptor chptrd_$descriptor() {
        return chptrd_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void chptrd_(const char *uplo, const int *n, _Complex float *AP, float *D, float *E, _Complex float *tau, int *info, size_t)
     * }
     */
    public static MethodHandle chptrd_$handle() {
        return chptrd_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void chptrd_(const char *uplo, const int *n, _Complex float *AP, float *D, float *E, _Complex float *tau, int *info, size_t)
     * }
     */
    public static MemorySegment chptrd_$address() {
        return chptrd_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void chptrd_(const char *uplo, const int *n, _Complex float *AP, float *D, float *E, _Complex float *tau, int *info, size_t)
     * }
     */
    public static void chptrd_(MemorySegment uplo, MemorySegment n, MemorySegment AP, MemorySegment D, MemorySegment E, MemorySegment tau, MemorySegment info, long x7) {
        var mh$ = chptrd_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("chptrd_", uplo, n, AP, D, E, tau, info, x7);
            }
            mh$.invokeExact(uplo, n, AP, D, E, tau, info, x7);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zhptrd_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("zhptrd_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zhptrd_(const char *uplo, const int *n, _Complex double *AP, double *D, double *E, _Complex double *tau, int *info, size_t)
     * }
     */
    public static FunctionDescriptor zhptrd_$descriptor() {
        return zhptrd_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zhptrd_(const char *uplo, const int *n, _Complex double *AP, double *D, double *E, _Complex double *tau, int *info, size_t)
     * }
     */
    public static MethodHandle zhptrd_$handle() {
        return zhptrd_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zhptrd_(const char *uplo, const int *n, _Complex double *AP, double *D, double *E, _Complex double *tau, int *info, size_t)
     * }
     */
    public static MemorySegment zhptrd_$address() {
        return zhptrd_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zhptrd_(const char *uplo, const int *n, _Complex double *AP, double *D, double *E, _Complex double *tau, int *info, size_t)
     * }
     */
    public static void zhptrd_(MemorySegment uplo, MemorySegment n, MemorySegment AP, MemorySegment D, MemorySegment E, MemorySegment tau, MemorySegment info, long x7) {
        var mh$ = zhptrd_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zhptrd_", uplo, n, AP, D, E, tau, info, x7);
            }
            mh$.invokeExact(uplo, n, AP, D, E, tau, info, x7);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class chptrf_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("chptrf_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void chptrf_(const char *uplo, const int *n, _Complex float *AP, int *ipiv, int *info, size_t)
     * }
     */
    public static FunctionDescriptor chptrf_$descriptor() {
        return chptrf_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void chptrf_(const char *uplo, const int *n, _Complex float *AP, int *ipiv, int *info, size_t)
     * }
     */
    public static MethodHandle chptrf_$handle() {
        return chptrf_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void chptrf_(const char *uplo, const int *n, _Complex float *AP, int *ipiv, int *info, size_t)
     * }
     */
    public static MemorySegment chptrf_$address() {
        return chptrf_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void chptrf_(const char *uplo, const int *n, _Complex float *AP, int *ipiv, int *info, size_t)
     * }
     */
    public static void chptrf_(MemorySegment uplo, MemorySegment n, MemorySegment AP, MemorySegment ipiv, MemorySegment info, long x5) {
        var mh$ = chptrf_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("chptrf_", uplo, n, AP, ipiv, info, x5);
            }
            mh$.invokeExact(uplo, n, AP, ipiv, info, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zhptrf_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("zhptrf_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zhptrf_(const char *uplo, const int *n, _Complex double *AP, int *ipiv, int *info, size_t)
     * }
     */
    public static FunctionDescriptor zhptrf_$descriptor() {
        return zhptrf_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zhptrf_(const char *uplo, const int *n, _Complex double *AP, int *ipiv, int *info, size_t)
     * }
     */
    public static MethodHandle zhptrf_$handle() {
        return zhptrf_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zhptrf_(const char *uplo, const int *n, _Complex double *AP, int *ipiv, int *info, size_t)
     * }
     */
    public static MemorySegment zhptrf_$address() {
        return zhptrf_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zhptrf_(const char *uplo, const int *n, _Complex double *AP, int *ipiv, int *info, size_t)
     * }
     */
    public static void zhptrf_(MemorySegment uplo, MemorySegment n, MemorySegment AP, MemorySegment ipiv, MemorySegment info, long x5) {
        var mh$ = zhptrf_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zhptrf_", uplo, n, AP, ipiv, info, x5);
            }
            mh$.invokeExact(uplo, n, AP, ipiv, info, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class chptri_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("chptri_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void chptri_(const char *uplo, const int *n, _Complex float *AP, const int *ipiv, _Complex float *work, int *info, size_t)
     * }
     */
    public static FunctionDescriptor chptri_$descriptor() {
        return chptri_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void chptri_(const char *uplo, const int *n, _Complex float *AP, const int *ipiv, _Complex float *work, int *info, size_t)
     * }
     */
    public static MethodHandle chptri_$handle() {
        return chptri_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void chptri_(const char *uplo, const int *n, _Complex float *AP, const int *ipiv, _Complex float *work, int *info, size_t)
     * }
     */
    public static MemorySegment chptri_$address() {
        return chptri_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void chptri_(const char *uplo, const int *n, _Complex float *AP, const int *ipiv, _Complex float *work, int *info, size_t)
     * }
     */
    public static void chptri_(MemorySegment uplo, MemorySegment n, MemorySegment AP, MemorySegment ipiv, MemorySegment work, MemorySegment info, long x6) {
        var mh$ = chptri_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("chptri_", uplo, n, AP, ipiv, work, info, x6);
            }
            mh$.invokeExact(uplo, n, AP, ipiv, work, info, x6);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zhptri_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("zhptri_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zhptri_(const char *uplo, const int *n, _Complex double *AP, const int *ipiv, _Complex double *work, int *info, size_t)
     * }
     */
    public static FunctionDescriptor zhptri_$descriptor() {
        return zhptri_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zhptri_(const char *uplo, const int *n, _Complex double *AP, const int *ipiv, _Complex double *work, int *info, size_t)
     * }
     */
    public static MethodHandle zhptri_$handle() {
        return zhptri_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zhptri_(const char *uplo, const int *n, _Complex double *AP, const int *ipiv, _Complex double *work, int *info, size_t)
     * }
     */
    public static MemorySegment zhptri_$address() {
        return zhptri_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zhptri_(const char *uplo, const int *n, _Complex double *AP, const int *ipiv, _Complex double *work, int *info, size_t)
     * }
     */
    public static void zhptri_(MemorySegment uplo, MemorySegment n, MemorySegment AP, MemorySegment ipiv, MemorySegment work, MemorySegment info, long x6) {
        var mh$ = zhptri_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zhptri_", uplo, n, AP, ipiv, work, info, x6);
            }
            mh$.invokeExact(uplo, n, AP, ipiv, work, info, x6);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class chptrs_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("chptrs_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void chptrs_(const char *uplo, const int *n, const int *nrhs, const _Complex float *AP, const int *ipiv, _Complex float *B, const int *ldb, int *info, size_t)
     * }
     */
    public static FunctionDescriptor chptrs_$descriptor() {
        return chptrs_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void chptrs_(const char *uplo, const int *n, const int *nrhs, const _Complex float *AP, const int *ipiv, _Complex float *B, const int *ldb, int *info, size_t)
     * }
     */
    public static MethodHandle chptrs_$handle() {
        return chptrs_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void chptrs_(const char *uplo, const int *n, const int *nrhs, const _Complex float *AP, const int *ipiv, _Complex float *B, const int *ldb, int *info, size_t)
     * }
     */
    public static MemorySegment chptrs_$address() {
        return chptrs_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void chptrs_(const char *uplo, const int *n, const int *nrhs, const _Complex float *AP, const int *ipiv, _Complex float *B, const int *ldb, int *info, size_t)
     * }
     */
    public static void chptrs_(MemorySegment uplo, MemorySegment n, MemorySegment nrhs, MemorySegment AP, MemorySegment ipiv, MemorySegment B, MemorySegment ldb, MemorySegment info, long x8) {
        var mh$ = chptrs_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("chptrs_", uplo, n, nrhs, AP, ipiv, B, ldb, info, x8);
            }
            mh$.invokeExact(uplo, n, nrhs, AP, ipiv, B, ldb, info, x8);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zhptrs_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("zhptrs_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zhptrs_(const char *uplo, const int *n, const int *nrhs, const _Complex double *AP, const int *ipiv, _Complex double *B, const int *ldb, int *info, size_t)
     * }
     */
    public static FunctionDescriptor zhptrs_$descriptor() {
        return zhptrs_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zhptrs_(const char *uplo, const int *n, const int *nrhs, const _Complex double *AP, const int *ipiv, _Complex double *B, const int *ldb, int *info, size_t)
     * }
     */
    public static MethodHandle zhptrs_$handle() {
        return zhptrs_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zhptrs_(const char *uplo, const int *n, const int *nrhs, const _Complex double *AP, const int *ipiv, _Complex double *B, const int *ldb, int *info, size_t)
     * }
     */
    public static MemorySegment zhptrs_$address() {
        return zhptrs_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zhptrs_(const char *uplo, const int *n, const int *nrhs, const _Complex double *AP, const int *ipiv, _Complex double *B, const int *ldb, int *info, size_t)
     * }
     */
    public static void zhptrs_(MemorySegment uplo, MemorySegment n, MemorySegment nrhs, MemorySegment AP, MemorySegment ipiv, MemorySegment B, MemorySegment ldb, MemorySegment info, long x8) {
        var mh$ = zhptrs_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zhptrs_", uplo, n, nrhs, AP, ipiv, B, ldb, info, x8);
            }
            mh$.invokeExact(uplo, n, nrhs, AP, ipiv, B, ldb, info, x8);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class chsein_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("chsein_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void chsein_(const char *side, const char *eigsrc, const char *initv, const int *select, const int *n, const _Complex float *H, const int *ldh, _Complex float *W, _Complex float *VL, const int *ldvl, _Complex float *VR, const int *ldvr, const int *mm, int *m, _Complex float *work, float *rwork, int *IFAILL, int *IFAILR, int *info, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor chsein_$descriptor() {
        return chsein_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void chsein_(const char *side, const char *eigsrc, const char *initv, const int *select, const int *n, const _Complex float *H, const int *ldh, _Complex float *W, _Complex float *VL, const int *ldvl, _Complex float *VR, const int *ldvr, const int *mm, int *m, _Complex float *work, float *rwork, int *IFAILL, int *IFAILR, int *info, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle chsein_$handle() {
        return chsein_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void chsein_(const char *side, const char *eigsrc, const char *initv, const int *select, const int *n, const _Complex float *H, const int *ldh, _Complex float *W, _Complex float *VL, const int *ldvl, _Complex float *VR, const int *ldvr, const int *mm, int *m, _Complex float *work, float *rwork, int *IFAILL, int *IFAILR, int *info, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment chsein_$address() {
        return chsein_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void chsein_(const char *side, const char *eigsrc, const char *initv, const int *select, const int *n, const _Complex float *H, const int *ldh, _Complex float *W, _Complex float *VL, const int *ldvl, _Complex float *VR, const int *ldvr, const int *mm, int *m, _Complex float *work, float *rwork, int *IFAILL, int *IFAILR, int *info, size_t, size_t, size_t)
     * }
     */
    public static void chsein_(MemorySegment side, MemorySegment eigsrc, MemorySegment initv, MemorySegment select, MemorySegment n, MemorySegment H, MemorySegment ldh, MemorySegment W, MemorySegment VL, MemorySegment ldvl, MemorySegment VR, MemorySegment ldvr, MemorySegment mm, MemorySegment m, MemorySegment work, MemorySegment rwork, MemorySegment IFAILL, MemorySegment IFAILR, MemorySegment info, long x19, long x20, long x21) {
        var mh$ = chsein_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("chsein_", side, eigsrc, initv, select, n, H, ldh, W, VL, ldvl, VR, ldvr, mm, m, work, rwork, IFAILL, IFAILR, info, x19, x20, x21);
            }
            mh$.invokeExact(side, eigsrc, initv, select, n, H, ldh, W, VL, ldvl, VR, ldvr, mm, m, work, rwork, IFAILL, IFAILR, info, x19, x20, x21);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dhsein_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("dhsein_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dhsein_(const char *side, const char *eigsrc, const char *initv, int *select, const int *n, const double *H, const int *ldh, double *WR, const double *WI, double *VL, const int *ldvl, double *VR, const int *ldvr, const int *mm, int *m, double *work, int *IFAILL, int *IFAILR, int *info, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor dhsein_$descriptor() {
        return dhsein_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dhsein_(const char *side, const char *eigsrc, const char *initv, int *select, const int *n, const double *H, const int *ldh, double *WR, const double *WI, double *VL, const int *ldvl, double *VR, const int *ldvr, const int *mm, int *m, double *work, int *IFAILL, int *IFAILR, int *info, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle dhsein_$handle() {
        return dhsein_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dhsein_(const char *side, const char *eigsrc, const char *initv, int *select, const int *n, const double *H, const int *ldh, double *WR, const double *WI, double *VL, const int *ldvl, double *VR, const int *ldvr, const int *mm, int *m, double *work, int *IFAILL, int *IFAILR, int *info, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment dhsein_$address() {
        return dhsein_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dhsein_(const char *side, const char *eigsrc, const char *initv, int *select, const int *n, const double *H, const int *ldh, double *WR, const double *WI, double *VL, const int *ldvl, double *VR, const int *ldvr, const int *mm, int *m, double *work, int *IFAILL, int *IFAILR, int *info, size_t, size_t, size_t)
     * }
     */
    public static void dhsein_(MemorySegment side, MemorySegment eigsrc, MemorySegment initv, MemorySegment select, MemorySegment n, MemorySegment H, MemorySegment ldh, MemorySegment WR, MemorySegment WI, MemorySegment VL, MemorySegment ldvl, MemorySegment VR, MemorySegment ldvr, MemorySegment mm, MemorySegment m, MemorySegment work, MemorySegment IFAILL, MemorySegment IFAILR, MemorySegment info, long x19, long x20, long x21) {
        var mh$ = dhsein_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dhsein_", side, eigsrc, initv, select, n, H, ldh, WR, WI, VL, ldvl, VR, ldvr, mm, m, work, IFAILL, IFAILR, info, x19, x20, x21);
            }
            mh$.invokeExact(side, eigsrc, initv, select, n, H, ldh, WR, WI, VL, ldvl, VR, ldvr, mm, m, work, IFAILL, IFAILR, info, x19, x20, x21);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class shsein_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("shsein_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void shsein_(const char *side, const char *eigsrc, const char *initv, int *select, const int *n, const float *H, const int *ldh, float *WR, const float *WI, float *VL, const int *ldvl, float *VR, const int *ldvr, const int *mm, int *m, float *work, int *IFAILL, int *IFAILR, int *info, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor shsein_$descriptor() {
        return shsein_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void shsein_(const char *side, const char *eigsrc, const char *initv, int *select, const int *n, const float *H, const int *ldh, float *WR, const float *WI, float *VL, const int *ldvl, float *VR, const int *ldvr, const int *mm, int *m, float *work, int *IFAILL, int *IFAILR, int *info, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle shsein_$handle() {
        return shsein_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void shsein_(const char *side, const char *eigsrc, const char *initv, int *select, const int *n, const float *H, const int *ldh, float *WR, const float *WI, float *VL, const int *ldvl, float *VR, const int *ldvr, const int *mm, int *m, float *work, int *IFAILL, int *IFAILR, int *info, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment shsein_$address() {
        return shsein_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void shsein_(const char *side, const char *eigsrc, const char *initv, int *select, const int *n, const float *H, const int *ldh, float *WR, const float *WI, float *VL, const int *ldvl, float *VR, const int *ldvr, const int *mm, int *m, float *work, int *IFAILL, int *IFAILR, int *info, size_t, size_t, size_t)
     * }
     */
    public static void shsein_(MemorySegment side, MemorySegment eigsrc, MemorySegment initv, MemorySegment select, MemorySegment n, MemorySegment H, MemorySegment ldh, MemorySegment WR, MemorySegment WI, MemorySegment VL, MemorySegment ldvl, MemorySegment VR, MemorySegment ldvr, MemorySegment mm, MemorySegment m, MemorySegment work, MemorySegment IFAILL, MemorySegment IFAILR, MemorySegment info, long x19, long x20, long x21) {
        var mh$ = shsein_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("shsein_", side, eigsrc, initv, select, n, H, ldh, WR, WI, VL, ldvl, VR, ldvr, mm, m, work, IFAILL, IFAILR, info, x19, x20, x21);
            }
            mh$.invokeExact(side, eigsrc, initv, select, n, H, ldh, WR, WI, VL, ldvl, VR, ldvr, mm, m, work, IFAILL, IFAILR, info, x19, x20, x21);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zhsein_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("zhsein_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zhsein_(const char *side, const char *eigsrc, const char *initv, const int *select, const int *n, const _Complex double *H, const int *ldh, _Complex double *W, _Complex double *VL, const int *ldvl, _Complex double *VR, const int *ldvr, const int *mm, int *m, _Complex double *work, double *rwork, int *IFAILL, int *IFAILR, int *info, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor zhsein_$descriptor() {
        return zhsein_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zhsein_(const char *side, const char *eigsrc, const char *initv, const int *select, const int *n, const _Complex double *H, const int *ldh, _Complex double *W, _Complex double *VL, const int *ldvl, _Complex double *VR, const int *ldvr, const int *mm, int *m, _Complex double *work, double *rwork, int *IFAILL, int *IFAILR, int *info, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle zhsein_$handle() {
        return zhsein_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zhsein_(const char *side, const char *eigsrc, const char *initv, const int *select, const int *n, const _Complex double *H, const int *ldh, _Complex double *W, _Complex double *VL, const int *ldvl, _Complex double *VR, const int *ldvr, const int *mm, int *m, _Complex double *work, double *rwork, int *IFAILL, int *IFAILR, int *info, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment zhsein_$address() {
        return zhsein_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zhsein_(const char *side, const char *eigsrc, const char *initv, const int *select, const int *n, const _Complex double *H, const int *ldh, _Complex double *W, _Complex double *VL, const int *ldvl, _Complex double *VR, const int *ldvr, const int *mm, int *m, _Complex double *work, double *rwork, int *IFAILL, int *IFAILR, int *info, size_t, size_t, size_t)
     * }
     */
    public static void zhsein_(MemorySegment side, MemorySegment eigsrc, MemorySegment initv, MemorySegment select, MemorySegment n, MemorySegment H, MemorySegment ldh, MemorySegment W, MemorySegment VL, MemorySegment ldvl, MemorySegment VR, MemorySegment ldvr, MemorySegment mm, MemorySegment m, MemorySegment work, MemorySegment rwork, MemorySegment IFAILL, MemorySegment IFAILR, MemorySegment info, long x19, long x20, long x21) {
        var mh$ = zhsein_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zhsein_", side, eigsrc, initv, select, n, H, ldh, W, VL, ldvl, VR, ldvr, mm, m, work, rwork, IFAILL, IFAILR, info, x19, x20, x21);
            }
            mh$.invokeExact(side, eigsrc, initv, select, n, H, ldh, W, VL, ldvl, VR, ldvr, mm, m, work, rwork, IFAILL, IFAILR, info, x19, x20, x21);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class chseqr_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("chseqr_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void chseqr_(const char *job, const char *compz, const int *n, const int *ilo, const int *ihi, _Complex float *H, const int *ldh, _Complex float *W, _Complex float *Z, const int *ldz, _Complex float *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor chseqr_$descriptor() {
        return chseqr_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void chseqr_(const char *job, const char *compz, const int *n, const int *ilo, const int *ihi, _Complex float *H, const int *ldh, _Complex float *W, _Complex float *Z, const int *ldz, _Complex float *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle chseqr_$handle() {
        return chseqr_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void chseqr_(const char *job, const char *compz, const int *n, const int *ilo, const int *ihi, _Complex float *H, const int *ldh, _Complex float *W, _Complex float *Z, const int *ldz, _Complex float *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment chseqr_$address() {
        return chseqr_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void chseqr_(const char *job, const char *compz, const int *n, const int *ilo, const int *ihi, _Complex float *H, const int *ldh, _Complex float *W, _Complex float *Z, const int *ldz, _Complex float *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static void chseqr_(MemorySegment job, MemorySegment compz, MemorySegment n, MemorySegment ilo, MemorySegment ihi, MemorySegment H, MemorySegment ldh, MemorySegment W, MemorySegment Z, MemorySegment ldz, MemorySegment work, MemorySegment lwork, MemorySegment info, long x13, long x14) {
        var mh$ = chseqr_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("chseqr_", job, compz, n, ilo, ihi, H, ldh, W, Z, ldz, work, lwork, info, x13, x14);
            }
            mh$.invokeExact(job, compz, n, ilo, ihi, H, ldh, W, Z, ldz, work, lwork, info, x13, x14);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dhseqr_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("dhseqr_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dhseqr_(const char *job, const char *compz, const int *n, const int *ilo, const int *ihi, double *H, const int *ldh, double *WR, double *WI, double *Z, const int *ldz, double *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor dhseqr_$descriptor() {
        return dhseqr_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dhseqr_(const char *job, const char *compz, const int *n, const int *ilo, const int *ihi, double *H, const int *ldh, double *WR, double *WI, double *Z, const int *ldz, double *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle dhseqr_$handle() {
        return dhseqr_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dhseqr_(const char *job, const char *compz, const int *n, const int *ilo, const int *ihi, double *H, const int *ldh, double *WR, double *WI, double *Z, const int *ldz, double *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment dhseqr_$address() {
        return dhseqr_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dhseqr_(const char *job, const char *compz, const int *n, const int *ilo, const int *ihi, double *H, const int *ldh, double *WR, double *WI, double *Z, const int *ldz, double *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static void dhseqr_(MemorySegment job, MemorySegment compz, MemorySegment n, MemorySegment ilo, MemorySegment ihi, MemorySegment H, MemorySegment ldh, MemorySegment WR, MemorySegment WI, MemorySegment Z, MemorySegment ldz, MemorySegment work, MemorySegment lwork, MemorySegment info, long x14, long x15) {
        var mh$ = dhseqr_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dhseqr_", job, compz, n, ilo, ihi, H, ldh, WR, WI, Z, ldz, work, lwork, info, x14, x15);
            }
            mh$.invokeExact(job, compz, n, ilo, ihi, H, ldh, WR, WI, Z, ldz, work, lwork, info, x14, x15);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class shseqr_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("shseqr_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void shseqr_(const char *job, const char *compz, const int *n, const int *ilo, const int *ihi, float *H, const int *ldh, float *WR, float *WI, float *Z, const int *ldz, float *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor shseqr_$descriptor() {
        return shseqr_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void shseqr_(const char *job, const char *compz, const int *n, const int *ilo, const int *ihi, float *H, const int *ldh, float *WR, float *WI, float *Z, const int *ldz, float *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle shseqr_$handle() {
        return shseqr_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void shseqr_(const char *job, const char *compz, const int *n, const int *ilo, const int *ihi, float *H, const int *ldh, float *WR, float *WI, float *Z, const int *ldz, float *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment shseqr_$address() {
        return shseqr_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void shseqr_(const char *job, const char *compz, const int *n, const int *ilo, const int *ihi, float *H, const int *ldh, float *WR, float *WI, float *Z, const int *ldz, float *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static void shseqr_(MemorySegment job, MemorySegment compz, MemorySegment n, MemorySegment ilo, MemorySegment ihi, MemorySegment H, MemorySegment ldh, MemorySegment WR, MemorySegment WI, MemorySegment Z, MemorySegment ldz, MemorySegment work, MemorySegment lwork, MemorySegment info, long x14, long x15) {
        var mh$ = shseqr_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("shseqr_", job, compz, n, ilo, ihi, H, ldh, WR, WI, Z, ldz, work, lwork, info, x14, x15);
            }
            mh$.invokeExact(job, compz, n, ilo, ihi, H, ldh, WR, WI, Z, ldz, work, lwork, info, x14, x15);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zhseqr_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("zhseqr_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zhseqr_(const char *job, const char *compz, const int *n, const int *ilo, const int *ihi, _Complex double *H, const int *ldh, _Complex double *W, _Complex double *Z, const int *ldz, _Complex double *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor zhseqr_$descriptor() {
        return zhseqr_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zhseqr_(const char *job, const char *compz, const int *n, const int *ilo, const int *ihi, _Complex double *H, const int *ldh, _Complex double *W, _Complex double *Z, const int *ldz, _Complex double *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle zhseqr_$handle() {
        return zhseqr_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zhseqr_(const char *job, const char *compz, const int *n, const int *ilo, const int *ihi, _Complex double *H, const int *ldh, _Complex double *W, _Complex double *Z, const int *ldz, _Complex double *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment zhseqr_$address() {
        return zhseqr_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zhseqr_(const char *job, const char *compz, const int *n, const int *ilo, const int *ihi, _Complex double *H, const int *ldh, _Complex double *W, _Complex double *Z, const int *ldz, _Complex double *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static void zhseqr_(MemorySegment job, MemorySegment compz, MemorySegment n, MemorySegment ilo, MemorySegment ihi, MemorySegment H, MemorySegment ldh, MemorySegment W, MemorySegment Z, MemorySegment ldz, MemorySegment work, MemorySegment lwork, MemorySegment info, long x13, long x14) {
        var mh$ = zhseqr_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zhseqr_", job, compz, n, ilo, ihi, H, ldh, W, Z, ldz, work, lwork, info, x13, x14);
            }
            mh$.invokeExact(job, compz, n, ilo, ihi, H, ldh, W, Z, ldz, work, lwork, info, x13, x14);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clacgv_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("clacgv_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void clacgv_(const int *n, _Complex float *X, const int *incx)
     * }
     */
    public static FunctionDescriptor clacgv_$descriptor() {
        return clacgv_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void clacgv_(const int *n, _Complex float *X, const int *incx)
     * }
     */
    public static MethodHandle clacgv_$handle() {
        return clacgv_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void clacgv_(const int *n, _Complex float *X, const int *incx)
     * }
     */
    public static MemorySegment clacgv_$address() {
        return clacgv_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void clacgv_(const int *n, _Complex float *X, const int *incx)
     * }
     */
    public static void clacgv_(MemorySegment n, MemorySegment X, MemorySegment incx) {
        var mh$ = clacgv_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clacgv_", n, X, incx);
            }
            mh$.invokeExact(n, X, incx);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zlacgv_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("zlacgv_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zlacgv_(const int *n, _Complex double *X, const int *incx)
     * }
     */
    public static FunctionDescriptor zlacgv_$descriptor() {
        return zlacgv_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zlacgv_(const int *n, _Complex double *X, const int *incx)
     * }
     */
    public static MethodHandle zlacgv_$handle() {
        return zlacgv_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zlacgv_(const int *n, _Complex double *X, const int *incx)
     * }
     */
    public static MemorySegment zlacgv_$address() {
        return zlacgv_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zlacgv_(const int *n, _Complex double *X, const int *incx)
     * }
     */
    public static void zlacgv_(MemorySegment n, MemorySegment X, MemorySegment incx) {
        var mh$ = zlacgv_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zlacgv_", n, X, incx);
            }
            mh$.invokeExact(n, X, incx);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clacn2_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("clacn2_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void clacn2_(const int *n, _Complex float *V, _Complex float *X, float *est, int *kase, int *ISAVE)
     * }
     */
    public static FunctionDescriptor clacn2_$descriptor() {
        return clacn2_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void clacn2_(const int *n, _Complex float *V, _Complex float *X, float *est, int *kase, int *ISAVE)
     * }
     */
    public static MethodHandle clacn2_$handle() {
        return clacn2_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void clacn2_(const int *n, _Complex float *V, _Complex float *X, float *est, int *kase, int *ISAVE)
     * }
     */
    public static MemorySegment clacn2_$address() {
        return clacn2_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void clacn2_(const int *n, _Complex float *V, _Complex float *X, float *est, int *kase, int *ISAVE)
     * }
     */
    public static void clacn2_(MemorySegment n, MemorySegment V, MemorySegment X, MemorySegment est, MemorySegment kase, MemorySegment ISAVE) {
        var mh$ = clacn2_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clacn2_", n, V, X, est, kase, ISAVE);
            }
            mh$.invokeExact(n, V, X, est, kase, ISAVE);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dlacn2_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("dlacn2_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dlacn2_(const int *n, double *V, double *X, int *ISGN, double *est, int *kase, int *ISAVE)
     * }
     */
    public static FunctionDescriptor dlacn2_$descriptor() {
        return dlacn2_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dlacn2_(const int *n, double *V, double *X, int *ISGN, double *est, int *kase, int *ISAVE)
     * }
     */
    public static MethodHandle dlacn2_$handle() {
        return dlacn2_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dlacn2_(const int *n, double *V, double *X, int *ISGN, double *est, int *kase, int *ISAVE)
     * }
     */
    public static MemorySegment dlacn2_$address() {
        return dlacn2_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dlacn2_(const int *n, double *V, double *X, int *ISGN, double *est, int *kase, int *ISAVE)
     * }
     */
    public static void dlacn2_(MemorySegment n, MemorySegment V, MemorySegment X, MemorySegment ISGN, MemorySegment est, MemorySegment kase, MemorySegment ISAVE) {
        var mh$ = dlacn2_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dlacn2_", n, V, X, ISGN, est, kase, ISAVE);
            }
            mh$.invokeExact(n, V, X, ISGN, est, kase, ISAVE);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class slacn2_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("slacn2_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void slacn2_(const int *n, float *V, float *X, int *ISGN, float *est, int *kase, int *ISAVE)
     * }
     */
    public static FunctionDescriptor slacn2_$descriptor() {
        return slacn2_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void slacn2_(const int *n, float *V, float *X, int *ISGN, float *est, int *kase, int *ISAVE)
     * }
     */
    public static MethodHandle slacn2_$handle() {
        return slacn2_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void slacn2_(const int *n, float *V, float *X, int *ISGN, float *est, int *kase, int *ISAVE)
     * }
     */
    public static MemorySegment slacn2_$address() {
        return slacn2_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void slacn2_(const int *n, float *V, float *X, int *ISGN, float *est, int *kase, int *ISAVE)
     * }
     */
    public static void slacn2_(MemorySegment n, MemorySegment V, MemorySegment X, MemorySegment ISGN, MemorySegment est, MemorySegment kase, MemorySegment ISAVE) {
        var mh$ = slacn2_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("slacn2_", n, V, X, ISGN, est, kase, ISAVE);
            }
            mh$.invokeExact(n, V, X, ISGN, est, kase, ISAVE);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zlacn2_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("zlacn2_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zlacn2_(const int *n, _Complex double *V, _Complex double *X, double *est, int *kase, int *ISAVE)
     * }
     */
    public static FunctionDescriptor zlacn2_$descriptor() {
        return zlacn2_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zlacn2_(const int *n, _Complex double *V, _Complex double *X, double *est, int *kase, int *ISAVE)
     * }
     */
    public static MethodHandle zlacn2_$handle() {
        return zlacn2_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zlacn2_(const int *n, _Complex double *V, _Complex double *X, double *est, int *kase, int *ISAVE)
     * }
     */
    public static MemorySegment zlacn2_$address() {
        return zlacn2_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zlacn2_(const int *n, _Complex double *V, _Complex double *X, double *est, int *kase, int *ISAVE)
     * }
     */
    public static void zlacn2_(MemorySegment n, MemorySegment V, MemorySegment X, MemorySegment est, MemorySegment kase, MemorySegment ISAVE) {
        var mh$ = zlacn2_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zlacn2_", n, V, X, est, kase, ISAVE);
            }
            mh$.invokeExact(n, V, X, est, kase, ISAVE);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clacp2_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("clacp2_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void clacp2_(const char *uplo, const int *m, const int *n, const float *A, const int *lda, _Complex float *B, const int *ldb, size_t)
     * }
     */
    public static FunctionDescriptor clacp2_$descriptor() {
        return clacp2_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void clacp2_(const char *uplo, const int *m, const int *n, const float *A, const int *lda, _Complex float *B, const int *ldb, size_t)
     * }
     */
    public static MethodHandle clacp2_$handle() {
        return clacp2_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void clacp2_(const char *uplo, const int *m, const int *n, const float *A, const int *lda, _Complex float *B, const int *ldb, size_t)
     * }
     */
    public static MemorySegment clacp2_$address() {
        return clacp2_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void clacp2_(const char *uplo, const int *m, const int *n, const float *A, const int *lda, _Complex float *B, const int *ldb, size_t)
     * }
     */
    public static void clacp2_(MemorySegment uplo, MemorySegment m, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment B, MemorySegment ldb, long x7) {
        var mh$ = clacp2_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clacp2_", uplo, m, n, A, lda, B, ldb, x7);
            }
            mh$.invokeExact(uplo, m, n, A, lda, B, ldb, x7);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zlacp2_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("zlacp2_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zlacp2_(const char *uplo, const int *m, const int *n, const double *A, const int *lda, _Complex double *B, const int *ldb, size_t)
     * }
     */
    public static FunctionDescriptor zlacp2_$descriptor() {
        return zlacp2_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zlacp2_(const char *uplo, const int *m, const int *n, const double *A, const int *lda, _Complex double *B, const int *ldb, size_t)
     * }
     */
    public static MethodHandle zlacp2_$handle() {
        return zlacp2_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zlacp2_(const char *uplo, const int *m, const int *n, const double *A, const int *lda, _Complex double *B, const int *ldb, size_t)
     * }
     */
    public static MemorySegment zlacp2_$address() {
        return zlacp2_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zlacp2_(const char *uplo, const int *m, const int *n, const double *A, const int *lda, _Complex double *B, const int *ldb, size_t)
     * }
     */
    public static void zlacp2_(MemorySegment uplo, MemorySegment m, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment B, MemorySegment ldb, long x7) {
        var mh$ = zlacp2_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zlacp2_", uplo, m, n, A, lda, B, ldb, x7);
            }
            mh$.invokeExact(uplo, m, n, A, lda, B, ldb, x7);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clacpy_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("clacpy_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void clacpy_(const char *uplo, const int *m, const int *n, const _Complex float *A, const int *lda, _Complex float *B, const int *ldb, size_t)
     * }
     */
    public static FunctionDescriptor clacpy_$descriptor() {
        return clacpy_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void clacpy_(const char *uplo, const int *m, const int *n, const _Complex float *A, const int *lda, _Complex float *B, const int *ldb, size_t)
     * }
     */
    public static MethodHandle clacpy_$handle() {
        return clacpy_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void clacpy_(const char *uplo, const int *m, const int *n, const _Complex float *A, const int *lda, _Complex float *B, const int *ldb, size_t)
     * }
     */
    public static MemorySegment clacpy_$address() {
        return clacpy_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void clacpy_(const char *uplo, const int *m, const int *n, const _Complex float *A, const int *lda, _Complex float *B, const int *ldb, size_t)
     * }
     */
    public static void clacpy_(MemorySegment uplo, MemorySegment m, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment B, MemorySegment ldb, long x7) {
        var mh$ = clacpy_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clacpy_", uplo, m, n, A, lda, B, ldb, x7);
            }
            mh$.invokeExact(uplo, m, n, A, lda, B, ldb, x7);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dlacpy_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("dlacpy_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dlacpy_(const char *uplo, const int *m, const int *n, const double *A, const int *lda, double *B, const int *ldb, size_t)
     * }
     */
    public static FunctionDescriptor dlacpy_$descriptor() {
        return dlacpy_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dlacpy_(const char *uplo, const int *m, const int *n, const double *A, const int *lda, double *B, const int *ldb, size_t)
     * }
     */
    public static MethodHandle dlacpy_$handle() {
        return dlacpy_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dlacpy_(const char *uplo, const int *m, const int *n, const double *A, const int *lda, double *B, const int *ldb, size_t)
     * }
     */
    public static MemorySegment dlacpy_$address() {
        return dlacpy_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dlacpy_(const char *uplo, const int *m, const int *n, const double *A, const int *lda, double *B, const int *ldb, size_t)
     * }
     */
    public static void dlacpy_(MemorySegment uplo, MemorySegment m, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment B, MemorySegment ldb, long x7) {
        var mh$ = dlacpy_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dlacpy_", uplo, m, n, A, lda, B, ldb, x7);
            }
            mh$.invokeExact(uplo, m, n, A, lda, B, ldb, x7);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class slacpy_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("slacpy_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void slacpy_(const char *uplo, const int *m, const int *n, const float *A, const int *lda, float *B, const int *ldb, size_t)
     * }
     */
    public static FunctionDescriptor slacpy_$descriptor() {
        return slacpy_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void slacpy_(const char *uplo, const int *m, const int *n, const float *A, const int *lda, float *B, const int *ldb, size_t)
     * }
     */
    public static MethodHandle slacpy_$handle() {
        return slacpy_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void slacpy_(const char *uplo, const int *m, const int *n, const float *A, const int *lda, float *B, const int *ldb, size_t)
     * }
     */
    public static MemorySegment slacpy_$address() {
        return slacpy_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void slacpy_(const char *uplo, const int *m, const int *n, const float *A, const int *lda, float *B, const int *ldb, size_t)
     * }
     */
    public static void slacpy_(MemorySegment uplo, MemorySegment m, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment B, MemorySegment ldb, long x7) {
        var mh$ = slacpy_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("slacpy_", uplo, m, n, A, lda, B, ldb, x7);
            }
            mh$.invokeExact(uplo, m, n, A, lda, B, ldb, x7);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zlacpy_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("zlacpy_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zlacpy_(const char *uplo, const int *m, const int *n, const _Complex double *A, const int *lda, _Complex double *B, const int *ldb, size_t)
     * }
     */
    public static FunctionDescriptor zlacpy_$descriptor() {
        return zlacpy_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zlacpy_(const char *uplo, const int *m, const int *n, const _Complex double *A, const int *lda, _Complex double *B, const int *ldb, size_t)
     * }
     */
    public static MethodHandle zlacpy_$handle() {
        return zlacpy_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zlacpy_(const char *uplo, const int *m, const int *n, const _Complex double *A, const int *lda, _Complex double *B, const int *ldb, size_t)
     * }
     */
    public static MemorySegment zlacpy_$address() {
        return zlacpy_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zlacpy_(const char *uplo, const int *m, const int *n, const _Complex double *A, const int *lda, _Complex double *B, const int *ldb, size_t)
     * }
     */
    public static void zlacpy_(MemorySegment uplo, MemorySegment m, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment B, MemorySegment ldb, long x7) {
        var mh$ = zlacpy_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zlacpy_", uplo, m, n, A, lda, B, ldb, x7);
            }
            mh$.invokeExact(uplo, m, n, A, lda, B, ldb, x7);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clacrm_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("clacrm_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void clacrm_(const int *m, const int *n, const _Complex float *A, const int *lda, const float *B, const int *ldb, _Complex float *C, const int *ldc, float *rwork)
     * }
     */
    public static FunctionDescriptor clacrm_$descriptor() {
        return clacrm_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void clacrm_(const int *m, const int *n, const _Complex float *A, const int *lda, const float *B, const int *ldb, _Complex float *C, const int *ldc, float *rwork)
     * }
     */
    public static MethodHandle clacrm_$handle() {
        return clacrm_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void clacrm_(const int *m, const int *n, const _Complex float *A, const int *lda, const float *B, const int *ldb, _Complex float *C, const int *ldc, float *rwork)
     * }
     */
    public static MemorySegment clacrm_$address() {
        return clacrm_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void clacrm_(const int *m, const int *n, const _Complex float *A, const int *lda, const float *B, const int *ldb, _Complex float *C, const int *ldc, float *rwork)
     * }
     */
    public static void clacrm_(MemorySegment m, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment B, MemorySegment ldb, MemorySegment C, MemorySegment ldc, MemorySegment rwork) {
        var mh$ = clacrm_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clacrm_", m, n, A, lda, B, ldb, C, ldc, rwork);
            }
            mh$.invokeExact(m, n, A, lda, B, ldb, C, ldc, rwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zlacrm_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("zlacrm_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zlacrm_(const int *m, const int *n, const _Complex double *A, const int *lda, const double *B, const int *ldb, _Complex double *C, const int *ldc, double *rwork)
     * }
     */
    public static FunctionDescriptor zlacrm_$descriptor() {
        return zlacrm_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zlacrm_(const int *m, const int *n, const _Complex double *A, const int *lda, const double *B, const int *ldb, _Complex double *C, const int *ldc, double *rwork)
     * }
     */
    public static MethodHandle zlacrm_$handle() {
        return zlacrm_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zlacrm_(const int *m, const int *n, const _Complex double *A, const int *lda, const double *B, const int *ldb, _Complex double *C, const int *ldc, double *rwork)
     * }
     */
    public static MemorySegment zlacrm_$address() {
        return zlacrm_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zlacrm_(const int *m, const int *n, const _Complex double *A, const int *lda, const double *B, const int *ldb, _Complex double *C, const int *ldc, double *rwork)
     * }
     */
    public static void zlacrm_(MemorySegment m, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment B, MemorySegment ldb, MemorySegment C, MemorySegment ldc, MemorySegment rwork) {
        var mh$ = zlacrm_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zlacrm_", m, n, A, lda, B, ldb, C, ldc, rwork);
            }
            mh$.invokeExact(m, n, A, lda, B, ldb, C, ldc, rwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zlag2c_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("zlag2c_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zlag2c_(const int *m, const int *n, const _Complex double *A, const int *lda, _Complex float *SA, const int *ldsa, int *info)
     * }
     */
    public static FunctionDescriptor zlag2c_$descriptor() {
        return zlag2c_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zlag2c_(const int *m, const int *n, const _Complex double *A, const int *lda, _Complex float *SA, const int *ldsa, int *info)
     * }
     */
    public static MethodHandle zlag2c_$handle() {
        return zlag2c_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zlag2c_(const int *m, const int *n, const _Complex double *A, const int *lda, _Complex float *SA, const int *ldsa, int *info)
     * }
     */
    public static MemorySegment zlag2c_$address() {
        return zlag2c_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zlag2c_(const int *m, const int *n, const _Complex double *A, const int *lda, _Complex float *SA, const int *ldsa, int *info)
     * }
     */
    public static void zlag2c_(MemorySegment m, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment SA, MemorySegment ldsa, MemorySegment info) {
        var mh$ = zlag2c_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zlag2c_", m, n, A, lda, SA, ldsa, info);
            }
            mh$.invokeExact(m, n, A, lda, SA, ldsa, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class slag2d_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("slag2d_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void slag2d_(const int *m, const int *n, const float *SA, const int *ldsa, double *A, const int *lda, int *info)
     * }
     */
    public static FunctionDescriptor slag2d_$descriptor() {
        return slag2d_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void slag2d_(const int *m, const int *n, const float *SA, const int *ldsa, double *A, const int *lda, int *info)
     * }
     */
    public static MethodHandle slag2d_$handle() {
        return slag2d_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void slag2d_(const int *m, const int *n, const float *SA, const int *ldsa, double *A, const int *lda, int *info)
     * }
     */
    public static MemorySegment slag2d_$address() {
        return slag2d_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void slag2d_(const int *m, const int *n, const float *SA, const int *ldsa, double *A, const int *lda, int *info)
     * }
     */
    public static void slag2d_(MemorySegment m, MemorySegment n, MemorySegment SA, MemorySegment ldsa, MemorySegment A, MemorySegment lda, MemorySegment info) {
        var mh$ = slag2d_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("slag2d_", m, n, SA, ldsa, A, lda, info);
            }
            mh$.invokeExact(m, n, SA, ldsa, A, lda, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dlag2s_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("dlag2s_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dlag2s_(const int *m, const int *n, const double *A, const int *lda, float *SA, const int *ldsa, int *info)
     * }
     */
    public static FunctionDescriptor dlag2s_$descriptor() {
        return dlag2s_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dlag2s_(const int *m, const int *n, const double *A, const int *lda, float *SA, const int *ldsa, int *info)
     * }
     */
    public static MethodHandle dlag2s_$handle() {
        return dlag2s_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dlag2s_(const int *m, const int *n, const double *A, const int *lda, float *SA, const int *ldsa, int *info)
     * }
     */
    public static MemorySegment dlag2s_$address() {
        return dlag2s_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dlag2s_(const int *m, const int *n, const double *A, const int *lda, float *SA, const int *ldsa, int *info)
     * }
     */
    public static void dlag2s_(MemorySegment m, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment SA, MemorySegment ldsa, MemorySegment info) {
        var mh$ = dlag2s_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dlag2s_", m, n, A, lda, SA, ldsa, info);
            }
            mh$.invokeExact(m, n, A, lda, SA, ldsa, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clag2z_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("clag2z_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void clag2z_(const int *m, const int *n, const _Complex float *SA, const int *ldsa, _Complex double *A, const int *lda, int *info)
     * }
     */
    public static FunctionDescriptor clag2z_$descriptor() {
        return clag2z_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void clag2z_(const int *m, const int *n, const _Complex float *SA, const int *ldsa, _Complex double *A, const int *lda, int *info)
     * }
     */
    public static MethodHandle clag2z_$handle() {
        return clag2z_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void clag2z_(const int *m, const int *n, const _Complex float *SA, const int *ldsa, _Complex double *A, const int *lda, int *info)
     * }
     */
    public static MemorySegment clag2z_$address() {
        return clag2z_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void clag2z_(const int *m, const int *n, const _Complex float *SA, const int *ldsa, _Complex double *A, const int *lda, int *info)
     * }
     */
    public static void clag2z_(MemorySegment m, MemorySegment n, MemorySegment SA, MemorySegment ldsa, MemorySegment A, MemorySegment lda, MemorySegment info) {
        var mh$ = clag2z_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clag2z_", m, n, SA, ldsa, A, lda, info);
            }
            mh$.invokeExact(m, n, SA, ldsa, A, lda, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clagge_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("clagge_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void clagge_(const int *m, const int *n, const int *kl, const int *ku, const float *D, _Complex float *A, const int *lda, int *iseed, _Complex float *work, int *info)
     * }
     */
    public static FunctionDescriptor clagge_$descriptor() {
        return clagge_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void clagge_(const int *m, const int *n, const int *kl, const int *ku, const float *D, _Complex float *A, const int *lda, int *iseed, _Complex float *work, int *info)
     * }
     */
    public static MethodHandle clagge_$handle() {
        return clagge_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void clagge_(const int *m, const int *n, const int *kl, const int *ku, const float *D, _Complex float *A, const int *lda, int *iseed, _Complex float *work, int *info)
     * }
     */
    public static MemorySegment clagge_$address() {
        return clagge_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void clagge_(const int *m, const int *n, const int *kl, const int *ku, const float *D, _Complex float *A, const int *lda, int *iseed, _Complex float *work, int *info)
     * }
     */
    public static void clagge_(MemorySegment m, MemorySegment n, MemorySegment kl, MemorySegment ku, MemorySegment D, MemorySegment A, MemorySegment lda, MemorySegment iseed, MemorySegment work, MemorySegment info) {
        var mh$ = clagge_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clagge_", m, n, kl, ku, D, A, lda, iseed, work, info);
            }
            mh$.invokeExact(m, n, kl, ku, D, A, lda, iseed, work, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dlagge_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("dlagge_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dlagge_(const int *m, const int *n, const int *kl, const int *ku, const double *D, double *A, const int *lda, int *iseed, double *work, int *info)
     * }
     */
    public static FunctionDescriptor dlagge_$descriptor() {
        return dlagge_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dlagge_(const int *m, const int *n, const int *kl, const int *ku, const double *D, double *A, const int *lda, int *iseed, double *work, int *info)
     * }
     */
    public static MethodHandle dlagge_$handle() {
        return dlagge_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dlagge_(const int *m, const int *n, const int *kl, const int *ku, const double *D, double *A, const int *lda, int *iseed, double *work, int *info)
     * }
     */
    public static MemorySegment dlagge_$address() {
        return dlagge_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dlagge_(const int *m, const int *n, const int *kl, const int *ku, const double *D, double *A, const int *lda, int *iseed, double *work, int *info)
     * }
     */
    public static void dlagge_(MemorySegment m, MemorySegment n, MemorySegment kl, MemorySegment ku, MemorySegment D, MemorySegment A, MemorySegment lda, MemorySegment iseed, MemorySegment work, MemorySegment info) {
        var mh$ = dlagge_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dlagge_", m, n, kl, ku, D, A, lda, iseed, work, info);
            }
            mh$.invokeExact(m, n, kl, ku, D, A, lda, iseed, work, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class slagge_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("slagge_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void slagge_(const int *m, const int *n, const int *kl, const int *ku, const float *D, float *A, const int *lda, int *iseed, float *work, int *info)
     * }
     */
    public static FunctionDescriptor slagge_$descriptor() {
        return slagge_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void slagge_(const int *m, const int *n, const int *kl, const int *ku, const float *D, float *A, const int *lda, int *iseed, float *work, int *info)
     * }
     */
    public static MethodHandle slagge_$handle() {
        return slagge_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void slagge_(const int *m, const int *n, const int *kl, const int *ku, const float *D, float *A, const int *lda, int *iseed, float *work, int *info)
     * }
     */
    public static MemorySegment slagge_$address() {
        return slagge_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void slagge_(const int *m, const int *n, const int *kl, const int *ku, const float *D, float *A, const int *lda, int *iseed, float *work, int *info)
     * }
     */
    public static void slagge_(MemorySegment m, MemorySegment n, MemorySegment kl, MemorySegment ku, MemorySegment D, MemorySegment A, MemorySegment lda, MemorySegment iseed, MemorySegment work, MemorySegment info) {
        var mh$ = slagge_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("slagge_", m, n, kl, ku, D, A, lda, iseed, work, info);
            }
            mh$.invokeExact(m, n, kl, ku, D, A, lda, iseed, work, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zlagge_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("zlagge_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zlagge_(const int *m, const int *n, const int *kl, const int *ku, const double *D, _Complex double *A, const int *lda, int *iseed, _Complex double *work, int *info)
     * }
     */
    public static FunctionDescriptor zlagge_$descriptor() {
        return zlagge_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zlagge_(const int *m, const int *n, const int *kl, const int *ku, const double *D, _Complex double *A, const int *lda, int *iseed, _Complex double *work, int *info)
     * }
     */
    public static MethodHandle zlagge_$handle() {
        return zlagge_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zlagge_(const int *m, const int *n, const int *kl, const int *ku, const double *D, _Complex double *A, const int *lda, int *iseed, _Complex double *work, int *info)
     * }
     */
    public static MemorySegment zlagge_$address() {
        return zlagge_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zlagge_(const int *m, const int *n, const int *kl, const int *ku, const double *D, _Complex double *A, const int *lda, int *iseed, _Complex double *work, int *info)
     * }
     */
    public static void zlagge_(MemorySegment m, MemorySegment n, MemorySegment kl, MemorySegment ku, MemorySegment D, MemorySegment A, MemorySegment lda, MemorySegment iseed, MemorySegment work, MemorySegment info) {
        var mh$ = zlagge_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zlagge_", m, n, kl, ku, D, A, lda, iseed, work, info);
            }
            mh$.invokeExact(m, n, kl, ku, D, A, lda, iseed, work, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class claghe_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("claghe_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void claghe_(const int *n, const int *k, const float *D, _Complex float *A, const int *lda, int *iseed, _Complex float *work, int *info)
     * }
     */
    public static FunctionDescriptor claghe_$descriptor() {
        return claghe_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void claghe_(const int *n, const int *k, const float *D, _Complex float *A, const int *lda, int *iseed, _Complex float *work, int *info)
     * }
     */
    public static MethodHandle claghe_$handle() {
        return claghe_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void claghe_(const int *n, const int *k, const float *D, _Complex float *A, const int *lda, int *iseed, _Complex float *work, int *info)
     * }
     */
    public static MemorySegment claghe_$address() {
        return claghe_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void claghe_(const int *n, const int *k, const float *D, _Complex float *A, const int *lda, int *iseed, _Complex float *work, int *info)
     * }
     */
    public static void claghe_(MemorySegment n, MemorySegment k, MemorySegment D, MemorySegment A, MemorySegment lda, MemorySegment iseed, MemorySegment work, MemorySegment info) {
        var mh$ = claghe_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("claghe_", n, k, D, A, lda, iseed, work, info);
            }
            mh$.invokeExact(n, k, D, A, lda, iseed, work, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zlaghe_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("zlaghe_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zlaghe_(const int *n, const int *k, const double *D, _Complex double *A, const int *lda, int *iseed, _Complex double *work, int *info)
     * }
     */
    public static FunctionDescriptor zlaghe_$descriptor() {
        return zlaghe_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zlaghe_(const int *n, const int *k, const double *D, _Complex double *A, const int *lda, int *iseed, _Complex double *work, int *info)
     * }
     */
    public static MethodHandle zlaghe_$handle() {
        return zlaghe_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zlaghe_(const int *n, const int *k, const double *D, _Complex double *A, const int *lda, int *iseed, _Complex double *work, int *info)
     * }
     */
    public static MemorySegment zlaghe_$address() {
        return zlaghe_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zlaghe_(const int *n, const int *k, const double *D, _Complex double *A, const int *lda, int *iseed, _Complex double *work, int *info)
     * }
     */
    public static void zlaghe_(MemorySegment n, MemorySegment k, MemorySegment D, MemorySegment A, MemorySegment lda, MemorySegment iseed, MemorySegment work, MemorySegment info) {
        var mh$ = zlaghe_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zlaghe_", n, k, D, A, lda, iseed, work, info);
            }
            mh$.invokeExact(n, k, D, A, lda, iseed, work, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clagsy_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("clagsy_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void clagsy_(const int *n, const int *k, const float *D, _Complex float *A, const int *lda, int *iseed, _Complex float *work, int *info)
     * }
     */
    public static FunctionDescriptor clagsy_$descriptor() {
        return clagsy_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void clagsy_(const int *n, const int *k, const float *D, _Complex float *A, const int *lda, int *iseed, _Complex float *work, int *info)
     * }
     */
    public static MethodHandle clagsy_$handle() {
        return clagsy_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void clagsy_(const int *n, const int *k, const float *D, _Complex float *A, const int *lda, int *iseed, _Complex float *work, int *info)
     * }
     */
    public static MemorySegment clagsy_$address() {
        return clagsy_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void clagsy_(const int *n, const int *k, const float *D, _Complex float *A, const int *lda, int *iseed, _Complex float *work, int *info)
     * }
     */
    public static void clagsy_(MemorySegment n, MemorySegment k, MemorySegment D, MemorySegment A, MemorySegment lda, MemorySegment iseed, MemorySegment work, MemorySegment info) {
        var mh$ = clagsy_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clagsy_", n, k, D, A, lda, iseed, work, info);
            }
            mh$.invokeExact(n, k, D, A, lda, iseed, work, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dlagsy_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("dlagsy_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dlagsy_(const int *n, const int *k, const double *D, double *A, const int *lda, int *iseed, double *work, int *info)
     * }
     */
    public static FunctionDescriptor dlagsy_$descriptor() {
        return dlagsy_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dlagsy_(const int *n, const int *k, const double *D, double *A, const int *lda, int *iseed, double *work, int *info)
     * }
     */
    public static MethodHandle dlagsy_$handle() {
        return dlagsy_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dlagsy_(const int *n, const int *k, const double *D, double *A, const int *lda, int *iseed, double *work, int *info)
     * }
     */
    public static MemorySegment dlagsy_$address() {
        return dlagsy_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dlagsy_(const int *n, const int *k, const double *D, double *A, const int *lda, int *iseed, double *work, int *info)
     * }
     */
    public static void dlagsy_(MemorySegment n, MemorySegment k, MemorySegment D, MemorySegment A, MemorySegment lda, MemorySegment iseed, MemorySegment work, MemorySegment info) {
        var mh$ = dlagsy_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dlagsy_", n, k, D, A, lda, iseed, work, info);
            }
            mh$.invokeExact(n, k, D, A, lda, iseed, work, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class slagsy_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("slagsy_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void slagsy_(const int *n, const int *k, const float *D, float *A, const int *lda, int *iseed, float *work, int *info)
     * }
     */
    public static FunctionDescriptor slagsy_$descriptor() {
        return slagsy_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void slagsy_(const int *n, const int *k, const float *D, float *A, const int *lda, int *iseed, float *work, int *info)
     * }
     */
    public static MethodHandle slagsy_$handle() {
        return slagsy_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void slagsy_(const int *n, const int *k, const float *D, float *A, const int *lda, int *iseed, float *work, int *info)
     * }
     */
    public static MemorySegment slagsy_$address() {
        return slagsy_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void slagsy_(const int *n, const int *k, const float *D, float *A, const int *lda, int *iseed, float *work, int *info)
     * }
     */
    public static void slagsy_(MemorySegment n, MemorySegment k, MemorySegment D, MemorySegment A, MemorySegment lda, MemorySegment iseed, MemorySegment work, MemorySegment info) {
        var mh$ = slagsy_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("slagsy_", n, k, D, A, lda, iseed, work, info);
            }
            mh$.invokeExact(n, k, D, A, lda, iseed, work, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zlagsy_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("zlagsy_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zlagsy_(const int *n, const int *k, const double *D, _Complex double *A, const int *lda, int *iseed, _Complex double *work, int *info)
     * }
     */
    public static FunctionDescriptor zlagsy_$descriptor() {
        return zlagsy_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zlagsy_(const int *n, const int *k, const double *D, _Complex double *A, const int *lda, int *iseed, _Complex double *work, int *info)
     * }
     */
    public static MethodHandle zlagsy_$handle() {
        return zlagsy_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zlagsy_(const int *n, const int *k, const double *D, _Complex double *A, const int *lda, int *iseed, _Complex double *work, int *info)
     * }
     */
    public static MemorySegment zlagsy_$address() {
        return zlagsy_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zlagsy_(const int *n, const int *k, const double *D, _Complex double *A, const int *lda, int *iseed, _Complex double *work, int *info)
     * }
     */
    public static void zlagsy_(MemorySegment n, MemorySegment k, MemorySegment D, MemorySegment A, MemorySegment lda, MemorySegment iseed, MemorySegment work, MemorySegment info) {
        var mh$ = zlagsy_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zlagsy_", n, k, D, A, lda, iseed, work, info);
            }
            mh$.invokeExact(n, k, D, A, lda, iseed, work, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dlamch_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("dlamch_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double dlamch_(const char *cmach, size_t)
     * }
     */
    public static FunctionDescriptor dlamch_$descriptor() {
        return dlamch_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double dlamch_(const char *cmach, size_t)
     * }
     */
    public static MethodHandle dlamch_$handle() {
        return dlamch_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double dlamch_(const char *cmach, size_t)
     * }
     */
    public static MemorySegment dlamch_$address() {
        return dlamch_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double dlamch_(const char *cmach, size_t)
     * }
     */
    public static double dlamch_(MemorySegment cmach, long x1) {
        var mh$ = dlamch_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dlamch_", cmach, x1);
            }
            return (double)mh$.invokeExact(cmach, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class slamch_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("slamch_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * lapack_float_return slamch_(const char *cmach, size_t)
     * }
     */
    public static FunctionDescriptor slamch_$descriptor() {
        return slamch_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * lapack_float_return slamch_(const char *cmach, size_t)
     * }
     */
    public static MethodHandle slamch_$handle() {
        return slamch_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * lapack_float_return slamch_(const char *cmach, size_t)
     * }
     */
    public static MemorySegment slamch_$address() {
        return slamch_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * lapack_float_return slamch_(const char *cmach, size_t)
     * }
     */
    public static float slamch_(MemorySegment cmach, long x1) {
        var mh$ = slamch_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("slamch_", cmach, x1);
            }
            return (float)mh$.invokeExact(cmach, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clangb_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("clangb_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * lapack_float_return clangb_(const char *norm, const int *n, const int *kl, const int *ku, const _Complex float *AB, const int *ldab, float *work, size_t)
     * }
     */
    public static FunctionDescriptor clangb_$descriptor() {
        return clangb_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * lapack_float_return clangb_(const char *norm, const int *n, const int *kl, const int *ku, const _Complex float *AB, const int *ldab, float *work, size_t)
     * }
     */
    public static MethodHandle clangb_$handle() {
        return clangb_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * lapack_float_return clangb_(const char *norm, const int *n, const int *kl, const int *ku, const _Complex float *AB, const int *ldab, float *work, size_t)
     * }
     */
    public static MemorySegment clangb_$address() {
        return clangb_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * lapack_float_return clangb_(const char *norm, const int *n, const int *kl, const int *ku, const _Complex float *AB, const int *ldab, float *work, size_t)
     * }
     */
    public static float clangb_(MemorySegment norm, MemorySegment n, MemorySegment kl, MemorySegment ku, MemorySegment AB, MemorySegment ldab, MemorySegment work, long x7) {
        var mh$ = clangb_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clangb_", norm, n, kl, ku, AB, ldab, work, x7);
            }
            return (float)mh$.invokeExact(norm, n, kl, ku, AB, ldab, work, x7);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dlangb_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("dlangb_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double dlangb_(const char *norm, const int *n, const int *kl, const int *ku, const double *AB, const int *ldab, double *work, size_t)
     * }
     */
    public static FunctionDescriptor dlangb_$descriptor() {
        return dlangb_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double dlangb_(const char *norm, const int *n, const int *kl, const int *ku, const double *AB, const int *ldab, double *work, size_t)
     * }
     */
    public static MethodHandle dlangb_$handle() {
        return dlangb_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double dlangb_(const char *norm, const int *n, const int *kl, const int *ku, const double *AB, const int *ldab, double *work, size_t)
     * }
     */
    public static MemorySegment dlangb_$address() {
        return dlangb_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double dlangb_(const char *norm, const int *n, const int *kl, const int *ku, const double *AB, const int *ldab, double *work, size_t)
     * }
     */
    public static double dlangb_(MemorySegment norm, MemorySegment n, MemorySegment kl, MemorySegment ku, MemorySegment AB, MemorySegment ldab, MemorySegment work, long x7) {
        var mh$ = dlangb_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dlangb_", norm, n, kl, ku, AB, ldab, work, x7);
            }
            return (double)mh$.invokeExact(norm, n, kl, ku, AB, ldab, work, x7);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class slangb_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("slangb_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * lapack_float_return slangb_(const char *norm, const int *n, const int *kl, const int *ku, const float *AB, const int *ldab, float *work, size_t)
     * }
     */
    public static FunctionDescriptor slangb_$descriptor() {
        return slangb_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * lapack_float_return slangb_(const char *norm, const int *n, const int *kl, const int *ku, const float *AB, const int *ldab, float *work, size_t)
     * }
     */
    public static MethodHandle slangb_$handle() {
        return slangb_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * lapack_float_return slangb_(const char *norm, const int *n, const int *kl, const int *ku, const float *AB, const int *ldab, float *work, size_t)
     * }
     */
    public static MemorySegment slangb_$address() {
        return slangb_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * lapack_float_return slangb_(const char *norm, const int *n, const int *kl, const int *ku, const float *AB, const int *ldab, float *work, size_t)
     * }
     */
    public static float slangb_(MemorySegment norm, MemorySegment n, MemorySegment kl, MemorySegment ku, MemorySegment AB, MemorySegment ldab, MemorySegment work, long x7) {
        var mh$ = slangb_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("slangb_", norm, n, kl, ku, AB, ldab, work, x7);
            }
            return (float)mh$.invokeExact(norm, n, kl, ku, AB, ldab, work, x7);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zlangb_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("zlangb_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double zlangb_(const char *norm, const int *n, const int *kl, const int *ku, const _Complex double *AB, const int *ldab, double *work, size_t)
     * }
     */
    public static FunctionDescriptor zlangb_$descriptor() {
        return zlangb_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double zlangb_(const char *norm, const int *n, const int *kl, const int *ku, const _Complex double *AB, const int *ldab, double *work, size_t)
     * }
     */
    public static MethodHandle zlangb_$handle() {
        return zlangb_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double zlangb_(const char *norm, const int *n, const int *kl, const int *ku, const _Complex double *AB, const int *ldab, double *work, size_t)
     * }
     */
    public static MemorySegment zlangb_$address() {
        return zlangb_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double zlangb_(const char *norm, const int *n, const int *kl, const int *ku, const _Complex double *AB, const int *ldab, double *work, size_t)
     * }
     */
    public static double zlangb_(MemorySegment norm, MemorySegment n, MemorySegment kl, MemorySegment ku, MemorySegment AB, MemorySegment ldab, MemorySegment work, long x7) {
        var mh$ = zlangb_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zlangb_", norm, n, kl, ku, AB, ldab, work, x7);
            }
            return (double)mh$.invokeExact(norm, n, kl, ku, AB, ldab, work, x7);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clange_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("clange_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * lapack_float_return clange_(const char *norm, const int *m, const int *n, const _Complex float *A, const int *lda, float *work, size_t)
     * }
     */
    public static FunctionDescriptor clange_$descriptor() {
        return clange_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * lapack_float_return clange_(const char *norm, const int *m, const int *n, const _Complex float *A, const int *lda, float *work, size_t)
     * }
     */
    public static MethodHandle clange_$handle() {
        return clange_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * lapack_float_return clange_(const char *norm, const int *m, const int *n, const _Complex float *A, const int *lda, float *work, size_t)
     * }
     */
    public static MemorySegment clange_$address() {
        return clange_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * lapack_float_return clange_(const char *norm, const int *m, const int *n, const _Complex float *A, const int *lda, float *work, size_t)
     * }
     */
    public static float clange_(MemorySegment norm, MemorySegment m, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment work, long x6) {
        var mh$ = clange_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clange_", norm, m, n, A, lda, work, x6);
            }
            return (float)mh$.invokeExact(norm, m, n, A, lda, work, x6);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dlange_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("dlange_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double dlange_(const char *norm, const int *m, const int *n, const double *A, const int *lda, double *work, size_t)
     * }
     */
    public static FunctionDescriptor dlange_$descriptor() {
        return dlange_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double dlange_(const char *norm, const int *m, const int *n, const double *A, const int *lda, double *work, size_t)
     * }
     */
    public static MethodHandle dlange_$handle() {
        return dlange_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double dlange_(const char *norm, const int *m, const int *n, const double *A, const int *lda, double *work, size_t)
     * }
     */
    public static MemorySegment dlange_$address() {
        return dlange_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double dlange_(const char *norm, const int *m, const int *n, const double *A, const int *lda, double *work, size_t)
     * }
     */
    public static double dlange_(MemorySegment norm, MemorySegment m, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment work, long x6) {
        var mh$ = dlange_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dlange_", norm, m, n, A, lda, work, x6);
            }
            return (double)mh$.invokeExact(norm, m, n, A, lda, work, x6);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class slange_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("slange_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * lapack_float_return slange_(const char *norm, const int *m, const int *n, const float *A, const int *lda, float *work, size_t)
     * }
     */
    public static FunctionDescriptor slange_$descriptor() {
        return slange_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * lapack_float_return slange_(const char *norm, const int *m, const int *n, const float *A, const int *lda, float *work, size_t)
     * }
     */
    public static MethodHandle slange_$handle() {
        return slange_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * lapack_float_return slange_(const char *norm, const int *m, const int *n, const float *A, const int *lda, float *work, size_t)
     * }
     */
    public static MemorySegment slange_$address() {
        return slange_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * lapack_float_return slange_(const char *norm, const int *m, const int *n, const float *A, const int *lda, float *work, size_t)
     * }
     */
    public static float slange_(MemorySegment norm, MemorySegment m, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment work, long x6) {
        var mh$ = slange_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("slange_", norm, m, n, A, lda, work, x6);
            }
            return (float)mh$.invokeExact(norm, m, n, A, lda, work, x6);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zlange_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("zlange_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double zlange_(const char *norm, const int *m, const int *n, const _Complex double *A, const int *lda, double *work, size_t)
     * }
     */
    public static FunctionDescriptor zlange_$descriptor() {
        return zlange_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double zlange_(const char *norm, const int *m, const int *n, const _Complex double *A, const int *lda, double *work, size_t)
     * }
     */
    public static MethodHandle zlange_$handle() {
        return zlange_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double zlange_(const char *norm, const int *m, const int *n, const _Complex double *A, const int *lda, double *work, size_t)
     * }
     */
    public static MemorySegment zlange_$address() {
        return zlange_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double zlange_(const char *norm, const int *m, const int *n, const _Complex double *A, const int *lda, double *work, size_t)
     * }
     */
    public static double zlange_(MemorySegment norm, MemorySegment m, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment work, long x6) {
        var mh$ = zlange_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zlange_", norm, m, n, A, lda, work, x6);
            }
            return (double)mh$.invokeExact(norm, m, n, A, lda, work, x6);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clangt_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("clangt_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * lapack_float_return clangt_(const char *norm, const int *n, const _Complex float *DL, const _Complex float *D, const _Complex float *DU, size_t)
     * }
     */
    public static FunctionDescriptor clangt_$descriptor() {
        return clangt_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * lapack_float_return clangt_(const char *norm, const int *n, const _Complex float *DL, const _Complex float *D, const _Complex float *DU, size_t)
     * }
     */
    public static MethodHandle clangt_$handle() {
        return clangt_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * lapack_float_return clangt_(const char *norm, const int *n, const _Complex float *DL, const _Complex float *D, const _Complex float *DU, size_t)
     * }
     */
    public static MemorySegment clangt_$address() {
        return clangt_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * lapack_float_return clangt_(const char *norm, const int *n, const _Complex float *DL, const _Complex float *D, const _Complex float *DU, size_t)
     * }
     */
    public static float clangt_(MemorySegment norm, MemorySegment n, MemorySegment DL, MemorySegment D, MemorySegment DU, long x5) {
        var mh$ = clangt_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clangt_", norm, n, DL, D, DU, x5);
            }
            return (float)mh$.invokeExact(norm, n, DL, D, DU, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dlangt_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("dlangt_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double dlangt_(const char *norm, const int *n, const double *DL, const double *D, const double *DU, size_t)
     * }
     */
    public static FunctionDescriptor dlangt_$descriptor() {
        return dlangt_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double dlangt_(const char *norm, const int *n, const double *DL, const double *D, const double *DU, size_t)
     * }
     */
    public static MethodHandle dlangt_$handle() {
        return dlangt_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double dlangt_(const char *norm, const int *n, const double *DL, const double *D, const double *DU, size_t)
     * }
     */
    public static MemorySegment dlangt_$address() {
        return dlangt_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double dlangt_(const char *norm, const int *n, const double *DL, const double *D, const double *DU, size_t)
     * }
     */
    public static double dlangt_(MemorySegment norm, MemorySegment n, MemorySegment DL, MemorySegment D, MemorySegment DU, long x5) {
        var mh$ = dlangt_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dlangt_", norm, n, DL, D, DU, x5);
            }
            return (double)mh$.invokeExact(norm, n, DL, D, DU, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class slangt_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("slangt_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * lapack_float_return slangt_(const char *norm, const int *n, const float *DL, const float *D, const float *DU, size_t)
     * }
     */
    public static FunctionDescriptor slangt_$descriptor() {
        return slangt_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * lapack_float_return slangt_(const char *norm, const int *n, const float *DL, const float *D, const float *DU, size_t)
     * }
     */
    public static MethodHandle slangt_$handle() {
        return slangt_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * lapack_float_return slangt_(const char *norm, const int *n, const float *DL, const float *D, const float *DU, size_t)
     * }
     */
    public static MemorySegment slangt_$address() {
        return slangt_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * lapack_float_return slangt_(const char *norm, const int *n, const float *DL, const float *D, const float *DU, size_t)
     * }
     */
    public static float slangt_(MemorySegment norm, MemorySegment n, MemorySegment DL, MemorySegment D, MemorySegment DU, long x5) {
        var mh$ = slangt_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("slangt_", norm, n, DL, D, DU, x5);
            }
            return (float)mh$.invokeExact(norm, n, DL, D, DU, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zlangt_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("zlangt_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double zlangt_(const char *norm, const int *n, const _Complex double *DL, const _Complex double *D, const _Complex double *DU, size_t)
     * }
     */
    public static FunctionDescriptor zlangt_$descriptor() {
        return zlangt_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double zlangt_(const char *norm, const int *n, const _Complex double *DL, const _Complex double *D, const _Complex double *DU, size_t)
     * }
     */
    public static MethodHandle zlangt_$handle() {
        return zlangt_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double zlangt_(const char *norm, const int *n, const _Complex double *DL, const _Complex double *D, const _Complex double *DU, size_t)
     * }
     */
    public static MemorySegment zlangt_$address() {
        return zlangt_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double zlangt_(const char *norm, const int *n, const _Complex double *DL, const _Complex double *D, const _Complex double *DU, size_t)
     * }
     */
    public static double zlangt_(MemorySegment norm, MemorySegment n, MemorySegment DL, MemorySegment D, MemorySegment DU, long x5) {
        var mh$ = zlangt_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zlangt_", norm, n, DL, D, DU, x5);
            }
            return (double)mh$.invokeExact(norm, n, DL, D, DU, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clanhb_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("clanhb_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * lapack_float_return clanhb_(const char *norm, const char *uplo, const int *n, const int *k, const _Complex float *AB, const int *ldab, float *work, size_t, size_t)
     * }
     */
    public static FunctionDescriptor clanhb_$descriptor() {
        return clanhb_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * lapack_float_return clanhb_(const char *norm, const char *uplo, const int *n, const int *k, const _Complex float *AB, const int *ldab, float *work, size_t, size_t)
     * }
     */
    public static MethodHandle clanhb_$handle() {
        return clanhb_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * lapack_float_return clanhb_(const char *norm, const char *uplo, const int *n, const int *k, const _Complex float *AB, const int *ldab, float *work, size_t, size_t)
     * }
     */
    public static MemorySegment clanhb_$address() {
        return clanhb_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * lapack_float_return clanhb_(const char *norm, const char *uplo, const int *n, const int *k, const _Complex float *AB, const int *ldab, float *work, size_t, size_t)
     * }
     */
    public static float clanhb_(MemorySegment norm, MemorySegment uplo, MemorySegment n, MemorySegment k, MemorySegment AB, MemorySegment ldab, MemorySegment work, long x7, long x8) {
        var mh$ = clanhb_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clanhb_", norm, uplo, n, k, AB, ldab, work, x7, x8);
            }
            return (float)mh$.invokeExact(norm, uplo, n, k, AB, ldab, work, x7, x8);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zlanhb_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("zlanhb_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double zlanhb_(const char *norm, const char *uplo, const int *n, const int *k, const _Complex double *AB, const int *ldab, double *work, size_t, size_t)
     * }
     */
    public static FunctionDescriptor zlanhb_$descriptor() {
        return zlanhb_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double zlanhb_(const char *norm, const char *uplo, const int *n, const int *k, const _Complex double *AB, const int *ldab, double *work, size_t, size_t)
     * }
     */
    public static MethodHandle zlanhb_$handle() {
        return zlanhb_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double zlanhb_(const char *norm, const char *uplo, const int *n, const int *k, const _Complex double *AB, const int *ldab, double *work, size_t, size_t)
     * }
     */
    public static MemorySegment zlanhb_$address() {
        return zlanhb_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double zlanhb_(const char *norm, const char *uplo, const int *n, const int *k, const _Complex double *AB, const int *ldab, double *work, size_t, size_t)
     * }
     */
    public static double zlanhb_(MemorySegment norm, MemorySegment uplo, MemorySegment n, MemorySegment k, MemorySegment AB, MemorySegment ldab, MemorySegment work, long x7, long x8) {
        var mh$ = zlanhb_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zlanhb_", norm, uplo, n, k, AB, ldab, work, x7, x8);
            }
            return (double)mh$.invokeExact(norm, uplo, n, k, AB, ldab, work, x7, x8);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clanhe_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("clanhe_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * lapack_float_return clanhe_(const char *norm, const char *uplo, const int *n, const _Complex float *A, const int *lda, float *work, size_t, size_t)
     * }
     */
    public static FunctionDescriptor clanhe_$descriptor() {
        return clanhe_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * lapack_float_return clanhe_(const char *norm, const char *uplo, const int *n, const _Complex float *A, const int *lda, float *work, size_t, size_t)
     * }
     */
    public static MethodHandle clanhe_$handle() {
        return clanhe_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * lapack_float_return clanhe_(const char *norm, const char *uplo, const int *n, const _Complex float *A, const int *lda, float *work, size_t, size_t)
     * }
     */
    public static MemorySegment clanhe_$address() {
        return clanhe_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * lapack_float_return clanhe_(const char *norm, const char *uplo, const int *n, const _Complex float *A, const int *lda, float *work, size_t, size_t)
     * }
     */
    public static float clanhe_(MemorySegment norm, MemorySegment uplo, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment work, long x6, long x7) {
        var mh$ = clanhe_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clanhe_", norm, uplo, n, A, lda, work, x6, x7);
            }
            return (float)mh$.invokeExact(norm, uplo, n, A, lda, work, x6, x7);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zlanhe_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("zlanhe_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double zlanhe_(const char *norm, const char *uplo, const int *n, const _Complex double *A, const int *lda, double *work, size_t, size_t)
     * }
     */
    public static FunctionDescriptor zlanhe_$descriptor() {
        return zlanhe_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double zlanhe_(const char *norm, const char *uplo, const int *n, const _Complex double *A, const int *lda, double *work, size_t, size_t)
     * }
     */
    public static MethodHandle zlanhe_$handle() {
        return zlanhe_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double zlanhe_(const char *norm, const char *uplo, const int *n, const _Complex double *A, const int *lda, double *work, size_t, size_t)
     * }
     */
    public static MemorySegment zlanhe_$address() {
        return zlanhe_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double zlanhe_(const char *norm, const char *uplo, const int *n, const _Complex double *A, const int *lda, double *work, size_t, size_t)
     * }
     */
    public static double zlanhe_(MemorySegment norm, MemorySegment uplo, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment work, long x6, long x7) {
        var mh$ = zlanhe_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zlanhe_", norm, uplo, n, A, lda, work, x6, x7);
            }
            return (double)mh$.invokeExact(norm, uplo, n, A, lda, work, x6, x7);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clanhp_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("clanhp_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * lapack_float_return clanhp_(const char *norm, const char *uplo, const int *n, const _Complex float *AP, float *work, size_t, size_t)
     * }
     */
    public static FunctionDescriptor clanhp_$descriptor() {
        return clanhp_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * lapack_float_return clanhp_(const char *norm, const char *uplo, const int *n, const _Complex float *AP, float *work, size_t, size_t)
     * }
     */
    public static MethodHandle clanhp_$handle() {
        return clanhp_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * lapack_float_return clanhp_(const char *norm, const char *uplo, const int *n, const _Complex float *AP, float *work, size_t, size_t)
     * }
     */
    public static MemorySegment clanhp_$address() {
        return clanhp_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * lapack_float_return clanhp_(const char *norm, const char *uplo, const int *n, const _Complex float *AP, float *work, size_t, size_t)
     * }
     */
    public static float clanhp_(MemorySegment norm, MemorySegment uplo, MemorySegment n, MemorySegment AP, MemorySegment work, long x5, long x6) {
        var mh$ = clanhp_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clanhp_", norm, uplo, n, AP, work, x5, x6);
            }
            return (float)mh$.invokeExact(norm, uplo, n, AP, work, x5, x6);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zlanhp_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("zlanhp_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double zlanhp_(const char *norm, const char *uplo, const int *n, const _Complex double *AP, double *work, size_t, size_t)
     * }
     */
    public static FunctionDescriptor zlanhp_$descriptor() {
        return zlanhp_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double zlanhp_(const char *norm, const char *uplo, const int *n, const _Complex double *AP, double *work, size_t, size_t)
     * }
     */
    public static MethodHandle zlanhp_$handle() {
        return zlanhp_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double zlanhp_(const char *norm, const char *uplo, const int *n, const _Complex double *AP, double *work, size_t, size_t)
     * }
     */
    public static MemorySegment zlanhp_$address() {
        return zlanhp_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double zlanhp_(const char *norm, const char *uplo, const int *n, const _Complex double *AP, double *work, size_t, size_t)
     * }
     */
    public static double zlanhp_(MemorySegment norm, MemorySegment uplo, MemorySegment n, MemorySegment AP, MemorySegment work, long x5, long x6) {
        var mh$ = zlanhp_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zlanhp_", norm, uplo, n, AP, work, x5, x6);
            }
            return (double)mh$.invokeExact(norm, uplo, n, AP, work, x5, x6);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clanhs_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("clanhs_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * lapack_float_return clanhs_(const char *norm, const int *n, const _Complex float *A, const int *lda, float *work, size_t)
     * }
     */
    public static FunctionDescriptor clanhs_$descriptor() {
        return clanhs_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * lapack_float_return clanhs_(const char *norm, const int *n, const _Complex float *A, const int *lda, float *work, size_t)
     * }
     */
    public static MethodHandle clanhs_$handle() {
        return clanhs_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * lapack_float_return clanhs_(const char *norm, const int *n, const _Complex float *A, const int *lda, float *work, size_t)
     * }
     */
    public static MemorySegment clanhs_$address() {
        return clanhs_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * lapack_float_return clanhs_(const char *norm, const int *n, const _Complex float *A, const int *lda, float *work, size_t)
     * }
     */
    public static float clanhs_(MemorySegment norm, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment work, long x5) {
        var mh$ = clanhs_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clanhs_", norm, n, A, lda, work, x5);
            }
            return (float)mh$.invokeExact(norm, n, A, lda, work, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dlanhs_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("dlanhs_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double dlanhs_(const char *norm, const int *n, const double *A, const int *lda, double *work, size_t)
     * }
     */
    public static FunctionDescriptor dlanhs_$descriptor() {
        return dlanhs_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double dlanhs_(const char *norm, const int *n, const double *A, const int *lda, double *work, size_t)
     * }
     */
    public static MethodHandle dlanhs_$handle() {
        return dlanhs_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double dlanhs_(const char *norm, const int *n, const double *A, const int *lda, double *work, size_t)
     * }
     */
    public static MemorySegment dlanhs_$address() {
        return dlanhs_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double dlanhs_(const char *norm, const int *n, const double *A, const int *lda, double *work, size_t)
     * }
     */
    public static double dlanhs_(MemorySegment norm, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment work, long x5) {
        var mh$ = dlanhs_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dlanhs_", norm, n, A, lda, work, x5);
            }
            return (double)mh$.invokeExact(norm, n, A, lda, work, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class slanhs_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("slanhs_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * lapack_float_return slanhs_(const char *norm, const int *n, const float *A, const int *lda, float *work, size_t)
     * }
     */
    public static FunctionDescriptor slanhs_$descriptor() {
        return slanhs_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * lapack_float_return slanhs_(const char *norm, const int *n, const float *A, const int *lda, float *work, size_t)
     * }
     */
    public static MethodHandle slanhs_$handle() {
        return slanhs_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * lapack_float_return slanhs_(const char *norm, const int *n, const float *A, const int *lda, float *work, size_t)
     * }
     */
    public static MemorySegment slanhs_$address() {
        return slanhs_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * lapack_float_return slanhs_(const char *norm, const int *n, const float *A, const int *lda, float *work, size_t)
     * }
     */
    public static float slanhs_(MemorySegment norm, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment work, long x5) {
        var mh$ = slanhs_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("slanhs_", norm, n, A, lda, work, x5);
            }
            return (float)mh$.invokeExact(norm, n, A, lda, work, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zlanhs_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("zlanhs_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double zlanhs_(const char *norm, const int *n, const _Complex double *A, const int *lda, double *work, size_t)
     * }
     */
    public static FunctionDescriptor zlanhs_$descriptor() {
        return zlanhs_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double zlanhs_(const char *norm, const int *n, const _Complex double *A, const int *lda, double *work, size_t)
     * }
     */
    public static MethodHandle zlanhs_$handle() {
        return zlanhs_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double zlanhs_(const char *norm, const int *n, const _Complex double *A, const int *lda, double *work, size_t)
     * }
     */
    public static MemorySegment zlanhs_$address() {
        return zlanhs_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double zlanhs_(const char *norm, const int *n, const _Complex double *A, const int *lda, double *work, size_t)
     * }
     */
    public static double zlanhs_(MemorySegment norm, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment work, long x5) {
        var mh$ = zlanhs_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zlanhs_", norm, n, A, lda, work, x5);
            }
            return (double)mh$.invokeExact(norm, n, A, lda, work, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clanht_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("clanht_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * lapack_float_return clanht_(const char *norm, const int *n, const float *D, const _Complex float *E, size_t)
     * }
     */
    public static FunctionDescriptor clanht_$descriptor() {
        return clanht_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * lapack_float_return clanht_(const char *norm, const int *n, const float *D, const _Complex float *E, size_t)
     * }
     */
    public static MethodHandle clanht_$handle() {
        return clanht_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * lapack_float_return clanht_(const char *norm, const int *n, const float *D, const _Complex float *E, size_t)
     * }
     */
    public static MemorySegment clanht_$address() {
        return clanht_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * lapack_float_return clanht_(const char *norm, const int *n, const float *D, const _Complex float *E, size_t)
     * }
     */
    public static float clanht_(MemorySegment norm, MemorySegment n, MemorySegment D, MemorySegment E, long x4) {
        var mh$ = clanht_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clanht_", norm, n, D, E, x4);
            }
            return (float)mh$.invokeExact(norm, n, D, E, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zlanht_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("zlanht_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double zlanht_(const char *norm, const int *n, const double *D, const _Complex double *E, size_t)
     * }
     */
    public static FunctionDescriptor zlanht_$descriptor() {
        return zlanht_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double zlanht_(const char *norm, const int *n, const double *D, const _Complex double *E, size_t)
     * }
     */
    public static MethodHandle zlanht_$handle() {
        return zlanht_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double zlanht_(const char *norm, const int *n, const double *D, const _Complex double *E, size_t)
     * }
     */
    public static MemorySegment zlanht_$address() {
        return zlanht_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double zlanht_(const char *norm, const int *n, const double *D, const _Complex double *E, size_t)
     * }
     */
    public static double zlanht_(MemorySegment norm, MemorySegment n, MemorySegment D, MemorySegment E, long x4) {
        var mh$ = zlanht_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zlanht_", norm, n, D, E, x4);
            }
            return (double)mh$.invokeExact(norm, n, D, E, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clansb_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("clansb_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * lapack_float_return clansb_(const char *norm, const char *uplo, const int *n, const int *k, const _Complex float *AB, const int *ldab, float *work, size_t, size_t)
     * }
     */
    public static FunctionDescriptor clansb_$descriptor() {
        return clansb_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * lapack_float_return clansb_(const char *norm, const char *uplo, const int *n, const int *k, const _Complex float *AB, const int *ldab, float *work, size_t, size_t)
     * }
     */
    public static MethodHandle clansb_$handle() {
        return clansb_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * lapack_float_return clansb_(const char *norm, const char *uplo, const int *n, const int *k, const _Complex float *AB, const int *ldab, float *work, size_t, size_t)
     * }
     */
    public static MemorySegment clansb_$address() {
        return clansb_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * lapack_float_return clansb_(const char *norm, const char *uplo, const int *n, const int *k, const _Complex float *AB, const int *ldab, float *work, size_t, size_t)
     * }
     */
    public static float clansb_(MemorySegment norm, MemorySegment uplo, MemorySegment n, MemorySegment k, MemorySegment AB, MemorySegment ldab, MemorySegment work, long x7, long x8) {
        var mh$ = clansb_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clansb_", norm, uplo, n, k, AB, ldab, work, x7, x8);
            }
            return (float)mh$.invokeExact(norm, uplo, n, k, AB, ldab, work, x7, x8);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dlansb_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("dlansb_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double dlansb_(const char *norm, const char *uplo, const int *n, const int *k, const double *AB, const int *ldab, double *work, size_t, size_t)
     * }
     */
    public static FunctionDescriptor dlansb_$descriptor() {
        return dlansb_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double dlansb_(const char *norm, const char *uplo, const int *n, const int *k, const double *AB, const int *ldab, double *work, size_t, size_t)
     * }
     */
    public static MethodHandle dlansb_$handle() {
        return dlansb_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double dlansb_(const char *norm, const char *uplo, const int *n, const int *k, const double *AB, const int *ldab, double *work, size_t, size_t)
     * }
     */
    public static MemorySegment dlansb_$address() {
        return dlansb_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double dlansb_(const char *norm, const char *uplo, const int *n, const int *k, const double *AB, const int *ldab, double *work, size_t, size_t)
     * }
     */
    public static double dlansb_(MemorySegment norm, MemorySegment uplo, MemorySegment n, MemorySegment k, MemorySegment AB, MemorySegment ldab, MemorySegment work, long x7, long x8) {
        var mh$ = dlansb_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dlansb_", norm, uplo, n, k, AB, ldab, work, x7, x8);
            }
            return (double)mh$.invokeExact(norm, uplo, n, k, AB, ldab, work, x7, x8);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class slansb_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("slansb_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * lapack_float_return slansb_(const char *norm, const char *uplo, const int *n, const int *k, const float *AB, const int *ldab, float *work, size_t, size_t)
     * }
     */
    public static FunctionDescriptor slansb_$descriptor() {
        return slansb_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * lapack_float_return slansb_(const char *norm, const char *uplo, const int *n, const int *k, const float *AB, const int *ldab, float *work, size_t, size_t)
     * }
     */
    public static MethodHandle slansb_$handle() {
        return slansb_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * lapack_float_return slansb_(const char *norm, const char *uplo, const int *n, const int *k, const float *AB, const int *ldab, float *work, size_t, size_t)
     * }
     */
    public static MemorySegment slansb_$address() {
        return slansb_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * lapack_float_return slansb_(const char *norm, const char *uplo, const int *n, const int *k, const float *AB, const int *ldab, float *work, size_t, size_t)
     * }
     */
    public static float slansb_(MemorySegment norm, MemorySegment uplo, MemorySegment n, MemorySegment k, MemorySegment AB, MemorySegment ldab, MemorySegment work, long x7, long x8) {
        var mh$ = slansb_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("slansb_", norm, uplo, n, k, AB, ldab, work, x7, x8);
            }
            return (float)mh$.invokeExact(norm, uplo, n, k, AB, ldab, work, x7, x8);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zlansb_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("zlansb_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double zlansb_(const char *norm, const char *uplo, const int *n, const int *k, const _Complex double *AB, const int *ldab, double *work, size_t, size_t)
     * }
     */
    public static FunctionDescriptor zlansb_$descriptor() {
        return zlansb_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double zlansb_(const char *norm, const char *uplo, const int *n, const int *k, const _Complex double *AB, const int *ldab, double *work, size_t, size_t)
     * }
     */
    public static MethodHandle zlansb_$handle() {
        return zlansb_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double zlansb_(const char *norm, const char *uplo, const int *n, const int *k, const _Complex double *AB, const int *ldab, double *work, size_t, size_t)
     * }
     */
    public static MemorySegment zlansb_$address() {
        return zlansb_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double zlansb_(const char *norm, const char *uplo, const int *n, const int *k, const _Complex double *AB, const int *ldab, double *work, size_t, size_t)
     * }
     */
    public static double zlansb_(MemorySegment norm, MemorySegment uplo, MemorySegment n, MemorySegment k, MemorySegment AB, MemorySegment ldab, MemorySegment work, long x7, long x8) {
        var mh$ = zlansb_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zlansb_", norm, uplo, n, k, AB, ldab, work, x7, x8);
            }
            return (double)mh$.invokeExact(norm, uplo, n, k, AB, ldab, work, x7, x8);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clansp_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("clansp_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * lapack_float_return clansp_(const char *norm, const char *uplo, const int *n, const _Complex float *AP, float *work, size_t, size_t)
     * }
     */
    public static FunctionDescriptor clansp_$descriptor() {
        return clansp_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * lapack_float_return clansp_(const char *norm, const char *uplo, const int *n, const _Complex float *AP, float *work, size_t, size_t)
     * }
     */
    public static MethodHandle clansp_$handle() {
        return clansp_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * lapack_float_return clansp_(const char *norm, const char *uplo, const int *n, const _Complex float *AP, float *work, size_t, size_t)
     * }
     */
    public static MemorySegment clansp_$address() {
        return clansp_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * lapack_float_return clansp_(const char *norm, const char *uplo, const int *n, const _Complex float *AP, float *work, size_t, size_t)
     * }
     */
    public static float clansp_(MemorySegment norm, MemorySegment uplo, MemorySegment n, MemorySegment AP, MemorySegment work, long x5, long x6) {
        var mh$ = clansp_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clansp_", norm, uplo, n, AP, work, x5, x6);
            }
            return (float)mh$.invokeExact(norm, uplo, n, AP, work, x5, x6);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dlansp_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("dlansp_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double dlansp_(const char *norm, const char *uplo, const int *n, const double *AP, double *work, size_t, size_t)
     * }
     */
    public static FunctionDescriptor dlansp_$descriptor() {
        return dlansp_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double dlansp_(const char *norm, const char *uplo, const int *n, const double *AP, double *work, size_t, size_t)
     * }
     */
    public static MethodHandle dlansp_$handle() {
        return dlansp_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double dlansp_(const char *norm, const char *uplo, const int *n, const double *AP, double *work, size_t, size_t)
     * }
     */
    public static MemorySegment dlansp_$address() {
        return dlansp_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double dlansp_(const char *norm, const char *uplo, const int *n, const double *AP, double *work, size_t, size_t)
     * }
     */
    public static double dlansp_(MemorySegment norm, MemorySegment uplo, MemorySegment n, MemorySegment AP, MemorySegment work, long x5, long x6) {
        var mh$ = dlansp_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dlansp_", norm, uplo, n, AP, work, x5, x6);
            }
            return (double)mh$.invokeExact(norm, uplo, n, AP, work, x5, x6);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class slansp_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("slansp_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * lapack_float_return slansp_(const char *norm, const char *uplo, const int *n, const float *AP, float *work, size_t, size_t)
     * }
     */
    public static FunctionDescriptor slansp_$descriptor() {
        return slansp_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * lapack_float_return slansp_(const char *norm, const char *uplo, const int *n, const float *AP, float *work, size_t, size_t)
     * }
     */
    public static MethodHandle slansp_$handle() {
        return slansp_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * lapack_float_return slansp_(const char *norm, const char *uplo, const int *n, const float *AP, float *work, size_t, size_t)
     * }
     */
    public static MemorySegment slansp_$address() {
        return slansp_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * lapack_float_return slansp_(const char *norm, const char *uplo, const int *n, const float *AP, float *work, size_t, size_t)
     * }
     */
    public static float slansp_(MemorySegment norm, MemorySegment uplo, MemorySegment n, MemorySegment AP, MemorySegment work, long x5, long x6) {
        var mh$ = slansp_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("slansp_", norm, uplo, n, AP, work, x5, x6);
            }
            return (float)mh$.invokeExact(norm, uplo, n, AP, work, x5, x6);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zlansp_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("zlansp_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double zlansp_(const char *norm, const char *uplo, const int *n, const _Complex double *AP, double *work, size_t, size_t)
     * }
     */
    public static FunctionDescriptor zlansp_$descriptor() {
        return zlansp_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double zlansp_(const char *norm, const char *uplo, const int *n, const _Complex double *AP, double *work, size_t, size_t)
     * }
     */
    public static MethodHandle zlansp_$handle() {
        return zlansp_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double zlansp_(const char *norm, const char *uplo, const int *n, const _Complex double *AP, double *work, size_t, size_t)
     * }
     */
    public static MemorySegment zlansp_$address() {
        return zlansp_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double zlansp_(const char *norm, const char *uplo, const int *n, const _Complex double *AP, double *work, size_t, size_t)
     * }
     */
    public static double zlansp_(MemorySegment norm, MemorySegment uplo, MemorySegment n, MemorySegment AP, MemorySegment work, long x5, long x6) {
        var mh$ = zlansp_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zlansp_", norm, uplo, n, AP, work, x5, x6);
            }
            return (double)mh$.invokeExact(norm, uplo, n, AP, work, x5, x6);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dlanst_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("dlanst_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double dlanst_(const char *norm, const int *n, const double *D, const double *E, size_t)
     * }
     */
    public static FunctionDescriptor dlanst_$descriptor() {
        return dlanst_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double dlanst_(const char *norm, const int *n, const double *D, const double *E, size_t)
     * }
     */
    public static MethodHandle dlanst_$handle() {
        return dlanst_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double dlanst_(const char *norm, const int *n, const double *D, const double *E, size_t)
     * }
     */
    public static MemorySegment dlanst_$address() {
        return dlanst_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double dlanst_(const char *norm, const int *n, const double *D, const double *E, size_t)
     * }
     */
    public static double dlanst_(MemorySegment norm, MemorySegment n, MemorySegment D, MemorySegment E, long x4) {
        var mh$ = dlanst_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dlanst_", norm, n, D, E, x4);
            }
            return (double)mh$.invokeExact(norm, n, D, E, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class slanst_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("slanst_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * lapack_float_return slanst_(const char *norm, const int *n, const float *D, const float *E, size_t)
     * }
     */
    public static FunctionDescriptor slanst_$descriptor() {
        return slanst_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * lapack_float_return slanst_(const char *norm, const int *n, const float *D, const float *E, size_t)
     * }
     */
    public static MethodHandle slanst_$handle() {
        return slanst_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * lapack_float_return slanst_(const char *norm, const int *n, const float *D, const float *E, size_t)
     * }
     */
    public static MemorySegment slanst_$address() {
        return slanst_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * lapack_float_return slanst_(const char *norm, const int *n, const float *D, const float *E, size_t)
     * }
     */
    public static float slanst_(MemorySegment norm, MemorySegment n, MemorySegment D, MemorySegment E, long x4) {
        var mh$ = slanst_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("slanst_", norm, n, D, E, x4);
            }
            return (float)mh$.invokeExact(norm, n, D, E, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clansy_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("clansy_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * lapack_float_return clansy_(const char *norm, const char *uplo, const int *n, const _Complex float *A, const int *lda, float *work, size_t, size_t)
     * }
     */
    public static FunctionDescriptor clansy_$descriptor() {
        return clansy_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * lapack_float_return clansy_(const char *norm, const char *uplo, const int *n, const _Complex float *A, const int *lda, float *work, size_t, size_t)
     * }
     */
    public static MethodHandle clansy_$handle() {
        return clansy_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * lapack_float_return clansy_(const char *norm, const char *uplo, const int *n, const _Complex float *A, const int *lda, float *work, size_t, size_t)
     * }
     */
    public static MemorySegment clansy_$address() {
        return clansy_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * lapack_float_return clansy_(const char *norm, const char *uplo, const int *n, const _Complex float *A, const int *lda, float *work, size_t, size_t)
     * }
     */
    public static float clansy_(MemorySegment norm, MemorySegment uplo, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment work, long x6, long x7) {
        var mh$ = clansy_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clansy_", norm, uplo, n, A, lda, work, x6, x7);
            }
            return (float)mh$.invokeExact(norm, uplo, n, A, lda, work, x6, x7);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dlansy_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("dlansy_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double dlansy_(const char *norm, const char *uplo, const int *n, const double *A, const int *lda, double *work, size_t, size_t)
     * }
     */
    public static FunctionDescriptor dlansy_$descriptor() {
        return dlansy_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double dlansy_(const char *norm, const char *uplo, const int *n, const double *A, const int *lda, double *work, size_t, size_t)
     * }
     */
    public static MethodHandle dlansy_$handle() {
        return dlansy_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double dlansy_(const char *norm, const char *uplo, const int *n, const double *A, const int *lda, double *work, size_t, size_t)
     * }
     */
    public static MemorySegment dlansy_$address() {
        return dlansy_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double dlansy_(const char *norm, const char *uplo, const int *n, const double *A, const int *lda, double *work, size_t, size_t)
     * }
     */
    public static double dlansy_(MemorySegment norm, MemorySegment uplo, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment work, long x6, long x7) {
        var mh$ = dlansy_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dlansy_", norm, uplo, n, A, lda, work, x6, x7);
            }
            return (double)mh$.invokeExact(norm, uplo, n, A, lda, work, x6, x7);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class slansy_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("slansy_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * lapack_float_return slansy_(const char *norm, const char *uplo, const int *n, const float *A, const int *lda, float *work, size_t, size_t)
     * }
     */
    public static FunctionDescriptor slansy_$descriptor() {
        return slansy_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * lapack_float_return slansy_(const char *norm, const char *uplo, const int *n, const float *A, const int *lda, float *work, size_t, size_t)
     * }
     */
    public static MethodHandle slansy_$handle() {
        return slansy_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * lapack_float_return slansy_(const char *norm, const char *uplo, const int *n, const float *A, const int *lda, float *work, size_t, size_t)
     * }
     */
    public static MemorySegment slansy_$address() {
        return slansy_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * lapack_float_return slansy_(const char *norm, const char *uplo, const int *n, const float *A, const int *lda, float *work, size_t, size_t)
     * }
     */
    public static float slansy_(MemorySegment norm, MemorySegment uplo, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment work, long x6, long x7) {
        var mh$ = slansy_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("slansy_", norm, uplo, n, A, lda, work, x6, x7);
            }
            return (float)mh$.invokeExact(norm, uplo, n, A, lda, work, x6, x7);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zlansy_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("zlansy_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double zlansy_(const char *norm, const char *uplo, const int *n, const _Complex double *A, const int *lda, double *work, size_t, size_t)
     * }
     */
    public static FunctionDescriptor zlansy_$descriptor() {
        return zlansy_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double zlansy_(const char *norm, const char *uplo, const int *n, const _Complex double *A, const int *lda, double *work, size_t, size_t)
     * }
     */
    public static MethodHandle zlansy_$handle() {
        return zlansy_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double zlansy_(const char *norm, const char *uplo, const int *n, const _Complex double *A, const int *lda, double *work, size_t, size_t)
     * }
     */
    public static MemorySegment zlansy_$address() {
        return zlansy_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double zlansy_(const char *norm, const char *uplo, const int *n, const _Complex double *A, const int *lda, double *work, size_t, size_t)
     * }
     */
    public static double zlansy_(MemorySegment norm, MemorySegment uplo, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment work, long x6, long x7) {
        var mh$ = zlansy_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zlansy_", norm, uplo, n, A, lda, work, x6, x7);
            }
            return (double)mh$.invokeExact(norm, uplo, n, A, lda, work, x6, x7);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clantb_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("clantb_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * lapack_float_return clantb_(const char *norm, const char *uplo, const char *diag, const int *n, const int *k, const _Complex float *AB, const int *ldab, float *work, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor clantb_$descriptor() {
        return clantb_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * lapack_float_return clantb_(const char *norm, const char *uplo, const char *diag, const int *n, const int *k, const _Complex float *AB, const int *ldab, float *work, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle clantb_$handle() {
        return clantb_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * lapack_float_return clantb_(const char *norm, const char *uplo, const char *diag, const int *n, const int *k, const _Complex float *AB, const int *ldab, float *work, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment clantb_$address() {
        return clantb_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * lapack_float_return clantb_(const char *norm, const char *uplo, const char *diag, const int *n, const int *k, const _Complex float *AB, const int *ldab, float *work, size_t, size_t, size_t)
     * }
     */
    public static float clantb_(MemorySegment norm, MemorySegment uplo, MemorySegment diag, MemorySegment n, MemorySegment k, MemorySegment AB, MemorySegment ldab, MemorySegment work, long x8, long x9, long x10) {
        var mh$ = clantb_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clantb_", norm, uplo, diag, n, k, AB, ldab, work, x8, x9, x10);
            }
            return (float)mh$.invokeExact(norm, uplo, diag, n, k, AB, ldab, work, x8, x9, x10);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dlantb_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("dlantb_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double dlantb_(const char *norm, const char *uplo, const char *diag, const int *n, const int *k, const double *AB, const int *ldab, double *work, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor dlantb_$descriptor() {
        return dlantb_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double dlantb_(const char *norm, const char *uplo, const char *diag, const int *n, const int *k, const double *AB, const int *ldab, double *work, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle dlantb_$handle() {
        return dlantb_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double dlantb_(const char *norm, const char *uplo, const char *diag, const int *n, const int *k, const double *AB, const int *ldab, double *work, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment dlantb_$address() {
        return dlantb_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double dlantb_(const char *norm, const char *uplo, const char *diag, const int *n, const int *k, const double *AB, const int *ldab, double *work, size_t, size_t, size_t)
     * }
     */
    public static double dlantb_(MemorySegment norm, MemorySegment uplo, MemorySegment diag, MemorySegment n, MemorySegment k, MemorySegment AB, MemorySegment ldab, MemorySegment work, long x8, long x9, long x10) {
        var mh$ = dlantb_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dlantb_", norm, uplo, diag, n, k, AB, ldab, work, x8, x9, x10);
            }
            return (double)mh$.invokeExact(norm, uplo, diag, n, k, AB, ldab, work, x8, x9, x10);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class slantb_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("slantb_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * lapack_float_return slantb_(const char *norm, const char *uplo, const char *diag, const int *n, const int *k, const float *AB, const int *ldab, float *work, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor slantb_$descriptor() {
        return slantb_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * lapack_float_return slantb_(const char *norm, const char *uplo, const char *diag, const int *n, const int *k, const float *AB, const int *ldab, float *work, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle slantb_$handle() {
        return slantb_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * lapack_float_return slantb_(const char *norm, const char *uplo, const char *diag, const int *n, const int *k, const float *AB, const int *ldab, float *work, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment slantb_$address() {
        return slantb_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * lapack_float_return slantb_(const char *norm, const char *uplo, const char *diag, const int *n, const int *k, const float *AB, const int *ldab, float *work, size_t, size_t, size_t)
     * }
     */
    public static float slantb_(MemorySegment norm, MemorySegment uplo, MemorySegment diag, MemorySegment n, MemorySegment k, MemorySegment AB, MemorySegment ldab, MemorySegment work, long x8, long x9, long x10) {
        var mh$ = slantb_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("slantb_", norm, uplo, diag, n, k, AB, ldab, work, x8, x9, x10);
            }
            return (float)mh$.invokeExact(norm, uplo, diag, n, k, AB, ldab, work, x8, x9, x10);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zlantb_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("zlantb_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double zlantb_(const char *norm, const char *uplo, const char *diag, const int *n, const int *k, const _Complex double *AB, const int *ldab, double *work, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor zlantb_$descriptor() {
        return zlantb_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double zlantb_(const char *norm, const char *uplo, const char *diag, const int *n, const int *k, const _Complex double *AB, const int *ldab, double *work, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle zlantb_$handle() {
        return zlantb_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double zlantb_(const char *norm, const char *uplo, const char *diag, const int *n, const int *k, const _Complex double *AB, const int *ldab, double *work, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment zlantb_$address() {
        return zlantb_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double zlantb_(const char *norm, const char *uplo, const char *diag, const int *n, const int *k, const _Complex double *AB, const int *ldab, double *work, size_t, size_t, size_t)
     * }
     */
    public static double zlantb_(MemorySegment norm, MemorySegment uplo, MemorySegment diag, MemorySegment n, MemorySegment k, MemorySegment AB, MemorySegment ldab, MemorySegment work, long x8, long x9, long x10) {
        var mh$ = zlantb_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zlantb_", norm, uplo, diag, n, k, AB, ldab, work, x8, x9, x10);
            }
            return (double)mh$.invokeExact(norm, uplo, diag, n, k, AB, ldab, work, x8, x9, x10);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clantp_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("clantp_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * lapack_float_return clantp_(const char *norm, const char *uplo, const char *diag, const int *n, const _Complex float *AP, float *work, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor clantp_$descriptor() {
        return clantp_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * lapack_float_return clantp_(const char *norm, const char *uplo, const char *diag, const int *n, const _Complex float *AP, float *work, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle clantp_$handle() {
        return clantp_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * lapack_float_return clantp_(const char *norm, const char *uplo, const char *diag, const int *n, const _Complex float *AP, float *work, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment clantp_$address() {
        return clantp_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * lapack_float_return clantp_(const char *norm, const char *uplo, const char *diag, const int *n, const _Complex float *AP, float *work, size_t, size_t, size_t)
     * }
     */
    public static float clantp_(MemorySegment norm, MemorySegment uplo, MemorySegment diag, MemorySegment n, MemorySegment AP, MemorySegment work, long x6, long x7, long x8) {
        var mh$ = clantp_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clantp_", norm, uplo, diag, n, AP, work, x6, x7, x8);
            }
            return (float)mh$.invokeExact(norm, uplo, diag, n, AP, work, x6, x7, x8);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dlantp_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("dlantp_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double dlantp_(const char *norm, const char *uplo, const char *diag, const int *n, const double *AP, double *work, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor dlantp_$descriptor() {
        return dlantp_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double dlantp_(const char *norm, const char *uplo, const char *diag, const int *n, const double *AP, double *work, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle dlantp_$handle() {
        return dlantp_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double dlantp_(const char *norm, const char *uplo, const char *diag, const int *n, const double *AP, double *work, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment dlantp_$address() {
        return dlantp_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double dlantp_(const char *norm, const char *uplo, const char *diag, const int *n, const double *AP, double *work, size_t, size_t, size_t)
     * }
     */
    public static double dlantp_(MemorySegment norm, MemorySegment uplo, MemorySegment diag, MemorySegment n, MemorySegment AP, MemorySegment work, long x6, long x7, long x8) {
        var mh$ = dlantp_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dlantp_", norm, uplo, diag, n, AP, work, x6, x7, x8);
            }
            return (double)mh$.invokeExact(norm, uplo, diag, n, AP, work, x6, x7, x8);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class slantp_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("slantp_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * lapack_float_return slantp_(const char *norm, const char *uplo, const char *diag, const int *n, const float *AP, float *work, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor slantp_$descriptor() {
        return slantp_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * lapack_float_return slantp_(const char *norm, const char *uplo, const char *diag, const int *n, const float *AP, float *work, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle slantp_$handle() {
        return slantp_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * lapack_float_return slantp_(const char *norm, const char *uplo, const char *diag, const int *n, const float *AP, float *work, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment slantp_$address() {
        return slantp_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * lapack_float_return slantp_(const char *norm, const char *uplo, const char *diag, const int *n, const float *AP, float *work, size_t, size_t, size_t)
     * }
     */
    public static float slantp_(MemorySegment norm, MemorySegment uplo, MemorySegment diag, MemorySegment n, MemorySegment AP, MemorySegment work, long x6, long x7, long x8) {
        var mh$ = slantp_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("slantp_", norm, uplo, diag, n, AP, work, x6, x7, x8);
            }
            return (float)mh$.invokeExact(norm, uplo, diag, n, AP, work, x6, x7, x8);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zlantp_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("zlantp_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double zlantp_(const char *norm, const char *uplo, const char *diag, const int *n, const _Complex double *AP, double *work, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor zlantp_$descriptor() {
        return zlantp_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double zlantp_(const char *norm, const char *uplo, const char *diag, const int *n, const _Complex double *AP, double *work, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle zlantp_$handle() {
        return zlantp_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double zlantp_(const char *norm, const char *uplo, const char *diag, const int *n, const _Complex double *AP, double *work, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment zlantp_$address() {
        return zlantp_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double zlantp_(const char *norm, const char *uplo, const char *diag, const int *n, const _Complex double *AP, double *work, size_t, size_t, size_t)
     * }
     */
    public static double zlantp_(MemorySegment norm, MemorySegment uplo, MemorySegment diag, MemorySegment n, MemorySegment AP, MemorySegment work, long x6, long x7, long x8) {
        var mh$ = zlantp_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zlantp_", norm, uplo, diag, n, AP, work, x6, x7, x8);
            }
            return (double)mh$.invokeExact(norm, uplo, diag, n, AP, work, x6, x7, x8);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clantr_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("clantr_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * lapack_float_return clantr_(const char *norm, const char *uplo, const char *diag, const int *m, const int *n, const _Complex float *A, const int *lda, float *work, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor clantr_$descriptor() {
        return clantr_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * lapack_float_return clantr_(const char *norm, const char *uplo, const char *diag, const int *m, const int *n, const _Complex float *A, const int *lda, float *work, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle clantr_$handle() {
        return clantr_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * lapack_float_return clantr_(const char *norm, const char *uplo, const char *diag, const int *m, const int *n, const _Complex float *A, const int *lda, float *work, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment clantr_$address() {
        return clantr_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * lapack_float_return clantr_(const char *norm, const char *uplo, const char *diag, const int *m, const int *n, const _Complex float *A, const int *lda, float *work, size_t, size_t, size_t)
     * }
     */
    public static float clantr_(MemorySegment norm, MemorySegment uplo, MemorySegment diag, MemorySegment m, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment work, long x8, long x9, long x10) {
        var mh$ = clantr_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clantr_", norm, uplo, diag, m, n, A, lda, work, x8, x9, x10);
            }
            return (float)mh$.invokeExact(norm, uplo, diag, m, n, A, lda, work, x8, x9, x10);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dlantr_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("dlantr_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double dlantr_(const char *norm, const char *uplo, const char *diag, const int *m, const int *n, const double *A, const int *lda, double *work, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor dlantr_$descriptor() {
        return dlantr_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double dlantr_(const char *norm, const char *uplo, const char *diag, const int *m, const int *n, const double *A, const int *lda, double *work, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle dlantr_$handle() {
        return dlantr_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double dlantr_(const char *norm, const char *uplo, const char *diag, const int *m, const int *n, const double *A, const int *lda, double *work, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment dlantr_$address() {
        return dlantr_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double dlantr_(const char *norm, const char *uplo, const char *diag, const int *m, const int *n, const double *A, const int *lda, double *work, size_t, size_t, size_t)
     * }
     */
    public static double dlantr_(MemorySegment norm, MemorySegment uplo, MemorySegment diag, MemorySegment m, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment work, long x8, long x9, long x10) {
        var mh$ = dlantr_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dlantr_", norm, uplo, diag, m, n, A, lda, work, x8, x9, x10);
            }
            return (double)mh$.invokeExact(norm, uplo, diag, m, n, A, lda, work, x8, x9, x10);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class slantr_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("slantr_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * lapack_float_return slantr_(const char *norm, const char *uplo, const char *diag, const int *m, const int *n, const float *A, const int *lda, float *work, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor slantr_$descriptor() {
        return slantr_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * lapack_float_return slantr_(const char *norm, const char *uplo, const char *diag, const int *m, const int *n, const float *A, const int *lda, float *work, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle slantr_$handle() {
        return slantr_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * lapack_float_return slantr_(const char *norm, const char *uplo, const char *diag, const int *m, const int *n, const float *A, const int *lda, float *work, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment slantr_$address() {
        return slantr_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * lapack_float_return slantr_(const char *norm, const char *uplo, const char *diag, const int *m, const int *n, const float *A, const int *lda, float *work, size_t, size_t, size_t)
     * }
     */
    public static float slantr_(MemorySegment norm, MemorySegment uplo, MemorySegment diag, MemorySegment m, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment work, long x8, long x9, long x10) {
        var mh$ = slantr_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("slantr_", norm, uplo, diag, m, n, A, lda, work, x8, x9, x10);
            }
            return (float)mh$.invokeExact(norm, uplo, diag, m, n, A, lda, work, x8, x9, x10);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zlantr_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("zlantr_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double zlantr_(const char *norm, const char *uplo, const char *diag, const int *m, const int *n, const _Complex double *A, const int *lda, double *work, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor zlantr_$descriptor() {
        return zlantr_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double zlantr_(const char *norm, const char *uplo, const char *diag, const int *m, const int *n, const _Complex double *A, const int *lda, double *work, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle zlantr_$handle() {
        return zlantr_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double zlantr_(const char *norm, const char *uplo, const char *diag, const int *m, const int *n, const _Complex double *A, const int *lda, double *work, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment zlantr_$address() {
        return zlantr_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double zlantr_(const char *norm, const char *uplo, const char *diag, const int *m, const int *n, const _Complex double *A, const int *lda, double *work, size_t, size_t, size_t)
     * }
     */
    public static double zlantr_(MemorySegment norm, MemorySegment uplo, MemorySegment diag, MemorySegment m, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment work, long x8, long x9, long x10) {
        var mh$ = zlantr_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zlantr_", norm, uplo, diag, m, n, A, lda, work, x8, x9, x10);
            }
            return (double)mh$.invokeExact(norm, uplo, diag, m, n, A, lda, work, x8, x9, x10);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clapmr_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("clapmr_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void clapmr_(const int *forwrd, const int *m, const int *n, _Complex float *X, const int *ldx, int *K)
     * }
     */
    public static FunctionDescriptor clapmr_$descriptor() {
        return clapmr_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void clapmr_(const int *forwrd, const int *m, const int *n, _Complex float *X, const int *ldx, int *K)
     * }
     */
    public static MethodHandle clapmr_$handle() {
        return clapmr_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void clapmr_(const int *forwrd, const int *m, const int *n, _Complex float *X, const int *ldx, int *K)
     * }
     */
    public static MemorySegment clapmr_$address() {
        return clapmr_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void clapmr_(const int *forwrd, const int *m, const int *n, _Complex float *X, const int *ldx, int *K)
     * }
     */
    public static void clapmr_(MemorySegment forwrd, MemorySegment m, MemorySegment n, MemorySegment X, MemorySegment ldx, MemorySegment K) {
        var mh$ = clapmr_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clapmr_", forwrd, m, n, X, ldx, K);
            }
            mh$.invokeExact(forwrd, m, n, X, ldx, K);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dlapmr_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("dlapmr_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dlapmr_(const int *forwrd, const int *m, const int *n, double *X, const int *ldx, int *K)
     * }
     */
    public static FunctionDescriptor dlapmr_$descriptor() {
        return dlapmr_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dlapmr_(const int *forwrd, const int *m, const int *n, double *X, const int *ldx, int *K)
     * }
     */
    public static MethodHandle dlapmr_$handle() {
        return dlapmr_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dlapmr_(const int *forwrd, const int *m, const int *n, double *X, const int *ldx, int *K)
     * }
     */
    public static MemorySegment dlapmr_$address() {
        return dlapmr_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dlapmr_(const int *forwrd, const int *m, const int *n, double *X, const int *ldx, int *K)
     * }
     */
    public static void dlapmr_(MemorySegment forwrd, MemorySegment m, MemorySegment n, MemorySegment X, MemorySegment ldx, MemorySegment K) {
        var mh$ = dlapmr_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dlapmr_", forwrd, m, n, X, ldx, K);
            }
            mh$.invokeExact(forwrd, m, n, X, ldx, K);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class slapmr_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("slapmr_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void slapmr_(const int *forwrd, const int *m, const int *n, float *X, const int *ldx, int *K)
     * }
     */
    public static FunctionDescriptor slapmr_$descriptor() {
        return slapmr_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void slapmr_(const int *forwrd, const int *m, const int *n, float *X, const int *ldx, int *K)
     * }
     */
    public static MethodHandle slapmr_$handle() {
        return slapmr_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void slapmr_(const int *forwrd, const int *m, const int *n, float *X, const int *ldx, int *K)
     * }
     */
    public static MemorySegment slapmr_$address() {
        return slapmr_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void slapmr_(const int *forwrd, const int *m, const int *n, float *X, const int *ldx, int *K)
     * }
     */
    public static void slapmr_(MemorySegment forwrd, MemorySegment m, MemorySegment n, MemorySegment X, MemorySegment ldx, MemorySegment K) {
        var mh$ = slapmr_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("slapmr_", forwrd, m, n, X, ldx, K);
            }
            mh$.invokeExact(forwrd, m, n, X, ldx, K);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zlapmr_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("zlapmr_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zlapmr_(const int *forwrd, const int *m, const int *n, _Complex double *X, const int *ldx, int *K)
     * }
     */
    public static FunctionDescriptor zlapmr_$descriptor() {
        return zlapmr_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zlapmr_(const int *forwrd, const int *m, const int *n, _Complex double *X, const int *ldx, int *K)
     * }
     */
    public static MethodHandle zlapmr_$handle() {
        return zlapmr_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zlapmr_(const int *forwrd, const int *m, const int *n, _Complex double *X, const int *ldx, int *K)
     * }
     */
    public static MemorySegment zlapmr_$address() {
        return zlapmr_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zlapmr_(const int *forwrd, const int *m, const int *n, _Complex double *X, const int *ldx, int *K)
     * }
     */
    public static void zlapmr_(MemorySegment forwrd, MemorySegment m, MemorySegment n, MemorySegment X, MemorySegment ldx, MemorySegment K) {
        var mh$ = zlapmr_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zlapmr_", forwrd, m, n, X, ldx, K);
            }
            mh$.invokeExact(forwrd, m, n, X, ldx, K);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clapmt_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("clapmt_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void clapmt_(const int *forwrd, const int *m, const int *n, _Complex float *X, const int *ldx, int *K)
     * }
     */
    public static FunctionDescriptor clapmt_$descriptor() {
        return clapmt_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void clapmt_(const int *forwrd, const int *m, const int *n, _Complex float *X, const int *ldx, int *K)
     * }
     */
    public static MethodHandle clapmt_$handle() {
        return clapmt_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void clapmt_(const int *forwrd, const int *m, const int *n, _Complex float *X, const int *ldx, int *K)
     * }
     */
    public static MemorySegment clapmt_$address() {
        return clapmt_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void clapmt_(const int *forwrd, const int *m, const int *n, _Complex float *X, const int *ldx, int *K)
     * }
     */
    public static void clapmt_(MemorySegment forwrd, MemorySegment m, MemorySegment n, MemorySegment X, MemorySegment ldx, MemorySegment K) {
        var mh$ = clapmt_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clapmt_", forwrd, m, n, X, ldx, K);
            }
            mh$.invokeExact(forwrd, m, n, X, ldx, K);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dlapmt_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("dlapmt_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dlapmt_(const int *forwrd, const int *m, const int *n, double *X, const int *ldx, int *K)
     * }
     */
    public static FunctionDescriptor dlapmt_$descriptor() {
        return dlapmt_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dlapmt_(const int *forwrd, const int *m, const int *n, double *X, const int *ldx, int *K)
     * }
     */
    public static MethodHandle dlapmt_$handle() {
        return dlapmt_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dlapmt_(const int *forwrd, const int *m, const int *n, double *X, const int *ldx, int *K)
     * }
     */
    public static MemorySegment dlapmt_$address() {
        return dlapmt_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dlapmt_(const int *forwrd, const int *m, const int *n, double *X, const int *ldx, int *K)
     * }
     */
    public static void dlapmt_(MemorySegment forwrd, MemorySegment m, MemorySegment n, MemorySegment X, MemorySegment ldx, MemorySegment K) {
        var mh$ = dlapmt_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dlapmt_", forwrd, m, n, X, ldx, K);
            }
            mh$.invokeExact(forwrd, m, n, X, ldx, K);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class slapmt_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("slapmt_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void slapmt_(const int *forwrd, const int *m, const int *n, float *X, const int *ldx, int *K)
     * }
     */
    public static FunctionDescriptor slapmt_$descriptor() {
        return slapmt_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void slapmt_(const int *forwrd, const int *m, const int *n, float *X, const int *ldx, int *K)
     * }
     */
    public static MethodHandle slapmt_$handle() {
        return slapmt_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void slapmt_(const int *forwrd, const int *m, const int *n, float *X, const int *ldx, int *K)
     * }
     */
    public static MemorySegment slapmt_$address() {
        return slapmt_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void slapmt_(const int *forwrd, const int *m, const int *n, float *X, const int *ldx, int *K)
     * }
     */
    public static void slapmt_(MemorySegment forwrd, MemorySegment m, MemorySegment n, MemorySegment X, MemorySegment ldx, MemorySegment K) {
        var mh$ = slapmt_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("slapmt_", forwrd, m, n, X, ldx, K);
            }
            mh$.invokeExact(forwrd, m, n, X, ldx, K);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zlapmt_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("zlapmt_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zlapmt_(const int *forwrd, const int *m, const int *n, _Complex double *X, const int *ldx, int *K)
     * }
     */
    public static FunctionDescriptor zlapmt_$descriptor() {
        return zlapmt_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zlapmt_(const int *forwrd, const int *m, const int *n, _Complex double *X, const int *ldx, int *K)
     * }
     */
    public static MethodHandle zlapmt_$handle() {
        return zlapmt_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zlapmt_(const int *forwrd, const int *m, const int *n, _Complex double *X, const int *ldx, int *K)
     * }
     */
    public static MemorySegment zlapmt_$address() {
        return zlapmt_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zlapmt_(const int *forwrd, const int *m, const int *n, _Complex double *X, const int *ldx, int *K)
     * }
     */
    public static void zlapmt_(MemorySegment forwrd, MemorySegment m, MemorySegment n, MemorySegment X, MemorySegment ldx, MemorySegment K) {
        var mh$ = zlapmt_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zlapmt_", forwrd, m, n, X, ldx, K);
            }
            mh$.invokeExact(forwrd, m, n, X, ldx, K);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dlapy2_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("dlapy2_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double dlapy2_(const double *x, const double *y)
     * }
     */
    public static FunctionDescriptor dlapy2_$descriptor() {
        return dlapy2_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double dlapy2_(const double *x, const double *y)
     * }
     */
    public static MethodHandle dlapy2_$handle() {
        return dlapy2_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double dlapy2_(const double *x, const double *y)
     * }
     */
    public static MemorySegment dlapy2_$address() {
        return dlapy2_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double dlapy2_(const double *x, const double *y)
     * }
     */
    public static double dlapy2_(MemorySegment x, MemorySegment y) {
        var mh$ = dlapy2_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dlapy2_", x, y);
            }
            return (double)mh$.invokeExact(x, y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class slapy2_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("slapy2_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * lapack_float_return slapy2_(const float *x, const float *y)
     * }
     */
    public static FunctionDescriptor slapy2_$descriptor() {
        return slapy2_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * lapack_float_return slapy2_(const float *x, const float *y)
     * }
     */
    public static MethodHandle slapy2_$handle() {
        return slapy2_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * lapack_float_return slapy2_(const float *x, const float *y)
     * }
     */
    public static MemorySegment slapy2_$address() {
        return slapy2_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * lapack_float_return slapy2_(const float *x, const float *y)
     * }
     */
    public static float slapy2_(MemorySegment x, MemorySegment y) {
        var mh$ = slapy2_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("slapy2_", x, y);
            }
            return (float)mh$.invokeExact(x, y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dlapy3_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("dlapy3_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double dlapy3_(const double *x, const double *y, const double *z)
     * }
     */
    public static FunctionDescriptor dlapy3_$descriptor() {
        return dlapy3_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double dlapy3_(const double *x, const double *y, const double *z)
     * }
     */
    public static MethodHandle dlapy3_$handle() {
        return dlapy3_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double dlapy3_(const double *x, const double *y, const double *z)
     * }
     */
    public static MemorySegment dlapy3_$address() {
        return dlapy3_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double dlapy3_(const double *x, const double *y, const double *z)
     * }
     */
    public static double dlapy3_(MemorySegment x, MemorySegment y, MemorySegment z) {
        var mh$ = dlapy3_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dlapy3_", x, y, z);
            }
            return (double)mh$.invokeExact(x, y, z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class slapy3_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("slapy3_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * lapack_float_return slapy3_(const float *x, const float *y, const float *z)
     * }
     */
    public static FunctionDescriptor slapy3_$descriptor() {
        return slapy3_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * lapack_float_return slapy3_(const float *x, const float *y, const float *z)
     * }
     */
    public static MethodHandle slapy3_$handle() {
        return slapy3_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * lapack_float_return slapy3_(const float *x, const float *y, const float *z)
     * }
     */
    public static MemorySegment slapy3_$address() {
        return slapy3_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * lapack_float_return slapy3_(const float *x, const float *y, const float *z)
     * }
     */
    public static float slapy3_(MemorySegment x, MemorySegment y, MemorySegment z) {
        var mh$ = slapy3_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("slapy3_", x, y, z);
            }
            return (float)mh$.invokeExact(x, y, z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clarcm_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("clarcm_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void clarcm_(const int *m, const int *n, const float *A, const int *lda, const _Complex float *B, const int *ldb, _Complex float *C, const int *ldc, float *rwork)
     * }
     */
    public static FunctionDescriptor clarcm_$descriptor() {
        return clarcm_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void clarcm_(const int *m, const int *n, const float *A, const int *lda, const _Complex float *B, const int *ldb, _Complex float *C, const int *ldc, float *rwork)
     * }
     */
    public static MethodHandle clarcm_$handle() {
        return clarcm_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void clarcm_(const int *m, const int *n, const float *A, const int *lda, const _Complex float *B, const int *ldb, _Complex float *C, const int *ldc, float *rwork)
     * }
     */
    public static MemorySegment clarcm_$address() {
        return clarcm_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void clarcm_(const int *m, const int *n, const float *A, const int *lda, const _Complex float *B, const int *ldb, _Complex float *C, const int *ldc, float *rwork)
     * }
     */
    public static void clarcm_(MemorySegment m, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment B, MemorySegment ldb, MemorySegment C, MemorySegment ldc, MemorySegment rwork) {
        var mh$ = clarcm_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clarcm_", m, n, A, lda, B, ldb, C, ldc, rwork);
            }
            mh$.invokeExact(m, n, A, lda, B, ldb, C, ldc, rwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zlarcm_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("zlarcm_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zlarcm_(const int *m, const int *n, const double *A, const int *lda, const _Complex double *B, const int *ldb, _Complex double *C, const int *ldc, double *rwork)
     * }
     */
    public static FunctionDescriptor zlarcm_$descriptor() {
        return zlarcm_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zlarcm_(const int *m, const int *n, const double *A, const int *lda, const _Complex double *B, const int *ldb, _Complex double *C, const int *ldc, double *rwork)
     * }
     */
    public static MethodHandle zlarcm_$handle() {
        return zlarcm_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zlarcm_(const int *m, const int *n, const double *A, const int *lda, const _Complex double *B, const int *ldb, _Complex double *C, const int *ldc, double *rwork)
     * }
     */
    public static MemorySegment zlarcm_$address() {
        return zlarcm_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zlarcm_(const int *m, const int *n, const double *A, const int *lda, const _Complex double *B, const int *ldb, _Complex double *C, const int *ldc, double *rwork)
     * }
     */
    public static void zlarcm_(MemorySegment m, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment B, MemorySegment ldb, MemorySegment C, MemorySegment ldc, MemorySegment rwork) {
        var mh$ = zlarcm_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zlarcm_", m, n, A, lda, B, ldb, C, ldc, rwork);
            }
            mh$.invokeExact(m, n, A, lda, B, ldb, C, ldc, rwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clarf_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("clarf_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void clarf_(const char *side, const int *m, const int *n, const _Complex float *V, const int *incv, const _Complex float *tau, _Complex float *C, const int *ldc, _Complex float *work, size_t)
     * }
     */
    public static FunctionDescriptor clarf_$descriptor() {
        return clarf_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void clarf_(const char *side, const int *m, const int *n, const _Complex float *V, const int *incv, const _Complex float *tau, _Complex float *C, const int *ldc, _Complex float *work, size_t)
     * }
     */
    public static MethodHandle clarf_$handle() {
        return clarf_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void clarf_(const char *side, const int *m, const int *n, const _Complex float *V, const int *incv, const _Complex float *tau, _Complex float *C, const int *ldc, _Complex float *work, size_t)
     * }
     */
    public static MemorySegment clarf_$address() {
        return clarf_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void clarf_(const char *side, const int *m, const int *n, const _Complex float *V, const int *incv, const _Complex float *tau, _Complex float *C, const int *ldc, _Complex float *work, size_t)
     * }
     */
    public static void clarf_(MemorySegment side, MemorySegment m, MemorySegment n, MemorySegment V, MemorySegment incv, MemorySegment tau, MemorySegment C, MemorySegment ldc, MemorySegment work, long x9) {
        var mh$ = clarf_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clarf_", side, m, n, V, incv, tau, C, ldc, work, x9);
            }
            mh$.invokeExact(side, m, n, V, incv, tau, C, ldc, work, x9);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dlarf_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("dlarf_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dlarf_(const char *side, const int *m, const int *n, const double *V, const int *incv, const double *tau, double *C, const int *ldc, double *work, size_t)
     * }
     */
    public static FunctionDescriptor dlarf_$descriptor() {
        return dlarf_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dlarf_(const char *side, const int *m, const int *n, const double *V, const int *incv, const double *tau, double *C, const int *ldc, double *work, size_t)
     * }
     */
    public static MethodHandle dlarf_$handle() {
        return dlarf_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dlarf_(const char *side, const int *m, const int *n, const double *V, const int *incv, const double *tau, double *C, const int *ldc, double *work, size_t)
     * }
     */
    public static MemorySegment dlarf_$address() {
        return dlarf_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dlarf_(const char *side, const int *m, const int *n, const double *V, const int *incv, const double *tau, double *C, const int *ldc, double *work, size_t)
     * }
     */
    public static void dlarf_(MemorySegment side, MemorySegment m, MemorySegment n, MemorySegment V, MemorySegment incv, MemorySegment tau, MemorySegment C, MemorySegment ldc, MemorySegment work, long x9) {
        var mh$ = dlarf_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dlarf_", side, m, n, V, incv, tau, C, ldc, work, x9);
            }
            mh$.invokeExact(side, m, n, V, incv, tau, C, ldc, work, x9);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class slarf_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("slarf_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void slarf_(const char *side, const int *m, const int *n, const float *V, const int *incv, const float *tau, float *C, const int *ldc, float *work, size_t)
     * }
     */
    public static FunctionDescriptor slarf_$descriptor() {
        return slarf_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void slarf_(const char *side, const int *m, const int *n, const float *V, const int *incv, const float *tau, float *C, const int *ldc, float *work, size_t)
     * }
     */
    public static MethodHandle slarf_$handle() {
        return slarf_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void slarf_(const char *side, const int *m, const int *n, const float *V, const int *incv, const float *tau, float *C, const int *ldc, float *work, size_t)
     * }
     */
    public static MemorySegment slarf_$address() {
        return slarf_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void slarf_(const char *side, const int *m, const int *n, const float *V, const int *incv, const float *tau, float *C, const int *ldc, float *work, size_t)
     * }
     */
    public static void slarf_(MemorySegment side, MemorySegment m, MemorySegment n, MemorySegment V, MemorySegment incv, MemorySegment tau, MemorySegment C, MemorySegment ldc, MemorySegment work, long x9) {
        var mh$ = slarf_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("slarf_", side, m, n, V, incv, tau, C, ldc, work, x9);
            }
            mh$.invokeExact(side, m, n, V, incv, tau, C, ldc, work, x9);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zlarf_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("zlarf_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zlarf_(const char *side, const int *m, const int *n, const _Complex double *V, const int *incv, const _Complex double *tau, _Complex double *C, const int *ldc, _Complex double *work, size_t)
     * }
     */
    public static FunctionDescriptor zlarf_$descriptor() {
        return zlarf_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zlarf_(const char *side, const int *m, const int *n, const _Complex double *V, const int *incv, const _Complex double *tau, _Complex double *C, const int *ldc, _Complex double *work, size_t)
     * }
     */
    public static MethodHandle zlarf_$handle() {
        return zlarf_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zlarf_(const char *side, const int *m, const int *n, const _Complex double *V, const int *incv, const _Complex double *tau, _Complex double *C, const int *ldc, _Complex double *work, size_t)
     * }
     */
    public static MemorySegment zlarf_$address() {
        return zlarf_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zlarf_(const char *side, const int *m, const int *n, const _Complex double *V, const int *incv, const _Complex double *tau, _Complex double *C, const int *ldc, _Complex double *work, size_t)
     * }
     */
    public static void zlarf_(MemorySegment side, MemorySegment m, MemorySegment n, MemorySegment V, MemorySegment incv, MemorySegment tau, MemorySegment C, MemorySegment ldc, MemorySegment work, long x9) {
        var mh$ = zlarf_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zlarf_", side, m, n, V, incv, tau, C, ldc, work, x9);
            }
            mh$.invokeExact(side, m, n, V, incv, tau, C, ldc, work, x9);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clarfb_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("clarfb_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void clarfb_(const char *side, const char *trans, const char *direct, const char *storev, const int *m, const int *n, const int *k, const _Complex float *V, const int *ldv, const _Complex float *T, const int *ldt, _Complex float *C, const int *ldc, _Complex float *work, const int *ldwork, size_t, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor clarfb_$descriptor() {
        return clarfb_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void clarfb_(const char *side, const char *trans, const char *direct, const char *storev, const int *m, const int *n, const int *k, const _Complex float *V, const int *ldv, const _Complex float *T, const int *ldt, _Complex float *C, const int *ldc, _Complex float *work, const int *ldwork, size_t, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle clarfb_$handle() {
        return clarfb_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void clarfb_(const char *side, const char *trans, const char *direct, const char *storev, const int *m, const int *n, const int *k, const _Complex float *V, const int *ldv, const _Complex float *T, const int *ldt, _Complex float *C, const int *ldc, _Complex float *work, const int *ldwork, size_t, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment clarfb_$address() {
        return clarfb_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void clarfb_(const char *side, const char *trans, const char *direct, const char *storev, const int *m, const int *n, const int *k, const _Complex float *V, const int *ldv, const _Complex float *T, const int *ldt, _Complex float *C, const int *ldc, _Complex float *work, const int *ldwork, size_t, size_t, size_t, size_t)
     * }
     */
    public static void clarfb_(MemorySegment side, MemorySegment trans, MemorySegment direct, MemorySegment storev, MemorySegment m, MemorySegment n, MemorySegment k, MemorySegment V, MemorySegment ldv, MemorySegment T, MemorySegment ldt, MemorySegment C, MemorySegment ldc, MemorySegment work, MemorySegment ldwork, long x15, long x16, long x17, long x18) {
        var mh$ = clarfb_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clarfb_", side, trans, direct, storev, m, n, k, V, ldv, T, ldt, C, ldc, work, ldwork, x15, x16, x17, x18);
            }
            mh$.invokeExact(side, trans, direct, storev, m, n, k, V, ldv, T, ldt, C, ldc, work, ldwork, x15, x16, x17, x18);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dlarfb_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("dlarfb_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dlarfb_(const char *side, const char *trans, const char *direct, const char *storev, const int *m, const int *n, const int *k, const double *V, const int *ldv, const double *T, const int *ldt, double *C, const int *ldc, double *work, const int *ldwork, size_t, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor dlarfb_$descriptor() {
        return dlarfb_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dlarfb_(const char *side, const char *trans, const char *direct, const char *storev, const int *m, const int *n, const int *k, const double *V, const int *ldv, const double *T, const int *ldt, double *C, const int *ldc, double *work, const int *ldwork, size_t, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle dlarfb_$handle() {
        return dlarfb_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dlarfb_(const char *side, const char *trans, const char *direct, const char *storev, const int *m, const int *n, const int *k, const double *V, const int *ldv, const double *T, const int *ldt, double *C, const int *ldc, double *work, const int *ldwork, size_t, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment dlarfb_$address() {
        return dlarfb_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dlarfb_(const char *side, const char *trans, const char *direct, const char *storev, const int *m, const int *n, const int *k, const double *V, const int *ldv, const double *T, const int *ldt, double *C, const int *ldc, double *work, const int *ldwork, size_t, size_t, size_t, size_t)
     * }
     */
    public static void dlarfb_(MemorySegment side, MemorySegment trans, MemorySegment direct, MemorySegment storev, MemorySegment m, MemorySegment n, MemorySegment k, MemorySegment V, MemorySegment ldv, MemorySegment T, MemorySegment ldt, MemorySegment C, MemorySegment ldc, MemorySegment work, MemorySegment ldwork, long x15, long x16, long x17, long x18) {
        var mh$ = dlarfb_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dlarfb_", side, trans, direct, storev, m, n, k, V, ldv, T, ldt, C, ldc, work, ldwork, x15, x16, x17, x18);
            }
            mh$.invokeExact(side, trans, direct, storev, m, n, k, V, ldv, T, ldt, C, ldc, work, ldwork, x15, x16, x17, x18);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class slarfb_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("slarfb_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void slarfb_(const char *side, const char *trans, const char *direct, const char *storev, const int *m, const int *n, const int *k, const float *V, const int *ldv, const float *T, const int *ldt, float *C, const int *ldc, float *work, const int *ldwork, size_t, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor slarfb_$descriptor() {
        return slarfb_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void slarfb_(const char *side, const char *trans, const char *direct, const char *storev, const int *m, const int *n, const int *k, const float *V, const int *ldv, const float *T, const int *ldt, float *C, const int *ldc, float *work, const int *ldwork, size_t, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle slarfb_$handle() {
        return slarfb_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void slarfb_(const char *side, const char *trans, const char *direct, const char *storev, const int *m, const int *n, const int *k, const float *V, const int *ldv, const float *T, const int *ldt, float *C, const int *ldc, float *work, const int *ldwork, size_t, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment slarfb_$address() {
        return slarfb_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void slarfb_(const char *side, const char *trans, const char *direct, const char *storev, const int *m, const int *n, const int *k, const float *V, const int *ldv, const float *T, const int *ldt, float *C, const int *ldc, float *work, const int *ldwork, size_t, size_t, size_t, size_t)
     * }
     */
    public static void slarfb_(MemorySegment side, MemorySegment trans, MemorySegment direct, MemorySegment storev, MemorySegment m, MemorySegment n, MemorySegment k, MemorySegment V, MemorySegment ldv, MemorySegment T, MemorySegment ldt, MemorySegment C, MemorySegment ldc, MemorySegment work, MemorySegment ldwork, long x15, long x16, long x17, long x18) {
        var mh$ = slarfb_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("slarfb_", side, trans, direct, storev, m, n, k, V, ldv, T, ldt, C, ldc, work, ldwork, x15, x16, x17, x18);
            }
            mh$.invokeExact(side, trans, direct, storev, m, n, k, V, ldv, T, ldt, C, ldc, work, ldwork, x15, x16, x17, x18);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zlarfb_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("zlarfb_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zlarfb_(const char *side, const char *trans, const char *direct, const char *storev, const int *m, const int *n, const int *k, const _Complex double *V, const int *ldv, const _Complex double *T, const int *ldt, _Complex double *C, const int *ldc, _Complex double *work, const int *ldwork, size_t, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor zlarfb_$descriptor() {
        return zlarfb_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zlarfb_(const char *side, const char *trans, const char *direct, const char *storev, const int *m, const int *n, const int *k, const _Complex double *V, const int *ldv, const _Complex double *T, const int *ldt, _Complex double *C, const int *ldc, _Complex double *work, const int *ldwork, size_t, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle zlarfb_$handle() {
        return zlarfb_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zlarfb_(const char *side, const char *trans, const char *direct, const char *storev, const int *m, const int *n, const int *k, const _Complex double *V, const int *ldv, const _Complex double *T, const int *ldt, _Complex double *C, const int *ldc, _Complex double *work, const int *ldwork, size_t, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment zlarfb_$address() {
        return zlarfb_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zlarfb_(const char *side, const char *trans, const char *direct, const char *storev, const int *m, const int *n, const int *k, const _Complex double *V, const int *ldv, const _Complex double *T, const int *ldt, _Complex double *C, const int *ldc, _Complex double *work, const int *ldwork, size_t, size_t, size_t, size_t)
     * }
     */
    public static void zlarfb_(MemorySegment side, MemorySegment trans, MemorySegment direct, MemorySegment storev, MemorySegment m, MemorySegment n, MemorySegment k, MemorySegment V, MemorySegment ldv, MemorySegment T, MemorySegment ldt, MemorySegment C, MemorySegment ldc, MemorySegment work, MemorySegment ldwork, long x15, long x16, long x17, long x18) {
        var mh$ = zlarfb_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zlarfb_", side, trans, direct, storev, m, n, k, V, ldv, T, ldt, C, ldc, work, ldwork, x15, x16, x17, x18);
            }
            mh$.invokeExact(side, trans, direct, storev, m, n, k, V, ldv, T, ldt, C, ldc, work, ldwork, x15, x16, x17, x18);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clarfg_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("clarfg_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void clarfg_(const int *n, _Complex float *alpha, _Complex float *X, const int *incx, _Complex float *tau)
     * }
     */
    public static FunctionDescriptor clarfg_$descriptor() {
        return clarfg_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void clarfg_(const int *n, _Complex float *alpha, _Complex float *X, const int *incx, _Complex float *tau)
     * }
     */
    public static MethodHandle clarfg_$handle() {
        return clarfg_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void clarfg_(const int *n, _Complex float *alpha, _Complex float *X, const int *incx, _Complex float *tau)
     * }
     */
    public static MemorySegment clarfg_$address() {
        return clarfg_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void clarfg_(const int *n, _Complex float *alpha, _Complex float *X, const int *incx, _Complex float *tau)
     * }
     */
    public static void clarfg_(MemorySegment n, MemorySegment alpha, MemorySegment X, MemorySegment incx, MemorySegment tau) {
        var mh$ = clarfg_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clarfg_", n, alpha, X, incx, tau);
            }
            mh$.invokeExact(n, alpha, X, incx, tau);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dlarfg_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("dlarfg_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dlarfg_(const int *n, double *alpha, double *X, const int *incx, double *tau)
     * }
     */
    public static FunctionDescriptor dlarfg_$descriptor() {
        return dlarfg_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dlarfg_(const int *n, double *alpha, double *X, const int *incx, double *tau)
     * }
     */
    public static MethodHandle dlarfg_$handle() {
        return dlarfg_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dlarfg_(const int *n, double *alpha, double *X, const int *incx, double *tau)
     * }
     */
    public static MemorySegment dlarfg_$address() {
        return dlarfg_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dlarfg_(const int *n, double *alpha, double *X, const int *incx, double *tau)
     * }
     */
    public static void dlarfg_(MemorySegment n, MemorySegment alpha, MemorySegment X, MemorySegment incx, MemorySegment tau) {
        var mh$ = dlarfg_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dlarfg_", n, alpha, X, incx, tau);
            }
            mh$.invokeExact(n, alpha, X, incx, tau);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class slarfg_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("slarfg_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void slarfg_(const int *n, float *alpha, float *X, const int *incx, float *tau)
     * }
     */
    public static FunctionDescriptor slarfg_$descriptor() {
        return slarfg_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void slarfg_(const int *n, float *alpha, float *X, const int *incx, float *tau)
     * }
     */
    public static MethodHandle slarfg_$handle() {
        return slarfg_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void slarfg_(const int *n, float *alpha, float *X, const int *incx, float *tau)
     * }
     */
    public static MemorySegment slarfg_$address() {
        return slarfg_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void slarfg_(const int *n, float *alpha, float *X, const int *incx, float *tau)
     * }
     */
    public static void slarfg_(MemorySegment n, MemorySegment alpha, MemorySegment X, MemorySegment incx, MemorySegment tau) {
        var mh$ = slarfg_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("slarfg_", n, alpha, X, incx, tau);
            }
            mh$.invokeExact(n, alpha, X, incx, tau);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zlarfg_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("zlarfg_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zlarfg_(const int *n, _Complex double *alpha, _Complex double *X, const int *incx, _Complex double *tau)
     * }
     */
    public static FunctionDescriptor zlarfg_$descriptor() {
        return zlarfg_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zlarfg_(const int *n, _Complex double *alpha, _Complex double *X, const int *incx, _Complex double *tau)
     * }
     */
    public static MethodHandle zlarfg_$handle() {
        return zlarfg_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zlarfg_(const int *n, _Complex double *alpha, _Complex double *X, const int *incx, _Complex double *tau)
     * }
     */
    public static MemorySegment zlarfg_$address() {
        return zlarfg_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zlarfg_(const int *n, _Complex double *alpha, _Complex double *X, const int *incx, _Complex double *tau)
     * }
     */
    public static void zlarfg_(MemorySegment n, MemorySegment alpha, MemorySegment X, MemorySegment incx, MemorySegment tau) {
        var mh$ = zlarfg_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zlarfg_", n, alpha, X, incx, tau);
            }
            mh$.invokeExact(n, alpha, X, incx, tau);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clarft_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("clarft_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void clarft_(const char *direct, const char *storev, const int *n, const int *k, const _Complex float *V, const int *ldv, const _Complex float *tau, _Complex float *T, const int *ldt, size_t, size_t)
     * }
     */
    public static FunctionDescriptor clarft_$descriptor() {
        return clarft_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void clarft_(const char *direct, const char *storev, const int *n, const int *k, const _Complex float *V, const int *ldv, const _Complex float *tau, _Complex float *T, const int *ldt, size_t, size_t)
     * }
     */
    public static MethodHandle clarft_$handle() {
        return clarft_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void clarft_(const char *direct, const char *storev, const int *n, const int *k, const _Complex float *V, const int *ldv, const _Complex float *tau, _Complex float *T, const int *ldt, size_t, size_t)
     * }
     */
    public static MemorySegment clarft_$address() {
        return clarft_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void clarft_(const char *direct, const char *storev, const int *n, const int *k, const _Complex float *V, const int *ldv, const _Complex float *tau, _Complex float *T, const int *ldt, size_t, size_t)
     * }
     */
    public static void clarft_(MemorySegment direct, MemorySegment storev, MemorySegment n, MemorySegment k, MemorySegment V, MemorySegment ldv, MemorySegment tau, MemorySegment T, MemorySegment ldt, long x9, long x10) {
        var mh$ = clarft_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clarft_", direct, storev, n, k, V, ldv, tau, T, ldt, x9, x10);
            }
            mh$.invokeExact(direct, storev, n, k, V, ldv, tau, T, ldt, x9, x10);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dlarft_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("dlarft_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dlarft_(const char *direct, const char *storev, const int *n, const int *k, const double *V, const int *ldv, const double *tau, double *T, const int *ldt, size_t, size_t)
     * }
     */
    public static FunctionDescriptor dlarft_$descriptor() {
        return dlarft_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dlarft_(const char *direct, const char *storev, const int *n, const int *k, const double *V, const int *ldv, const double *tau, double *T, const int *ldt, size_t, size_t)
     * }
     */
    public static MethodHandle dlarft_$handle() {
        return dlarft_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dlarft_(const char *direct, const char *storev, const int *n, const int *k, const double *V, const int *ldv, const double *tau, double *T, const int *ldt, size_t, size_t)
     * }
     */
    public static MemorySegment dlarft_$address() {
        return dlarft_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dlarft_(const char *direct, const char *storev, const int *n, const int *k, const double *V, const int *ldv, const double *tau, double *T, const int *ldt, size_t, size_t)
     * }
     */
    public static void dlarft_(MemorySegment direct, MemorySegment storev, MemorySegment n, MemorySegment k, MemorySegment V, MemorySegment ldv, MemorySegment tau, MemorySegment T, MemorySegment ldt, long x9, long x10) {
        var mh$ = dlarft_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dlarft_", direct, storev, n, k, V, ldv, tau, T, ldt, x9, x10);
            }
            mh$.invokeExact(direct, storev, n, k, V, ldv, tau, T, ldt, x9, x10);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class slarft_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("slarft_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void slarft_(const char *direct, const char *storev, const int *n, const int *k, const float *V, const int *ldv, const float *tau, float *T, const int *ldt, size_t, size_t)
     * }
     */
    public static FunctionDescriptor slarft_$descriptor() {
        return slarft_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void slarft_(const char *direct, const char *storev, const int *n, const int *k, const float *V, const int *ldv, const float *tau, float *T, const int *ldt, size_t, size_t)
     * }
     */
    public static MethodHandle slarft_$handle() {
        return slarft_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void slarft_(const char *direct, const char *storev, const int *n, const int *k, const float *V, const int *ldv, const float *tau, float *T, const int *ldt, size_t, size_t)
     * }
     */
    public static MemorySegment slarft_$address() {
        return slarft_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void slarft_(const char *direct, const char *storev, const int *n, const int *k, const float *V, const int *ldv, const float *tau, float *T, const int *ldt, size_t, size_t)
     * }
     */
    public static void slarft_(MemorySegment direct, MemorySegment storev, MemorySegment n, MemorySegment k, MemorySegment V, MemorySegment ldv, MemorySegment tau, MemorySegment T, MemorySegment ldt, long x9, long x10) {
        var mh$ = slarft_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("slarft_", direct, storev, n, k, V, ldv, tau, T, ldt, x9, x10);
            }
            mh$.invokeExact(direct, storev, n, k, V, ldv, tau, T, ldt, x9, x10);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zlarft_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("zlarft_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zlarft_(const char *direct, const char *storev, const int *n, const int *k, const _Complex double *V, const int *ldv, const _Complex double *tau, _Complex double *T, const int *ldt, size_t, size_t)
     * }
     */
    public static FunctionDescriptor zlarft_$descriptor() {
        return zlarft_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zlarft_(const char *direct, const char *storev, const int *n, const int *k, const _Complex double *V, const int *ldv, const _Complex double *tau, _Complex double *T, const int *ldt, size_t, size_t)
     * }
     */
    public static MethodHandle zlarft_$handle() {
        return zlarft_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zlarft_(const char *direct, const char *storev, const int *n, const int *k, const _Complex double *V, const int *ldv, const _Complex double *tau, _Complex double *T, const int *ldt, size_t, size_t)
     * }
     */
    public static MemorySegment zlarft_$address() {
        return zlarft_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zlarft_(const char *direct, const char *storev, const int *n, const int *k, const _Complex double *V, const int *ldv, const _Complex double *tau, _Complex double *T, const int *ldt, size_t, size_t)
     * }
     */
    public static void zlarft_(MemorySegment direct, MemorySegment storev, MemorySegment n, MemorySegment k, MemorySegment V, MemorySegment ldv, MemorySegment tau, MemorySegment T, MemorySegment ldt, long x9, long x10) {
        var mh$ = zlarft_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zlarft_", direct, storev, n, k, V, ldv, tau, T, ldt, x9, x10);
            }
            mh$.invokeExact(direct, storev, n, k, V, ldv, tau, T, ldt, x9, x10);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clarfx_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("clarfx_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void clarfx_(const char *side, const int *m, const int *n, const _Complex float *V, const _Complex float *tau, _Complex float *C, const int *ldc, _Complex float *work, size_t)
     * }
     */
    public static FunctionDescriptor clarfx_$descriptor() {
        return clarfx_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void clarfx_(const char *side, const int *m, const int *n, const _Complex float *V, const _Complex float *tau, _Complex float *C, const int *ldc, _Complex float *work, size_t)
     * }
     */
    public static MethodHandle clarfx_$handle() {
        return clarfx_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void clarfx_(const char *side, const int *m, const int *n, const _Complex float *V, const _Complex float *tau, _Complex float *C, const int *ldc, _Complex float *work, size_t)
     * }
     */
    public static MemorySegment clarfx_$address() {
        return clarfx_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void clarfx_(const char *side, const int *m, const int *n, const _Complex float *V, const _Complex float *tau, _Complex float *C, const int *ldc, _Complex float *work, size_t)
     * }
     */
    public static void clarfx_(MemorySegment side, MemorySegment m, MemorySegment n, MemorySegment V, MemorySegment tau, MemorySegment C, MemorySegment ldc, MemorySegment work, long x8) {
        var mh$ = clarfx_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clarfx_", side, m, n, V, tau, C, ldc, work, x8);
            }
            mh$.invokeExact(side, m, n, V, tau, C, ldc, work, x8);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dlarfx_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("dlarfx_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dlarfx_(const char *side, const int *m, const int *n, const double *V, const double *tau, double *C, const int *ldc, double *work, size_t)
     * }
     */
    public static FunctionDescriptor dlarfx_$descriptor() {
        return dlarfx_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dlarfx_(const char *side, const int *m, const int *n, const double *V, const double *tau, double *C, const int *ldc, double *work, size_t)
     * }
     */
    public static MethodHandle dlarfx_$handle() {
        return dlarfx_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dlarfx_(const char *side, const int *m, const int *n, const double *V, const double *tau, double *C, const int *ldc, double *work, size_t)
     * }
     */
    public static MemorySegment dlarfx_$address() {
        return dlarfx_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dlarfx_(const char *side, const int *m, const int *n, const double *V, const double *tau, double *C, const int *ldc, double *work, size_t)
     * }
     */
    public static void dlarfx_(MemorySegment side, MemorySegment m, MemorySegment n, MemorySegment V, MemorySegment tau, MemorySegment C, MemorySegment ldc, MemorySegment work, long x8) {
        var mh$ = dlarfx_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dlarfx_", side, m, n, V, tau, C, ldc, work, x8);
            }
            mh$.invokeExact(side, m, n, V, tau, C, ldc, work, x8);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class slarfx_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("slarfx_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void slarfx_(const char *side, const int *m, const int *n, const float *V, const float *tau, float *C, const int *ldc, float *work, size_t)
     * }
     */
    public static FunctionDescriptor slarfx_$descriptor() {
        return slarfx_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void slarfx_(const char *side, const int *m, const int *n, const float *V, const float *tau, float *C, const int *ldc, float *work, size_t)
     * }
     */
    public static MethodHandle slarfx_$handle() {
        return slarfx_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void slarfx_(const char *side, const int *m, const int *n, const float *V, const float *tau, float *C, const int *ldc, float *work, size_t)
     * }
     */
    public static MemorySegment slarfx_$address() {
        return slarfx_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void slarfx_(const char *side, const int *m, const int *n, const float *V, const float *tau, float *C, const int *ldc, float *work, size_t)
     * }
     */
    public static void slarfx_(MemorySegment side, MemorySegment m, MemorySegment n, MemorySegment V, MemorySegment tau, MemorySegment C, MemorySegment ldc, MemorySegment work, long x8) {
        var mh$ = slarfx_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("slarfx_", side, m, n, V, tau, C, ldc, work, x8);
            }
            mh$.invokeExact(side, m, n, V, tau, C, ldc, work, x8);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zlarfx_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("zlarfx_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zlarfx_(const char *side, const int *m, const int *n, const _Complex double *V, const _Complex double *tau, _Complex double *C, const int *ldc, _Complex double *work, size_t)
     * }
     */
    public static FunctionDescriptor zlarfx_$descriptor() {
        return zlarfx_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zlarfx_(const char *side, const int *m, const int *n, const _Complex double *V, const _Complex double *tau, _Complex double *C, const int *ldc, _Complex double *work, size_t)
     * }
     */
    public static MethodHandle zlarfx_$handle() {
        return zlarfx_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zlarfx_(const char *side, const int *m, const int *n, const _Complex double *V, const _Complex double *tau, _Complex double *C, const int *ldc, _Complex double *work, size_t)
     * }
     */
    public static MemorySegment zlarfx_$address() {
        return zlarfx_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zlarfx_(const char *side, const int *m, const int *n, const _Complex double *V, const _Complex double *tau, _Complex double *C, const int *ldc, _Complex double *work, size_t)
     * }
     */
    public static void zlarfx_(MemorySegment side, MemorySegment m, MemorySegment n, MemorySegment V, MemorySegment tau, MemorySegment C, MemorySegment ldc, MemorySegment work, long x8) {
        var mh$ = zlarfx_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zlarfx_", side, m, n, V, tau, C, ldc, work, x8);
            }
            mh$.invokeExact(side, m, n, V, tau, C, ldc, work, x8);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clarnv_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("clarnv_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void clarnv_(const int *idist, int *iseed, const int *n, _Complex float *X)
     * }
     */
    public static FunctionDescriptor clarnv_$descriptor() {
        return clarnv_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void clarnv_(const int *idist, int *iseed, const int *n, _Complex float *X)
     * }
     */
    public static MethodHandle clarnv_$handle() {
        return clarnv_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void clarnv_(const int *idist, int *iseed, const int *n, _Complex float *X)
     * }
     */
    public static MemorySegment clarnv_$address() {
        return clarnv_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void clarnv_(const int *idist, int *iseed, const int *n, _Complex float *X)
     * }
     */
    public static void clarnv_(MemorySegment idist, MemorySegment iseed, MemorySegment n, MemorySegment X) {
        var mh$ = clarnv_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clarnv_", idist, iseed, n, X);
            }
            mh$.invokeExact(idist, iseed, n, X);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dlarnv_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("dlarnv_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dlarnv_(const int *idist, int *iseed, const int *n, double *X)
     * }
     */
    public static FunctionDescriptor dlarnv_$descriptor() {
        return dlarnv_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dlarnv_(const int *idist, int *iseed, const int *n, double *X)
     * }
     */
    public static MethodHandle dlarnv_$handle() {
        return dlarnv_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dlarnv_(const int *idist, int *iseed, const int *n, double *X)
     * }
     */
    public static MemorySegment dlarnv_$address() {
        return dlarnv_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dlarnv_(const int *idist, int *iseed, const int *n, double *X)
     * }
     */
    public static void dlarnv_(MemorySegment idist, MemorySegment iseed, MemorySegment n, MemorySegment X) {
        var mh$ = dlarnv_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dlarnv_", idist, iseed, n, X);
            }
            mh$.invokeExact(idist, iseed, n, X);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class slarnv_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("slarnv_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void slarnv_(const int *idist, int *iseed, const int *n, float *X)
     * }
     */
    public static FunctionDescriptor slarnv_$descriptor() {
        return slarnv_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void slarnv_(const int *idist, int *iseed, const int *n, float *X)
     * }
     */
    public static MethodHandle slarnv_$handle() {
        return slarnv_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void slarnv_(const int *idist, int *iseed, const int *n, float *X)
     * }
     */
    public static MemorySegment slarnv_$address() {
        return slarnv_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void slarnv_(const int *idist, int *iseed, const int *n, float *X)
     * }
     */
    public static void slarnv_(MemorySegment idist, MemorySegment iseed, MemorySegment n, MemorySegment X) {
        var mh$ = slarnv_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("slarnv_", idist, iseed, n, X);
            }
            mh$.invokeExact(idist, iseed, n, X);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zlarnv_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("zlarnv_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zlarnv_(const int *idist, int *iseed, const int *n, _Complex double *X)
     * }
     */
    public static FunctionDescriptor zlarnv_$descriptor() {
        return zlarnv_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zlarnv_(const int *idist, int *iseed, const int *n, _Complex double *X)
     * }
     */
    public static MethodHandle zlarnv_$handle() {
        return zlarnv_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zlarnv_(const int *idist, int *iseed, const int *n, _Complex double *X)
     * }
     */
    public static MemorySegment zlarnv_$address() {
        return zlarnv_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zlarnv_(const int *idist, int *iseed, const int *n, _Complex double *X)
     * }
     */
    public static void zlarnv_(MemorySegment idist, MemorySegment iseed, MemorySegment n, MemorySegment X) {
        var mh$ = zlarnv_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zlarnv_", idist, iseed, n, X);
            }
            mh$.invokeExact(idist, iseed, n, X);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dlartgp_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("dlartgp_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dlartgp_(const double *f, const double *g, double *cs, double *sn, double *r)
     * }
     */
    public static FunctionDescriptor dlartgp_$descriptor() {
        return dlartgp_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dlartgp_(const double *f, const double *g, double *cs, double *sn, double *r)
     * }
     */
    public static MethodHandle dlartgp_$handle() {
        return dlartgp_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dlartgp_(const double *f, const double *g, double *cs, double *sn, double *r)
     * }
     */
    public static MemorySegment dlartgp_$address() {
        return dlartgp_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dlartgp_(const double *f, const double *g, double *cs, double *sn, double *r)
     * }
     */
    public static void dlartgp_(MemorySegment f, MemorySegment g, MemorySegment cs, MemorySegment sn, MemorySegment r) {
        var mh$ = dlartgp_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dlartgp_", f, g, cs, sn, r);
            }
            mh$.invokeExact(f, g, cs, sn, r);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class slartgp_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("slartgp_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void slartgp_(const float *f, const float *g, float *cs, float *sn, float *r)
     * }
     */
    public static FunctionDescriptor slartgp_$descriptor() {
        return slartgp_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void slartgp_(const float *f, const float *g, float *cs, float *sn, float *r)
     * }
     */
    public static MethodHandle slartgp_$handle() {
        return slartgp_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void slartgp_(const float *f, const float *g, float *cs, float *sn, float *r)
     * }
     */
    public static MemorySegment slartgp_$address() {
        return slartgp_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void slartgp_(const float *f, const float *g, float *cs, float *sn, float *r)
     * }
     */
    public static void slartgp_(MemorySegment f, MemorySegment g, MemorySegment cs, MemorySegment sn, MemorySegment r) {
        var mh$ = slartgp_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("slartgp_", f, g, cs, sn, r);
            }
            mh$.invokeExact(f, g, cs, sn, r);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dlartgs_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("dlartgs_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dlartgs_(const double *x, const double *y, const double *sigma, double *cs, double *sn)
     * }
     */
    public static FunctionDescriptor dlartgs_$descriptor() {
        return dlartgs_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dlartgs_(const double *x, const double *y, const double *sigma, double *cs, double *sn)
     * }
     */
    public static MethodHandle dlartgs_$handle() {
        return dlartgs_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dlartgs_(const double *x, const double *y, const double *sigma, double *cs, double *sn)
     * }
     */
    public static MemorySegment dlartgs_$address() {
        return dlartgs_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dlartgs_(const double *x, const double *y, const double *sigma, double *cs, double *sn)
     * }
     */
    public static void dlartgs_(MemorySegment x, MemorySegment y, MemorySegment sigma, MemorySegment cs, MemorySegment sn) {
        var mh$ = dlartgs_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dlartgs_", x, y, sigma, cs, sn);
            }
            mh$.invokeExact(x, y, sigma, cs, sn);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class slartgs_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("slartgs_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void slartgs_(const float *x, const float *y, const float *sigma, float *cs, float *sn)
     * }
     */
    public static FunctionDescriptor slartgs_$descriptor() {
        return slartgs_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void slartgs_(const float *x, const float *y, const float *sigma, float *cs, float *sn)
     * }
     */
    public static MethodHandle slartgs_$handle() {
        return slartgs_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void slartgs_(const float *x, const float *y, const float *sigma, float *cs, float *sn)
     * }
     */
    public static MemorySegment slartgs_$address() {
        return slartgs_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void slartgs_(const float *x, const float *y, const float *sigma, float *cs, float *sn)
     * }
     */
    public static void slartgs_(MemorySegment x, MemorySegment y, MemorySegment sigma, MemorySegment cs, MemorySegment sn) {
        var mh$ = slartgs_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("slartgs_", x, y, sigma, cs, sn);
            }
            mh$.invokeExact(x, y, sigma, cs, sn);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clascl_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("clascl_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void clascl_(const char *type, const int *kl, const int *ku, const float *cfrom, const float *cto, const int *m, const int *n, _Complex float *A, const int *lda, int *info, size_t)
     * }
     */
    public static FunctionDescriptor clascl_$descriptor() {
        return clascl_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void clascl_(const char *type, const int *kl, const int *ku, const float *cfrom, const float *cto, const int *m, const int *n, _Complex float *A, const int *lda, int *info, size_t)
     * }
     */
    public static MethodHandle clascl_$handle() {
        return clascl_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void clascl_(const char *type, const int *kl, const int *ku, const float *cfrom, const float *cto, const int *m, const int *n, _Complex float *A, const int *lda, int *info, size_t)
     * }
     */
    public static MemorySegment clascl_$address() {
        return clascl_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void clascl_(const char *type, const int *kl, const int *ku, const float *cfrom, const float *cto, const int *m, const int *n, _Complex float *A, const int *lda, int *info, size_t)
     * }
     */
    public static void clascl_(MemorySegment type, MemorySegment kl, MemorySegment ku, MemorySegment cfrom, MemorySegment cto, MemorySegment m, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment info, long x10) {
        var mh$ = clascl_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clascl_", type, kl, ku, cfrom, cto, m, n, A, lda, info, x10);
            }
            mh$.invokeExact(type, kl, ku, cfrom, cto, m, n, A, lda, info, x10);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dlascl_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("dlascl_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dlascl_(const char *type, const int *kl, const int *ku, const double *cfrom, const double *cto, const int *m, const int *n, double *A, const int *lda, int *info, size_t)
     * }
     */
    public static FunctionDescriptor dlascl_$descriptor() {
        return dlascl_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dlascl_(const char *type, const int *kl, const int *ku, const double *cfrom, const double *cto, const int *m, const int *n, double *A, const int *lda, int *info, size_t)
     * }
     */
    public static MethodHandle dlascl_$handle() {
        return dlascl_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dlascl_(const char *type, const int *kl, const int *ku, const double *cfrom, const double *cto, const int *m, const int *n, double *A, const int *lda, int *info, size_t)
     * }
     */
    public static MemorySegment dlascl_$address() {
        return dlascl_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dlascl_(const char *type, const int *kl, const int *ku, const double *cfrom, const double *cto, const int *m, const int *n, double *A, const int *lda, int *info, size_t)
     * }
     */
    public static void dlascl_(MemorySegment type, MemorySegment kl, MemorySegment ku, MemorySegment cfrom, MemorySegment cto, MemorySegment m, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment info, long x10) {
        var mh$ = dlascl_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dlascl_", type, kl, ku, cfrom, cto, m, n, A, lda, info, x10);
            }
            mh$.invokeExact(type, kl, ku, cfrom, cto, m, n, A, lda, info, x10);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class slascl_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("slascl_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void slascl_(const char *type, const int *kl, const int *ku, const float *cfrom, const float *cto, const int *m, const int *n, float *A, const int *lda, int *info, size_t)
     * }
     */
    public static FunctionDescriptor slascl_$descriptor() {
        return slascl_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void slascl_(const char *type, const int *kl, const int *ku, const float *cfrom, const float *cto, const int *m, const int *n, float *A, const int *lda, int *info, size_t)
     * }
     */
    public static MethodHandle slascl_$handle() {
        return slascl_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void slascl_(const char *type, const int *kl, const int *ku, const float *cfrom, const float *cto, const int *m, const int *n, float *A, const int *lda, int *info, size_t)
     * }
     */
    public static MemorySegment slascl_$address() {
        return slascl_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void slascl_(const char *type, const int *kl, const int *ku, const float *cfrom, const float *cto, const int *m, const int *n, float *A, const int *lda, int *info, size_t)
     * }
     */
    public static void slascl_(MemorySegment type, MemorySegment kl, MemorySegment ku, MemorySegment cfrom, MemorySegment cto, MemorySegment m, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment info, long x10) {
        var mh$ = slascl_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("slascl_", type, kl, ku, cfrom, cto, m, n, A, lda, info, x10);
            }
            mh$.invokeExact(type, kl, ku, cfrom, cto, m, n, A, lda, info, x10);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zlascl_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("zlascl_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zlascl_(const char *type, const int *kl, const int *ku, const double *cfrom, const double *cto, const int *m, const int *n, _Complex double *A, const int *lda, int *info, size_t)
     * }
     */
    public static FunctionDescriptor zlascl_$descriptor() {
        return zlascl_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zlascl_(const char *type, const int *kl, const int *ku, const double *cfrom, const double *cto, const int *m, const int *n, _Complex double *A, const int *lda, int *info, size_t)
     * }
     */
    public static MethodHandle zlascl_$handle() {
        return zlascl_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zlascl_(const char *type, const int *kl, const int *ku, const double *cfrom, const double *cto, const int *m, const int *n, _Complex double *A, const int *lda, int *info, size_t)
     * }
     */
    public static MemorySegment zlascl_$address() {
        return zlascl_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zlascl_(const char *type, const int *kl, const int *ku, const double *cfrom, const double *cto, const int *m, const int *n, _Complex double *A, const int *lda, int *info, size_t)
     * }
     */
    public static void zlascl_(MemorySegment type, MemorySegment kl, MemorySegment ku, MemorySegment cfrom, MemorySegment cto, MemorySegment m, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment info, long x10) {
        var mh$ = zlascl_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zlascl_", type, kl, ku, cfrom, cto, m, n, A, lda, info, x10);
            }
            mh$.invokeExact(type, kl, ku, cfrom, cto, m, n, A, lda, info, x10);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class claset_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("claset_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void claset_(const char *uplo, const int *m, const int *n, const _Complex float *alpha, const _Complex float *beta, _Complex float *A, const int *lda, size_t)
     * }
     */
    public static FunctionDescriptor claset_$descriptor() {
        return claset_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void claset_(const char *uplo, const int *m, const int *n, const _Complex float *alpha, const _Complex float *beta, _Complex float *A, const int *lda, size_t)
     * }
     */
    public static MethodHandle claset_$handle() {
        return claset_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void claset_(const char *uplo, const int *m, const int *n, const _Complex float *alpha, const _Complex float *beta, _Complex float *A, const int *lda, size_t)
     * }
     */
    public static MemorySegment claset_$address() {
        return claset_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void claset_(const char *uplo, const int *m, const int *n, const _Complex float *alpha, const _Complex float *beta, _Complex float *A, const int *lda, size_t)
     * }
     */
    public static void claset_(MemorySegment uplo, MemorySegment m, MemorySegment n, MemorySegment alpha, MemorySegment beta, MemorySegment A, MemorySegment lda, long x7) {
        var mh$ = claset_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("claset_", uplo, m, n, alpha, beta, A, lda, x7);
            }
            mh$.invokeExact(uplo, m, n, alpha, beta, A, lda, x7);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dlaset_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("dlaset_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dlaset_(const char *uplo, const int *m, const int *n, const double *alpha, const double *beta, double *A, const int *lda, size_t)
     * }
     */
    public static FunctionDescriptor dlaset_$descriptor() {
        return dlaset_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dlaset_(const char *uplo, const int *m, const int *n, const double *alpha, const double *beta, double *A, const int *lda, size_t)
     * }
     */
    public static MethodHandle dlaset_$handle() {
        return dlaset_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dlaset_(const char *uplo, const int *m, const int *n, const double *alpha, const double *beta, double *A, const int *lda, size_t)
     * }
     */
    public static MemorySegment dlaset_$address() {
        return dlaset_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dlaset_(const char *uplo, const int *m, const int *n, const double *alpha, const double *beta, double *A, const int *lda, size_t)
     * }
     */
    public static void dlaset_(MemorySegment uplo, MemorySegment m, MemorySegment n, MemorySegment alpha, MemorySegment beta, MemorySegment A, MemorySegment lda, long x7) {
        var mh$ = dlaset_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dlaset_", uplo, m, n, alpha, beta, A, lda, x7);
            }
            mh$.invokeExact(uplo, m, n, alpha, beta, A, lda, x7);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class slaset_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("slaset_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void slaset_(const char *uplo, const int *m, const int *n, const float *alpha, const float *beta, float *A, const int *lda, size_t)
     * }
     */
    public static FunctionDescriptor slaset_$descriptor() {
        return slaset_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void slaset_(const char *uplo, const int *m, const int *n, const float *alpha, const float *beta, float *A, const int *lda, size_t)
     * }
     */
    public static MethodHandle slaset_$handle() {
        return slaset_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void slaset_(const char *uplo, const int *m, const int *n, const float *alpha, const float *beta, float *A, const int *lda, size_t)
     * }
     */
    public static MemorySegment slaset_$address() {
        return slaset_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void slaset_(const char *uplo, const int *m, const int *n, const float *alpha, const float *beta, float *A, const int *lda, size_t)
     * }
     */
    public static void slaset_(MemorySegment uplo, MemorySegment m, MemorySegment n, MemorySegment alpha, MemorySegment beta, MemorySegment A, MemorySegment lda, long x7) {
        var mh$ = slaset_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("slaset_", uplo, m, n, alpha, beta, A, lda, x7);
            }
            mh$.invokeExact(uplo, m, n, alpha, beta, A, lda, x7);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zlaset_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("zlaset_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zlaset_(const char *uplo, const int *m, const int *n, const _Complex double *alpha, const _Complex double *beta, _Complex double *A, const int *lda, size_t)
     * }
     */
    public static FunctionDescriptor zlaset_$descriptor() {
        return zlaset_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zlaset_(const char *uplo, const int *m, const int *n, const _Complex double *alpha, const _Complex double *beta, _Complex double *A, const int *lda, size_t)
     * }
     */
    public static MethodHandle zlaset_$handle() {
        return zlaset_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zlaset_(const char *uplo, const int *m, const int *n, const _Complex double *alpha, const _Complex double *beta, _Complex double *A, const int *lda, size_t)
     * }
     */
    public static MemorySegment zlaset_$address() {
        return zlaset_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zlaset_(const char *uplo, const int *m, const int *n, const _Complex double *alpha, const _Complex double *beta, _Complex double *A, const int *lda, size_t)
     * }
     */
    public static void zlaset_(MemorySegment uplo, MemorySegment m, MemorySegment n, MemorySegment alpha, MemorySegment beta, MemorySegment A, MemorySegment lda, long x7) {
        var mh$ = zlaset_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zlaset_", uplo, m, n, alpha, beta, A, lda, x7);
            }
            mh$.invokeExact(uplo, m, n, alpha, beta, A, lda, x7);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dlasrt_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("dlasrt_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dlasrt_(const char *id, const int *n, double *D, int *info, size_t)
     * }
     */
    public static FunctionDescriptor dlasrt_$descriptor() {
        return dlasrt_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dlasrt_(const char *id, const int *n, double *D, int *info, size_t)
     * }
     */
    public static MethodHandle dlasrt_$handle() {
        return dlasrt_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dlasrt_(const char *id, const int *n, double *D, int *info, size_t)
     * }
     */
    public static MemorySegment dlasrt_$address() {
        return dlasrt_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dlasrt_(const char *id, const int *n, double *D, int *info, size_t)
     * }
     */
    public static void dlasrt_(MemorySegment id, MemorySegment n, MemorySegment D, MemorySegment info, long x4) {
        var mh$ = dlasrt_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dlasrt_", id, n, D, info, x4);
            }
            mh$.invokeExact(id, n, D, info, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class slasrt_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("slasrt_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void slasrt_(const char *id, const int *n, float *D, int *info, size_t)
     * }
     */
    public static FunctionDescriptor slasrt_$descriptor() {
        return slasrt_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void slasrt_(const char *id, const int *n, float *D, int *info, size_t)
     * }
     */
    public static MethodHandle slasrt_$handle() {
        return slasrt_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void slasrt_(const char *id, const int *n, float *D, int *info, size_t)
     * }
     */
    public static MemorySegment slasrt_$address() {
        return slasrt_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void slasrt_(const char *id, const int *n, float *D, int *info, size_t)
     * }
     */
    public static void slasrt_(MemorySegment id, MemorySegment n, MemorySegment D, MemorySegment info, long x4) {
        var mh$ = slasrt_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("slasrt_", id, n, D, info, x4);
            }
            mh$.invokeExact(id, n, D, info, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class classq_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("classq_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void classq_(const int *n, const _Complex float *X, const int *incx, float *scale, float *sumsq)
     * }
     */
    public static FunctionDescriptor classq_$descriptor() {
        return classq_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void classq_(const int *n, const _Complex float *X, const int *incx, float *scale, float *sumsq)
     * }
     */
    public static MethodHandle classq_$handle() {
        return classq_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void classq_(const int *n, const _Complex float *X, const int *incx, float *scale, float *sumsq)
     * }
     */
    public static MemorySegment classq_$address() {
        return classq_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void classq_(const int *n, const _Complex float *X, const int *incx, float *scale, float *sumsq)
     * }
     */
    public static void classq_(MemorySegment n, MemorySegment X, MemorySegment incx, MemorySegment scale, MemorySegment sumsq) {
        var mh$ = classq_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("classq_", n, X, incx, scale, sumsq);
            }
            mh$.invokeExact(n, X, incx, scale, sumsq);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dlassq_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("dlassq_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dlassq_(const int *n, const double *X, const int *incx, double *scale, double *sumsq)
     * }
     */
    public static FunctionDescriptor dlassq_$descriptor() {
        return dlassq_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dlassq_(const int *n, const double *X, const int *incx, double *scale, double *sumsq)
     * }
     */
    public static MethodHandle dlassq_$handle() {
        return dlassq_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dlassq_(const int *n, const double *X, const int *incx, double *scale, double *sumsq)
     * }
     */
    public static MemorySegment dlassq_$address() {
        return dlassq_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dlassq_(const int *n, const double *X, const int *incx, double *scale, double *sumsq)
     * }
     */
    public static void dlassq_(MemorySegment n, MemorySegment X, MemorySegment incx, MemorySegment scale, MemorySegment sumsq) {
        var mh$ = dlassq_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dlassq_", n, X, incx, scale, sumsq);
            }
            mh$.invokeExact(n, X, incx, scale, sumsq);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class slassq_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("slassq_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void slassq_(const int *n, const float *X, const int *incx, float *scale, float *sumsq)
     * }
     */
    public static FunctionDescriptor slassq_$descriptor() {
        return slassq_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void slassq_(const int *n, const float *X, const int *incx, float *scale, float *sumsq)
     * }
     */
    public static MethodHandle slassq_$handle() {
        return slassq_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void slassq_(const int *n, const float *X, const int *incx, float *scale, float *sumsq)
     * }
     */
    public static MemorySegment slassq_$address() {
        return slassq_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void slassq_(const int *n, const float *X, const int *incx, float *scale, float *sumsq)
     * }
     */
    public static void slassq_(MemorySegment n, MemorySegment X, MemorySegment incx, MemorySegment scale, MemorySegment sumsq) {
        var mh$ = slassq_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("slassq_", n, X, incx, scale, sumsq);
            }
            mh$.invokeExact(n, X, incx, scale, sumsq);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zlassq_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("zlassq_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zlassq_(const int *n, const _Complex double *X, const int *incx, double *scale, double *sumsq)
     * }
     */
    public static FunctionDescriptor zlassq_$descriptor() {
        return zlassq_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zlassq_(const int *n, const _Complex double *X, const int *incx, double *scale, double *sumsq)
     * }
     */
    public static MethodHandle zlassq_$handle() {
        return zlassq_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zlassq_(const int *n, const _Complex double *X, const int *incx, double *scale, double *sumsq)
     * }
     */
    public static MemorySegment zlassq_$address() {
        return zlassq_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zlassq_(const int *n, const _Complex double *X, const int *incx, double *scale, double *sumsq)
     * }
     */
    public static void zlassq_(MemorySegment n, MemorySegment X, MemorySegment incx, MemorySegment scale, MemorySegment sumsq) {
        var mh$ = zlassq_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zlassq_", n, X, incx, scale, sumsq);
            }
            mh$.invokeExact(n, X, incx, scale, sumsq);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class claswp_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("claswp_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void claswp_(const int *n, _Complex float *A, const int *lda, const int *k1, const int *k2, const int *ipiv, const int *incx)
     * }
     */
    public static FunctionDescriptor claswp_$descriptor() {
        return claswp_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void claswp_(const int *n, _Complex float *A, const int *lda, const int *k1, const int *k2, const int *ipiv, const int *incx)
     * }
     */
    public static MethodHandle claswp_$handle() {
        return claswp_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void claswp_(const int *n, _Complex float *A, const int *lda, const int *k1, const int *k2, const int *ipiv, const int *incx)
     * }
     */
    public static MemorySegment claswp_$address() {
        return claswp_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void claswp_(const int *n, _Complex float *A, const int *lda, const int *k1, const int *k2, const int *ipiv, const int *incx)
     * }
     */
    public static void claswp_(MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment k1, MemorySegment k2, MemorySegment ipiv, MemorySegment incx) {
        var mh$ = claswp_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("claswp_", n, A, lda, k1, k2, ipiv, incx);
            }
            mh$.invokeExact(n, A, lda, k1, k2, ipiv, incx);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dlaswp_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("dlaswp_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dlaswp_(const int *n, double *A, const int *lda, const int *k1, const int *k2, const int *ipiv, const int *incx)
     * }
     */
    public static FunctionDescriptor dlaswp_$descriptor() {
        return dlaswp_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dlaswp_(const int *n, double *A, const int *lda, const int *k1, const int *k2, const int *ipiv, const int *incx)
     * }
     */
    public static MethodHandle dlaswp_$handle() {
        return dlaswp_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dlaswp_(const int *n, double *A, const int *lda, const int *k1, const int *k2, const int *ipiv, const int *incx)
     * }
     */
    public static MemorySegment dlaswp_$address() {
        return dlaswp_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dlaswp_(const int *n, double *A, const int *lda, const int *k1, const int *k2, const int *ipiv, const int *incx)
     * }
     */
    public static void dlaswp_(MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment k1, MemorySegment k2, MemorySegment ipiv, MemorySegment incx) {
        var mh$ = dlaswp_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dlaswp_", n, A, lda, k1, k2, ipiv, incx);
            }
            mh$.invokeExact(n, A, lda, k1, k2, ipiv, incx);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class slaswp_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("slaswp_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void slaswp_(const int *n, float *A, const int *lda, const int *k1, const int *k2, const int *ipiv, const int *incx)
     * }
     */
    public static FunctionDescriptor slaswp_$descriptor() {
        return slaswp_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void slaswp_(const int *n, float *A, const int *lda, const int *k1, const int *k2, const int *ipiv, const int *incx)
     * }
     */
    public static MethodHandle slaswp_$handle() {
        return slaswp_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void slaswp_(const int *n, float *A, const int *lda, const int *k1, const int *k2, const int *ipiv, const int *incx)
     * }
     */
    public static MemorySegment slaswp_$address() {
        return slaswp_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void slaswp_(const int *n, float *A, const int *lda, const int *k1, const int *k2, const int *ipiv, const int *incx)
     * }
     */
    public static void slaswp_(MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment k1, MemorySegment k2, MemorySegment ipiv, MemorySegment incx) {
        var mh$ = slaswp_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("slaswp_", n, A, lda, k1, k2, ipiv, incx);
            }
            mh$.invokeExact(n, A, lda, k1, k2, ipiv, incx);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zlaswp_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("zlaswp_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zlaswp_(const int *n, _Complex double *A, const int *lda, const int *k1, const int *k2, const int *ipiv, const int *incx)
     * }
     */
    public static FunctionDescriptor zlaswp_$descriptor() {
        return zlaswp_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zlaswp_(const int *n, _Complex double *A, const int *lda, const int *k1, const int *k2, const int *ipiv, const int *incx)
     * }
     */
    public static MethodHandle zlaswp_$handle() {
        return zlaswp_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zlaswp_(const int *n, _Complex double *A, const int *lda, const int *k1, const int *k2, const int *ipiv, const int *incx)
     * }
     */
    public static MemorySegment zlaswp_$address() {
        return zlaswp_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zlaswp_(const int *n, _Complex double *A, const int *lda, const int *k1, const int *k2, const int *ipiv, const int *incx)
     * }
     */
    public static void zlaswp_(MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment k1, MemorySegment k2, MemorySegment ipiv, MemorySegment incx) {
        var mh$ = zlaswp_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zlaswp_", n, A, lda, k1, k2, ipiv, incx);
            }
            mh$.invokeExact(n, A, lda, k1, k2, ipiv, incx);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clatms_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("clatms_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void clatms_(const int *m, const int *n, const char *dist, int *iseed, const char *sym, float *D, const int *mode, const float *cond, const float *dmax, const int *kl, const int *ku, const char *pack, _Complex float *A, const int *lda, _Complex float *work, int *info, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor clatms_$descriptor() {
        return clatms_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void clatms_(const int *m, const int *n, const char *dist, int *iseed, const char *sym, float *D, const int *mode, const float *cond, const float *dmax, const int *kl, const int *ku, const char *pack, _Complex float *A, const int *lda, _Complex float *work, int *info, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle clatms_$handle() {
        return clatms_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void clatms_(const int *m, const int *n, const char *dist, int *iseed, const char *sym, float *D, const int *mode, const float *cond, const float *dmax, const int *kl, const int *ku, const char *pack, _Complex float *A, const int *lda, _Complex float *work, int *info, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment clatms_$address() {
        return clatms_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void clatms_(const int *m, const int *n, const char *dist, int *iseed, const char *sym, float *D, const int *mode, const float *cond, const float *dmax, const int *kl, const int *ku, const char *pack, _Complex float *A, const int *lda, _Complex float *work, int *info, size_t, size_t, size_t)
     * }
     */
    public static void clatms_(MemorySegment m, MemorySegment n, MemorySegment dist, MemorySegment iseed, MemorySegment sym, MemorySegment D, MemorySegment mode, MemorySegment cond, MemorySegment dmax, MemorySegment kl, MemorySegment ku, MemorySegment pack, MemorySegment A, MemorySegment lda, MemorySegment work, MemorySegment info, long x16, long x17, long x18) {
        var mh$ = clatms_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clatms_", m, n, dist, iseed, sym, D, mode, cond, dmax, kl, ku, pack, A, lda, work, info, x16, x17, x18);
            }
            mh$.invokeExact(m, n, dist, iseed, sym, D, mode, cond, dmax, kl, ku, pack, A, lda, work, info, x16, x17, x18);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dlatms_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("dlatms_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dlatms_(const int *m, const int *n, const char *dist, int *iseed, const char *sym, double *D, const int *mode, const double *cond, const double *dmax, const int *kl, const int *ku, const char *pack, double *A, const int *lda, double *work, int *info, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor dlatms_$descriptor() {
        return dlatms_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dlatms_(const int *m, const int *n, const char *dist, int *iseed, const char *sym, double *D, const int *mode, const double *cond, const double *dmax, const int *kl, const int *ku, const char *pack, double *A, const int *lda, double *work, int *info, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle dlatms_$handle() {
        return dlatms_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dlatms_(const int *m, const int *n, const char *dist, int *iseed, const char *sym, double *D, const int *mode, const double *cond, const double *dmax, const int *kl, const int *ku, const char *pack, double *A, const int *lda, double *work, int *info, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment dlatms_$address() {
        return dlatms_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dlatms_(const int *m, const int *n, const char *dist, int *iseed, const char *sym, double *D, const int *mode, const double *cond, const double *dmax, const int *kl, const int *ku, const char *pack, double *A, const int *lda, double *work, int *info, size_t, size_t, size_t)
     * }
     */
    public static void dlatms_(MemorySegment m, MemorySegment n, MemorySegment dist, MemorySegment iseed, MemorySegment sym, MemorySegment D, MemorySegment mode, MemorySegment cond, MemorySegment dmax, MemorySegment kl, MemorySegment ku, MemorySegment pack, MemorySegment A, MemorySegment lda, MemorySegment work, MemorySegment info, long x16, long x17, long x18) {
        var mh$ = dlatms_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dlatms_", m, n, dist, iseed, sym, D, mode, cond, dmax, kl, ku, pack, A, lda, work, info, x16, x17, x18);
            }
            mh$.invokeExact(m, n, dist, iseed, sym, D, mode, cond, dmax, kl, ku, pack, A, lda, work, info, x16, x17, x18);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class slatms_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("slatms_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void slatms_(const int *m, const int *n, const char *dist, int *iseed, const char *sym, float *D, const int *mode, const float *cond, const float *dmax, const int *kl, const int *ku, const char *pack, float *A, const int *lda, float *work, int *info, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor slatms_$descriptor() {
        return slatms_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void slatms_(const int *m, const int *n, const char *dist, int *iseed, const char *sym, float *D, const int *mode, const float *cond, const float *dmax, const int *kl, const int *ku, const char *pack, float *A, const int *lda, float *work, int *info, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle slatms_$handle() {
        return slatms_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void slatms_(const int *m, const int *n, const char *dist, int *iseed, const char *sym, float *D, const int *mode, const float *cond, const float *dmax, const int *kl, const int *ku, const char *pack, float *A, const int *lda, float *work, int *info, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment slatms_$address() {
        return slatms_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void slatms_(const int *m, const int *n, const char *dist, int *iseed, const char *sym, float *D, const int *mode, const float *cond, const float *dmax, const int *kl, const int *ku, const char *pack, float *A, const int *lda, float *work, int *info, size_t, size_t, size_t)
     * }
     */
    public static void slatms_(MemorySegment m, MemorySegment n, MemorySegment dist, MemorySegment iseed, MemorySegment sym, MemorySegment D, MemorySegment mode, MemorySegment cond, MemorySegment dmax, MemorySegment kl, MemorySegment ku, MemorySegment pack, MemorySegment A, MemorySegment lda, MemorySegment work, MemorySegment info, long x16, long x17, long x18) {
        var mh$ = slatms_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("slatms_", m, n, dist, iseed, sym, D, mode, cond, dmax, kl, ku, pack, A, lda, work, info, x16, x17, x18);
            }
            mh$.invokeExact(m, n, dist, iseed, sym, D, mode, cond, dmax, kl, ku, pack, A, lda, work, info, x16, x17, x18);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zlatms_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("zlatms_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zlatms_(const int *m, const int *n, const char *dist, int *iseed, const char *sym, double *D, const int *mode, const double *cond, const double *dmax, const int *kl, const int *ku, const char *pack, _Complex double *A, const int *lda, _Complex double *work, int *info, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor zlatms_$descriptor() {
        return zlatms_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zlatms_(const int *m, const int *n, const char *dist, int *iseed, const char *sym, double *D, const int *mode, const double *cond, const double *dmax, const int *kl, const int *ku, const char *pack, _Complex double *A, const int *lda, _Complex double *work, int *info, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle zlatms_$handle() {
        return zlatms_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zlatms_(const int *m, const int *n, const char *dist, int *iseed, const char *sym, double *D, const int *mode, const double *cond, const double *dmax, const int *kl, const int *ku, const char *pack, _Complex double *A, const int *lda, _Complex double *work, int *info, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment zlatms_$address() {
        return zlatms_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zlatms_(const int *m, const int *n, const char *dist, int *iseed, const char *sym, double *D, const int *mode, const double *cond, const double *dmax, const int *kl, const int *ku, const char *pack, _Complex double *A, const int *lda, _Complex double *work, int *info, size_t, size_t, size_t)
     * }
     */
    public static void zlatms_(MemorySegment m, MemorySegment n, MemorySegment dist, MemorySegment iseed, MemorySegment sym, MemorySegment D, MemorySegment mode, MemorySegment cond, MemorySegment dmax, MemorySegment kl, MemorySegment ku, MemorySegment pack, MemorySegment A, MemorySegment lda, MemorySegment work, MemorySegment info, long x16, long x17, long x18) {
        var mh$ = zlatms_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zlatms_", m, n, dist, iseed, sym, D, mode, cond, dmax, kl, ku, pack, A, lda, work, info, x16, x17, x18);
            }
            mh$.invokeExact(m, n, dist, iseed, sym, D, mode, cond, dmax, kl, ku, pack, A, lda, work, info, x16, x17, x18);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clauum_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("clauum_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void clauum_(const char *uplo, const int *n, _Complex float *A, const int *lda, int *info, size_t)
     * }
     */
    public static FunctionDescriptor clauum_$descriptor() {
        return clauum_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void clauum_(const char *uplo, const int *n, _Complex float *A, const int *lda, int *info, size_t)
     * }
     */
    public static MethodHandle clauum_$handle() {
        return clauum_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void clauum_(const char *uplo, const int *n, _Complex float *A, const int *lda, int *info, size_t)
     * }
     */
    public static MemorySegment clauum_$address() {
        return clauum_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void clauum_(const char *uplo, const int *n, _Complex float *A, const int *lda, int *info, size_t)
     * }
     */
    public static void clauum_(MemorySegment uplo, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment info, long x5) {
        var mh$ = clauum_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clauum_", uplo, n, A, lda, info, x5);
            }
            mh$.invokeExact(uplo, n, A, lda, info, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dlauum_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("dlauum_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dlauum_(const char *uplo, const int *n, double *A, const int *lda, int *info, size_t)
     * }
     */
    public static FunctionDescriptor dlauum_$descriptor() {
        return dlauum_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dlauum_(const char *uplo, const int *n, double *A, const int *lda, int *info, size_t)
     * }
     */
    public static MethodHandle dlauum_$handle() {
        return dlauum_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dlauum_(const char *uplo, const int *n, double *A, const int *lda, int *info, size_t)
     * }
     */
    public static MemorySegment dlauum_$address() {
        return dlauum_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dlauum_(const char *uplo, const int *n, double *A, const int *lda, int *info, size_t)
     * }
     */
    public static void dlauum_(MemorySegment uplo, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment info, long x5) {
        var mh$ = dlauum_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dlauum_", uplo, n, A, lda, info, x5);
            }
            mh$.invokeExact(uplo, n, A, lda, info, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class slauum_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("slauum_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void slauum_(const char *uplo, const int *n, float *A, const int *lda, int *info, size_t)
     * }
     */
    public static FunctionDescriptor slauum_$descriptor() {
        return slauum_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void slauum_(const char *uplo, const int *n, float *A, const int *lda, int *info, size_t)
     * }
     */
    public static MethodHandle slauum_$handle() {
        return slauum_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void slauum_(const char *uplo, const int *n, float *A, const int *lda, int *info, size_t)
     * }
     */
    public static MemorySegment slauum_$address() {
        return slauum_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void slauum_(const char *uplo, const int *n, float *A, const int *lda, int *info, size_t)
     * }
     */
    public static void slauum_(MemorySegment uplo, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment info, long x5) {
        var mh$ = slauum_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("slauum_", uplo, n, A, lda, info, x5);
            }
            mh$.invokeExact(uplo, n, A, lda, info, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zlauum_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("zlauum_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zlauum_(const char *uplo, const int *n, _Complex double *A, const int *lda, int *info, size_t)
     * }
     */
    public static FunctionDescriptor zlauum_$descriptor() {
        return zlauum_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zlauum_(const char *uplo, const int *n, _Complex double *A, const int *lda, int *info, size_t)
     * }
     */
    public static MethodHandle zlauum_$handle() {
        return zlauum_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zlauum_(const char *uplo, const int *n, _Complex double *A, const int *lda, int *info, size_t)
     * }
     */
    public static MemorySegment zlauum_$address() {
        return zlauum_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zlauum_(const char *uplo, const int *n, _Complex double *A, const int *lda, int *info, size_t)
     * }
     */
    public static void zlauum_(MemorySegment uplo, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment info, long x5) {
        var mh$ = zlauum_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zlauum_", uplo, n, A, lda, info, x5);
            }
            mh$.invokeExact(uplo, n, A, lda, info, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ilaver_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("ilaver_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ilaver_(int *vers_major, int *vers_minor, int *vers_patch)
     * }
     */
    public static FunctionDescriptor ilaver_$descriptor() {
        return ilaver_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ilaver_(int *vers_major, int *vers_minor, int *vers_patch)
     * }
     */
    public static MethodHandle ilaver_$handle() {
        return ilaver_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ilaver_(int *vers_major, int *vers_minor, int *vers_patch)
     * }
     */
    public static MemorySegment ilaver_$address() {
        return ilaver_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ilaver_(int *vers_major, int *vers_minor, int *vers_patch)
     * }
     */
    public static void ilaver_(MemorySegment vers_major, MemorySegment vers_minor, MemorySegment vers_patch) {
        var mh$ = ilaver_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ilaver_", vers_major, vers_minor, vers_patch);
            }
            mh$.invokeExact(vers_major, vers_minor, vers_patch);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dopgtr_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("dopgtr_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dopgtr_(const char *uplo, const int *n, const double *AP, const double *tau, double *Q, const int *ldq, double *work, int *info, size_t)
     * }
     */
    public static FunctionDescriptor dopgtr_$descriptor() {
        return dopgtr_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dopgtr_(const char *uplo, const int *n, const double *AP, const double *tau, double *Q, const int *ldq, double *work, int *info, size_t)
     * }
     */
    public static MethodHandle dopgtr_$handle() {
        return dopgtr_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dopgtr_(const char *uplo, const int *n, const double *AP, const double *tau, double *Q, const int *ldq, double *work, int *info, size_t)
     * }
     */
    public static MemorySegment dopgtr_$address() {
        return dopgtr_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dopgtr_(const char *uplo, const int *n, const double *AP, const double *tau, double *Q, const int *ldq, double *work, int *info, size_t)
     * }
     */
    public static void dopgtr_(MemorySegment uplo, MemorySegment n, MemorySegment AP, MemorySegment tau, MemorySegment Q, MemorySegment ldq, MemorySegment work, MemorySegment info, long x8) {
        var mh$ = dopgtr_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dopgtr_", uplo, n, AP, tau, Q, ldq, work, info, x8);
            }
            mh$.invokeExact(uplo, n, AP, tau, Q, ldq, work, info, x8);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sopgtr_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("sopgtr_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void sopgtr_(const char *uplo, const int *n, const float *AP, const float *tau, float *Q, const int *ldq, float *work, int *info, size_t)
     * }
     */
    public static FunctionDescriptor sopgtr_$descriptor() {
        return sopgtr_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void sopgtr_(const char *uplo, const int *n, const float *AP, const float *tau, float *Q, const int *ldq, float *work, int *info, size_t)
     * }
     */
    public static MethodHandle sopgtr_$handle() {
        return sopgtr_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void sopgtr_(const char *uplo, const int *n, const float *AP, const float *tau, float *Q, const int *ldq, float *work, int *info, size_t)
     * }
     */
    public static MemorySegment sopgtr_$address() {
        return sopgtr_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void sopgtr_(const char *uplo, const int *n, const float *AP, const float *tau, float *Q, const int *ldq, float *work, int *info, size_t)
     * }
     */
    public static void sopgtr_(MemorySegment uplo, MemorySegment n, MemorySegment AP, MemorySegment tau, MemorySegment Q, MemorySegment ldq, MemorySegment work, MemorySegment info, long x8) {
        var mh$ = sopgtr_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sopgtr_", uplo, n, AP, tau, Q, ldq, work, info, x8);
            }
            mh$.invokeExact(uplo, n, AP, tau, Q, ldq, work, info, x8);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dopmtr_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("dopmtr_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dopmtr_(const char *side, const char *uplo, const char *trans, const int *m, const int *n, const double *AP, const double *tau, double *C, const int *ldc, double *work, int *info, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor dopmtr_$descriptor() {
        return dopmtr_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dopmtr_(const char *side, const char *uplo, const char *trans, const int *m, const int *n, const double *AP, const double *tau, double *C, const int *ldc, double *work, int *info, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle dopmtr_$handle() {
        return dopmtr_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dopmtr_(const char *side, const char *uplo, const char *trans, const int *m, const int *n, const double *AP, const double *tau, double *C, const int *ldc, double *work, int *info, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment dopmtr_$address() {
        return dopmtr_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dopmtr_(const char *side, const char *uplo, const char *trans, const int *m, const int *n, const double *AP, const double *tau, double *C, const int *ldc, double *work, int *info, size_t, size_t, size_t)
     * }
     */
    public static void dopmtr_(MemorySegment side, MemorySegment uplo, MemorySegment trans, MemorySegment m, MemorySegment n, MemorySegment AP, MemorySegment tau, MemorySegment C, MemorySegment ldc, MemorySegment work, MemorySegment info, long x11, long x12, long x13) {
        var mh$ = dopmtr_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dopmtr_", side, uplo, trans, m, n, AP, tau, C, ldc, work, info, x11, x12, x13);
            }
            mh$.invokeExact(side, uplo, trans, m, n, AP, tau, C, ldc, work, info, x11, x12, x13);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sopmtr_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("sopmtr_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void sopmtr_(const char *side, const char *uplo, const char *trans, const int *m, const int *n, const float *AP, const float *tau, float *C, const int *ldc, float *work, int *info, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor sopmtr_$descriptor() {
        return sopmtr_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void sopmtr_(const char *side, const char *uplo, const char *trans, const int *m, const int *n, const float *AP, const float *tau, float *C, const int *ldc, float *work, int *info, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle sopmtr_$handle() {
        return sopmtr_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void sopmtr_(const char *side, const char *uplo, const char *trans, const int *m, const int *n, const float *AP, const float *tau, float *C, const int *ldc, float *work, int *info, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment sopmtr_$address() {
        return sopmtr_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void sopmtr_(const char *side, const char *uplo, const char *trans, const int *m, const int *n, const float *AP, const float *tau, float *C, const int *ldc, float *work, int *info, size_t, size_t, size_t)
     * }
     */
    public static void sopmtr_(MemorySegment side, MemorySegment uplo, MemorySegment trans, MemorySegment m, MemorySegment n, MemorySegment AP, MemorySegment tau, MemorySegment C, MemorySegment ldc, MemorySegment work, MemorySegment info, long x11, long x12, long x13) {
        var mh$ = sopmtr_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sopmtr_", side, uplo, trans, m, n, AP, tau, C, ldc, work, info, x11, x12, x13);
            }
            mh$.invokeExact(side, uplo, trans, m, n, AP, tau, C, ldc, work, info, x11, x12, x13);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dorbdb_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("dorbdb_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dorbdb_(const char *trans, const char *signs, const int *m, const int *p, const int *q, double *X11, const int *ldx11, double *X12, const int *ldx12, double *X21, const int *ldx21, double *X22, const int *ldx22, double *theta, double *phi, double *TAUP1, double *TAUP2, double *TAUQ1, double *TAUQ2, double *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor dorbdb_$descriptor() {
        return dorbdb_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dorbdb_(const char *trans, const char *signs, const int *m, const int *p, const int *q, double *X11, const int *ldx11, double *X12, const int *ldx12, double *X21, const int *ldx21, double *X22, const int *ldx22, double *theta, double *phi, double *TAUP1, double *TAUP2, double *TAUQ1, double *TAUQ2, double *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle dorbdb_$handle() {
        return dorbdb_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dorbdb_(const char *trans, const char *signs, const int *m, const int *p, const int *q, double *X11, const int *ldx11, double *X12, const int *ldx12, double *X21, const int *ldx21, double *X22, const int *ldx22, double *theta, double *phi, double *TAUP1, double *TAUP2, double *TAUQ1, double *TAUQ2, double *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment dorbdb_$address() {
        return dorbdb_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dorbdb_(const char *trans, const char *signs, const int *m, const int *p, const int *q, double *X11, const int *ldx11, double *X12, const int *ldx12, double *X21, const int *ldx21, double *X22, const int *ldx22, double *theta, double *phi, double *TAUP1, double *TAUP2, double *TAUQ1, double *TAUQ2, double *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static void dorbdb_(MemorySegment trans, MemorySegment signs, MemorySegment m, MemorySegment p, MemorySegment q, MemorySegment X11, MemorySegment ldx11, MemorySegment X12, MemorySegment ldx12, MemorySegment X21, MemorySegment ldx21, MemorySegment X22, MemorySegment ldx22, MemorySegment theta, MemorySegment phi, MemorySegment TAUP1, MemorySegment TAUP2, MemorySegment TAUQ1, MemorySegment TAUQ2, MemorySegment work, MemorySegment lwork, MemorySegment info, long x22, long x23) {
        var mh$ = dorbdb_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dorbdb_", trans, signs, m, p, q, X11, ldx11, X12, ldx12, X21, ldx21, X22, ldx22, theta, phi, TAUP1, TAUP2, TAUQ1, TAUQ2, work, lwork, info, x22, x23);
            }
            mh$.invokeExact(trans, signs, m, p, q, X11, ldx11, X12, ldx12, X21, ldx21, X22, ldx22, theta, phi, TAUP1, TAUP2, TAUQ1, TAUQ2, work, lwork, info, x22, x23);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sorbdb_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("sorbdb_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void sorbdb_(const char *trans, const char *signs, const int *m, const int *p, const int *q, float *X11, const int *ldx11, float *X12, const int *ldx12, float *X21, const int *ldx21, float *X22, const int *ldx22, float *theta, float *phi, float *TAUP1, float *TAUP2, float *TAUQ1, float *TAUQ2, float *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor sorbdb_$descriptor() {
        return sorbdb_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void sorbdb_(const char *trans, const char *signs, const int *m, const int *p, const int *q, float *X11, const int *ldx11, float *X12, const int *ldx12, float *X21, const int *ldx21, float *X22, const int *ldx22, float *theta, float *phi, float *TAUP1, float *TAUP2, float *TAUQ1, float *TAUQ2, float *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle sorbdb_$handle() {
        return sorbdb_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void sorbdb_(const char *trans, const char *signs, const int *m, const int *p, const int *q, float *X11, const int *ldx11, float *X12, const int *ldx12, float *X21, const int *ldx21, float *X22, const int *ldx22, float *theta, float *phi, float *TAUP1, float *TAUP2, float *TAUQ1, float *TAUQ2, float *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment sorbdb_$address() {
        return sorbdb_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void sorbdb_(const char *trans, const char *signs, const int *m, const int *p, const int *q, float *X11, const int *ldx11, float *X12, const int *ldx12, float *X21, const int *ldx21, float *X22, const int *ldx22, float *theta, float *phi, float *TAUP1, float *TAUP2, float *TAUQ1, float *TAUQ2, float *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static void sorbdb_(MemorySegment trans, MemorySegment signs, MemorySegment m, MemorySegment p, MemorySegment q, MemorySegment X11, MemorySegment ldx11, MemorySegment X12, MemorySegment ldx12, MemorySegment X21, MemorySegment ldx21, MemorySegment X22, MemorySegment ldx22, MemorySegment theta, MemorySegment phi, MemorySegment TAUP1, MemorySegment TAUP2, MemorySegment TAUQ1, MemorySegment TAUQ2, MemorySegment work, MemorySegment lwork, MemorySegment info, long x22, long x23) {
        var mh$ = sorbdb_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sorbdb_", trans, signs, m, p, q, X11, ldx11, X12, ldx12, X21, ldx21, X22, ldx22, theta, phi, TAUP1, TAUP2, TAUQ1, TAUQ2, work, lwork, info, x22, x23);
            }
            mh$.invokeExact(trans, signs, m, p, q, X11, ldx11, X12, ldx12, X21, ldx21, X22, ldx22, theta, phi, TAUP1, TAUP2, TAUQ1, TAUQ2, work, lwork, info, x22, x23);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dorcsd_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("dorcsd_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dorcsd_(const char *jobu1, const char *jobu2, const char *jobv1t, const char *jobv2t, const char *trans, const char *signs, const int *m, const int *p, const int *q, double *X11, const int *ldx11, double *X12, const int *ldx12, double *X21, const int *ldx21, double *X22, const int *ldx22, double *theta, double *U1, const int *ldu1, double *U2, const int *ldu2, double *V1T, const int *ldv1t, double *V2T, const int *ldv2t, double *work, const int *lwork, int *iwork, int *info, size_t, size_t, size_t, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor dorcsd_$descriptor() {
        return dorcsd_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dorcsd_(const char *jobu1, const char *jobu2, const char *jobv1t, const char *jobv2t, const char *trans, const char *signs, const int *m, const int *p, const int *q, double *X11, const int *ldx11, double *X12, const int *ldx12, double *X21, const int *ldx21, double *X22, const int *ldx22, double *theta, double *U1, const int *ldu1, double *U2, const int *ldu2, double *V1T, const int *ldv1t, double *V2T, const int *ldv2t, double *work, const int *lwork, int *iwork, int *info, size_t, size_t, size_t, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle dorcsd_$handle() {
        return dorcsd_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dorcsd_(const char *jobu1, const char *jobu2, const char *jobv1t, const char *jobv2t, const char *trans, const char *signs, const int *m, const int *p, const int *q, double *X11, const int *ldx11, double *X12, const int *ldx12, double *X21, const int *ldx21, double *X22, const int *ldx22, double *theta, double *U1, const int *ldu1, double *U2, const int *ldu2, double *V1T, const int *ldv1t, double *V2T, const int *ldv2t, double *work, const int *lwork, int *iwork, int *info, size_t, size_t, size_t, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment dorcsd_$address() {
        return dorcsd_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dorcsd_(const char *jobu1, const char *jobu2, const char *jobv1t, const char *jobv2t, const char *trans, const char *signs, const int *m, const int *p, const int *q, double *X11, const int *ldx11, double *X12, const int *ldx12, double *X21, const int *ldx21, double *X22, const int *ldx22, double *theta, double *U1, const int *ldu1, double *U2, const int *ldu2, double *V1T, const int *ldv1t, double *V2T, const int *ldv2t, double *work, const int *lwork, int *iwork, int *info, size_t, size_t, size_t, size_t, size_t, size_t)
     * }
     */
    public static void dorcsd_(MemorySegment jobu1, MemorySegment jobu2, MemorySegment jobv1t, MemorySegment jobv2t, MemorySegment trans, MemorySegment signs, MemorySegment m, MemorySegment p, MemorySegment q, MemorySegment X11, MemorySegment ldx11, MemorySegment X12, MemorySegment ldx12, MemorySegment X21, MemorySegment ldx21, MemorySegment X22, MemorySegment ldx22, MemorySegment theta, MemorySegment U1, MemorySegment ldu1, MemorySegment U2, MemorySegment ldu2, MemorySegment V1T, MemorySegment ldv1t, MemorySegment V2T, MemorySegment ldv2t, MemorySegment work, MemorySegment lwork, MemorySegment iwork, MemorySegment info, long x30, long x31, long x32, long x33, long x34, long x35) {
        var mh$ = dorcsd_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dorcsd_", jobu1, jobu2, jobv1t, jobv2t, trans, signs, m, p, q, X11, ldx11, X12, ldx12, X21, ldx21, X22, ldx22, theta, U1, ldu1, U2, ldu2, V1T, ldv1t, V2T, ldv2t, work, lwork, iwork, info, x30, x31, x32, x33, x34, x35);
            }
            mh$.invokeExact(jobu1, jobu2, jobv1t, jobv2t, trans, signs, m, p, q, X11, ldx11, X12, ldx12, X21, ldx21, X22, ldx22, theta, U1, ldu1, U2, ldu2, V1T, ldv1t, V2T, ldv2t, work, lwork, iwork, info, x30, x31, x32, x33, x34, x35);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sorcsd_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("sorcsd_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void sorcsd_(const char *jobu1, const char *jobu2, const char *jobv1t, const char *jobv2t, const char *trans, const char *signs, const int *m, const int *p, const int *q, float *X11, const int *ldx11, float *X12, const int *ldx12, float *X21, const int *ldx21, float *X22, const int *ldx22, float *theta, float *U1, const int *ldu1, float *U2, const int *ldu2, float *V1T, const int *ldv1t, float *V2T, const int *ldv2t, float *work, const int *lwork, int *iwork, int *info, size_t, size_t, size_t, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor sorcsd_$descriptor() {
        return sorcsd_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void sorcsd_(const char *jobu1, const char *jobu2, const char *jobv1t, const char *jobv2t, const char *trans, const char *signs, const int *m, const int *p, const int *q, float *X11, const int *ldx11, float *X12, const int *ldx12, float *X21, const int *ldx21, float *X22, const int *ldx22, float *theta, float *U1, const int *ldu1, float *U2, const int *ldu2, float *V1T, const int *ldv1t, float *V2T, const int *ldv2t, float *work, const int *lwork, int *iwork, int *info, size_t, size_t, size_t, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle sorcsd_$handle() {
        return sorcsd_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void sorcsd_(const char *jobu1, const char *jobu2, const char *jobv1t, const char *jobv2t, const char *trans, const char *signs, const int *m, const int *p, const int *q, float *X11, const int *ldx11, float *X12, const int *ldx12, float *X21, const int *ldx21, float *X22, const int *ldx22, float *theta, float *U1, const int *ldu1, float *U2, const int *ldu2, float *V1T, const int *ldv1t, float *V2T, const int *ldv2t, float *work, const int *lwork, int *iwork, int *info, size_t, size_t, size_t, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment sorcsd_$address() {
        return sorcsd_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void sorcsd_(const char *jobu1, const char *jobu2, const char *jobv1t, const char *jobv2t, const char *trans, const char *signs, const int *m, const int *p, const int *q, float *X11, const int *ldx11, float *X12, const int *ldx12, float *X21, const int *ldx21, float *X22, const int *ldx22, float *theta, float *U1, const int *ldu1, float *U2, const int *ldu2, float *V1T, const int *ldv1t, float *V2T, const int *ldv2t, float *work, const int *lwork, int *iwork, int *info, size_t, size_t, size_t, size_t, size_t, size_t)
     * }
     */
    public static void sorcsd_(MemorySegment jobu1, MemorySegment jobu2, MemorySegment jobv1t, MemorySegment jobv2t, MemorySegment trans, MemorySegment signs, MemorySegment m, MemorySegment p, MemorySegment q, MemorySegment X11, MemorySegment ldx11, MemorySegment X12, MemorySegment ldx12, MemorySegment X21, MemorySegment ldx21, MemorySegment X22, MemorySegment ldx22, MemorySegment theta, MemorySegment U1, MemorySegment ldu1, MemorySegment U2, MemorySegment ldu2, MemorySegment V1T, MemorySegment ldv1t, MemorySegment V2T, MemorySegment ldv2t, MemorySegment work, MemorySegment lwork, MemorySegment iwork, MemorySegment info, long x30, long x31, long x32, long x33, long x34, long x35) {
        var mh$ = sorcsd_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sorcsd_", jobu1, jobu2, jobv1t, jobv2t, trans, signs, m, p, q, X11, ldx11, X12, ldx12, X21, ldx21, X22, ldx22, theta, U1, ldu1, U2, ldu2, V1T, ldv1t, V2T, ldv2t, work, lwork, iwork, info, x30, x31, x32, x33, x34, x35);
            }
            mh$.invokeExact(jobu1, jobu2, jobv1t, jobv2t, trans, signs, m, p, q, X11, ldx11, X12, ldx12, X21, ldx21, X22, ldx22, theta, U1, ldu1, U2, ldu2, V1T, ldv1t, V2T, ldv2t, work, lwork, iwork, info, x30, x31, x32, x33, x34, x35);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dorcsd2by1_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("dorcsd2by1_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dorcsd2by1_(const char *jobu1, const char *jobu2, const char *jobv1t, const int *m, const int *p, const int *q, double *X11, const int *ldx11, double *X21, const int *ldx21, double *theta, double *U1, const int *ldu1, double *U2, const int *ldu2, double *V1T, const int *ldv1t, double *work, const int *lwork, int *iwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor dorcsd2by1_$descriptor() {
        return dorcsd2by1_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dorcsd2by1_(const char *jobu1, const char *jobu2, const char *jobv1t, const int *m, const int *p, const int *q, double *X11, const int *ldx11, double *X21, const int *ldx21, double *theta, double *U1, const int *ldu1, double *U2, const int *ldu2, double *V1T, const int *ldv1t, double *work, const int *lwork, int *iwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle dorcsd2by1_$handle() {
        return dorcsd2by1_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dorcsd2by1_(const char *jobu1, const char *jobu2, const char *jobv1t, const int *m, const int *p, const int *q, double *X11, const int *ldx11, double *X21, const int *ldx21, double *theta, double *U1, const int *ldu1, double *U2, const int *ldu2, double *V1T, const int *ldv1t, double *work, const int *lwork, int *iwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment dorcsd2by1_$address() {
        return dorcsd2by1_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dorcsd2by1_(const char *jobu1, const char *jobu2, const char *jobv1t, const int *m, const int *p, const int *q, double *X11, const int *ldx11, double *X21, const int *ldx21, double *theta, double *U1, const int *ldu1, double *U2, const int *ldu2, double *V1T, const int *ldv1t, double *work, const int *lwork, int *iwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static void dorcsd2by1_(MemorySegment jobu1, MemorySegment jobu2, MemorySegment jobv1t, MemorySegment m, MemorySegment p, MemorySegment q, MemorySegment X11, MemorySegment ldx11, MemorySegment X21, MemorySegment ldx21, MemorySegment theta, MemorySegment U1, MemorySegment ldu1, MemorySegment U2, MemorySegment ldu2, MemorySegment V1T, MemorySegment ldv1t, MemorySegment work, MemorySegment lwork, MemorySegment iwork, MemorySegment info, long x21, long x22, long x23) {
        var mh$ = dorcsd2by1_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dorcsd2by1_", jobu1, jobu2, jobv1t, m, p, q, X11, ldx11, X21, ldx21, theta, U1, ldu1, U2, ldu2, V1T, ldv1t, work, lwork, iwork, info, x21, x22, x23);
            }
            mh$.invokeExact(jobu1, jobu2, jobv1t, m, p, q, X11, ldx11, X21, ldx21, theta, U1, ldu1, U2, ldu2, V1T, ldv1t, work, lwork, iwork, info, x21, x22, x23);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sorcsd2by1_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("sorcsd2by1_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void sorcsd2by1_(const char *jobu1, const char *jobu2, const char *jobv1t, const int *m, const int *p, const int *q, float *X11, const int *ldx11, float *X21, const int *ldx21, float *theta, float *U1, const int *ldu1, float *U2, const int *ldu2, float *V1T, const int *ldv1t, float *work, const int *lwork, int *iwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor sorcsd2by1_$descriptor() {
        return sorcsd2by1_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void sorcsd2by1_(const char *jobu1, const char *jobu2, const char *jobv1t, const int *m, const int *p, const int *q, float *X11, const int *ldx11, float *X21, const int *ldx21, float *theta, float *U1, const int *ldu1, float *U2, const int *ldu2, float *V1T, const int *ldv1t, float *work, const int *lwork, int *iwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle sorcsd2by1_$handle() {
        return sorcsd2by1_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void sorcsd2by1_(const char *jobu1, const char *jobu2, const char *jobv1t, const int *m, const int *p, const int *q, float *X11, const int *ldx11, float *X21, const int *ldx21, float *theta, float *U1, const int *ldu1, float *U2, const int *ldu2, float *V1T, const int *ldv1t, float *work, const int *lwork, int *iwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment sorcsd2by1_$address() {
        return sorcsd2by1_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void sorcsd2by1_(const char *jobu1, const char *jobu2, const char *jobv1t, const int *m, const int *p, const int *q, float *X11, const int *ldx11, float *X21, const int *ldx21, float *theta, float *U1, const int *ldu1, float *U2, const int *ldu2, float *V1T, const int *ldv1t, float *work, const int *lwork, int *iwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static void sorcsd2by1_(MemorySegment jobu1, MemorySegment jobu2, MemorySegment jobv1t, MemorySegment m, MemorySegment p, MemorySegment q, MemorySegment X11, MemorySegment ldx11, MemorySegment X21, MemorySegment ldx21, MemorySegment theta, MemorySegment U1, MemorySegment ldu1, MemorySegment U2, MemorySegment ldu2, MemorySegment V1T, MemorySegment ldv1t, MemorySegment work, MemorySegment lwork, MemorySegment iwork, MemorySegment info, long x21, long x22, long x23) {
        var mh$ = sorcsd2by1_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sorcsd2by1_", jobu1, jobu2, jobv1t, m, p, q, X11, ldx11, X21, ldx21, theta, U1, ldu1, U2, ldu2, V1T, ldv1t, work, lwork, iwork, info, x21, x22, x23);
            }
            mh$.invokeExact(jobu1, jobu2, jobv1t, m, p, q, X11, ldx11, X21, ldx21, theta, U1, ldu1, U2, ldu2, V1T, ldv1t, work, lwork, iwork, info, x21, x22, x23);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dorgbr_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("dorgbr_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dorgbr_(const char *vect, const int *m, const int *n, const int *k, double *A, const int *lda, const double *tau, double *work, const int *lwork, int *info, size_t)
     * }
     */
    public static FunctionDescriptor dorgbr_$descriptor() {
        return dorgbr_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dorgbr_(const char *vect, const int *m, const int *n, const int *k, double *A, const int *lda, const double *tau, double *work, const int *lwork, int *info, size_t)
     * }
     */
    public static MethodHandle dorgbr_$handle() {
        return dorgbr_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dorgbr_(const char *vect, const int *m, const int *n, const int *k, double *A, const int *lda, const double *tau, double *work, const int *lwork, int *info, size_t)
     * }
     */
    public static MemorySegment dorgbr_$address() {
        return dorgbr_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dorgbr_(const char *vect, const int *m, const int *n, const int *k, double *A, const int *lda, const double *tau, double *work, const int *lwork, int *info, size_t)
     * }
     */
    public static void dorgbr_(MemorySegment vect, MemorySegment m, MemorySegment n, MemorySegment k, MemorySegment A, MemorySegment lda, MemorySegment tau, MemorySegment work, MemorySegment lwork, MemorySegment info, long x10) {
        var mh$ = dorgbr_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dorgbr_", vect, m, n, k, A, lda, tau, work, lwork, info, x10);
            }
            mh$.invokeExact(vect, m, n, k, A, lda, tau, work, lwork, info, x10);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sorgbr_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("sorgbr_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void sorgbr_(const char *vect, const int *m, const int *n, const int *k, float *A, const int *lda, const float *tau, float *work, const int *lwork, int *info, size_t)
     * }
     */
    public static FunctionDescriptor sorgbr_$descriptor() {
        return sorgbr_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void sorgbr_(const char *vect, const int *m, const int *n, const int *k, float *A, const int *lda, const float *tau, float *work, const int *lwork, int *info, size_t)
     * }
     */
    public static MethodHandle sorgbr_$handle() {
        return sorgbr_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void sorgbr_(const char *vect, const int *m, const int *n, const int *k, float *A, const int *lda, const float *tau, float *work, const int *lwork, int *info, size_t)
     * }
     */
    public static MemorySegment sorgbr_$address() {
        return sorgbr_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void sorgbr_(const char *vect, const int *m, const int *n, const int *k, float *A, const int *lda, const float *tau, float *work, const int *lwork, int *info, size_t)
     * }
     */
    public static void sorgbr_(MemorySegment vect, MemorySegment m, MemorySegment n, MemorySegment k, MemorySegment A, MemorySegment lda, MemorySegment tau, MemorySegment work, MemorySegment lwork, MemorySegment info, long x10) {
        var mh$ = sorgbr_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sorgbr_", vect, m, n, k, A, lda, tau, work, lwork, info, x10);
            }
            mh$.invokeExact(vect, m, n, k, A, lda, tau, work, lwork, info, x10);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dorghr_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("dorghr_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dorghr_(const int *n, const int *ilo, const int *ihi, double *A, const int *lda, const double *tau, double *work, const int *lwork, int *info)
     * }
     */
    public static FunctionDescriptor dorghr_$descriptor() {
        return dorghr_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dorghr_(const int *n, const int *ilo, const int *ihi, double *A, const int *lda, const double *tau, double *work, const int *lwork, int *info)
     * }
     */
    public static MethodHandle dorghr_$handle() {
        return dorghr_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dorghr_(const int *n, const int *ilo, const int *ihi, double *A, const int *lda, const double *tau, double *work, const int *lwork, int *info)
     * }
     */
    public static MemorySegment dorghr_$address() {
        return dorghr_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dorghr_(const int *n, const int *ilo, const int *ihi, double *A, const int *lda, const double *tau, double *work, const int *lwork, int *info)
     * }
     */
    public static void dorghr_(MemorySegment n, MemorySegment ilo, MemorySegment ihi, MemorySegment A, MemorySegment lda, MemorySegment tau, MemorySegment work, MemorySegment lwork, MemorySegment info) {
        var mh$ = dorghr_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dorghr_", n, ilo, ihi, A, lda, tau, work, lwork, info);
            }
            mh$.invokeExact(n, ilo, ihi, A, lda, tau, work, lwork, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sorghr_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("sorghr_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void sorghr_(const int *n, const int *ilo, const int *ihi, float *A, const int *lda, const float *tau, float *work, const int *lwork, int *info)
     * }
     */
    public static FunctionDescriptor sorghr_$descriptor() {
        return sorghr_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void sorghr_(const int *n, const int *ilo, const int *ihi, float *A, const int *lda, const float *tau, float *work, const int *lwork, int *info)
     * }
     */
    public static MethodHandle sorghr_$handle() {
        return sorghr_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void sorghr_(const int *n, const int *ilo, const int *ihi, float *A, const int *lda, const float *tau, float *work, const int *lwork, int *info)
     * }
     */
    public static MemorySegment sorghr_$address() {
        return sorghr_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void sorghr_(const int *n, const int *ilo, const int *ihi, float *A, const int *lda, const float *tau, float *work, const int *lwork, int *info)
     * }
     */
    public static void sorghr_(MemorySegment n, MemorySegment ilo, MemorySegment ihi, MemorySegment A, MemorySegment lda, MemorySegment tau, MemorySegment work, MemorySegment lwork, MemorySegment info) {
        var mh$ = sorghr_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sorghr_", n, ilo, ihi, A, lda, tau, work, lwork, info);
            }
            mh$.invokeExact(n, ilo, ihi, A, lda, tau, work, lwork, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dorglq_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("dorglq_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dorglq_(const int *m, const int *n, const int *k, double *A, const int *lda, const double *tau, double *work, const int *lwork, int *info)
     * }
     */
    public static FunctionDescriptor dorglq_$descriptor() {
        return dorglq_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dorglq_(const int *m, const int *n, const int *k, double *A, const int *lda, const double *tau, double *work, const int *lwork, int *info)
     * }
     */
    public static MethodHandle dorglq_$handle() {
        return dorglq_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dorglq_(const int *m, const int *n, const int *k, double *A, const int *lda, const double *tau, double *work, const int *lwork, int *info)
     * }
     */
    public static MemorySegment dorglq_$address() {
        return dorglq_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dorglq_(const int *m, const int *n, const int *k, double *A, const int *lda, const double *tau, double *work, const int *lwork, int *info)
     * }
     */
    public static void dorglq_(MemorySegment m, MemorySegment n, MemorySegment k, MemorySegment A, MemorySegment lda, MemorySegment tau, MemorySegment work, MemorySegment lwork, MemorySegment info) {
        var mh$ = dorglq_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dorglq_", m, n, k, A, lda, tau, work, lwork, info);
            }
            mh$.invokeExact(m, n, k, A, lda, tau, work, lwork, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sorglq_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("sorglq_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void sorglq_(const int *m, const int *n, const int *k, float *A, const int *lda, const float *tau, float *work, const int *lwork, int *info)
     * }
     */
    public static FunctionDescriptor sorglq_$descriptor() {
        return sorglq_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void sorglq_(const int *m, const int *n, const int *k, float *A, const int *lda, const float *tau, float *work, const int *lwork, int *info)
     * }
     */
    public static MethodHandle sorglq_$handle() {
        return sorglq_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void sorglq_(const int *m, const int *n, const int *k, float *A, const int *lda, const float *tau, float *work, const int *lwork, int *info)
     * }
     */
    public static MemorySegment sorglq_$address() {
        return sorglq_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void sorglq_(const int *m, const int *n, const int *k, float *A, const int *lda, const float *tau, float *work, const int *lwork, int *info)
     * }
     */
    public static void sorglq_(MemorySegment m, MemorySegment n, MemorySegment k, MemorySegment A, MemorySegment lda, MemorySegment tau, MemorySegment work, MemorySegment lwork, MemorySegment info) {
        var mh$ = sorglq_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sorglq_", m, n, k, A, lda, tau, work, lwork, info);
            }
            mh$.invokeExact(m, n, k, A, lda, tau, work, lwork, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dorgql_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("dorgql_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dorgql_(const int *m, const int *n, const int *k, double *A, const int *lda, const double *tau, double *work, const int *lwork, int *info)
     * }
     */
    public static FunctionDescriptor dorgql_$descriptor() {
        return dorgql_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dorgql_(const int *m, const int *n, const int *k, double *A, const int *lda, const double *tau, double *work, const int *lwork, int *info)
     * }
     */
    public static MethodHandle dorgql_$handle() {
        return dorgql_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dorgql_(const int *m, const int *n, const int *k, double *A, const int *lda, const double *tau, double *work, const int *lwork, int *info)
     * }
     */
    public static MemorySegment dorgql_$address() {
        return dorgql_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dorgql_(const int *m, const int *n, const int *k, double *A, const int *lda, const double *tau, double *work, const int *lwork, int *info)
     * }
     */
    public static void dorgql_(MemorySegment m, MemorySegment n, MemorySegment k, MemorySegment A, MemorySegment lda, MemorySegment tau, MemorySegment work, MemorySegment lwork, MemorySegment info) {
        var mh$ = dorgql_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dorgql_", m, n, k, A, lda, tau, work, lwork, info);
            }
            mh$.invokeExact(m, n, k, A, lda, tau, work, lwork, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sorgql_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("sorgql_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void sorgql_(const int *m, const int *n, const int *k, float *A, const int *lda, const float *tau, float *work, const int *lwork, int *info)
     * }
     */
    public static FunctionDescriptor sorgql_$descriptor() {
        return sorgql_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void sorgql_(const int *m, const int *n, const int *k, float *A, const int *lda, const float *tau, float *work, const int *lwork, int *info)
     * }
     */
    public static MethodHandle sorgql_$handle() {
        return sorgql_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void sorgql_(const int *m, const int *n, const int *k, float *A, const int *lda, const float *tau, float *work, const int *lwork, int *info)
     * }
     */
    public static MemorySegment sorgql_$address() {
        return sorgql_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void sorgql_(const int *m, const int *n, const int *k, float *A, const int *lda, const float *tau, float *work, const int *lwork, int *info)
     * }
     */
    public static void sorgql_(MemorySegment m, MemorySegment n, MemorySegment k, MemorySegment A, MemorySegment lda, MemorySegment tau, MemorySegment work, MemorySegment lwork, MemorySegment info) {
        var mh$ = sorgql_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sorgql_", m, n, k, A, lda, tau, work, lwork, info);
            }
            mh$.invokeExact(m, n, k, A, lda, tau, work, lwork, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dorgqr_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("dorgqr_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dorgqr_(const int *m, const int *n, const int *k, double *A, const int *lda, const double *tau, double *work, const int *lwork, int *info)
     * }
     */
    public static FunctionDescriptor dorgqr_$descriptor() {
        return dorgqr_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dorgqr_(const int *m, const int *n, const int *k, double *A, const int *lda, const double *tau, double *work, const int *lwork, int *info)
     * }
     */
    public static MethodHandle dorgqr_$handle() {
        return dorgqr_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dorgqr_(const int *m, const int *n, const int *k, double *A, const int *lda, const double *tau, double *work, const int *lwork, int *info)
     * }
     */
    public static MemorySegment dorgqr_$address() {
        return dorgqr_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dorgqr_(const int *m, const int *n, const int *k, double *A, const int *lda, const double *tau, double *work, const int *lwork, int *info)
     * }
     */
    public static void dorgqr_(MemorySegment m, MemorySegment n, MemorySegment k, MemorySegment A, MemorySegment lda, MemorySegment tau, MemorySegment work, MemorySegment lwork, MemorySegment info) {
        var mh$ = dorgqr_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dorgqr_", m, n, k, A, lda, tau, work, lwork, info);
            }
            mh$.invokeExact(m, n, k, A, lda, tau, work, lwork, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sorgqr_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("sorgqr_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void sorgqr_(const int *m, const int *n, const int *k, float *A, const int *lda, const float *tau, float *work, const int *lwork, int *info)
     * }
     */
    public static FunctionDescriptor sorgqr_$descriptor() {
        return sorgqr_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void sorgqr_(const int *m, const int *n, const int *k, float *A, const int *lda, const float *tau, float *work, const int *lwork, int *info)
     * }
     */
    public static MethodHandle sorgqr_$handle() {
        return sorgqr_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void sorgqr_(const int *m, const int *n, const int *k, float *A, const int *lda, const float *tau, float *work, const int *lwork, int *info)
     * }
     */
    public static MemorySegment sorgqr_$address() {
        return sorgqr_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void sorgqr_(const int *m, const int *n, const int *k, float *A, const int *lda, const float *tau, float *work, const int *lwork, int *info)
     * }
     */
    public static void sorgqr_(MemorySegment m, MemorySegment n, MemorySegment k, MemorySegment A, MemorySegment lda, MemorySegment tau, MemorySegment work, MemorySegment lwork, MemorySegment info) {
        var mh$ = sorgqr_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sorgqr_", m, n, k, A, lda, tau, work, lwork, info);
            }
            mh$.invokeExact(m, n, k, A, lda, tau, work, lwork, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dorgrq_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("dorgrq_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dorgrq_(const int *m, const int *n, const int *k, double *A, const int *lda, const double *tau, double *work, const int *lwork, int *info)
     * }
     */
    public static FunctionDescriptor dorgrq_$descriptor() {
        return dorgrq_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dorgrq_(const int *m, const int *n, const int *k, double *A, const int *lda, const double *tau, double *work, const int *lwork, int *info)
     * }
     */
    public static MethodHandle dorgrq_$handle() {
        return dorgrq_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dorgrq_(const int *m, const int *n, const int *k, double *A, const int *lda, const double *tau, double *work, const int *lwork, int *info)
     * }
     */
    public static MemorySegment dorgrq_$address() {
        return dorgrq_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dorgrq_(const int *m, const int *n, const int *k, double *A, const int *lda, const double *tau, double *work, const int *lwork, int *info)
     * }
     */
    public static void dorgrq_(MemorySegment m, MemorySegment n, MemorySegment k, MemorySegment A, MemorySegment lda, MemorySegment tau, MemorySegment work, MemorySegment lwork, MemorySegment info) {
        var mh$ = dorgrq_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dorgrq_", m, n, k, A, lda, tau, work, lwork, info);
            }
            mh$.invokeExact(m, n, k, A, lda, tau, work, lwork, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sorgrq_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("sorgrq_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void sorgrq_(const int *m, const int *n, const int *k, float *A, const int *lda, const float *tau, float *work, const int *lwork, int *info)
     * }
     */
    public static FunctionDescriptor sorgrq_$descriptor() {
        return sorgrq_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void sorgrq_(const int *m, const int *n, const int *k, float *A, const int *lda, const float *tau, float *work, const int *lwork, int *info)
     * }
     */
    public static MethodHandle sorgrq_$handle() {
        return sorgrq_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void sorgrq_(const int *m, const int *n, const int *k, float *A, const int *lda, const float *tau, float *work, const int *lwork, int *info)
     * }
     */
    public static MemorySegment sorgrq_$address() {
        return sorgrq_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void sorgrq_(const int *m, const int *n, const int *k, float *A, const int *lda, const float *tau, float *work, const int *lwork, int *info)
     * }
     */
    public static void sorgrq_(MemorySegment m, MemorySegment n, MemorySegment k, MemorySegment A, MemorySegment lda, MemorySegment tau, MemorySegment work, MemorySegment lwork, MemorySegment info) {
        var mh$ = sorgrq_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sorgrq_", m, n, k, A, lda, tau, work, lwork, info);
            }
            mh$.invokeExact(m, n, k, A, lda, tau, work, lwork, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dorgtr_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("dorgtr_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dorgtr_(const char *uplo, const int *n, double *A, const int *lda, const double *tau, double *work, const int *lwork, int *info, size_t)
     * }
     */
    public static FunctionDescriptor dorgtr_$descriptor() {
        return dorgtr_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dorgtr_(const char *uplo, const int *n, double *A, const int *lda, const double *tau, double *work, const int *lwork, int *info, size_t)
     * }
     */
    public static MethodHandle dorgtr_$handle() {
        return dorgtr_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dorgtr_(const char *uplo, const int *n, double *A, const int *lda, const double *tau, double *work, const int *lwork, int *info, size_t)
     * }
     */
    public static MemorySegment dorgtr_$address() {
        return dorgtr_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dorgtr_(const char *uplo, const int *n, double *A, const int *lda, const double *tau, double *work, const int *lwork, int *info, size_t)
     * }
     */
    public static void dorgtr_(MemorySegment uplo, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment tau, MemorySegment work, MemorySegment lwork, MemorySegment info, long x8) {
        var mh$ = dorgtr_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dorgtr_", uplo, n, A, lda, tau, work, lwork, info, x8);
            }
            mh$.invokeExact(uplo, n, A, lda, tau, work, lwork, info, x8);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sorgtr_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("sorgtr_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void sorgtr_(const char *uplo, const int *n, float *A, const int *lda, const float *tau, float *work, const int *lwork, int *info, size_t)
     * }
     */
    public static FunctionDescriptor sorgtr_$descriptor() {
        return sorgtr_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void sorgtr_(const char *uplo, const int *n, float *A, const int *lda, const float *tau, float *work, const int *lwork, int *info, size_t)
     * }
     */
    public static MethodHandle sorgtr_$handle() {
        return sorgtr_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void sorgtr_(const char *uplo, const int *n, float *A, const int *lda, const float *tau, float *work, const int *lwork, int *info, size_t)
     * }
     */
    public static MemorySegment sorgtr_$address() {
        return sorgtr_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void sorgtr_(const char *uplo, const int *n, float *A, const int *lda, const float *tau, float *work, const int *lwork, int *info, size_t)
     * }
     */
    public static void sorgtr_(MemorySegment uplo, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment tau, MemorySegment work, MemorySegment lwork, MemorySegment info, long x8) {
        var mh$ = sorgtr_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sorgtr_", uplo, n, A, lda, tau, work, lwork, info, x8);
            }
            mh$.invokeExact(uplo, n, A, lda, tau, work, lwork, info, x8);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dorgtsqr_row_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("dorgtsqr_row_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dorgtsqr_row_(const int *m, const int *n, const int *mb, const int *nb, double *A, const int *lda, const double *T, const int *ldt, double *work, const int *lwork, int *info)
     * }
     */
    public static FunctionDescriptor dorgtsqr_row_$descriptor() {
        return dorgtsqr_row_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dorgtsqr_row_(const int *m, const int *n, const int *mb, const int *nb, double *A, const int *lda, const double *T, const int *ldt, double *work, const int *lwork, int *info)
     * }
     */
    public static MethodHandle dorgtsqr_row_$handle() {
        return dorgtsqr_row_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dorgtsqr_row_(const int *m, const int *n, const int *mb, const int *nb, double *A, const int *lda, const double *T, const int *ldt, double *work, const int *lwork, int *info)
     * }
     */
    public static MemorySegment dorgtsqr_row_$address() {
        return dorgtsqr_row_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dorgtsqr_row_(const int *m, const int *n, const int *mb, const int *nb, double *A, const int *lda, const double *T, const int *ldt, double *work, const int *lwork, int *info)
     * }
     */
    public static void dorgtsqr_row_(MemorySegment m, MemorySegment n, MemorySegment mb, MemorySegment nb, MemorySegment A, MemorySegment lda, MemorySegment T, MemorySegment ldt, MemorySegment work, MemorySegment lwork, MemorySegment info) {
        var mh$ = dorgtsqr_row_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dorgtsqr_row_", m, n, mb, nb, A, lda, T, ldt, work, lwork, info);
            }
            mh$.invokeExact(m, n, mb, nb, A, lda, T, ldt, work, lwork, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sorgtsqr_row_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("sorgtsqr_row_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void sorgtsqr_row_(const int *m, const int *n, const int *mb, const int *nb, float *A, const int *lda, const float *T, const int *ldt, float *work, const int *lwork, int *info)
     * }
     */
    public static FunctionDescriptor sorgtsqr_row_$descriptor() {
        return sorgtsqr_row_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void sorgtsqr_row_(const int *m, const int *n, const int *mb, const int *nb, float *A, const int *lda, const float *T, const int *ldt, float *work, const int *lwork, int *info)
     * }
     */
    public static MethodHandle sorgtsqr_row_$handle() {
        return sorgtsqr_row_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void sorgtsqr_row_(const int *m, const int *n, const int *mb, const int *nb, float *A, const int *lda, const float *T, const int *ldt, float *work, const int *lwork, int *info)
     * }
     */
    public static MemorySegment sorgtsqr_row_$address() {
        return sorgtsqr_row_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void sorgtsqr_row_(const int *m, const int *n, const int *mb, const int *nb, float *A, const int *lda, const float *T, const int *ldt, float *work, const int *lwork, int *info)
     * }
     */
    public static void sorgtsqr_row_(MemorySegment m, MemorySegment n, MemorySegment mb, MemorySegment nb, MemorySegment A, MemorySegment lda, MemorySegment T, MemorySegment ldt, MemorySegment work, MemorySegment lwork, MemorySegment info) {
        var mh$ = sorgtsqr_row_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sorgtsqr_row_", m, n, mb, nb, A, lda, T, ldt, work, lwork, info);
            }
            mh$.invokeExact(m, n, mb, nb, A, lda, T, ldt, work, lwork, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dormbr_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("dormbr_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dormbr_(const char *vect, const char *side, const char *trans, const int *m, const int *n, const int *k, const double *A, const int *lda, const double *tau, double *C, const int *ldc, double *work, const int *lwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor dormbr_$descriptor() {
        return dormbr_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dormbr_(const char *vect, const char *side, const char *trans, const int *m, const int *n, const int *k, const double *A, const int *lda, const double *tau, double *C, const int *ldc, double *work, const int *lwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle dormbr_$handle() {
        return dormbr_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dormbr_(const char *vect, const char *side, const char *trans, const int *m, const int *n, const int *k, const double *A, const int *lda, const double *tau, double *C, const int *ldc, double *work, const int *lwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment dormbr_$address() {
        return dormbr_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dormbr_(const char *vect, const char *side, const char *trans, const int *m, const int *n, const int *k, const double *A, const int *lda, const double *tau, double *C, const int *ldc, double *work, const int *lwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static void dormbr_(MemorySegment vect, MemorySegment side, MemorySegment trans, MemorySegment m, MemorySegment n, MemorySegment k, MemorySegment A, MemorySegment lda, MemorySegment tau, MemorySegment C, MemorySegment ldc, MemorySegment work, MemorySegment lwork, MemorySegment info, long x14, long x15, long x16) {
        var mh$ = dormbr_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dormbr_", vect, side, trans, m, n, k, A, lda, tau, C, ldc, work, lwork, info, x14, x15, x16);
            }
            mh$.invokeExact(vect, side, trans, m, n, k, A, lda, tau, C, ldc, work, lwork, info, x14, x15, x16);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sormbr_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("sormbr_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void sormbr_(const char *vect, const char *side, const char *trans, const int *m, const int *n, const int *k, const float *A, const int *lda, const float *tau, float *C, const int *ldc, float *work, const int *lwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor sormbr_$descriptor() {
        return sormbr_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void sormbr_(const char *vect, const char *side, const char *trans, const int *m, const int *n, const int *k, const float *A, const int *lda, const float *tau, float *C, const int *ldc, float *work, const int *lwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle sormbr_$handle() {
        return sormbr_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void sormbr_(const char *vect, const char *side, const char *trans, const int *m, const int *n, const int *k, const float *A, const int *lda, const float *tau, float *C, const int *ldc, float *work, const int *lwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment sormbr_$address() {
        return sormbr_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void sormbr_(const char *vect, const char *side, const char *trans, const int *m, const int *n, const int *k, const float *A, const int *lda, const float *tau, float *C, const int *ldc, float *work, const int *lwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static void sormbr_(MemorySegment vect, MemorySegment side, MemorySegment trans, MemorySegment m, MemorySegment n, MemorySegment k, MemorySegment A, MemorySegment lda, MemorySegment tau, MemorySegment C, MemorySegment ldc, MemorySegment work, MemorySegment lwork, MemorySegment info, long x14, long x15, long x16) {
        var mh$ = sormbr_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sormbr_", vect, side, trans, m, n, k, A, lda, tau, C, ldc, work, lwork, info, x14, x15, x16);
            }
            mh$.invokeExact(vect, side, trans, m, n, k, A, lda, tau, C, ldc, work, lwork, info, x14, x15, x16);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dormhr_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("dormhr_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dormhr_(const char *side, const char *trans, const int *m, const int *n, const int *ilo, const int *ihi, const double *A, const int *lda, const double *tau, double *C, const int *ldc, double *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor dormhr_$descriptor() {
        return dormhr_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dormhr_(const char *side, const char *trans, const int *m, const int *n, const int *ilo, const int *ihi, const double *A, const int *lda, const double *tau, double *C, const int *ldc, double *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle dormhr_$handle() {
        return dormhr_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dormhr_(const char *side, const char *trans, const int *m, const int *n, const int *ilo, const int *ihi, const double *A, const int *lda, const double *tau, double *C, const int *ldc, double *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment dormhr_$address() {
        return dormhr_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dormhr_(const char *side, const char *trans, const int *m, const int *n, const int *ilo, const int *ihi, const double *A, const int *lda, const double *tau, double *C, const int *ldc, double *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static void dormhr_(MemorySegment side, MemorySegment trans, MemorySegment m, MemorySegment n, MemorySegment ilo, MemorySegment ihi, MemorySegment A, MemorySegment lda, MemorySegment tau, MemorySegment C, MemorySegment ldc, MemorySegment work, MemorySegment lwork, MemorySegment info, long x14, long x15) {
        var mh$ = dormhr_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dormhr_", side, trans, m, n, ilo, ihi, A, lda, tau, C, ldc, work, lwork, info, x14, x15);
            }
            mh$.invokeExact(side, trans, m, n, ilo, ihi, A, lda, tau, C, ldc, work, lwork, info, x14, x15);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sormhr_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("sormhr_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void sormhr_(const char *side, const char *trans, const int *m, const int *n, const int *ilo, const int *ihi, const float *A, const int *lda, const float *tau, float *C, const int *ldc, float *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor sormhr_$descriptor() {
        return sormhr_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void sormhr_(const char *side, const char *trans, const int *m, const int *n, const int *ilo, const int *ihi, const float *A, const int *lda, const float *tau, float *C, const int *ldc, float *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle sormhr_$handle() {
        return sormhr_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void sormhr_(const char *side, const char *trans, const int *m, const int *n, const int *ilo, const int *ihi, const float *A, const int *lda, const float *tau, float *C, const int *ldc, float *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment sormhr_$address() {
        return sormhr_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void sormhr_(const char *side, const char *trans, const int *m, const int *n, const int *ilo, const int *ihi, const float *A, const int *lda, const float *tau, float *C, const int *ldc, float *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static void sormhr_(MemorySegment side, MemorySegment trans, MemorySegment m, MemorySegment n, MemorySegment ilo, MemorySegment ihi, MemorySegment A, MemorySegment lda, MemorySegment tau, MemorySegment C, MemorySegment ldc, MemorySegment work, MemorySegment lwork, MemorySegment info, long x14, long x15) {
        var mh$ = sormhr_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sormhr_", side, trans, m, n, ilo, ihi, A, lda, tau, C, ldc, work, lwork, info, x14, x15);
            }
            mh$.invokeExact(side, trans, m, n, ilo, ihi, A, lda, tau, C, ldc, work, lwork, info, x14, x15);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dormlq_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("dormlq_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dormlq_(const char *side, const char *trans, const int *m, const int *n, const int *k, const double *A, const int *lda, const double *tau, double *C, const int *ldc, double *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor dormlq_$descriptor() {
        return dormlq_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dormlq_(const char *side, const char *trans, const int *m, const int *n, const int *k, const double *A, const int *lda, const double *tau, double *C, const int *ldc, double *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle dormlq_$handle() {
        return dormlq_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dormlq_(const char *side, const char *trans, const int *m, const int *n, const int *k, const double *A, const int *lda, const double *tau, double *C, const int *ldc, double *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment dormlq_$address() {
        return dormlq_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dormlq_(const char *side, const char *trans, const int *m, const int *n, const int *k, const double *A, const int *lda, const double *tau, double *C, const int *ldc, double *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static void dormlq_(MemorySegment side, MemorySegment trans, MemorySegment m, MemorySegment n, MemorySegment k, MemorySegment A, MemorySegment lda, MemorySegment tau, MemorySegment C, MemorySegment ldc, MemorySegment work, MemorySegment lwork, MemorySegment info, long x13, long x14) {
        var mh$ = dormlq_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dormlq_", side, trans, m, n, k, A, lda, tau, C, ldc, work, lwork, info, x13, x14);
            }
            mh$.invokeExact(side, trans, m, n, k, A, lda, tau, C, ldc, work, lwork, info, x13, x14);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sormlq_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("sormlq_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void sormlq_(const char *side, const char *trans, const int *m, const int *n, const int *k, const float *A, const int *lda, const float *tau, float *C, const int *ldc, float *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor sormlq_$descriptor() {
        return sormlq_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void sormlq_(const char *side, const char *trans, const int *m, const int *n, const int *k, const float *A, const int *lda, const float *tau, float *C, const int *ldc, float *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle sormlq_$handle() {
        return sormlq_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void sormlq_(const char *side, const char *trans, const int *m, const int *n, const int *k, const float *A, const int *lda, const float *tau, float *C, const int *ldc, float *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment sormlq_$address() {
        return sormlq_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void sormlq_(const char *side, const char *trans, const int *m, const int *n, const int *k, const float *A, const int *lda, const float *tau, float *C, const int *ldc, float *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static void sormlq_(MemorySegment side, MemorySegment trans, MemorySegment m, MemorySegment n, MemorySegment k, MemorySegment A, MemorySegment lda, MemorySegment tau, MemorySegment C, MemorySegment ldc, MemorySegment work, MemorySegment lwork, MemorySegment info, long x13, long x14) {
        var mh$ = sormlq_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sormlq_", side, trans, m, n, k, A, lda, tau, C, ldc, work, lwork, info, x13, x14);
            }
            mh$.invokeExact(side, trans, m, n, k, A, lda, tau, C, ldc, work, lwork, info, x13, x14);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dormql_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("dormql_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dormql_(const char *side, const char *trans, const int *m, const int *n, const int *k, const double *A, const int *lda, const double *tau, double *C, const int *ldc, double *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor dormql_$descriptor() {
        return dormql_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dormql_(const char *side, const char *trans, const int *m, const int *n, const int *k, const double *A, const int *lda, const double *tau, double *C, const int *ldc, double *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle dormql_$handle() {
        return dormql_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dormql_(const char *side, const char *trans, const int *m, const int *n, const int *k, const double *A, const int *lda, const double *tau, double *C, const int *ldc, double *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment dormql_$address() {
        return dormql_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dormql_(const char *side, const char *trans, const int *m, const int *n, const int *k, const double *A, const int *lda, const double *tau, double *C, const int *ldc, double *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static void dormql_(MemorySegment side, MemorySegment trans, MemorySegment m, MemorySegment n, MemorySegment k, MemorySegment A, MemorySegment lda, MemorySegment tau, MemorySegment C, MemorySegment ldc, MemorySegment work, MemorySegment lwork, MemorySegment info, long x13, long x14) {
        var mh$ = dormql_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dormql_", side, trans, m, n, k, A, lda, tau, C, ldc, work, lwork, info, x13, x14);
            }
            mh$.invokeExact(side, trans, m, n, k, A, lda, tau, C, ldc, work, lwork, info, x13, x14);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sormql_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("sormql_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void sormql_(const char *side, const char *trans, const int *m, const int *n, const int *k, const float *A, const int *lda, const float *tau, float *C, const int *ldc, float *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor sormql_$descriptor() {
        return sormql_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void sormql_(const char *side, const char *trans, const int *m, const int *n, const int *k, const float *A, const int *lda, const float *tau, float *C, const int *ldc, float *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle sormql_$handle() {
        return sormql_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void sormql_(const char *side, const char *trans, const int *m, const int *n, const int *k, const float *A, const int *lda, const float *tau, float *C, const int *ldc, float *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment sormql_$address() {
        return sormql_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void sormql_(const char *side, const char *trans, const int *m, const int *n, const int *k, const float *A, const int *lda, const float *tau, float *C, const int *ldc, float *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static void sormql_(MemorySegment side, MemorySegment trans, MemorySegment m, MemorySegment n, MemorySegment k, MemorySegment A, MemorySegment lda, MemorySegment tau, MemorySegment C, MemorySegment ldc, MemorySegment work, MemorySegment lwork, MemorySegment info, long x13, long x14) {
        var mh$ = sormql_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sormql_", side, trans, m, n, k, A, lda, tau, C, ldc, work, lwork, info, x13, x14);
            }
            mh$.invokeExact(side, trans, m, n, k, A, lda, tau, C, ldc, work, lwork, info, x13, x14);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dormqr_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("dormqr_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dormqr_(const char *side, const char *trans, const int *m, const int *n, const int *k, const double *A, const int *lda, const double *tau, double *C, const int *ldc, double *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor dormqr_$descriptor() {
        return dormqr_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dormqr_(const char *side, const char *trans, const int *m, const int *n, const int *k, const double *A, const int *lda, const double *tau, double *C, const int *ldc, double *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle dormqr_$handle() {
        return dormqr_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dormqr_(const char *side, const char *trans, const int *m, const int *n, const int *k, const double *A, const int *lda, const double *tau, double *C, const int *ldc, double *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment dormqr_$address() {
        return dormqr_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dormqr_(const char *side, const char *trans, const int *m, const int *n, const int *k, const double *A, const int *lda, const double *tau, double *C, const int *ldc, double *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static void dormqr_(MemorySegment side, MemorySegment trans, MemorySegment m, MemorySegment n, MemorySegment k, MemorySegment A, MemorySegment lda, MemorySegment tau, MemorySegment C, MemorySegment ldc, MemorySegment work, MemorySegment lwork, MemorySegment info, long x13, long x14) {
        var mh$ = dormqr_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dormqr_", side, trans, m, n, k, A, lda, tau, C, ldc, work, lwork, info, x13, x14);
            }
            mh$.invokeExact(side, trans, m, n, k, A, lda, tau, C, ldc, work, lwork, info, x13, x14);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sormqr_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("sormqr_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void sormqr_(const char *side, const char *trans, const int *m, const int *n, const int *k, const float *A, const int *lda, const float *tau, float *C, const int *ldc, float *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor sormqr_$descriptor() {
        return sormqr_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void sormqr_(const char *side, const char *trans, const int *m, const int *n, const int *k, const float *A, const int *lda, const float *tau, float *C, const int *ldc, float *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle sormqr_$handle() {
        return sormqr_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void sormqr_(const char *side, const char *trans, const int *m, const int *n, const int *k, const float *A, const int *lda, const float *tau, float *C, const int *ldc, float *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment sormqr_$address() {
        return sormqr_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void sormqr_(const char *side, const char *trans, const int *m, const int *n, const int *k, const float *A, const int *lda, const float *tau, float *C, const int *ldc, float *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static void sormqr_(MemorySegment side, MemorySegment trans, MemorySegment m, MemorySegment n, MemorySegment k, MemorySegment A, MemorySegment lda, MemorySegment tau, MemorySegment C, MemorySegment ldc, MemorySegment work, MemorySegment lwork, MemorySegment info, long x13, long x14) {
        var mh$ = sormqr_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sormqr_", side, trans, m, n, k, A, lda, tau, C, ldc, work, lwork, info, x13, x14);
            }
            mh$.invokeExact(side, trans, m, n, k, A, lda, tau, C, ldc, work, lwork, info, x13, x14);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dormrq_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("dormrq_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dormrq_(const char *side, const char *trans, const int *m, const int *n, const int *k, const double *A, const int *lda, const double *tau, double *C, const int *ldc, double *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor dormrq_$descriptor() {
        return dormrq_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dormrq_(const char *side, const char *trans, const int *m, const int *n, const int *k, const double *A, const int *lda, const double *tau, double *C, const int *ldc, double *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle dormrq_$handle() {
        return dormrq_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dormrq_(const char *side, const char *trans, const int *m, const int *n, const int *k, const double *A, const int *lda, const double *tau, double *C, const int *ldc, double *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment dormrq_$address() {
        return dormrq_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dormrq_(const char *side, const char *trans, const int *m, const int *n, const int *k, const double *A, const int *lda, const double *tau, double *C, const int *ldc, double *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static void dormrq_(MemorySegment side, MemorySegment trans, MemorySegment m, MemorySegment n, MemorySegment k, MemorySegment A, MemorySegment lda, MemorySegment tau, MemorySegment C, MemorySegment ldc, MemorySegment work, MemorySegment lwork, MemorySegment info, long x13, long x14) {
        var mh$ = dormrq_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dormrq_", side, trans, m, n, k, A, lda, tau, C, ldc, work, lwork, info, x13, x14);
            }
            mh$.invokeExact(side, trans, m, n, k, A, lda, tau, C, ldc, work, lwork, info, x13, x14);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sormrq_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("sormrq_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void sormrq_(const char *side, const char *trans, const int *m, const int *n, const int *k, const float *A, const int *lda, const float *tau, float *C, const int *ldc, float *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor sormrq_$descriptor() {
        return sormrq_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void sormrq_(const char *side, const char *trans, const int *m, const int *n, const int *k, const float *A, const int *lda, const float *tau, float *C, const int *ldc, float *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle sormrq_$handle() {
        return sormrq_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void sormrq_(const char *side, const char *trans, const int *m, const int *n, const int *k, const float *A, const int *lda, const float *tau, float *C, const int *ldc, float *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment sormrq_$address() {
        return sormrq_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void sormrq_(const char *side, const char *trans, const int *m, const int *n, const int *k, const float *A, const int *lda, const float *tau, float *C, const int *ldc, float *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static void sormrq_(MemorySegment side, MemorySegment trans, MemorySegment m, MemorySegment n, MemorySegment k, MemorySegment A, MemorySegment lda, MemorySegment tau, MemorySegment C, MemorySegment ldc, MemorySegment work, MemorySegment lwork, MemorySegment info, long x13, long x14) {
        var mh$ = sormrq_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sormrq_", side, trans, m, n, k, A, lda, tau, C, ldc, work, lwork, info, x13, x14);
            }
            mh$.invokeExact(side, trans, m, n, k, A, lda, tau, C, ldc, work, lwork, info, x13, x14);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dormrz_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("dormrz_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dormrz_(const char *side, const char *trans, const int *m, const int *n, const int *k, const int *l, const double *A, const int *lda, const double *tau, double *C, const int *ldc, double *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor dormrz_$descriptor() {
        return dormrz_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dormrz_(const char *side, const char *trans, const int *m, const int *n, const int *k, const int *l, const double *A, const int *lda, const double *tau, double *C, const int *ldc, double *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle dormrz_$handle() {
        return dormrz_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dormrz_(const char *side, const char *trans, const int *m, const int *n, const int *k, const int *l, const double *A, const int *lda, const double *tau, double *C, const int *ldc, double *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment dormrz_$address() {
        return dormrz_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dormrz_(const char *side, const char *trans, const int *m, const int *n, const int *k, const int *l, const double *A, const int *lda, const double *tau, double *C, const int *ldc, double *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static void dormrz_(MemorySegment side, MemorySegment trans, MemorySegment m, MemorySegment n, MemorySegment k, MemorySegment l, MemorySegment A, MemorySegment lda, MemorySegment tau, MemorySegment C, MemorySegment ldc, MemorySegment work, MemorySegment lwork, MemorySegment info, long x14, long x15) {
        var mh$ = dormrz_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dormrz_", side, trans, m, n, k, l, A, lda, tau, C, ldc, work, lwork, info, x14, x15);
            }
            mh$.invokeExact(side, trans, m, n, k, l, A, lda, tau, C, ldc, work, lwork, info, x14, x15);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sormrz_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("sormrz_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void sormrz_(const char *side, const char *trans, const int *m, const int *n, const int *k, const int *l, const float *A, const int *lda, const float *tau, float *C, const int *ldc, float *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor sormrz_$descriptor() {
        return sormrz_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void sormrz_(const char *side, const char *trans, const int *m, const int *n, const int *k, const int *l, const float *A, const int *lda, const float *tau, float *C, const int *ldc, float *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle sormrz_$handle() {
        return sormrz_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void sormrz_(const char *side, const char *trans, const int *m, const int *n, const int *k, const int *l, const float *A, const int *lda, const float *tau, float *C, const int *ldc, float *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment sormrz_$address() {
        return sormrz_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void sormrz_(const char *side, const char *trans, const int *m, const int *n, const int *k, const int *l, const float *A, const int *lda, const float *tau, float *C, const int *ldc, float *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static void sormrz_(MemorySegment side, MemorySegment trans, MemorySegment m, MemorySegment n, MemorySegment k, MemorySegment l, MemorySegment A, MemorySegment lda, MemorySegment tau, MemorySegment C, MemorySegment ldc, MemorySegment work, MemorySegment lwork, MemorySegment info, long x14, long x15) {
        var mh$ = sormrz_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sormrz_", side, trans, m, n, k, l, A, lda, tau, C, ldc, work, lwork, info, x14, x15);
            }
            mh$.invokeExact(side, trans, m, n, k, l, A, lda, tau, C, ldc, work, lwork, info, x14, x15);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dormtr_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("dormtr_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dormtr_(const char *side, const char *uplo, const char *trans, const int *m, const int *n, const double *A, const int *lda, const double *tau, double *C, const int *ldc, double *work, const int *lwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor dormtr_$descriptor() {
        return dormtr_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dormtr_(const char *side, const char *uplo, const char *trans, const int *m, const int *n, const double *A, const int *lda, const double *tau, double *C, const int *ldc, double *work, const int *lwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle dormtr_$handle() {
        return dormtr_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dormtr_(const char *side, const char *uplo, const char *trans, const int *m, const int *n, const double *A, const int *lda, const double *tau, double *C, const int *ldc, double *work, const int *lwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment dormtr_$address() {
        return dormtr_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dormtr_(const char *side, const char *uplo, const char *trans, const int *m, const int *n, const double *A, const int *lda, const double *tau, double *C, const int *ldc, double *work, const int *lwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static void dormtr_(MemorySegment side, MemorySegment uplo, MemorySegment trans, MemorySegment m, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment tau, MemorySegment C, MemorySegment ldc, MemorySegment work, MemorySegment lwork, MemorySegment info, long x13, long x14, long x15) {
        var mh$ = dormtr_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dormtr_", side, uplo, trans, m, n, A, lda, tau, C, ldc, work, lwork, info, x13, x14, x15);
            }
            mh$.invokeExact(side, uplo, trans, m, n, A, lda, tau, C, ldc, work, lwork, info, x13, x14, x15);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sormtr_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("sormtr_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void sormtr_(const char *side, const char *uplo, const char *trans, const int *m, const int *n, const float *A, const int *lda, const float *tau, float *C, const int *ldc, float *work, const int *lwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor sormtr_$descriptor() {
        return sormtr_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void sormtr_(const char *side, const char *uplo, const char *trans, const int *m, const int *n, const float *A, const int *lda, const float *tau, float *C, const int *ldc, float *work, const int *lwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle sormtr_$handle() {
        return sormtr_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void sormtr_(const char *side, const char *uplo, const char *trans, const int *m, const int *n, const float *A, const int *lda, const float *tau, float *C, const int *ldc, float *work, const int *lwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment sormtr_$address() {
        return sormtr_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void sormtr_(const char *side, const char *uplo, const char *trans, const int *m, const int *n, const float *A, const int *lda, const float *tau, float *C, const int *ldc, float *work, const int *lwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static void sormtr_(MemorySegment side, MemorySegment uplo, MemorySegment trans, MemorySegment m, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment tau, MemorySegment C, MemorySegment ldc, MemorySegment work, MemorySegment lwork, MemorySegment info, long x13, long x14, long x15) {
        var mh$ = sormtr_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sormtr_", side, uplo, trans, m, n, A, lda, tau, C, ldc, work, lwork, info, x13, x14, x15);
            }
            mh$.invokeExact(side, uplo, trans, m, n, A, lda, tau, C, ldc, work, lwork, info, x13, x14, x15);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cpbcon_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cpbcon_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cpbcon_(const char *uplo, const int *n, const int *kd, const _Complex float *AB, const int *ldab, const float *anorm, float *rcond, _Complex float *work, float *rwork, int *info, size_t)
     * }
     */
    public static FunctionDescriptor cpbcon_$descriptor() {
        return cpbcon_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cpbcon_(const char *uplo, const int *n, const int *kd, const _Complex float *AB, const int *ldab, const float *anorm, float *rcond, _Complex float *work, float *rwork, int *info, size_t)
     * }
     */
    public static MethodHandle cpbcon_$handle() {
        return cpbcon_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cpbcon_(const char *uplo, const int *n, const int *kd, const _Complex float *AB, const int *ldab, const float *anorm, float *rcond, _Complex float *work, float *rwork, int *info, size_t)
     * }
     */
    public static MemorySegment cpbcon_$address() {
        return cpbcon_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cpbcon_(const char *uplo, const int *n, const int *kd, const _Complex float *AB, const int *ldab, const float *anorm, float *rcond, _Complex float *work, float *rwork, int *info, size_t)
     * }
     */
    public static void cpbcon_(MemorySegment uplo, MemorySegment n, MemorySegment kd, MemorySegment AB, MemorySegment ldab, MemorySegment anorm, MemorySegment rcond, MemorySegment work, MemorySegment rwork, MemorySegment info, long x10) {
        var mh$ = cpbcon_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cpbcon_", uplo, n, kd, AB, ldab, anorm, rcond, work, rwork, info, x10);
            }
            mh$.invokeExact(uplo, n, kd, AB, ldab, anorm, rcond, work, rwork, info, x10);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dpbcon_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("dpbcon_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dpbcon_(const char *uplo, const int *n, const int *kd, const double *AB, const int *ldab, const double *anorm, double *rcond, double *work, int *iwork, int *info, size_t)
     * }
     */
    public static FunctionDescriptor dpbcon_$descriptor() {
        return dpbcon_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dpbcon_(const char *uplo, const int *n, const int *kd, const double *AB, const int *ldab, const double *anorm, double *rcond, double *work, int *iwork, int *info, size_t)
     * }
     */
    public static MethodHandle dpbcon_$handle() {
        return dpbcon_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dpbcon_(const char *uplo, const int *n, const int *kd, const double *AB, const int *ldab, const double *anorm, double *rcond, double *work, int *iwork, int *info, size_t)
     * }
     */
    public static MemorySegment dpbcon_$address() {
        return dpbcon_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dpbcon_(const char *uplo, const int *n, const int *kd, const double *AB, const int *ldab, const double *anorm, double *rcond, double *work, int *iwork, int *info, size_t)
     * }
     */
    public static void dpbcon_(MemorySegment uplo, MemorySegment n, MemorySegment kd, MemorySegment AB, MemorySegment ldab, MemorySegment anorm, MemorySegment rcond, MemorySegment work, MemorySegment iwork, MemorySegment info, long x10) {
        var mh$ = dpbcon_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dpbcon_", uplo, n, kd, AB, ldab, anorm, rcond, work, iwork, info, x10);
            }
            mh$.invokeExact(uplo, n, kd, AB, ldab, anorm, rcond, work, iwork, info, x10);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class spbcon_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("spbcon_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void spbcon_(const char *uplo, const int *n, const int *kd, const float *AB, const int *ldab, const float *anorm, float *rcond, float *work, int *iwork, int *info, size_t)
     * }
     */
    public static FunctionDescriptor spbcon_$descriptor() {
        return spbcon_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void spbcon_(const char *uplo, const int *n, const int *kd, const float *AB, const int *ldab, const float *anorm, float *rcond, float *work, int *iwork, int *info, size_t)
     * }
     */
    public static MethodHandle spbcon_$handle() {
        return spbcon_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void spbcon_(const char *uplo, const int *n, const int *kd, const float *AB, const int *ldab, const float *anorm, float *rcond, float *work, int *iwork, int *info, size_t)
     * }
     */
    public static MemorySegment spbcon_$address() {
        return spbcon_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void spbcon_(const char *uplo, const int *n, const int *kd, const float *AB, const int *ldab, const float *anorm, float *rcond, float *work, int *iwork, int *info, size_t)
     * }
     */
    public static void spbcon_(MemorySegment uplo, MemorySegment n, MemorySegment kd, MemorySegment AB, MemorySegment ldab, MemorySegment anorm, MemorySegment rcond, MemorySegment work, MemorySegment iwork, MemorySegment info, long x10) {
        var mh$ = spbcon_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("spbcon_", uplo, n, kd, AB, ldab, anorm, rcond, work, iwork, info, x10);
            }
            mh$.invokeExact(uplo, n, kd, AB, ldab, anorm, rcond, work, iwork, info, x10);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zpbcon_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("zpbcon_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zpbcon_(const char *uplo, const int *n, const int *kd, const _Complex double *AB, const int *ldab, const double *anorm, double *rcond, _Complex double *work, double *rwork, int *info, size_t)
     * }
     */
    public static FunctionDescriptor zpbcon_$descriptor() {
        return zpbcon_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zpbcon_(const char *uplo, const int *n, const int *kd, const _Complex double *AB, const int *ldab, const double *anorm, double *rcond, _Complex double *work, double *rwork, int *info, size_t)
     * }
     */
    public static MethodHandle zpbcon_$handle() {
        return zpbcon_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zpbcon_(const char *uplo, const int *n, const int *kd, const _Complex double *AB, const int *ldab, const double *anorm, double *rcond, _Complex double *work, double *rwork, int *info, size_t)
     * }
     */
    public static MemorySegment zpbcon_$address() {
        return zpbcon_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zpbcon_(const char *uplo, const int *n, const int *kd, const _Complex double *AB, const int *ldab, const double *anorm, double *rcond, _Complex double *work, double *rwork, int *info, size_t)
     * }
     */
    public static void zpbcon_(MemorySegment uplo, MemorySegment n, MemorySegment kd, MemorySegment AB, MemorySegment ldab, MemorySegment anorm, MemorySegment rcond, MemorySegment work, MemorySegment rwork, MemorySegment info, long x10) {
        var mh$ = zpbcon_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zpbcon_", uplo, n, kd, AB, ldab, anorm, rcond, work, rwork, info, x10);
            }
            mh$.invokeExact(uplo, n, kd, AB, ldab, anorm, rcond, work, rwork, info, x10);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cpbequ_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cpbequ_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cpbequ_(const char *uplo, const int *n, const int *kd, const _Complex float *AB, const int *ldab, float *S, float *scond, float *amax, int *info, size_t)
     * }
     */
    public static FunctionDescriptor cpbequ_$descriptor() {
        return cpbequ_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cpbequ_(const char *uplo, const int *n, const int *kd, const _Complex float *AB, const int *ldab, float *S, float *scond, float *amax, int *info, size_t)
     * }
     */
    public static MethodHandle cpbequ_$handle() {
        return cpbequ_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cpbequ_(const char *uplo, const int *n, const int *kd, const _Complex float *AB, const int *ldab, float *S, float *scond, float *amax, int *info, size_t)
     * }
     */
    public static MemorySegment cpbequ_$address() {
        return cpbequ_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cpbequ_(const char *uplo, const int *n, const int *kd, const _Complex float *AB, const int *ldab, float *S, float *scond, float *amax, int *info, size_t)
     * }
     */
    public static void cpbequ_(MemorySegment uplo, MemorySegment n, MemorySegment kd, MemorySegment AB, MemorySegment ldab, MemorySegment S, MemorySegment scond, MemorySegment amax, MemorySegment info, long x9) {
        var mh$ = cpbequ_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cpbequ_", uplo, n, kd, AB, ldab, S, scond, amax, info, x9);
            }
            mh$.invokeExact(uplo, n, kd, AB, ldab, S, scond, amax, info, x9);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dpbequ_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("dpbequ_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dpbequ_(const char *uplo, const int *n, const int *kd, const double *AB, const int *ldab, double *S, double *scond, double *amax, int *info, size_t)
     * }
     */
    public static FunctionDescriptor dpbequ_$descriptor() {
        return dpbequ_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dpbequ_(const char *uplo, const int *n, const int *kd, const double *AB, const int *ldab, double *S, double *scond, double *amax, int *info, size_t)
     * }
     */
    public static MethodHandle dpbequ_$handle() {
        return dpbequ_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dpbequ_(const char *uplo, const int *n, const int *kd, const double *AB, const int *ldab, double *S, double *scond, double *amax, int *info, size_t)
     * }
     */
    public static MemorySegment dpbequ_$address() {
        return dpbequ_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dpbequ_(const char *uplo, const int *n, const int *kd, const double *AB, const int *ldab, double *S, double *scond, double *amax, int *info, size_t)
     * }
     */
    public static void dpbequ_(MemorySegment uplo, MemorySegment n, MemorySegment kd, MemorySegment AB, MemorySegment ldab, MemorySegment S, MemorySegment scond, MemorySegment amax, MemorySegment info, long x9) {
        var mh$ = dpbequ_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dpbequ_", uplo, n, kd, AB, ldab, S, scond, amax, info, x9);
            }
            mh$.invokeExact(uplo, n, kd, AB, ldab, S, scond, amax, info, x9);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class spbequ_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("spbequ_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void spbequ_(const char *uplo, const int *n, const int *kd, const float *AB, const int *ldab, float *S, float *scond, float *amax, int *info, size_t)
     * }
     */
    public static FunctionDescriptor spbequ_$descriptor() {
        return spbequ_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void spbequ_(const char *uplo, const int *n, const int *kd, const float *AB, const int *ldab, float *S, float *scond, float *amax, int *info, size_t)
     * }
     */
    public static MethodHandle spbequ_$handle() {
        return spbequ_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void spbequ_(const char *uplo, const int *n, const int *kd, const float *AB, const int *ldab, float *S, float *scond, float *amax, int *info, size_t)
     * }
     */
    public static MemorySegment spbequ_$address() {
        return spbequ_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void spbequ_(const char *uplo, const int *n, const int *kd, const float *AB, const int *ldab, float *S, float *scond, float *amax, int *info, size_t)
     * }
     */
    public static void spbequ_(MemorySegment uplo, MemorySegment n, MemorySegment kd, MemorySegment AB, MemorySegment ldab, MemorySegment S, MemorySegment scond, MemorySegment amax, MemorySegment info, long x9) {
        var mh$ = spbequ_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("spbequ_", uplo, n, kd, AB, ldab, S, scond, amax, info, x9);
            }
            mh$.invokeExact(uplo, n, kd, AB, ldab, S, scond, amax, info, x9);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zpbequ_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("zpbequ_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zpbequ_(const char *uplo, const int *n, const int *kd, const _Complex double *AB, const int *ldab, double *S, double *scond, double *amax, int *info, size_t)
     * }
     */
    public static FunctionDescriptor zpbequ_$descriptor() {
        return zpbequ_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zpbequ_(const char *uplo, const int *n, const int *kd, const _Complex double *AB, const int *ldab, double *S, double *scond, double *amax, int *info, size_t)
     * }
     */
    public static MethodHandle zpbequ_$handle() {
        return zpbequ_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zpbequ_(const char *uplo, const int *n, const int *kd, const _Complex double *AB, const int *ldab, double *S, double *scond, double *amax, int *info, size_t)
     * }
     */
    public static MemorySegment zpbequ_$address() {
        return zpbequ_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zpbequ_(const char *uplo, const int *n, const int *kd, const _Complex double *AB, const int *ldab, double *S, double *scond, double *amax, int *info, size_t)
     * }
     */
    public static void zpbequ_(MemorySegment uplo, MemorySegment n, MemorySegment kd, MemorySegment AB, MemorySegment ldab, MemorySegment S, MemorySegment scond, MemorySegment amax, MemorySegment info, long x9) {
        var mh$ = zpbequ_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zpbequ_", uplo, n, kd, AB, ldab, S, scond, amax, info, x9);
            }
            mh$.invokeExact(uplo, n, kd, AB, ldab, S, scond, amax, info, x9);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cpbrfs_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cpbrfs_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cpbrfs_(const char *uplo, const int *n, const int *kd, const int *nrhs, const _Complex float *AB, const int *ldab, const _Complex float *AFB, const int *ldafb, const _Complex float *B, const int *ldb, _Complex float *X, const int *ldx, float *ferr, float *berr, _Complex float *work, float *rwork, int *info, size_t)
     * }
     */
    public static FunctionDescriptor cpbrfs_$descriptor() {
        return cpbrfs_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cpbrfs_(const char *uplo, const int *n, const int *kd, const int *nrhs, const _Complex float *AB, const int *ldab, const _Complex float *AFB, const int *ldafb, const _Complex float *B, const int *ldb, _Complex float *X, const int *ldx, float *ferr, float *berr, _Complex float *work, float *rwork, int *info, size_t)
     * }
     */
    public static MethodHandle cpbrfs_$handle() {
        return cpbrfs_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cpbrfs_(const char *uplo, const int *n, const int *kd, const int *nrhs, const _Complex float *AB, const int *ldab, const _Complex float *AFB, const int *ldafb, const _Complex float *B, const int *ldb, _Complex float *X, const int *ldx, float *ferr, float *berr, _Complex float *work, float *rwork, int *info, size_t)
     * }
     */
    public static MemorySegment cpbrfs_$address() {
        return cpbrfs_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cpbrfs_(const char *uplo, const int *n, const int *kd, const int *nrhs, const _Complex float *AB, const int *ldab, const _Complex float *AFB, const int *ldafb, const _Complex float *B, const int *ldb, _Complex float *X, const int *ldx, float *ferr, float *berr, _Complex float *work, float *rwork, int *info, size_t)
     * }
     */
    public static void cpbrfs_(MemorySegment uplo, MemorySegment n, MemorySegment kd, MemorySegment nrhs, MemorySegment AB, MemorySegment ldab, MemorySegment AFB, MemorySegment ldafb, MemorySegment B, MemorySegment ldb, MemorySegment X, MemorySegment ldx, MemorySegment ferr, MemorySegment berr, MemorySegment work, MemorySegment rwork, MemorySegment info, long x17) {
        var mh$ = cpbrfs_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cpbrfs_", uplo, n, kd, nrhs, AB, ldab, AFB, ldafb, B, ldb, X, ldx, ferr, berr, work, rwork, info, x17);
            }
            mh$.invokeExact(uplo, n, kd, nrhs, AB, ldab, AFB, ldafb, B, ldb, X, ldx, ferr, berr, work, rwork, info, x17);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dpbrfs_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("dpbrfs_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dpbrfs_(const char *uplo, const int *n, const int *kd, const int *nrhs, const double *AB, const int *ldab, const double *AFB, const int *ldafb, const double *B, const int *ldb, double *X, const int *ldx, double *ferr, double *berr, double *work, int *iwork, int *info, size_t)
     * }
     */
    public static FunctionDescriptor dpbrfs_$descriptor() {
        return dpbrfs_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dpbrfs_(const char *uplo, const int *n, const int *kd, const int *nrhs, const double *AB, const int *ldab, const double *AFB, const int *ldafb, const double *B, const int *ldb, double *X, const int *ldx, double *ferr, double *berr, double *work, int *iwork, int *info, size_t)
     * }
     */
    public static MethodHandle dpbrfs_$handle() {
        return dpbrfs_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dpbrfs_(const char *uplo, const int *n, const int *kd, const int *nrhs, const double *AB, const int *ldab, const double *AFB, const int *ldafb, const double *B, const int *ldb, double *X, const int *ldx, double *ferr, double *berr, double *work, int *iwork, int *info, size_t)
     * }
     */
    public static MemorySegment dpbrfs_$address() {
        return dpbrfs_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dpbrfs_(const char *uplo, const int *n, const int *kd, const int *nrhs, const double *AB, const int *ldab, const double *AFB, const int *ldafb, const double *B, const int *ldb, double *X, const int *ldx, double *ferr, double *berr, double *work, int *iwork, int *info, size_t)
     * }
     */
    public static void dpbrfs_(MemorySegment uplo, MemorySegment n, MemorySegment kd, MemorySegment nrhs, MemorySegment AB, MemorySegment ldab, MemorySegment AFB, MemorySegment ldafb, MemorySegment B, MemorySegment ldb, MemorySegment X, MemorySegment ldx, MemorySegment ferr, MemorySegment berr, MemorySegment work, MemorySegment iwork, MemorySegment info, long x17) {
        var mh$ = dpbrfs_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dpbrfs_", uplo, n, kd, nrhs, AB, ldab, AFB, ldafb, B, ldb, X, ldx, ferr, berr, work, iwork, info, x17);
            }
            mh$.invokeExact(uplo, n, kd, nrhs, AB, ldab, AFB, ldafb, B, ldb, X, ldx, ferr, berr, work, iwork, info, x17);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class spbrfs_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("spbrfs_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void spbrfs_(const char *uplo, const int *n, const int *kd, const int *nrhs, const float *AB, const int *ldab, const float *AFB, const int *ldafb, const float *B, const int *ldb, float *X, const int *ldx, float *ferr, float *berr, float *work, int *iwork, int *info, size_t)
     * }
     */
    public static FunctionDescriptor spbrfs_$descriptor() {
        return spbrfs_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void spbrfs_(const char *uplo, const int *n, const int *kd, const int *nrhs, const float *AB, const int *ldab, const float *AFB, const int *ldafb, const float *B, const int *ldb, float *X, const int *ldx, float *ferr, float *berr, float *work, int *iwork, int *info, size_t)
     * }
     */
    public static MethodHandle spbrfs_$handle() {
        return spbrfs_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void spbrfs_(const char *uplo, const int *n, const int *kd, const int *nrhs, const float *AB, const int *ldab, const float *AFB, const int *ldafb, const float *B, const int *ldb, float *X, const int *ldx, float *ferr, float *berr, float *work, int *iwork, int *info, size_t)
     * }
     */
    public static MemorySegment spbrfs_$address() {
        return spbrfs_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void spbrfs_(const char *uplo, const int *n, const int *kd, const int *nrhs, const float *AB, const int *ldab, const float *AFB, const int *ldafb, const float *B, const int *ldb, float *X, const int *ldx, float *ferr, float *berr, float *work, int *iwork, int *info, size_t)
     * }
     */
    public static void spbrfs_(MemorySegment uplo, MemorySegment n, MemorySegment kd, MemorySegment nrhs, MemorySegment AB, MemorySegment ldab, MemorySegment AFB, MemorySegment ldafb, MemorySegment B, MemorySegment ldb, MemorySegment X, MemorySegment ldx, MemorySegment ferr, MemorySegment berr, MemorySegment work, MemorySegment iwork, MemorySegment info, long x17) {
        var mh$ = spbrfs_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("spbrfs_", uplo, n, kd, nrhs, AB, ldab, AFB, ldafb, B, ldb, X, ldx, ferr, berr, work, iwork, info, x17);
            }
            mh$.invokeExact(uplo, n, kd, nrhs, AB, ldab, AFB, ldafb, B, ldb, X, ldx, ferr, berr, work, iwork, info, x17);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zpbrfs_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("zpbrfs_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zpbrfs_(const char *uplo, const int *n, const int *kd, const int *nrhs, const _Complex double *AB, const int *ldab, const _Complex double *AFB, const int *ldafb, const _Complex double *B, const int *ldb, _Complex double *X, const int *ldx, double *ferr, double *berr, _Complex double *work, double *rwork, int *info, size_t)
     * }
     */
    public static FunctionDescriptor zpbrfs_$descriptor() {
        return zpbrfs_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zpbrfs_(const char *uplo, const int *n, const int *kd, const int *nrhs, const _Complex double *AB, const int *ldab, const _Complex double *AFB, const int *ldafb, const _Complex double *B, const int *ldb, _Complex double *X, const int *ldx, double *ferr, double *berr, _Complex double *work, double *rwork, int *info, size_t)
     * }
     */
    public static MethodHandle zpbrfs_$handle() {
        return zpbrfs_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zpbrfs_(const char *uplo, const int *n, const int *kd, const int *nrhs, const _Complex double *AB, const int *ldab, const _Complex double *AFB, const int *ldafb, const _Complex double *B, const int *ldb, _Complex double *X, const int *ldx, double *ferr, double *berr, _Complex double *work, double *rwork, int *info, size_t)
     * }
     */
    public static MemorySegment zpbrfs_$address() {
        return zpbrfs_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zpbrfs_(const char *uplo, const int *n, const int *kd, const int *nrhs, const _Complex double *AB, const int *ldab, const _Complex double *AFB, const int *ldafb, const _Complex double *B, const int *ldb, _Complex double *X, const int *ldx, double *ferr, double *berr, _Complex double *work, double *rwork, int *info, size_t)
     * }
     */
    public static void zpbrfs_(MemorySegment uplo, MemorySegment n, MemorySegment kd, MemorySegment nrhs, MemorySegment AB, MemorySegment ldab, MemorySegment AFB, MemorySegment ldafb, MemorySegment B, MemorySegment ldb, MemorySegment X, MemorySegment ldx, MemorySegment ferr, MemorySegment berr, MemorySegment work, MemorySegment rwork, MemorySegment info, long x17) {
        var mh$ = zpbrfs_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zpbrfs_", uplo, n, kd, nrhs, AB, ldab, AFB, ldafb, B, ldb, X, ldx, ferr, berr, work, rwork, info, x17);
            }
            mh$.invokeExact(uplo, n, kd, nrhs, AB, ldab, AFB, ldafb, B, ldb, X, ldx, ferr, berr, work, rwork, info, x17);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cpbstf_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cpbstf_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cpbstf_(const char *uplo, const int *n, const int *kd, _Complex float *AB, const int *ldab, int *info, size_t)
     * }
     */
    public static FunctionDescriptor cpbstf_$descriptor() {
        return cpbstf_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cpbstf_(const char *uplo, const int *n, const int *kd, _Complex float *AB, const int *ldab, int *info, size_t)
     * }
     */
    public static MethodHandle cpbstf_$handle() {
        return cpbstf_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cpbstf_(const char *uplo, const int *n, const int *kd, _Complex float *AB, const int *ldab, int *info, size_t)
     * }
     */
    public static MemorySegment cpbstf_$address() {
        return cpbstf_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cpbstf_(const char *uplo, const int *n, const int *kd, _Complex float *AB, const int *ldab, int *info, size_t)
     * }
     */
    public static void cpbstf_(MemorySegment uplo, MemorySegment n, MemorySegment kd, MemorySegment AB, MemorySegment ldab, MemorySegment info, long x6) {
        var mh$ = cpbstf_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cpbstf_", uplo, n, kd, AB, ldab, info, x6);
            }
            mh$.invokeExact(uplo, n, kd, AB, ldab, info, x6);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dpbstf_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("dpbstf_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dpbstf_(const char *uplo, const int *n, const int *kd, double *AB, const int *ldab, int *info, size_t)
     * }
     */
    public static FunctionDescriptor dpbstf_$descriptor() {
        return dpbstf_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dpbstf_(const char *uplo, const int *n, const int *kd, double *AB, const int *ldab, int *info, size_t)
     * }
     */
    public static MethodHandle dpbstf_$handle() {
        return dpbstf_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dpbstf_(const char *uplo, const int *n, const int *kd, double *AB, const int *ldab, int *info, size_t)
     * }
     */
    public static MemorySegment dpbstf_$address() {
        return dpbstf_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dpbstf_(const char *uplo, const int *n, const int *kd, double *AB, const int *ldab, int *info, size_t)
     * }
     */
    public static void dpbstf_(MemorySegment uplo, MemorySegment n, MemorySegment kd, MemorySegment AB, MemorySegment ldab, MemorySegment info, long x6) {
        var mh$ = dpbstf_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dpbstf_", uplo, n, kd, AB, ldab, info, x6);
            }
            mh$.invokeExact(uplo, n, kd, AB, ldab, info, x6);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class spbstf_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("spbstf_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void spbstf_(const char *uplo, const int *n, const int *kd, float *AB, const int *ldab, int *info, size_t)
     * }
     */
    public static FunctionDescriptor spbstf_$descriptor() {
        return spbstf_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void spbstf_(const char *uplo, const int *n, const int *kd, float *AB, const int *ldab, int *info, size_t)
     * }
     */
    public static MethodHandle spbstf_$handle() {
        return spbstf_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void spbstf_(const char *uplo, const int *n, const int *kd, float *AB, const int *ldab, int *info, size_t)
     * }
     */
    public static MemorySegment spbstf_$address() {
        return spbstf_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void spbstf_(const char *uplo, const int *n, const int *kd, float *AB, const int *ldab, int *info, size_t)
     * }
     */
    public static void spbstf_(MemorySegment uplo, MemorySegment n, MemorySegment kd, MemorySegment AB, MemorySegment ldab, MemorySegment info, long x6) {
        var mh$ = spbstf_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("spbstf_", uplo, n, kd, AB, ldab, info, x6);
            }
            mh$.invokeExact(uplo, n, kd, AB, ldab, info, x6);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zpbstf_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("zpbstf_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zpbstf_(const char *uplo, const int *n, const int *kd, _Complex double *AB, const int *ldab, int *info, size_t)
     * }
     */
    public static FunctionDescriptor zpbstf_$descriptor() {
        return zpbstf_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zpbstf_(const char *uplo, const int *n, const int *kd, _Complex double *AB, const int *ldab, int *info, size_t)
     * }
     */
    public static MethodHandle zpbstf_$handle() {
        return zpbstf_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zpbstf_(const char *uplo, const int *n, const int *kd, _Complex double *AB, const int *ldab, int *info, size_t)
     * }
     */
    public static MemorySegment zpbstf_$address() {
        return zpbstf_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zpbstf_(const char *uplo, const int *n, const int *kd, _Complex double *AB, const int *ldab, int *info, size_t)
     * }
     */
    public static void zpbstf_(MemorySegment uplo, MemorySegment n, MemorySegment kd, MemorySegment AB, MemorySegment ldab, MemorySegment info, long x6) {
        var mh$ = zpbstf_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zpbstf_", uplo, n, kd, AB, ldab, info, x6);
            }
            mh$.invokeExact(uplo, n, kd, AB, ldab, info, x6);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cpbsv_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cpbsv_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cpbsv_(const char *uplo, const int *n, const int *kd, const int *nrhs, _Complex float *AB, const int *ldab, _Complex float *B, const int *ldb, int *info, size_t)
     * }
     */
    public static FunctionDescriptor cpbsv_$descriptor() {
        return cpbsv_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cpbsv_(const char *uplo, const int *n, const int *kd, const int *nrhs, _Complex float *AB, const int *ldab, _Complex float *B, const int *ldb, int *info, size_t)
     * }
     */
    public static MethodHandle cpbsv_$handle() {
        return cpbsv_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cpbsv_(const char *uplo, const int *n, const int *kd, const int *nrhs, _Complex float *AB, const int *ldab, _Complex float *B, const int *ldb, int *info, size_t)
     * }
     */
    public static MemorySegment cpbsv_$address() {
        return cpbsv_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cpbsv_(const char *uplo, const int *n, const int *kd, const int *nrhs, _Complex float *AB, const int *ldab, _Complex float *B, const int *ldb, int *info, size_t)
     * }
     */
    public static void cpbsv_(MemorySegment uplo, MemorySegment n, MemorySegment kd, MemorySegment nrhs, MemorySegment AB, MemorySegment ldab, MemorySegment B, MemorySegment ldb, MemorySegment info, long x9) {
        var mh$ = cpbsv_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cpbsv_", uplo, n, kd, nrhs, AB, ldab, B, ldb, info, x9);
            }
            mh$.invokeExact(uplo, n, kd, nrhs, AB, ldab, B, ldb, info, x9);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dpbsv_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("dpbsv_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dpbsv_(const char *uplo, const int *n, const int *kd, const int *nrhs, double *AB, const int *ldab, double *B, const int *ldb, int *info, size_t)
     * }
     */
    public static FunctionDescriptor dpbsv_$descriptor() {
        return dpbsv_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dpbsv_(const char *uplo, const int *n, const int *kd, const int *nrhs, double *AB, const int *ldab, double *B, const int *ldb, int *info, size_t)
     * }
     */
    public static MethodHandle dpbsv_$handle() {
        return dpbsv_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dpbsv_(const char *uplo, const int *n, const int *kd, const int *nrhs, double *AB, const int *ldab, double *B, const int *ldb, int *info, size_t)
     * }
     */
    public static MemorySegment dpbsv_$address() {
        return dpbsv_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dpbsv_(const char *uplo, const int *n, const int *kd, const int *nrhs, double *AB, const int *ldab, double *B, const int *ldb, int *info, size_t)
     * }
     */
    public static void dpbsv_(MemorySegment uplo, MemorySegment n, MemorySegment kd, MemorySegment nrhs, MemorySegment AB, MemorySegment ldab, MemorySegment B, MemorySegment ldb, MemorySegment info, long x9) {
        var mh$ = dpbsv_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dpbsv_", uplo, n, kd, nrhs, AB, ldab, B, ldb, info, x9);
            }
            mh$.invokeExact(uplo, n, kd, nrhs, AB, ldab, B, ldb, info, x9);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class spbsv_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("spbsv_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void spbsv_(const char *uplo, const int *n, const int *kd, const int *nrhs, float *AB, const int *ldab, float *B, const int *ldb, int *info, size_t)
     * }
     */
    public static FunctionDescriptor spbsv_$descriptor() {
        return spbsv_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void spbsv_(const char *uplo, const int *n, const int *kd, const int *nrhs, float *AB, const int *ldab, float *B, const int *ldb, int *info, size_t)
     * }
     */
    public static MethodHandle spbsv_$handle() {
        return spbsv_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void spbsv_(const char *uplo, const int *n, const int *kd, const int *nrhs, float *AB, const int *ldab, float *B, const int *ldb, int *info, size_t)
     * }
     */
    public static MemorySegment spbsv_$address() {
        return spbsv_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void spbsv_(const char *uplo, const int *n, const int *kd, const int *nrhs, float *AB, const int *ldab, float *B, const int *ldb, int *info, size_t)
     * }
     */
    public static void spbsv_(MemorySegment uplo, MemorySegment n, MemorySegment kd, MemorySegment nrhs, MemorySegment AB, MemorySegment ldab, MemorySegment B, MemorySegment ldb, MemorySegment info, long x9) {
        var mh$ = spbsv_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("spbsv_", uplo, n, kd, nrhs, AB, ldab, B, ldb, info, x9);
            }
            mh$.invokeExact(uplo, n, kd, nrhs, AB, ldab, B, ldb, info, x9);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zpbsv_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("zpbsv_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zpbsv_(const char *uplo, const int *n, const int *kd, const int *nrhs, _Complex double *AB, const int *ldab, _Complex double *B, const int *ldb, int *info, size_t)
     * }
     */
    public static FunctionDescriptor zpbsv_$descriptor() {
        return zpbsv_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zpbsv_(const char *uplo, const int *n, const int *kd, const int *nrhs, _Complex double *AB, const int *ldab, _Complex double *B, const int *ldb, int *info, size_t)
     * }
     */
    public static MethodHandle zpbsv_$handle() {
        return zpbsv_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zpbsv_(const char *uplo, const int *n, const int *kd, const int *nrhs, _Complex double *AB, const int *ldab, _Complex double *B, const int *ldb, int *info, size_t)
     * }
     */
    public static MemorySegment zpbsv_$address() {
        return zpbsv_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zpbsv_(const char *uplo, const int *n, const int *kd, const int *nrhs, _Complex double *AB, const int *ldab, _Complex double *B, const int *ldb, int *info, size_t)
     * }
     */
    public static void zpbsv_(MemorySegment uplo, MemorySegment n, MemorySegment kd, MemorySegment nrhs, MemorySegment AB, MemorySegment ldab, MemorySegment B, MemorySegment ldb, MemorySegment info, long x9) {
        var mh$ = zpbsv_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zpbsv_", uplo, n, kd, nrhs, AB, ldab, B, ldb, info, x9);
            }
            mh$.invokeExact(uplo, n, kd, nrhs, AB, ldab, B, ldb, info, x9);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cpbsvx_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cpbsvx_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cpbsvx_(const char *fact, const char *uplo, const int *n, const int *kd, const int *nrhs, _Complex float *AB, const int *ldab, _Complex float *AFB, const int *ldafb, char *equed, float *S, _Complex float *B, const int *ldb, _Complex float *X, const int *ldx, float *rcond, float *ferr, float *berr, _Complex float *work, float *rwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor cpbsvx_$descriptor() {
        return cpbsvx_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cpbsvx_(const char *fact, const char *uplo, const int *n, const int *kd, const int *nrhs, _Complex float *AB, const int *ldab, _Complex float *AFB, const int *ldafb, char *equed, float *S, _Complex float *B, const int *ldb, _Complex float *X, const int *ldx, float *rcond, float *ferr, float *berr, _Complex float *work, float *rwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle cpbsvx_$handle() {
        return cpbsvx_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cpbsvx_(const char *fact, const char *uplo, const int *n, const int *kd, const int *nrhs, _Complex float *AB, const int *ldab, _Complex float *AFB, const int *ldafb, char *equed, float *S, _Complex float *B, const int *ldb, _Complex float *X, const int *ldx, float *rcond, float *ferr, float *berr, _Complex float *work, float *rwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment cpbsvx_$address() {
        return cpbsvx_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cpbsvx_(const char *fact, const char *uplo, const int *n, const int *kd, const int *nrhs, _Complex float *AB, const int *ldab, _Complex float *AFB, const int *ldafb, char *equed, float *S, _Complex float *B, const int *ldb, _Complex float *X, const int *ldx, float *rcond, float *ferr, float *berr, _Complex float *work, float *rwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static void cpbsvx_(MemorySegment fact, MemorySegment uplo, MemorySegment n, MemorySegment kd, MemorySegment nrhs, MemorySegment AB, MemorySegment ldab, MemorySegment AFB, MemorySegment ldafb, MemorySegment equed, MemorySegment S, MemorySegment B, MemorySegment ldb, MemorySegment X, MemorySegment ldx, MemorySegment rcond, MemorySegment ferr, MemorySegment berr, MemorySegment work, MemorySegment rwork, MemorySegment info, long x21, long x22, long x23) {
        var mh$ = cpbsvx_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cpbsvx_", fact, uplo, n, kd, nrhs, AB, ldab, AFB, ldafb, equed, S, B, ldb, X, ldx, rcond, ferr, berr, work, rwork, info, x21, x22, x23);
            }
            mh$.invokeExact(fact, uplo, n, kd, nrhs, AB, ldab, AFB, ldafb, equed, S, B, ldb, X, ldx, rcond, ferr, berr, work, rwork, info, x21, x22, x23);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dpbsvx_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("dpbsvx_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dpbsvx_(const char *fact, const char *uplo, const int *n, const int *kd, const int *nrhs, double *AB, const int *ldab, double *AFB, const int *ldafb, char *equed, double *S, double *B, const int *ldb, double *X, const int *ldx, double *rcond, double *ferr, double *berr, double *work, int *iwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor dpbsvx_$descriptor() {
        return dpbsvx_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dpbsvx_(const char *fact, const char *uplo, const int *n, const int *kd, const int *nrhs, double *AB, const int *ldab, double *AFB, const int *ldafb, char *equed, double *S, double *B, const int *ldb, double *X, const int *ldx, double *rcond, double *ferr, double *berr, double *work, int *iwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle dpbsvx_$handle() {
        return dpbsvx_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dpbsvx_(const char *fact, const char *uplo, const int *n, const int *kd, const int *nrhs, double *AB, const int *ldab, double *AFB, const int *ldafb, char *equed, double *S, double *B, const int *ldb, double *X, const int *ldx, double *rcond, double *ferr, double *berr, double *work, int *iwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment dpbsvx_$address() {
        return dpbsvx_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dpbsvx_(const char *fact, const char *uplo, const int *n, const int *kd, const int *nrhs, double *AB, const int *ldab, double *AFB, const int *ldafb, char *equed, double *S, double *B, const int *ldb, double *X, const int *ldx, double *rcond, double *ferr, double *berr, double *work, int *iwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static void dpbsvx_(MemorySegment fact, MemorySegment uplo, MemorySegment n, MemorySegment kd, MemorySegment nrhs, MemorySegment AB, MemorySegment ldab, MemorySegment AFB, MemorySegment ldafb, MemorySegment equed, MemorySegment S, MemorySegment B, MemorySegment ldb, MemorySegment X, MemorySegment ldx, MemorySegment rcond, MemorySegment ferr, MemorySegment berr, MemorySegment work, MemorySegment iwork, MemorySegment info, long x21, long x22, long x23) {
        var mh$ = dpbsvx_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dpbsvx_", fact, uplo, n, kd, nrhs, AB, ldab, AFB, ldafb, equed, S, B, ldb, X, ldx, rcond, ferr, berr, work, iwork, info, x21, x22, x23);
            }
            mh$.invokeExact(fact, uplo, n, kd, nrhs, AB, ldab, AFB, ldafb, equed, S, B, ldb, X, ldx, rcond, ferr, berr, work, iwork, info, x21, x22, x23);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class spbsvx_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("spbsvx_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void spbsvx_(const char *fact, const char *uplo, const int *n, const int *kd, const int *nrhs, float *AB, const int *ldab, float *AFB, const int *ldafb, char *equed, float *S, float *B, const int *ldb, float *X, const int *ldx, float *rcond, float *ferr, float *berr, float *work, int *iwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor spbsvx_$descriptor() {
        return spbsvx_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void spbsvx_(const char *fact, const char *uplo, const int *n, const int *kd, const int *nrhs, float *AB, const int *ldab, float *AFB, const int *ldafb, char *equed, float *S, float *B, const int *ldb, float *X, const int *ldx, float *rcond, float *ferr, float *berr, float *work, int *iwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle spbsvx_$handle() {
        return spbsvx_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void spbsvx_(const char *fact, const char *uplo, const int *n, const int *kd, const int *nrhs, float *AB, const int *ldab, float *AFB, const int *ldafb, char *equed, float *S, float *B, const int *ldb, float *X, const int *ldx, float *rcond, float *ferr, float *berr, float *work, int *iwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment spbsvx_$address() {
        return spbsvx_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void spbsvx_(const char *fact, const char *uplo, const int *n, const int *kd, const int *nrhs, float *AB, const int *ldab, float *AFB, const int *ldafb, char *equed, float *S, float *B, const int *ldb, float *X, const int *ldx, float *rcond, float *ferr, float *berr, float *work, int *iwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static void spbsvx_(MemorySegment fact, MemorySegment uplo, MemorySegment n, MemorySegment kd, MemorySegment nrhs, MemorySegment AB, MemorySegment ldab, MemorySegment AFB, MemorySegment ldafb, MemorySegment equed, MemorySegment S, MemorySegment B, MemorySegment ldb, MemorySegment X, MemorySegment ldx, MemorySegment rcond, MemorySegment ferr, MemorySegment berr, MemorySegment work, MemorySegment iwork, MemorySegment info, long x21, long x22, long x23) {
        var mh$ = spbsvx_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("spbsvx_", fact, uplo, n, kd, nrhs, AB, ldab, AFB, ldafb, equed, S, B, ldb, X, ldx, rcond, ferr, berr, work, iwork, info, x21, x22, x23);
            }
            mh$.invokeExact(fact, uplo, n, kd, nrhs, AB, ldab, AFB, ldafb, equed, S, B, ldb, X, ldx, rcond, ferr, berr, work, iwork, info, x21, x22, x23);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zpbsvx_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("zpbsvx_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zpbsvx_(const char *fact, const char *uplo, const int *n, const int *kd, const int *nrhs, _Complex double *AB, const int *ldab, _Complex double *AFB, const int *ldafb, char *equed, double *S, _Complex double *B, const int *ldb, _Complex double *X, const int *ldx, double *rcond, double *ferr, double *berr, _Complex double *work, double *rwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor zpbsvx_$descriptor() {
        return zpbsvx_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zpbsvx_(const char *fact, const char *uplo, const int *n, const int *kd, const int *nrhs, _Complex double *AB, const int *ldab, _Complex double *AFB, const int *ldafb, char *equed, double *S, _Complex double *B, const int *ldb, _Complex double *X, const int *ldx, double *rcond, double *ferr, double *berr, _Complex double *work, double *rwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle zpbsvx_$handle() {
        return zpbsvx_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zpbsvx_(const char *fact, const char *uplo, const int *n, const int *kd, const int *nrhs, _Complex double *AB, const int *ldab, _Complex double *AFB, const int *ldafb, char *equed, double *S, _Complex double *B, const int *ldb, _Complex double *X, const int *ldx, double *rcond, double *ferr, double *berr, _Complex double *work, double *rwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment zpbsvx_$address() {
        return zpbsvx_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zpbsvx_(const char *fact, const char *uplo, const int *n, const int *kd, const int *nrhs, _Complex double *AB, const int *ldab, _Complex double *AFB, const int *ldafb, char *equed, double *S, _Complex double *B, const int *ldb, _Complex double *X, const int *ldx, double *rcond, double *ferr, double *berr, _Complex double *work, double *rwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static void zpbsvx_(MemorySegment fact, MemorySegment uplo, MemorySegment n, MemorySegment kd, MemorySegment nrhs, MemorySegment AB, MemorySegment ldab, MemorySegment AFB, MemorySegment ldafb, MemorySegment equed, MemorySegment S, MemorySegment B, MemorySegment ldb, MemorySegment X, MemorySegment ldx, MemorySegment rcond, MemorySegment ferr, MemorySegment berr, MemorySegment work, MemorySegment rwork, MemorySegment info, long x21, long x22, long x23) {
        var mh$ = zpbsvx_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zpbsvx_", fact, uplo, n, kd, nrhs, AB, ldab, AFB, ldafb, equed, S, B, ldb, X, ldx, rcond, ferr, berr, work, rwork, info, x21, x22, x23);
            }
            mh$.invokeExact(fact, uplo, n, kd, nrhs, AB, ldab, AFB, ldafb, equed, S, B, ldb, X, ldx, rcond, ferr, berr, work, rwork, info, x21, x22, x23);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cpbtrf_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cpbtrf_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cpbtrf_(const char *uplo, const int *n, const int *kd, _Complex float *AB, const int *ldab, int *info, size_t)
     * }
     */
    public static FunctionDescriptor cpbtrf_$descriptor() {
        return cpbtrf_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cpbtrf_(const char *uplo, const int *n, const int *kd, _Complex float *AB, const int *ldab, int *info, size_t)
     * }
     */
    public static MethodHandle cpbtrf_$handle() {
        return cpbtrf_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cpbtrf_(const char *uplo, const int *n, const int *kd, _Complex float *AB, const int *ldab, int *info, size_t)
     * }
     */
    public static MemorySegment cpbtrf_$address() {
        return cpbtrf_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cpbtrf_(const char *uplo, const int *n, const int *kd, _Complex float *AB, const int *ldab, int *info, size_t)
     * }
     */
    public static void cpbtrf_(MemorySegment uplo, MemorySegment n, MemorySegment kd, MemorySegment AB, MemorySegment ldab, MemorySegment info, long x6) {
        var mh$ = cpbtrf_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cpbtrf_", uplo, n, kd, AB, ldab, info, x6);
            }
            mh$.invokeExact(uplo, n, kd, AB, ldab, info, x6);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dpbtrf_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("dpbtrf_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dpbtrf_(const char *uplo, const int *n, const int *kd, double *AB, const int *ldab, int *info, size_t)
     * }
     */
    public static FunctionDescriptor dpbtrf_$descriptor() {
        return dpbtrf_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dpbtrf_(const char *uplo, const int *n, const int *kd, double *AB, const int *ldab, int *info, size_t)
     * }
     */
    public static MethodHandle dpbtrf_$handle() {
        return dpbtrf_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dpbtrf_(const char *uplo, const int *n, const int *kd, double *AB, const int *ldab, int *info, size_t)
     * }
     */
    public static MemorySegment dpbtrf_$address() {
        return dpbtrf_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dpbtrf_(const char *uplo, const int *n, const int *kd, double *AB, const int *ldab, int *info, size_t)
     * }
     */
    public static void dpbtrf_(MemorySegment uplo, MemorySegment n, MemorySegment kd, MemorySegment AB, MemorySegment ldab, MemorySegment info, long x6) {
        var mh$ = dpbtrf_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dpbtrf_", uplo, n, kd, AB, ldab, info, x6);
            }
            mh$.invokeExact(uplo, n, kd, AB, ldab, info, x6);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class spbtrf_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("spbtrf_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void spbtrf_(const char *uplo, const int *n, const int *kd, float *AB, const int *ldab, int *info, size_t)
     * }
     */
    public static FunctionDescriptor spbtrf_$descriptor() {
        return spbtrf_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void spbtrf_(const char *uplo, const int *n, const int *kd, float *AB, const int *ldab, int *info, size_t)
     * }
     */
    public static MethodHandle spbtrf_$handle() {
        return spbtrf_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void spbtrf_(const char *uplo, const int *n, const int *kd, float *AB, const int *ldab, int *info, size_t)
     * }
     */
    public static MemorySegment spbtrf_$address() {
        return spbtrf_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void spbtrf_(const char *uplo, const int *n, const int *kd, float *AB, const int *ldab, int *info, size_t)
     * }
     */
    public static void spbtrf_(MemorySegment uplo, MemorySegment n, MemorySegment kd, MemorySegment AB, MemorySegment ldab, MemorySegment info, long x6) {
        var mh$ = spbtrf_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("spbtrf_", uplo, n, kd, AB, ldab, info, x6);
            }
            mh$.invokeExact(uplo, n, kd, AB, ldab, info, x6);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zpbtrf_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("zpbtrf_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zpbtrf_(const char *uplo, const int *n, const int *kd, _Complex double *AB, const int *ldab, int *info, size_t)
     * }
     */
    public static FunctionDescriptor zpbtrf_$descriptor() {
        return zpbtrf_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zpbtrf_(const char *uplo, const int *n, const int *kd, _Complex double *AB, const int *ldab, int *info, size_t)
     * }
     */
    public static MethodHandle zpbtrf_$handle() {
        return zpbtrf_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zpbtrf_(const char *uplo, const int *n, const int *kd, _Complex double *AB, const int *ldab, int *info, size_t)
     * }
     */
    public static MemorySegment zpbtrf_$address() {
        return zpbtrf_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zpbtrf_(const char *uplo, const int *n, const int *kd, _Complex double *AB, const int *ldab, int *info, size_t)
     * }
     */
    public static void zpbtrf_(MemorySegment uplo, MemorySegment n, MemorySegment kd, MemorySegment AB, MemorySegment ldab, MemorySegment info, long x6) {
        var mh$ = zpbtrf_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zpbtrf_", uplo, n, kd, AB, ldab, info, x6);
            }
            mh$.invokeExact(uplo, n, kd, AB, ldab, info, x6);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cpbtrs_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cpbtrs_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cpbtrs_(const char *uplo, const int *n, const int *kd, const int *nrhs, const _Complex float *AB, const int *ldab, _Complex float *B, const int *ldb, int *info, size_t)
     * }
     */
    public static FunctionDescriptor cpbtrs_$descriptor() {
        return cpbtrs_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cpbtrs_(const char *uplo, const int *n, const int *kd, const int *nrhs, const _Complex float *AB, const int *ldab, _Complex float *B, const int *ldb, int *info, size_t)
     * }
     */
    public static MethodHandle cpbtrs_$handle() {
        return cpbtrs_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cpbtrs_(const char *uplo, const int *n, const int *kd, const int *nrhs, const _Complex float *AB, const int *ldab, _Complex float *B, const int *ldb, int *info, size_t)
     * }
     */
    public static MemorySegment cpbtrs_$address() {
        return cpbtrs_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cpbtrs_(const char *uplo, const int *n, const int *kd, const int *nrhs, const _Complex float *AB, const int *ldab, _Complex float *B, const int *ldb, int *info, size_t)
     * }
     */
    public static void cpbtrs_(MemorySegment uplo, MemorySegment n, MemorySegment kd, MemorySegment nrhs, MemorySegment AB, MemorySegment ldab, MemorySegment B, MemorySegment ldb, MemorySegment info, long x9) {
        var mh$ = cpbtrs_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cpbtrs_", uplo, n, kd, nrhs, AB, ldab, B, ldb, info, x9);
            }
            mh$.invokeExact(uplo, n, kd, nrhs, AB, ldab, B, ldb, info, x9);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dpbtrs_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("dpbtrs_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dpbtrs_(const char *uplo, const int *n, const int *kd, const int *nrhs, const double *AB, const int *ldab, double *B, const int *ldb, int *info, size_t)
     * }
     */
    public static FunctionDescriptor dpbtrs_$descriptor() {
        return dpbtrs_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dpbtrs_(const char *uplo, const int *n, const int *kd, const int *nrhs, const double *AB, const int *ldab, double *B, const int *ldb, int *info, size_t)
     * }
     */
    public static MethodHandle dpbtrs_$handle() {
        return dpbtrs_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dpbtrs_(const char *uplo, const int *n, const int *kd, const int *nrhs, const double *AB, const int *ldab, double *B, const int *ldb, int *info, size_t)
     * }
     */
    public static MemorySegment dpbtrs_$address() {
        return dpbtrs_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dpbtrs_(const char *uplo, const int *n, const int *kd, const int *nrhs, const double *AB, const int *ldab, double *B, const int *ldb, int *info, size_t)
     * }
     */
    public static void dpbtrs_(MemorySegment uplo, MemorySegment n, MemorySegment kd, MemorySegment nrhs, MemorySegment AB, MemorySegment ldab, MemorySegment B, MemorySegment ldb, MemorySegment info, long x9) {
        var mh$ = dpbtrs_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dpbtrs_", uplo, n, kd, nrhs, AB, ldab, B, ldb, info, x9);
            }
            mh$.invokeExact(uplo, n, kd, nrhs, AB, ldab, B, ldb, info, x9);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class spbtrs_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("spbtrs_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void spbtrs_(const char *uplo, const int *n, const int *kd, const int *nrhs, const float *AB, const int *ldab, float *B, const int *ldb, int *info, size_t)
     * }
     */
    public static FunctionDescriptor spbtrs_$descriptor() {
        return spbtrs_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void spbtrs_(const char *uplo, const int *n, const int *kd, const int *nrhs, const float *AB, const int *ldab, float *B, const int *ldb, int *info, size_t)
     * }
     */
    public static MethodHandle spbtrs_$handle() {
        return spbtrs_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void spbtrs_(const char *uplo, const int *n, const int *kd, const int *nrhs, const float *AB, const int *ldab, float *B, const int *ldb, int *info, size_t)
     * }
     */
    public static MemorySegment spbtrs_$address() {
        return spbtrs_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void spbtrs_(const char *uplo, const int *n, const int *kd, const int *nrhs, const float *AB, const int *ldab, float *B, const int *ldb, int *info, size_t)
     * }
     */
    public static void spbtrs_(MemorySegment uplo, MemorySegment n, MemorySegment kd, MemorySegment nrhs, MemorySegment AB, MemorySegment ldab, MemorySegment B, MemorySegment ldb, MemorySegment info, long x9) {
        var mh$ = spbtrs_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("spbtrs_", uplo, n, kd, nrhs, AB, ldab, B, ldb, info, x9);
            }
            mh$.invokeExact(uplo, n, kd, nrhs, AB, ldab, B, ldb, info, x9);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zpbtrs_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("zpbtrs_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zpbtrs_(const char *uplo, const int *n, const int *kd, const int *nrhs, const _Complex double *AB, const int *ldab, _Complex double *B, const int *ldb, int *info, size_t)
     * }
     */
    public static FunctionDescriptor zpbtrs_$descriptor() {
        return zpbtrs_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zpbtrs_(const char *uplo, const int *n, const int *kd, const int *nrhs, const _Complex double *AB, const int *ldab, _Complex double *B, const int *ldb, int *info, size_t)
     * }
     */
    public static MethodHandle zpbtrs_$handle() {
        return zpbtrs_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zpbtrs_(const char *uplo, const int *n, const int *kd, const int *nrhs, const _Complex double *AB, const int *ldab, _Complex double *B, const int *ldb, int *info, size_t)
     * }
     */
    public static MemorySegment zpbtrs_$address() {
        return zpbtrs_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zpbtrs_(const char *uplo, const int *n, const int *kd, const int *nrhs, const _Complex double *AB, const int *ldab, _Complex double *B, const int *ldb, int *info, size_t)
     * }
     */
    public static void zpbtrs_(MemorySegment uplo, MemorySegment n, MemorySegment kd, MemorySegment nrhs, MemorySegment AB, MemorySegment ldab, MemorySegment B, MemorySegment ldb, MemorySegment info, long x9) {
        var mh$ = zpbtrs_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zpbtrs_", uplo, n, kd, nrhs, AB, ldab, B, ldb, info, x9);
            }
            mh$.invokeExact(uplo, n, kd, nrhs, AB, ldab, B, ldb, info, x9);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cpftrf_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cpftrf_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cpftrf_(const char *transr, const char *uplo, const int *n, _Complex float *A, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor cpftrf_$descriptor() {
        return cpftrf_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cpftrf_(const char *transr, const char *uplo, const int *n, _Complex float *A, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle cpftrf_$handle() {
        return cpftrf_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cpftrf_(const char *transr, const char *uplo, const int *n, _Complex float *A, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment cpftrf_$address() {
        return cpftrf_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cpftrf_(const char *transr, const char *uplo, const int *n, _Complex float *A, int *info, size_t, size_t)
     * }
     */
    public static void cpftrf_(MemorySegment transr, MemorySegment uplo, MemorySegment n, MemorySegment A, MemorySegment info, long x5, long x6) {
        var mh$ = cpftrf_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cpftrf_", transr, uplo, n, A, info, x5, x6);
            }
            mh$.invokeExact(transr, uplo, n, A, info, x5, x6);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dpftrf_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("dpftrf_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dpftrf_(const char *transr, const char *uplo, const int *n, double *A, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor dpftrf_$descriptor() {
        return dpftrf_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dpftrf_(const char *transr, const char *uplo, const int *n, double *A, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle dpftrf_$handle() {
        return dpftrf_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dpftrf_(const char *transr, const char *uplo, const int *n, double *A, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment dpftrf_$address() {
        return dpftrf_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dpftrf_(const char *transr, const char *uplo, const int *n, double *A, int *info, size_t, size_t)
     * }
     */
    public static void dpftrf_(MemorySegment transr, MemorySegment uplo, MemorySegment n, MemorySegment A, MemorySegment info, long x5, long x6) {
        var mh$ = dpftrf_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dpftrf_", transr, uplo, n, A, info, x5, x6);
            }
            mh$.invokeExact(transr, uplo, n, A, info, x5, x6);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class spftrf_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("spftrf_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void spftrf_(const char *transr, const char *uplo, const int *n, float *A, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor spftrf_$descriptor() {
        return spftrf_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void spftrf_(const char *transr, const char *uplo, const int *n, float *A, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle spftrf_$handle() {
        return spftrf_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void spftrf_(const char *transr, const char *uplo, const int *n, float *A, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment spftrf_$address() {
        return spftrf_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void spftrf_(const char *transr, const char *uplo, const int *n, float *A, int *info, size_t, size_t)
     * }
     */
    public static void spftrf_(MemorySegment transr, MemorySegment uplo, MemorySegment n, MemorySegment A, MemorySegment info, long x5, long x6) {
        var mh$ = spftrf_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("spftrf_", transr, uplo, n, A, info, x5, x6);
            }
            mh$.invokeExact(transr, uplo, n, A, info, x5, x6);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zpftrf_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("zpftrf_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zpftrf_(const char *transr, const char *uplo, const int *n, _Complex double *A, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor zpftrf_$descriptor() {
        return zpftrf_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zpftrf_(const char *transr, const char *uplo, const int *n, _Complex double *A, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle zpftrf_$handle() {
        return zpftrf_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zpftrf_(const char *transr, const char *uplo, const int *n, _Complex double *A, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment zpftrf_$address() {
        return zpftrf_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zpftrf_(const char *transr, const char *uplo, const int *n, _Complex double *A, int *info, size_t, size_t)
     * }
     */
    public static void zpftrf_(MemorySegment transr, MemorySegment uplo, MemorySegment n, MemorySegment A, MemorySegment info, long x5, long x6) {
        var mh$ = zpftrf_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zpftrf_", transr, uplo, n, A, info, x5, x6);
            }
            mh$.invokeExact(transr, uplo, n, A, info, x5, x6);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cpftri_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cpftri_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cpftri_(const char *transr, const char *uplo, const int *n, _Complex float *A, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor cpftri_$descriptor() {
        return cpftri_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cpftri_(const char *transr, const char *uplo, const int *n, _Complex float *A, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle cpftri_$handle() {
        return cpftri_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cpftri_(const char *transr, const char *uplo, const int *n, _Complex float *A, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment cpftri_$address() {
        return cpftri_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cpftri_(const char *transr, const char *uplo, const int *n, _Complex float *A, int *info, size_t, size_t)
     * }
     */
    public static void cpftri_(MemorySegment transr, MemorySegment uplo, MemorySegment n, MemorySegment A, MemorySegment info, long x5, long x6) {
        var mh$ = cpftri_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cpftri_", transr, uplo, n, A, info, x5, x6);
            }
            mh$.invokeExact(transr, uplo, n, A, info, x5, x6);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dpftri_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("dpftri_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dpftri_(const char *transr, const char *uplo, const int *n, double *A, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor dpftri_$descriptor() {
        return dpftri_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dpftri_(const char *transr, const char *uplo, const int *n, double *A, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle dpftri_$handle() {
        return dpftri_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dpftri_(const char *transr, const char *uplo, const int *n, double *A, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment dpftri_$address() {
        return dpftri_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dpftri_(const char *transr, const char *uplo, const int *n, double *A, int *info, size_t, size_t)
     * }
     */
    public static void dpftri_(MemorySegment transr, MemorySegment uplo, MemorySegment n, MemorySegment A, MemorySegment info, long x5, long x6) {
        var mh$ = dpftri_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dpftri_", transr, uplo, n, A, info, x5, x6);
            }
            mh$.invokeExact(transr, uplo, n, A, info, x5, x6);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class spftri_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("spftri_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void spftri_(const char *transr, const char *uplo, const int *n, float *A, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor spftri_$descriptor() {
        return spftri_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void spftri_(const char *transr, const char *uplo, const int *n, float *A, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle spftri_$handle() {
        return spftri_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void spftri_(const char *transr, const char *uplo, const int *n, float *A, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment spftri_$address() {
        return spftri_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void spftri_(const char *transr, const char *uplo, const int *n, float *A, int *info, size_t, size_t)
     * }
     */
    public static void spftri_(MemorySegment transr, MemorySegment uplo, MemorySegment n, MemorySegment A, MemorySegment info, long x5, long x6) {
        var mh$ = spftri_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("spftri_", transr, uplo, n, A, info, x5, x6);
            }
            mh$.invokeExact(transr, uplo, n, A, info, x5, x6);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zpftri_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("zpftri_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zpftri_(const char *transr, const char *uplo, const int *n, _Complex double *A, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor zpftri_$descriptor() {
        return zpftri_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zpftri_(const char *transr, const char *uplo, const int *n, _Complex double *A, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle zpftri_$handle() {
        return zpftri_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zpftri_(const char *transr, const char *uplo, const int *n, _Complex double *A, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment zpftri_$address() {
        return zpftri_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zpftri_(const char *transr, const char *uplo, const int *n, _Complex double *A, int *info, size_t, size_t)
     * }
     */
    public static void zpftri_(MemorySegment transr, MemorySegment uplo, MemorySegment n, MemorySegment A, MemorySegment info, long x5, long x6) {
        var mh$ = zpftri_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zpftri_", transr, uplo, n, A, info, x5, x6);
            }
            mh$.invokeExact(transr, uplo, n, A, info, x5, x6);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cpftrs_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cpftrs_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cpftrs_(const char *transr, const char *uplo, const int *n, const int *nrhs, const _Complex float *A, _Complex float *B, const int *ldb, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor cpftrs_$descriptor() {
        return cpftrs_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cpftrs_(const char *transr, const char *uplo, const int *n, const int *nrhs, const _Complex float *A, _Complex float *B, const int *ldb, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle cpftrs_$handle() {
        return cpftrs_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cpftrs_(const char *transr, const char *uplo, const int *n, const int *nrhs, const _Complex float *A, _Complex float *B, const int *ldb, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment cpftrs_$address() {
        return cpftrs_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cpftrs_(const char *transr, const char *uplo, const int *n, const int *nrhs, const _Complex float *A, _Complex float *B, const int *ldb, int *info, size_t, size_t)
     * }
     */
    public static void cpftrs_(MemorySegment transr, MemorySegment uplo, MemorySegment n, MemorySegment nrhs, MemorySegment A, MemorySegment B, MemorySegment ldb, MemorySegment info, long x8, long x9) {
        var mh$ = cpftrs_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cpftrs_", transr, uplo, n, nrhs, A, B, ldb, info, x8, x9);
            }
            mh$.invokeExact(transr, uplo, n, nrhs, A, B, ldb, info, x8, x9);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dpftrs_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("dpftrs_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dpftrs_(const char *transr, const char *uplo, const int *n, const int *nrhs, const double *A, double *B, const int *ldb, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor dpftrs_$descriptor() {
        return dpftrs_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dpftrs_(const char *transr, const char *uplo, const int *n, const int *nrhs, const double *A, double *B, const int *ldb, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle dpftrs_$handle() {
        return dpftrs_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dpftrs_(const char *transr, const char *uplo, const int *n, const int *nrhs, const double *A, double *B, const int *ldb, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment dpftrs_$address() {
        return dpftrs_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dpftrs_(const char *transr, const char *uplo, const int *n, const int *nrhs, const double *A, double *B, const int *ldb, int *info, size_t, size_t)
     * }
     */
    public static void dpftrs_(MemorySegment transr, MemorySegment uplo, MemorySegment n, MemorySegment nrhs, MemorySegment A, MemorySegment B, MemorySegment ldb, MemorySegment info, long x8, long x9) {
        var mh$ = dpftrs_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dpftrs_", transr, uplo, n, nrhs, A, B, ldb, info, x8, x9);
            }
            mh$.invokeExact(transr, uplo, n, nrhs, A, B, ldb, info, x8, x9);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class spftrs_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("spftrs_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void spftrs_(const char *transr, const char *uplo, const int *n, const int *nrhs, const float *A, float *B, const int *ldb, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor spftrs_$descriptor() {
        return spftrs_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void spftrs_(const char *transr, const char *uplo, const int *n, const int *nrhs, const float *A, float *B, const int *ldb, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle spftrs_$handle() {
        return spftrs_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void spftrs_(const char *transr, const char *uplo, const int *n, const int *nrhs, const float *A, float *B, const int *ldb, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment spftrs_$address() {
        return spftrs_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void spftrs_(const char *transr, const char *uplo, const int *n, const int *nrhs, const float *A, float *B, const int *ldb, int *info, size_t, size_t)
     * }
     */
    public static void spftrs_(MemorySegment transr, MemorySegment uplo, MemorySegment n, MemorySegment nrhs, MemorySegment A, MemorySegment B, MemorySegment ldb, MemorySegment info, long x8, long x9) {
        var mh$ = spftrs_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("spftrs_", transr, uplo, n, nrhs, A, B, ldb, info, x8, x9);
            }
            mh$.invokeExact(transr, uplo, n, nrhs, A, B, ldb, info, x8, x9);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zpftrs_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("zpftrs_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zpftrs_(const char *transr, const char *uplo, const int *n, const int *nrhs, const _Complex double *A, _Complex double *B, const int *ldb, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor zpftrs_$descriptor() {
        return zpftrs_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zpftrs_(const char *transr, const char *uplo, const int *n, const int *nrhs, const _Complex double *A, _Complex double *B, const int *ldb, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle zpftrs_$handle() {
        return zpftrs_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zpftrs_(const char *transr, const char *uplo, const int *n, const int *nrhs, const _Complex double *A, _Complex double *B, const int *ldb, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment zpftrs_$address() {
        return zpftrs_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zpftrs_(const char *transr, const char *uplo, const int *n, const int *nrhs, const _Complex double *A, _Complex double *B, const int *ldb, int *info, size_t, size_t)
     * }
     */
    public static void zpftrs_(MemorySegment transr, MemorySegment uplo, MemorySegment n, MemorySegment nrhs, MemorySegment A, MemorySegment B, MemorySegment ldb, MemorySegment info, long x8, long x9) {
        var mh$ = zpftrs_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zpftrs_", transr, uplo, n, nrhs, A, B, ldb, info, x8, x9);
            }
            mh$.invokeExact(transr, uplo, n, nrhs, A, B, ldb, info, x8, x9);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cpocon_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cpocon_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cpocon_(const char *uplo, const int *n, const _Complex float *A, const int *lda, const float *anorm, float *rcond, _Complex float *work, float *rwork, int *info, size_t)
     * }
     */
    public static FunctionDescriptor cpocon_$descriptor() {
        return cpocon_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cpocon_(const char *uplo, const int *n, const _Complex float *A, const int *lda, const float *anorm, float *rcond, _Complex float *work, float *rwork, int *info, size_t)
     * }
     */
    public static MethodHandle cpocon_$handle() {
        return cpocon_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cpocon_(const char *uplo, const int *n, const _Complex float *A, const int *lda, const float *anorm, float *rcond, _Complex float *work, float *rwork, int *info, size_t)
     * }
     */
    public static MemorySegment cpocon_$address() {
        return cpocon_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cpocon_(const char *uplo, const int *n, const _Complex float *A, const int *lda, const float *anorm, float *rcond, _Complex float *work, float *rwork, int *info, size_t)
     * }
     */
    public static void cpocon_(MemorySegment uplo, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment anorm, MemorySegment rcond, MemorySegment work, MemorySegment rwork, MemorySegment info, long x9) {
        var mh$ = cpocon_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cpocon_", uplo, n, A, lda, anorm, rcond, work, rwork, info, x9);
            }
            mh$.invokeExact(uplo, n, A, lda, anorm, rcond, work, rwork, info, x9);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dpocon_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("dpocon_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dpocon_(const char *uplo, const int *n, const double *A, const int *lda, const double *anorm, double *rcond, double *work, int *iwork, int *info, size_t)
     * }
     */
    public static FunctionDescriptor dpocon_$descriptor() {
        return dpocon_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dpocon_(const char *uplo, const int *n, const double *A, const int *lda, const double *anorm, double *rcond, double *work, int *iwork, int *info, size_t)
     * }
     */
    public static MethodHandle dpocon_$handle() {
        return dpocon_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dpocon_(const char *uplo, const int *n, const double *A, const int *lda, const double *anorm, double *rcond, double *work, int *iwork, int *info, size_t)
     * }
     */
    public static MemorySegment dpocon_$address() {
        return dpocon_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dpocon_(const char *uplo, const int *n, const double *A, const int *lda, const double *anorm, double *rcond, double *work, int *iwork, int *info, size_t)
     * }
     */
    public static void dpocon_(MemorySegment uplo, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment anorm, MemorySegment rcond, MemorySegment work, MemorySegment iwork, MemorySegment info, long x9) {
        var mh$ = dpocon_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dpocon_", uplo, n, A, lda, anorm, rcond, work, iwork, info, x9);
            }
            mh$.invokeExact(uplo, n, A, lda, anorm, rcond, work, iwork, info, x9);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class spocon_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("spocon_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void spocon_(const char *uplo, const int *n, const float *A, const int *lda, const float *anorm, float *rcond, float *work, int *iwork, int *info, size_t)
     * }
     */
    public static FunctionDescriptor spocon_$descriptor() {
        return spocon_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void spocon_(const char *uplo, const int *n, const float *A, const int *lda, const float *anorm, float *rcond, float *work, int *iwork, int *info, size_t)
     * }
     */
    public static MethodHandle spocon_$handle() {
        return spocon_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void spocon_(const char *uplo, const int *n, const float *A, const int *lda, const float *anorm, float *rcond, float *work, int *iwork, int *info, size_t)
     * }
     */
    public static MemorySegment spocon_$address() {
        return spocon_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void spocon_(const char *uplo, const int *n, const float *A, const int *lda, const float *anorm, float *rcond, float *work, int *iwork, int *info, size_t)
     * }
     */
    public static void spocon_(MemorySegment uplo, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment anorm, MemorySegment rcond, MemorySegment work, MemorySegment iwork, MemorySegment info, long x9) {
        var mh$ = spocon_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("spocon_", uplo, n, A, lda, anorm, rcond, work, iwork, info, x9);
            }
            mh$.invokeExact(uplo, n, A, lda, anorm, rcond, work, iwork, info, x9);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zpocon_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("zpocon_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zpocon_(const char *uplo, const int *n, const _Complex double *A, const int *lda, const double *anorm, double *rcond, _Complex double *work, double *rwork, int *info, size_t)
     * }
     */
    public static FunctionDescriptor zpocon_$descriptor() {
        return zpocon_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zpocon_(const char *uplo, const int *n, const _Complex double *A, const int *lda, const double *anorm, double *rcond, _Complex double *work, double *rwork, int *info, size_t)
     * }
     */
    public static MethodHandle zpocon_$handle() {
        return zpocon_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zpocon_(const char *uplo, const int *n, const _Complex double *A, const int *lda, const double *anorm, double *rcond, _Complex double *work, double *rwork, int *info, size_t)
     * }
     */
    public static MemorySegment zpocon_$address() {
        return zpocon_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zpocon_(const char *uplo, const int *n, const _Complex double *A, const int *lda, const double *anorm, double *rcond, _Complex double *work, double *rwork, int *info, size_t)
     * }
     */
    public static void zpocon_(MemorySegment uplo, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment anorm, MemorySegment rcond, MemorySegment work, MemorySegment rwork, MemorySegment info, long x9) {
        var mh$ = zpocon_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zpocon_", uplo, n, A, lda, anorm, rcond, work, rwork, info, x9);
            }
            mh$.invokeExact(uplo, n, A, lda, anorm, rcond, work, rwork, info, x9);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cpoequ_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cpoequ_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cpoequ_(const int *n, const _Complex float *A, const int *lda, float *S, float *scond, float *amax, int *info)
     * }
     */
    public static FunctionDescriptor cpoequ_$descriptor() {
        return cpoequ_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cpoequ_(const int *n, const _Complex float *A, const int *lda, float *S, float *scond, float *amax, int *info)
     * }
     */
    public static MethodHandle cpoequ_$handle() {
        return cpoequ_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cpoequ_(const int *n, const _Complex float *A, const int *lda, float *S, float *scond, float *amax, int *info)
     * }
     */
    public static MemorySegment cpoequ_$address() {
        return cpoequ_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cpoequ_(const int *n, const _Complex float *A, const int *lda, float *S, float *scond, float *amax, int *info)
     * }
     */
    public static void cpoequ_(MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment S, MemorySegment scond, MemorySegment amax, MemorySegment info) {
        var mh$ = cpoequ_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cpoequ_", n, A, lda, S, scond, amax, info);
            }
            mh$.invokeExact(n, A, lda, S, scond, amax, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dpoequ_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("dpoequ_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dpoequ_(const int *n, const double *A, const int *lda, double *S, double *scond, double *amax, int *info)
     * }
     */
    public static FunctionDescriptor dpoequ_$descriptor() {
        return dpoequ_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dpoequ_(const int *n, const double *A, const int *lda, double *S, double *scond, double *amax, int *info)
     * }
     */
    public static MethodHandle dpoequ_$handle() {
        return dpoequ_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dpoequ_(const int *n, const double *A, const int *lda, double *S, double *scond, double *amax, int *info)
     * }
     */
    public static MemorySegment dpoequ_$address() {
        return dpoequ_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dpoequ_(const int *n, const double *A, const int *lda, double *S, double *scond, double *amax, int *info)
     * }
     */
    public static void dpoequ_(MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment S, MemorySegment scond, MemorySegment amax, MemorySegment info) {
        var mh$ = dpoequ_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dpoequ_", n, A, lda, S, scond, amax, info);
            }
            mh$.invokeExact(n, A, lda, S, scond, amax, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class spoequ_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("spoequ_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void spoequ_(const int *n, const float *A, const int *lda, float *S, float *scond, float *amax, int *info)
     * }
     */
    public static FunctionDescriptor spoequ_$descriptor() {
        return spoequ_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void spoequ_(const int *n, const float *A, const int *lda, float *S, float *scond, float *amax, int *info)
     * }
     */
    public static MethodHandle spoequ_$handle() {
        return spoequ_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void spoequ_(const int *n, const float *A, const int *lda, float *S, float *scond, float *amax, int *info)
     * }
     */
    public static MemorySegment spoequ_$address() {
        return spoequ_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void spoequ_(const int *n, const float *A, const int *lda, float *S, float *scond, float *amax, int *info)
     * }
     */
    public static void spoequ_(MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment S, MemorySegment scond, MemorySegment amax, MemorySegment info) {
        var mh$ = spoequ_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("spoequ_", n, A, lda, S, scond, amax, info);
            }
            mh$.invokeExact(n, A, lda, S, scond, amax, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zpoequ_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("zpoequ_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zpoequ_(const int *n, const _Complex double *A, const int *lda, double *S, double *scond, double *amax, int *info)
     * }
     */
    public static FunctionDescriptor zpoequ_$descriptor() {
        return zpoequ_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zpoequ_(const int *n, const _Complex double *A, const int *lda, double *S, double *scond, double *amax, int *info)
     * }
     */
    public static MethodHandle zpoequ_$handle() {
        return zpoequ_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zpoequ_(const int *n, const _Complex double *A, const int *lda, double *S, double *scond, double *amax, int *info)
     * }
     */
    public static MemorySegment zpoequ_$address() {
        return zpoequ_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zpoequ_(const int *n, const _Complex double *A, const int *lda, double *S, double *scond, double *amax, int *info)
     * }
     */
    public static void zpoequ_(MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment S, MemorySegment scond, MemorySegment amax, MemorySegment info) {
        var mh$ = zpoequ_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zpoequ_", n, A, lda, S, scond, amax, info);
            }
            mh$.invokeExact(n, A, lda, S, scond, amax, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cpoequb_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cpoequb_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cpoequb_(const int *n, const _Complex float *A, const int *lda, float *S, float *scond, float *amax, int *info)
     * }
     */
    public static FunctionDescriptor cpoequb_$descriptor() {
        return cpoequb_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cpoequb_(const int *n, const _Complex float *A, const int *lda, float *S, float *scond, float *amax, int *info)
     * }
     */
    public static MethodHandle cpoequb_$handle() {
        return cpoequb_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cpoequb_(const int *n, const _Complex float *A, const int *lda, float *S, float *scond, float *amax, int *info)
     * }
     */
    public static MemorySegment cpoequb_$address() {
        return cpoequb_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cpoequb_(const int *n, const _Complex float *A, const int *lda, float *S, float *scond, float *amax, int *info)
     * }
     */
    public static void cpoequb_(MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment S, MemorySegment scond, MemorySegment amax, MemorySegment info) {
        var mh$ = cpoequb_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cpoequb_", n, A, lda, S, scond, amax, info);
            }
            mh$.invokeExact(n, A, lda, S, scond, amax, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dpoequb_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("dpoequb_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dpoequb_(const int *n, const double *A, const int *lda, double *S, double *scond, double *amax, int *info)
     * }
     */
    public static FunctionDescriptor dpoequb_$descriptor() {
        return dpoequb_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dpoequb_(const int *n, const double *A, const int *lda, double *S, double *scond, double *amax, int *info)
     * }
     */
    public static MethodHandle dpoequb_$handle() {
        return dpoequb_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dpoequb_(const int *n, const double *A, const int *lda, double *S, double *scond, double *amax, int *info)
     * }
     */
    public static MemorySegment dpoequb_$address() {
        return dpoequb_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dpoequb_(const int *n, const double *A, const int *lda, double *S, double *scond, double *amax, int *info)
     * }
     */
    public static void dpoequb_(MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment S, MemorySegment scond, MemorySegment amax, MemorySegment info) {
        var mh$ = dpoequb_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dpoequb_", n, A, lda, S, scond, amax, info);
            }
            mh$.invokeExact(n, A, lda, S, scond, amax, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class spoequb_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("spoequb_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void spoequb_(const int *n, const float *A, const int *lda, float *S, float *scond, float *amax, int *info)
     * }
     */
    public static FunctionDescriptor spoequb_$descriptor() {
        return spoequb_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void spoequb_(const int *n, const float *A, const int *lda, float *S, float *scond, float *amax, int *info)
     * }
     */
    public static MethodHandle spoequb_$handle() {
        return spoequb_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void spoequb_(const int *n, const float *A, const int *lda, float *S, float *scond, float *amax, int *info)
     * }
     */
    public static MemorySegment spoequb_$address() {
        return spoequb_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void spoequb_(const int *n, const float *A, const int *lda, float *S, float *scond, float *amax, int *info)
     * }
     */
    public static void spoequb_(MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment S, MemorySegment scond, MemorySegment amax, MemorySegment info) {
        var mh$ = spoequb_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("spoequb_", n, A, lda, S, scond, amax, info);
            }
            mh$.invokeExact(n, A, lda, S, scond, amax, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zpoequb_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("zpoequb_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zpoequb_(const int *n, const _Complex double *A, const int *lda, double *S, double *scond, double *amax, int *info)
     * }
     */
    public static FunctionDescriptor zpoequb_$descriptor() {
        return zpoequb_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zpoequb_(const int *n, const _Complex double *A, const int *lda, double *S, double *scond, double *amax, int *info)
     * }
     */
    public static MethodHandle zpoequb_$handle() {
        return zpoequb_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zpoequb_(const int *n, const _Complex double *A, const int *lda, double *S, double *scond, double *amax, int *info)
     * }
     */
    public static MemorySegment zpoequb_$address() {
        return zpoequb_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zpoequb_(const int *n, const _Complex double *A, const int *lda, double *S, double *scond, double *amax, int *info)
     * }
     */
    public static void zpoequb_(MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment S, MemorySegment scond, MemorySegment amax, MemorySegment info) {
        var mh$ = zpoequb_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zpoequb_", n, A, lda, S, scond, amax, info);
            }
            mh$.invokeExact(n, A, lda, S, scond, amax, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cporfs_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cporfs_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cporfs_(const char *uplo, const int *n, const int *nrhs, const _Complex float *A, const int *lda, const _Complex float *AF, const int *ldaf, const _Complex float *B, const int *ldb, _Complex float *X, const int *ldx, float *ferr, float *berr, _Complex float *work, float *rwork, int *info, size_t)
     * }
     */
    public static FunctionDescriptor cporfs_$descriptor() {
        return cporfs_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cporfs_(const char *uplo, const int *n, const int *nrhs, const _Complex float *A, const int *lda, const _Complex float *AF, const int *ldaf, const _Complex float *B, const int *ldb, _Complex float *X, const int *ldx, float *ferr, float *berr, _Complex float *work, float *rwork, int *info, size_t)
     * }
     */
    public static MethodHandle cporfs_$handle() {
        return cporfs_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cporfs_(const char *uplo, const int *n, const int *nrhs, const _Complex float *A, const int *lda, const _Complex float *AF, const int *ldaf, const _Complex float *B, const int *ldb, _Complex float *X, const int *ldx, float *ferr, float *berr, _Complex float *work, float *rwork, int *info, size_t)
     * }
     */
    public static MemorySegment cporfs_$address() {
        return cporfs_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cporfs_(const char *uplo, const int *n, const int *nrhs, const _Complex float *A, const int *lda, const _Complex float *AF, const int *ldaf, const _Complex float *B, const int *ldb, _Complex float *X, const int *ldx, float *ferr, float *berr, _Complex float *work, float *rwork, int *info, size_t)
     * }
     */
    public static void cporfs_(MemorySegment uplo, MemorySegment n, MemorySegment nrhs, MemorySegment A, MemorySegment lda, MemorySegment AF, MemorySegment ldaf, MemorySegment B, MemorySegment ldb, MemorySegment X, MemorySegment ldx, MemorySegment ferr, MemorySegment berr, MemorySegment work, MemorySegment rwork, MemorySegment info, long x16) {
        var mh$ = cporfs_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cporfs_", uplo, n, nrhs, A, lda, AF, ldaf, B, ldb, X, ldx, ferr, berr, work, rwork, info, x16);
            }
            mh$.invokeExact(uplo, n, nrhs, A, lda, AF, ldaf, B, ldb, X, ldx, ferr, berr, work, rwork, info, x16);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dporfs_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("dporfs_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dporfs_(const char *uplo, const int *n, const int *nrhs, const double *A, const int *lda, const double *AF, const int *ldaf, const double *B, const int *ldb, double *X, const int *ldx, double *ferr, double *berr, double *work, int *iwork, int *info, size_t)
     * }
     */
    public static FunctionDescriptor dporfs_$descriptor() {
        return dporfs_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dporfs_(const char *uplo, const int *n, const int *nrhs, const double *A, const int *lda, const double *AF, const int *ldaf, const double *B, const int *ldb, double *X, const int *ldx, double *ferr, double *berr, double *work, int *iwork, int *info, size_t)
     * }
     */
    public static MethodHandle dporfs_$handle() {
        return dporfs_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dporfs_(const char *uplo, const int *n, const int *nrhs, const double *A, const int *lda, const double *AF, const int *ldaf, const double *B, const int *ldb, double *X, const int *ldx, double *ferr, double *berr, double *work, int *iwork, int *info, size_t)
     * }
     */
    public static MemorySegment dporfs_$address() {
        return dporfs_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dporfs_(const char *uplo, const int *n, const int *nrhs, const double *A, const int *lda, const double *AF, const int *ldaf, const double *B, const int *ldb, double *X, const int *ldx, double *ferr, double *berr, double *work, int *iwork, int *info, size_t)
     * }
     */
    public static void dporfs_(MemorySegment uplo, MemorySegment n, MemorySegment nrhs, MemorySegment A, MemorySegment lda, MemorySegment AF, MemorySegment ldaf, MemorySegment B, MemorySegment ldb, MemorySegment X, MemorySegment ldx, MemorySegment ferr, MemorySegment berr, MemorySegment work, MemorySegment iwork, MemorySegment info, long x16) {
        var mh$ = dporfs_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dporfs_", uplo, n, nrhs, A, lda, AF, ldaf, B, ldb, X, ldx, ferr, berr, work, iwork, info, x16);
            }
            mh$.invokeExact(uplo, n, nrhs, A, lda, AF, ldaf, B, ldb, X, ldx, ferr, berr, work, iwork, info, x16);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sporfs_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("sporfs_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void sporfs_(const char *uplo, const int *n, const int *nrhs, const float *A, const int *lda, const float *AF, const int *ldaf, const float *B, const int *ldb, float *X, const int *ldx, float *ferr, float *berr, float *work, int *iwork, int *info, size_t)
     * }
     */
    public static FunctionDescriptor sporfs_$descriptor() {
        return sporfs_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void sporfs_(const char *uplo, const int *n, const int *nrhs, const float *A, const int *lda, const float *AF, const int *ldaf, const float *B, const int *ldb, float *X, const int *ldx, float *ferr, float *berr, float *work, int *iwork, int *info, size_t)
     * }
     */
    public static MethodHandle sporfs_$handle() {
        return sporfs_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void sporfs_(const char *uplo, const int *n, const int *nrhs, const float *A, const int *lda, const float *AF, const int *ldaf, const float *B, const int *ldb, float *X, const int *ldx, float *ferr, float *berr, float *work, int *iwork, int *info, size_t)
     * }
     */
    public static MemorySegment sporfs_$address() {
        return sporfs_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void sporfs_(const char *uplo, const int *n, const int *nrhs, const float *A, const int *lda, const float *AF, const int *ldaf, const float *B, const int *ldb, float *X, const int *ldx, float *ferr, float *berr, float *work, int *iwork, int *info, size_t)
     * }
     */
    public static void sporfs_(MemorySegment uplo, MemorySegment n, MemorySegment nrhs, MemorySegment A, MemorySegment lda, MemorySegment AF, MemorySegment ldaf, MemorySegment B, MemorySegment ldb, MemorySegment X, MemorySegment ldx, MemorySegment ferr, MemorySegment berr, MemorySegment work, MemorySegment iwork, MemorySegment info, long x16) {
        var mh$ = sporfs_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sporfs_", uplo, n, nrhs, A, lda, AF, ldaf, B, ldb, X, ldx, ferr, berr, work, iwork, info, x16);
            }
            mh$.invokeExact(uplo, n, nrhs, A, lda, AF, ldaf, B, ldb, X, ldx, ferr, berr, work, iwork, info, x16);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zporfs_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("zporfs_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zporfs_(const char *uplo, const int *n, const int *nrhs, const _Complex double *A, const int *lda, const _Complex double *AF, const int *ldaf, const _Complex double *B, const int *ldb, _Complex double *X, const int *ldx, double *ferr, double *berr, _Complex double *work, double *rwork, int *info, size_t)
     * }
     */
    public static FunctionDescriptor zporfs_$descriptor() {
        return zporfs_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zporfs_(const char *uplo, const int *n, const int *nrhs, const _Complex double *A, const int *lda, const _Complex double *AF, const int *ldaf, const _Complex double *B, const int *ldb, _Complex double *X, const int *ldx, double *ferr, double *berr, _Complex double *work, double *rwork, int *info, size_t)
     * }
     */
    public static MethodHandle zporfs_$handle() {
        return zporfs_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zporfs_(const char *uplo, const int *n, const int *nrhs, const _Complex double *A, const int *lda, const _Complex double *AF, const int *ldaf, const _Complex double *B, const int *ldb, _Complex double *X, const int *ldx, double *ferr, double *berr, _Complex double *work, double *rwork, int *info, size_t)
     * }
     */
    public static MemorySegment zporfs_$address() {
        return zporfs_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zporfs_(const char *uplo, const int *n, const int *nrhs, const _Complex double *A, const int *lda, const _Complex double *AF, const int *ldaf, const _Complex double *B, const int *ldb, _Complex double *X, const int *ldx, double *ferr, double *berr, _Complex double *work, double *rwork, int *info, size_t)
     * }
     */
    public static void zporfs_(MemorySegment uplo, MemorySegment n, MemorySegment nrhs, MemorySegment A, MemorySegment lda, MemorySegment AF, MemorySegment ldaf, MemorySegment B, MemorySegment ldb, MemorySegment X, MemorySegment ldx, MemorySegment ferr, MemorySegment berr, MemorySegment work, MemorySegment rwork, MemorySegment info, long x16) {
        var mh$ = zporfs_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zporfs_", uplo, n, nrhs, A, lda, AF, ldaf, B, ldb, X, ldx, ferr, berr, work, rwork, info, x16);
            }
            mh$.invokeExact(uplo, n, nrhs, A, lda, AF, ldaf, B, ldb, X, ldx, ferr, berr, work, rwork, info, x16);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cporfsx_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cporfsx_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cporfsx_(const char *uplo, const char *equed, const int *n, const int *nrhs, const _Complex float *A, const int *lda, const _Complex float *AF, const int *ldaf, const float *S, const _Complex float *B, const int *ldb, _Complex float *X, const int *ldx, float *rcond, float *berr, const int *n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, const int *nparams, float *params, _Complex float *work, float *rwork, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor cporfsx_$descriptor() {
        return cporfsx_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cporfsx_(const char *uplo, const char *equed, const int *n, const int *nrhs, const _Complex float *A, const int *lda, const _Complex float *AF, const int *ldaf, const float *S, const _Complex float *B, const int *ldb, _Complex float *X, const int *ldx, float *rcond, float *berr, const int *n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, const int *nparams, float *params, _Complex float *work, float *rwork, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle cporfsx_$handle() {
        return cporfsx_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cporfsx_(const char *uplo, const char *equed, const int *n, const int *nrhs, const _Complex float *A, const int *lda, const _Complex float *AF, const int *ldaf, const float *S, const _Complex float *B, const int *ldb, _Complex float *X, const int *ldx, float *rcond, float *berr, const int *n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, const int *nparams, float *params, _Complex float *work, float *rwork, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment cporfsx_$address() {
        return cporfsx_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cporfsx_(const char *uplo, const char *equed, const int *n, const int *nrhs, const _Complex float *A, const int *lda, const _Complex float *AF, const int *ldaf, const float *S, const _Complex float *B, const int *ldb, _Complex float *X, const int *ldx, float *rcond, float *berr, const int *n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, const int *nparams, float *params, _Complex float *work, float *rwork, int *info, size_t, size_t)
     * }
     */
    public static void cporfsx_(MemorySegment uplo, MemorySegment equed, MemorySegment n, MemorySegment nrhs, MemorySegment A, MemorySegment lda, MemorySegment AF, MemorySegment ldaf, MemorySegment S, MemorySegment B, MemorySegment ldb, MemorySegment X, MemorySegment ldx, MemorySegment rcond, MemorySegment berr, MemorySegment n_err_bnds, MemorySegment err_bnds_norm, MemorySegment err_bnds_comp, MemorySegment nparams, MemorySegment params, MemorySegment work, MemorySegment rwork, MemorySegment info, long x23, long x24) {
        var mh$ = cporfsx_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cporfsx_", uplo, equed, n, nrhs, A, lda, AF, ldaf, S, B, ldb, X, ldx, rcond, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params, work, rwork, info, x23, x24);
            }
            mh$.invokeExact(uplo, equed, n, nrhs, A, lda, AF, ldaf, S, B, ldb, X, ldx, rcond, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params, work, rwork, info, x23, x24);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dporfsx_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("dporfsx_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dporfsx_(const char *uplo, const char *equed, const int *n, const int *nrhs, const double *A, const int *lda, const double *AF, const int *ldaf, const double *S, const double *B, const int *ldb, double *X, const int *ldx, double *rcond, double *berr, const int *n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, const int *nparams, double *params, double *work, int *iwork, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor dporfsx_$descriptor() {
        return dporfsx_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dporfsx_(const char *uplo, const char *equed, const int *n, const int *nrhs, const double *A, const int *lda, const double *AF, const int *ldaf, const double *S, const double *B, const int *ldb, double *X, const int *ldx, double *rcond, double *berr, const int *n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, const int *nparams, double *params, double *work, int *iwork, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle dporfsx_$handle() {
        return dporfsx_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dporfsx_(const char *uplo, const char *equed, const int *n, const int *nrhs, const double *A, const int *lda, const double *AF, const int *ldaf, const double *S, const double *B, const int *ldb, double *X, const int *ldx, double *rcond, double *berr, const int *n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, const int *nparams, double *params, double *work, int *iwork, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment dporfsx_$address() {
        return dporfsx_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dporfsx_(const char *uplo, const char *equed, const int *n, const int *nrhs, const double *A, const int *lda, const double *AF, const int *ldaf, const double *S, const double *B, const int *ldb, double *X, const int *ldx, double *rcond, double *berr, const int *n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, const int *nparams, double *params, double *work, int *iwork, int *info, size_t, size_t)
     * }
     */
    public static void dporfsx_(MemorySegment uplo, MemorySegment equed, MemorySegment n, MemorySegment nrhs, MemorySegment A, MemorySegment lda, MemorySegment AF, MemorySegment ldaf, MemorySegment S, MemorySegment B, MemorySegment ldb, MemorySegment X, MemorySegment ldx, MemorySegment rcond, MemorySegment berr, MemorySegment n_err_bnds, MemorySegment err_bnds_norm, MemorySegment err_bnds_comp, MemorySegment nparams, MemorySegment params, MemorySegment work, MemorySegment iwork, MemorySegment info, long x23, long x24) {
        var mh$ = dporfsx_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dporfsx_", uplo, equed, n, nrhs, A, lda, AF, ldaf, S, B, ldb, X, ldx, rcond, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params, work, iwork, info, x23, x24);
            }
            mh$.invokeExact(uplo, equed, n, nrhs, A, lda, AF, ldaf, S, B, ldb, X, ldx, rcond, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params, work, iwork, info, x23, x24);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sporfsx_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("sporfsx_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void sporfsx_(const char *uplo, const char *equed, const int *n, const int *nrhs, const float *A, const int *lda, const float *AF, const int *ldaf, const float *S, const float *B, const int *ldb, float *X, const int *ldx, float *rcond, float *berr, const int *n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, const int *nparams, float *params, float *work, int *iwork, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor sporfsx_$descriptor() {
        return sporfsx_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void sporfsx_(const char *uplo, const char *equed, const int *n, const int *nrhs, const float *A, const int *lda, const float *AF, const int *ldaf, const float *S, const float *B, const int *ldb, float *X, const int *ldx, float *rcond, float *berr, const int *n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, const int *nparams, float *params, float *work, int *iwork, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle sporfsx_$handle() {
        return sporfsx_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void sporfsx_(const char *uplo, const char *equed, const int *n, const int *nrhs, const float *A, const int *lda, const float *AF, const int *ldaf, const float *S, const float *B, const int *ldb, float *X, const int *ldx, float *rcond, float *berr, const int *n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, const int *nparams, float *params, float *work, int *iwork, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment sporfsx_$address() {
        return sporfsx_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void sporfsx_(const char *uplo, const char *equed, const int *n, const int *nrhs, const float *A, const int *lda, const float *AF, const int *ldaf, const float *S, const float *B, const int *ldb, float *X, const int *ldx, float *rcond, float *berr, const int *n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, const int *nparams, float *params, float *work, int *iwork, int *info, size_t, size_t)
     * }
     */
    public static void sporfsx_(MemorySegment uplo, MemorySegment equed, MemorySegment n, MemorySegment nrhs, MemorySegment A, MemorySegment lda, MemorySegment AF, MemorySegment ldaf, MemorySegment S, MemorySegment B, MemorySegment ldb, MemorySegment X, MemorySegment ldx, MemorySegment rcond, MemorySegment berr, MemorySegment n_err_bnds, MemorySegment err_bnds_norm, MemorySegment err_bnds_comp, MemorySegment nparams, MemorySegment params, MemorySegment work, MemorySegment iwork, MemorySegment info, long x23, long x24) {
        var mh$ = sporfsx_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sporfsx_", uplo, equed, n, nrhs, A, lda, AF, ldaf, S, B, ldb, X, ldx, rcond, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params, work, iwork, info, x23, x24);
            }
            mh$.invokeExact(uplo, equed, n, nrhs, A, lda, AF, ldaf, S, B, ldb, X, ldx, rcond, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params, work, iwork, info, x23, x24);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zporfsx_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("zporfsx_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zporfsx_(const char *uplo, const char *equed, const int *n, const int *nrhs, const _Complex double *A, const int *lda, const _Complex double *AF, const int *ldaf, const double *S, const _Complex double *B, const int *ldb, _Complex double *X, const int *ldx, double *rcond, double *berr, const int *n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, const int *nparams, double *params, _Complex double *work, double *rwork, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor zporfsx_$descriptor() {
        return zporfsx_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zporfsx_(const char *uplo, const char *equed, const int *n, const int *nrhs, const _Complex double *A, const int *lda, const _Complex double *AF, const int *ldaf, const double *S, const _Complex double *B, const int *ldb, _Complex double *X, const int *ldx, double *rcond, double *berr, const int *n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, const int *nparams, double *params, _Complex double *work, double *rwork, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle zporfsx_$handle() {
        return zporfsx_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zporfsx_(const char *uplo, const char *equed, const int *n, const int *nrhs, const _Complex double *A, const int *lda, const _Complex double *AF, const int *ldaf, const double *S, const _Complex double *B, const int *ldb, _Complex double *X, const int *ldx, double *rcond, double *berr, const int *n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, const int *nparams, double *params, _Complex double *work, double *rwork, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment zporfsx_$address() {
        return zporfsx_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zporfsx_(const char *uplo, const char *equed, const int *n, const int *nrhs, const _Complex double *A, const int *lda, const _Complex double *AF, const int *ldaf, const double *S, const _Complex double *B, const int *ldb, _Complex double *X, const int *ldx, double *rcond, double *berr, const int *n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, const int *nparams, double *params, _Complex double *work, double *rwork, int *info, size_t, size_t)
     * }
     */
    public static void zporfsx_(MemorySegment uplo, MemorySegment equed, MemorySegment n, MemorySegment nrhs, MemorySegment A, MemorySegment lda, MemorySegment AF, MemorySegment ldaf, MemorySegment S, MemorySegment B, MemorySegment ldb, MemorySegment X, MemorySegment ldx, MemorySegment rcond, MemorySegment berr, MemorySegment n_err_bnds, MemorySegment err_bnds_norm, MemorySegment err_bnds_comp, MemorySegment nparams, MemorySegment params, MemorySegment work, MemorySegment rwork, MemorySegment info, long x23, long x24) {
        var mh$ = zporfsx_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zporfsx_", uplo, equed, n, nrhs, A, lda, AF, ldaf, S, B, ldb, X, ldx, rcond, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params, work, rwork, info, x23, x24);
            }
            mh$.invokeExact(uplo, equed, n, nrhs, A, lda, AF, ldaf, S, B, ldb, X, ldx, rcond, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params, work, rwork, info, x23, x24);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cposv_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cposv_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cposv_(const char *uplo, const int *n, const int *nrhs, _Complex float *A, const int *lda, _Complex float *B, const int *ldb, int *info, size_t)
     * }
     */
    public static FunctionDescriptor cposv_$descriptor() {
        return cposv_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cposv_(const char *uplo, const int *n, const int *nrhs, _Complex float *A, const int *lda, _Complex float *B, const int *ldb, int *info, size_t)
     * }
     */
    public static MethodHandle cposv_$handle() {
        return cposv_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cposv_(const char *uplo, const int *n, const int *nrhs, _Complex float *A, const int *lda, _Complex float *B, const int *ldb, int *info, size_t)
     * }
     */
    public static MemorySegment cposv_$address() {
        return cposv_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cposv_(const char *uplo, const int *n, const int *nrhs, _Complex float *A, const int *lda, _Complex float *B, const int *ldb, int *info, size_t)
     * }
     */
    public static void cposv_(MemorySegment uplo, MemorySegment n, MemorySegment nrhs, MemorySegment A, MemorySegment lda, MemorySegment B, MemorySegment ldb, MemorySegment info, long x8) {
        var mh$ = cposv_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cposv_", uplo, n, nrhs, A, lda, B, ldb, info, x8);
            }
            mh$.invokeExact(uplo, n, nrhs, A, lda, B, ldb, info, x8);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dposv_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("dposv_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dposv_(const char *uplo, const int *n, const int *nrhs, double *A, const int *lda, double *B, const int *ldb, int *info, size_t)
     * }
     */
    public static FunctionDescriptor dposv_$descriptor() {
        return dposv_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dposv_(const char *uplo, const int *n, const int *nrhs, double *A, const int *lda, double *B, const int *ldb, int *info, size_t)
     * }
     */
    public static MethodHandle dposv_$handle() {
        return dposv_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dposv_(const char *uplo, const int *n, const int *nrhs, double *A, const int *lda, double *B, const int *ldb, int *info, size_t)
     * }
     */
    public static MemorySegment dposv_$address() {
        return dposv_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dposv_(const char *uplo, const int *n, const int *nrhs, double *A, const int *lda, double *B, const int *ldb, int *info, size_t)
     * }
     */
    public static void dposv_(MemorySegment uplo, MemorySegment n, MemorySegment nrhs, MemorySegment A, MemorySegment lda, MemorySegment B, MemorySegment ldb, MemorySegment info, long x8) {
        var mh$ = dposv_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dposv_", uplo, n, nrhs, A, lda, B, ldb, info, x8);
            }
            mh$.invokeExact(uplo, n, nrhs, A, lda, B, ldb, info, x8);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sposv_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("sposv_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void sposv_(const char *uplo, const int *n, const int *nrhs, float *A, const int *lda, float *B, const int *ldb, int *info, size_t)
     * }
     */
    public static FunctionDescriptor sposv_$descriptor() {
        return sposv_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void sposv_(const char *uplo, const int *n, const int *nrhs, float *A, const int *lda, float *B, const int *ldb, int *info, size_t)
     * }
     */
    public static MethodHandle sposv_$handle() {
        return sposv_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void sposv_(const char *uplo, const int *n, const int *nrhs, float *A, const int *lda, float *B, const int *ldb, int *info, size_t)
     * }
     */
    public static MemorySegment sposv_$address() {
        return sposv_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void sposv_(const char *uplo, const int *n, const int *nrhs, float *A, const int *lda, float *B, const int *ldb, int *info, size_t)
     * }
     */
    public static void sposv_(MemorySegment uplo, MemorySegment n, MemorySegment nrhs, MemorySegment A, MemorySegment lda, MemorySegment B, MemorySegment ldb, MemorySegment info, long x8) {
        var mh$ = sposv_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sposv_", uplo, n, nrhs, A, lda, B, ldb, info, x8);
            }
            mh$.invokeExact(uplo, n, nrhs, A, lda, B, ldb, info, x8);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zposv_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("zposv_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zposv_(const char *uplo, const int *n, const int *nrhs, _Complex double *A, const int *lda, _Complex double *B, const int *ldb, int *info, size_t)
     * }
     */
    public static FunctionDescriptor zposv_$descriptor() {
        return zposv_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zposv_(const char *uplo, const int *n, const int *nrhs, _Complex double *A, const int *lda, _Complex double *B, const int *ldb, int *info, size_t)
     * }
     */
    public static MethodHandle zposv_$handle() {
        return zposv_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zposv_(const char *uplo, const int *n, const int *nrhs, _Complex double *A, const int *lda, _Complex double *B, const int *ldb, int *info, size_t)
     * }
     */
    public static MemorySegment zposv_$address() {
        return zposv_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zposv_(const char *uplo, const int *n, const int *nrhs, _Complex double *A, const int *lda, _Complex double *B, const int *ldb, int *info, size_t)
     * }
     */
    public static void zposv_(MemorySegment uplo, MemorySegment n, MemorySegment nrhs, MemorySegment A, MemorySegment lda, MemorySegment B, MemorySegment ldb, MemorySegment info, long x8) {
        var mh$ = zposv_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zposv_", uplo, n, nrhs, A, lda, B, ldb, info, x8);
            }
            mh$.invokeExact(uplo, n, nrhs, A, lda, B, ldb, info, x8);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dsposv_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("dsposv_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dsposv_(const char *uplo, const int *n, const int *nrhs, double *A, const int *lda, const double *B, const int *ldb, double *X, const int *ldx, double *work, float *swork, int *iter, int *info, size_t)
     * }
     */
    public static FunctionDescriptor dsposv_$descriptor() {
        return dsposv_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dsposv_(const char *uplo, const int *n, const int *nrhs, double *A, const int *lda, const double *B, const int *ldb, double *X, const int *ldx, double *work, float *swork, int *iter, int *info, size_t)
     * }
     */
    public static MethodHandle dsposv_$handle() {
        return dsposv_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dsposv_(const char *uplo, const int *n, const int *nrhs, double *A, const int *lda, const double *B, const int *ldb, double *X, const int *ldx, double *work, float *swork, int *iter, int *info, size_t)
     * }
     */
    public static MemorySegment dsposv_$address() {
        return dsposv_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dsposv_(const char *uplo, const int *n, const int *nrhs, double *A, const int *lda, const double *B, const int *ldb, double *X, const int *ldx, double *work, float *swork, int *iter, int *info, size_t)
     * }
     */
    public static void dsposv_(MemorySegment uplo, MemorySegment n, MemorySegment nrhs, MemorySegment A, MemorySegment lda, MemorySegment B, MemorySegment ldb, MemorySegment X, MemorySegment ldx, MemorySegment work, MemorySegment swork, MemorySegment iter, MemorySegment info, long x13) {
        var mh$ = dsposv_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dsposv_", uplo, n, nrhs, A, lda, B, ldb, X, ldx, work, swork, iter, info, x13);
            }
            mh$.invokeExact(uplo, n, nrhs, A, lda, B, ldb, X, ldx, work, swork, iter, info, x13);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zcposv_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("zcposv_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zcposv_(const char *uplo, const int *n, const int *nrhs, _Complex double *A, const int *lda, const _Complex double *B, const int *ldb, _Complex double *X, const int *ldx, _Complex double *work, _Complex float *swork, double *rwork, int *iter, int *info, size_t)
     * }
     */
    public static FunctionDescriptor zcposv_$descriptor() {
        return zcposv_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zcposv_(const char *uplo, const int *n, const int *nrhs, _Complex double *A, const int *lda, const _Complex double *B, const int *ldb, _Complex double *X, const int *ldx, _Complex double *work, _Complex float *swork, double *rwork, int *iter, int *info, size_t)
     * }
     */
    public static MethodHandle zcposv_$handle() {
        return zcposv_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zcposv_(const char *uplo, const int *n, const int *nrhs, _Complex double *A, const int *lda, const _Complex double *B, const int *ldb, _Complex double *X, const int *ldx, _Complex double *work, _Complex float *swork, double *rwork, int *iter, int *info, size_t)
     * }
     */
    public static MemorySegment zcposv_$address() {
        return zcposv_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zcposv_(const char *uplo, const int *n, const int *nrhs, _Complex double *A, const int *lda, const _Complex double *B, const int *ldb, _Complex double *X, const int *ldx, _Complex double *work, _Complex float *swork, double *rwork, int *iter, int *info, size_t)
     * }
     */
    public static void zcposv_(MemorySegment uplo, MemorySegment n, MemorySegment nrhs, MemorySegment A, MemorySegment lda, MemorySegment B, MemorySegment ldb, MemorySegment X, MemorySegment ldx, MemorySegment work, MemorySegment swork, MemorySegment rwork, MemorySegment iter, MemorySegment info, long x14) {
        var mh$ = zcposv_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zcposv_", uplo, n, nrhs, A, lda, B, ldb, X, ldx, work, swork, rwork, iter, info, x14);
            }
            mh$.invokeExact(uplo, n, nrhs, A, lda, B, ldb, X, ldx, work, swork, rwork, iter, info, x14);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cposvx_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cposvx_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cposvx_(const char *fact, const char *uplo, const int *n, const int *nrhs, _Complex float *A, const int *lda, _Complex float *AF, const int *ldaf, char *equed, float *S, _Complex float *B, const int *ldb, _Complex float *X, const int *ldx, float *rcond, float *ferr, float *berr, _Complex float *work, float *rwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor cposvx_$descriptor() {
        return cposvx_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cposvx_(const char *fact, const char *uplo, const int *n, const int *nrhs, _Complex float *A, const int *lda, _Complex float *AF, const int *ldaf, char *equed, float *S, _Complex float *B, const int *ldb, _Complex float *X, const int *ldx, float *rcond, float *ferr, float *berr, _Complex float *work, float *rwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle cposvx_$handle() {
        return cposvx_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cposvx_(const char *fact, const char *uplo, const int *n, const int *nrhs, _Complex float *A, const int *lda, _Complex float *AF, const int *ldaf, char *equed, float *S, _Complex float *B, const int *ldb, _Complex float *X, const int *ldx, float *rcond, float *ferr, float *berr, _Complex float *work, float *rwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment cposvx_$address() {
        return cposvx_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cposvx_(const char *fact, const char *uplo, const int *n, const int *nrhs, _Complex float *A, const int *lda, _Complex float *AF, const int *ldaf, char *equed, float *S, _Complex float *B, const int *ldb, _Complex float *X, const int *ldx, float *rcond, float *ferr, float *berr, _Complex float *work, float *rwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static void cposvx_(MemorySegment fact, MemorySegment uplo, MemorySegment n, MemorySegment nrhs, MemorySegment A, MemorySegment lda, MemorySegment AF, MemorySegment ldaf, MemorySegment equed, MemorySegment S, MemorySegment B, MemorySegment ldb, MemorySegment X, MemorySegment ldx, MemorySegment rcond, MemorySegment ferr, MemorySegment berr, MemorySegment work, MemorySegment rwork, MemorySegment info, long x20, long x21, long x22) {
        var mh$ = cposvx_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cposvx_", fact, uplo, n, nrhs, A, lda, AF, ldaf, equed, S, B, ldb, X, ldx, rcond, ferr, berr, work, rwork, info, x20, x21, x22);
            }
            mh$.invokeExact(fact, uplo, n, nrhs, A, lda, AF, ldaf, equed, S, B, ldb, X, ldx, rcond, ferr, berr, work, rwork, info, x20, x21, x22);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dposvx_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("dposvx_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dposvx_(const char *fact, const char *uplo, const int *n, const int *nrhs, double *A, const int *lda, double *AF, const int *ldaf, char *equed, double *S, double *B, const int *ldb, double *X, const int *ldx, double *rcond, double *ferr, double *berr, double *work, int *iwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor dposvx_$descriptor() {
        return dposvx_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dposvx_(const char *fact, const char *uplo, const int *n, const int *nrhs, double *A, const int *lda, double *AF, const int *ldaf, char *equed, double *S, double *B, const int *ldb, double *X, const int *ldx, double *rcond, double *ferr, double *berr, double *work, int *iwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle dposvx_$handle() {
        return dposvx_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dposvx_(const char *fact, const char *uplo, const int *n, const int *nrhs, double *A, const int *lda, double *AF, const int *ldaf, char *equed, double *S, double *B, const int *ldb, double *X, const int *ldx, double *rcond, double *ferr, double *berr, double *work, int *iwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment dposvx_$address() {
        return dposvx_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dposvx_(const char *fact, const char *uplo, const int *n, const int *nrhs, double *A, const int *lda, double *AF, const int *ldaf, char *equed, double *S, double *B, const int *ldb, double *X, const int *ldx, double *rcond, double *ferr, double *berr, double *work, int *iwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static void dposvx_(MemorySegment fact, MemorySegment uplo, MemorySegment n, MemorySegment nrhs, MemorySegment A, MemorySegment lda, MemorySegment AF, MemorySegment ldaf, MemorySegment equed, MemorySegment S, MemorySegment B, MemorySegment ldb, MemorySegment X, MemorySegment ldx, MemorySegment rcond, MemorySegment ferr, MemorySegment berr, MemorySegment work, MemorySegment iwork, MemorySegment info, long x20, long x21, long x22) {
        var mh$ = dposvx_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dposvx_", fact, uplo, n, nrhs, A, lda, AF, ldaf, equed, S, B, ldb, X, ldx, rcond, ferr, berr, work, iwork, info, x20, x21, x22);
            }
            mh$.invokeExact(fact, uplo, n, nrhs, A, lda, AF, ldaf, equed, S, B, ldb, X, ldx, rcond, ferr, berr, work, iwork, info, x20, x21, x22);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sposvx_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("sposvx_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void sposvx_(const char *fact, const char *uplo, const int *n, const int *nrhs, float *A, const int *lda, float *AF, const int *ldaf, char *equed, float *S, float *B, const int *ldb, float *X, const int *ldx, float *rcond, float *ferr, float *berr, float *work, int *iwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor sposvx_$descriptor() {
        return sposvx_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void sposvx_(const char *fact, const char *uplo, const int *n, const int *nrhs, float *A, const int *lda, float *AF, const int *ldaf, char *equed, float *S, float *B, const int *ldb, float *X, const int *ldx, float *rcond, float *ferr, float *berr, float *work, int *iwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle sposvx_$handle() {
        return sposvx_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void sposvx_(const char *fact, const char *uplo, const int *n, const int *nrhs, float *A, const int *lda, float *AF, const int *ldaf, char *equed, float *S, float *B, const int *ldb, float *X, const int *ldx, float *rcond, float *ferr, float *berr, float *work, int *iwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment sposvx_$address() {
        return sposvx_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void sposvx_(const char *fact, const char *uplo, const int *n, const int *nrhs, float *A, const int *lda, float *AF, const int *ldaf, char *equed, float *S, float *B, const int *ldb, float *X, const int *ldx, float *rcond, float *ferr, float *berr, float *work, int *iwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static void sposvx_(MemorySegment fact, MemorySegment uplo, MemorySegment n, MemorySegment nrhs, MemorySegment A, MemorySegment lda, MemorySegment AF, MemorySegment ldaf, MemorySegment equed, MemorySegment S, MemorySegment B, MemorySegment ldb, MemorySegment X, MemorySegment ldx, MemorySegment rcond, MemorySegment ferr, MemorySegment berr, MemorySegment work, MemorySegment iwork, MemorySegment info, long x20, long x21, long x22) {
        var mh$ = sposvx_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sposvx_", fact, uplo, n, nrhs, A, lda, AF, ldaf, equed, S, B, ldb, X, ldx, rcond, ferr, berr, work, iwork, info, x20, x21, x22);
            }
            mh$.invokeExact(fact, uplo, n, nrhs, A, lda, AF, ldaf, equed, S, B, ldb, X, ldx, rcond, ferr, berr, work, iwork, info, x20, x21, x22);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zposvx_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("zposvx_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zposvx_(const char *fact, const char *uplo, const int *n, const int *nrhs, _Complex double *A, const int *lda, _Complex double *AF, const int *ldaf, char *equed, double *S, _Complex double *B, const int *ldb, _Complex double *X, const int *ldx, double *rcond, double *ferr, double *berr, _Complex double *work, double *rwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor zposvx_$descriptor() {
        return zposvx_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zposvx_(const char *fact, const char *uplo, const int *n, const int *nrhs, _Complex double *A, const int *lda, _Complex double *AF, const int *ldaf, char *equed, double *S, _Complex double *B, const int *ldb, _Complex double *X, const int *ldx, double *rcond, double *ferr, double *berr, _Complex double *work, double *rwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle zposvx_$handle() {
        return zposvx_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zposvx_(const char *fact, const char *uplo, const int *n, const int *nrhs, _Complex double *A, const int *lda, _Complex double *AF, const int *ldaf, char *equed, double *S, _Complex double *B, const int *ldb, _Complex double *X, const int *ldx, double *rcond, double *ferr, double *berr, _Complex double *work, double *rwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment zposvx_$address() {
        return zposvx_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zposvx_(const char *fact, const char *uplo, const int *n, const int *nrhs, _Complex double *A, const int *lda, _Complex double *AF, const int *ldaf, char *equed, double *S, _Complex double *B, const int *ldb, _Complex double *X, const int *ldx, double *rcond, double *ferr, double *berr, _Complex double *work, double *rwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static void zposvx_(MemorySegment fact, MemorySegment uplo, MemorySegment n, MemorySegment nrhs, MemorySegment A, MemorySegment lda, MemorySegment AF, MemorySegment ldaf, MemorySegment equed, MemorySegment S, MemorySegment B, MemorySegment ldb, MemorySegment X, MemorySegment ldx, MemorySegment rcond, MemorySegment ferr, MemorySegment berr, MemorySegment work, MemorySegment rwork, MemorySegment info, long x20, long x21, long x22) {
        var mh$ = zposvx_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zposvx_", fact, uplo, n, nrhs, A, lda, AF, ldaf, equed, S, B, ldb, X, ldx, rcond, ferr, berr, work, rwork, info, x20, x21, x22);
            }
            mh$.invokeExact(fact, uplo, n, nrhs, A, lda, AF, ldaf, equed, S, B, ldb, X, ldx, rcond, ferr, berr, work, rwork, info, x20, x21, x22);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cposvxx_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cposvxx_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cposvxx_(const char *fact, const char *uplo, const int *n, const int *nrhs, _Complex float *A, const int *lda, _Complex float *AF, const int *ldaf, char *equed, float *S, _Complex float *B, const int *ldb, _Complex float *X, const int *ldx, float *rcond, float *rpvgrw, float *berr, const int *n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, const int *nparams, float *params, _Complex float *work, float *rwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor cposvxx_$descriptor() {
        return cposvxx_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cposvxx_(const char *fact, const char *uplo, const int *n, const int *nrhs, _Complex float *A, const int *lda, _Complex float *AF, const int *ldaf, char *equed, float *S, _Complex float *B, const int *ldb, _Complex float *X, const int *ldx, float *rcond, float *rpvgrw, float *berr, const int *n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, const int *nparams, float *params, _Complex float *work, float *rwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle cposvxx_$handle() {
        return cposvxx_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cposvxx_(const char *fact, const char *uplo, const int *n, const int *nrhs, _Complex float *A, const int *lda, _Complex float *AF, const int *ldaf, char *equed, float *S, _Complex float *B, const int *ldb, _Complex float *X, const int *ldx, float *rcond, float *rpvgrw, float *berr, const int *n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, const int *nparams, float *params, _Complex float *work, float *rwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment cposvxx_$address() {
        return cposvxx_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cposvxx_(const char *fact, const char *uplo, const int *n, const int *nrhs, _Complex float *A, const int *lda, _Complex float *AF, const int *ldaf, char *equed, float *S, _Complex float *B, const int *ldb, _Complex float *X, const int *ldx, float *rcond, float *rpvgrw, float *berr, const int *n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, const int *nparams, float *params, _Complex float *work, float *rwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static void cposvxx_(MemorySegment fact, MemorySegment uplo, MemorySegment n, MemorySegment nrhs, MemorySegment A, MemorySegment lda, MemorySegment AF, MemorySegment ldaf, MemorySegment equed, MemorySegment S, MemorySegment B, MemorySegment ldb, MemorySegment X, MemorySegment ldx, MemorySegment rcond, MemorySegment rpvgrw, MemorySegment berr, MemorySegment n_err_bnds, MemorySegment err_bnds_norm, MemorySegment err_bnds_comp, MemorySegment nparams, MemorySegment params, MemorySegment work, MemorySegment rwork, MemorySegment info, long x25, long x26, long x27) {
        var mh$ = cposvxx_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cposvxx_", fact, uplo, n, nrhs, A, lda, AF, ldaf, equed, S, B, ldb, X, ldx, rcond, rpvgrw, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params, work, rwork, info, x25, x26, x27);
            }
            mh$.invokeExact(fact, uplo, n, nrhs, A, lda, AF, ldaf, equed, S, B, ldb, X, ldx, rcond, rpvgrw, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params, work, rwork, info, x25, x26, x27);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dposvxx_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("dposvxx_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dposvxx_(const char *fact, const char *uplo, const int *n, const int *nrhs, double *A, const int *lda, double *AF, const int *ldaf, char *equed, double *S, double *B, const int *ldb, double *X, const int *ldx, double *rcond, double *rpvgrw, double *berr, const int *n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, const int *nparams, double *params, double *work, int *iwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor dposvxx_$descriptor() {
        return dposvxx_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dposvxx_(const char *fact, const char *uplo, const int *n, const int *nrhs, double *A, const int *lda, double *AF, const int *ldaf, char *equed, double *S, double *B, const int *ldb, double *X, const int *ldx, double *rcond, double *rpvgrw, double *berr, const int *n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, const int *nparams, double *params, double *work, int *iwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle dposvxx_$handle() {
        return dposvxx_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dposvxx_(const char *fact, const char *uplo, const int *n, const int *nrhs, double *A, const int *lda, double *AF, const int *ldaf, char *equed, double *S, double *B, const int *ldb, double *X, const int *ldx, double *rcond, double *rpvgrw, double *berr, const int *n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, const int *nparams, double *params, double *work, int *iwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment dposvxx_$address() {
        return dposvxx_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dposvxx_(const char *fact, const char *uplo, const int *n, const int *nrhs, double *A, const int *lda, double *AF, const int *ldaf, char *equed, double *S, double *B, const int *ldb, double *X, const int *ldx, double *rcond, double *rpvgrw, double *berr, const int *n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, const int *nparams, double *params, double *work, int *iwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static void dposvxx_(MemorySegment fact, MemorySegment uplo, MemorySegment n, MemorySegment nrhs, MemorySegment A, MemorySegment lda, MemorySegment AF, MemorySegment ldaf, MemorySegment equed, MemorySegment S, MemorySegment B, MemorySegment ldb, MemorySegment X, MemorySegment ldx, MemorySegment rcond, MemorySegment rpvgrw, MemorySegment berr, MemorySegment n_err_bnds, MemorySegment err_bnds_norm, MemorySegment err_bnds_comp, MemorySegment nparams, MemorySegment params, MemorySegment work, MemorySegment iwork, MemorySegment info, long x25, long x26, long x27) {
        var mh$ = dposvxx_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dposvxx_", fact, uplo, n, nrhs, A, lda, AF, ldaf, equed, S, B, ldb, X, ldx, rcond, rpvgrw, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params, work, iwork, info, x25, x26, x27);
            }
            mh$.invokeExact(fact, uplo, n, nrhs, A, lda, AF, ldaf, equed, S, B, ldb, X, ldx, rcond, rpvgrw, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params, work, iwork, info, x25, x26, x27);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sposvxx_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("sposvxx_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void sposvxx_(const char *fact, const char *uplo, const int *n, const int *nrhs, float *A, const int *lda, float *AF, const int *ldaf, char *equed, float *S, float *B, const int *ldb, float *X, const int *ldx, float *rcond, float *rpvgrw, float *berr, const int *n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, const int *nparams, float *params, float *work, int *iwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor sposvxx_$descriptor() {
        return sposvxx_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void sposvxx_(const char *fact, const char *uplo, const int *n, const int *nrhs, float *A, const int *lda, float *AF, const int *ldaf, char *equed, float *S, float *B, const int *ldb, float *X, const int *ldx, float *rcond, float *rpvgrw, float *berr, const int *n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, const int *nparams, float *params, float *work, int *iwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle sposvxx_$handle() {
        return sposvxx_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void sposvxx_(const char *fact, const char *uplo, const int *n, const int *nrhs, float *A, const int *lda, float *AF, const int *ldaf, char *equed, float *S, float *B, const int *ldb, float *X, const int *ldx, float *rcond, float *rpvgrw, float *berr, const int *n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, const int *nparams, float *params, float *work, int *iwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment sposvxx_$address() {
        return sposvxx_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void sposvxx_(const char *fact, const char *uplo, const int *n, const int *nrhs, float *A, const int *lda, float *AF, const int *ldaf, char *equed, float *S, float *B, const int *ldb, float *X, const int *ldx, float *rcond, float *rpvgrw, float *berr, const int *n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, const int *nparams, float *params, float *work, int *iwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static void sposvxx_(MemorySegment fact, MemorySegment uplo, MemorySegment n, MemorySegment nrhs, MemorySegment A, MemorySegment lda, MemorySegment AF, MemorySegment ldaf, MemorySegment equed, MemorySegment S, MemorySegment B, MemorySegment ldb, MemorySegment X, MemorySegment ldx, MemorySegment rcond, MemorySegment rpvgrw, MemorySegment berr, MemorySegment n_err_bnds, MemorySegment err_bnds_norm, MemorySegment err_bnds_comp, MemorySegment nparams, MemorySegment params, MemorySegment work, MemorySegment iwork, MemorySegment info, long x25, long x26, long x27) {
        var mh$ = sposvxx_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sposvxx_", fact, uplo, n, nrhs, A, lda, AF, ldaf, equed, S, B, ldb, X, ldx, rcond, rpvgrw, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params, work, iwork, info, x25, x26, x27);
            }
            mh$.invokeExact(fact, uplo, n, nrhs, A, lda, AF, ldaf, equed, S, B, ldb, X, ldx, rcond, rpvgrw, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params, work, iwork, info, x25, x26, x27);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zposvxx_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("zposvxx_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zposvxx_(const char *fact, const char *uplo, const int *n, const int *nrhs, _Complex double *A, const int *lda, _Complex double *AF, const int *ldaf, char *equed, double *S, _Complex double *B, const int *ldb, _Complex double *X, const int *ldx, double *rcond, double *rpvgrw, double *berr, const int *n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, const int *nparams, double *params, _Complex double *work, double *rwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor zposvxx_$descriptor() {
        return zposvxx_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zposvxx_(const char *fact, const char *uplo, const int *n, const int *nrhs, _Complex double *A, const int *lda, _Complex double *AF, const int *ldaf, char *equed, double *S, _Complex double *B, const int *ldb, _Complex double *X, const int *ldx, double *rcond, double *rpvgrw, double *berr, const int *n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, const int *nparams, double *params, _Complex double *work, double *rwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle zposvxx_$handle() {
        return zposvxx_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zposvxx_(const char *fact, const char *uplo, const int *n, const int *nrhs, _Complex double *A, const int *lda, _Complex double *AF, const int *ldaf, char *equed, double *S, _Complex double *B, const int *ldb, _Complex double *X, const int *ldx, double *rcond, double *rpvgrw, double *berr, const int *n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, const int *nparams, double *params, _Complex double *work, double *rwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment zposvxx_$address() {
        return zposvxx_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zposvxx_(const char *fact, const char *uplo, const int *n, const int *nrhs, _Complex double *A, const int *lda, _Complex double *AF, const int *ldaf, char *equed, double *S, _Complex double *B, const int *ldb, _Complex double *X, const int *ldx, double *rcond, double *rpvgrw, double *berr, const int *n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, const int *nparams, double *params, _Complex double *work, double *rwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static void zposvxx_(MemorySegment fact, MemorySegment uplo, MemorySegment n, MemorySegment nrhs, MemorySegment A, MemorySegment lda, MemorySegment AF, MemorySegment ldaf, MemorySegment equed, MemorySegment S, MemorySegment B, MemorySegment ldb, MemorySegment X, MemorySegment ldx, MemorySegment rcond, MemorySegment rpvgrw, MemorySegment berr, MemorySegment n_err_bnds, MemorySegment err_bnds_norm, MemorySegment err_bnds_comp, MemorySegment nparams, MemorySegment params, MemorySegment work, MemorySegment rwork, MemorySegment info, long x25, long x26, long x27) {
        var mh$ = zposvxx_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zposvxx_", fact, uplo, n, nrhs, A, lda, AF, ldaf, equed, S, B, ldb, X, ldx, rcond, rpvgrw, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params, work, rwork, info, x25, x26, x27);
            }
            mh$.invokeExact(fact, uplo, n, nrhs, A, lda, AF, ldaf, equed, S, B, ldb, X, ldx, rcond, rpvgrw, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params, work, rwork, info, x25, x26, x27);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cpotf2_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cpotf2_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cpotf2_(const char *uplo, const int *n, _Complex float *A, const int *lda, int *info, size_t)
     * }
     */
    public static FunctionDescriptor cpotf2_$descriptor() {
        return cpotf2_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cpotf2_(const char *uplo, const int *n, _Complex float *A, const int *lda, int *info, size_t)
     * }
     */
    public static MethodHandle cpotf2_$handle() {
        return cpotf2_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cpotf2_(const char *uplo, const int *n, _Complex float *A, const int *lda, int *info, size_t)
     * }
     */
    public static MemorySegment cpotf2_$address() {
        return cpotf2_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cpotf2_(const char *uplo, const int *n, _Complex float *A, const int *lda, int *info, size_t)
     * }
     */
    public static void cpotf2_(MemorySegment uplo, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment info, long x5) {
        var mh$ = cpotf2_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cpotf2_", uplo, n, A, lda, info, x5);
            }
            mh$.invokeExact(uplo, n, A, lda, info, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dpotf2_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("dpotf2_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dpotf2_(const char *uplo, const int *n, double *A, const int *lda, int *info, size_t)
     * }
     */
    public static FunctionDescriptor dpotf2_$descriptor() {
        return dpotf2_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dpotf2_(const char *uplo, const int *n, double *A, const int *lda, int *info, size_t)
     * }
     */
    public static MethodHandle dpotf2_$handle() {
        return dpotf2_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dpotf2_(const char *uplo, const int *n, double *A, const int *lda, int *info, size_t)
     * }
     */
    public static MemorySegment dpotf2_$address() {
        return dpotf2_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dpotf2_(const char *uplo, const int *n, double *A, const int *lda, int *info, size_t)
     * }
     */
    public static void dpotf2_(MemorySegment uplo, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment info, long x5) {
        var mh$ = dpotf2_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dpotf2_", uplo, n, A, lda, info, x5);
            }
            mh$.invokeExact(uplo, n, A, lda, info, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class spotf2_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("spotf2_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void spotf2_(const char *uplo, const int *n, float *A, const int *lda, int *info, size_t)
     * }
     */
    public static FunctionDescriptor spotf2_$descriptor() {
        return spotf2_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void spotf2_(const char *uplo, const int *n, float *A, const int *lda, int *info, size_t)
     * }
     */
    public static MethodHandle spotf2_$handle() {
        return spotf2_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void spotf2_(const char *uplo, const int *n, float *A, const int *lda, int *info, size_t)
     * }
     */
    public static MemorySegment spotf2_$address() {
        return spotf2_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void spotf2_(const char *uplo, const int *n, float *A, const int *lda, int *info, size_t)
     * }
     */
    public static void spotf2_(MemorySegment uplo, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment info, long x5) {
        var mh$ = spotf2_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("spotf2_", uplo, n, A, lda, info, x5);
            }
            mh$.invokeExact(uplo, n, A, lda, info, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zpotf2_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("zpotf2_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zpotf2_(const char *uplo, const int *n, _Complex double *A, const int *lda, int *info, size_t)
     * }
     */
    public static FunctionDescriptor zpotf2_$descriptor() {
        return zpotf2_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zpotf2_(const char *uplo, const int *n, _Complex double *A, const int *lda, int *info, size_t)
     * }
     */
    public static MethodHandle zpotf2_$handle() {
        return zpotf2_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zpotf2_(const char *uplo, const int *n, _Complex double *A, const int *lda, int *info, size_t)
     * }
     */
    public static MemorySegment zpotf2_$address() {
        return zpotf2_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zpotf2_(const char *uplo, const int *n, _Complex double *A, const int *lda, int *info, size_t)
     * }
     */
    public static void zpotf2_(MemorySegment uplo, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment info, long x5) {
        var mh$ = zpotf2_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zpotf2_", uplo, n, A, lda, info, x5);
            }
            mh$.invokeExact(uplo, n, A, lda, info, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cpotrf_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cpotrf_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cpotrf_(const char *uplo, const int *n, _Complex float *A, const int *lda, int *info, size_t)
     * }
     */
    public static FunctionDescriptor cpotrf_$descriptor() {
        return cpotrf_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cpotrf_(const char *uplo, const int *n, _Complex float *A, const int *lda, int *info, size_t)
     * }
     */
    public static MethodHandle cpotrf_$handle() {
        return cpotrf_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cpotrf_(const char *uplo, const int *n, _Complex float *A, const int *lda, int *info, size_t)
     * }
     */
    public static MemorySegment cpotrf_$address() {
        return cpotrf_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cpotrf_(const char *uplo, const int *n, _Complex float *A, const int *lda, int *info, size_t)
     * }
     */
    public static void cpotrf_(MemorySegment uplo, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment info, long x5) {
        var mh$ = cpotrf_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cpotrf_", uplo, n, A, lda, info, x5);
            }
            mh$.invokeExact(uplo, n, A, lda, info, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dpotrf_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("dpotrf_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dpotrf_(const char *uplo, const int *n, double *A, const int *lda, int *info, size_t)
     * }
     */
    public static FunctionDescriptor dpotrf_$descriptor() {
        return dpotrf_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dpotrf_(const char *uplo, const int *n, double *A, const int *lda, int *info, size_t)
     * }
     */
    public static MethodHandle dpotrf_$handle() {
        return dpotrf_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dpotrf_(const char *uplo, const int *n, double *A, const int *lda, int *info, size_t)
     * }
     */
    public static MemorySegment dpotrf_$address() {
        return dpotrf_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dpotrf_(const char *uplo, const int *n, double *A, const int *lda, int *info, size_t)
     * }
     */
    public static void dpotrf_(MemorySegment uplo, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment info, long x5) {
        var mh$ = dpotrf_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dpotrf_", uplo, n, A, lda, info, x5);
            }
            mh$.invokeExact(uplo, n, A, lda, info, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class spotrf_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("spotrf_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void spotrf_(const char *uplo, const int *n, float *A, const int *lda, int *info, size_t)
     * }
     */
    public static FunctionDescriptor spotrf_$descriptor() {
        return spotrf_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void spotrf_(const char *uplo, const int *n, float *A, const int *lda, int *info, size_t)
     * }
     */
    public static MethodHandle spotrf_$handle() {
        return spotrf_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void spotrf_(const char *uplo, const int *n, float *A, const int *lda, int *info, size_t)
     * }
     */
    public static MemorySegment spotrf_$address() {
        return spotrf_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void spotrf_(const char *uplo, const int *n, float *A, const int *lda, int *info, size_t)
     * }
     */
    public static void spotrf_(MemorySegment uplo, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment info, long x5) {
        var mh$ = spotrf_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("spotrf_", uplo, n, A, lda, info, x5);
            }
            mh$.invokeExact(uplo, n, A, lda, info, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zpotrf_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("zpotrf_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zpotrf_(const char *uplo, const int *n, _Complex double *A, const int *lda, int *info, size_t)
     * }
     */
    public static FunctionDescriptor zpotrf_$descriptor() {
        return zpotrf_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zpotrf_(const char *uplo, const int *n, _Complex double *A, const int *lda, int *info, size_t)
     * }
     */
    public static MethodHandle zpotrf_$handle() {
        return zpotrf_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zpotrf_(const char *uplo, const int *n, _Complex double *A, const int *lda, int *info, size_t)
     * }
     */
    public static MemorySegment zpotrf_$address() {
        return zpotrf_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zpotrf_(const char *uplo, const int *n, _Complex double *A, const int *lda, int *info, size_t)
     * }
     */
    public static void zpotrf_(MemorySegment uplo, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment info, long x5) {
        var mh$ = zpotrf_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zpotrf_", uplo, n, A, lda, info, x5);
            }
            mh$.invokeExact(uplo, n, A, lda, info, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cpotrf2_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cpotrf2_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cpotrf2_(const char *uplo, const int *n, _Complex float *A, const int *lda, int *info, size_t)
     * }
     */
    public static FunctionDescriptor cpotrf2_$descriptor() {
        return cpotrf2_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cpotrf2_(const char *uplo, const int *n, _Complex float *A, const int *lda, int *info, size_t)
     * }
     */
    public static MethodHandle cpotrf2_$handle() {
        return cpotrf2_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cpotrf2_(const char *uplo, const int *n, _Complex float *A, const int *lda, int *info, size_t)
     * }
     */
    public static MemorySegment cpotrf2_$address() {
        return cpotrf2_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cpotrf2_(const char *uplo, const int *n, _Complex float *A, const int *lda, int *info, size_t)
     * }
     */
    public static void cpotrf2_(MemorySegment uplo, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment info, long x5) {
        var mh$ = cpotrf2_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cpotrf2_", uplo, n, A, lda, info, x5);
            }
            mh$.invokeExact(uplo, n, A, lda, info, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dpotrf2_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("dpotrf2_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dpotrf2_(const char *uplo, const int *n, double *A, const int *lda, int *info, size_t)
     * }
     */
    public static FunctionDescriptor dpotrf2_$descriptor() {
        return dpotrf2_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dpotrf2_(const char *uplo, const int *n, double *A, const int *lda, int *info, size_t)
     * }
     */
    public static MethodHandle dpotrf2_$handle() {
        return dpotrf2_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dpotrf2_(const char *uplo, const int *n, double *A, const int *lda, int *info, size_t)
     * }
     */
    public static MemorySegment dpotrf2_$address() {
        return dpotrf2_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dpotrf2_(const char *uplo, const int *n, double *A, const int *lda, int *info, size_t)
     * }
     */
    public static void dpotrf2_(MemorySegment uplo, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment info, long x5) {
        var mh$ = dpotrf2_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dpotrf2_", uplo, n, A, lda, info, x5);
            }
            mh$.invokeExact(uplo, n, A, lda, info, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class spotrf2_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("spotrf2_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void spotrf2_(const char *uplo, const int *n, float *A, const int *lda, int *info, size_t)
     * }
     */
    public static FunctionDescriptor spotrf2_$descriptor() {
        return spotrf2_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void spotrf2_(const char *uplo, const int *n, float *A, const int *lda, int *info, size_t)
     * }
     */
    public static MethodHandle spotrf2_$handle() {
        return spotrf2_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void spotrf2_(const char *uplo, const int *n, float *A, const int *lda, int *info, size_t)
     * }
     */
    public static MemorySegment spotrf2_$address() {
        return spotrf2_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void spotrf2_(const char *uplo, const int *n, float *A, const int *lda, int *info, size_t)
     * }
     */
    public static void spotrf2_(MemorySegment uplo, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment info, long x5) {
        var mh$ = spotrf2_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("spotrf2_", uplo, n, A, lda, info, x5);
            }
            mh$.invokeExact(uplo, n, A, lda, info, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zpotrf2_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("zpotrf2_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zpotrf2_(const char *uplo, const int *n, _Complex double *A, const int *lda, int *info, size_t)
     * }
     */
    public static FunctionDescriptor zpotrf2_$descriptor() {
        return zpotrf2_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zpotrf2_(const char *uplo, const int *n, _Complex double *A, const int *lda, int *info, size_t)
     * }
     */
    public static MethodHandle zpotrf2_$handle() {
        return zpotrf2_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zpotrf2_(const char *uplo, const int *n, _Complex double *A, const int *lda, int *info, size_t)
     * }
     */
    public static MemorySegment zpotrf2_$address() {
        return zpotrf2_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zpotrf2_(const char *uplo, const int *n, _Complex double *A, const int *lda, int *info, size_t)
     * }
     */
    public static void zpotrf2_(MemorySegment uplo, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment info, long x5) {
        var mh$ = zpotrf2_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zpotrf2_", uplo, n, A, lda, info, x5);
            }
            mh$.invokeExact(uplo, n, A, lda, info, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cpotri_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cpotri_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cpotri_(const char *uplo, const int *n, _Complex float *A, const int *lda, int *info, size_t)
     * }
     */
    public static FunctionDescriptor cpotri_$descriptor() {
        return cpotri_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cpotri_(const char *uplo, const int *n, _Complex float *A, const int *lda, int *info, size_t)
     * }
     */
    public static MethodHandle cpotri_$handle() {
        return cpotri_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cpotri_(const char *uplo, const int *n, _Complex float *A, const int *lda, int *info, size_t)
     * }
     */
    public static MemorySegment cpotri_$address() {
        return cpotri_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cpotri_(const char *uplo, const int *n, _Complex float *A, const int *lda, int *info, size_t)
     * }
     */
    public static void cpotri_(MemorySegment uplo, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment info, long x5) {
        var mh$ = cpotri_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cpotri_", uplo, n, A, lda, info, x5);
            }
            mh$.invokeExact(uplo, n, A, lda, info, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dpotri_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("dpotri_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dpotri_(const char *uplo, const int *n, double *A, const int *lda, int *info, size_t)
     * }
     */
    public static FunctionDescriptor dpotri_$descriptor() {
        return dpotri_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dpotri_(const char *uplo, const int *n, double *A, const int *lda, int *info, size_t)
     * }
     */
    public static MethodHandle dpotri_$handle() {
        return dpotri_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dpotri_(const char *uplo, const int *n, double *A, const int *lda, int *info, size_t)
     * }
     */
    public static MemorySegment dpotri_$address() {
        return dpotri_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dpotri_(const char *uplo, const int *n, double *A, const int *lda, int *info, size_t)
     * }
     */
    public static void dpotri_(MemorySegment uplo, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment info, long x5) {
        var mh$ = dpotri_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dpotri_", uplo, n, A, lda, info, x5);
            }
            mh$.invokeExact(uplo, n, A, lda, info, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class spotri_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("spotri_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void spotri_(const char *uplo, const int *n, float *A, const int *lda, int *info, size_t)
     * }
     */
    public static FunctionDescriptor spotri_$descriptor() {
        return spotri_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void spotri_(const char *uplo, const int *n, float *A, const int *lda, int *info, size_t)
     * }
     */
    public static MethodHandle spotri_$handle() {
        return spotri_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void spotri_(const char *uplo, const int *n, float *A, const int *lda, int *info, size_t)
     * }
     */
    public static MemorySegment spotri_$address() {
        return spotri_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void spotri_(const char *uplo, const int *n, float *A, const int *lda, int *info, size_t)
     * }
     */
    public static void spotri_(MemorySegment uplo, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment info, long x5) {
        var mh$ = spotri_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("spotri_", uplo, n, A, lda, info, x5);
            }
            mh$.invokeExact(uplo, n, A, lda, info, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zpotri_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("zpotri_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zpotri_(const char *uplo, const int *n, _Complex double *A, const int *lda, int *info, size_t)
     * }
     */
    public static FunctionDescriptor zpotri_$descriptor() {
        return zpotri_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zpotri_(const char *uplo, const int *n, _Complex double *A, const int *lda, int *info, size_t)
     * }
     */
    public static MethodHandle zpotri_$handle() {
        return zpotri_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zpotri_(const char *uplo, const int *n, _Complex double *A, const int *lda, int *info, size_t)
     * }
     */
    public static MemorySegment zpotri_$address() {
        return zpotri_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zpotri_(const char *uplo, const int *n, _Complex double *A, const int *lda, int *info, size_t)
     * }
     */
    public static void zpotri_(MemorySegment uplo, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment info, long x5) {
        var mh$ = zpotri_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zpotri_", uplo, n, A, lda, info, x5);
            }
            mh$.invokeExact(uplo, n, A, lda, info, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cpotrs_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cpotrs_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cpotrs_(const char *uplo, const int *n, const int *nrhs, const _Complex float *A, const int *lda, _Complex float *B, const int *ldb, int *info, size_t)
     * }
     */
    public static FunctionDescriptor cpotrs_$descriptor() {
        return cpotrs_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cpotrs_(const char *uplo, const int *n, const int *nrhs, const _Complex float *A, const int *lda, _Complex float *B, const int *ldb, int *info, size_t)
     * }
     */
    public static MethodHandle cpotrs_$handle() {
        return cpotrs_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cpotrs_(const char *uplo, const int *n, const int *nrhs, const _Complex float *A, const int *lda, _Complex float *B, const int *ldb, int *info, size_t)
     * }
     */
    public static MemorySegment cpotrs_$address() {
        return cpotrs_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cpotrs_(const char *uplo, const int *n, const int *nrhs, const _Complex float *A, const int *lda, _Complex float *B, const int *ldb, int *info, size_t)
     * }
     */
    public static void cpotrs_(MemorySegment uplo, MemorySegment n, MemorySegment nrhs, MemorySegment A, MemorySegment lda, MemorySegment B, MemorySegment ldb, MemorySegment info, long x8) {
        var mh$ = cpotrs_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cpotrs_", uplo, n, nrhs, A, lda, B, ldb, info, x8);
            }
            mh$.invokeExact(uplo, n, nrhs, A, lda, B, ldb, info, x8);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dpotrs_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("dpotrs_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dpotrs_(const char *uplo, const int *n, const int *nrhs, const double *A, const int *lda, double *B, const int *ldb, int *info, size_t)
     * }
     */
    public static FunctionDescriptor dpotrs_$descriptor() {
        return dpotrs_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dpotrs_(const char *uplo, const int *n, const int *nrhs, const double *A, const int *lda, double *B, const int *ldb, int *info, size_t)
     * }
     */
    public static MethodHandle dpotrs_$handle() {
        return dpotrs_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dpotrs_(const char *uplo, const int *n, const int *nrhs, const double *A, const int *lda, double *B, const int *ldb, int *info, size_t)
     * }
     */
    public static MemorySegment dpotrs_$address() {
        return dpotrs_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dpotrs_(const char *uplo, const int *n, const int *nrhs, const double *A, const int *lda, double *B, const int *ldb, int *info, size_t)
     * }
     */
    public static void dpotrs_(MemorySegment uplo, MemorySegment n, MemorySegment nrhs, MemorySegment A, MemorySegment lda, MemorySegment B, MemorySegment ldb, MemorySegment info, long x8) {
        var mh$ = dpotrs_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dpotrs_", uplo, n, nrhs, A, lda, B, ldb, info, x8);
            }
            mh$.invokeExact(uplo, n, nrhs, A, lda, B, ldb, info, x8);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class spotrs_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("spotrs_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void spotrs_(const char *uplo, const int *n, const int *nrhs, const float *A, const int *lda, float *B, const int *ldb, int *info, size_t)
     * }
     */
    public static FunctionDescriptor spotrs_$descriptor() {
        return spotrs_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void spotrs_(const char *uplo, const int *n, const int *nrhs, const float *A, const int *lda, float *B, const int *ldb, int *info, size_t)
     * }
     */
    public static MethodHandle spotrs_$handle() {
        return spotrs_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void spotrs_(const char *uplo, const int *n, const int *nrhs, const float *A, const int *lda, float *B, const int *ldb, int *info, size_t)
     * }
     */
    public static MemorySegment spotrs_$address() {
        return spotrs_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void spotrs_(const char *uplo, const int *n, const int *nrhs, const float *A, const int *lda, float *B, const int *ldb, int *info, size_t)
     * }
     */
    public static void spotrs_(MemorySegment uplo, MemorySegment n, MemorySegment nrhs, MemorySegment A, MemorySegment lda, MemorySegment B, MemorySegment ldb, MemorySegment info, long x8) {
        var mh$ = spotrs_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("spotrs_", uplo, n, nrhs, A, lda, B, ldb, info, x8);
            }
            mh$.invokeExact(uplo, n, nrhs, A, lda, B, ldb, info, x8);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zpotrs_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("zpotrs_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zpotrs_(const char *uplo, const int *n, const int *nrhs, const _Complex double *A, const int *lda, _Complex double *B, const int *ldb, int *info, size_t)
     * }
     */
    public static FunctionDescriptor zpotrs_$descriptor() {
        return zpotrs_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zpotrs_(const char *uplo, const int *n, const int *nrhs, const _Complex double *A, const int *lda, _Complex double *B, const int *ldb, int *info, size_t)
     * }
     */
    public static MethodHandle zpotrs_$handle() {
        return zpotrs_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zpotrs_(const char *uplo, const int *n, const int *nrhs, const _Complex double *A, const int *lda, _Complex double *B, const int *ldb, int *info, size_t)
     * }
     */
    public static MemorySegment zpotrs_$address() {
        return zpotrs_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zpotrs_(const char *uplo, const int *n, const int *nrhs, const _Complex double *A, const int *lda, _Complex double *B, const int *ldb, int *info, size_t)
     * }
     */
    public static void zpotrs_(MemorySegment uplo, MemorySegment n, MemorySegment nrhs, MemorySegment A, MemorySegment lda, MemorySegment B, MemorySegment ldb, MemorySegment info, long x8) {
        var mh$ = zpotrs_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zpotrs_", uplo, n, nrhs, A, lda, B, ldb, info, x8);
            }
            mh$.invokeExact(uplo, n, nrhs, A, lda, B, ldb, info, x8);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cppcon_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cppcon_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cppcon_(const char *uplo, const int *n, const _Complex float *AP, const float *anorm, float *rcond, _Complex float *work, float *rwork, int *info, size_t)
     * }
     */
    public static FunctionDescriptor cppcon_$descriptor() {
        return cppcon_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cppcon_(const char *uplo, const int *n, const _Complex float *AP, const float *anorm, float *rcond, _Complex float *work, float *rwork, int *info, size_t)
     * }
     */
    public static MethodHandle cppcon_$handle() {
        return cppcon_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cppcon_(const char *uplo, const int *n, const _Complex float *AP, const float *anorm, float *rcond, _Complex float *work, float *rwork, int *info, size_t)
     * }
     */
    public static MemorySegment cppcon_$address() {
        return cppcon_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cppcon_(const char *uplo, const int *n, const _Complex float *AP, const float *anorm, float *rcond, _Complex float *work, float *rwork, int *info, size_t)
     * }
     */
    public static void cppcon_(MemorySegment uplo, MemorySegment n, MemorySegment AP, MemorySegment anorm, MemorySegment rcond, MemorySegment work, MemorySegment rwork, MemorySegment info, long x8) {
        var mh$ = cppcon_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cppcon_", uplo, n, AP, anorm, rcond, work, rwork, info, x8);
            }
            mh$.invokeExact(uplo, n, AP, anorm, rcond, work, rwork, info, x8);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dppcon_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("dppcon_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dppcon_(const char *uplo, const int *n, const double *AP, const double *anorm, double *rcond, double *work, int *iwork, int *info, size_t)
     * }
     */
    public static FunctionDescriptor dppcon_$descriptor() {
        return dppcon_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dppcon_(const char *uplo, const int *n, const double *AP, const double *anorm, double *rcond, double *work, int *iwork, int *info, size_t)
     * }
     */
    public static MethodHandle dppcon_$handle() {
        return dppcon_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dppcon_(const char *uplo, const int *n, const double *AP, const double *anorm, double *rcond, double *work, int *iwork, int *info, size_t)
     * }
     */
    public static MemorySegment dppcon_$address() {
        return dppcon_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dppcon_(const char *uplo, const int *n, const double *AP, const double *anorm, double *rcond, double *work, int *iwork, int *info, size_t)
     * }
     */
    public static void dppcon_(MemorySegment uplo, MemorySegment n, MemorySegment AP, MemorySegment anorm, MemorySegment rcond, MemorySegment work, MemorySegment iwork, MemorySegment info, long x8) {
        var mh$ = dppcon_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dppcon_", uplo, n, AP, anorm, rcond, work, iwork, info, x8);
            }
            mh$.invokeExact(uplo, n, AP, anorm, rcond, work, iwork, info, x8);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sppcon_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("sppcon_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void sppcon_(const char *uplo, const int *n, const float *AP, const float *anorm, float *rcond, float *work, int *iwork, int *info, size_t)
     * }
     */
    public static FunctionDescriptor sppcon_$descriptor() {
        return sppcon_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void sppcon_(const char *uplo, const int *n, const float *AP, const float *anorm, float *rcond, float *work, int *iwork, int *info, size_t)
     * }
     */
    public static MethodHandle sppcon_$handle() {
        return sppcon_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void sppcon_(const char *uplo, const int *n, const float *AP, const float *anorm, float *rcond, float *work, int *iwork, int *info, size_t)
     * }
     */
    public static MemorySegment sppcon_$address() {
        return sppcon_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void sppcon_(const char *uplo, const int *n, const float *AP, const float *anorm, float *rcond, float *work, int *iwork, int *info, size_t)
     * }
     */
    public static void sppcon_(MemorySegment uplo, MemorySegment n, MemorySegment AP, MemorySegment anorm, MemorySegment rcond, MemorySegment work, MemorySegment iwork, MemorySegment info, long x8) {
        var mh$ = sppcon_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sppcon_", uplo, n, AP, anorm, rcond, work, iwork, info, x8);
            }
            mh$.invokeExact(uplo, n, AP, anorm, rcond, work, iwork, info, x8);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zppcon_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("zppcon_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zppcon_(const char *uplo, const int *n, const _Complex double *AP, const double *anorm, double *rcond, _Complex double *work, double *rwork, int *info, size_t)
     * }
     */
    public static FunctionDescriptor zppcon_$descriptor() {
        return zppcon_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zppcon_(const char *uplo, const int *n, const _Complex double *AP, const double *anorm, double *rcond, _Complex double *work, double *rwork, int *info, size_t)
     * }
     */
    public static MethodHandle zppcon_$handle() {
        return zppcon_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zppcon_(const char *uplo, const int *n, const _Complex double *AP, const double *anorm, double *rcond, _Complex double *work, double *rwork, int *info, size_t)
     * }
     */
    public static MemorySegment zppcon_$address() {
        return zppcon_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zppcon_(const char *uplo, const int *n, const _Complex double *AP, const double *anorm, double *rcond, _Complex double *work, double *rwork, int *info, size_t)
     * }
     */
    public static void zppcon_(MemorySegment uplo, MemorySegment n, MemorySegment AP, MemorySegment anorm, MemorySegment rcond, MemorySegment work, MemorySegment rwork, MemorySegment info, long x8) {
        var mh$ = zppcon_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zppcon_", uplo, n, AP, anorm, rcond, work, rwork, info, x8);
            }
            mh$.invokeExact(uplo, n, AP, anorm, rcond, work, rwork, info, x8);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cppequ_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cppequ_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cppequ_(const char *uplo, const int *n, const _Complex float *AP, float *S, float *scond, float *amax, int *info, size_t)
     * }
     */
    public static FunctionDescriptor cppequ_$descriptor() {
        return cppequ_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cppequ_(const char *uplo, const int *n, const _Complex float *AP, float *S, float *scond, float *amax, int *info, size_t)
     * }
     */
    public static MethodHandle cppequ_$handle() {
        return cppequ_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cppequ_(const char *uplo, const int *n, const _Complex float *AP, float *S, float *scond, float *amax, int *info, size_t)
     * }
     */
    public static MemorySegment cppequ_$address() {
        return cppequ_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cppequ_(const char *uplo, const int *n, const _Complex float *AP, float *S, float *scond, float *amax, int *info, size_t)
     * }
     */
    public static void cppequ_(MemorySegment uplo, MemorySegment n, MemorySegment AP, MemorySegment S, MemorySegment scond, MemorySegment amax, MemorySegment info, long x7) {
        var mh$ = cppequ_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cppequ_", uplo, n, AP, S, scond, amax, info, x7);
            }
            mh$.invokeExact(uplo, n, AP, S, scond, amax, info, x7);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dppequ_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("dppequ_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dppequ_(const char *uplo, const int *n, const double *AP, double *S, double *scond, double *amax, int *info, size_t)
     * }
     */
    public static FunctionDescriptor dppequ_$descriptor() {
        return dppequ_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dppequ_(const char *uplo, const int *n, const double *AP, double *S, double *scond, double *amax, int *info, size_t)
     * }
     */
    public static MethodHandle dppequ_$handle() {
        return dppequ_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dppequ_(const char *uplo, const int *n, const double *AP, double *S, double *scond, double *amax, int *info, size_t)
     * }
     */
    public static MemorySegment dppequ_$address() {
        return dppequ_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dppequ_(const char *uplo, const int *n, const double *AP, double *S, double *scond, double *amax, int *info, size_t)
     * }
     */
    public static void dppequ_(MemorySegment uplo, MemorySegment n, MemorySegment AP, MemorySegment S, MemorySegment scond, MemorySegment amax, MemorySegment info, long x7) {
        var mh$ = dppequ_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dppequ_", uplo, n, AP, S, scond, amax, info, x7);
            }
            mh$.invokeExact(uplo, n, AP, S, scond, amax, info, x7);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sppequ_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("sppequ_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void sppequ_(const char *uplo, const int *n, const float *AP, float *S, float *scond, float *amax, int *info, size_t)
     * }
     */
    public static FunctionDescriptor sppequ_$descriptor() {
        return sppequ_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void sppequ_(const char *uplo, const int *n, const float *AP, float *S, float *scond, float *amax, int *info, size_t)
     * }
     */
    public static MethodHandle sppequ_$handle() {
        return sppequ_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void sppequ_(const char *uplo, const int *n, const float *AP, float *S, float *scond, float *amax, int *info, size_t)
     * }
     */
    public static MemorySegment sppequ_$address() {
        return sppequ_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void sppequ_(const char *uplo, const int *n, const float *AP, float *S, float *scond, float *amax, int *info, size_t)
     * }
     */
    public static void sppequ_(MemorySegment uplo, MemorySegment n, MemorySegment AP, MemorySegment S, MemorySegment scond, MemorySegment amax, MemorySegment info, long x7) {
        var mh$ = sppequ_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sppequ_", uplo, n, AP, S, scond, amax, info, x7);
            }
            mh$.invokeExact(uplo, n, AP, S, scond, amax, info, x7);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zppequ_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("zppequ_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zppequ_(const char *uplo, const int *n, const _Complex double *AP, double *S, double *scond, double *amax, int *info, size_t)
     * }
     */
    public static FunctionDescriptor zppequ_$descriptor() {
        return zppequ_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zppequ_(const char *uplo, const int *n, const _Complex double *AP, double *S, double *scond, double *amax, int *info, size_t)
     * }
     */
    public static MethodHandle zppequ_$handle() {
        return zppequ_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zppequ_(const char *uplo, const int *n, const _Complex double *AP, double *S, double *scond, double *amax, int *info, size_t)
     * }
     */
    public static MemorySegment zppequ_$address() {
        return zppequ_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zppequ_(const char *uplo, const int *n, const _Complex double *AP, double *S, double *scond, double *amax, int *info, size_t)
     * }
     */
    public static void zppequ_(MemorySegment uplo, MemorySegment n, MemorySegment AP, MemorySegment S, MemorySegment scond, MemorySegment amax, MemorySegment info, long x7) {
        var mh$ = zppequ_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zppequ_", uplo, n, AP, S, scond, amax, info, x7);
            }
            mh$.invokeExact(uplo, n, AP, S, scond, amax, info, x7);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cpprfs_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cpprfs_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cpprfs_(const char *uplo, const int *n, const int *nrhs, const _Complex float *AP, const _Complex float *AFP, const _Complex float *B, const int *ldb, _Complex float *X, const int *ldx, float *ferr, float *berr, _Complex float *work, float *rwork, int *info, size_t)
     * }
     */
    public static FunctionDescriptor cpprfs_$descriptor() {
        return cpprfs_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cpprfs_(const char *uplo, const int *n, const int *nrhs, const _Complex float *AP, const _Complex float *AFP, const _Complex float *B, const int *ldb, _Complex float *X, const int *ldx, float *ferr, float *berr, _Complex float *work, float *rwork, int *info, size_t)
     * }
     */
    public static MethodHandle cpprfs_$handle() {
        return cpprfs_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cpprfs_(const char *uplo, const int *n, const int *nrhs, const _Complex float *AP, const _Complex float *AFP, const _Complex float *B, const int *ldb, _Complex float *X, const int *ldx, float *ferr, float *berr, _Complex float *work, float *rwork, int *info, size_t)
     * }
     */
    public static MemorySegment cpprfs_$address() {
        return cpprfs_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cpprfs_(const char *uplo, const int *n, const int *nrhs, const _Complex float *AP, const _Complex float *AFP, const _Complex float *B, const int *ldb, _Complex float *X, const int *ldx, float *ferr, float *berr, _Complex float *work, float *rwork, int *info, size_t)
     * }
     */
    public static void cpprfs_(MemorySegment uplo, MemorySegment n, MemorySegment nrhs, MemorySegment AP, MemorySegment AFP, MemorySegment B, MemorySegment ldb, MemorySegment X, MemorySegment ldx, MemorySegment ferr, MemorySegment berr, MemorySegment work, MemorySegment rwork, MemorySegment info, long x14) {
        var mh$ = cpprfs_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cpprfs_", uplo, n, nrhs, AP, AFP, B, ldb, X, ldx, ferr, berr, work, rwork, info, x14);
            }
            mh$.invokeExact(uplo, n, nrhs, AP, AFP, B, ldb, X, ldx, ferr, berr, work, rwork, info, x14);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dpprfs_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("dpprfs_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dpprfs_(const char *uplo, const int *n, const int *nrhs, const double *AP, const double *AFP, const double *B, const int *ldb, double *X, const int *ldx, double *ferr, double *berr, double *work, int *iwork, int *info, size_t)
     * }
     */
    public static FunctionDescriptor dpprfs_$descriptor() {
        return dpprfs_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dpprfs_(const char *uplo, const int *n, const int *nrhs, const double *AP, const double *AFP, const double *B, const int *ldb, double *X, const int *ldx, double *ferr, double *berr, double *work, int *iwork, int *info, size_t)
     * }
     */
    public static MethodHandle dpprfs_$handle() {
        return dpprfs_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dpprfs_(const char *uplo, const int *n, const int *nrhs, const double *AP, const double *AFP, const double *B, const int *ldb, double *X, const int *ldx, double *ferr, double *berr, double *work, int *iwork, int *info, size_t)
     * }
     */
    public static MemorySegment dpprfs_$address() {
        return dpprfs_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dpprfs_(const char *uplo, const int *n, const int *nrhs, const double *AP, const double *AFP, const double *B, const int *ldb, double *X, const int *ldx, double *ferr, double *berr, double *work, int *iwork, int *info, size_t)
     * }
     */
    public static void dpprfs_(MemorySegment uplo, MemorySegment n, MemorySegment nrhs, MemorySegment AP, MemorySegment AFP, MemorySegment B, MemorySegment ldb, MemorySegment X, MemorySegment ldx, MemorySegment ferr, MemorySegment berr, MemorySegment work, MemorySegment iwork, MemorySegment info, long x14) {
        var mh$ = dpprfs_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dpprfs_", uplo, n, nrhs, AP, AFP, B, ldb, X, ldx, ferr, berr, work, iwork, info, x14);
            }
            mh$.invokeExact(uplo, n, nrhs, AP, AFP, B, ldb, X, ldx, ferr, berr, work, iwork, info, x14);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class spprfs_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("spprfs_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void spprfs_(const char *uplo, const int *n, const int *nrhs, const float *AP, const float *AFP, const float *B, const int *ldb, float *X, const int *ldx, float *ferr, float *berr, float *work, int *iwork, int *info, size_t)
     * }
     */
    public static FunctionDescriptor spprfs_$descriptor() {
        return spprfs_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void spprfs_(const char *uplo, const int *n, const int *nrhs, const float *AP, const float *AFP, const float *B, const int *ldb, float *X, const int *ldx, float *ferr, float *berr, float *work, int *iwork, int *info, size_t)
     * }
     */
    public static MethodHandle spprfs_$handle() {
        return spprfs_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void spprfs_(const char *uplo, const int *n, const int *nrhs, const float *AP, const float *AFP, const float *B, const int *ldb, float *X, const int *ldx, float *ferr, float *berr, float *work, int *iwork, int *info, size_t)
     * }
     */
    public static MemorySegment spprfs_$address() {
        return spprfs_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void spprfs_(const char *uplo, const int *n, const int *nrhs, const float *AP, const float *AFP, const float *B, const int *ldb, float *X, const int *ldx, float *ferr, float *berr, float *work, int *iwork, int *info, size_t)
     * }
     */
    public static void spprfs_(MemorySegment uplo, MemorySegment n, MemorySegment nrhs, MemorySegment AP, MemorySegment AFP, MemorySegment B, MemorySegment ldb, MemorySegment X, MemorySegment ldx, MemorySegment ferr, MemorySegment berr, MemorySegment work, MemorySegment iwork, MemorySegment info, long x14) {
        var mh$ = spprfs_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("spprfs_", uplo, n, nrhs, AP, AFP, B, ldb, X, ldx, ferr, berr, work, iwork, info, x14);
            }
            mh$.invokeExact(uplo, n, nrhs, AP, AFP, B, ldb, X, ldx, ferr, berr, work, iwork, info, x14);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zpprfs_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("zpprfs_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zpprfs_(const char *uplo, const int *n, const int *nrhs, const _Complex double *AP, const _Complex double *AFP, const _Complex double *B, const int *ldb, _Complex double *X, const int *ldx, double *ferr, double *berr, _Complex double *work, double *rwork, int *info, size_t)
     * }
     */
    public static FunctionDescriptor zpprfs_$descriptor() {
        return zpprfs_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zpprfs_(const char *uplo, const int *n, const int *nrhs, const _Complex double *AP, const _Complex double *AFP, const _Complex double *B, const int *ldb, _Complex double *X, const int *ldx, double *ferr, double *berr, _Complex double *work, double *rwork, int *info, size_t)
     * }
     */
    public static MethodHandle zpprfs_$handle() {
        return zpprfs_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zpprfs_(const char *uplo, const int *n, const int *nrhs, const _Complex double *AP, const _Complex double *AFP, const _Complex double *B, const int *ldb, _Complex double *X, const int *ldx, double *ferr, double *berr, _Complex double *work, double *rwork, int *info, size_t)
     * }
     */
    public static MemorySegment zpprfs_$address() {
        return zpprfs_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zpprfs_(const char *uplo, const int *n, const int *nrhs, const _Complex double *AP, const _Complex double *AFP, const _Complex double *B, const int *ldb, _Complex double *X, const int *ldx, double *ferr, double *berr, _Complex double *work, double *rwork, int *info, size_t)
     * }
     */
    public static void zpprfs_(MemorySegment uplo, MemorySegment n, MemorySegment nrhs, MemorySegment AP, MemorySegment AFP, MemorySegment B, MemorySegment ldb, MemorySegment X, MemorySegment ldx, MemorySegment ferr, MemorySegment berr, MemorySegment work, MemorySegment rwork, MemorySegment info, long x14) {
        var mh$ = zpprfs_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zpprfs_", uplo, n, nrhs, AP, AFP, B, ldb, X, ldx, ferr, berr, work, rwork, info, x14);
            }
            mh$.invokeExact(uplo, n, nrhs, AP, AFP, B, ldb, X, ldx, ferr, berr, work, rwork, info, x14);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cppsv_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cppsv_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cppsv_(const char *uplo, const int *n, const int *nrhs, _Complex float *AP, _Complex float *B, const int *ldb, int *info, size_t)
     * }
     */
    public static FunctionDescriptor cppsv_$descriptor() {
        return cppsv_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cppsv_(const char *uplo, const int *n, const int *nrhs, _Complex float *AP, _Complex float *B, const int *ldb, int *info, size_t)
     * }
     */
    public static MethodHandle cppsv_$handle() {
        return cppsv_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cppsv_(const char *uplo, const int *n, const int *nrhs, _Complex float *AP, _Complex float *B, const int *ldb, int *info, size_t)
     * }
     */
    public static MemorySegment cppsv_$address() {
        return cppsv_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cppsv_(const char *uplo, const int *n, const int *nrhs, _Complex float *AP, _Complex float *B, const int *ldb, int *info, size_t)
     * }
     */
    public static void cppsv_(MemorySegment uplo, MemorySegment n, MemorySegment nrhs, MemorySegment AP, MemorySegment B, MemorySegment ldb, MemorySegment info, long x7) {
        var mh$ = cppsv_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cppsv_", uplo, n, nrhs, AP, B, ldb, info, x7);
            }
            mh$.invokeExact(uplo, n, nrhs, AP, B, ldb, info, x7);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dppsv_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("dppsv_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dppsv_(const char *uplo, const int *n, const int *nrhs, double *AP, double *B, const int *ldb, int *info, size_t)
     * }
     */
    public static FunctionDescriptor dppsv_$descriptor() {
        return dppsv_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dppsv_(const char *uplo, const int *n, const int *nrhs, double *AP, double *B, const int *ldb, int *info, size_t)
     * }
     */
    public static MethodHandle dppsv_$handle() {
        return dppsv_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dppsv_(const char *uplo, const int *n, const int *nrhs, double *AP, double *B, const int *ldb, int *info, size_t)
     * }
     */
    public static MemorySegment dppsv_$address() {
        return dppsv_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dppsv_(const char *uplo, const int *n, const int *nrhs, double *AP, double *B, const int *ldb, int *info, size_t)
     * }
     */
    public static void dppsv_(MemorySegment uplo, MemorySegment n, MemorySegment nrhs, MemorySegment AP, MemorySegment B, MemorySegment ldb, MemorySegment info, long x7) {
        var mh$ = dppsv_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dppsv_", uplo, n, nrhs, AP, B, ldb, info, x7);
            }
            mh$.invokeExact(uplo, n, nrhs, AP, B, ldb, info, x7);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sppsv_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("sppsv_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void sppsv_(const char *uplo, const int *n, const int *nrhs, float *AP, float *B, const int *ldb, int *info, size_t)
     * }
     */
    public static FunctionDescriptor sppsv_$descriptor() {
        return sppsv_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void sppsv_(const char *uplo, const int *n, const int *nrhs, float *AP, float *B, const int *ldb, int *info, size_t)
     * }
     */
    public static MethodHandle sppsv_$handle() {
        return sppsv_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void sppsv_(const char *uplo, const int *n, const int *nrhs, float *AP, float *B, const int *ldb, int *info, size_t)
     * }
     */
    public static MemorySegment sppsv_$address() {
        return sppsv_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void sppsv_(const char *uplo, const int *n, const int *nrhs, float *AP, float *B, const int *ldb, int *info, size_t)
     * }
     */
    public static void sppsv_(MemorySegment uplo, MemorySegment n, MemorySegment nrhs, MemorySegment AP, MemorySegment B, MemorySegment ldb, MemorySegment info, long x7) {
        var mh$ = sppsv_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sppsv_", uplo, n, nrhs, AP, B, ldb, info, x7);
            }
            mh$.invokeExact(uplo, n, nrhs, AP, B, ldb, info, x7);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zppsv_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("zppsv_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zppsv_(const char *uplo, const int *n, const int *nrhs, _Complex double *AP, _Complex double *B, const int *ldb, int *info, size_t)
     * }
     */
    public static FunctionDescriptor zppsv_$descriptor() {
        return zppsv_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zppsv_(const char *uplo, const int *n, const int *nrhs, _Complex double *AP, _Complex double *B, const int *ldb, int *info, size_t)
     * }
     */
    public static MethodHandle zppsv_$handle() {
        return zppsv_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zppsv_(const char *uplo, const int *n, const int *nrhs, _Complex double *AP, _Complex double *B, const int *ldb, int *info, size_t)
     * }
     */
    public static MemorySegment zppsv_$address() {
        return zppsv_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zppsv_(const char *uplo, const int *n, const int *nrhs, _Complex double *AP, _Complex double *B, const int *ldb, int *info, size_t)
     * }
     */
    public static void zppsv_(MemorySegment uplo, MemorySegment n, MemorySegment nrhs, MemorySegment AP, MemorySegment B, MemorySegment ldb, MemorySegment info, long x7) {
        var mh$ = zppsv_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zppsv_", uplo, n, nrhs, AP, B, ldb, info, x7);
            }
            mh$.invokeExact(uplo, n, nrhs, AP, B, ldb, info, x7);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cppsvx_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cppsvx_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cppsvx_(const char *fact, const char *uplo, const int *n, const int *nrhs, _Complex float *AP, _Complex float *AFP, char *equed, float *S, _Complex float *B, const int *ldb, _Complex float *X, const int *ldx, float *rcond, float *ferr, float *berr, _Complex float *work, float *rwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor cppsvx_$descriptor() {
        return cppsvx_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cppsvx_(const char *fact, const char *uplo, const int *n, const int *nrhs, _Complex float *AP, _Complex float *AFP, char *equed, float *S, _Complex float *B, const int *ldb, _Complex float *X, const int *ldx, float *rcond, float *ferr, float *berr, _Complex float *work, float *rwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle cppsvx_$handle() {
        return cppsvx_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cppsvx_(const char *fact, const char *uplo, const int *n, const int *nrhs, _Complex float *AP, _Complex float *AFP, char *equed, float *S, _Complex float *B, const int *ldb, _Complex float *X, const int *ldx, float *rcond, float *ferr, float *berr, _Complex float *work, float *rwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment cppsvx_$address() {
        return cppsvx_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cppsvx_(const char *fact, const char *uplo, const int *n, const int *nrhs, _Complex float *AP, _Complex float *AFP, char *equed, float *S, _Complex float *B, const int *ldb, _Complex float *X, const int *ldx, float *rcond, float *ferr, float *berr, _Complex float *work, float *rwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static void cppsvx_(MemorySegment fact, MemorySegment uplo, MemorySegment n, MemorySegment nrhs, MemorySegment AP, MemorySegment AFP, MemorySegment equed, MemorySegment S, MemorySegment B, MemorySegment ldb, MemorySegment X, MemorySegment ldx, MemorySegment rcond, MemorySegment ferr, MemorySegment berr, MemorySegment work, MemorySegment rwork, MemorySegment info, long x18, long x19, long x20) {
        var mh$ = cppsvx_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cppsvx_", fact, uplo, n, nrhs, AP, AFP, equed, S, B, ldb, X, ldx, rcond, ferr, berr, work, rwork, info, x18, x19, x20);
            }
            mh$.invokeExact(fact, uplo, n, nrhs, AP, AFP, equed, S, B, ldb, X, ldx, rcond, ferr, berr, work, rwork, info, x18, x19, x20);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dppsvx_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("dppsvx_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dppsvx_(const char *fact, const char *uplo, const int *n, const int *nrhs, double *AP, double *AFP, char *equed, double *S, double *B, const int *ldb, double *X, const int *ldx, double *rcond, double *ferr, double *berr, double *work, int *iwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor dppsvx_$descriptor() {
        return dppsvx_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dppsvx_(const char *fact, const char *uplo, const int *n, const int *nrhs, double *AP, double *AFP, char *equed, double *S, double *B, const int *ldb, double *X, const int *ldx, double *rcond, double *ferr, double *berr, double *work, int *iwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle dppsvx_$handle() {
        return dppsvx_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dppsvx_(const char *fact, const char *uplo, const int *n, const int *nrhs, double *AP, double *AFP, char *equed, double *S, double *B, const int *ldb, double *X, const int *ldx, double *rcond, double *ferr, double *berr, double *work, int *iwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment dppsvx_$address() {
        return dppsvx_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dppsvx_(const char *fact, const char *uplo, const int *n, const int *nrhs, double *AP, double *AFP, char *equed, double *S, double *B, const int *ldb, double *X, const int *ldx, double *rcond, double *ferr, double *berr, double *work, int *iwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static void dppsvx_(MemorySegment fact, MemorySegment uplo, MemorySegment n, MemorySegment nrhs, MemorySegment AP, MemorySegment AFP, MemorySegment equed, MemorySegment S, MemorySegment B, MemorySegment ldb, MemorySegment X, MemorySegment ldx, MemorySegment rcond, MemorySegment ferr, MemorySegment berr, MemorySegment work, MemorySegment iwork, MemorySegment info, long x18, long x19, long x20) {
        var mh$ = dppsvx_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dppsvx_", fact, uplo, n, nrhs, AP, AFP, equed, S, B, ldb, X, ldx, rcond, ferr, berr, work, iwork, info, x18, x19, x20);
            }
            mh$.invokeExact(fact, uplo, n, nrhs, AP, AFP, equed, S, B, ldb, X, ldx, rcond, ferr, berr, work, iwork, info, x18, x19, x20);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sppsvx_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("sppsvx_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void sppsvx_(const char *fact, const char *uplo, const int *n, const int *nrhs, float *AP, float *AFP, char *equed, float *S, float *B, const int *ldb, float *X, const int *ldx, float *rcond, float *ferr, float *berr, float *work, int *iwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor sppsvx_$descriptor() {
        return sppsvx_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void sppsvx_(const char *fact, const char *uplo, const int *n, const int *nrhs, float *AP, float *AFP, char *equed, float *S, float *B, const int *ldb, float *X, const int *ldx, float *rcond, float *ferr, float *berr, float *work, int *iwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle sppsvx_$handle() {
        return sppsvx_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void sppsvx_(const char *fact, const char *uplo, const int *n, const int *nrhs, float *AP, float *AFP, char *equed, float *S, float *B, const int *ldb, float *X, const int *ldx, float *rcond, float *ferr, float *berr, float *work, int *iwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment sppsvx_$address() {
        return sppsvx_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void sppsvx_(const char *fact, const char *uplo, const int *n, const int *nrhs, float *AP, float *AFP, char *equed, float *S, float *B, const int *ldb, float *X, const int *ldx, float *rcond, float *ferr, float *berr, float *work, int *iwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static void sppsvx_(MemorySegment fact, MemorySegment uplo, MemorySegment n, MemorySegment nrhs, MemorySegment AP, MemorySegment AFP, MemorySegment equed, MemorySegment S, MemorySegment B, MemorySegment ldb, MemorySegment X, MemorySegment ldx, MemorySegment rcond, MemorySegment ferr, MemorySegment berr, MemorySegment work, MemorySegment iwork, MemorySegment info, long x18, long x19, long x20) {
        var mh$ = sppsvx_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sppsvx_", fact, uplo, n, nrhs, AP, AFP, equed, S, B, ldb, X, ldx, rcond, ferr, berr, work, iwork, info, x18, x19, x20);
            }
            mh$.invokeExact(fact, uplo, n, nrhs, AP, AFP, equed, S, B, ldb, X, ldx, rcond, ferr, berr, work, iwork, info, x18, x19, x20);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zppsvx_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("zppsvx_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zppsvx_(const char *fact, const char *uplo, const int *n, const int *nrhs, _Complex double *AP, _Complex double *AFP, char *equed, double *S, _Complex double *B, const int *ldb, _Complex double *X, const int *ldx, double *rcond, double *ferr, double *berr, _Complex double *work, double *rwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor zppsvx_$descriptor() {
        return zppsvx_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zppsvx_(const char *fact, const char *uplo, const int *n, const int *nrhs, _Complex double *AP, _Complex double *AFP, char *equed, double *S, _Complex double *B, const int *ldb, _Complex double *X, const int *ldx, double *rcond, double *ferr, double *berr, _Complex double *work, double *rwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle zppsvx_$handle() {
        return zppsvx_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zppsvx_(const char *fact, const char *uplo, const int *n, const int *nrhs, _Complex double *AP, _Complex double *AFP, char *equed, double *S, _Complex double *B, const int *ldb, _Complex double *X, const int *ldx, double *rcond, double *ferr, double *berr, _Complex double *work, double *rwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment zppsvx_$address() {
        return zppsvx_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zppsvx_(const char *fact, const char *uplo, const int *n, const int *nrhs, _Complex double *AP, _Complex double *AFP, char *equed, double *S, _Complex double *B, const int *ldb, _Complex double *X, const int *ldx, double *rcond, double *ferr, double *berr, _Complex double *work, double *rwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static void zppsvx_(MemorySegment fact, MemorySegment uplo, MemorySegment n, MemorySegment nrhs, MemorySegment AP, MemorySegment AFP, MemorySegment equed, MemorySegment S, MemorySegment B, MemorySegment ldb, MemorySegment X, MemorySegment ldx, MemorySegment rcond, MemorySegment ferr, MemorySegment berr, MemorySegment work, MemorySegment rwork, MemorySegment info, long x18, long x19, long x20) {
        var mh$ = zppsvx_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zppsvx_", fact, uplo, n, nrhs, AP, AFP, equed, S, B, ldb, X, ldx, rcond, ferr, berr, work, rwork, info, x18, x19, x20);
            }
            mh$.invokeExact(fact, uplo, n, nrhs, AP, AFP, equed, S, B, ldb, X, ldx, rcond, ferr, berr, work, rwork, info, x18, x19, x20);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cpptrf_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cpptrf_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cpptrf_(const char *uplo, const int *n, _Complex float *AP, int *info, size_t)
     * }
     */
    public static FunctionDescriptor cpptrf_$descriptor() {
        return cpptrf_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cpptrf_(const char *uplo, const int *n, _Complex float *AP, int *info, size_t)
     * }
     */
    public static MethodHandle cpptrf_$handle() {
        return cpptrf_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cpptrf_(const char *uplo, const int *n, _Complex float *AP, int *info, size_t)
     * }
     */
    public static MemorySegment cpptrf_$address() {
        return cpptrf_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cpptrf_(const char *uplo, const int *n, _Complex float *AP, int *info, size_t)
     * }
     */
    public static void cpptrf_(MemorySegment uplo, MemorySegment n, MemorySegment AP, MemorySegment info, long x4) {
        var mh$ = cpptrf_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cpptrf_", uplo, n, AP, info, x4);
            }
            mh$.invokeExact(uplo, n, AP, info, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dpptrf_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("dpptrf_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dpptrf_(const char *uplo, const int *n, double *AP, int *info, size_t)
     * }
     */
    public static FunctionDescriptor dpptrf_$descriptor() {
        return dpptrf_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dpptrf_(const char *uplo, const int *n, double *AP, int *info, size_t)
     * }
     */
    public static MethodHandle dpptrf_$handle() {
        return dpptrf_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dpptrf_(const char *uplo, const int *n, double *AP, int *info, size_t)
     * }
     */
    public static MemorySegment dpptrf_$address() {
        return dpptrf_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dpptrf_(const char *uplo, const int *n, double *AP, int *info, size_t)
     * }
     */
    public static void dpptrf_(MemorySegment uplo, MemorySegment n, MemorySegment AP, MemorySegment info, long x4) {
        var mh$ = dpptrf_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dpptrf_", uplo, n, AP, info, x4);
            }
            mh$.invokeExact(uplo, n, AP, info, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class spptrf_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("spptrf_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void spptrf_(const char *uplo, const int *n, float *AP, int *info, size_t)
     * }
     */
    public static FunctionDescriptor spptrf_$descriptor() {
        return spptrf_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void spptrf_(const char *uplo, const int *n, float *AP, int *info, size_t)
     * }
     */
    public static MethodHandle spptrf_$handle() {
        return spptrf_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void spptrf_(const char *uplo, const int *n, float *AP, int *info, size_t)
     * }
     */
    public static MemorySegment spptrf_$address() {
        return spptrf_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void spptrf_(const char *uplo, const int *n, float *AP, int *info, size_t)
     * }
     */
    public static void spptrf_(MemorySegment uplo, MemorySegment n, MemorySegment AP, MemorySegment info, long x4) {
        var mh$ = spptrf_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("spptrf_", uplo, n, AP, info, x4);
            }
            mh$.invokeExact(uplo, n, AP, info, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zpptrf_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("zpptrf_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zpptrf_(const char *uplo, const int *n, _Complex double *AP, int *info, size_t)
     * }
     */
    public static FunctionDescriptor zpptrf_$descriptor() {
        return zpptrf_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zpptrf_(const char *uplo, const int *n, _Complex double *AP, int *info, size_t)
     * }
     */
    public static MethodHandle zpptrf_$handle() {
        return zpptrf_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zpptrf_(const char *uplo, const int *n, _Complex double *AP, int *info, size_t)
     * }
     */
    public static MemorySegment zpptrf_$address() {
        return zpptrf_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zpptrf_(const char *uplo, const int *n, _Complex double *AP, int *info, size_t)
     * }
     */
    public static void zpptrf_(MemorySegment uplo, MemorySegment n, MemorySegment AP, MemorySegment info, long x4) {
        var mh$ = zpptrf_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zpptrf_", uplo, n, AP, info, x4);
            }
            mh$.invokeExact(uplo, n, AP, info, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cpptri_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cpptri_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cpptri_(const char *uplo, const int *n, _Complex float *AP, int *info, size_t)
     * }
     */
    public static FunctionDescriptor cpptri_$descriptor() {
        return cpptri_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cpptri_(const char *uplo, const int *n, _Complex float *AP, int *info, size_t)
     * }
     */
    public static MethodHandle cpptri_$handle() {
        return cpptri_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cpptri_(const char *uplo, const int *n, _Complex float *AP, int *info, size_t)
     * }
     */
    public static MemorySegment cpptri_$address() {
        return cpptri_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cpptri_(const char *uplo, const int *n, _Complex float *AP, int *info, size_t)
     * }
     */
    public static void cpptri_(MemorySegment uplo, MemorySegment n, MemorySegment AP, MemorySegment info, long x4) {
        var mh$ = cpptri_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cpptri_", uplo, n, AP, info, x4);
            }
            mh$.invokeExact(uplo, n, AP, info, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dpptri_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("dpptri_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dpptri_(const char *uplo, const int *n, double *AP, int *info, size_t)
     * }
     */
    public static FunctionDescriptor dpptri_$descriptor() {
        return dpptri_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dpptri_(const char *uplo, const int *n, double *AP, int *info, size_t)
     * }
     */
    public static MethodHandle dpptri_$handle() {
        return dpptri_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dpptri_(const char *uplo, const int *n, double *AP, int *info, size_t)
     * }
     */
    public static MemorySegment dpptri_$address() {
        return dpptri_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dpptri_(const char *uplo, const int *n, double *AP, int *info, size_t)
     * }
     */
    public static void dpptri_(MemorySegment uplo, MemorySegment n, MemorySegment AP, MemorySegment info, long x4) {
        var mh$ = dpptri_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dpptri_", uplo, n, AP, info, x4);
            }
            mh$.invokeExact(uplo, n, AP, info, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class spptri_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("spptri_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void spptri_(const char *uplo, const int *n, float *AP, int *info, size_t)
     * }
     */
    public static FunctionDescriptor spptri_$descriptor() {
        return spptri_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void spptri_(const char *uplo, const int *n, float *AP, int *info, size_t)
     * }
     */
    public static MethodHandle spptri_$handle() {
        return spptri_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void spptri_(const char *uplo, const int *n, float *AP, int *info, size_t)
     * }
     */
    public static MemorySegment spptri_$address() {
        return spptri_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void spptri_(const char *uplo, const int *n, float *AP, int *info, size_t)
     * }
     */
    public static void spptri_(MemorySegment uplo, MemorySegment n, MemorySegment AP, MemorySegment info, long x4) {
        var mh$ = spptri_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("spptri_", uplo, n, AP, info, x4);
            }
            mh$.invokeExact(uplo, n, AP, info, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zpptri_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("zpptri_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zpptri_(const char *uplo, const int *n, _Complex double *AP, int *info, size_t)
     * }
     */
    public static FunctionDescriptor zpptri_$descriptor() {
        return zpptri_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zpptri_(const char *uplo, const int *n, _Complex double *AP, int *info, size_t)
     * }
     */
    public static MethodHandle zpptri_$handle() {
        return zpptri_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zpptri_(const char *uplo, const int *n, _Complex double *AP, int *info, size_t)
     * }
     */
    public static MemorySegment zpptri_$address() {
        return zpptri_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zpptri_(const char *uplo, const int *n, _Complex double *AP, int *info, size_t)
     * }
     */
    public static void zpptri_(MemorySegment uplo, MemorySegment n, MemorySegment AP, MemorySegment info, long x4) {
        var mh$ = zpptri_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zpptri_", uplo, n, AP, info, x4);
            }
            mh$.invokeExact(uplo, n, AP, info, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cpptrs_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cpptrs_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cpptrs_(const char *uplo, const int *n, const int *nrhs, const _Complex float *AP, _Complex float *B, const int *ldb, int *info, size_t)
     * }
     */
    public static FunctionDescriptor cpptrs_$descriptor() {
        return cpptrs_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cpptrs_(const char *uplo, const int *n, const int *nrhs, const _Complex float *AP, _Complex float *B, const int *ldb, int *info, size_t)
     * }
     */
    public static MethodHandle cpptrs_$handle() {
        return cpptrs_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cpptrs_(const char *uplo, const int *n, const int *nrhs, const _Complex float *AP, _Complex float *B, const int *ldb, int *info, size_t)
     * }
     */
    public static MemorySegment cpptrs_$address() {
        return cpptrs_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cpptrs_(const char *uplo, const int *n, const int *nrhs, const _Complex float *AP, _Complex float *B, const int *ldb, int *info, size_t)
     * }
     */
    public static void cpptrs_(MemorySegment uplo, MemorySegment n, MemorySegment nrhs, MemorySegment AP, MemorySegment B, MemorySegment ldb, MemorySegment info, long x7) {
        var mh$ = cpptrs_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cpptrs_", uplo, n, nrhs, AP, B, ldb, info, x7);
            }
            mh$.invokeExact(uplo, n, nrhs, AP, B, ldb, info, x7);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dpptrs_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("dpptrs_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dpptrs_(const char *uplo, const int *n, const int *nrhs, const double *AP, double *B, const int *ldb, int *info, size_t)
     * }
     */
    public static FunctionDescriptor dpptrs_$descriptor() {
        return dpptrs_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dpptrs_(const char *uplo, const int *n, const int *nrhs, const double *AP, double *B, const int *ldb, int *info, size_t)
     * }
     */
    public static MethodHandle dpptrs_$handle() {
        return dpptrs_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dpptrs_(const char *uplo, const int *n, const int *nrhs, const double *AP, double *B, const int *ldb, int *info, size_t)
     * }
     */
    public static MemorySegment dpptrs_$address() {
        return dpptrs_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dpptrs_(const char *uplo, const int *n, const int *nrhs, const double *AP, double *B, const int *ldb, int *info, size_t)
     * }
     */
    public static void dpptrs_(MemorySegment uplo, MemorySegment n, MemorySegment nrhs, MemorySegment AP, MemorySegment B, MemorySegment ldb, MemorySegment info, long x7) {
        var mh$ = dpptrs_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dpptrs_", uplo, n, nrhs, AP, B, ldb, info, x7);
            }
            mh$.invokeExact(uplo, n, nrhs, AP, B, ldb, info, x7);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class spptrs_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("spptrs_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void spptrs_(const char *uplo, const int *n, const int *nrhs, const float *AP, float *B, const int *ldb, int *info, size_t)
     * }
     */
    public static FunctionDescriptor spptrs_$descriptor() {
        return spptrs_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void spptrs_(const char *uplo, const int *n, const int *nrhs, const float *AP, float *B, const int *ldb, int *info, size_t)
     * }
     */
    public static MethodHandle spptrs_$handle() {
        return spptrs_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void spptrs_(const char *uplo, const int *n, const int *nrhs, const float *AP, float *B, const int *ldb, int *info, size_t)
     * }
     */
    public static MemorySegment spptrs_$address() {
        return spptrs_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void spptrs_(const char *uplo, const int *n, const int *nrhs, const float *AP, float *B, const int *ldb, int *info, size_t)
     * }
     */
    public static void spptrs_(MemorySegment uplo, MemorySegment n, MemorySegment nrhs, MemorySegment AP, MemorySegment B, MemorySegment ldb, MemorySegment info, long x7) {
        var mh$ = spptrs_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("spptrs_", uplo, n, nrhs, AP, B, ldb, info, x7);
            }
            mh$.invokeExact(uplo, n, nrhs, AP, B, ldb, info, x7);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zpptrs_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("zpptrs_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zpptrs_(const char *uplo, const int *n, const int *nrhs, const _Complex double *AP, _Complex double *B, const int *ldb, int *info, size_t)
     * }
     */
    public static FunctionDescriptor zpptrs_$descriptor() {
        return zpptrs_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zpptrs_(const char *uplo, const int *n, const int *nrhs, const _Complex double *AP, _Complex double *B, const int *ldb, int *info, size_t)
     * }
     */
    public static MethodHandle zpptrs_$handle() {
        return zpptrs_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zpptrs_(const char *uplo, const int *n, const int *nrhs, const _Complex double *AP, _Complex double *B, const int *ldb, int *info, size_t)
     * }
     */
    public static MemorySegment zpptrs_$address() {
        return zpptrs_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zpptrs_(const char *uplo, const int *n, const int *nrhs, const _Complex double *AP, _Complex double *B, const int *ldb, int *info, size_t)
     * }
     */
    public static void zpptrs_(MemorySegment uplo, MemorySegment n, MemorySegment nrhs, MemorySegment AP, MemorySegment B, MemorySegment ldb, MemorySegment info, long x7) {
        var mh$ = zpptrs_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zpptrs_", uplo, n, nrhs, AP, B, ldb, info, x7);
            }
            mh$.invokeExact(uplo, n, nrhs, AP, B, ldb, info, x7);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cpstrf_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cpstrf_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cpstrf_(const char *uplo, const int *n, _Complex float *A, const int *lda, int *piv, int *rank, const float *tol, float *work, int *info, size_t)
     * }
     */
    public static FunctionDescriptor cpstrf_$descriptor() {
        return cpstrf_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cpstrf_(const char *uplo, const int *n, _Complex float *A, const int *lda, int *piv, int *rank, const float *tol, float *work, int *info, size_t)
     * }
     */
    public static MethodHandle cpstrf_$handle() {
        return cpstrf_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cpstrf_(const char *uplo, const int *n, _Complex float *A, const int *lda, int *piv, int *rank, const float *tol, float *work, int *info, size_t)
     * }
     */
    public static MemorySegment cpstrf_$address() {
        return cpstrf_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cpstrf_(const char *uplo, const int *n, _Complex float *A, const int *lda, int *piv, int *rank, const float *tol, float *work, int *info, size_t)
     * }
     */
    public static void cpstrf_(MemorySegment uplo, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment piv, MemorySegment rank, MemorySegment tol, MemorySegment work, MemorySegment info, long x9) {
        var mh$ = cpstrf_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cpstrf_", uplo, n, A, lda, piv, rank, tol, work, info, x9);
            }
            mh$.invokeExact(uplo, n, A, lda, piv, rank, tol, work, info, x9);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dpstrf_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("dpstrf_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dpstrf_(const char *uplo, const int *n, double *A, const int *lda, int *piv, int *rank, const double *tol, double *work, int *info, size_t)
     * }
     */
    public static FunctionDescriptor dpstrf_$descriptor() {
        return dpstrf_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dpstrf_(const char *uplo, const int *n, double *A, const int *lda, int *piv, int *rank, const double *tol, double *work, int *info, size_t)
     * }
     */
    public static MethodHandle dpstrf_$handle() {
        return dpstrf_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dpstrf_(const char *uplo, const int *n, double *A, const int *lda, int *piv, int *rank, const double *tol, double *work, int *info, size_t)
     * }
     */
    public static MemorySegment dpstrf_$address() {
        return dpstrf_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dpstrf_(const char *uplo, const int *n, double *A, const int *lda, int *piv, int *rank, const double *tol, double *work, int *info, size_t)
     * }
     */
    public static void dpstrf_(MemorySegment uplo, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment piv, MemorySegment rank, MemorySegment tol, MemorySegment work, MemorySegment info, long x9) {
        var mh$ = dpstrf_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dpstrf_", uplo, n, A, lda, piv, rank, tol, work, info, x9);
            }
            mh$.invokeExact(uplo, n, A, lda, piv, rank, tol, work, info, x9);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class spstrf_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("spstrf_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void spstrf_(const char *uplo, const int *n, float *A, const int *lda, int *piv, int *rank, const float *tol, float *work, int *info, size_t)
     * }
     */
    public static FunctionDescriptor spstrf_$descriptor() {
        return spstrf_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void spstrf_(const char *uplo, const int *n, float *A, const int *lda, int *piv, int *rank, const float *tol, float *work, int *info, size_t)
     * }
     */
    public static MethodHandle spstrf_$handle() {
        return spstrf_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void spstrf_(const char *uplo, const int *n, float *A, const int *lda, int *piv, int *rank, const float *tol, float *work, int *info, size_t)
     * }
     */
    public static MemorySegment spstrf_$address() {
        return spstrf_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void spstrf_(const char *uplo, const int *n, float *A, const int *lda, int *piv, int *rank, const float *tol, float *work, int *info, size_t)
     * }
     */
    public static void spstrf_(MemorySegment uplo, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment piv, MemorySegment rank, MemorySegment tol, MemorySegment work, MemorySegment info, long x9) {
        var mh$ = spstrf_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("spstrf_", uplo, n, A, lda, piv, rank, tol, work, info, x9);
            }
            mh$.invokeExact(uplo, n, A, lda, piv, rank, tol, work, info, x9);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zpstrf_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("zpstrf_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zpstrf_(const char *uplo, const int *n, _Complex double *A, const int *lda, int *piv, int *rank, const double *tol, double *work, int *info, size_t)
     * }
     */
    public static FunctionDescriptor zpstrf_$descriptor() {
        return zpstrf_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zpstrf_(const char *uplo, const int *n, _Complex double *A, const int *lda, int *piv, int *rank, const double *tol, double *work, int *info, size_t)
     * }
     */
    public static MethodHandle zpstrf_$handle() {
        return zpstrf_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zpstrf_(const char *uplo, const int *n, _Complex double *A, const int *lda, int *piv, int *rank, const double *tol, double *work, int *info, size_t)
     * }
     */
    public static MemorySegment zpstrf_$address() {
        return zpstrf_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zpstrf_(const char *uplo, const int *n, _Complex double *A, const int *lda, int *piv, int *rank, const double *tol, double *work, int *info, size_t)
     * }
     */
    public static void zpstrf_(MemorySegment uplo, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment piv, MemorySegment rank, MemorySegment tol, MemorySegment work, MemorySegment info, long x9) {
        var mh$ = zpstrf_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zpstrf_", uplo, n, A, lda, piv, rank, tol, work, info, x9);
            }
            mh$.invokeExact(uplo, n, A, lda, piv, rank, tol, work, info, x9);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cptcon_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cptcon_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cptcon_(const int *n, const float *D, const _Complex float *E, const float *anorm, float *rcond, float *rwork, int *info)
     * }
     */
    public static FunctionDescriptor cptcon_$descriptor() {
        return cptcon_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cptcon_(const int *n, const float *D, const _Complex float *E, const float *anorm, float *rcond, float *rwork, int *info)
     * }
     */
    public static MethodHandle cptcon_$handle() {
        return cptcon_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cptcon_(const int *n, const float *D, const _Complex float *E, const float *anorm, float *rcond, float *rwork, int *info)
     * }
     */
    public static MemorySegment cptcon_$address() {
        return cptcon_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cptcon_(const int *n, const float *D, const _Complex float *E, const float *anorm, float *rcond, float *rwork, int *info)
     * }
     */
    public static void cptcon_(MemorySegment n, MemorySegment D, MemorySegment E, MemorySegment anorm, MemorySegment rcond, MemorySegment rwork, MemorySegment info) {
        var mh$ = cptcon_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cptcon_", n, D, E, anorm, rcond, rwork, info);
            }
            mh$.invokeExact(n, D, E, anorm, rcond, rwork, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dptcon_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("dptcon_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dptcon_(const int *n, const double *D, const double *E, const double *anorm, double *rcond, double *work, int *info)
     * }
     */
    public static FunctionDescriptor dptcon_$descriptor() {
        return dptcon_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dptcon_(const int *n, const double *D, const double *E, const double *anorm, double *rcond, double *work, int *info)
     * }
     */
    public static MethodHandle dptcon_$handle() {
        return dptcon_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dptcon_(const int *n, const double *D, const double *E, const double *anorm, double *rcond, double *work, int *info)
     * }
     */
    public static MemorySegment dptcon_$address() {
        return dptcon_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dptcon_(const int *n, const double *D, const double *E, const double *anorm, double *rcond, double *work, int *info)
     * }
     */
    public static void dptcon_(MemorySegment n, MemorySegment D, MemorySegment E, MemorySegment anorm, MemorySegment rcond, MemorySegment work, MemorySegment info) {
        var mh$ = dptcon_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dptcon_", n, D, E, anorm, rcond, work, info);
            }
            mh$.invokeExact(n, D, E, anorm, rcond, work, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sptcon_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("sptcon_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void sptcon_(const int *n, const float *D, const float *E, const float *anorm, float *rcond, float *work, int *info)
     * }
     */
    public static FunctionDescriptor sptcon_$descriptor() {
        return sptcon_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void sptcon_(const int *n, const float *D, const float *E, const float *anorm, float *rcond, float *work, int *info)
     * }
     */
    public static MethodHandle sptcon_$handle() {
        return sptcon_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void sptcon_(const int *n, const float *D, const float *E, const float *anorm, float *rcond, float *work, int *info)
     * }
     */
    public static MemorySegment sptcon_$address() {
        return sptcon_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void sptcon_(const int *n, const float *D, const float *E, const float *anorm, float *rcond, float *work, int *info)
     * }
     */
    public static void sptcon_(MemorySegment n, MemorySegment D, MemorySegment E, MemorySegment anorm, MemorySegment rcond, MemorySegment work, MemorySegment info) {
        var mh$ = sptcon_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sptcon_", n, D, E, anorm, rcond, work, info);
            }
            mh$.invokeExact(n, D, E, anorm, rcond, work, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zptcon_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("zptcon_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zptcon_(const int *n, const double *D, const _Complex double *E, const double *anorm, double *rcond, double *rwork, int *info)
     * }
     */
    public static FunctionDescriptor zptcon_$descriptor() {
        return zptcon_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zptcon_(const int *n, const double *D, const _Complex double *E, const double *anorm, double *rcond, double *rwork, int *info)
     * }
     */
    public static MethodHandle zptcon_$handle() {
        return zptcon_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zptcon_(const int *n, const double *D, const _Complex double *E, const double *anorm, double *rcond, double *rwork, int *info)
     * }
     */
    public static MemorySegment zptcon_$address() {
        return zptcon_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zptcon_(const int *n, const double *D, const _Complex double *E, const double *anorm, double *rcond, double *rwork, int *info)
     * }
     */
    public static void zptcon_(MemorySegment n, MemorySegment D, MemorySegment E, MemorySegment anorm, MemorySegment rcond, MemorySegment rwork, MemorySegment info) {
        var mh$ = zptcon_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zptcon_", n, D, E, anorm, rcond, rwork, info);
            }
            mh$.invokeExact(n, D, E, anorm, rcond, rwork, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cpteqr_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cpteqr_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cpteqr_(const char *compz, const int *n, float *D, float *E, _Complex float *Z, const int *ldz, float *work, int *info, size_t)
     * }
     */
    public static FunctionDescriptor cpteqr_$descriptor() {
        return cpteqr_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cpteqr_(const char *compz, const int *n, float *D, float *E, _Complex float *Z, const int *ldz, float *work, int *info, size_t)
     * }
     */
    public static MethodHandle cpteqr_$handle() {
        return cpteqr_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cpteqr_(const char *compz, const int *n, float *D, float *E, _Complex float *Z, const int *ldz, float *work, int *info, size_t)
     * }
     */
    public static MemorySegment cpteqr_$address() {
        return cpteqr_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cpteqr_(const char *compz, const int *n, float *D, float *E, _Complex float *Z, const int *ldz, float *work, int *info, size_t)
     * }
     */
    public static void cpteqr_(MemorySegment compz, MemorySegment n, MemorySegment D, MemorySegment E, MemorySegment Z, MemorySegment ldz, MemorySegment work, MemorySegment info, long x8) {
        var mh$ = cpteqr_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cpteqr_", compz, n, D, E, Z, ldz, work, info, x8);
            }
            mh$.invokeExact(compz, n, D, E, Z, ldz, work, info, x8);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dpteqr_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("dpteqr_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dpteqr_(const char *compz, const int *n, double *D, double *E, double *Z, const int *ldz, double *work, int *info, size_t)
     * }
     */
    public static FunctionDescriptor dpteqr_$descriptor() {
        return dpteqr_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dpteqr_(const char *compz, const int *n, double *D, double *E, double *Z, const int *ldz, double *work, int *info, size_t)
     * }
     */
    public static MethodHandle dpteqr_$handle() {
        return dpteqr_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dpteqr_(const char *compz, const int *n, double *D, double *E, double *Z, const int *ldz, double *work, int *info, size_t)
     * }
     */
    public static MemorySegment dpteqr_$address() {
        return dpteqr_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dpteqr_(const char *compz, const int *n, double *D, double *E, double *Z, const int *ldz, double *work, int *info, size_t)
     * }
     */
    public static void dpteqr_(MemorySegment compz, MemorySegment n, MemorySegment D, MemorySegment E, MemorySegment Z, MemorySegment ldz, MemorySegment work, MemorySegment info, long x8) {
        var mh$ = dpteqr_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dpteqr_", compz, n, D, E, Z, ldz, work, info, x8);
            }
            mh$.invokeExact(compz, n, D, E, Z, ldz, work, info, x8);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class spteqr_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("spteqr_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void spteqr_(const char *compz, const int *n, float *D, float *E, float *Z, const int *ldz, float *work, int *info, size_t)
     * }
     */
    public static FunctionDescriptor spteqr_$descriptor() {
        return spteqr_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void spteqr_(const char *compz, const int *n, float *D, float *E, float *Z, const int *ldz, float *work, int *info, size_t)
     * }
     */
    public static MethodHandle spteqr_$handle() {
        return spteqr_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void spteqr_(const char *compz, const int *n, float *D, float *E, float *Z, const int *ldz, float *work, int *info, size_t)
     * }
     */
    public static MemorySegment spteqr_$address() {
        return spteqr_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void spteqr_(const char *compz, const int *n, float *D, float *E, float *Z, const int *ldz, float *work, int *info, size_t)
     * }
     */
    public static void spteqr_(MemorySegment compz, MemorySegment n, MemorySegment D, MemorySegment E, MemorySegment Z, MemorySegment ldz, MemorySegment work, MemorySegment info, long x8) {
        var mh$ = spteqr_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("spteqr_", compz, n, D, E, Z, ldz, work, info, x8);
            }
            mh$.invokeExact(compz, n, D, E, Z, ldz, work, info, x8);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zpteqr_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("zpteqr_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zpteqr_(const char *compz, const int *n, double *D, double *E, _Complex double *Z, const int *ldz, double *work, int *info, size_t)
     * }
     */
    public static FunctionDescriptor zpteqr_$descriptor() {
        return zpteqr_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zpteqr_(const char *compz, const int *n, double *D, double *E, _Complex double *Z, const int *ldz, double *work, int *info, size_t)
     * }
     */
    public static MethodHandle zpteqr_$handle() {
        return zpteqr_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zpteqr_(const char *compz, const int *n, double *D, double *E, _Complex double *Z, const int *ldz, double *work, int *info, size_t)
     * }
     */
    public static MemorySegment zpteqr_$address() {
        return zpteqr_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zpteqr_(const char *compz, const int *n, double *D, double *E, _Complex double *Z, const int *ldz, double *work, int *info, size_t)
     * }
     */
    public static void zpteqr_(MemorySegment compz, MemorySegment n, MemorySegment D, MemorySegment E, MemorySegment Z, MemorySegment ldz, MemorySegment work, MemorySegment info, long x8) {
        var mh$ = zpteqr_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zpteqr_", compz, n, D, E, Z, ldz, work, info, x8);
            }
            mh$.invokeExact(compz, n, D, E, Z, ldz, work, info, x8);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cptrfs_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cptrfs_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cptrfs_(const char *uplo, const int *n, const int *nrhs, const float *D, const _Complex float *E, const float *DF, const _Complex float *EF, const _Complex float *B, const int *ldb, _Complex float *X, const int *ldx, float *ferr, float *berr, _Complex float *work, float *rwork, int *info, size_t)
     * }
     */
    public static FunctionDescriptor cptrfs_$descriptor() {
        return cptrfs_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cptrfs_(const char *uplo, const int *n, const int *nrhs, const float *D, const _Complex float *E, const float *DF, const _Complex float *EF, const _Complex float *B, const int *ldb, _Complex float *X, const int *ldx, float *ferr, float *berr, _Complex float *work, float *rwork, int *info, size_t)
     * }
     */
    public static MethodHandle cptrfs_$handle() {
        return cptrfs_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cptrfs_(const char *uplo, const int *n, const int *nrhs, const float *D, const _Complex float *E, const float *DF, const _Complex float *EF, const _Complex float *B, const int *ldb, _Complex float *X, const int *ldx, float *ferr, float *berr, _Complex float *work, float *rwork, int *info, size_t)
     * }
     */
    public static MemorySegment cptrfs_$address() {
        return cptrfs_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cptrfs_(const char *uplo, const int *n, const int *nrhs, const float *D, const _Complex float *E, const float *DF, const _Complex float *EF, const _Complex float *B, const int *ldb, _Complex float *X, const int *ldx, float *ferr, float *berr, _Complex float *work, float *rwork, int *info, size_t)
     * }
     */
    public static void cptrfs_(MemorySegment uplo, MemorySegment n, MemorySegment nrhs, MemorySegment D, MemorySegment E, MemorySegment DF, MemorySegment EF, MemorySegment B, MemorySegment ldb, MemorySegment X, MemorySegment ldx, MemorySegment ferr, MemorySegment berr, MemorySegment work, MemorySegment rwork, MemorySegment info, long x16) {
        var mh$ = cptrfs_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cptrfs_", uplo, n, nrhs, D, E, DF, EF, B, ldb, X, ldx, ferr, berr, work, rwork, info, x16);
            }
            mh$.invokeExact(uplo, n, nrhs, D, E, DF, EF, B, ldb, X, ldx, ferr, berr, work, rwork, info, x16);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dptrfs_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("dptrfs_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dptrfs_(const int *n, const int *nrhs, const double *D, const double *E, const double *DF, const double *EF, const double *B, const int *ldb, double *X, const int *ldx, double *ferr, double *berr, double *work, int *info)
     * }
     */
    public static FunctionDescriptor dptrfs_$descriptor() {
        return dptrfs_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dptrfs_(const int *n, const int *nrhs, const double *D, const double *E, const double *DF, const double *EF, const double *B, const int *ldb, double *X, const int *ldx, double *ferr, double *berr, double *work, int *info)
     * }
     */
    public static MethodHandle dptrfs_$handle() {
        return dptrfs_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dptrfs_(const int *n, const int *nrhs, const double *D, const double *E, const double *DF, const double *EF, const double *B, const int *ldb, double *X, const int *ldx, double *ferr, double *berr, double *work, int *info)
     * }
     */
    public static MemorySegment dptrfs_$address() {
        return dptrfs_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dptrfs_(const int *n, const int *nrhs, const double *D, const double *E, const double *DF, const double *EF, const double *B, const int *ldb, double *X, const int *ldx, double *ferr, double *berr, double *work, int *info)
     * }
     */
    public static void dptrfs_(MemorySegment n, MemorySegment nrhs, MemorySegment D, MemorySegment E, MemorySegment DF, MemorySegment EF, MemorySegment B, MemorySegment ldb, MemorySegment X, MemorySegment ldx, MemorySegment ferr, MemorySegment berr, MemorySegment work, MemorySegment info) {
        var mh$ = dptrfs_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dptrfs_", n, nrhs, D, E, DF, EF, B, ldb, X, ldx, ferr, berr, work, info);
            }
            mh$.invokeExact(n, nrhs, D, E, DF, EF, B, ldb, X, ldx, ferr, berr, work, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sptrfs_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("sptrfs_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void sptrfs_(const int *n, const int *nrhs, const float *D, const float *E, const float *DF, const float *EF, const float *B, const int *ldb, float *X, const int *ldx, float *ferr, float *berr, float *work, int *info)
     * }
     */
    public static FunctionDescriptor sptrfs_$descriptor() {
        return sptrfs_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void sptrfs_(const int *n, const int *nrhs, const float *D, const float *E, const float *DF, const float *EF, const float *B, const int *ldb, float *X, const int *ldx, float *ferr, float *berr, float *work, int *info)
     * }
     */
    public static MethodHandle sptrfs_$handle() {
        return sptrfs_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void sptrfs_(const int *n, const int *nrhs, const float *D, const float *E, const float *DF, const float *EF, const float *B, const int *ldb, float *X, const int *ldx, float *ferr, float *berr, float *work, int *info)
     * }
     */
    public static MemorySegment sptrfs_$address() {
        return sptrfs_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void sptrfs_(const int *n, const int *nrhs, const float *D, const float *E, const float *DF, const float *EF, const float *B, const int *ldb, float *X, const int *ldx, float *ferr, float *berr, float *work, int *info)
     * }
     */
    public static void sptrfs_(MemorySegment n, MemorySegment nrhs, MemorySegment D, MemorySegment E, MemorySegment DF, MemorySegment EF, MemorySegment B, MemorySegment ldb, MemorySegment X, MemorySegment ldx, MemorySegment ferr, MemorySegment berr, MemorySegment work, MemorySegment info) {
        var mh$ = sptrfs_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sptrfs_", n, nrhs, D, E, DF, EF, B, ldb, X, ldx, ferr, berr, work, info);
            }
            mh$.invokeExact(n, nrhs, D, E, DF, EF, B, ldb, X, ldx, ferr, berr, work, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zptrfs_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("zptrfs_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zptrfs_(const char *uplo, const int *n, const int *nrhs, const double *D, const _Complex double *E, const double *DF, const _Complex double *EF, const _Complex double *B, const int *ldb, _Complex double *X, const int *ldx, double *ferr, double *berr, _Complex double *work, double *rwork, int *info, size_t)
     * }
     */
    public static FunctionDescriptor zptrfs_$descriptor() {
        return zptrfs_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zptrfs_(const char *uplo, const int *n, const int *nrhs, const double *D, const _Complex double *E, const double *DF, const _Complex double *EF, const _Complex double *B, const int *ldb, _Complex double *X, const int *ldx, double *ferr, double *berr, _Complex double *work, double *rwork, int *info, size_t)
     * }
     */
    public static MethodHandle zptrfs_$handle() {
        return zptrfs_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zptrfs_(const char *uplo, const int *n, const int *nrhs, const double *D, const _Complex double *E, const double *DF, const _Complex double *EF, const _Complex double *B, const int *ldb, _Complex double *X, const int *ldx, double *ferr, double *berr, _Complex double *work, double *rwork, int *info, size_t)
     * }
     */
    public static MemorySegment zptrfs_$address() {
        return zptrfs_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zptrfs_(const char *uplo, const int *n, const int *nrhs, const double *D, const _Complex double *E, const double *DF, const _Complex double *EF, const _Complex double *B, const int *ldb, _Complex double *X, const int *ldx, double *ferr, double *berr, _Complex double *work, double *rwork, int *info, size_t)
     * }
     */
    public static void zptrfs_(MemorySegment uplo, MemorySegment n, MemorySegment nrhs, MemorySegment D, MemorySegment E, MemorySegment DF, MemorySegment EF, MemorySegment B, MemorySegment ldb, MemorySegment X, MemorySegment ldx, MemorySegment ferr, MemorySegment berr, MemorySegment work, MemorySegment rwork, MemorySegment info, long x16) {
        var mh$ = zptrfs_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zptrfs_", uplo, n, nrhs, D, E, DF, EF, B, ldb, X, ldx, ferr, berr, work, rwork, info, x16);
            }
            mh$.invokeExact(uplo, n, nrhs, D, E, DF, EF, B, ldb, X, ldx, ferr, berr, work, rwork, info, x16);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cptsv_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cptsv_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cptsv_(const int *n, const int *nrhs, float *D, _Complex float *E, _Complex float *B, const int *ldb, int *info)
     * }
     */
    public static FunctionDescriptor cptsv_$descriptor() {
        return cptsv_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cptsv_(const int *n, const int *nrhs, float *D, _Complex float *E, _Complex float *B, const int *ldb, int *info)
     * }
     */
    public static MethodHandle cptsv_$handle() {
        return cptsv_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cptsv_(const int *n, const int *nrhs, float *D, _Complex float *E, _Complex float *B, const int *ldb, int *info)
     * }
     */
    public static MemorySegment cptsv_$address() {
        return cptsv_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cptsv_(const int *n, const int *nrhs, float *D, _Complex float *E, _Complex float *B, const int *ldb, int *info)
     * }
     */
    public static void cptsv_(MemorySegment n, MemorySegment nrhs, MemorySegment D, MemorySegment E, MemorySegment B, MemorySegment ldb, MemorySegment info) {
        var mh$ = cptsv_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cptsv_", n, nrhs, D, E, B, ldb, info);
            }
            mh$.invokeExact(n, nrhs, D, E, B, ldb, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dptsv_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("dptsv_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dptsv_(const int *n, const int *nrhs, double *D, double *E, double *B, const int *ldb, int *info)
     * }
     */
    public static FunctionDescriptor dptsv_$descriptor() {
        return dptsv_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dptsv_(const int *n, const int *nrhs, double *D, double *E, double *B, const int *ldb, int *info)
     * }
     */
    public static MethodHandle dptsv_$handle() {
        return dptsv_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dptsv_(const int *n, const int *nrhs, double *D, double *E, double *B, const int *ldb, int *info)
     * }
     */
    public static MemorySegment dptsv_$address() {
        return dptsv_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dptsv_(const int *n, const int *nrhs, double *D, double *E, double *B, const int *ldb, int *info)
     * }
     */
    public static void dptsv_(MemorySegment n, MemorySegment nrhs, MemorySegment D, MemorySegment E, MemorySegment B, MemorySegment ldb, MemorySegment info) {
        var mh$ = dptsv_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dptsv_", n, nrhs, D, E, B, ldb, info);
            }
            mh$.invokeExact(n, nrhs, D, E, B, ldb, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sptsv_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("sptsv_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void sptsv_(const int *n, const int *nrhs, float *D, float *E, float *B, const int *ldb, int *info)
     * }
     */
    public static FunctionDescriptor sptsv_$descriptor() {
        return sptsv_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void sptsv_(const int *n, const int *nrhs, float *D, float *E, float *B, const int *ldb, int *info)
     * }
     */
    public static MethodHandle sptsv_$handle() {
        return sptsv_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void sptsv_(const int *n, const int *nrhs, float *D, float *E, float *B, const int *ldb, int *info)
     * }
     */
    public static MemorySegment sptsv_$address() {
        return sptsv_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void sptsv_(const int *n, const int *nrhs, float *D, float *E, float *B, const int *ldb, int *info)
     * }
     */
    public static void sptsv_(MemorySegment n, MemorySegment nrhs, MemorySegment D, MemorySegment E, MemorySegment B, MemorySegment ldb, MemorySegment info) {
        var mh$ = sptsv_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sptsv_", n, nrhs, D, E, B, ldb, info);
            }
            mh$.invokeExact(n, nrhs, D, E, B, ldb, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zptsv_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("zptsv_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zptsv_(const int *n, const int *nrhs, double *D, _Complex double *E, _Complex double *B, const int *ldb, int *info)
     * }
     */
    public static FunctionDescriptor zptsv_$descriptor() {
        return zptsv_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zptsv_(const int *n, const int *nrhs, double *D, _Complex double *E, _Complex double *B, const int *ldb, int *info)
     * }
     */
    public static MethodHandle zptsv_$handle() {
        return zptsv_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zptsv_(const int *n, const int *nrhs, double *D, _Complex double *E, _Complex double *B, const int *ldb, int *info)
     * }
     */
    public static MemorySegment zptsv_$address() {
        return zptsv_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zptsv_(const int *n, const int *nrhs, double *D, _Complex double *E, _Complex double *B, const int *ldb, int *info)
     * }
     */
    public static void zptsv_(MemorySegment n, MemorySegment nrhs, MemorySegment D, MemorySegment E, MemorySegment B, MemorySegment ldb, MemorySegment info) {
        var mh$ = zptsv_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zptsv_", n, nrhs, D, E, B, ldb, info);
            }
            mh$.invokeExact(n, nrhs, D, E, B, ldb, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cptsvx_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cptsvx_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cptsvx_(const char *fact, const int *n, const int *nrhs, const float *D, const _Complex float *E, float *DF, _Complex float *EF, const _Complex float *B, const int *ldb, _Complex float *X, const int *ldx, float *rcond, float *ferr, float *berr, _Complex float *work, float *rwork, int *info, size_t)
     * }
     */
    public static FunctionDescriptor cptsvx_$descriptor() {
        return cptsvx_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cptsvx_(const char *fact, const int *n, const int *nrhs, const float *D, const _Complex float *E, float *DF, _Complex float *EF, const _Complex float *B, const int *ldb, _Complex float *X, const int *ldx, float *rcond, float *ferr, float *berr, _Complex float *work, float *rwork, int *info, size_t)
     * }
     */
    public static MethodHandle cptsvx_$handle() {
        return cptsvx_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cptsvx_(const char *fact, const int *n, const int *nrhs, const float *D, const _Complex float *E, float *DF, _Complex float *EF, const _Complex float *B, const int *ldb, _Complex float *X, const int *ldx, float *rcond, float *ferr, float *berr, _Complex float *work, float *rwork, int *info, size_t)
     * }
     */
    public static MemorySegment cptsvx_$address() {
        return cptsvx_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cptsvx_(const char *fact, const int *n, const int *nrhs, const float *D, const _Complex float *E, float *DF, _Complex float *EF, const _Complex float *B, const int *ldb, _Complex float *X, const int *ldx, float *rcond, float *ferr, float *berr, _Complex float *work, float *rwork, int *info, size_t)
     * }
     */
    public static void cptsvx_(MemorySegment fact, MemorySegment n, MemorySegment nrhs, MemorySegment D, MemorySegment E, MemorySegment DF, MemorySegment EF, MemorySegment B, MemorySegment ldb, MemorySegment X, MemorySegment ldx, MemorySegment rcond, MemorySegment ferr, MemorySegment berr, MemorySegment work, MemorySegment rwork, MemorySegment info, long x17) {
        var mh$ = cptsvx_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cptsvx_", fact, n, nrhs, D, E, DF, EF, B, ldb, X, ldx, rcond, ferr, berr, work, rwork, info, x17);
            }
            mh$.invokeExact(fact, n, nrhs, D, E, DF, EF, B, ldb, X, ldx, rcond, ferr, berr, work, rwork, info, x17);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dptsvx_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("dptsvx_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dptsvx_(const char *fact, const int *n, const int *nrhs, const double *D, const double *E, double *DF, double *EF, const double *B, const int *ldb, double *X, const int *ldx, double *rcond, double *ferr, double *berr, double *work, int *info, size_t)
     * }
     */
    public static FunctionDescriptor dptsvx_$descriptor() {
        return dptsvx_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dptsvx_(const char *fact, const int *n, const int *nrhs, const double *D, const double *E, double *DF, double *EF, const double *B, const int *ldb, double *X, const int *ldx, double *rcond, double *ferr, double *berr, double *work, int *info, size_t)
     * }
     */
    public static MethodHandle dptsvx_$handle() {
        return dptsvx_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dptsvx_(const char *fact, const int *n, const int *nrhs, const double *D, const double *E, double *DF, double *EF, const double *B, const int *ldb, double *X, const int *ldx, double *rcond, double *ferr, double *berr, double *work, int *info, size_t)
     * }
     */
    public static MemorySegment dptsvx_$address() {
        return dptsvx_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dptsvx_(const char *fact, const int *n, const int *nrhs, const double *D, const double *E, double *DF, double *EF, const double *B, const int *ldb, double *X, const int *ldx, double *rcond, double *ferr, double *berr, double *work, int *info, size_t)
     * }
     */
    public static void dptsvx_(MemorySegment fact, MemorySegment n, MemorySegment nrhs, MemorySegment D, MemorySegment E, MemorySegment DF, MemorySegment EF, MemorySegment B, MemorySegment ldb, MemorySegment X, MemorySegment ldx, MemorySegment rcond, MemorySegment ferr, MemorySegment berr, MemorySegment work, MemorySegment info, long x16) {
        var mh$ = dptsvx_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dptsvx_", fact, n, nrhs, D, E, DF, EF, B, ldb, X, ldx, rcond, ferr, berr, work, info, x16);
            }
            mh$.invokeExact(fact, n, nrhs, D, E, DF, EF, B, ldb, X, ldx, rcond, ferr, berr, work, info, x16);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sptsvx_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("sptsvx_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void sptsvx_(const char *fact, const int *n, const int *nrhs, const float *D, const float *E, float *DF, float *EF, const float *B, const int *ldb, float *X, const int *ldx, float *rcond, float *ferr, float *berr, float *work, int *info, size_t)
     * }
     */
    public static FunctionDescriptor sptsvx_$descriptor() {
        return sptsvx_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void sptsvx_(const char *fact, const int *n, const int *nrhs, const float *D, const float *E, float *DF, float *EF, const float *B, const int *ldb, float *X, const int *ldx, float *rcond, float *ferr, float *berr, float *work, int *info, size_t)
     * }
     */
    public static MethodHandle sptsvx_$handle() {
        return sptsvx_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void sptsvx_(const char *fact, const int *n, const int *nrhs, const float *D, const float *E, float *DF, float *EF, const float *B, const int *ldb, float *X, const int *ldx, float *rcond, float *ferr, float *berr, float *work, int *info, size_t)
     * }
     */
    public static MemorySegment sptsvx_$address() {
        return sptsvx_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void sptsvx_(const char *fact, const int *n, const int *nrhs, const float *D, const float *E, float *DF, float *EF, const float *B, const int *ldb, float *X, const int *ldx, float *rcond, float *ferr, float *berr, float *work, int *info, size_t)
     * }
     */
    public static void sptsvx_(MemorySegment fact, MemorySegment n, MemorySegment nrhs, MemorySegment D, MemorySegment E, MemorySegment DF, MemorySegment EF, MemorySegment B, MemorySegment ldb, MemorySegment X, MemorySegment ldx, MemorySegment rcond, MemorySegment ferr, MemorySegment berr, MemorySegment work, MemorySegment info, long x16) {
        var mh$ = sptsvx_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sptsvx_", fact, n, nrhs, D, E, DF, EF, B, ldb, X, ldx, rcond, ferr, berr, work, info, x16);
            }
            mh$.invokeExact(fact, n, nrhs, D, E, DF, EF, B, ldb, X, ldx, rcond, ferr, berr, work, info, x16);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zptsvx_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("zptsvx_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zptsvx_(const char *fact, const int *n, const int *nrhs, const double *D, const _Complex double *E, double *DF, _Complex double *EF, const _Complex double *B, const int *ldb, _Complex double *X, const int *ldx, double *rcond, double *ferr, double *berr, _Complex double *work, double *rwork, int *info, size_t)
     * }
     */
    public static FunctionDescriptor zptsvx_$descriptor() {
        return zptsvx_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zptsvx_(const char *fact, const int *n, const int *nrhs, const double *D, const _Complex double *E, double *DF, _Complex double *EF, const _Complex double *B, const int *ldb, _Complex double *X, const int *ldx, double *rcond, double *ferr, double *berr, _Complex double *work, double *rwork, int *info, size_t)
     * }
     */
    public static MethodHandle zptsvx_$handle() {
        return zptsvx_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zptsvx_(const char *fact, const int *n, const int *nrhs, const double *D, const _Complex double *E, double *DF, _Complex double *EF, const _Complex double *B, const int *ldb, _Complex double *X, const int *ldx, double *rcond, double *ferr, double *berr, _Complex double *work, double *rwork, int *info, size_t)
     * }
     */
    public static MemorySegment zptsvx_$address() {
        return zptsvx_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zptsvx_(const char *fact, const int *n, const int *nrhs, const double *D, const _Complex double *E, double *DF, _Complex double *EF, const _Complex double *B, const int *ldb, _Complex double *X, const int *ldx, double *rcond, double *ferr, double *berr, _Complex double *work, double *rwork, int *info, size_t)
     * }
     */
    public static void zptsvx_(MemorySegment fact, MemorySegment n, MemorySegment nrhs, MemorySegment D, MemorySegment E, MemorySegment DF, MemorySegment EF, MemorySegment B, MemorySegment ldb, MemorySegment X, MemorySegment ldx, MemorySegment rcond, MemorySegment ferr, MemorySegment berr, MemorySegment work, MemorySegment rwork, MemorySegment info, long x17) {
        var mh$ = zptsvx_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zptsvx_", fact, n, nrhs, D, E, DF, EF, B, ldb, X, ldx, rcond, ferr, berr, work, rwork, info, x17);
            }
            mh$.invokeExact(fact, n, nrhs, D, E, DF, EF, B, ldb, X, ldx, rcond, ferr, berr, work, rwork, info, x17);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cpttrf_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cpttrf_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cpttrf_(const int *n, float *D, _Complex float *E, int *info)
     * }
     */
    public static FunctionDescriptor cpttrf_$descriptor() {
        return cpttrf_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cpttrf_(const int *n, float *D, _Complex float *E, int *info)
     * }
     */
    public static MethodHandle cpttrf_$handle() {
        return cpttrf_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cpttrf_(const int *n, float *D, _Complex float *E, int *info)
     * }
     */
    public static MemorySegment cpttrf_$address() {
        return cpttrf_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cpttrf_(const int *n, float *D, _Complex float *E, int *info)
     * }
     */
    public static void cpttrf_(MemorySegment n, MemorySegment D, MemorySegment E, MemorySegment info) {
        var mh$ = cpttrf_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cpttrf_", n, D, E, info);
            }
            mh$.invokeExact(n, D, E, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dpttrf_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("dpttrf_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dpttrf_(const int *n, double *D, double *E, int *info)
     * }
     */
    public static FunctionDescriptor dpttrf_$descriptor() {
        return dpttrf_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dpttrf_(const int *n, double *D, double *E, int *info)
     * }
     */
    public static MethodHandle dpttrf_$handle() {
        return dpttrf_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dpttrf_(const int *n, double *D, double *E, int *info)
     * }
     */
    public static MemorySegment dpttrf_$address() {
        return dpttrf_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dpttrf_(const int *n, double *D, double *E, int *info)
     * }
     */
    public static void dpttrf_(MemorySegment n, MemorySegment D, MemorySegment E, MemorySegment info) {
        var mh$ = dpttrf_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dpttrf_", n, D, E, info);
            }
            mh$.invokeExact(n, D, E, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class spttrf_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("spttrf_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void spttrf_(const int *n, float *D, float *E, int *info)
     * }
     */
    public static FunctionDescriptor spttrf_$descriptor() {
        return spttrf_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void spttrf_(const int *n, float *D, float *E, int *info)
     * }
     */
    public static MethodHandle spttrf_$handle() {
        return spttrf_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void spttrf_(const int *n, float *D, float *E, int *info)
     * }
     */
    public static MemorySegment spttrf_$address() {
        return spttrf_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void spttrf_(const int *n, float *D, float *E, int *info)
     * }
     */
    public static void spttrf_(MemorySegment n, MemorySegment D, MemorySegment E, MemorySegment info) {
        var mh$ = spttrf_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("spttrf_", n, D, E, info);
            }
            mh$.invokeExact(n, D, E, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zpttrf_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("zpttrf_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zpttrf_(const int *n, double *D, _Complex double *E, int *info)
     * }
     */
    public static FunctionDescriptor zpttrf_$descriptor() {
        return zpttrf_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zpttrf_(const int *n, double *D, _Complex double *E, int *info)
     * }
     */
    public static MethodHandle zpttrf_$handle() {
        return zpttrf_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zpttrf_(const int *n, double *D, _Complex double *E, int *info)
     * }
     */
    public static MemorySegment zpttrf_$address() {
        return zpttrf_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zpttrf_(const int *n, double *D, _Complex double *E, int *info)
     * }
     */
    public static void zpttrf_(MemorySegment n, MemorySegment D, MemorySegment E, MemorySegment info) {
        var mh$ = zpttrf_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zpttrf_", n, D, E, info);
            }
            mh$.invokeExact(n, D, E, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cpttrs_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cpttrs_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cpttrs_(const char *uplo, const int *n, const int *nrhs, const float *D, const _Complex float *E, _Complex float *B, const int *ldb, int *info, size_t)
     * }
     */
    public static FunctionDescriptor cpttrs_$descriptor() {
        return cpttrs_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cpttrs_(const char *uplo, const int *n, const int *nrhs, const float *D, const _Complex float *E, _Complex float *B, const int *ldb, int *info, size_t)
     * }
     */
    public static MethodHandle cpttrs_$handle() {
        return cpttrs_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cpttrs_(const char *uplo, const int *n, const int *nrhs, const float *D, const _Complex float *E, _Complex float *B, const int *ldb, int *info, size_t)
     * }
     */
    public static MemorySegment cpttrs_$address() {
        return cpttrs_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cpttrs_(const char *uplo, const int *n, const int *nrhs, const float *D, const _Complex float *E, _Complex float *B, const int *ldb, int *info, size_t)
     * }
     */
    public static void cpttrs_(MemorySegment uplo, MemorySegment n, MemorySegment nrhs, MemorySegment D, MemorySegment E, MemorySegment B, MemorySegment ldb, MemorySegment info, long x8) {
        var mh$ = cpttrs_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cpttrs_", uplo, n, nrhs, D, E, B, ldb, info, x8);
            }
            mh$.invokeExact(uplo, n, nrhs, D, E, B, ldb, info, x8);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dpttrs_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("dpttrs_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dpttrs_(const int *n, const int *nrhs, const double *D, const double *E, double *B, const int *ldb, int *info)
     * }
     */
    public static FunctionDescriptor dpttrs_$descriptor() {
        return dpttrs_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dpttrs_(const int *n, const int *nrhs, const double *D, const double *E, double *B, const int *ldb, int *info)
     * }
     */
    public static MethodHandle dpttrs_$handle() {
        return dpttrs_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dpttrs_(const int *n, const int *nrhs, const double *D, const double *E, double *B, const int *ldb, int *info)
     * }
     */
    public static MemorySegment dpttrs_$address() {
        return dpttrs_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dpttrs_(const int *n, const int *nrhs, const double *D, const double *E, double *B, const int *ldb, int *info)
     * }
     */
    public static void dpttrs_(MemorySegment n, MemorySegment nrhs, MemorySegment D, MemorySegment E, MemorySegment B, MemorySegment ldb, MemorySegment info) {
        var mh$ = dpttrs_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dpttrs_", n, nrhs, D, E, B, ldb, info);
            }
            mh$.invokeExact(n, nrhs, D, E, B, ldb, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class spttrs_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("spttrs_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void spttrs_(const int *n, const int *nrhs, const float *D, const float *E, float *B, const int *ldb, int *info)
     * }
     */
    public static FunctionDescriptor spttrs_$descriptor() {
        return spttrs_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void spttrs_(const int *n, const int *nrhs, const float *D, const float *E, float *B, const int *ldb, int *info)
     * }
     */
    public static MethodHandle spttrs_$handle() {
        return spttrs_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void spttrs_(const int *n, const int *nrhs, const float *D, const float *E, float *B, const int *ldb, int *info)
     * }
     */
    public static MemorySegment spttrs_$address() {
        return spttrs_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void spttrs_(const int *n, const int *nrhs, const float *D, const float *E, float *B, const int *ldb, int *info)
     * }
     */
    public static void spttrs_(MemorySegment n, MemorySegment nrhs, MemorySegment D, MemorySegment E, MemorySegment B, MemorySegment ldb, MemorySegment info) {
        var mh$ = spttrs_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("spttrs_", n, nrhs, D, E, B, ldb, info);
            }
            mh$.invokeExact(n, nrhs, D, E, B, ldb, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zpttrs_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("zpttrs_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zpttrs_(const char *uplo, const int *n, const int *nrhs, const double *D, const _Complex double *E, _Complex double *B, const int *ldb, int *info, size_t)
     * }
     */
    public static FunctionDescriptor zpttrs_$descriptor() {
        return zpttrs_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zpttrs_(const char *uplo, const int *n, const int *nrhs, const double *D, const _Complex double *E, _Complex double *B, const int *ldb, int *info, size_t)
     * }
     */
    public static MethodHandle zpttrs_$handle() {
        return zpttrs_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zpttrs_(const char *uplo, const int *n, const int *nrhs, const double *D, const _Complex double *E, _Complex double *B, const int *ldb, int *info, size_t)
     * }
     */
    public static MemorySegment zpttrs_$address() {
        return zpttrs_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zpttrs_(const char *uplo, const int *n, const int *nrhs, const double *D, const _Complex double *E, _Complex double *B, const int *ldb, int *info, size_t)
     * }
     */
    public static void zpttrs_(MemorySegment uplo, MemorySegment n, MemorySegment nrhs, MemorySegment D, MemorySegment E, MemorySegment B, MemorySegment ldb, MemorySegment info, long x8) {
        var mh$ = zpttrs_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zpttrs_", uplo, n, nrhs, D, E, B, ldb, info, x8);
            }
            mh$.invokeExact(uplo, n, nrhs, D, E, B, ldb, info, x8);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dsbev_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("dsbev_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dsbev_(const char *jobz, const char *uplo, const int *n, const int *kd, double *AB, const int *ldab, double *W, double *Z, const int *ldz, double *work, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor dsbev_$descriptor() {
        return dsbev_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dsbev_(const char *jobz, const char *uplo, const int *n, const int *kd, double *AB, const int *ldab, double *W, double *Z, const int *ldz, double *work, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle dsbev_$handle() {
        return dsbev_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dsbev_(const char *jobz, const char *uplo, const int *n, const int *kd, double *AB, const int *ldab, double *W, double *Z, const int *ldz, double *work, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment dsbev_$address() {
        return dsbev_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dsbev_(const char *jobz, const char *uplo, const int *n, const int *kd, double *AB, const int *ldab, double *W, double *Z, const int *ldz, double *work, int *info, size_t, size_t)
     * }
     */
    public static void dsbev_(MemorySegment jobz, MemorySegment uplo, MemorySegment n, MemorySegment kd, MemorySegment AB, MemorySegment ldab, MemorySegment W, MemorySegment Z, MemorySegment ldz, MemorySegment work, MemorySegment info, long x11, long x12) {
        var mh$ = dsbev_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dsbev_", jobz, uplo, n, kd, AB, ldab, W, Z, ldz, work, info, x11, x12);
            }
            mh$.invokeExact(jobz, uplo, n, kd, AB, ldab, W, Z, ldz, work, info, x11, x12);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ssbev_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("ssbev_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ssbev_(const char *jobz, const char *uplo, const int *n, const int *kd, float *AB, const int *ldab, float *W, float *Z, const int *ldz, float *work, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor ssbev_$descriptor() {
        return ssbev_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ssbev_(const char *jobz, const char *uplo, const int *n, const int *kd, float *AB, const int *ldab, float *W, float *Z, const int *ldz, float *work, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle ssbev_$handle() {
        return ssbev_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ssbev_(const char *jobz, const char *uplo, const int *n, const int *kd, float *AB, const int *ldab, float *W, float *Z, const int *ldz, float *work, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment ssbev_$address() {
        return ssbev_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ssbev_(const char *jobz, const char *uplo, const int *n, const int *kd, float *AB, const int *ldab, float *W, float *Z, const int *ldz, float *work, int *info, size_t, size_t)
     * }
     */
    public static void ssbev_(MemorySegment jobz, MemorySegment uplo, MemorySegment n, MemorySegment kd, MemorySegment AB, MemorySegment ldab, MemorySegment W, MemorySegment Z, MemorySegment ldz, MemorySegment work, MemorySegment info, long x11, long x12) {
        var mh$ = ssbev_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ssbev_", jobz, uplo, n, kd, AB, ldab, W, Z, ldz, work, info, x11, x12);
            }
            mh$.invokeExact(jobz, uplo, n, kd, AB, ldab, W, Z, ldz, work, info, x11, x12);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dsbev_2stage_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("dsbev_2stage_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dsbev_2stage_(const char *jobz, const char *uplo, const int *n, const int *kd, double *AB, const int *ldab, double *W, double *Z, const int *ldz, double *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor dsbev_2stage_$descriptor() {
        return dsbev_2stage_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dsbev_2stage_(const char *jobz, const char *uplo, const int *n, const int *kd, double *AB, const int *ldab, double *W, double *Z, const int *ldz, double *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle dsbev_2stage_$handle() {
        return dsbev_2stage_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dsbev_2stage_(const char *jobz, const char *uplo, const int *n, const int *kd, double *AB, const int *ldab, double *W, double *Z, const int *ldz, double *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment dsbev_2stage_$address() {
        return dsbev_2stage_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dsbev_2stage_(const char *jobz, const char *uplo, const int *n, const int *kd, double *AB, const int *ldab, double *W, double *Z, const int *ldz, double *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static void dsbev_2stage_(MemorySegment jobz, MemorySegment uplo, MemorySegment n, MemorySegment kd, MemorySegment AB, MemorySegment ldab, MemorySegment W, MemorySegment Z, MemorySegment ldz, MemorySegment work, MemorySegment lwork, MemorySegment info, long x12, long x13) {
        var mh$ = dsbev_2stage_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dsbev_2stage_", jobz, uplo, n, kd, AB, ldab, W, Z, ldz, work, lwork, info, x12, x13);
            }
            mh$.invokeExact(jobz, uplo, n, kd, AB, ldab, W, Z, ldz, work, lwork, info, x12, x13);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ssbev_2stage_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("ssbev_2stage_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ssbev_2stage_(const char *jobz, const char *uplo, const int *n, const int *kd, float *AB, const int *ldab, float *W, float *Z, const int *ldz, float *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor ssbev_2stage_$descriptor() {
        return ssbev_2stage_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ssbev_2stage_(const char *jobz, const char *uplo, const int *n, const int *kd, float *AB, const int *ldab, float *W, float *Z, const int *ldz, float *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle ssbev_2stage_$handle() {
        return ssbev_2stage_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ssbev_2stage_(const char *jobz, const char *uplo, const int *n, const int *kd, float *AB, const int *ldab, float *W, float *Z, const int *ldz, float *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment ssbev_2stage_$address() {
        return ssbev_2stage_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ssbev_2stage_(const char *jobz, const char *uplo, const int *n, const int *kd, float *AB, const int *ldab, float *W, float *Z, const int *ldz, float *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static void ssbev_2stage_(MemorySegment jobz, MemorySegment uplo, MemorySegment n, MemorySegment kd, MemorySegment AB, MemorySegment ldab, MemorySegment W, MemorySegment Z, MemorySegment ldz, MemorySegment work, MemorySegment lwork, MemorySegment info, long x12, long x13) {
        var mh$ = ssbev_2stage_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ssbev_2stage_", jobz, uplo, n, kd, AB, ldab, W, Z, ldz, work, lwork, info, x12, x13);
            }
            mh$.invokeExact(jobz, uplo, n, kd, AB, ldab, W, Z, ldz, work, lwork, info, x12, x13);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dsbevd_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("dsbevd_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dsbevd_(const char *jobz, const char *uplo, const int *n, const int *kd, double *AB, const int *ldab, double *W, double *Z, const int *ldz, double *work, const int *lwork, int *iwork, const int *liwork, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor dsbevd_$descriptor() {
        return dsbevd_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dsbevd_(const char *jobz, const char *uplo, const int *n, const int *kd, double *AB, const int *ldab, double *W, double *Z, const int *ldz, double *work, const int *lwork, int *iwork, const int *liwork, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle dsbevd_$handle() {
        return dsbevd_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dsbevd_(const char *jobz, const char *uplo, const int *n, const int *kd, double *AB, const int *ldab, double *W, double *Z, const int *ldz, double *work, const int *lwork, int *iwork, const int *liwork, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment dsbevd_$address() {
        return dsbevd_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dsbevd_(const char *jobz, const char *uplo, const int *n, const int *kd, double *AB, const int *ldab, double *W, double *Z, const int *ldz, double *work, const int *lwork, int *iwork, const int *liwork, int *info, size_t, size_t)
     * }
     */
    public static void dsbevd_(MemorySegment jobz, MemorySegment uplo, MemorySegment n, MemorySegment kd, MemorySegment AB, MemorySegment ldab, MemorySegment W, MemorySegment Z, MemorySegment ldz, MemorySegment work, MemorySegment lwork, MemorySegment iwork, MemorySegment liwork, MemorySegment info, long x14, long x15) {
        var mh$ = dsbevd_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dsbevd_", jobz, uplo, n, kd, AB, ldab, W, Z, ldz, work, lwork, iwork, liwork, info, x14, x15);
            }
            mh$.invokeExact(jobz, uplo, n, kd, AB, ldab, W, Z, ldz, work, lwork, iwork, liwork, info, x14, x15);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ssbevd_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("ssbevd_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ssbevd_(const char *jobz, const char *uplo, const int *n, const int *kd, float *AB, const int *ldab, float *W, float *Z, const int *ldz, float *work, const int *lwork, int *iwork, const int *liwork, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor ssbevd_$descriptor() {
        return ssbevd_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ssbevd_(const char *jobz, const char *uplo, const int *n, const int *kd, float *AB, const int *ldab, float *W, float *Z, const int *ldz, float *work, const int *lwork, int *iwork, const int *liwork, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle ssbevd_$handle() {
        return ssbevd_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ssbevd_(const char *jobz, const char *uplo, const int *n, const int *kd, float *AB, const int *ldab, float *W, float *Z, const int *ldz, float *work, const int *lwork, int *iwork, const int *liwork, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment ssbevd_$address() {
        return ssbevd_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ssbevd_(const char *jobz, const char *uplo, const int *n, const int *kd, float *AB, const int *ldab, float *W, float *Z, const int *ldz, float *work, const int *lwork, int *iwork, const int *liwork, int *info, size_t, size_t)
     * }
     */
    public static void ssbevd_(MemorySegment jobz, MemorySegment uplo, MemorySegment n, MemorySegment kd, MemorySegment AB, MemorySegment ldab, MemorySegment W, MemorySegment Z, MemorySegment ldz, MemorySegment work, MemorySegment lwork, MemorySegment iwork, MemorySegment liwork, MemorySegment info, long x14, long x15) {
        var mh$ = ssbevd_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ssbevd_", jobz, uplo, n, kd, AB, ldab, W, Z, ldz, work, lwork, iwork, liwork, info, x14, x15);
            }
            mh$.invokeExact(jobz, uplo, n, kd, AB, ldab, W, Z, ldz, work, lwork, iwork, liwork, info, x14, x15);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dsbevd_2stage_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("dsbevd_2stage_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dsbevd_2stage_(const char *jobz, const char *uplo, const int *n, const int *kd, double *AB, const int *ldab, double *W, double *Z, const int *ldz, double *work, const int *lwork, int *iwork, const int *liwork, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor dsbevd_2stage_$descriptor() {
        return dsbevd_2stage_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dsbevd_2stage_(const char *jobz, const char *uplo, const int *n, const int *kd, double *AB, const int *ldab, double *W, double *Z, const int *ldz, double *work, const int *lwork, int *iwork, const int *liwork, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle dsbevd_2stage_$handle() {
        return dsbevd_2stage_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dsbevd_2stage_(const char *jobz, const char *uplo, const int *n, const int *kd, double *AB, const int *ldab, double *W, double *Z, const int *ldz, double *work, const int *lwork, int *iwork, const int *liwork, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment dsbevd_2stage_$address() {
        return dsbevd_2stage_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dsbevd_2stage_(const char *jobz, const char *uplo, const int *n, const int *kd, double *AB, const int *ldab, double *W, double *Z, const int *ldz, double *work, const int *lwork, int *iwork, const int *liwork, int *info, size_t, size_t)
     * }
     */
    public static void dsbevd_2stage_(MemorySegment jobz, MemorySegment uplo, MemorySegment n, MemorySegment kd, MemorySegment AB, MemorySegment ldab, MemorySegment W, MemorySegment Z, MemorySegment ldz, MemorySegment work, MemorySegment lwork, MemorySegment iwork, MemorySegment liwork, MemorySegment info, long x14, long x15) {
        var mh$ = dsbevd_2stage_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dsbevd_2stage_", jobz, uplo, n, kd, AB, ldab, W, Z, ldz, work, lwork, iwork, liwork, info, x14, x15);
            }
            mh$.invokeExact(jobz, uplo, n, kd, AB, ldab, W, Z, ldz, work, lwork, iwork, liwork, info, x14, x15);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ssbevd_2stage_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("ssbevd_2stage_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ssbevd_2stage_(const char *jobz, const char *uplo, const int *n, const int *kd, float *AB, const int *ldab, float *W, float *Z, const int *ldz, float *work, const int *lwork, int *iwork, const int *liwork, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor ssbevd_2stage_$descriptor() {
        return ssbevd_2stage_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ssbevd_2stage_(const char *jobz, const char *uplo, const int *n, const int *kd, float *AB, const int *ldab, float *W, float *Z, const int *ldz, float *work, const int *lwork, int *iwork, const int *liwork, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle ssbevd_2stage_$handle() {
        return ssbevd_2stage_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ssbevd_2stage_(const char *jobz, const char *uplo, const int *n, const int *kd, float *AB, const int *ldab, float *W, float *Z, const int *ldz, float *work, const int *lwork, int *iwork, const int *liwork, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment ssbevd_2stage_$address() {
        return ssbevd_2stage_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ssbevd_2stage_(const char *jobz, const char *uplo, const int *n, const int *kd, float *AB, const int *ldab, float *W, float *Z, const int *ldz, float *work, const int *lwork, int *iwork, const int *liwork, int *info, size_t, size_t)
     * }
     */
    public static void ssbevd_2stage_(MemorySegment jobz, MemorySegment uplo, MemorySegment n, MemorySegment kd, MemorySegment AB, MemorySegment ldab, MemorySegment W, MemorySegment Z, MemorySegment ldz, MemorySegment work, MemorySegment lwork, MemorySegment iwork, MemorySegment liwork, MemorySegment info, long x14, long x15) {
        var mh$ = ssbevd_2stage_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ssbevd_2stage_", jobz, uplo, n, kd, AB, ldab, W, Z, ldz, work, lwork, iwork, liwork, info, x14, x15);
            }
            mh$.invokeExact(jobz, uplo, n, kd, AB, ldab, W, Z, ldz, work, lwork, iwork, liwork, info, x14, x15);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dsbevx_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("dsbevx_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dsbevx_(const char *jobz, const char *range, const char *uplo, const int *n, const int *kd, double *AB, const int *ldab, double *Q, const int *ldq, const double *vl, const double *vu, const int *il, const int *iu, const double *abstol, int *m, double *W, double *Z, const int *ldz, double *work, int *iwork, int *IFAIL, int *info, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor dsbevx_$descriptor() {
        return dsbevx_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dsbevx_(const char *jobz, const char *range, const char *uplo, const int *n, const int *kd, double *AB, const int *ldab, double *Q, const int *ldq, const double *vl, const double *vu, const int *il, const int *iu, const double *abstol, int *m, double *W, double *Z, const int *ldz, double *work, int *iwork, int *IFAIL, int *info, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle dsbevx_$handle() {
        return dsbevx_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dsbevx_(const char *jobz, const char *range, const char *uplo, const int *n, const int *kd, double *AB, const int *ldab, double *Q, const int *ldq, const double *vl, const double *vu, const int *il, const int *iu, const double *abstol, int *m, double *W, double *Z, const int *ldz, double *work, int *iwork, int *IFAIL, int *info, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment dsbevx_$address() {
        return dsbevx_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dsbevx_(const char *jobz, const char *range, const char *uplo, const int *n, const int *kd, double *AB, const int *ldab, double *Q, const int *ldq, const double *vl, const double *vu, const int *il, const int *iu, const double *abstol, int *m, double *W, double *Z, const int *ldz, double *work, int *iwork, int *IFAIL, int *info, size_t, size_t, size_t)
     * }
     */
    public static void dsbevx_(MemorySegment jobz, MemorySegment range, MemorySegment uplo, MemorySegment n, MemorySegment kd, MemorySegment AB, MemorySegment ldab, MemorySegment Q, MemorySegment ldq, MemorySegment vl, MemorySegment vu, MemorySegment il, MemorySegment iu, MemorySegment abstol, MemorySegment m, MemorySegment W, MemorySegment Z, MemorySegment ldz, MemorySegment work, MemorySegment iwork, MemorySegment IFAIL, MemorySegment info, long x22, long x23, long x24) {
        var mh$ = dsbevx_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dsbevx_", jobz, range, uplo, n, kd, AB, ldab, Q, ldq, vl, vu, il, iu, abstol, m, W, Z, ldz, work, iwork, IFAIL, info, x22, x23, x24);
            }
            mh$.invokeExact(jobz, range, uplo, n, kd, AB, ldab, Q, ldq, vl, vu, il, iu, abstol, m, W, Z, ldz, work, iwork, IFAIL, info, x22, x23, x24);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ssbevx_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("ssbevx_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ssbevx_(const char *jobz, const char *range, const char *uplo, const int *n, const int *kd, float *AB, const int *ldab, float *Q, const int *ldq, const float *vl, const float *vu, const int *il, const int *iu, const float *abstol, int *m, float *W, float *Z, const int *ldz, float *work, int *iwork, int *IFAIL, int *info, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor ssbevx_$descriptor() {
        return ssbevx_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ssbevx_(const char *jobz, const char *range, const char *uplo, const int *n, const int *kd, float *AB, const int *ldab, float *Q, const int *ldq, const float *vl, const float *vu, const int *il, const int *iu, const float *abstol, int *m, float *W, float *Z, const int *ldz, float *work, int *iwork, int *IFAIL, int *info, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle ssbevx_$handle() {
        return ssbevx_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ssbevx_(const char *jobz, const char *range, const char *uplo, const int *n, const int *kd, float *AB, const int *ldab, float *Q, const int *ldq, const float *vl, const float *vu, const int *il, const int *iu, const float *abstol, int *m, float *W, float *Z, const int *ldz, float *work, int *iwork, int *IFAIL, int *info, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment ssbevx_$address() {
        return ssbevx_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ssbevx_(const char *jobz, const char *range, const char *uplo, const int *n, const int *kd, float *AB, const int *ldab, float *Q, const int *ldq, const float *vl, const float *vu, const int *il, const int *iu, const float *abstol, int *m, float *W, float *Z, const int *ldz, float *work, int *iwork, int *IFAIL, int *info, size_t, size_t, size_t)
     * }
     */
    public static void ssbevx_(MemorySegment jobz, MemorySegment range, MemorySegment uplo, MemorySegment n, MemorySegment kd, MemorySegment AB, MemorySegment ldab, MemorySegment Q, MemorySegment ldq, MemorySegment vl, MemorySegment vu, MemorySegment il, MemorySegment iu, MemorySegment abstol, MemorySegment m, MemorySegment W, MemorySegment Z, MemorySegment ldz, MemorySegment work, MemorySegment iwork, MemorySegment IFAIL, MemorySegment info, long x22, long x23, long x24) {
        var mh$ = ssbevx_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ssbevx_", jobz, range, uplo, n, kd, AB, ldab, Q, ldq, vl, vu, il, iu, abstol, m, W, Z, ldz, work, iwork, IFAIL, info, x22, x23, x24);
            }
            mh$.invokeExact(jobz, range, uplo, n, kd, AB, ldab, Q, ldq, vl, vu, il, iu, abstol, m, W, Z, ldz, work, iwork, IFAIL, info, x22, x23, x24);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dsbevx_2stage_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("dsbevx_2stage_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dsbevx_2stage_(const char *jobz, const char *range, const char *uplo, const int *n, const int *kd, double *AB, const int *ldab, double *Q, const int *ldq, const double *vl, const double *vu, const int *il, const int *iu, const double *abstol, int *m, double *W, double *Z, const int *ldz, double *work, const int *lwork, int *iwork, int *IFAIL, int *info, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor dsbevx_2stage_$descriptor() {
        return dsbevx_2stage_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dsbevx_2stage_(const char *jobz, const char *range, const char *uplo, const int *n, const int *kd, double *AB, const int *ldab, double *Q, const int *ldq, const double *vl, const double *vu, const int *il, const int *iu, const double *abstol, int *m, double *W, double *Z, const int *ldz, double *work, const int *lwork, int *iwork, int *IFAIL, int *info, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle dsbevx_2stage_$handle() {
        return dsbevx_2stage_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dsbevx_2stage_(const char *jobz, const char *range, const char *uplo, const int *n, const int *kd, double *AB, const int *ldab, double *Q, const int *ldq, const double *vl, const double *vu, const int *il, const int *iu, const double *abstol, int *m, double *W, double *Z, const int *ldz, double *work, const int *lwork, int *iwork, int *IFAIL, int *info, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment dsbevx_2stage_$address() {
        return dsbevx_2stage_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dsbevx_2stage_(const char *jobz, const char *range, const char *uplo, const int *n, const int *kd, double *AB, const int *ldab, double *Q, const int *ldq, const double *vl, const double *vu, const int *il, const int *iu, const double *abstol, int *m, double *W, double *Z, const int *ldz, double *work, const int *lwork, int *iwork, int *IFAIL, int *info, size_t, size_t, size_t)
     * }
     */
    public static void dsbevx_2stage_(MemorySegment jobz, MemorySegment range, MemorySegment uplo, MemorySegment n, MemorySegment kd, MemorySegment AB, MemorySegment ldab, MemorySegment Q, MemorySegment ldq, MemorySegment vl, MemorySegment vu, MemorySegment il, MemorySegment iu, MemorySegment abstol, MemorySegment m, MemorySegment W, MemorySegment Z, MemorySegment ldz, MemorySegment work, MemorySegment lwork, MemorySegment iwork, MemorySegment IFAIL, MemorySegment info, long x23, long x24, long x25) {
        var mh$ = dsbevx_2stage_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dsbevx_2stage_", jobz, range, uplo, n, kd, AB, ldab, Q, ldq, vl, vu, il, iu, abstol, m, W, Z, ldz, work, lwork, iwork, IFAIL, info, x23, x24, x25);
            }
            mh$.invokeExact(jobz, range, uplo, n, kd, AB, ldab, Q, ldq, vl, vu, il, iu, abstol, m, W, Z, ldz, work, lwork, iwork, IFAIL, info, x23, x24, x25);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ssbevx_2stage_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("ssbevx_2stage_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ssbevx_2stage_(const char *jobz, const char *range, const char *uplo, const int *n, const int *kd, float *AB, const int *ldab, float *Q, const int *ldq, const float *vl, const float *vu, const int *il, const int *iu, const float *abstol, int *m, float *W, float *Z, const int *ldz, float *work, const int *lwork, int *iwork, int *IFAIL, int *info, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor ssbevx_2stage_$descriptor() {
        return ssbevx_2stage_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ssbevx_2stage_(const char *jobz, const char *range, const char *uplo, const int *n, const int *kd, float *AB, const int *ldab, float *Q, const int *ldq, const float *vl, const float *vu, const int *il, const int *iu, const float *abstol, int *m, float *W, float *Z, const int *ldz, float *work, const int *lwork, int *iwork, int *IFAIL, int *info, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle ssbevx_2stage_$handle() {
        return ssbevx_2stage_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ssbevx_2stage_(const char *jobz, const char *range, const char *uplo, const int *n, const int *kd, float *AB, const int *ldab, float *Q, const int *ldq, const float *vl, const float *vu, const int *il, const int *iu, const float *abstol, int *m, float *W, float *Z, const int *ldz, float *work, const int *lwork, int *iwork, int *IFAIL, int *info, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment ssbevx_2stage_$address() {
        return ssbevx_2stage_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ssbevx_2stage_(const char *jobz, const char *range, const char *uplo, const int *n, const int *kd, float *AB, const int *ldab, float *Q, const int *ldq, const float *vl, const float *vu, const int *il, const int *iu, const float *abstol, int *m, float *W, float *Z, const int *ldz, float *work, const int *lwork, int *iwork, int *IFAIL, int *info, size_t, size_t, size_t)
     * }
     */
    public static void ssbevx_2stage_(MemorySegment jobz, MemorySegment range, MemorySegment uplo, MemorySegment n, MemorySegment kd, MemorySegment AB, MemorySegment ldab, MemorySegment Q, MemorySegment ldq, MemorySegment vl, MemorySegment vu, MemorySegment il, MemorySegment iu, MemorySegment abstol, MemorySegment m, MemorySegment W, MemorySegment Z, MemorySegment ldz, MemorySegment work, MemorySegment lwork, MemorySegment iwork, MemorySegment IFAIL, MemorySegment info, long x23, long x24, long x25) {
        var mh$ = ssbevx_2stage_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ssbevx_2stage_", jobz, range, uplo, n, kd, AB, ldab, Q, ldq, vl, vu, il, iu, abstol, m, W, Z, ldz, work, lwork, iwork, IFAIL, info, x23, x24, x25);
            }
            mh$.invokeExact(jobz, range, uplo, n, kd, AB, ldab, Q, ldq, vl, vu, il, iu, abstol, m, W, Z, ldz, work, lwork, iwork, IFAIL, info, x23, x24, x25);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dsbgst_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("dsbgst_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dsbgst_(const char *vect, const char *uplo, const int *n, const int *ka, const int *kb, double *AB, const int *ldab, const double *BB, const int *ldbb, double *X, const int *ldx, double *work, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor dsbgst_$descriptor() {
        return dsbgst_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dsbgst_(const char *vect, const char *uplo, const int *n, const int *ka, const int *kb, double *AB, const int *ldab, const double *BB, const int *ldbb, double *X, const int *ldx, double *work, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle dsbgst_$handle() {
        return dsbgst_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dsbgst_(const char *vect, const char *uplo, const int *n, const int *ka, const int *kb, double *AB, const int *ldab, const double *BB, const int *ldbb, double *X, const int *ldx, double *work, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment dsbgst_$address() {
        return dsbgst_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dsbgst_(const char *vect, const char *uplo, const int *n, const int *ka, const int *kb, double *AB, const int *ldab, const double *BB, const int *ldbb, double *X, const int *ldx, double *work, int *info, size_t, size_t)
     * }
     */
    public static void dsbgst_(MemorySegment vect, MemorySegment uplo, MemorySegment n, MemorySegment ka, MemorySegment kb, MemorySegment AB, MemorySegment ldab, MemorySegment BB, MemorySegment ldbb, MemorySegment X, MemorySegment ldx, MemorySegment work, MemorySegment info, long x13, long x14) {
        var mh$ = dsbgst_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dsbgst_", vect, uplo, n, ka, kb, AB, ldab, BB, ldbb, X, ldx, work, info, x13, x14);
            }
            mh$.invokeExact(vect, uplo, n, ka, kb, AB, ldab, BB, ldbb, X, ldx, work, info, x13, x14);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ssbgst_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("ssbgst_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ssbgst_(const char *vect, const char *uplo, const int *n, const int *ka, const int *kb, float *AB, const int *ldab, const float *BB, const int *ldbb, float *X, const int *ldx, float *work, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor ssbgst_$descriptor() {
        return ssbgst_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ssbgst_(const char *vect, const char *uplo, const int *n, const int *ka, const int *kb, float *AB, const int *ldab, const float *BB, const int *ldbb, float *X, const int *ldx, float *work, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle ssbgst_$handle() {
        return ssbgst_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ssbgst_(const char *vect, const char *uplo, const int *n, const int *ka, const int *kb, float *AB, const int *ldab, const float *BB, const int *ldbb, float *X, const int *ldx, float *work, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment ssbgst_$address() {
        return ssbgst_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ssbgst_(const char *vect, const char *uplo, const int *n, const int *ka, const int *kb, float *AB, const int *ldab, const float *BB, const int *ldbb, float *X, const int *ldx, float *work, int *info, size_t, size_t)
     * }
     */
    public static void ssbgst_(MemorySegment vect, MemorySegment uplo, MemorySegment n, MemorySegment ka, MemorySegment kb, MemorySegment AB, MemorySegment ldab, MemorySegment BB, MemorySegment ldbb, MemorySegment X, MemorySegment ldx, MemorySegment work, MemorySegment info, long x13, long x14) {
        var mh$ = ssbgst_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ssbgst_", vect, uplo, n, ka, kb, AB, ldab, BB, ldbb, X, ldx, work, info, x13, x14);
            }
            mh$.invokeExact(vect, uplo, n, ka, kb, AB, ldab, BB, ldbb, X, ldx, work, info, x13, x14);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dsbgv_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("dsbgv_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dsbgv_(const char *jobz, const char *uplo, const int *n, const int *ka, const int *kb, double *AB, const int *ldab, double *BB, const int *ldbb, double *W, double *Z, const int *ldz, double *work, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor dsbgv_$descriptor() {
        return dsbgv_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dsbgv_(const char *jobz, const char *uplo, const int *n, const int *ka, const int *kb, double *AB, const int *ldab, double *BB, const int *ldbb, double *W, double *Z, const int *ldz, double *work, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle dsbgv_$handle() {
        return dsbgv_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dsbgv_(const char *jobz, const char *uplo, const int *n, const int *ka, const int *kb, double *AB, const int *ldab, double *BB, const int *ldbb, double *W, double *Z, const int *ldz, double *work, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment dsbgv_$address() {
        return dsbgv_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dsbgv_(const char *jobz, const char *uplo, const int *n, const int *ka, const int *kb, double *AB, const int *ldab, double *BB, const int *ldbb, double *W, double *Z, const int *ldz, double *work, int *info, size_t, size_t)
     * }
     */
    public static void dsbgv_(MemorySegment jobz, MemorySegment uplo, MemorySegment n, MemorySegment ka, MemorySegment kb, MemorySegment AB, MemorySegment ldab, MemorySegment BB, MemorySegment ldbb, MemorySegment W, MemorySegment Z, MemorySegment ldz, MemorySegment work, MemorySegment info, long x14, long x15) {
        var mh$ = dsbgv_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dsbgv_", jobz, uplo, n, ka, kb, AB, ldab, BB, ldbb, W, Z, ldz, work, info, x14, x15);
            }
            mh$.invokeExact(jobz, uplo, n, ka, kb, AB, ldab, BB, ldbb, W, Z, ldz, work, info, x14, x15);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ssbgv_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("ssbgv_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ssbgv_(const char *jobz, const char *uplo, const int *n, const int *ka, const int *kb, float *AB, const int *ldab, float *BB, const int *ldbb, float *W, float *Z, const int *ldz, float *work, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor ssbgv_$descriptor() {
        return ssbgv_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ssbgv_(const char *jobz, const char *uplo, const int *n, const int *ka, const int *kb, float *AB, const int *ldab, float *BB, const int *ldbb, float *W, float *Z, const int *ldz, float *work, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle ssbgv_$handle() {
        return ssbgv_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ssbgv_(const char *jobz, const char *uplo, const int *n, const int *ka, const int *kb, float *AB, const int *ldab, float *BB, const int *ldbb, float *W, float *Z, const int *ldz, float *work, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment ssbgv_$address() {
        return ssbgv_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ssbgv_(const char *jobz, const char *uplo, const int *n, const int *ka, const int *kb, float *AB, const int *ldab, float *BB, const int *ldbb, float *W, float *Z, const int *ldz, float *work, int *info, size_t, size_t)
     * }
     */
    public static void ssbgv_(MemorySegment jobz, MemorySegment uplo, MemorySegment n, MemorySegment ka, MemorySegment kb, MemorySegment AB, MemorySegment ldab, MemorySegment BB, MemorySegment ldbb, MemorySegment W, MemorySegment Z, MemorySegment ldz, MemorySegment work, MemorySegment info, long x14, long x15) {
        var mh$ = ssbgv_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ssbgv_", jobz, uplo, n, ka, kb, AB, ldab, BB, ldbb, W, Z, ldz, work, info, x14, x15);
            }
            mh$.invokeExact(jobz, uplo, n, ka, kb, AB, ldab, BB, ldbb, W, Z, ldz, work, info, x14, x15);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dsbgvd_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("dsbgvd_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dsbgvd_(const char *jobz, const char *uplo, const int *n, const int *ka, const int *kb, double *AB, const int *ldab, double *BB, const int *ldbb, double *W, double *Z, const int *ldz, double *work, const int *lwork, int *iwork, const int *liwork, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor dsbgvd_$descriptor() {
        return dsbgvd_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dsbgvd_(const char *jobz, const char *uplo, const int *n, const int *ka, const int *kb, double *AB, const int *ldab, double *BB, const int *ldbb, double *W, double *Z, const int *ldz, double *work, const int *lwork, int *iwork, const int *liwork, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle dsbgvd_$handle() {
        return dsbgvd_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dsbgvd_(const char *jobz, const char *uplo, const int *n, const int *ka, const int *kb, double *AB, const int *ldab, double *BB, const int *ldbb, double *W, double *Z, const int *ldz, double *work, const int *lwork, int *iwork, const int *liwork, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment dsbgvd_$address() {
        return dsbgvd_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dsbgvd_(const char *jobz, const char *uplo, const int *n, const int *ka, const int *kb, double *AB, const int *ldab, double *BB, const int *ldbb, double *W, double *Z, const int *ldz, double *work, const int *lwork, int *iwork, const int *liwork, int *info, size_t, size_t)
     * }
     */
    public static void dsbgvd_(MemorySegment jobz, MemorySegment uplo, MemorySegment n, MemorySegment ka, MemorySegment kb, MemorySegment AB, MemorySegment ldab, MemorySegment BB, MemorySegment ldbb, MemorySegment W, MemorySegment Z, MemorySegment ldz, MemorySegment work, MemorySegment lwork, MemorySegment iwork, MemorySegment liwork, MemorySegment info, long x17, long x18) {
        var mh$ = dsbgvd_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dsbgvd_", jobz, uplo, n, ka, kb, AB, ldab, BB, ldbb, W, Z, ldz, work, lwork, iwork, liwork, info, x17, x18);
            }
            mh$.invokeExact(jobz, uplo, n, ka, kb, AB, ldab, BB, ldbb, W, Z, ldz, work, lwork, iwork, liwork, info, x17, x18);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ssbgvd_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("ssbgvd_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ssbgvd_(const char *jobz, const char *uplo, const int *n, const int *ka, const int *kb, float *AB, const int *ldab, float *BB, const int *ldbb, float *W, float *Z, const int *ldz, float *work, const int *lwork, int *iwork, const int *liwork, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor ssbgvd_$descriptor() {
        return ssbgvd_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ssbgvd_(const char *jobz, const char *uplo, const int *n, const int *ka, const int *kb, float *AB, const int *ldab, float *BB, const int *ldbb, float *W, float *Z, const int *ldz, float *work, const int *lwork, int *iwork, const int *liwork, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle ssbgvd_$handle() {
        return ssbgvd_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ssbgvd_(const char *jobz, const char *uplo, const int *n, const int *ka, const int *kb, float *AB, const int *ldab, float *BB, const int *ldbb, float *W, float *Z, const int *ldz, float *work, const int *lwork, int *iwork, const int *liwork, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment ssbgvd_$address() {
        return ssbgvd_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ssbgvd_(const char *jobz, const char *uplo, const int *n, const int *ka, const int *kb, float *AB, const int *ldab, float *BB, const int *ldbb, float *W, float *Z, const int *ldz, float *work, const int *lwork, int *iwork, const int *liwork, int *info, size_t, size_t)
     * }
     */
    public static void ssbgvd_(MemorySegment jobz, MemorySegment uplo, MemorySegment n, MemorySegment ka, MemorySegment kb, MemorySegment AB, MemorySegment ldab, MemorySegment BB, MemorySegment ldbb, MemorySegment W, MemorySegment Z, MemorySegment ldz, MemorySegment work, MemorySegment lwork, MemorySegment iwork, MemorySegment liwork, MemorySegment info, long x17, long x18) {
        var mh$ = ssbgvd_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ssbgvd_", jobz, uplo, n, ka, kb, AB, ldab, BB, ldbb, W, Z, ldz, work, lwork, iwork, liwork, info, x17, x18);
            }
            mh$.invokeExact(jobz, uplo, n, ka, kb, AB, ldab, BB, ldbb, W, Z, ldz, work, lwork, iwork, liwork, info, x17, x18);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dsbgvx_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("dsbgvx_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dsbgvx_(const char *jobz, const char *range, const char *uplo, const int *n, const int *ka, const int *kb, double *AB, const int *ldab, double *BB, const int *ldbb, double *Q, const int *ldq, const double *vl, const double *vu, const int *il, const int *iu, const double *abstol, int *m, double *W, double *Z, const int *ldz, double *work, int *iwork, int *IFAIL, int *info, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor dsbgvx_$descriptor() {
        return dsbgvx_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dsbgvx_(const char *jobz, const char *range, const char *uplo, const int *n, const int *ka, const int *kb, double *AB, const int *ldab, double *BB, const int *ldbb, double *Q, const int *ldq, const double *vl, const double *vu, const int *il, const int *iu, const double *abstol, int *m, double *W, double *Z, const int *ldz, double *work, int *iwork, int *IFAIL, int *info, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle dsbgvx_$handle() {
        return dsbgvx_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dsbgvx_(const char *jobz, const char *range, const char *uplo, const int *n, const int *ka, const int *kb, double *AB, const int *ldab, double *BB, const int *ldbb, double *Q, const int *ldq, const double *vl, const double *vu, const int *il, const int *iu, const double *abstol, int *m, double *W, double *Z, const int *ldz, double *work, int *iwork, int *IFAIL, int *info, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment dsbgvx_$address() {
        return dsbgvx_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dsbgvx_(const char *jobz, const char *range, const char *uplo, const int *n, const int *ka, const int *kb, double *AB, const int *ldab, double *BB, const int *ldbb, double *Q, const int *ldq, const double *vl, const double *vu, const int *il, const int *iu, const double *abstol, int *m, double *W, double *Z, const int *ldz, double *work, int *iwork, int *IFAIL, int *info, size_t, size_t, size_t)
     * }
     */
    public static void dsbgvx_(MemorySegment jobz, MemorySegment range, MemorySegment uplo, MemorySegment n, MemorySegment ka, MemorySegment kb, MemorySegment AB, MemorySegment ldab, MemorySegment BB, MemorySegment ldbb, MemorySegment Q, MemorySegment ldq, MemorySegment vl, MemorySegment vu, MemorySegment il, MemorySegment iu, MemorySegment abstol, MemorySegment m, MemorySegment W, MemorySegment Z, MemorySegment ldz, MemorySegment work, MemorySegment iwork, MemorySegment IFAIL, MemorySegment info, long x25, long x26, long x27) {
        var mh$ = dsbgvx_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dsbgvx_", jobz, range, uplo, n, ka, kb, AB, ldab, BB, ldbb, Q, ldq, vl, vu, il, iu, abstol, m, W, Z, ldz, work, iwork, IFAIL, info, x25, x26, x27);
            }
            mh$.invokeExact(jobz, range, uplo, n, ka, kb, AB, ldab, BB, ldbb, Q, ldq, vl, vu, il, iu, abstol, m, W, Z, ldz, work, iwork, IFAIL, info, x25, x26, x27);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ssbgvx_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("ssbgvx_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ssbgvx_(const char *jobz, const char *range, const char *uplo, const int *n, const int *ka, const int *kb, float *AB, const int *ldab, float *BB, const int *ldbb, float *Q, const int *ldq, const float *vl, const float *vu, const int *il, const int *iu, const float *abstol, int *m, float *W, float *Z, const int *ldz, float *work, int *iwork, int *IFAIL, int *info, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor ssbgvx_$descriptor() {
        return ssbgvx_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ssbgvx_(const char *jobz, const char *range, const char *uplo, const int *n, const int *ka, const int *kb, float *AB, const int *ldab, float *BB, const int *ldbb, float *Q, const int *ldq, const float *vl, const float *vu, const int *il, const int *iu, const float *abstol, int *m, float *W, float *Z, const int *ldz, float *work, int *iwork, int *IFAIL, int *info, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle ssbgvx_$handle() {
        return ssbgvx_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ssbgvx_(const char *jobz, const char *range, const char *uplo, const int *n, const int *ka, const int *kb, float *AB, const int *ldab, float *BB, const int *ldbb, float *Q, const int *ldq, const float *vl, const float *vu, const int *il, const int *iu, const float *abstol, int *m, float *W, float *Z, const int *ldz, float *work, int *iwork, int *IFAIL, int *info, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment ssbgvx_$address() {
        return ssbgvx_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ssbgvx_(const char *jobz, const char *range, const char *uplo, const int *n, const int *ka, const int *kb, float *AB, const int *ldab, float *BB, const int *ldbb, float *Q, const int *ldq, const float *vl, const float *vu, const int *il, const int *iu, const float *abstol, int *m, float *W, float *Z, const int *ldz, float *work, int *iwork, int *IFAIL, int *info, size_t, size_t, size_t)
     * }
     */
    public static void ssbgvx_(MemorySegment jobz, MemorySegment range, MemorySegment uplo, MemorySegment n, MemorySegment ka, MemorySegment kb, MemorySegment AB, MemorySegment ldab, MemorySegment BB, MemorySegment ldbb, MemorySegment Q, MemorySegment ldq, MemorySegment vl, MemorySegment vu, MemorySegment il, MemorySegment iu, MemorySegment abstol, MemorySegment m, MemorySegment W, MemorySegment Z, MemorySegment ldz, MemorySegment work, MemorySegment iwork, MemorySegment IFAIL, MemorySegment info, long x25, long x26, long x27) {
        var mh$ = ssbgvx_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ssbgvx_", jobz, range, uplo, n, ka, kb, AB, ldab, BB, ldbb, Q, ldq, vl, vu, il, iu, abstol, m, W, Z, ldz, work, iwork, IFAIL, info, x25, x26, x27);
            }
            mh$.invokeExact(jobz, range, uplo, n, ka, kb, AB, ldab, BB, ldbb, Q, ldq, vl, vu, il, iu, abstol, m, W, Z, ldz, work, iwork, IFAIL, info, x25, x26, x27);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dsbtrd_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("dsbtrd_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dsbtrd_(const char *vect, const char *uplo, const int *n, const int *kd, double *AB, const int *ldab, double *D, double *E, double *Q, const int *ldq, double *work, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor dsbtrd_$descriptor() {
        return dsbtrd_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dsbtrd_(const char *vect, const char *uplo, const int *n, const int *kd, double *AB, const int *ldab, double *D, double *E, double *Q, const int *ldq, double *work, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle dsbtrd_$handle() {
        return dsbtrd_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dsbtrd_(const char *vect, const char *uplo, const int *n, const int *kd, double *AB, const int *ldab, double *D, double *E, double *Q, const int *ldq, double *work, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment dsbtrd_$address() {
        return dsbtrd_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dsbtrd_(const char *vect, const char *uplo, const int *n, const int *kd, double *AB, const int *ldab, double *D, double *E, double *Q, const int *ldq, double *work, int *info, size_t, size_t)
     * }
     */
    public static void dsbtrd_(MemorySegment vect, MemorySegment uplo, MemorySegment n, MemorySegment kd, MemorySegment AB, MemorySegment ldab, MemorySegment D, MemorySegment E, MemorySegment Q, MemorySegment ldq, MemorySegment work, MemorySegment info, long x12, long x13) {
        var mh$ = dsbtrd_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dsbtrd_", vect, uplo, n, kd, AB, ldab, D, E, Q, ldq, work, info, x12, x13);
            }
            mh$.invokeExact(vect, uplo, n, kd, AB, ldab, D, E, Q, ldq, work, info, x12, x13);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ssbtrd_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("ssbtrd_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ssbtrd_(const char *vect, const char *uplo, const int *n, const int *kd, float *AB, const int *ldab, float *D, float *E, float *Q, const int *ldq, float *work, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor ssbtrd_$descriptor() {
        return ssbtrd_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ssbtrd_(const char *vect, const char *uplo, const int *n, const int *kd, float *AB, const int *ldab, float *D, float *E, float *Q, const int *ldq, float *work, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle ssbtrd_$handle() {
        return ssbtrd_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ssbtrd_(const char *vect, const char *uplo, const int *n, const int *kd, float *AB, const int *ldab, float *D, float *E, float *Q, const int *ldq, float *work, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment ssbtrd_$address() {
        return ssbtrd_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ssbtrd_(const char *vect, const char *uplo, const int *n, const int *kd, float *AB, const int *ldab, float *D, float *E, float *Q, const int *ldq, float *work, int *info, size_t, size_t)
     * }
     */
    public static void ssbtrd_(MemorySegment vect, MemorySegment uplo, MemorySegment n, MemorySegment kd, MemorySegment AB, MemorySegment ldab, MemorySegment D, MemorySegment E, MemorySegment Q, MemorySegment ldq, MemorySegment work, MemorySegment info, long x12, long x13) {
        var mh$ = ssbtrd_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ssbtrd_", vect, uplo, n, kd, AB, ldab, D, E, Q, ldq, work, info, x12, x13);
            }
            mh$.invokeExact(vect, uplo, n, kd, AB, ldab, D, E, Q, ldq, work, info, x12, x13);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dsfrk_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("dsfrk_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dsfrk_(const char *transr, const char *uplo, const char *trans, const int *n, const int *k, const double *alpha, const double *A, const int *lda, const double *beta, double *C, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor dsfrk_$descriptor() {
        return dsfrk_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dsfrk_(const char *transr, const char *uplo, const char *trans, const int *n, const int *k, const double *alpha, const double *A, const int *lda, const double *beta, double *C, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle dsfrk_$handle() {
        return dsfrk_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dsfrk_(const char *transr, const char *uplo, const char *trans, const int *n, const int *k, const double *alpha, const double *A, const int *lda, const double *beta, double *C, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment dsfrk_$address() {
        return dsfrk_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dsfrk_(const char *transr, const char *uplo, const char *trans, const int *n, const int *k, const double *alpha, const double *A, const int *lda, const double *beta, double *C, size_t, size_t, size_t)
     * }
     */
    public static void dsfrk_(MemorySegment transr, MemorySegment uplo, MemorySegment trans, MemorySegment n, MemorySegment k, MemorySegment alpha, MemorySegment A, MemorySegment lda, MemorySegment beta, MemorySegment C, long x10, long x11, long x12) {
        var mh$ = dsfrk_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dsfrk_", transr, uplo, trans, n, k, alpha, A, lda, beta, C, x10, x11, x12);
            }
            mh$.invokeExact(transr, uplo, trans, n, k, alpha, A, lda, beta, C, x10, x11, x12);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ssfrk_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("ssfrk_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ssfrk_(const char *transr, const char *uplo, const char *trans, const int *n, const int *k, const float *alpha, const float *A, const int *lda, const float *beta, float *C, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor ssfrk_$descriptor() {
        return ssfrk_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ssfrk_(const char *transr, const char *uplo, const char *trans, const int *n, const int *k, const float *alpha, const float *A, const int *lda, const float *beta, float *C, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle ssfrk_$handle() {
        return ssfrk_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ssfrk_(const char *transr, const char *uplo, const char *trans, const int *n, const int *k, const float *alpha, const float *A, const int *lda, const float *beta, float *C, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment ssfrk_$address() {
        return ssfrk_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ssfrk_(const char *transr, const char *uplo, const char *trans, const int *n, const int *k, const float *alpha, const float *A, const int *lda, const float *beta, float *C, size_t, size_t, size_t)
     * }
     */
    public static void ssfrk_(MemorySegment transr, MemorySegment uplo, MemorySegment trans, MemorySegment n, MemorySegment k, MemorySegment alpha, MemorySegment A, MemorySegment lda, MemorySegment beta, MemorySegment C, long x10, long x11, long x12) {
        var mh$ = ssfrk_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ssfrk_", transr, uplo, trans, n, k, alpha, A, lda, beta, C, x10, x11, x12);
            }
            mh$.invokeExact(transr, uplo, trans, n, k, alpha, A, lda, beta, C, x10, x11, x12);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cspcon_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cspcon_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cspcon_(const char *uplo, const int *n, const _Complex float *AP, const int *ipiv, const float *anorm, float *rcond, _Complex float *work, int *info, size_t)
     * }
     */
    public static FunctionDescriptor cspcon_$descriptor() {
        return cspcon_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cspcon_(const char *uplo, const int *n, const _Complex float *AP, const int *ipiv, const float *anorm, float *rcond, _Complex float *work, int *info, size_t)
     * }
     */
    public static MethodHandle cspcon_$handle() {
        return cspcon_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cspcon_(const char *uplo, const int *n, const _Complex float *AP, const int *ipiv, const float *anorm, float *rcond, _Complex float *work, int *info, size_t)
     * }
     */
    public static MemorySegment cspcon_$address() {
        return cspcon_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cspcon_(const char *uplo, const int *n, const _Complex float *AP, const int *ipiv, const float *anorm, float *rcond, _Complex float *work, int *info, size_t)
     * }
     */
    public static void cspcon_(MemorySegment uplo, MemorySegment n, MemorySegment AP, MemorySegment ipiv, MemorySegment anorm, MemorySegment rcond, MemorySegment work, MemorySegment info, long x8) {
        var mh$ = cspcon_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cspcon_", uplo, n, AP, ipiv, anorm, rcond, work, info, x8);
            }
            mh$.invokeExact(uplo, n, AP, ipiv, anorm, rcond, work, info, x8);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dspcon_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("dspcon_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dspcon_(const char *uplo, const int *n, const double *AP, const int *ipiv, const double *anorm, double *rcond, double *work, int *iwork, int *info, size_t)
     * }
     */
    public static FunctionDescriptor dspcon_$descriptor() {
        return dspcon_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dspcon_(const char *uplo, const int *n, const double *AP, const int *ipiv, const double *anorm, double *rcond, double *work, int *iwork, int *info, size_t)
     * }
     */
    public static MethodHandle dspcon_$handle() {
        return dspcon_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dspcon_(const char *uplo, const int *n, const double *AP, const int *ipiv, const double *anorm, double *rcond, double *work, int *iwork, int *info, size_t)
     * }
     */
    public static MemorySegment dspcon_$address() {
        return dspcon_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dspcon_(const char *uplo, const int *n, const double *AP, const int *ipiv, const double *anorm, double *rcond, double *work, int *iwork, int *info, size_t)
     * }
     */
    public static void dspcon_(MemorySegment uplo, MemorySegment n, MemorySegment AP, MemorySegment ipiv, MemorySegment anorm, MemorySegment rcond, MemorySegment work, MemorySegment iwork, MemorySegment info, long x9) {
        var mh$ = dspcon_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dspcon_", uplo, n, AP, ipiv, anorm, rcond, work, iwork, info, x9);
            }
            mh$.invokeExact(uplo, n, AP, ipiv, anorm, rcond, work, iwork, info, x9);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sspcon_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("sspcon_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void sspcon_(const char *uplo, const int *n, const float *AP, const int *ipiv, const float *anorm, float *rcond, float *work, int *iwork, int *info, size_t)
     * }
     */
    public static FunctionDescriptor sspcon_$descriptor() {
        return sspcon_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void sspcon_(const char *uplo, const int *n, const float *AP, const int *ipiv, const float *anorm, float *rcond, float *work, int *iwork, int *info, size_t)
     * }
     */
    public static MethodHandle sspcon_$handle() {
        return sspcon_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void sspcon_(const char *uplo, const int *n, const float *AP, const int *ipiv, const float *anorm, float *rcond, float *work, int *iwork, int *info, size_t)
     * }
     */
    public static MemorySegment sspcon_$address() {
        return sspcon_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void sspcon_(const char *uplo, const int *n, const float *AP, const int *ipiv, const float *anorm, float *rcond, float *work, int *iwork, int *info, size_t)
     * }
     */
    public static void sspcon_(MemorySegment uplo, MemorySegment n, MemorySegment AP, MemorySegment ipiv, MemorySegment anorm, MemorySegment rcond, MemorySegment work, MemorySegment iwork, MemorySegment info, long x9) {
        var mh$ = sspcon_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sspcon_", uplo, n, AP, ipiv, anorm, rcond, work, iwork, info, x9);
            }
            mh$.invokeExact(uplo, n, AP, ipiv, anorm, rcond, work, iwork, info, x9);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zspcon_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("zspcon_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zspcon_(const char *uplo, const int *n, const _Complex double *AP, const int *ipiv, const double *anorm, double *rcond, _Complex double *work, int *info, size_t)
     * }
     */
    public static FunctionDescriptor zspcon_$descriptor() {
        return zspcon_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zspcon_(const char *uplo, const int *n, const _Complex double *AP, const int *ipiv, const double *anorm, double *rcond, _Complex double *work, int *info, size_t)
     * }
     */
    public static MethodHandle zspcon_$handle() {
        return zspcon_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zspcon_(const char *uplo, const int *n, const _Complex double *AP, const int *ipiv, const double *anorm, double *rcond, _Complex double *work, int *info, size_t)
     * }
     */
    public static MemorySegment zspcon_$address() {
        return zspcon_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zspcon_(const char *uplo, const int *n, const _Complex double *AP, const int *ipiv, const double *anorm, double *rcond, _Complex double *work, int *info, size_t)
     * }
     */
    public static void zspcon_(MemorySegment uplo, MemorySegment n, MemorySegment AP, MemorySegment ipiv, MemorySegment anorm, MemorySegment rcond, MemorySegment work, MemorySegment info, long x8) {
        var mh$ = zspcon_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zspcon_", uplo, n, AP, ipiv, anorm, rcond, work, info, x8);
            }
            mh$.invokeExact(uplo, n, AP, ipiv, anorm, rcond, work, info, x8);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dspev_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("dspev_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dspev_(const char *jobz, const char *uplo, const int *n, double *AP, double *W, double *Z, const int *ldz, double *work, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor dspev_$descriptor() {
        return dspev_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dspev_(const char *jobz, const char *uplo, const int *n, double *AP, double *W, double *Z, const int *ldz, double *work, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle dspev_$handle() {
        return dspev_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dspev_(const char *jobz, const char *uplo, const int *n, double *AP, double *W, double *Z, const int *ldz, double *work, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment dspev_$address() {
        return dspev_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dspev_(const char *jobz, const char *uplo, const int *n, double *AP, double *W, double *Z, const int *ldz, double *work, int *info, size_t, size_t)
     * }
     */
    public static void dspev_(MemorySegment jobz, MemorySegment uplo, MemorySegment n, MemorySegment AP, MemorySegment W, MemorySegment Z, MemorySegment ldz, MemorySegment work, MemorySegment info, long x9, long x10) {
        var mh$ = dspev_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dspev_", jobz, uplo, n, AP, W, Z, ldz, work, info, x9, x10);
            }
            mh$.invokeExact(jobz, uplo, n, AP, W, Z, ldz, work, info, x9, x10);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sspev_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("sspev_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void sspev_(const char *jobz, const char *uplo, const int *n, float *AP, float *W, float *Z, const int *ldz, float *work, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor sspev_$descriptor() {
        return sspev_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void sspev_(const char *jobz, const char *uplo, const int *n, float *AP, float *W, float *Z, const int *ldz, float *work, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle sspev_$handle() {
        return sspev_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void sspev_(const char *jobz, const char *uplo, const int *n, float *AP, float *W, float *Z, const int *ldz, float *work, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment sspev_$address() {
        return sspev_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void sspev_(const char *jobz, const char *uplo, const int *n, float *AP, float *W, float *Z, const int *ldz, float *work, int *info, size_t, size_t)
     * }
     */
    public static void sspev_(MemorySegment jobz, MemorySegment uplo, MemorySegment n, MemorySegment AP, MemorySegment W, MemorySegment Z, MemorySegment ldz, MemorySegment work, MemorySegment info, long x9, long x10) {
        var mh$ = sspev_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sspev_", jobz, uplo, n, AP, W, Z, ldz, work, info, x9, x10);
            }
            mh$.invokeExact(jobz, uplo, n, AP, W, Z, ldz, work, info, x9, x10);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dspevd_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("dspevd_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dspevd_(const char *jobz, const char *uplo, const int *n, double *AP, double *W, double *Z, const int *ldz, double *work, const int *lwork, int *iwork, const int *liwork, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor dspevd_$descriptor() {
        return dspevd_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dspevd_(const char *jobz, const char *uplo, const int *n, double *AP, double *W, double *Z, const int *ldz, double *work, const int *lwork, int *iwork, const int *liwork, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle dspevd_$handle() {
        return dspevd_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dspevd_(const char *jobz, const char *uplo, const int *n, double *AP, double *W, double *Z, const int *ldz, double *work, const int *lwork, int *iwork, const int *liwork, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment dspevd_$address() {
        return dspevd_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dspevd_(const char *jobz, const char *uplo, const int *n, double *AP, double *W, double *Z, const int *ldz, double *work, const int *lwork, int *iwork, const int *liwork, int *info, size_t, size_t)
     * }
     */
    public static void dspevd_(MemorySegment jobz, MemorySegment uplo, MemorySegment n, MemorySegment AP, MemorySegment W, MemorySegment Z, MemorySegment ldz, MemorySegment work, MemorySegment lwork, MemorySegment iwork, MemorySegment liwork, MemorySegment info, long x12, long x13) {
        var mh$ = dspevd_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dspevd_", jobz, uplo, n, AP, W, Z, ldz, work, lwork, iwork, liwork, info, x12, x13);
            }
            mh$.invokeExact(jobz, uplo, n, AP, W, Z, ldz, work, lwork, iwork, liwork, info, x12, x13);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sspevd_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("sspevd_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void sspevd_(const char *jobz, const char *uplo, const int *n, float *AP, float *W, float *Z, const int *ldz, float *work, const int *lwork, int *iwork, const int *liwork, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor sspevd_$descriptor() {
        return sspevd_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void sspevd_(const char *jobz, const char *uplo, const int *n, float *AP, float *W, float *Z, const int *ldz, float *work, const int *lwork, int *iwork, const int *liwork, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle sspevd_$handle() {
        return sspevd_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void sspevd_(const char *jobz, const char *uplo, const int *n, float *AP, float *W, float *Z, const int *ldz, float *work, const int *lwork, int *iwork, const int *liwork, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment sspevd_$address() {
        return sspevd_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void sspevd_(const char *jobz, const char *uplo, const int *n, float *AP, float *W, float *Z, const int *ldz, float *work, const int *lwork, int *iwork, const int *liwork, int *info, size_t, size_t)
     * }
     */
    public static void sspevd_(MemorySegment jobz, MemorySegment uplo, MemorySegment n, MemorySegment AP, MemorySegment W, MemorySegment Z, MemorySegment ldz, MemorySegment work, MemorySegment lwork, MemorySegment iwork, MemorySegment liwork, MemorySegment info, long x12, long x13) {
        var mh$ = sspevd_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sspevd_", jobz, uplo, n, AP, W, Z, ldz, work, lwork, iwork, liwork, info, x12, x13);
            }
            mh$.invokeExact(jobz, uplo, n, AP, W, Z, ldz, work, lwork, iwork, liwork, info, x12, x13);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dspevx_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("dspevx_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dspevx_(const char *jobz, const char *range, const char *uplo, const int *n, double *AP, const double *vl, const double *vu, const int *il, const int *iu, const double *abstol, int *m, double *W, double *Z, const int *ldz, double *work, int *iwork, int *IFAIL, int *info, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor dspevx_$descriptor() {
        return dspevx_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dspevx_(const char *jobz, const char *range, const char *uplo, const int *n, double *AP, const double *vl, const double *vu, const int *il, const int *iu, const double *abstol, int *m, double *W, double *Z, const int *ldz, double *work, int *iwork, int *IFAIL, int *info, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle dspevx_$handle() {
        return dspevx_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dspevx_(const char *jobz, const char *range, const char *uplo, const int *n, double *AP, const double *vl, const double *vu, const int *il, const int *iu, const double *abstol, int *m, double *W, double *Z, const int *ldz, double *work, int *iwork, int *IFAIL, int *info, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment dspevx_$address() {
        return dspevx_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dspevx_(const char *jobz, const char *range, const char *uplo, const int *n, double *AP, const double *vl, const double *vu, const int *il, const int *iu, const double *abstol, int *m, double *W, double *Z, const int *ldz, double *work, int *iwork, int *IFAIL, int *info, size_t, size_t, size_t)
     * }
     */
    public static void dspevx_(MemorySegment jobz, MemorySegment range, MemorySegment uplo, MemorySegment n, MemorySegment AP, MemorySegment vl, MemorySegment vu, MemorySegment il, MemorySegment iu, MemorySegment abstol, MemorySegment m, MemorySegment W, MemorySegment Z, MemorySegment ldz, MemorySegment work, MemorySegment iwork, MemorySegment IFAIL, MemorySegment info, long x18, long x19, long x20) {
        var mh$ = dspevx_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dspevx_", jobz, range, uplo, n, AP, vl, vu, il, iu, abstol, m, W, Z, ldz, work, iwork, IFAIL, info, x18, x19, x20);
            }
            mh$.invokeExact(jobz, range, uplo, n, AP, vl, vu, il, iu, abstol, m, W, Z, ldz, work, iwork, IFAIL, info, x18, x19, x20);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sspevx_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("sspevx_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void sspevx_(const char *jobz, const char *range, const char *uplo, const int *n, float *AP, const float *vl, const float *vu, const int *il, const int *iu, const float *abstol, int *m, float *W, float *Z, const int *ldz, float *work, int *iwork, int *IFAIL, int *info, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor sspevx_$descriptor() {
        return sspevx_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void sspevx_(const char *jobz, const char *range, const char *uplo, const int *n, float *AP, const float *vl, const float *vu, const int *il, const int *iu, const float *abstol, int *m, float *W, float *Z, const int *ldz, float *work, int *iwork, int *IFAIL, int *info, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle sspevx_$handle() {
        return sspevx_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void sspevx_(const char *jobz, const char *range, const char *uplo, const int *n, float *AP, const float *vl, const float *vu, const int *il, const int *iu, const float *abstol, int *m, float *W, float *Z, const int *ldz, float *work, int *iwork, int *IFAIL, int *info, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment sspevx_$address() {
        return sspevx_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void sspevx_(const char *jobz, const char *range, const char *uplo, const int *n, float *AP, const float *vl, const float *vu, const int *il, const int *iu, const float *abstol, int *m, float *W, float *Z, const int *ldz, float *work, int *iwork, int *IFAIL, int *info, size_t, size_t, size_t)
     * }
     */
    public static void sspevx_(MemorySegment jobz, MemorySegment range, MemorySegment uplo, MemorySegment n, MemorySegment AP, MemorySegment vl, MemorySegment vu, MemorySegment il, MemorySegment iu, MemorySegment abstol, MemorySegment m, MemorySegment W, MemorySegment Z, MemorySegment ldz, MemorySegment work, MemorySegment iwork, MemorySegment IFAIL, MemorySegment info, long x18, long x19, long x20) {
        var mh$ = sspevx_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sspevx_", jobz, range, uplo, n, AP, vl, vu, il, iu, abstol, m, W, Z, ldz, work, iwork, IFAIL, info, x18, x19, x20);
            }
            mh$.invokeExact(jobz, range, uplo, n, AP, vl, vu, il, iu, abstol, m, W, Z, ldz, work, iwork, IFAIL, info, x18, x19, x20);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dspgst_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("dspgst_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dspgst_(const int *itype, const char *uplo, const int *n, double *AP, const double *BP, int *info, size_t)
     * }
     */
    public static FunctionDescriptor dspgst_$descriptor() {
        return dspgst_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dspgst_(const int *itype, const char *uplo, const int *n, double *AP, const double *BP, int *info, size_t)
     * }
     */
    public static MethodHandle dspgst_$handle() {
        return dspgst_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dspgst_(const int *itype, const char *uplo, const int *n, double *AP, const double *BP, int *info, size_t)
     * }
     */
    public static MemorySegment dspgst_$address() {
        return dspgst_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dspgst_(const int *itype, const char *uplo, const int *n, double *AP, const double *BP, int *info, size_t)
     * }
     */
    public static void dspgst_(MemorySegment itype, MemorySegment uplo, MemorySegment n, MemorySegment AP, MemorySegment BP, MemorySegment info, long x6) {
        var mh$ = dspgst_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dspgst_", itype, uplo, n, AP, BP, info, x6);
            }
            mh$.invokeExact(itype, uplo, n, AP, BP, info, x6);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sspgst_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("sspgst_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void sspgst_(const int *itype, const char *uplo, const int *n, float *AP, const float *BP, int *info, size_t)
     * }
     */
    public static FunctionDescriptor sspgst_$descriptor() {
        return sspgst_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void sspgst_(const int *itype, const char *uplo, const int *n, float *AP, const float *BP, int *info, size_t)
     * }
     */
    public static MethodHandle sspgst_$handle() {
        return sspgst_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void sspgst_(const int *itype, const char *uplo, const int *n, float *AP, const float *BP, int *info, size_t)
     * }
     */
    public static MemorySegment sspgst_$address() {
        return sspgst_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void sspgst_(const int *itype, const char *uplo, const int *n, float *AP, const float *BP, int *info, size_t)
     * }
     */
    public static void sspgst_(MemorySegment itype, MemorySegment uplo, MemorySegment n, MemorySegment AP, MemorySegment BP, MemorySegment info, long x6) {
        var mh$ = sspgst_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sspgst_", itype, uplo, n, AP, BP, info, x6);
            }
            mh$.invokeExact(itype, uplo, n, AP, BP, info, x6);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dspgv_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("dspgv_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dspgv_(const int *itype, const char *jobz, const char *uplo, const int *n, double *AP, double *BP, double *W, double *Z, const int *ldz, double *work, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor dspgv_$descriptor() {
        return dspgv_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dspgv_(const int *itype, const char *jobz, const char *uplo, const int *n, double *AP, double *BP, double *W, double *Z, const int *ldz, double *work, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle dspgv_$handle() {
        return dspgv_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dspgv_(const int *itype, const char *jobz, const char *uplo, const int *n, double *AP, double *BP, double *W, double *Z, const int *ldz, double *work, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment dspgv_$address() {
        return dspgv_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dspgv_(const int *itype, const char *jobz, const char *uplo, const int *n, double *AP, double *BP, double *W, double *Z, const int *ldz, double *work, int *info, size_t, size_t)
     * }
     */
    public static void dspgv_(MemorySegment itype, MemorySegment jobz, MemorySegment uplo, MemorySegment n, MemorySegment AP, MemorySegment BP, MemorySegment W, MemorySegment Z, MemorySegment ldz, MemorySegment work, MemorySegment info, long x11, long x12) {
        var mh$ = dspgv_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dspgv_", itype, jobz, uplo, n, AP, BP, W, Z, ldz, work, info, x11, x12);
            }
            mh$.invokeExact(itype, jobz, uplo, n, AP, BP, W, Z, ldz, work, info, x11, x12);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sspgv_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("sspgv_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void sspgv_(const int *itype, const char *jobz, const char *uplo, const int *n, float *AP, float *BP, float *W, float *Z, const int *ldz, float *work, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor sspgv_$descriptor() {
        return sspgv_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void sspgv_(const int *itype, const char *jobz, const char *uplo, const int *n, float *AP, float *BP, float *W, float *Z, const int *ldz, float *work, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle sspgv_$handle() {
        return sspgv_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void sspgv_(const int *itype, const char *jobz, const char *uplo, const int *n, float *AP, float *BP, float *W, float *Z, const int *ldz, float *work, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment sspgv_$address() {
        return sspgv_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void sspgv_(const int *itype, const char *jobz, const char *uplo, const int *n, float *AP, float *BP, float *W, float *Z, const int *ldz, float *work, int *info, size_t, size_t)
     * }
     */
    public static void sspgv_(MemorySegment itype, MemorySegment jobz, MemorySegment uplo, MemorySegment n, MemorySegment AP, MemorySegment BP, MemorySegment W, MemorySegment Z, MemorySegment ldz, MemorySegment work, MemorySegment info, long x11, long x12) {
        var mh$ = sspgv_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sspgv_", itype, jobz, uplo, n, AP, BP, W, Z, ldz, work, info, x11, x12);
            }
            mh$.invokeExact(itype, jobz, uplo, n, AP, BP, W, Z, ldz, work, info, x11, x12);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dspgvd_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("dspgvd_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dspgvd_(const int *itype, const char *jobz, const char *uplo, const int *n, double *AP, double *BP, double *W, double *Z, const int *ldz, double *work, const int *lwork, int *iwork, const int *liwork, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor dspgvd_$descriptor() {
        return dspgvd_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dspgvd_(const int *itype, const char *jobz, const char *uplo, const int *n, double *AP, double *BP, double *W, double *Z, const int *ldz, double *work, const int *lwork, int *iwork, const int *liwork, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle dspgvd_$handle() {
        return dspgvd_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dspgvd_(const int *itype, const char *jobz, const char *uplo, const int *n, double *AP, double *BP, double *W, double *Z, const int *ldz, double *work, const int *lwork, int *iwork, const int *liwork, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment dspgvd_$address() {
        return dspgvd_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dspgvd_(const int *itype, const char *jobz, const char *uplo, const int *n, double *AP, double *BP, double *W, double *Z, const int *ldz, double *work, const int *lwork, int *iwork, const int *liwork, int *info, size_t, size_t)
     * }
     */
    public static void dspgvd_(MemorySegment itype, MemorySegment jobz, MemorySegment uplo, MemorySegment n, MemorySegment AP, MemorySegment BP, MemorySegment W, MemorySegment Z, MemorySegment ldz, MemorySegment work, MemorySegment lwork, MemorySegment iwork, MemorySegment liwork, MemorySegment info, long x14, long x15) {
        var mh$ = dspgvd_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dspgvd_", itype, jobz, uplo, n, AP, BP, W, Z, ldz, work, lwork, iwork, liwork, info, x14, x15);
            }
            mh$.invokeExact(itype, jobz, uplo, n, AP, BP, W, Z, ldz, work, lwork, iwork, liwork, info, x14, x15);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sspgvd_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("sspgvd_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void sspgvd_(const int *itype, const char *jobz, const char *uplo, const int *n, float *AP, float *BP, float *W, float *Z, const int *ldz, float *work, const int *lwork, int *iwork, const int *liwork, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor sspgvd_$descriptor() {
        return sspgvd_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void sspgvd_(const int *itype, const char *jobz, const char *uplo, const int *n, float *AP, float *BP, float *W, float *Z, const int *ldz, float *work, const int *lwork, int *iwork, const int *liwork, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle sspgvd_$handle() {
        return sspgvd_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void sspgvd_(const int *itype, const char *jobz, const char *uplo, const int *n, float *AP, float *BP, float *W, float *Z, const int *ldz, float *work, const int *lwork, int *iwork, const int *liwork, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment sspgvd_$address() {
        return sspgvd_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void sspgvd_(const int *itype, const char *jobz, const char *uplo, const int *n, float *AP, float *BP, float *W, float *Z, const int *ldz, float *work, const int *lwork, int *iwork, const int *liwork, int *info, size_t, size_t)
     * }
     */
    public static void sspgvd_(MemorySegment itype, MemorySegment jobz, MemorySegment uplo, MemorySegment n, MemorySegment AP, MemorySegment BP, MemorySegment W, MemorySegment Z, MemorySegment ldz, MemorySegment work, MemorySegment lwork, MemorySegment iwork, MemorySegment liwork, MemorySegment info, long x14, long x15) {
        var mh$ = sspgvd_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sspgvd_", itype, jobz, uplo, n, AP, BP, W, Z, ldz, work, lwork, iwork, liwork, info, x14, x15);
            }
            mh$.invokeExact(itype, jobz, uplo, n, AP, BP, W, Z, ldz, work, lwork, iwork, liwork, info, x14, x15);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dspgvx_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("dspgvx_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dspgvx_(const int *itype, const char *jobz, const char *range, const char *uplo, const int *n, double *AP, double *BP, const double *vl, const double *vu, const int *il, const int *iu, const double *abstol, int *m, double *W, double *Z, const int *ldz, double *work, int *iwork, int *IFAIL, int *info, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor dspgvx_$descriptor() {
        return dspgvx_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dspgvx_(const int *itype, const char *jobz, const char *range, const char *uplo, const int *n, double *AP, double *BP, const double *vl, const double *vu, const int *il, const int *iu, const double *abstol, int *m, double *W, double *Z, const int *ldz, double *work, int *iwork, int *IFAIL, int *info, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle dspgvx_$handle() {
        return dspgvx_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dspgvx_(const int *itype, const char *jobz, const char *range, const char *uplo, const int *n, double *AP, double *BP, const double *vl, const double *vu, const int *il, const int *iu, const double *abstol, int *m, double *W, double *Z, const int *ldz, double *work, int *iwork, int *IFAIL, int *info, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment dspgvx_$address() {
        return dspgvx_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dspgvx_(const int *itype, const char *jobz, const char *range, const char *uplo, const int *n, double *AP, double *BP, const double *vl, const double *vu, const int *il, const int *iu, const double *abstol, int *m, double *W, double *Z, const int *ldz, double *work, int *iwork, int *IFAIL, int *info, size_t, size_t, size_t)
     * }
     */
    public static void dspgvx_(MemorySegment itype, MemorySegment jobz, MemorySegment range, MemorySegment uplo, MemorySegment n, MemorySegment AP, MemorySegment BP, MemorySegment vl, MemorySegment vu, MemorySegment il, MemorySegment iu, MemorySegment abstol, MemorySegment m, MemorySegment W, MemorySegment Z, MemorySegment ldz, MemorySegment work, MemorySegment iwork, MemorySegment IFAIL, MemorySegment info, long x20, long x21, long x22) {
        var mh$ = dspgvx_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dspgvx_", itype, jobz, range, uplo, n, AP, BP, vl, vu, il, iu, abstol, m, W, Z, ldz, work, iwork, IFAIL, info, x20, x21, x22);
            }
            mh$.invokeExact(itype, jobz, range, uplo, n, AP, BP, vl, vu, il, iu, abstol, m, W, Z, ldz, work, iwork, IFAIL, info, x20, x21, x22);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sspgvx_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("sspgvx_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void sspgvx_(const int *itype, const char *jobz, const char *range, const char *uplo, const int *n, float *AP, float *BP, const float *vl, const float *vu, const int *il, const int *iu, const float *abstol, int *m, float *W, float *Z, const int *ldz, float *work, int *iwork, int *IFAIL, int *info, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor sspgvx_$descriptor() {
        return sspgvx_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void sspgvx_(const int *itype, const char *jobz, const char *range, const char *uplo, const int *n, float *AP, float *BP, const float *vl, const float *vu, const int *il, const int *iu, const float *abstol, int *m, float *W, float *Z, const int *ldz, float *work, int *iwork, int *IFAIL, int *info, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle sspgvx_$handle() {
        return sspgvx_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void sspgvx_(const int *itype, const char *jobz, const char *range, const char *uplo, const int *n, float *AP, float *BP, const float *vl, const float *vu, const int *il, const int *iu, const float *abstol, int *m, float *W, float *Z, const int *ldz, float *work, int *iwork, int *IFAIL, int *info, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment sspgvx_$address() {
        return sspgvx_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void sspgvx_(const int *itype, const char *jobz, const char *range, const char *uplo, const int *n, float *AP, float *BP, const float *vl, const float *vu, const int *il, const int *iu, const float *abstol, int *m, float *W, float *Z, const int *ldz, float *work, int *iwork, int *IFAIL, int *info, size_t, size_t, size_t)
     * }
     */
    public static void sspgvx_(MemorySegment itype, MemorySegment jobz, MemorySegment range, MemorySegment uplo, MemorySegment n, MemorySegment AP, MemorySegment BP, MemorySegment vl, MemorySegment vu, MemorySegment il, MemorySegment iu, MemorySegment abstol, MemorySegment m, MemorySegment W, MemorySegment Z, MemorySegment ldz, MemorySegment work, MemorySegment iwork, MemorySegment IFAIL, MemorySegment info, long x20, long x21, long x22) {
        var mh$ = sspgvx_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sspgvx_", itype, jobz, range, uplo, n, AP, BP, vl, vu, il, iu, abstol, m, W, Z, ldz, work, iwork, IFAIL, info, x20, x21, x22);
            }
            mh$.invokeExact(itype, jobz, range, uplo, n, AP, BP, vl, vu, il, iu, abstol, m, W, Z, ldz, work, iwork, IFAIL, info, x20, x21, x22);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class csprfs_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("csprfs_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void csprfs_(const char *uplo, const int *n, const int *nrhs, const _Complex float *AP, const _Complex float *AFP, const int *ipiv, const _Complex float *B, const int *ldb, _Complex float *X, const int *ldx, float *ferr, float *berr, _Complex float *work, float *rwork, int *info, size_t)
     * }
     */
    public static FunctionDescriptor csprfs_$descriptor() {
        return csprfs_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void csprfs_(const char *uplo, const int *n, const int *nrhs, const _Complex float *AP, const _Complex float *AFP, const int *ipiv, const _Complex float *B, const int *ldb, _Complex float *X, const int *ldx, float *ferr, float *berr, _Complex float *work, float *rwork, int *info, size_t)
     * }
     */
    public static MethodHandle csprfs_$handle() {
        return csprfs_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void csprfs_(const char *uplo, const int *n, const int *nrhs, const _Complex float *AP, const _Complex float *AFP, const int *ipiv, const _Complex float *B, const int *ldb, _Complex float *X, const int *ldx, float *ferr, float *berr, _Complex float *work, float *rwork, int *info, size_t)
     * }
     */
    public static MemorySegment csprfs_$address() {
        return csprfs_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void csprfs_(const char *uplo, const int *n, const int *nrhs, const _Complex float *AP, const _Complex float *AFP, const int *ipiv, const _Complex float *B, const int *ldb, _Complex float *X, const int *ldx, float *ferr, float *berr, _Complex float *work, float *rwork, int *info, size_t)
     * }
     */
    public static void csprfs_(MemorySegment uplo, MemorySegment n, MemorySegment nrhs, MemorySegment AP, MemorySegment AFP, MemorySegment ipiv, MemorySegment B, MemorySegment ldb, MemorySegment X, MemorySegment ldx, MemorySegment ferr, MemorySegment berr, MemorySegment work, MemorySegment rwork, MemorySegment info, long x15) {
        var mh$ = csprfs_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("csprfs_", uplo, n, nrhs, AP, AFP, ipiv, B, ldb, X, ldx, ferr, berr, work, rwork, info, x15);
            }
            mh$.invokeExact(uplo, n, nrhs, AP, AFP, ipiv, B, ldb, X, ldx, ferr, berr, work, rwork, info, x15);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dsprfs_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("dsprfs_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dsprfs_(const char *uplo, const int *n, const int *nrhs, const double *AP, const double *AFP, const int *ipiv, const double *B, const int *ldb, double *X, const int *ldx, double *ferr, double *berr, double *work, int *iwork, int *info, size_t)
     * }
     */
    public static FunctionDescriptor dsprfs_$descriptor() {
        return dsprfs_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dsprfs_(const char *uplo, const int *n, const int *nrhs, const double *AP, const double *AFP, const int *ipiv, const double *B, const int *ldb, double *X, const int *ldx, double *ferr, double *berr, double *work, int *iwork, int *info, size_t)
     * }
     */
    public static MethodHandle dsprfs_$handle() {
        return dsprfs_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dsprfs_(const char *uplo, const int *n, const int *nrhs, const double *AP, const double *AFP, const int *ipiv, const double *B, const int *ldb, double *X, const int *ldx, double *ferr, double *berr, double *work, int *iwork, int *info, size_t)
     * }
     */
    public static MemorySegment dsprfs_$address() {
        return dsprfs_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dsprfs_(const char *uplo, const int *n, const int *nrhs, const double *AP, const double *AFP, const int *ipiv, const double *B, const int *ldb, double *X, const int *ldx, double *ferr, double *berr, double *work, int *iwork, int *info, size_t)
     * }
     */
    public static void dsprfs_(MemorySegment uplo, MemorySegment n, MemorySegment nrhs, MemorySegment AP, MemorySegment AFP, MemorySegment ipiv, MemorySegment B, MemorySegment ldb, MemorySegment X, MemorySegment ldx, MemorySegment ferr, MemorySegment berr, MemorySegment work, MemorySegment iwork, MemorySegment info, long x15) {
        var mh$ = dsprfs_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dsprfs_", uplo, n, nrhs, AP, AFP, ipiv, B, ldb, X, ldx, ferr, berr, work, iwork, info, x15);
            }
            mh$.invokeExact(uplo, n, nrhs, AP, AFP, ipiv, B, ldb, X, ldx, ferr, berr, work, iwork, info, x15);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ssprfs_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("ssprfs_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ssprfs_(const char *uplo, const int *n, const int *nrhs, const float *AP, const float *AFP, const int *ipiv, const float *B, const int *ldb, float *X, const int *ldx, float *ferr, float *berr, float *work, int *iwork, int *info, size_t)
     * }
     */
    public static FunctionDescriptor ssprfs_$descriptor() {
        return ssprfs_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ssprfs_(const char *uplo, const int *n, const int *nrhs, const float *AP, const float *AFP, const int *ipiv, const float *B, const int *ldb, float *X, const int *ldx, float *ferr, float *berr, float *work, int *iwork, int *info, size_t)
     * }
     */
    public static MethodHandle ssprfs_$handle() {
        return ssprfs_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ssprfs_(const char *uplo, const int *n, const int *nrhs, const float *AP, const float *AFP, const int *ipiv, const float *B, const int *ldb, float *X, const int *ldx, float *ferr, float *berr, float *work, int *iwork, int *info, size_t)
     * }
     */
    public static MemorySegment ssprfs_$address() {
        return ssprfs_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ssprfs_(const char *uplo, const int *n, const int *nrhs, const float *AP, const float *AFP, const int *ipiv, const float *B, const int *ldb, float *X, const int *ldx, float *ferr, float *berr, float *work, int *iwork, int *info, size_t)
     * }
     */
    public static void ssprfs_(MemorySegment uplo, MemorySegment n, MemorySegment nrhs, MemorySegment AP, MemorySegment AFP, MemorySegment ipiv, MemorySegment B, MemorySegment ldb, MemorySegment X, MemorySegment ldx, MemorySegment ferr, MemorySegment berr, MemorySegment work, MemorySegment iwork, MemorySegment info, long x15) {
        var mh$ = ssprfs_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ssprfs_", uplo, n, nrhs, AP, AFP, ipiv, B, ldb, X, ldx, ferr, berr, work, iwork, info, x15);
            }
            mh$.invokeExact(uplo, n, nrhs, AP, AFP, ipiv, B, ldb, X, ldx, ferr, berr, work, iwork, info, x15);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zsprfs_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("zsprfs_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zsprfs_(const char *uplo, const int *n, const int *nrhs, const _Complex double *AP, const _Complex double *AFP, const int *ipiv, const _Complex double *B, const int *ldb, _Complex double *X, const int *ldx, double *ferr, double *berr, _Complex double *work, double *rwork, int *info, size_t)
     * }
     */
    public static FunctionDescriptor zsprfs_$descriptor() {
        return zsprfs_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zsprfs_(const char *uplo, const int *n, const int *nrhs, const _Complex double *AP, const _Complex double *AFP, const int *ipiv, const _Complex double *B, const int *ldb, _Complex double *X, const int *ldx, double *ferr, double *berr, _Complex double *work, double *rwork, int *info, size_t)
     * }
     */
    public static MethodHandle zsprfs_$handle() {
        return zsprfs_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zsprfs_(const char *uplo, const int *n, const int *nrhs, const _Complex double *AP, const _Complex double *AFP, const int *ipiv, const _Complex double *B, const int *ldb, _Complex double *X, const int *ldx, double *ferr, double *berr, _Complex double *work, double *rwork, int *info, size_t)
     * }
     */
    public static MemorySegment zsprfs_$address() {
        return zsprfs_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zsprfs_(const char *uplo, const int *n, const int *nrhs, const _Complex double *AP, const _Complex double *AFP, const int *ipiv, const _Complex double *B, const int *ldb, _Complex double *X, const int *ldx, double *ferr, double *berr, _Complex double *work, double *rwork, int *info, size_t)
     * }
     */
    public static void zsprfs_(MemorySegment uplo, MemorySegment n, MemorySegment nrhs, MemorySegment AP, MemorySegment AFP, MemorySegment ipiv, MemorySegment B, MemorySegment ldb, MemorySegment X, MemorySegment ldx, MemorySegment ferr, MemorySegment berr, MemorySegment work, MemorySegment rwork, MemorySegment info, long x15) {
        var mh$ = zsprfs_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zsprfs_", uplo, n, nrhs, AP, AFP, ipiv, B, ldb, X, ldx, ferr, berr, work, rwork, info, x15);
            }
            mh$.invokeExact(uplo, n, nrhs, AP, AFP, ipiv, B, ldb, X, ldx, ferr, berr, work, rwork, info, x15);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cspsv_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cspsv_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cspsv_(const char *uplo, const int *n, const int *nrhs, _Complex float *AP, int *ipiv, _Complex float *B, const int *ldb, int *info, size_t)
     * }
     */
    public static FunctionDescriptor cspsv_$descriptor() {
        return cspsv_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cspsv_(const char *uplo, const int *n, const int *nrhs, _Complex float *AP, int *ipiv, _Complex float *B, const int *ldb, int *info, size_t)
     * }
     */
    public static MethodHandle cspsv_$handle() {
        return cspsv_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cspsv_(const char *uplo, const int *n, const int *nrhs, _Complex float *AP, int *ipiv, _Complex float *B, const int *ldb, int *info, size_t)
     * }
     */
    public static MemorySegment cspsv_$address() {
        return cspsv_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cspsv_(const char *uplo, const int *n, const int *nrhs, _Complex float *AP, int *ipiv, _Complex float *B, const int *ldb, int *info, size_t)
     * }
     */
    public static void cspsv_(MemorySegment uplo, MemorySegment n, MemorySegment nrhs, MemorySegment AP, MemorySegment ipiv, MemorySegment B, MemorySegment ldb, MemorySegment info, long x8) {
        var mh$ = cspsv_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cspsv_", uplo, n, nrhs, AP, ipiv, B, ldb, info, x8);
            }
            mh$.invokeExact(uplo, n, nrhs, AP, ipiv, B, ldb, info, x8);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dspsv_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("dspsv_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dspsv_(const char *uplo, const int *n, const int *nrhs, double *AP, int *ipiv, double *B, const int *ldb, int *info, size_t)
     * }
     */
    public static FunctionDescriptor dspsv_$descriptor() {
        return dspsv_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dspsv_(const char *uplo, const int *n, const int *nrhs, double *AP, int *ipiv, double *B, const int *ldb, int *info, size_t)
     * }
     */
    public static MethodHandle dspsv_$handle() {
        return dspsv_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dspsv_(const char *uplo, const int *n, const int *nrhs, double *AP, int *ipiv, double *B, const int *ldb, int *info, size_t)
     * }
     */
    public static MemorySegment dspsv_$address() {
        return dspsv_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dspsv_(const char *uplo, const int *n, const int *nrhs, double *AP, int *ipiv, double *B, const int *ldb, int *info, size_t)
     * }
     */
    public static void dspsv_(MemorySegment uplo, MemorySegment n, MemorySegment nrhs, MemorySegment AP, MemorySegment ipiv, MemorySegment B, MemorySegment ldb, MemorySegment info, long x8) {
        var mh$ = dspsv_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dspsv_", uplo, n, nrhs, AP, ipiv, B, ldb, info, x8);
            }
            mh$.invokeExact(uplo, n, nrhs, AP, ipiv, B, ldb, info, x8);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sspsv_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("sspsv_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void sspsv_(const char *uplo, const int *n, const int *nrhs, float *AP, int *ipiv, float *B, const int *ldb, int *info, size_t)
     * }
     */
    public static FunctionDescriptor sspsv_$descriptor() {
        return sspsv_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void sspsv_(const char *uplo, const int *n, const int *nrhs, float *AP, int *ipiv, float *B, const int *ldb, int *info, size_t)
     * }
     */
    public static MethodHandle sspsv_$handle() {
        return sspsv_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void sspsv_(const char *uplo, const int *n, const int *nrhs, float *AP, int *ipiv, float *B, const int *ldb, int *info, size_t)
     * }
     */
    public static MemorySegment sspsv_$address() {
        return sspsv_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void sspsv_(const char *uplo, const int *n, const int *nrhs, float *AP, int *ipiv, float *B, const int *ldb, int *info, size_t)
     * }
     */
    public static void sspsv_(MemorySegment uplo, MemorySegment n, MemorySegment nrhs, MemorySegment AP, MemorySegment ipiv, MemorySegment B, MemorySegment ldb, MemorySegment info, long x8) {
        var mh$ = sspsv_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sspsv_", uplo, n, nrhs, AP, ipiv, B, ldb, info, x8);
            }
            mh$.invokeExact(uplo, n, nrhs, AP, ipiv, B, ldb, info, x8);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zspsv_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("zspsv_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zspsv_(const char *uplo, const int *n, const int *nrhs, _Complex double *AP, int *ipiv, _Complex double *B, const int *ldb, int *info, size_t)
     * }
     */
    public static FunctionDescriptor zspsv_$descriptor() {
        return zspsv_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zspsv_(const char *uplo, const int *n, const int *nrhs, _Complex double *AP, int *ipiv, _Complex double *B, const int *ldb, int *info, size_t)
     * }
     */
    public static MethodHandle zspsv_$handle() {
        return zspsv_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zspsv_(const char *uplo, const int *n, const int *nrhs, _Complex double *AP, int *ipiv, _Complex double *B, const int *ldb, int *info, size_t)
     * }
     */
    public static MemorySegment zspsv_$address() {
        return zspsv_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zspsv_(const char *uplo, const int *n, const int *nrhs, _Complex double *AP, int *ipiv, _Complex double *B, const int *ldb, int *info, size_t)
     * }
     */
    public static void zspsv_(MemorySegment uplo, MemorySegment n, MemorySegment nrhs, MemorySegment AP, MemorySegment ipiv, MemorySegment B, MemorySegment ldb, MemorySegment info, long x8) {
        var mh$ = zspsv_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zspsv_", uplo, n, nrhs, AP, ipiv, B, ldb, info, x8);
            }
            mh$.invokeExact(uplo, n, nrhs, AP, ipiv, B, ldb, info, x8);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cspsvx_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cspsvx_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cspsvx_(const char *fact, const char *uplo, const int *n, const int *nrhs, const _Complex float *AP, _Complex float *AFP, int *ipiv, const _Complex float *B, const int *ldb, _Complex float *X, const int *ldx, float *rcond, float *ferr, float *berr, _Complex float *work, float *rwork, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor cspsvx_$descriptor() {
        return cspsvx_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cspsvx_(const char *fact, const char *uplo, const int *n, const int *nrhs, const _Complex float *AP, _Complex float *AFP, int *ipiv, const _Complex float *B, const int *ldb, _Complex float *X, const int *ldx, float *rcond, float *ferr, float *berr, _Complex float *work, float *rwork, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle cspsvx_$handle() {
        return cspsvx_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cspsvx_(const char *fact, const char *uplo, const int *n, const int *nrhs, const _Complex float *AP, _Complex float *AFP, int *ipiv, const _Complex float *B, const int *ldb, _Complex float *X, const int *ldx, float *rcond, float *ferr, float *berr, _Complex float *work, float *rwork, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment cspsvx_$address() {
        return cspsvx_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cspsvx_(const char *fact, const char *uplo, const int *n, const int *nrhs, const _Complex float *AP, _Complex float *AFP, int *ipiv, const _Complex float *B, const int *ldb, _Complex float *X, const int *ldx, float *rcond, float *ferr, float *berr, _Complex float *work, float *rwork, int *info, size_t, size_t)
     * }
     */
    public static void cspsvx_(MemorySegment fact, MemorySegment uplo, MemorySegment n, MemorySegment nrhs, MemorySegment AP, MemorySegment AFP, MemorySegment ipiv, MemorySegment B, MemorySegment ldb, MemorySegment X, MemorySegment ldx, MemorySegment rcond, MemorySegment ferr, MemorySegment berr, MemorySegment work, MemorySegment rwork, MemorySegment info, long x17, long x18) {
        var mh$ = cspsvx_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cspsvx_", fact, uplo, n, nrhs, AP, AFP, ipiv, B, ldb, X, ldx, rcond, ferr, berr, work, rwork, info, x17, x18);
            }
            mh$.invokeExact(fact, uplo, n, nrhs, AP, AFP, ipiv, B, ldb, X, ldx, rcond, ferr, berr, work, rwork, info, x17, x18);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dspsvx_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("dspsvx_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dspsvx_(const char *fact, const char *uplo, const int *n, const int *nrhs, const double *AP, double *AFP, int *ipiv, const double *B, const int *ldb, double *X, const int *ldx, double *rcond, double *ferr, double *berr, double *work, int *iwork, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor dspsvx_$descriptor() {
        return dspsvx_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dspsvx_(const char *fact, const char *uplo, const int *n, const int *nrhs, const double *AP, double *AFP, int *ipiv, const double *B, const int *ldb, double *X, const int *ldx, double *rcond, double *ferr, double *berr, double *work, int *iwork, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle dspsvx_$handle() {
        return dspsvx_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dspsvx_(const char *fact, const char *uplo, const int *n, const int *nrhs, const double *AP, double *AFP, int *ipiv, const double *B, const int *ldb, double *X, const int *ldx, double *rcond, double *ferr, double *berr, double *work, int *iwork, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment dspsvx_$address() {
        return dspsvx_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dspsvx_(const char *fact, const char *uplo, const int *n, const int *nrhs, const double *AP, double *AFP, int *ipiv, const double *B, const int *ldb, double *X, const int *ldx, double *rcond, double *ferr, double *berr, double *work, int *iwork, int *info, size_t, size_t)
     * }
     */
    public static void dspsvx_(MemorySegment fact, MemorySegment uplo, MemorySegment n, MemorySegment nrhs, MemorySegment AP, MemorySegment AFP, MemorySegment ipiv, MemorySegment B, MemorySegment ldb, MemorySegment X, MemorySegment ldx, MemorySegment rcond, MemorySegment ferr, MemorySegment berr, MemorySegment work, MemorySegment iwork, MemorySegment info, long x17, long x18) {
        var mh$ = dspsvx_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dspsvx_", fact, uplo, n, nrhs, AP, AFP, ipiv, B, ldb, X, ldx, rcond, ferr, berr, work, iwork, info, x17, x18);
            }
            mh$.invokeExact(fact, uplo, n, nrhs, AP, AFP, ipiv, B, ldb, X, ldx, rcond, ferr, berr, work, iwork, info, x17, x18);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sspsvx_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("sspsvx_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void sspsvx_(const char *fact, const char *uplo, const int *n, const int *nrhs, const float *AP, float *AFP, int *ipiv, const float *B, const int *ldb, float *X, const int *ldx, float *rcond, float *ferr, float *berr, float *work, int *iwork, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor sspsvx_$descriptor() {
        return sspsvx_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void sspsvx_(const char *fact, const char *uplo, const int *n, const int *nrhs, const float *AP, float *AFP, int *ipiv, const float *B, const int *ldb, float *X, const int *ldx, float *rcond, float *ferr, float *berr, float *work, int *iwork, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle sspsvx_$handle() {
        return sspsvx_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void sspsvx_(const char *fact, const char *uplo, const int *n, const int *nrhs, const float *AP, float *AFP, int *ipiv, const float *B, const int *ldb, float *X, const int *ldx, float *rcond, float *ferr, float *berr, float *work, int *iwork, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment sspsvx_$address() {
        return sspsvx_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void sspsvx_(const char *fact, const char *uplo, const int *n, const int *nrhs, const float *AP, float *AFP, int *ipiv, const float *B, const int *ldb, float *X, const int *ldx, float *rcond, float *ferr, float *berr, float *work, int *iwork, int *info, size_t, size_t)
     * }
     */
    public static void sspsvx_(MemorySegment fact, MemorySegment uplo, MemorySegment n, MemorySegment nrhs, MemorySegment AP, MemorySegment AFP, MemorySegment ipiv, MemorySegment B, MemorySegment ldb, MemorySegment X, MemorySegment ldx, MemorySegment rcond, MemorySegment ferr, MemorySegment berr, MemorySegment work, MemorySegment iwork, MemorySegment info, long x17, long x18) {
        var mh$ = sspsvx_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sspsvx_", fact, uplo, n, nrhs, AP, AFP, ipiv, B, ldb, X, ldx, rcond, ferr, berr, work, iwork, info, x17, x18);
            }
            mh$.invokeExact(fact, uplo, n, nrhs, AP, AFP, ipiv, B, ldb, X, ldx, rcond, ferr, berr, work, iwork, info, x17, x18);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zspsvx_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("zspsvx_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zspsvx_(const char *fact, const char *uplo, const int *n, const int *nrhs, const _Complex double *AP, _Complex double *AFP, int *ipiv, const _Complex double *B, const int *ldb, _Complex double *X, const int *ldx, double *rcond, double *ferr, double *berr, _Complex double *work, double *rwork, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor zspsvx_$descriptor() {
        return zspsvx_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zspsvx_(const char *fact, const char *uplo, const int *n, const int *nrhs, const _Complex double *AP, _Complex double *AFP, int *ipiv, const _Complex double *B, const int *ldb, _Complex double *X, const int *ldx, double *rcond, double *ferr, double *berr, _Complex double *work, double *rwork, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle zspsvx_$handle() {
        return zspsvx_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zspsvx_(const char *fact, const char *uplo, const int *n, const int *nrhs, const _Complex double *AP, _Complex double *AFP, int *ipiv, const _Complex double *B, const int *ldb, _Complex double *X, const int *ldx, double *rcond, double *ferr, double *berr, _Complex double *work, double *rwork, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment zspsvx_$address() {
        return zspsvx_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zspsvx_(const char *fact, const char *uplo, const int *n, const int *nrhs, const _Complex double *AP, _Complex double *AFP, int *ipiv, const _Complex double *B, const int *ldb, _Complex double *X, const int *ldx, double *rcond, double *ferr, double *berr, _Complex double *work, double *rwork, int *info, size_t, size_t)
     * }
     */
    public static void zspsvx_(MemorySegment fact, MemorySegment uplo, MemorySegment n, MemorySegment nrhs, MemorySegment AP, MemorySegment AFP, MemorySegment ipiv, MemorySegment B, MemorySegment ldb, MemorySegment X, MemorySegment ldx, MemorySegment rcond, MemorySegment ferr, MemorySegment berr, MemorySegment work, MemorySegment rwork, MemorySegment info, long x17, long x18) {
        var mh$ = zspsvx_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zspsvx_", fact, uplo, n, nrhs, AP, AFP, ipiv, B, ldb, X, ldx, rcond, ferr, berr, work, rwork, info, x17, x18);
            }
            mh$.invokeExact(fact, uplo, n, nrhs, AP, AFP, ipiv, B, ldb, X, ldx, rcond, ferr, berr, work, rwork, info, x17, x18);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dsptrd_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("dsptrd_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dsptrd_(const char *uplo, const int *n, double *AP, double *D, double *E, double *tau, int *info, size_t)
     * }
     */
    public static FunctionDescriptor dsptrd_$descriptor() {
        return dsptrd_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dsptrd_(const char *uplo, const int *n, double *AP, double *D, double *E, double *tau, int *info, size_t)
     * }
     */
    public static MethodHandle dsptrd_$handle() {
        return dsptrd_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dsptrd_(const char *uplo, const int *n, double *AP, double *D, double *E, double *tau, int *info, size_t)
     * }
     */
    public static MemorySegment dsptrd_$address() {
        return dsptrd_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dsptrd_(const char *uplo, const int *n, double *AP, double *D, double *E, double *tau, int *info, size_t)
     * }
     */
    public static void dsptrd_(MemorySegment uplo, MemorySegment n, MemorySegment AP, MemorySegment D, MemorySegment E, MemorySegment tau, MemorySegment info, long x7) {
        var mh$ = dsptrd_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dsptrd_", uplo, n, AP, D, E, tau, info, x7);
            }
            mh$.invokeExact(uplo, n, AP, D, E, tau, info, x7);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ssptrd_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("ssptrd_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ssptrd_(const char *uplo, const int *n, float *AP, float *D, float *E, float *tau, int *info, size_t)
     * }
     */
    public static FunctionDescriptor ssptrd_$descriptor() {
        return ssptrd_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ssptrd_(const char *uplo, const int *n, float *AP, float *D, float *E, float *tau, int *info, size_t)
     * }
     */
    public static MethodHandle ssptrd_$handle() {
        return ssptrd_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ssptrd_(const char *uplo, const int *n, float *AP, float *D, float *E, float *tau, int *info, size_t)
     * }
     */
    public static MemorySegment ssptrd_$address() {
        return ssptrd_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ssptrd_(const char *uplo, const int *n, float *AP, float *D, float *E, float *tau, int *info, size_t)
     * }
     */
    public static void ssptrd_(MemorySegment uplo, MemorySegment n, MemorySegment AP, MemorySegment D, MemorySegment E, MemorySegment tau, MemorySegment info, long x7) {
        var mh$ = ssptrd_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ssptrd_", uplo, n, AP, D, E, tau, info, x7);
            }
            mh$.invokeExact(uplo, n, AP, D, E, tau, info, x7);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class csptrf_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("csptrf_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void csptrf_(const char *uplo, const int *n, _Complex float *AP, int *ipiv, int *info, size_t)
     * }
     */
    public static FunctionDescriptor csptrf_$descriptor() {
        return csptrf_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void csptrf_(const char *uplo, const int *n, _Complex float *AP, int *ipiv, int *info, size_t)
     * }
     */
    public static MethodHandle csptrf_$handle() {
        return csptrf_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void csptrf_(const char *uplo, const int *n, _Complex float *AP, int *ipiv, int *info, size_t)
     * }
     */
    public static MemorySegment csptrf_$address() {
        return csptrf_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void csptrf_(const char *uplo, const int *n, _Complex float *AP, int *ipiv, int *info, size_t)
     * }
     */
    public static void csptrf_(MemorySegment uplo, MemorySegment n, MemorySegment AP, MemorySegment ipiv, MemorySegment info, long x5) {
        var mh$ = csptrf_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("csptrf_", uplo, n, AP, ipiv, info, x5);
            }
            mh$.invokeExact(uplo, n, AP, ipiv, info, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dsptrf_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("dsptrf_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dsptrf_(const char *uplo, const int *n, double *AP, int *ipiv, int *info, size_t)
     * }
     */
    public static FunctionDescriptor dsptrf_$descriptor() {
        return dsptrf_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dsptrf_(const char *uplo, const int *n, double *AP, int *ipiv, int *info, size_t)
     * }
     */
    public static MethodHandle dsptrf_$handle() {
        return dsptrf_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dsptrf_(const char *uplo, const int *n, double *AP, int *ipiv, int *info, size_t)
     * }
     */
    public static MemorySegment dsptrf_$address() {
        return dsptrf_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dsptrf_(const char *uplo, const int *n, double *AP, int *ipiv, int *info, size_t)
     * }
     */
    public static void dsptrf_(MemorySegment uplo, MemorySegment n, MemorySegment AP, MemorySegment ipiv, MemorySegment info, long x5) {
        var mh$ = dsptrf_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dsptrf_", uplo, n, AP, ipiv, info, x5);
            }
            mh$.invokeExact(uplo, n, AP, ipiv, info, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ssptrf_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("ssptrf_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ssptrf_(const char *uplo, const int *n, float *AP, int *ipiv, int *info, size_t)
     * }
     */
    public static FunctionDescriptor ssptrf_$descriptor() {
        return ssptrf_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ssptrf_(const char *uplo, const int *n, float *AP, int *ipiv, int *info, size_t)
     * }
     */
    public static MethodHandle ssptrf_$handle() {
        return ssptrf_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ssptrf_(const char *uplo, const int *n, float *AP, int *ipiv, int *info, size_t)
     * }
     */
    public static MemorySegment ssptrf_$address() {
        return ssptrf_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ssptrf_(const char *uplo, const int *n, float *AP, int *ipiv, int *info, size_t)
     * }
     */
    public static void ssptrf_(MemorySegment uplo, MemorySegment n, MemorySegment AP, MemorySegment ipiv, MemorySegment info, long x5) {
        var mh$ = ssptrf_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ssptrf_", uplo, n, AP, ipiv, info, x5);
            }
            mh$.invokeExact(uplo, n, AP, ipiv, info, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zsptrf_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("zsptrf_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zsptrf_(const char *uplo, const int *n, _Complex double *AP, int *ipiv, int *info, size_t)
     * }
     */
    public static FunctionDescriptor zsptrf_$descriptor() {
        return zsptrf_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zsptrf_(const char *uplo, const int *n, _Complex double *AP, int *ipiv, int *info, size_t)
     * }
     */
    public static MethodHandle zsptrf_$handle() {
        return zsptrf_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zsptrf_(const char *uplo, const int *n, _Complex double *AP, int *ipiv, int *info, size_t)
     * }
     */
    public static MemorySegment zsptrf_$address() {
        return zsptrf_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zsptrf_(const char *uplo, const int *n, _Complex double *AP, int *ipiv, int *info, size_t)
     * }
     */
    public static void zsptrf_(MemorySegment uplo, MemorySegment n, MemorySegment AP, MemorySegment ipiv, MemorySegment info, long x5) {
        var mh$ = zsptrf_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zsptrf_", uplo, n, AP, ipiv, info, x5);
            }
            mh$.invokeExact(uplo, n, AP, ipiv, info, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class csptri_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("csptri_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void csptri_(const char *uplo, const int *n, _Complex float *AP, const int *ipiv, _Complex float *work, int *info, size_t)
     * }
     */
    public static FunctionDescriptor csptri_$descriptor() {
        return csptri_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void csptri_(const char *uplo, const int *n, _Complex float *AP, const int *ipiv, _Complex float *work, int *info, size_t)
     * }
     */
    public static MethodHandle csptri_$handle() {
        return csptri_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void csptri_(const char *uplo, const int *n, _Complex float *AP, const int *ipiv, _Complex float *work, int *info, size_t)
     * }
     */
    public static MemorySegment csptri_$address() {
        return csptri_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void csptri_(const char *uplo, const int *n, _Complex float *AP, const int *ipiv, _Complex float *work, int *info, size_t)
     * }
     */
    public static void csptri_(MemorySegment uplo, MemorySegment n, MemorySegment AP, MemorySegment ipiv, MemorySegment work, MemorySegment info, long x6) {
        var mh$ = csptri_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("csptri_", uplo, n, AP, ipiv, work, info, x6);
            }
            mh$.invokeExact(uplo, n, AP, ipiv, work, info, x6);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dsptri_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("dsptri_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dsptri_(const char *uplo, const int *n, double *AP, const int *ipiv, double *work, int *info, size_t)
     * }
     */
    public static FunctionDescriptor dsptri_$descriptor() {
        return dsptri_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dsptri_(const char *uplo, const int *n, double *AP, const int *ipiv, double *work, int *info, size_t)
     * }
     */
    public static MethodHandle dsptri_$handle() {
        return dsptri_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dsptri_(const char *uplo, const int *n, double *AP, const int *ipiv, double *work, int *info, size_t)
     * }
     */
    public static MemorySegment dsptri_$address() {
        return dsptri_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dsptri_(const char *uplo, const int *n, double *AP, const int *ipiv, double *work, int *info, size_t)
     * }
     */
    public static void dsptri_(MemorySegment uplo, MemorySegment n, MemorySegment AP, MemorySegment ipiv, MemorySegment work, MemorySegment info, long x6) {
        var mh$ = dsptri_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dsptri_", uplo, n, AP, ipiv, work, info, x6);
            }
            mh$.invokeExact(uplo, n, AP, ipiv, work, info, x6);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ssptri_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("ssptri_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ssptri_(const char *uplo, const int *n, float *AP, const int *ipiv, float *work, int *info, size_t)
     * }
     */
    public static FunctionDescriptor ssptri_$descriptor() {
        return ssptri_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ssptri_(const char *uplo, const int *n, float *AP, const int *ipiv, float *work, int *info, size_t)
     * }
     */
    public static MethodHandle ssptri_$handle() {
        return ssptri_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ssptri_(const char *uplo, const int *n, float *AP, const int *ipiv, float *work, int *info, size_t)
     * }
     */
    public static MemorySegment ssptri_$address() {
        return ssptri_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ssptri_(const char *uplo, const int *n, float *AP, const int *ipiv, float *work, int *info, size_t)
     * }
     */
    public static void ssptri_(MemorySegment uplo, MemorySegment n, MemorySegment AP, MemorySegment ipiv, MemorySegment work, MemorySegment info, long x6) {
        var mh$ = ssptri_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ssptri_", uplo, n, AP, ipiv, work, info, x6);
            }
            mh$.invokeExact(uplo, n, AP, ipiv, work, info, x6);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zsptri_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("zsptri_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zsptri_(const char *uplo, const int *n, _Complex double *AP, const int *ipiv, _Complex double *work, int *info, size_t)
     * }
     */
    public static FunctionDescriptor zsptri_$descriptor() {
        return zsptri_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zsptri_(const char *uplo, const int *n, _Complex double *AP, const int *ipiv, _Complex double *work, int *info, size_t)
     * }
     */
    public static MethodHandle zsptri_$handle() {
        return zsptri_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zsptri_(const char *uplo, const int *n, _Complex double *AP, const int *ipiv, _Complex double *work, int *info, size_t)
     * }
     */
    public static MemorySegment zsptri_$address() {
        return zsptri_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zsptri_(const char *uplo, const int *n, _Complex double *AP, const int *ipiv, _Complex double *work, int *info, size_t)
     * }
     */
    public static void zsptri_(MemorySegment uplo, MemorySegment n, MemorySegment AP, MemorySegment ipiv, MemorySegment work, MemorySegment info, long x6) {
        var mh$ = zsptri_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zsptri_", uplo, n, AP, ipiv, work, info, x6);
            }
            mh$.invokeExact(uplo, n, AP, ipiv, work, info, x6);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class csptrs_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("csptrs_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void csptrs_(const char *uplo, const int *n, const int *nrhs, const _Complex float *AP, const int *ipiv, _Complex float *B, const int *ldb, int *info, size_t)
     * }
     */
    public static FunctionDescriptor csptrs_$descriptor() {
        return csptrs_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void csptrs_(const char *uplo, const int *n, const int *nrhs, const _Complex float *AP, const int *ipiv, _Complex float *B, const int *ldb, int *info, size_t)
     * }
     */
    public static MethodHandle csptrs_$handle() {
        return csptrs_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void csptrs_(const char *uplo, const int *n, const int *nrhs, const _Complex float *AP, const int *ipiv, _Complex float *B, const int *ldb, int *info, size_t)
     * }
     */
    public static MemorySegment csptrs_$address() {
        return csptrs_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void csptrs_(const char *uplo, const int *n, const int *nrhs, const _Complex float *AP, const int *ipiv, _Complex float *B, const int *ldb, int *info, size_t)
     * }
     */
    public static void csptrs_(MemorySegment uplo, MemorySegment n, MemorySegment nrhs, MemorySegment AP, MemorySegment ipiv, MemorySegment B, MemorySegment ldb, MemorySegment info, long x8) {
        var mh$ = csptrs_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("csptrs_", uplo, n, nrhs, AP, ipiv, B, ldb, info, x8);
            }
            mh$.invokeExact(uplo, n, nrhs, AP, ipiv, B, ldb, info, x8);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dsptrs_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("dsptrs_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dsptrs_(const char *uplo, const int *n, const int *nrhs, const double *AP, const int *ipiv, double *B, const int *ldb, int *info, size_t)
     * }
     */
    public static FunctionDescriptor dsptrs_$descriptor() {
        return dsptrs_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dsptrs_(const char *uplo, const int *n, const int *nrhs, const double *AP, const int *ipiv, double *B, const int *ldb, int *info, size_t)
     * }
     */
    public static MethodHandle dsptrs_$handle() {
        return dsptrs_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dsptrs_(const char *uplo, const int *n, const int *nrhs, const double *AP, const int *ipiv, double *B, const int *ldb, int *info, size_t)
     * }
     */
    public static MemorySegment dsptrs_$address() {
        return dsptrs_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dsptrs_(const char *uplo, const int *n, const int *nrhs, const double *AP, const int *ipiv, double *B, const int *ldb, int *info, size_t)
     * }
     */
    public static void dsptrs_(MemorySegment uplo, MemorySegment n, MemorySegment nrhs, MemorySegment AP, MemorySegment ipiv, MemorySegment B, MemorySegment ldb, MemorySegment info, long x8) {
        var mh$ = dsptrs_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dsptrs_", uplo, n, nrhs, AP, ipiv, B, ldb, info, x8);
            }
            mh$.invokeExact(uplo, n, nrhs, AP, ipiv, B, ldb, info, x8);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ssptrs_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("ssptrs_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ssptrs_(const char *uplo, const int *n, const int *nrhs, const float *AP, const int *ipiv, float *B, const int *ldb, int *info, size_t)
     * }
     */
    public static FunctionDescriptor ssptrs_$descriptor() {
        return ssptrs_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ssptrs_(const char *uplo, const int *n, const int *nrhs, const float *AP, const int *ipiv, float *B, const int *ldb, int *info, size_t)
     * }
     */
    public static MethodHandle ssptrs_$handle() {
        return ssptrs_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ssptrs_(const char *uplo, const int *n, const int *nrhs, const float *AP, const int *ipiv, float *B, const int *ldb, int *info, size_t)
     * }
     */
    public static MemorySegment ssptrs_$address() {
        return ssptrs_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ssptrs_(const char *uplo, const int *n, const int *nrhs, const float *AP, const int *ipiv, float *B, const int *ldb, int *info, size_t)
     * }
     */
    public static void ssptrs_(MemorySegment uplo, MemorySegment n, MemorySegment nrhs, MemorySegment AP, MemorySegment ipiv, MemorySegment B, MemorySegment ldb, MemorySegment info, long x8) {
        var mh$ = ssptrs_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ssptrs_", uplo, n, nrhs, AP, ipiv, B, ldb, info, x8);
            }
            mh$.invokeExact(uplo, n, nrhs, AP, ipiv, B, ldb, info, x8);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zsptrs_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("zsptrs_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zsptrs_(const char *uplo, const int *n, const int *nrhs, const _Complex double *AP, const int *ipiv, _Complex double *B, const int *ldb, int *info, size_t)
     * }
     */
    public static FunctionDescriptor zsptrs_$descriptor() {
        return zsptrs_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zsptrs_(const char *uplo, const int *n, const int *nrhs, const _Complex double *AP, const int *ipiv, _Complex double *B, const int *ldb, int *info, size_t)
     * }
     */
    public static MethodHandle zsptrs_$handle() {
        return zsptrs_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zsptrs_(const char *uplo, const int *n, const int *nrhs, const _Complex double *AP, const int *ipiv, _Complex double *B, const int *ldb, int *info, size_t)
     * }
     */
    public static MemorySegment zsptrs_$address() {
        return zsptrs_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zsptrs_(const char *uplo, const int *n, const int *nrhs, const _Complex double *AP, const int *ipiv, _Complex double *B, const int *ldb, int *info, size_t)
     * }
     */
    public static void zsptrs_(MemorySegment uplo, MemorySegment n, MemorySegment nrhs, MemorySegment AP, MemorySegment ipiv, MemorySegment B, MemorySegment ldb, MemorySegment info, long x8) {
        var mh$ = zsptrs_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zsptrs_", uplo, n, nrhs, AP, ipiv, B, ldb, info, x8);
            }
            mh$.invokeExact(uplo, n, nrhs, AP, ipiv, B, ldb, info, x8);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dstebz_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("dstebz_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dstebz_(const char *range, const char *order, const int *n, const double *vl, const double *vu, const int *il, const int *iu, const double *abstol, const double *D, const double *E, int *m, int *nsplit, double *W, int *IBLOCK, int *ISPLIT, double *work, int *iwork, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor dstebz_$descriptor() {
        return dstebz_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dstebz_(const char *range, const char *order, const int *n, const double *vl, const double *vu, const int *il, const int *iu, const double *abstol, const double *D, const double *E, int *m, int *nsplit, double *W, int *IBLOCK, int *ISPLIT, double *work, int *iwork, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle dstebz_$handle() {
        return dstebz_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dstebz_(const char *range, const char *order, const int *n, const double *vl, const double *vu, const int *il, const int *iu, const double *abstol, const double *D, const double *E, int *m, int *nsplit, double *W, int *IBLOCK, int *ISPLIT, double *work, int *iwork, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment dstebz_$address() {
        return dstebz_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dstebz_(const char *range, const char *order, const int *n, const double *vl, const double *vu, const int *il, const int *iu, const double *abstol, const double *D, const double *E, int *m, int *nsplit, double *W, int *IBLOCK, int *ISPLIT, double *work, int *iwork, int *info, size_t, size_t)
     * }
     */
    public static void dstebz_(MemorySegment range, MemorySegment order, MemorySegment n, MemorySegment vl, MemorySegment vu, MemorySegment il, MemorySegment iu, MemorySegment abstol, MemorySegment D, MemorySegment E, MemorySegment m, MemorySegment nsplit, MemorySegment W, MemorySegment IBLOCK, MemorySegment ISPLIT, MemorySegment work, MemorySegment iwork, MemorySegment info, long x18, long x19) {
        var mh$ = dstebz_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dstebz_", range, order, n, vl, vu, il, iu, abstol, D, E, m, nsplit, W, IBLOCK, ISPLIT, work, iwork, info, x18, x19);
            }
            mh$.invokeExact(range, order, n, vl, vu, il, iu, abstol, D, E, m, nsplit, W, IBLOCK, ISPLIT, work, iwork, info, x18, x19);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sstebz_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("sstebz_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void sstebz_(const char *range, const char *order, const int *n, const float *vl, const float *vu, const int *il, const int *iu, const float *abstol, const float *D, const float *E, int *m, int *nsplit, float *W, int *IBLOCK, int *ISPLIT, float *work, int *iwork, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor sstebz_$descriptor() {
        return sstebz_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void sstebz_(const char *range, const char *order, const int *n, const float *vl, const float *vu, const int *il, const int *iu, const float *abstol, const float *D, const float *E, int *m, int *nsplit, float *W, int *IBLOCK, int *ISPLIT, float *work, int *iwork, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle sstebz_$handle() {
        return sstebz_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void sstebz_(const char *range, const char *order, const int *n, const float *vl, const float *vu, const int *il, const int *iu, const float *abstol, const float *D, const float *E, int *m, int *nsplit, float *W, int *IBLOCK, int *ISPLIT, float *work, int *iwork, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment sstebz_$address() {
        return sstebz_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void sstebz_(const char *range, const char *order, const int *n, const float *vl, const float *vu, const int *il, const int *iu, const float *abstol, const float *D, const float *E, int *m, int *nsplit, float *W, int *IBLOCK, int *ISPLIT, float *work, int *iwork, int *info, size_t, size_t)
     * }
     */
    public static void sstebz_(MemorySegment range, MemorySegment order, MemorySegment n, MemorySegment vl, MemorySegment vu, MemorySegment il, MemorySegment iu, MemorySegment abstol, MemorySegment D, MemorySegment E, MemorySegment m, MemorySegment nsplit, MemorySegment W, MemorySegment IBLOCK, MemorySegment ISPLIT, MemorySegment work, MemorySegment iwork, MemorySegment info, long x18, long x19) {
        var mh$ = sstebz_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sstebz_", range, order, n, vl, vu, il, iu, abstol, D, E, m, nsplit, W, IBLOCK, ISPLIT, work, iwork, info, x18, x19);
            }
            mh$.invokeExact(range, order, n, vl, vu, il, iu, abstol, D, E, m, nsplit, W, IBLOCK, ISPLIT, work, iwork, info, x18, x19);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cstedc_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cstedc_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cstedc_(const char *compz, const int *n, float *D, float *E, _Complex float *Z, const int *ldz, _Complex float *work, const int *lwork, float *rwork, const int *lrwork, int *iwork, const int *liwork, int *info, size_t)
     * }
     */
    public static FunctionDescriptor cstedc_$descriptor() {
        return cstedc_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cstedc_(const char *compz, const int *n, float *D, float *E, _Complex float *Z, const int *ldz, _Complex float *work, const int *lwork, float *rwork, const int *lrwork, int *iwork, const int *liwork, int *info, size_t)
     * }
     */
    public static MethodHandle cstedc_$handle() {
        return cstedc_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cstedc_(const char *compz, const int *n, float *D, float *E, _Complex float *Z, const int *ldz, _Complex float *work, const int *lwork, float *rwork, const int *lrwork, int *iwork, const int *liwork, int *info, size_t)
     * }
     */
    public static MemorySegment cstedc_$address() {
        return cstedc_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cstedc_(const char *compz, const int *n, float *D, float *E, _Complex float *Z, const int *ldz, _Complex float *work, const int *lwork, float *rwork, const int *lrwork, int *iwork, const int *liwork, int *info, size_t)
     * }
     */
    public static void cstedc_(MemorySegment compz, MemorySegment n, MemorySegment D, MemorySegment E, MemorySegment Z, MemorySegment ldz, MemorySegment work, MemorySegment lwork, MemorySegment rwork, MemorySegment lrwork, MemorySegment iwork, MemorySegment liwork, MemorySegment info, long x13) {
        var mh$ = cstedc_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cstedc_", compz, n, D, E, Z, ldz, work, lwork, rwork, lrwork, iwork, liwork, info, x13);
            }
            mh$.invokeExact(compz, n, D, E, Z, ldz, work, lwork, rwork, lrwork, iwork, liwork, info, x13);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dstedc_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("dstedc_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dstedc_(const char *compz, const int *n, double *D, double *E, double *Z, const int *ldz, double *work, const int *lwork, int *iwork, const int *liwork, int *info, size_t)
     * }
     */
    public static FunctionDescriptor dstedc_$descriptor() {
        return dstedc_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dstedc_(const char *compz, const int *n, double *D, double *E, double *Z, const int *ldz, double *work, const int *lwork, int *iwork, const int *liwork, int *info, size_t)
     * }
     */
    public static MethodHandle dstedc_$handle() {
        return dstedc_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dstedc_(const char *compz, const int *n, double *D, double *E, double *Z, const int *ldz, double *work, const int *lwork, int *iwork, const int *liwork, int *info, size_t)
     * }
     */
    public static MemorySegment dstedc_$address() {
        return dstedc_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dstedc_(const char *compz, const int *n, double *D, double *E, double *Z, const int *ldz, double *work, const int *lwork, int *iwork, const int *liwork, int *info, size_t)
     * }
     */
    public static void dstedc_(MemorySegment compz, MemorySegment n, MemorySegment D, MemorySegment E, MemorySegment Z, MemorySegment ldz, MemorySegment work, MemorySegment lwork, MemorySegment iwork, MemorySegment liwork, MemorySegment info, long x11) {
        var mh$ = dstedc_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dstedc_", compz, n, D, E, Z, ldz, work, lwork, iwork, liwork, info, x11);
            }
            mh$.invokeExact(compz, n, D, E, Z, ldz, work, lwork, iwork, liwork, info, x11);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sstedc_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("sstedc_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void sstedc_(const char *compz, const int *n, float *D, float *E, float *Z, const int *ldz, float *work, const int *lwork, int *iwork, const int *liwork, int *info, size_t)
     * }
     */
    public static FunctionDescriptor sstedc_$descriptor() {
        return sstedc_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void sstedc_(const char *compz, const int *n, float *D, float *E, float *Z, const int *ldz, float *work, const int *lwork, int *iwork, const int *liwork, int *info, size_t)
     * }
     */
    public static MethodHandle sstedc_$handle() {
        return sstedc_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void sstedc_(const char *compz, const int *n, float *D, float *E, float *Z, const int *ldz, float *work, const int *lwork, int *iwork, const int *liwork, int *info, size_t)
     * }
     */
    public static MemorySegment sstedc_$address() {
        return sstedc_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void sstedc_(const char *compz, const int *n, float *D, float *E, float *Z, const int *ldz, float *work, const int *lwork, int *iwork, const int *liwork, int *info, size_t)
     * }
     */
    public static void sstedc_(MemorySegment compz, MemorySegment n, MemorySegment D, MemorySegment E, MemorySegment Z, MemorySegment ldz, MemorySegment work, MemorySegment lwork, MemorySegment iwork, MemorySegment liwork, MemorySegment info, long x11) {
        var mh$ = sstedc_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sstedc_", compz, n, D, E, Z, ldz, work, lwork, iwork, liwork, info, x11);
            }
            mh$.invokeExact(compz, n, D, E, Z, ldz, work, lwork, iwork, liwork, info, x11);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zstedc_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("zstedc_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zstedc_(const char *compz, const int *n, double *D, double *E, _Complex double *Z, const int *ldz, _Complex double *work, const int *lwork, double *rwork, const int *lrwork, int *iwork, const int *liwork, int *info, size_t)
     * }
     */
    public static FunctionDescriptor zstedc_$descriptor() {
        return zstedc_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zstedc_(const char *compz, const int *n, double *D, double *E, _Complex double *Z, const int *ldz, _Complex double *work, const int *lwork, double *rwork, const int *lrwork, int *iwork, const int *liwork, int *info, size_t)
     * }
     */
    public static MethodHandle zstedc_$handle() {
        return zstedc_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zstedc_(const char *compz, const int *n, double *D, double *E, _Complex double *Z, const int *ldz, _Complex double *work, const int *lwork, double *rwork, const int *lrwork, int *iwork, const int *liwork, int *info, size_t)
     * }
     */
    public static MemorySegment zstedc_$address() {
        return zstedc_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zstedc_(const char *compz, const int *n, double *D, double *E, _Complex double *Z, const int *ldz, _Complex double *work, const int *lwork, double *rwork, const int *lrwork, int *iwork, const int *liwork, int *info, size_t)
     * }
     */
    public static void zstedc_(MemorySegment compz, MemorySegment n, MemorySegment D, MemorySegment E, MemorySegment Z, MemorySegment ldz, MemorySegment work, MemorySegment lwork, MemorySegment rwork, MemorySegment lrwork, MemorySegment iwork, MemorySegment liwork, MemorySegment info, long x13) {
        var mh$ = zstedc_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zstedc_", compz, n, D, E, Z, ldz, work, lwork, rwork, lrwork, iwork, liwork, info, x13);
            }
            mh$.invokeExact(compz, n, D, E, Z, ldz, work, lwork, rwork, lrwork, iwork, liwork, info, x13);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cstegr_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cstegr_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cstegr_(const char *jobz, const char *range, const int *n, float *D, float *E, const float *vl, const float *vu, const int *il, const int *iu, const float *abstol, int *m, float *W, _Complex float *Z, const int *ldz, int *ISUPPZ, float *work, const int *lwork, int *iwork, const int *liwork, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor cstegr_$descriptor() {
        return cstegr_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cstegr_(const char *jobz, const char *range, const int *n, float *D, float *E, const float *vl, const float *vu, const int *il, const int *iu, const float *abstol, int *m, float *W, _Complex float *Z, const int *ldz, int *ISUPPZ, float *work, const int *lwork, int *iwork, const int *liwork, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle cstegr_$handle() {
        return cstegr_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cstegr_(const char *jobz, const char *range, const int *n, float *D, float *E, const float *vl, const float *vu, const int *il, const int *iu, const float *abstol, int *m, float *W, _Complex float *Z, const int *ldz, int *ISUPPZ, float *work, const int *lwork, int *iwork, const int *liwork, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment cstegr_$address() {
        return cstegr_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cstegr_(const char *jobz, const char *range, const int *n, float *D, float *E, const float *vl, const float *vu, const int *il, const int *iu, const float *abstol, int *m, float *W, _Complex float *Z, const int *ldz, int *ISUPPZ, float *work, const int *lwork, int *iwork, const int *liwork, int *info, size_t, size_t)
     * }
     */
    public static void cstegr_(MemorySegment jobz, MemorySegment range, MemorySegment n, MemorySegment D, MemorySegment E, MemorySegment vl, MemorySegment vu, MemorySegment il, MemorySegment iu, MemorySegment abstol, MemorySegment m, MemorySegment W, MemorySegment Z, MemorySegment ldz, MemorySegment ISUPPZ, MemorySegment work, MemorySegment lwork, MemorySegment iwork, MemorySegment liwork, MemorySegment info, long x20, long x21) {
        var mh$ = cstegr_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cstegr_", jobz, range, n, D, E, vl, vu, il, iu, abstol, m, W, Z, ldz, ISUPPZ, work, lwork, iwork, liwork, info, x20, x21);
            }
            mh$.invokeExact(jobz, range, n, D, E, vl, vu, il, iu, abstol, m, W, Z, ldz, ISUPPZ, work, lwork, iwork, liwork, info, x20, x21);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dstegr_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("dstegr_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dstegr_(const char *jobz, const char *range, const int *n, double *D, double *E, const double *vl, const double *vu, const int *il, const int *iu, const double *abstol, int *m, double *W, double *Z, const int *ldz, int *ISUPPZ, double *work, const int *lwork, int *iwork, const int *liwork, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor dstegr_$descriptor() {
        return dstegr_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dstegr_(const char *jobz, const char *range, const int *n, double *D, double *E, const double *vl, const double *vu, const int *il, const int *iu, const double *abstol, int *m, double *W, double *Z, const int *ldz, int *ISUPPZ, double *work, const int *lwork, int *iwork, const int *liwork, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle dstegr_$handle() {
        return dstegr_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dstegr_(const char *jobz, const char *range, const int *n, double *D, double *E, const double *vl, const double *vu, const int *il, const int *iu, const double *abstol, int *m, double *W, double *Z, const int *ldz, int *ISUPPZ, double *work, const int *lwork, int *iwork, const int *liwork, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment dstegr_$address() {
        return dstegr_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dstegr_(const char *jobz, const char *range, const int *n, double *D, double *E, const double *vl, const double *vu, const int *il, const int *iu, const double *abstol, int *m, double *W, double *Z, const int *ldz, int *ISUPPZ, double *work, const int *lwork, int *iwork, const int *liwork, int *info, size_t, size_t)
     * }
     */
    public static void dstegr_(MemorySegment jobz, MemorySegment range, MemorySegment n, MemorySegment D, MemorySegment E, MemorySegment vl, MemorySegment vu, MemorySegment il, MemorySegment iu, MemorySegment abstol, MemorySegment m, MemorySegment W, MemorySegment Z, MemorySegment ldz, MemorySegment ISUPPZ, MemorySegment work, MemorySegment lwork, MemorySegment iwork, MemorySegment liwork, MemorySegment info, long x20, long x21) {
        var mh$ = dstegr_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dstegr_", jobz, range, n, D, E, vl, vu, il, iu, abstol, m, W, Z, ldz, ISUPPZ, work, lwork, iwork, liwork, info, x20, x21);
            }
            mh$.invokeExact(jobz, range, n, D, E, vl, vu, il, iu, abstol, m, W, Z, ldz, ISUPPZ, work, lwork, iwork, liwork, info, x20, x21);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sstegr_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("sstegr_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void sstegr_(const char *jobz, const char *range, const int *n, float *D, float *E, const float *vl, const float *vu, const int *il, const int *iu, const float *abstol, int *m, float *W, float *Z, const int *ldz, int *ISUPPZ, float *work, const int *lwork, int *iwork, const int *liwork, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor sstegr_$descriptor() {
        return sstegr_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void sstegr_(const char *jobz, const char *range, const int *n, float *D, float *E, const float *vl, const float *vu, const int *il, const int *iu, const float *abstol, int *m, float *W, float *Z, const int *ldz, int *ISUPPZ, float *work, const int *lwork, int *iwork, const int *liwork, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle sstegr_$handle() {
        return sstegr_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void sstegr_(const char *jobz, const char *range, const int *n, float *D, float *E, const float *vl, const float *vu, const int *il, const int *iu, const float *abstol, int *m, float *W, float *Z, const int *ldz, int *ISUPPZ, float *work, const int *lwork, int *iwork, const int *liwork, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment sstegr_$address() {
        return sstegr_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void sstegr_(const char *jobz, const char *range, const int *n, float *D, float *E, const float *vl, const float *vu, const int *il, const int *iu, const float *abstol, int *m, float *W, float *Z, const int *ldz, int *ISUPPZ, float *work, const int *lwork, int *iwork, const int *liwork, int *info, size_t, size_t)
     * }
     */
    public static void sstegr_(MemorySegment jobz, MemorySegment range, MemorySegment n, MemorySegment D, MemorySegment E, MemorySegment vl, MemorySegment vu, MemorySegment il, MemorySegment iu, MemorySegment abstol, MemorySegment m, MemorySegment W, MemorySegment Z, MemorySegment ldz, MemorySegment ISUPPZ, MemorySegment work, MemorySegment lwork, MemorySegment iwork, MemorySegment liwork, MemorySegment info, long x20, long x21) {
        var mh$ = sstegr_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sstegr_", jobz, range, n, D, E, vl, vu, il, iu, abstol, m, W, Z, ldz, ISUPPZ, work, lwork, iwork, liwork, info, x20, x21);
            }
            mh$.invokeExact(jobz, range, n, D, E, vl, vu, il, iu, abstol, m, W, Z, ldz, ISUPPZ, work, lwork, iwork, liwork, info, x20, x21);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zstegr_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("zstegr_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zstegr_(const char *jobz, const char *range, const int *n, double *D, double *E, const double *vl, const double *vu, const int *il, const int *iu, const double *abstol, int *m, double *W, _Complex double *Z, const int *ldz, int *ISUPPZ, double *work, const int *lwork, int *iwork, const int *liwork, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor zstegr_$descriptor() {
        return zstegr_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zstegr_(const char *jobz, const char *range, const int *n, double *D, double *E, const double *vl, const double *vu, const int *il, const int *iu, const double *abstol, int *m, double *W, _Complex double *Z, const int *ldz, int *ISUPPZ, double *work, const int *lwork, int *iwork, const int *liwork, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle zstegr_$handle() {
        return zstegr_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zstegr_(const char *jobz, const char *range, const int *n, double *D, double *E, const double *vl, const double *vu, const int *il, const int *iu, const double *abstol, int *m, double *W, _Complex double *Z, const int *ldz, int *ISUPPZ, double *work, const int *lwork, int *iwork, const int *liwork, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment zstegr_$address() {
        return zstegr_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zstegr_(const char *jobz, const char *range, const int *n, double *D, double *E, const double *vl, const double *vu, const int *il, const int *iu, const double *abstol, int *m, double *W, _Complex double *Z, const int *ldz, int *ISUPPZ, double *work, const int *lwork, int *iwork, const int *liwork, int *info, size_t, size_t)
     * }
     */
    public static void zstegr_(MemorySegment jobz, MemorySegment range, MemorySegment n, MemorySegment D, MemorySegment E, MemorySegment vl, MemorySegment vu, MemorySegment il, MemorySegment iu, MemorySegment abstol, MemorySegment m, MemorySegment W, MemorySegment Z, MemorySegment ldz, MemorySegment ISUPPZ, MemorySegment work, MemorySegment lwork, MemorySegment iwork, MemorySegment liwork, MemorySegment info, long x20, long x21) {
        var mh$ = zstegr_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zstegr_", jobz, range, n, D, E, vl, vu, il, iu, abstol, m, W, Z, ldz, ISUPPZ, work, lwork, iwork, liwork, info, x20, x21);
            }
            mh$.invokeExact(jobz, range, n, D, E, vl, vu, il, iu, abstol, m, W, Z, ldz, ISUPPZ, work, lwork, iwork, liwork, info, x20, x21);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cstein_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cstein_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cstein_(const int *n, const float *D, const float *E, const int *m, const float *W, const int *IBLOCK, const int *ISPLIT, _Complex float *Z, const int *ldz, float *work, int *iwork, int *IFAIL, int *info)
     * }
     */
    public static FunctionDescriptor cstein_$descriptor() {
        return cstein_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cstein_(const int *n, const float *D, const float *E, const int *m, const float *W, const int *IBLOCK, const int *ISPLIT, _Complex float *Z, const int *ldz, float *work, int *iwork, int *IFAIL, int *info)
     * }
     */
    public static MethodHandle cstein_$handle() {
        return cstein_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cstein_(const int *n, const float *D, const float *E, const int *m, const float *W, const int *IBLOCK, const int *ISPLIT, _Complex float *Z, const int *ldz, float *work, int *iwork, int *IFAIL, int *info)
     * }
     */
    public static MemorySegment cstein_$address() {
        return cstein_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cstein_(const int *n, const float *D, const float *E, const int *m, const float *W, const int *IBLOCK, const int *ISPLIT, _Complex float *Z, const int *ldz, float *work, int *iwork, int *IFAIL, int *info)
     * }
     */
    public static void cstein_(MemorySegment n, MemorySegment D, MemorySegment E, MemorySegment m, MemorySegment W, MemorySegment IBLOCK, MemorySegment ISPLIT, MemorySegment Z, MemorySegment ldz, MemorySegment work, MemorySegment iwork, MemorySegment IFAIL, MemorySegment info) {
        var mh$ = cstein_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cstein_", n, D, E, m, W, IBLOCK, ISPLIT, Z, ldz, work, iwork, IFAIL, info);
            }
            mh$.invokeExact(n, D, E, m, W, IBLOCK, ISPLIT, Z, ldz, work, iwork, IFAIL, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dstein_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("dstein_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dstein_(const int *n, const double *D, const double *E, const int *m, const double *W, const int *IBLOCK, const int *ISPLIT, double *Z, const int *ldz, double *work, int *iwork, int *IFAIL, int *info)
     * }
     */
    public static FunctionDescriptor dstein_$descriptor() {
        return dstein_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dstein_(const int *n, const double *D, const double *E, const int *m, const double *W, const int *IBLOCK, const int *ISPLIT, double *Z, const int *ldz, double *work, int *iwork, int *IFAIL, int *info)
     * }
     */
    public static MethodHandle dstein_$handle() {
        return dstein_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dstein_(const int *n, const double *D, const double *E, const int *m, const double *W, const int *IBLOCK, const int *ISPLIT, double *Z, const int *ldz, double *work, int *iwork, int *IFAIL, int *info)
     * }
     */
    public static MemorySegment dstein_$address() {
        return dstein_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dstein_(const int *n, const double *D, const double *E, const int *m, const double *W, const int *IBLOCK, const int *ISPLIT, double *Z, const int *ldz, double *work, int *iwork, int *IFAIL, int *info)
     * }
     */
    public static void dstein_(MemorySegment n, MemorySegment D, MemorySegment E, MemorySegment m, MemorySegment W, MemorySegment IBLOCK, MemorySegment ISPLIT, MemorySegment Z, MemorySegment ldz, MemorySegment work, MemorySegment iwork, MemorySegment IFAIL, MemorySegment info) {
        var mh$ = dstein_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dstein_", n, D, E, m, W, IBLOCK, ISPLIT, Z, ldz, work, iwork, IFAIL, info);
            }
            mh$.invokeExact(n, D, E, m, W, IBLOCK, ISPLIT, Z, ldz, work, iwork, IFAIL, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sstein_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("sstein_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void sstein_(const int *n, const float *D, const float *E, const int *m, const float *W, const int *IBLOCK, const int *ISPLIT, float *Z, const int *ldz, float *work, int *iwork, int *IFAIL, int *info)
     * }
     */
    public static FunctionDescriptor sstein_$descriptor() {
        return sstein_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void sstein_(const int *n, const float *D, const float *E, const int *m, const float *W, const int *IBLOCK, const int *ISPLIT, float *Z, const int *ldz, float *work, int *iwork, int *IFAIL, int *info)
     * }
     */
    public static MethodHandle sstein_$handle() {
        return sstein_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void sstein_(const int *n, const float *D, const float *E, const int *m, const float *W, const int *IBLOCK, const int *ISPLIT, float *Z, const int *ldz, float *work, int *iwork, int *IFAIL, int *info)
     * }
     */
    public static MemorySegment sstein_$address() {
        return sstein_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void sstein_(const int *n, const float *D, const float *E, const int *m, const float *W, const int *IBLOCK, const int *ISPLIT, float *Z, const int *ldz, float *work, int *iwork, int *IFAIL, int *info)
     * }
     */
    public static void sstein_(MemorySegment n, MemorySegment D, MemorySegment E, MemorySegment m, MemorySegment W, MemorySegment IBLOCK, MemorySegment ISPLIT, MemorySegment Z, MemorySegment ldz, MemorySegment work, MemorySegment iwork, MemorySegment IFAIL, MemorySegment info) {
        var mh$ = sstein_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sstein_", n, D, E, m, W, IBLOCK, ISPLIT, Z, ldz, work, iwork, IFAIL, info);
            }
            mh$.invokeExact(n, D, E, m, W, IBLOCK, ISPLIT, Z, ldz, work, iwork, IFAIL, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zstein_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("zstein_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zstein_(const int *n, const double *D, const double *E, const int *m, const double *W, const int *IBLOCK, const int *ISPLIT, _Complex double *Z, const int *ldz, double *work, int *iwork, int *IFAIL, int *info)
     * }
     */
    public static FunctionDescriptor zstein_$descriptor() {
        return zstein_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zstein_(const int *n, const double *D, const double *E, const int *m, const double *W, const int *IBLOCK, const int *ISPLIT, _Complex double *Z, const int *ldz, double *work, int *iwork, int *IFAIL, int *info)
     * }
     */
    public static MethodHandle zstein_$handle() {
        return zstein_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zstein_(const int *n, const double *D, const double *E, const int *m, const double *W, const int *IBLOCK, const int *ISPLIT, _Complex double *Z, const int *ldz, double *work, int *iwork, int *IFAIL, int *info)
     * }
     */
    public static MemorySegment zstein_$address() {
        return zstein_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zstein_(const int *n, const double *D, const double *E, const int *m, const double *W, const int *IBLOCK, const int *ISPLIT, _Complex double *Z, const int *ldz, double *work, int *iwork, int *IFAIL, int *info)
     * }
     */
    public static void zstein_(MemorySegment n, MemorySegment D, MemorySegment E, MemorySegment m, MemorySegment W, MemorySegment IBLOCK, MemorySegment ISPLIT, MemorySegment Z, MemorySegment ldz, MemorySegment work, MemorySegment iwork, MemorySegment IFAIL, MemorySegment info) {
        var mh$ = zstein_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zstein_", n, D, E, m, W, IBLOCK, ISPLIT, Z, ldz, work, iwork, IFAIL, info);
            }
            mh$.invokeExact(n, D, E, m, W, IBLOCK, ISPLIT, Z, ldz, work, iwork, IFAIL, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cstemr_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cstemr_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cstemr_(const char *jobz, const char *range, const int *n, float *D, float *E, const float *vl, const float *vu, const int *il, const int *iu, int *m, float *W, _Complex float *Z, const int *ldz, const int *nzc, int *ISUPPZ, int *tryrac, float *work, const int *lwork, int *iwork, const int *liwork, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor cstemr_$descriptor() {
        return cstemr_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cstemr_(const char *jobz, const char *range, const int *n, float *D, float *E, const float *vl, const float *vu, const int *il, const int *iu, int *m, float *W, _Complex float *Z, const int *ldz, const int *nzc, int *ISUPPZ, int *tryrac, float *work, const int *lwork, int *iwork, const int *liwork, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle cstemr_$handle() {
        return cstemr_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cstemr_(const char *jobz, const char *range, const int *n, float *D, float *E, const float *vl, const float *vu, const int *il, const int *iu, int *m, float *W, _Complex float *Z, const int *ldz, const int *nzc, int *ISUPPZ, int *tryrac, float *work, const int *lwork, int *iwork, const int *liwork, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment cstemr_$address() {
        return cstemr_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cstemr_(const char *jobz, const char *range, const int *n, float *D, float *E, const float *vl, const float *vu, const int *il, const int *iu, int *m, float *W, _Complex float *Z, const int *ldz, const int *nzc, int *ISUPPZ, int *tryrac, float *work, const int *lwork, int *iwork, const int *liwork, int *info, size_t, size_t)
     * }
     */
    public static void cstemr_(MemorySegment jobz, MemorySegment range, MemorySegment n, MemorySegment D, MemorySegment E, MemorySegment vl, MemorySegment vu, MemorySegment il, MemorySegment iu, MemorySegment m, MemorySegment W, MemorySegment Z, MemorySegment ldz, MemorySegment nzc, MemorySegment ISUPPZ, MemorySegment tryrac, MemorySegment work, MemorySegment lwork, MemorySegment iwork, MemorySegment liwork, MemorySegment info, long x21, long x22) {
        var mh$ = cstemr_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cstemr_", jobz, range, n, D, E, vl, vu, il, iu, m, W, Z, ldz, nzc, ISUPPZ, tryrac, work, lwork, iwork, liwork, info, x21, x22);
            }
            mh$.invokeExact(jobz, range, n, D, E, vl, vu, il, iu, m, W, Z, ldz, nzc, ISUPPZ, tryrac, work, lwork, iwork, liwork, info, x21, x22);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dstemr_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("dstemr_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dstemr_(const char *jobz, const char *range, const int *n, double *D, double *E, const double *vl, const double *vu, const int *il, const int *iu, int *m, double *W, double *Z, const int *ldz, const int *nzc, int *ISUPPZ, int *tryrac, double *work, const int *lwork, int *iwork, const int *liwork, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor dstemr_$descriptor() {
        return dstemr_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dstemr_(const char *jobz, const char *range, const int *n, double *D, double *E, const double *vl, const double *vu, const int *il, const int *iu, int *m, double *W, double *Z, const int *ldz, const int *nzc, int *ISUPPZ, int *tryrac, double *work, const int *lwork, int *iwork, const int *liwork, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle dstemr_$handle() {
        return dstemr_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dstemr_(const char *jobz, const char *range, const int *n, double *D, double *E, const double *vl, const double *vu, const int *il, const int *iu, int *m, double *W, double *Z, const int *ldz, const int *nzc, int *ISUPPZ, int *tryrac, double *work, const int *lwork, int *iwork, const int *liwork, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment dstemr_$address() {
        return dstemr_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dstemr_(const char *jobz, const char *range, const int *n, double *D, double *E, const double *vl, const double *vu, const int *il, const int *iu, int *m, double *W, double *Z, const int *ldz, const int *nzc, int *ISUPPZ, int *tryrac, double *work, const int *lwork, int *iwork, const int *liwork, int *info, size_t, size_t)
     * }
     */
    public static void dstemr_(MemorySegment jobz, MemorySegment range, MemorySegment n, MemorySegment D, MemorySegment E, MemorySegment vl, MemorySegment vu, MemorySegment il, MemorySegment iu, MemorySegment m, MemorySegment W, MemorySegment Z, MemorySegment ldz, MemorySegment nzc, MemorySegment ISUPPZ, MemorySegment tryrac, MemorySegment work, MemorySegment lwork, MemorySegment iwork, MemorySegment liwork, MemorySegment info, long x21, long x22) {
        var mh$ = dstemr_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dstemr_", jobz, range, n, D, E, vl, vu, il, iu, m, W, Z, ldz, nzc, ISUPPZ, tryrac, work, lwork, iwork, liwork, info, x21, x22);
            }
            mh$.invokeExact(jobz, range, n, D, E, vl, vu, il, iu, m, W, Z, ldz, nzc, ISUPPZ, tryrac, work, lwork, iwork, liwork, info, x21, x22);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sstemr_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("sstemr_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void sstemr_(const char *jobz, const char *range, const int *n, float *D, float *E, const float *vl, const float *vu, const int *il, const int *iu, int *m, float *W, float *Z, const int *ldz, const int *nzc, int *ISUPPZ, int *tryrac, float *work, const int *lwork, int *iwork, const int *liwork, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor sstemr_$descriptor() {
        return sstemr_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void sstemr_(const char *jobz, const char *range, const int *n, float *D, float *E, const float *vl, const float *vu, const int *il, const int *iu, int *m, float *W, float *Z, const int *ldz, const int *nzc, int *ISUPPZ, int *tryrac, float *work, const int *lwork, int *iwork, const int *liwork, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle sstemr_$handle() {
        return sstemr_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void sstemr_(const char *jobz, const char *range, const int *n, float *D, float *E, const float *vl, const float *vu, const int *il, const int *iu, int *m, float *W, float *Z, const int *ldz, const int *nzc, int *ISUPPZ, int *tryrac, float *work, const int *lwork, int *iwork, const int *liwork, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment sstemr_$address() {
        return sstemr_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void sstemr_(const char *jobz, const char *range, const int *n, float *D, float *E, const float *vl, const float *vu, const int *il, const int *iu, int *m, float *W, float *Z, const int *ldz, const int *nzc, int *ISUPPZ, int *tryrac, float *work, const int *lwork, int *iwork, const int *liwork, int *info, size_t, size_t)
     * }
     */
    public static void sstemr_(MemorySegment jobz, MemorySegment range, MemorySegment n, MemorySegment D, MemorySegment E, MemorySegment vl, MemorySegment vu, MemorySegment il, MemorySegment iu, MemorySegment m, MemorySegment W, MemorySegment Z, MemorySegment ldz, MemorySegment nzc, MemorySegment ISUPPZ, MemorySegment tryrac, MemorySegment work, MemorySegment lwork, MemorySegment iwork, MemorySegment liwork, MemorySegment info, long x21, long x22) {
        var mh$ = sstemr_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sstemr_", jobz, range, n, D, E, vl, vu, il, iu, m, W, Z, ldz, nzc, ISUPPZ, tryrac, work, lwork, iwork, liwork, info, x21, x22);
            }
            mh$.invokeExact(jobz, range, n, D, E, vl, vu, il, iu, m, W, Z, ldz, nzc, ISUPPZ, tryrac, work, lwork, iwork, liwork, info, x21, x22);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zstemr_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("zstemr_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zstemr_(const char *jobz, const char *range, const int *n, double *D, double *E, const double *vl, const double *vu, const int *il, const int *iu, int *m, double *W, _Complex double *Z, const int *ldz, const int *nzc, int *ISUPPZ, int *tryrac, double *work, const int *lwork, int *iwork, const int *liwork, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor zstemr_$descriptor() {
        return zstemr_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zstemr_(const char *jobz, const char *range, const int *n, double *D, double *E, const double *vl, const double *vu, const int *il, const int *iu, int *m, double *W, _Complex double *Z, const int *ldz, const int *nzc, int *ISUPPZ, int *tryrac, double *work, const int *lwork, int *iwork, const int *liwork, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle zstemr_$handle() {
        return zstemr_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zstemr_(const char *jobz, const char *range, const int *n, double *D, double *E, const double *vl, const double *vu, const int *il, const int *iu, int *m, double *W, _Complex double *Z, const int *ldz, const int *nzc, int *ISUPPZ, int *tryrac, double *work, const int *lwork, int *iwork, const int *liwork, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment zstemr_$address() {
        return zstemr_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zstemr_(const char *jobz, const char *range, const int *n, double *D, double *E, const double *vl, const double *vu, const int *il, const int *iu, int *m, double *W, _Complex double *Z, const int *ldz, const int *nzc, int *ISUPPZ, int *tryrac, double *work, const int *lwork, int *iwork, const int *liwork, int *info, size_t, size_t)
     * }
     */
    public static void zstemr_(MemorySegment jobz, MemorySegment range, MemorySegment n, MemorySegment D, MemorySegment E, MemorySegment vl, MemorySegment vu, MemorySegment il, MemorySegment iu, MemorySegment m, MemorySegment W, MemorySegment Z, MemorySegment ldz, MemorySegment nzc, MemorySegment ISUPPZ, MemorySegment tryrac, MemorySegment work, MemorySegment lwork, MemorySegment iwork, MemorySegment liwork, MemorySegment info, long x21, long x22) {
        var mh$ = zstemr_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zstemr_", jobz, range, n, D, E, vl, vu, il, iu, m, W, Z, ldz, nzc, ISUPPZ, tryrac, work, lwork, iwork, liwork, info, x21, x22);
            }
            mh$.invokeExact(jobz, range, n, D, E, vl, vu, il, iu, m, W, Z, ldz, nzc, ISUPPZ, tryrac, work, lwork, iwork, liwork, info, x21, x22);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class csteqr_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("csteqr_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void csteqr_(const char *compz, const int *n, float *D, float *E, _Complex float *Z, const int *ldz, float *work, int *info, size_t)
     * }
     */
    public static FunctionDescriptor csteqr_$descriptor() {
        return csteqr_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void csteqr_(const char *compz, const int *n, float *D, float *E, _Complex float *Z, const int *ldz, float *work, int *info, size_t)
     * }
     */
    public static MethodHandle csteqr_$handle() {
        return csteqr_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void csteqr_(const char *compz, const int *n, float *D, float *E, _Complex float *Z, const int *ldz, float *work, int *info, size_t)
     * }
     */
    public static MemorySegment csteqr_$address() {
        return csteqr_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void csteqr_(const char *compz, const int *n, float *D, float *E, _Complex float *Z, const int *ldz, float *work, int *info, size_t)
     * }
     */
    public static void csteqr_(MemorySegment compz, MemorySegment n, MemorySegment D, MemorySegment E, MemorySegment Z, MemorySegment ldz, MemorySegment work, MemorySegment info, long x8) {
        var mh$ = csteqr_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("csteqr_", compz, n, D, E, Z, ldz, work, info, x8);
            }
            mh$.invokeExact(compz, n, D, E, Z, ldz, work, info, x8);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dsteqr_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("dsteqr_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dsteqr_(const char *compz, const int *n, double *D, double *E, double *Z, const int *ldz, double *work, int *info, size_t)
     * }
     */
    public static FunctionDescriptor dsteqr_$descriptor() {
        return dsteqr_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dsteqr_(const char *compz, const int *n, double *D, double *E, double *Z, const int *ldz, double *work, int *info, size_t)
     * }
     */
    public static MethodHandle dsteqr_$handle() {
        return dsteqr_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dsteqr_(const char *compz, const int *n, double *D, double *E, double *Z, const int *ldz, double *work, int *info, size_t)
     * }
     */
    public static MemorySegment dsteqr_$address() {
        return dsteqr_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dsteqr_(const char *compz, const int *n, double *D, double *E, double *Z, const int *ldz, double *work, int *info, size_t)
     * }
     */
    public static void dsteqr_(MemorySegment compz, MemorySegment n, MemorySegment D, MemorySegment E, MemorySegment Z, MemorySegment ldz, MemorySegment work, MemorySegment info, long x8) {
        var mh$ = dsteqr_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dsteqr_", compz, n, D, E, Z, ldz, work, info, x8);
            }
            mh$.invokeExact(compz, n, D, E, Z, ldz, work, info, x8);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ssteqr_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("ssteqr_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ssteqr_(const char *compz, const int *n, float *D, float *E, float *Z, const int *ldz, float *work, int *info, size_t)
     * }
     */
    public static FunctionDescriptor ssteqr_$descriptor() {
        return ssteqr_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ssteqr_(const char *compz, const int *n, float *D, float *E, float *Z, const int *ldz, float *work, int *info, size_t)
     * }
     */
    public static MethodHandle ssteqr_$handle() {
        return ssteqr_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ssteqr_(const char *compz, const int *n, float *D, float *E, float *Z, const int *ldz, float *work, int *info, size_t)
     * }
     */
    public static MemorySegment ssteqr_$address() {
        return ssteqr_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ssteqr_(const char *compz, const int *n, float *D, float *E, float *Z, const int *ldz, float *work, int *info, size_t)
     * }
     */
    public static void ssteqr_(MemorySegment compz, MemorySegment n, MemorySegment D, MemorySegment E, MemorySegment Z, MemorySegment ldz, MemorySegment work, MemorySegment info, long x8) {
        var mh$ = ssteqr_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ssteqr_", compz, n, D, E, Z, ldz, work, info, x8);
            }
            mh$.invokeExact(compz, n, D, E, Z, ldz, work, info, x8);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zsteqr_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("zsteqr_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zsteqr_(const char *compz, const int *n, double *D, double *E, _Complex double *Z, const int *ldz, double *work, int *info, size_t)
     * }
     */
    public static FunctionDescriptor zsteqr_$descriptor() {
        return zsteqr_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zsteqr_(const char *compz, const int *n, double *D, double *E, _Complex double *Z, const int *ldz, double *work, int *info, size_t)
     * }
     */
    public static MethodHandle zsteqr_$handle() {
        return zsteqr_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zsteqr_(const char *compz, const int *n, double *D, double *E, _Complex double *Z, const int *ldz, double *work, int *info, size_t)
     * }
     */
    public static MemorySegment zsteqr_$address() {
        return zsteqr_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zsteqr_(const char *compz, const int *n, double *D, double *E, _Complex double *Z, const int *ldz, double *work, int *info, size_t)
     * }
     */
    public static void zsteqr_(MemorySegment compz, MemorySegment n, MemorySegment D, MemorySegment E, MemorySegment Z, MemorySegment ldz, MemorySegment work, MemorySegment info, long x8) {
        var mh$ = zsteqr_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zsteqr_", compz, n, D, E, Z, ldz, work, info, x8);
            }
            mh$.invokeExact(compz, n, D, E, Z, ldz, work, info, x8);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dsterf_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("dsterf_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dsterf_(const int *n, double *D, double *E, int *info)
     * }
     */
    public static FunctionDescriptor dsterf_$descriptor() {
        return dsterf_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dsterf_(const int *n, double *D, double *E, int *info)
     * }
     */
    public static MethodHandle dsterf_$handle() {
        return dsterf_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dsterf_(const int *n, double *D, double *E, int *info)
     * }
     */
    public static MemorySegment dsterf_$address() {
        return dsterf_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dsterf_(const int *n, double *D, double *E, int *info)
     * }
     */
    public static void dsterf_(MemorySegment n, MemorySegment D, MemorySegment E, MemorySegment info) {
        var mh$ = dsterf_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dsterf_", n, D, E, info);
            }
            mh$.invokeExact(n, D, E, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ssterf_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("ssterf_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ssterf_(const int *n, float *D, float *E, int *info)
     * }
     */
    public static FunctionDescriptor ssterf_$descriptor() {
        return ssterf_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ssterf_(const int *n, float *D, float *E, int *info)
     * }
     */
    public static MethodHandle ssterf_$handle() {
        return ssterf_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ssterf_(const int *n, float *D, float *E, int *info)
     * }
     */
    public static MemorySegment ssterf_$address() {
        return ssterf_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ssterf_(const int *n, float *D, float *E, int *info)
     * }
     */
    public static void ssterf_(MemorySegment n, MemorySegment D, MemorySegment E, MemorySegment info) {
        var mh$ = ssterf_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ssterf_", n, D, E, info);
            }
            mh$.invokeExact(n, D, E, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dstev_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("dstev_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dstev_(const char *jobz, const int *n, double *D, double *E, double *Z, const int *ldz, double *work, int *info, size_t)
     * }
     */
    public static FunctionDescriptor dstev_$descriptor() {
        return dstev_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dstev_(const char *jobz, const int *n, double *D, double *E, double *Z, const int *ldz, double *work, int *info, size_t)
     * }
     */
    public static MethodHandle dstev_$handle() {
        return dstev_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dstev_(const char *jobz, const int *n, double *D, double *E, double *Z, const int *ldz, double *work, int *info, size_t)
     * }
     */
    public static MemorySegment dstev_$address() {
        return dstev_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dstev_(const char *jobz, const int *n, double *D, double *E, double *Z, const int *ldz, double *work, int *info, size_t)
     * }
     */
    public static void dstev_(MemorySegment jobz, MemorySegment n, MemorySegment D, MemorySegment E, MemorySegment Z, MemorySegment ldz, MemorySegment work, MemorySegment info, long x8) {
        var mh$ = dstev_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dstev_", jobz, n, D, E, Z, ldz, work, info, x8);
            }
            mh$.invokeExact(jobz, n, D, E, Z, ldz, work, info, x8);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sstev_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("sstev_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void sstev_(const char *jobz, const int *n, float *D, float *E, float *Z, const int *ldz, float *work, int *info, size_t)
     * }
     */
    public static FunctionDescriptor sstev_$descriptor() {
        return sstev_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void sstev_(const char *jobz, const int *n, float *D, float *E, float *Z, const int *ldz, float *work, int *info, size_t)
     * }
     */
    public static MethodHandle sstev_$handle() {
        return sstev_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void sstev_(const char *jobz, const int *n, float *D, float *E, float *Z, const int *ldz, float *work, int *info, size_t)
     * }
     */
    public static MemorySegment sstev_$address() {
        return sstev_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void sstev_(const char *jobz, const int *n, float *D, float *E, float *Z, const int *ldz, float *work, int *info, size_t)
     * }
     */
    public static void sstev_(MemorySegment jobz, MemorySegment n, MemorySegment D, MemorySegment E, MemorySegment Z, MemorySegment ldz, MemorySegment work, MemorySegment info, long x8) {
        var mh$ = sstev_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sstev_", jobz, n, D, E, Z, ldz, work, info, x8);
            }
            mh$.invokeExact(jobz, n, D, E, Z, ldz, work, info, x8);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dstevd_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("dstevd_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dstevd_(const char *jobz, const int *n, double *D, double *E, double *Z, const int *ldz, double *work, const int *lwork, int *iwork, const int *liwork, int *info, size_t)
     * }
     */
    public static FunctionDescriptor dstevd_$descriptor() {
        return dstevd_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dstevd_(const char *jobz, const int *n, double *D, double *E, double *Z, const int *ldz, double *work, const int *lwork, int *iwork, const int *liwork, int *info, size_t)
     * }
     */
    public static MethodHandle dstevd_$handle() {
        return dstevd_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dstevd_(const char *jobz, const int *n, double *D, double *E, double *Z, const int *ldz, double *work, const int *lwork, int *iwork, const int *liwork, int *info, size_t)
     * }
     */
    public static MemorySegment dstevd_$address() {
        return dstevd_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dstevd_(const char *jobz, const int *n, double *D, double *E, double *Z, const int *ldz, double *work, const int *lwork, int *iwork, const int *liwork, int *info, size_t)
     * }
     */
    public static void dstevd_(MemorySegment jobz, MemorySegment n, MemorySegment D, MemorySegment E, MemorySegment Z, MemorySegment ldz, MemorySegment work, MemorySegment lwork, MemorySegment iwork, MemorySegment liwork, MemorySegment info, long x11) {
        var mh$ = dstevd_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dstevd_", jobz, n, D, E, Z, ldz, work, lwork, iwork, liwork, info, x11);
            }
            mh$.invokeExact(jobz, n, D, E, Z, ldz, work, lwork, iwork, liwork, info, x11);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sstevd_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("sstevd_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void sstevd_(const char *jobz, const int *n, float *D, float *E, float *Z, const int *ldz, float *work, const int *lwork, int *iwork, const int *liwork, int *info, size_t)
     * }
     */
    public static FunctionDescriptor sstevd_$descriptor() {
        return sstevd_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void sstevd_(const char *jobz, const int *n, float *D, float *E, float *Z, const int *ldz, float *work, const int *lwork, int *iwork, const int *liwork, int *info, size_t)
     * }
     */
    public static MethodHandle sstevd_$handle() {
        return sstevd_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void sstevd_(const char *jobz, const int *n, float *D, float *E, float *Z, const int *ldz, float *work, const int *lwork, int *iwork, const int *liwork, int *info, size_t)
     * }
     */
    public static MemorySegment sstevd_$address() {
        return sstevd_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void sstevd_(const char *jobz, const int *n, float *D, float *E, float *Z, const int *ldz, float *work, const int *lwork, int *iwork, const int *liwork, int *info, size_t)
     * }
     */
    public static void sstevd_(MemorySegment jobz, MemorySegment n, MemorySegment D, MemorySegment E, MemorySegment Z, MemorySegment ldz, MemorySegment work, MemorySegment lwork, MemorySegment iwork, MemorySegment liwork, MemorySegment info, long x11) {
        var mh$ = sstevd_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sstevd_", jobz, n, D, E, Z, ldz, work, lwork, iwork, liwork, info, x11);
            }
            mh$.invokeExact(jobz, n, D, E, Z, ldz, work, lwork, iwork, liwork, info, x11);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dstevr_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("dstevr_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dstevr_(const char *jobz, const char *range, const int *n, double *D, double *E, const double *vl, const double *vu, const int *il, const int *iu, const double *abstol, int *m, double *W, double *Z, const int *ldz, int *ISUPPZ, double *work, const int *lwork, int *iwork, const int *liwork, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor dstevr_$descriptor() {
        return dstevr_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dstevr_(const char *jobz, const char *range, const int *n, double *D, double *E, const double *vl, const double *vu, const int *il, const int *iu, const double *abstol, int *m, double *W, double *Z, const int *ldz, int *ISUPPZ, double *work, const int *lwork, int *iwork, const int *liwork, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle dstevr_$handle() {
        return dstevr_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dstevr_(const char *jobz, const char *range, const int *n, double *D, double *E, const double *vl, const double *vu, const int *il, const int *iu, const double *abstol, int *m, double *W, double *Z, const int *ldz, int *ISUPPZ, double *work, const int *lwork, int *iwork, const int *liwork, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment dstevr_$address() {
        return dstevr_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dstevr_(const char *jobz, const char *range, const int *n, double *D, double *E, const double *vl, const double *vu, const int *il, const int *iu, const double *abstol, int *m, double *W, double *Z, const int *ldz, int *ISUPPZ, double *work, const int *lwork, int *iwork, const int *liwork, int *info, size_t, size_t)
     * }
     */
    public static void dstevr_(MemorySegment jobz, MemorySegment range, MemorySegment n, MemorySegment D, MemorySegment E, MemorySegment vl, MemorySegment vu, MemorySegment il, MemorySegment iu, MemorySegment abstol, MemorySegment m, MemorySegment W, MemorySegment Z, MemorySegment ldz, MemorySegment ISUPPZ, MemorySegment work, MemorySegment lwork, MemorySegment iwork, MemorySegment liwork, MemorySegment info, long x20, long x21) {
        var mh$ = dstevr_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dstevr_", jobz, range, n, D, E, vl, vu, il, iu, abstol, m, W, Z, ldz, ISUPPZ, work, lwork, iwork, liwork, info, x20, x21);
            }
            mh$.invokeExact(jobz, range, n, D, E, vl, vu, il, iu, abstol, m, W, Z, ldz, ISUPPZ, work, lwork, iwork, liwork, info, x20, x21);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sstevr_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("sstevr_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void sstevr_(const char *jobz, const char *range, const int *n, float *D, float *E, const float *vl, const float *vu, const int *il, const int *iu, const float *abstol, int *m, float *W, float *Z, const int *ldz, int *ISUPPZ, float *work, const int *lwork, int *iwork, const int *liwork, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor sstevr_$descriptor() {
        return sstevr_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void sstevr_(const char *jobz, const char *range, const int *n, float *D, float *E, const float *vl, const float *vu, const int *il, const int *iu, const float *abstol, int *m, float *W, float *Z, const int *ldz, int *ISUPPZ, float *work, const int *lwork, int *iwork, const int *liwork, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle sstevr_$handle() {
        return sstevr_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void sstevr_(const char *jobz, const char *range, const int *n, float *D, float *E, const float *vl, const float *vu, const int *il, const int *iu, const float *abstol, int *m, float *W, float *Z, const int *ldz, int *ISUPPZ, float *work, const int *lwork, int *iwork, const int *liwork, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment sstevr_$address() {
        return sstevr_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void sstevr_(const char *jobz, const char *range, const int *n, float *D, float *E, const float *vl, const float *vu, const int *il, const int *iu, const float *abstol, int *m, float *W, float *Z, const int *ldz, int *ISUPPZ, float *work, const int *lwork, int *iwork, const int *liwork, int *info, size_t, size_t)
     * }
     */
    public static void sstevr_(MemorySegment jobz, MemorySegment range, MemorySegment n, MemorySegment D, MemorySegment E, MemorySegment vl, MemorySegment vu, MemorySegment il, MemorySegment iu, MemorySegment abstol, MemorySegment m, MemorySegment W, MemorySegment Z, MemorySegment ldz, MemorySegment ISUPPZ, MemorySegment work, MemorySegment lwork, MemorySegment iwork, MemorySegment liwork, MemorySegment info, long x20, long x21) {
        var mh$ = sstevr_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sstevr_", jobz, range, n, D, E, vl, vu, il, iu, abstol, m, W, Z, ldz, ISUPPZ, work, lwork, iwork, liwork, info, x20, x21);
            }
            mh$.invokeExact(jobz, range, n, D, E, vl, vu, il, iu, abstol, m, W, Z, ldz, ISUPPZ, work, lwork, iwork, liwork, info, x20, x21);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dstevx_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("dstevx_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dstevx_(const char *jobz, const char *range, const int *n, double *D, double *E, const double *vl, const double *vu, const int *il, const int *iu, const double *abstol, int *m, double *W, double *Z, const int *ldz, double *work, int *iwork, int *IFAIL, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor dstevx_$descriptor() {
        return dstevx_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dstevx_(const char *jobz, const char *range, const int *n, double *D, double *E, const double *vl, const double *vu, const int *il, const int *iu, const double *abstol, int *m, double *W, double *Z, const int *ldz, double *work, int *iwork, int *IFAIL, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle dstevx_$handle() {
        return dstevx_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dstevx_(const char *jobz, const char *range, const int *n, double *D, double *E, const double *vl, const double *vu, const int *il, const int *iu, const double *abstol, int *m, double *W, double *Z, const int *ldz, double *work, int *iwork, int *IFAIL, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment dstevx_$address() {
        return dstevx_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dstevx_(const char *jobz, const char *range, const int *n, double *D, double *E, const double *vl, const double *vu, const int *il, const int *iu, const double *abstol, int *m, double *W, double *Z, const int *ldz, double *work, int *iwork, int *IFAIL, int *info, size_t, size_t)
     * }
     */
    public static void dstevx_(MemorySegment jobz, MemorySegment range, MemorySegment n, MemorySegment D, MemorySegment E, MemorySegment vl, MemorySegment vu, MemorySegment il, MemorySegment iu, MemorySegment abstol, MemorySegment m, MemorySegment W, MemorySegment Z, MemorySegment ldz, MemorySegment work, MemorySegment iwork, MemorySegment IFAIL, MemorySegment info, long x18, long x19) {
        var mh$ = dstevx_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dstevx_", jobz, range, n, D, E, vl, vu, il, iu, abstol, m, W, Z, ldz, work, iwork, IFAIL, info, x18, x19);
            }
            mh$.invokeExact(jobz, range, n, D, E, vl, vu, il, iu, abstol, m, W, Z, ldz, work, iwork, IFAIL, info, x18, x19);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sstevx_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("sstevx_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void sstevx_(const char *jobz, const char *range, const int *n, float *D, float *E, const float *vl, const float *vu, const int *il, const int *iu, const float *abstol, int *m, float *W, float *Z, const int *ldz, float *work, int *iwork, int *IFAIL, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor sstevx_$descriptor() {
        return sstevx_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void sstevx_(const char *jobz, const char *range, const int *n, float *D, float *E, const float *vl, const float *vu, const int *il, const int *iu, const float *abstol, int *m, float *W, float *Z, const int *ldz, float *work, int *iwork, int *IFAIL, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle sstevx_$handle() {
        return sstevx_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void sstevx_(const char *jobz, const char *range, const int *n, float *D, float *E, const float *vl, const float *vu, const int *il, const int *iu, const float *abstol, int *m, float *W, float *Z, const int *ldz, float *work, int *iwork, int *IFAIL, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment sstevx_$address() {
        return sstevx_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void sstevx_(const char *jobz, const char *range, const int *n, float *D, float *E, const float *vl, const float *vu, const int *il, const int *iu, const float *abstol, int *m, float *W, float *Z, const int *ldz, float *work, int *iwork, int *IFAIL, int *info, size_t, size_t)
     * }
     */
    public static void sstevx_(MemorySegment jobz, MemorySegment range, MemorySegment n, MemorySegment D, MemorySegment E, MemorySegment vl, MemorySegment vu, MemorySegment il, MemorySegment iu, MemorySegment abstol, MemorySegment m, MemorySegment W, MemorySegment Z, MemorySegment ldz, MemorySegment work, MemorySegment iwork, MemorySegment IFAIL, MemorySegment info, long x18, long x19) {
        var mh$ = sstevx_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sstevx_", jobz, range, n, D, E, vl, vu, il, iu, abstol, m, W, Z, ldz, work, iwork, IFAIL, info, x18, x19);
            }
            mh$.invokeExact(jobz, range, n, D, E, vl, vu, il, iu, abstol, m, W, Z, ldz, work, iwork, IFAIL, info, x18, x19);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class csycon_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("csycon_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void csycon_(const char *uplo, const int *n, const _Complex float *A, const int *lda, const int *ipiv, const float *anorm, float *rcond, _Complex float *work, int *info, size_t)
     * }
     */
    public static FunctionDescriptor csycon_$descriptor() {
        return csycon_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void csycon_(const char *uplo, const int *n, const _Complex float *A, const int *lda, const int *ipiv, const float *anorm, float *rcond, _Complex float *work, int *info, size_t)
     * }
     */
    public static MethodHandle csycon_$handle() {
        return csycon_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void csycon_(const char *uplo, const int *n, const _Complex float *A, const int *lda, const int *ipiv, const float *anorm, float *rcond, _Complex float *work, int *info, size_t)
     * }
     */
    public static MemorySegment csycon_$address() {
        return csycon_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void csycon_(const char *uplo, const int *n, const _Complex float *A, const int *lda, const int *ipiv, const float *anorm, float *rcond, _Complex float *work, int *info, size_t)
     * }
     */
    public static void csycon_(MemorySegment uplo, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment ipiv, MemorySegment anorm, MemorySegment rcond, MemorySegment work, MemorySegment info, long x9) {
        var mh$ = csycon_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("csycon_", uplo, n, A, lda, ipiv, anorm, rcond, work, info, x9);
            }
            mh$.invokeExact(uplo, n, A, lda, ipiv, anorm, rcond, work, info, x9);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dsycon_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("dsycon_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dsycon_(const char *uplo, const int *n, const double *A, const int *lda, const int *ipiv, const double *anorm, double *rcond, double *work, int *iwork, int *info, size_t)
     * }
     */
    public static FunctionDescriptor dsycon_$descriptor() {
        return dsycon_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dsycon_(const char *uplo, const int *n, const double *A, const int *lda, const int *ipiv, const double *anorm, double *rcond, double *work, int *iwork, int *info, size_t)
     * }
     */
    public static MethodHandle dsycon_$handle() {
        return dsycon_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dsycon_(const char *uplo, const int *n, const double *A, const int *lda, const int *ipiv, const double *anorm, double *rcond, double *work, int *iwork, int *info, size_t)
     * }
     */
    public static MemorySegment dsycon_$address() {
        return dsycon_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dsycon_(const char *uplo, const int *n, const double *A, const int *lda, const int *ipiv, const double *anorm, double *rcond, double *work, int *iwork, int *info, size_t)
     * }
     */
    public static void dsycon_(MemorySegment uplo, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment ipiv, MemorySegment anorm, MemorySegment rcond, MemorySegment work, MemorySegment iwork, MemorySegment info, long x10) {
        var mh$ = dsycon_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dsycon_", uplo, n, A, lda, ipiv, anorm, rcond, work, iwork, info, x10);
            }
            mh$.invokeExact(uplo, n, A, lda, ipiv, anorm, rcond, work, iwork, info, x10);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ssycon_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("ssycon_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ssycon_(const char *uplo, const int *n, const float *A, const int *lda, const int *ipiv, const float *anorm, float *rcond, float *work, int *iwork, int *info, size_t)
     * }
     */
    public static FunctionDescriptor ssycon_$descriptor() {
        return ssycon_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ssycon_(const char *uplo, const int *n, const float *A, const int *lda, const int *ipiv, const float *anorm, float *rcond, float *work, int *iwork, int *info, size_t)
     * }
     */
    public static MethodHandle ssycon_$handle() {
        return ssycon_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ssycon_(const char *uplo, const int *n, const float *A, const int *lda, const int *ipiv, const float *anorm, float *rcond, float *work, int *iwork, int *info, size_t)
     * }
     */
    public static MemorySegment ssycon_$address() {
        return ssycon_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ssycon_(const char *uplo, const int *n, const float *A, const int *lda, const int *ipiv, const float *anorm, float *rcond, float *work, int *iwork, int *info, size_t)
     * }
     */
    public static void ssycon_(MemorySegment uplo, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment ipiv, MemorySegment anorm, MemorySegment rcond, MemorySegment work, MemorySegment iwork, MemorySegment info, long x10) {
        var mh$ = ssycon_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ssycon_", uplo, n, A, lda, ipiv, anorm, rcond, work, iwork, info, x10);
            }
            mh$.invokeExact(uplo, n, A, lda, ipiv, anorm, rcond, work, iwork, info, x10);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zsycon_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("zsycon_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zsycon_(const char *uplo, const int *n, const _Complex double *A, const int *lda, const int *ipiv, const double *anorm, double *rcond, _Complex double *work, int *info, size_t)
     * }
     */
    public static FunctionDescriptor zsycon_$descriptor() {
        return zsycon_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zsycon_(const char *uplo, const int *n, const _Complex double *A, const int *lda, const int *ipiv, const double *anorm, double *rcond, _Complex double *work, int *info, size_t)
     * }
     */
    public static MethodHandle zsycon_$handle() {
        return zsycon_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zsycon_(const char *uplo, const int *n, const _Complex double *A, const int *lda, const int *ipiv, const double *anorm, double *rcond, _Complex double *work, int *info, size_t)
     * }
     */
    public static MemorySegment zsycon_$address() {
        return zsycon_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zsycon_(const char *uplo, const int *n, const _Complex double *A, const int *lda, const int *ipiv, const double *anorm, double *rcond, _Complex double *work, int *info, size_t)
     * }
     */
    public static void zsycon_(MemorySegment uplo, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment ipiv, MemorySegment anorm, MemorySegment rcond, MemorySegment work, MemorySegment info, long x9) {
        var mh$ = zsycon_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zsycon_", uplo, n, A, lda, ipiv, anorm, rcond, work, info, x9);
            }
            mh$.invokeExact(uplo, n, A, lda, ipiv, anorm, rcond, work, info, x9);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class csycon_3_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("csycon_3_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void csycon_3_(const char *uplo, const int *n, const _Complex float *A, const int *lda, const _Complex float *E, const int *ipiv, const float *anorm, float *rcond, _Complex float *work, int *info, size_t)
     * }
     */
    public static FunctionDescriptor csycon_3_$descriptor() {
        return csycon_3_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void csycon_3_(const char *uplo, const int *n, const _Complex float *A, const int *lda, const _Complex float *E, const int *ipiv, const float *anorm, float *rcond, _Complex float *work, int *info, size_t)
     * }
     */
    public static MethodHandle csycon_3_$handle() {
        return csycon_3_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void csycon_3_(const char *uplo, const int *n, const _Complex float *A, const int *lda, const _Complex float *E, const int *ipiv, const float *anorm, float *rcond, _Complex float *work, int *info, size_t)
     * }
     */
    public static MemorySegment csycon_3_$address() {
        return csycon_3_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void csycon_3_(const char *uplo, const int *n, const _Complex float *A, const int *lda, const _Complex float *E, const int *ipiv, const float *anorm, float *rcond, _Complex float *work, int *info, size_t)
     * }
     */
    public static void csycon_3_(MemorySegment uplo, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment E, MemorySegment ipiv, MemorySegment anorm, MemorySegment rcond, MemorySegment work, MemorySegment info, long x10) {
        var mh$ = csycon_3_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("csycon_3_", uplo, n, A, lda, E, ipiv, anorm, rcond, work, info, x10);
            }
            mh$.invokeExact(uplo, n, A, lda, E, ipiv, anorm, rcond, work, info, x10);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dsycon_3_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("dsycon_3_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dsycon_3_(const char *uplo, const int *n, const double *A, const int *lda, const double *E, const int *ipiv, const double *anorm, double *rcond, double *work, int *iwork, int *info, size_t)
     * }
     */
    public static FunctionDescriptor dsycon_3_$descriptor() {
        return dsycon_3_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dsycon_3_(const char *uplo, const int *n, const double *A, const int *lda, const double *E, const int *ipiv, const double *anorm, double *rcond, double *work, int *iwork, int *info, size_t)
     * }
     */
    public static MethodHandle dsycon_3_$handle() {
        return dsycon_3_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dsycon_3_(const char *uplo, const int *n, const double *A, const int *lda, const double *E, const int *ipiv, const double *anorm, double *rcond, double *work, int *iwork, int *info, size_t)
     * }
     */
    public static MemorySegment dsycon_3_$address() {
        return dsycon_3_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dsycon_3_(const char *uplo, const int *n, const double *A, const int *lda, const double *E, const int *ipiv, const double *anorm, double *rcond, double *work, int *iwork, int *info, size_t)
     * }
     */
    public static void dsycon_3_(MemorySegment uplo, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment E, MemorySegment ipiv, MemorySegment anorm, MemorySegment rcond, MemorySegment work, MemorySegment iwork, MemorySegment info, long x11) {
        var mh$ = dsycon_3_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dsycon_3_", uplo, n, A, lda, E, ipiv, anorm, rcond, work, iwork, info, x11);
            }
            mh$.invokeExact(uplo, n, A, lda, E, ipiv, anorm, rcond, work, iwork, info, x11);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ssycon_3_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("ssycon_3_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ssycon_3_(const char *uplo, const int *n, const float *A, const int *lda, const float *E, const int *ipiv, const float *anorm, float *rcond, float *work, int *iwork, int *info, size_t)
     * }
     */
    public static FunctionDescriptor ssycon_3_$descriptor() {
        return ssycon_3_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ssycon_3_(const char *uplo, const int *n, const float *A, const int *lda, const float *E, const int *ipiv, const float *anorm, float *rcond, float *work, int *iwork, int *info, size_t)
     * }
     */
    public static MethodHandle ssycon_3_$handle() {
        return ssycon_3_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ssycon_3_(const char *uplo, const int *n, const float *A, const int *lda, const float *E, const int *ipiv, const float *anorm, float *rcond, float *work, int *iwork, int *info, size_t)
     * }
     */
    public static MemorySegment ssycon_3_$address() {
        return ssycon_3_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ssycon_3_(const char *uplo, const int *n, const float *A, const int *lda, const float *E, const int *ipiv, const float *anorm, float *rcond, float *work, int *iwork, int *info, size_t)
     * }
     */
    public static void ssycon_3_(MemorySegment uplo, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment E, MemorySegment ipiv, MemorySegment anorm, MemorySegment rcond, MemorySegment work, MemorySegment iwork, MemorySegment info, long x11) {
        var mh$ = ssycon_3_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ssycon_3_", uplo, n, A, lda, E, ipiv, anorm, rcond, work, iwork, info, x11);
            }
            mh$.invokeExact(uplo, n, A, lda, E, ipiv, anorm, rcond, work, iwork, info, x11);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zsycon_3_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("zsycon_3_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zsycon_3_(const char *uplo, const int *n, const _Complex double *A, const int *lda, const _Complex double *E, const int *ipiv, const double *anorm, double *rcond, _Complex double *work, int *info, size_t)
     * }
     */
    public static FunctionDescriptor zsycon_3_$descriptor() {
        return zsycon_3_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zsycon_3_(const char *uplo, const int *n, const _Complex double *A, const int *lda, const _Complex double *E, const int *ipiv, const double *anorm, double *rcond, _Complex double *work, int *info, size_t)
     * }
     */
    public static MethodHandle zsycon_3_$handle() {
        return zsycon_3_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zsycon_3_(const char *uplo, const int *n, const _Complex double *A, const int *lda, const _Complex double *E, const int *ipiv, const double *anorm, double *rcond, _Complex double *work, int *info, size_t)
     * }
     */
    public static MemorySegment zsycon_3_$address() {
        return zsycon_3_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zsycon_3_(const char *uplo, const int *n, const _Complex double *A, const int *lda, const _Complex double *E, const int *ipiv, const double *anorm, double *rcond, _Complex double *work, int *info, size_t)
     * }
     */
    public static void zsycon_3_(MemorySegment uplo, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment E, MemorySegment ipiv, MemorySegment anorm, MemorySegment rcond, MemorySegment work, MemorySegment info, long x10) {
        var mh$ = zsycon_3_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zsycon_3_", uplo, n, A, lda, E, ipiv, anorm, rcond, work, info, x10);
            }
            mh$.invokeExact(uplo, n, A, lda, E, ipiv, anorm, rcond, work, info, x10);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class csyconv_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("csyconv_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void csyconv_(const char *uplo, const char *way, const int *n, _Complex float *A, const int *lda, const int *ipiv, _Complex float *E, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor csyconv_$descriptor() {
        return csyconv_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void csyconv_(const char *uplo, const char *way, const int *n, _Complex float *A, const int *lda, const int *ipiv, _Complex float *E, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle csyconv_$handle() {
        return csyconv_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void csyconv_(const char *uplo, const char *way, const int *n, _Complex float *A, const int *lda, const int *ipiv, _Complex float *E, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment csyconv_$address() {
        return csyconv_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void csyconv_(const char *uplo, const char *way, const int *n, _Complex float *A, const int *lda, const int *ipiv, _Complex float *E, int *info, size_t, size_t)
     * }
     */
    public static void csyconv_(MemorySegment uplo, MemorySegment way, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment ipiv, MemorySegment E, MemorySegment info, long x8, long x9) {
        var mh$ = csyconv_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("csyconv_", uplo, way, n, A, lda, ipiv, E, info, x8, x9);
            }
            mh$.invokeExact(uplo, way, n, A, lda, ipiv, E, info, x8, x9);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dsyconv_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("dsyconv_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dsyconv_(const char *uplo, const char *way, const int *n, double *A, const int *lda, const int *ipiv, double *E, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor dsyconv_$descriptor() {
        return dsyconv_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dsyconv_(const char *uplo, const char *way, const int *n, double *A, const int *lda, const int *ipiv, double *E, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle dsyconv_$handle() {
        return dsyconv_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dsyconv_(const char *uplo, const char *way, const int *n, double *A, const int *lda, const int *ipiv, double *E, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment dsyconv_$address() {
        return dsyconv_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dsyconv_(const char *uplo, const char *way, const int *n, double *A, const int *lda, const int *ipiv, double *E, int *info, size_t, size_t)
     * }
     */
    public static void dsyconv_(MemorySegment uplo, MemorySegment way, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment ipiv, MemorySegment E, MemorySegment info, long x8, long x9) {
        var mh$ = dsyconv_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dsyconv_", uplo, way, n, A, lda, ipiv, E, info, x8, x9);
            }
            mh$.invokeExact(uplo, way, n, A, lda, ipiv, E, info, x8, x9);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ssyconv_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("ssyconv_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ssyconv_(const char *uplo, const char *way, const int *n, float *A, const int *lda, const int *ipiv, float *E, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor ssyconv_$descriptor() {
        return ssyconv_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ssyconv_(const char *uplo, const char *way, const int *n, float *A, const int *lda, const int *ipiv, float *E, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle ssyconv_$handle() {
        return ssyconv_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ssyconv_(const char *uplo, const char *way, const int *n, float *A, const int *lda, const int *ipiv, float *E, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment ssyconv_$address() {
        return ssyconv_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ssyconv_(const char *uplo, const char *way, const int *n, float *A, const int *lda, const int *ipiv, float *E, int *info, size_t, size_t)
     * }
     */
    public static void ssyconv_(MemorySegment uplo, MemorySegment way, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment ipiv, MemorySegment E, MemorySegment info, long x8, long x9) {
        var mh$ = ssyconv_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ssyconv_", uplo, way, n, A, lda, ipiv, E, info, x8, x9);
            }
            mh$.invokeExact(uplo, way, n, A, lda, ipiv, E, info, x8, x9);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zsyconv_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("zsyconv_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zsyconv_(const char *uplo, const char *way, const int *n, _Complex double *A, const int *lda, const int *ipiv, _Complex double *E, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor zsyconv_$descriptor() {
        return zsyconv_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zsyconv_(const char *uplo, const char *way, const int *n, _Complex double *A, const int *lda, const int *ipiv, _Complex double *E, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle zsyconv_$handle() {
        return zsyconv_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zsyconv_(const char *uplo, const char *way, const int *n, _Complex double *A, const int *lda, const int *ipiv, _Complex double *E, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment zsyconv_$address() {
        return zsyconv_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zsyconv_(const char *uplo, const char *way, const int *n, _Complex double *A, const int *lda, const int *ipiv, _Complex double *E, int *info, size_t, size_t)
     * }
     */
    public static void zsyconv_(MemorySegment uplo, MemorySegment way, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment ipiv, MemorySegment E, MemorySegment info, long x8, long x9) {
        var mh$ = zsyconv_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zsyconv_", uplo, way, n, A, lda, ipiv, E, info, x8, x9);
            }
            mh$.invokeExact(uplo, way, n, A, lda, ipiv, E, info, x8, x9);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class csyequb_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("csyequb_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void csyequb_(const char *uplo, const int *n, const _Complex float *A, const int *lda, float *S, float *scond, float *amax, _Complex float *work, int *info, size_t)
     * }
     */
    public static FunctionDescriptor csyequb_$descriptor() {
        return csyequb_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void csyequb_(const char *uplo, const int *n, const _Complex float *A, const int *lda, float *S, float *scond, float *amax, _Complex float *work, int *info, size_t)
     * }
     */
    public static MethodHandle csyequb_$handle() {
        return csyequb_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void csyequb_(const char *uplo, const int *n, const _Complex float *A, const int *lda, float *S, float *scond, float *amax, _Complex float *work, int *info, size_t)
     * }
     */
    public static MemorySegment csyequb_$address() {
        return csyequb_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void csyequb_(const char *uplo, const int *n, const _Complex float *A, const int *lda, float *S, float *scond, float *amax, _Complex float *work, int *info, size_t)
     * }
     */
    public static void csyequb_(MemorySegment uplo, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment S, MemorySegment scond, MemorySegment amax, MemorySegment work, MemorySegment info, long x9) {
        var mh$ = csyequb_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("csyequb_", uplo, n, A, lda, S, scond, amax, work, info, x9);
            }
            mh$.invokeExact(uplo, n, A, lda, S, scond, amax, work, info, x9);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dsyequb_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("dsyequb_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dsyequb_(const char *uplo, const int *n, const double *A, const int *lda, double *S, double *scond, double *amax, double *work, int *info, size_t)
     * }
     */
    public static FunctionDescriptor dsyequb_$descriptor() {
        return dsyequb_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dsyequb_(const char *uplo, const int *n, const double *A, const int *lda, double *S, double *scond, double *amax, double *work, int *info, size_t)
     * }
     */
    public static MethodHandle dsyequb_$handle() {
        return dsyequb_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dsyequb_(const char *uplo, const int *n, const double *A, const int *lda, double *S, double *scond, double *amax, double *work, int *info, size_t)
     * }
     */
    public static MemorySegment dsyequb_$address() {
        return dsyequb_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dsyequb_(const char *uplo, const int *n, const double *A, const int *lda, double *S, double *scond, double *amax, double *work, int *info, size_t)
     * }
     */
    public static void dsyequb_(MemorySegment uplo, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment S, MemorySegment scond, MemorySegment amax, MemorySegment work, MemorySegment info, long x9) {
        var mh$ = dsyequb_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dsyequb_", uplo, n, A, lda, S, scond, amax, work, info, x9);
            }
            mh$.invokeExact(uplo, n, A, lda, S, scond, amax, work, info, x9);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ssyequb_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("ssyequb_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ssyequb_(const char *uplo, const int *n, const float *A, const int *lda, float *S, float *scond, float *amax, float *work, int *info, size_t)
     * }
     */
    public static FunctionDescriptor ssyequb_$descriptor() {
        return ssyequb_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ssyequb_(const char *uplo, const int *n, const float *A, const int *lda, float *S, float *scond, float *amax, float *work, int *info, size_t)
     * }
     */
    public static MethodHandle ssyequb_$handle() {
        return ssyequb_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ssyequb_(const char *uplo, const int *n, const float *A, const int *lda, float *S, float *scond, float *amax, float *work, int *info, size_t)
     * }
     */
    public static MemorySegment ssyequb_$address() {
        return ssyequb_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ssyequb_(const char *uplo, const int *n, const float *A, const int *lda, float *S, float *scond, float *amax, float *work, int *info, size_t)
     * }
     */
    public static void ssyequb_(MemorySegment uplo, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment S, MemorySegment scond, MemorySegment amax, MemorySegment work, MemorySegment info, long x9) {
        var mh$ = ssyequb_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ssyequb_", uplo, n, A, lda, S, scond, amax, work, info, x9);
            }
            mh$.invokeExact(uplo, n, A, lda, S, scond, amax, work, info, x9);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zsyequb_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("zsyequb_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zsyequb_(const char *uplo, const int *n, const _Complex double *A, const int *lda, double *S, double *scond, double *amax, _Complex double *work, int *info, size_t)
     * }
     */
    public static FunctionDescriptor zsyequb_$descriptor() {
        return zsyequb_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zsyequb_(const char *uplo, const int *n, const _Complex double *A, const int *lda, double *S, double *scond, double *amax, _Complex double *work, int *info, size_t)
     * }
     */
    public static MethodHandle zsyequb_$handle() {
        return zsyequb_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zsyequb_(const char *uplo, const int *n, const _Complex double *A, const int *lda, double *S, double *scond, double *amax, _Complex double *work, int *info, size_t)
     * }
     */
    public static MemorySegment zsyequb_$address() {
        return zsyequb_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zsyequb_(const char *uplo, const int *n, const _Complex double *A, const int *lda, double *S, double *scond, double *amax, _Complex double *work, int *info, size_t)
     * }
     */
    public static void zsyequb_(MemorySegment uplo, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment S, MemorySegment scond, MemorySegment amax, MemorySegment work, MemorySegment info, long x9) {
        var mh$ = zsyequb_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zsyequb_", uplo, n, A, lda, S, scond, amax, work, info, x9);
            }
            mh$.invokeExact(uplo, n, A, lda, S, scond, amax, work, info, x9);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dsyev_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("dsyev_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dsyev_(const char *jobz, const char *uplo, const int *n, double *A, const int *lda, double *W, double *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor dsyev_$descriptor() {
        return dsyev_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dsyev_(const char *jobz, const char *uplo, const int *n, double *A, const int *lda, double *W, double *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle dsyev_$handle() {
        return dsyev_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dsyev_(const char *jobz, const char *uplo, const int *n, double *A, const int *lda, double *W, double *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment dsyev_$address() {
        return dsyev_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dsyev_(const char *jobz, const char *uplo, const int *n, double *A, const int *lda, double *W, double *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static void dsyev_(MemorySegment jobz, MemorySegment uplo, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment W, MemorySegment work, MemorySegment lwork, MemorySegment info, long x9, long x10) {
        var mh$ = dsyev_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dsyev_", jobz, uplo, n, A, lda, W, work, lwork, info, x9, x10);
            }
            mh$.invokeExact(jobz, uplo, n, A, lda, W, work, lwork, info, x9, x10);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ssyev_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("ssyev_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ssyev_(const char *jobz, const char *uplo, const int *n, float *A, const int *lda, float *W, float *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor ssyev_$descriptor() {
        return ssyev_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ssyev_(const char *jobz, const char *uplo, const int *n, float *A, const int *lda, float *W, float *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle ssyev_$handle() {
        return ssyev_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ssyev_(const char *jobz, const char *uplo, const int *n, float *A, const int *lda, float *W, float *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment ssyev_$address() {
        return ssyev_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ssyev_(const char *jobz, const char *uplo, const int *n, float *A, const int *lda, float *W, float *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static void ssyev_(MemorySegment jobz, MemorySegment uplo, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment W, MemorySegment work, MemorySegment lwork, MemorySegment info, long x9, long x10) {
        var mh$ = ssyev_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ssyev_", jobz, uplo, n, A, lda, W, work, lwork, info, x9, x10);
            }
            mh$.invokeExact(jobz, uplo, n, A, lda, W, work, lwork, info, x9, x10);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dsyev_2stage_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("dsyev_2stage_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dsyev_2stage_(const char *jobz, const char *uplo, const int *n, double *A, const int *lda, double *W, double *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor dsyev_2stage_$descriptor() {
        return dsyev_2stage_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dsyev_2stage_(const char *jobz, const char *uplo, const int *n, double *A, const int *lda, double *W, double *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle dsyev_2stage_$handle() {
        return dsyev_2stage_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dsyev_2stage_(const char *jobz, const char *uplo, const int *n, double *A, const int *lda, double *W, double *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment dsyev_2stage_$address() {
        return dsyev_2stage_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dsyev_2stage_(const char *jobz, const char *uplo, const int *n, double *A, const int *lda, double *W, double *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static void dsyev_2stage_(MemorySegment jobz, MemorySegment uplo, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment W, MemorySegment work, MemorySegment lwork, MemorySegment info, long x9, long x10) {
        var mh$ = dsyev_2stage_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dsyev_2stage_", jobz, uplo, n, A, lda, W, work, lwork, info, x9, x10);
            }
            mh$.invokeExact(jobz, uplo, n, A, lda, W, work, lwork, info, x9, x10);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ssyev_2stage_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("ssyev_2stage_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ssyev_2stage_(const char *jobz, const char *uplo, const int *n, float *A, const int *lda, float *W, float *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor ssyev_2stage_$descriptor() {
        return ssyev_2stage_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ssyev_2stage_(const char *jobz, const char *uplo, const int *n, float *A, const int *lda, float *W, float *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle ssyev_2stage_$handle() {
        return ssyev_2stage_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ssyev_2stage_(const char *jobz, const char *uplo, const int *n, float *A, const int *lda, float *W, float *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment ssyev_2stage_$address() {
        return ssyev_2stage_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ssyev_2stage_(const char *jobz, const char *uplo, const int *n, float *A, const int *lda, float *W, float *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static void ssyev_2stage_(MemorySegment jobz, MemorySegment uplo, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment W, MemorySegment work, MemorySegment lwork, MemorySegment info, long x9, long x10) {
        var mh$ = ssyev_2stage_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ssyev_2stage_", jobz, uplo, n, A, lda, W, work, lwork, info, x9, x10);
            }
            mh$.invokeExact(jobz, uplo, n, A, lda, W, work, lwork, info, x9, x10);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dsyevd_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("dsyevd_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dsyevd_(const char *jobz, const char *uplo, const int *n, double *A, const int *lda, double *W, double *work, const int *lwork, int *iwork, const int *liwork, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor dsyevd_$descriptor() {
        return dsyevd_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dsyevd_(const char *jobz, const char *uplo, const int *n, double *A, const int *lda, double *W, double *work, const int *lwork, int *iwork, const int *liwork, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle dsyevd_$handle() {
        return dsyevd_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dsyevd_(const char *jobz, const char *uplo, const int *n, double *A, const int *lda, double *W, double *work, const int *lwork, int *iwork, const int *liwork, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment dsyevd_$address() {
        return dsyevd_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dsyevd_(const char *jobz, const char *uplo, const int *n, double *A, const int *lda, double *W, double *work, const int *lwork, int *iwork, const int *liwork, int *info, size_t, size_t)
     * }
     */
    public static void dsyevd_(MemorySegment jobz, MemorySegment uplo, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment W, MemorySegment work, MemorySegment lwork, MemorySegment iwork, MemorySegment liwork, MemorySegment info, long x11, long x12) {
        var mh$ = dsyevd_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dsyevd_", jobz, uplo, n, A, lda, W, work, lwork, iwork, liwork, info, x11, x12);
            }
            mh$.invokeExact(jobz, uplo, n, A, lda, W, work, lwork, iwork, liwork, info, x11, x12);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ssyevd_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("ssyevd_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ssyevd_(const char *jobz, const char *uplo, const int *n, float *A, const int *lda, float *W, float *work, const int *lwork, int *iwork, const int *liwork, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor ssyevd_$descriptor() {
        return ssyevd_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ssyevd_(const char *jobz, const char *uplo, const int *n, float *A, const int *lda, float *W, float *work, const int *lwork, int *iwork, const int *liwork, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle ssyevd_$handle() {
        return ssyevd_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ssyevd_(const char *jobz, const char *uplo, const int *n, float *A, const int *lda, float *W, float *work, const int *lwork, int *iwork, const int *liwork, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment ssyevd_$address() {
        return ssyevd_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ssyevd_(const char *jobz, const char *uplo, const int *n, float *A, const int *lda, float *W, float *work, const int *lwork, int *iwork, const int *liwork, int *info, size_t, size_t)
     * }
     */
    public static void ssyevd_(MemorySegment jobz, MemorySegment uplo, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment W, MemorySegment work, MemorySegment lwork, MemorySegment iwork, MemorySegment liwork, MemorySegment info, long x11, long x12) {
        var mh$ = ssyevd_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ssyevd_", jobz, uplo, n, A, lda, W, work, lwork, iwork, liwork, info, x11, x12);
            }
            mh$.invokeExact(jobz, uplo, n, A, lda, W, work, lwork, iwork, liwork, info, x11, x12);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dsyevd_2stage_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("dsyevd_2stage_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dsyevd_2stage_(const char *jobz, const char *uplo, const int *n, double *A, const int *lda, double *W, double *work, const int *lwork, int *iwork, const int *liwork, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor dsyevd_2stage_$descriptor() {
        return dsyevd_2stage_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dsyevd_2stage_(const char *jobz, const char *uplo, const int *n, double *A, const int *lda, double *W, double *work, const int *lwork, int *iwork, const int *liwork, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle dsyevd_2stage_$handle() {
        return dsyevd_2stage_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dsyevd_2stage_(const char *jobz, const char *uplo, const int *n, double *A, const int *lda, double *W, double *work, const int *lwork, int *iwork, const int *liwork, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment dsyevd_2stage_$address() {
        return dsyevd_2stage_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dsyevd_2stage_(const char *jobz, const char *uplo, const int *n, double *A, const int *lda, double *W, double *work, const int *lwork, int *iwork, const int *liwork, int *info, size_t, size_t)
     * }
     */
    public static void dsyevd_2stage_(MemorySegment jobz, MemorySegment uplo, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment W, MemorySegment work, MemorySegment lwork, MemorySegment iwork, MemorySegment liwork, MemorySegment info, long x11, long x12) {
        var mh$ = dsyevd_2stage_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dsyevd_2stage_", jobz, uplo, n, A, lda, W, work, lwork, iwork, liwork, info, x11, x12);
            }
            mh$.invokeExact(jobz, uplo, n, A, lda, W, work, lwork, iwork, liwork, info, x11, x12);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ssyevd_2stage_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("ssyevd_2stage_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ssyevd_2stage_(const char *jobz, const char *uplo, const int *n, float *A, const int *lda, float *W, float *work, const int *lwork, int *iwork, const int *liwork, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor ssyevd_2stage_$descriptor() {
        return ssyevd_2stage_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ssyevd_2stage_(const char *jobz, const char *uplo, const int *n, float *A, const int *lda, float *W, float *work, const int *lwork, int *iwork, const int *liwork, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle ssyevd_2stage_$handle() {
        return ssyevd_2stage_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ssyevd_2stage_(const char *jobz, const char *uplo, const int *n, float *A, const int *lda, float *W, float *work, const int *lwork, int *iwork, const int *liwork, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment ssyevd_2stage_$address() {
        return ssyevd_2stage_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ssyevd_2stage_(const char *jobz, const char *uplo, const int *n, float *A, const int *lda, float *W, float *work, const int *lwork, int *iwork, const int *liwork, int *info, size_t, size_t)
     * }
     */
    public static void ssyevd_2stage_(MemorySegment jobz, MemorySegment uplo, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment W, MemorySegment work, MemorySegment lwork, MemorySegment iwork, MemorySegment liwork, MemorySegment info, long x11, long x12) {
        var mh$ = ssyevd_2stage_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ssyevd_2stage_", jobz, uplo, n, A, lda, W, work, lwork, iwork, liwork, info, x11, x12);
            }
            mh$.invokeExact(jobz, uplo, n, A, lda, W, work, lwork, iwork, liwork, info, x11, x12);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dsyevr_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("dsyevr_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dsyevr_(const char *jobz, const char *range, const char *uplo, const int *n, double *A, const int *lda, const double *vl, const double *vu, const int *il, const int *iu, const double *abstol, int *m, double *W, double *Z, const int *ldz, int *ISUPPZ, double *work, const int *lwork, int *iwork, const int *liwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor dsyevr_$descriptor() {
        return dsyevr_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dsyevr_(const char *jobz, const char *range, const char *uplo, const int *n, double *A, const int *lda, const double *vl, const double *vu, const int *il, const int *iu, const double *abstol, int *m, double *W, double *Z, const int *ldz, int *ISUPPZ, double *work, const int *lwork, int *iwork, const int *liwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle dsyevr_$handle() {
        return dsyevr_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dsyevr_(const char *jobz, const char *range, const char *uplo, const int *n, double *A, const int *lda, const double *vl, const double *vu, const int *il, const int *iu, const double *abstol, int *m, double *W, double *Z, const int *ldz, int *ISUPPZ, double *work, const int *lwork, int *iwork, const int *liwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment dsyevr_$address() {
        return dsyevr_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dsyevr_(const char *jobz, const char *range, const char *uplo, const int *n, double *A, const int *lda, const double *vl, const double *vu, const int *il, const int *iu, const double *abstol, int *m, double *W, double *Z, const int *ldz, int *ISUPPZ, double *work, const int *lwork, int *iwork, const int *liwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static void dsyevr_(MemorySegment jobz, MemorySegment range, MemorySegment uplo, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment vl, MemorySegment vu, MemorySegment il, MemorySegment iu, MemorySegment abstol, MemorySegment m, MemorySegment W, MemorySegment Z, MemorySegment ldz, MemorySegment ISUPPZ, MemorySegment work, MemorySegment lwork, MemorySegment iwork, MemorySegment liwork, MemorySegment info, long x21, long x22, long x23) {
        var mh$ = dsyevr_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dsyevr_", jobz, range, uplo, n, A, lda, vl, vu, il, iu, abstol, m, W, Z, ldz, ISUPPZ, work, lwork, iwork, liwork, info, x21, x22, x23);
            }
            mh$.invokeExact(jobz, range, uplo, n, A, lda, vl, vu, il, iu, abstol, m, W, Z, ldz, ISUPPZ, work, lwork, iwork, liwork, info, x21, x22, x23);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ssyevr_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("ssyevr_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ssyevr_(const char *jobz, const char *range, const char *uplo, const int *n, float *A, const int *lda, const float *vl, const float *vu, const int *il, const int *iu, const float *abstol, int *m, float *W, float *Z, const int *ldz, int *ISUPPZ, float *work, const int *lwork, int *iwork, const int *liwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor ssyevr_$descriptor() {
        return ssyevr_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ssyevr_(const char *jobz, const char *range, const char *uplo, const int *n, float *A, const int *lda, const float *vl, const float *vu, const int *il, const int *iu, const float *abstol, int *m, float *W, float *Z, const int *ldz, int *ISUPPZ, float *work, const int *lwork, int *iwork, const int *liwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle ssyevr_$handle() {
        return ssyevr_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ssyevr_(const char *jobz, const char *range, const char *uplo, const int *n, float *A, const int *lda, const float *vl, const float *vu, const int *il, const int *iu, const float *abstol, int *m, float *W, float *Z, const int *ldz, int *ISUPPZ, float *work, const int *lwork, int *iwork, const int *liwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment ssyevr_$address() {
        return ssyevr_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ssyevr_(const char *jobz, const char *range, const char *uplo, const int *n, float *A, const int *lda, const float *vl, const float *vu, const int *il, const int *iu, const float *abstol, int *m, float *W, float *Z, const int *ldz, int *ISUPPZ, float *work, const int *lwork, int *iwork, const int *liwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static void ssyevr_(MemorySegment jobz, MemorySegment range, MemorySegment uplo, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment vl, MemorySegment vu, MemorySegment il, MemorySegment iu, MemorySegment abstol, MemorySegment m, MemorySegment W, MemorySegment Z, MemorySegment ldz, MemorySegment ISUPPZ, MemorySegment work, MemorySegment lwork, MemorySegment iwork, MemorySegment liwork, MemorySegment info, long x21, long x22, long x23) {
        var mh$ = ssyevr_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ssyevr_", jobz, range, uplo, n, A, lda, vl, vu, il, iu, abstol, m, W, Z, ldz, ISUPPZ, work, lwork, iwork, liwork, info, x21, x22, x23);
            }
            mh$.invokeExact(jobz, range, uplo, n, A, lda, vl, vu, il, iu, abstol, m, W, Z, ldz, ISUPPZ, work, lwork, iwork, liwork, info, x21, x22, x23);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dsyevr_2stage_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("dsyevr_2stage_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dsyevr_2stage_(const char *jobz, const char *range, const char *uplo, const int *n, double *A, const int *lda, const double *vl, const double *vu, const int *il, const int *iu, const double *abstol, int *m, double *W, double *Z, const int *ldz, int *ISUPPZ, double *work, const int *lwork, int *iwork, const int *liwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor dsyevr_2stage_$descriptor() {
        return dsyevr_2stage_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dsyevr_2stage_(const char *jobz, const char *range, const char *uplo, const int *n, double *A, const int *lda, const double *vl, const double *vu, const int *il, const int *iu, const double *abstol, int *m, double *W, double *Z, const int *ldz, int *ISUPPZ, double *work, const int *lwork, int *iwork, const int *liwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle dsyevr_2stage_$handle() {
        return dsyevr_2stage_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dsyevr_2stage_(const char *jobz, const char *range, const char *uplo, const int *n, double *A, const int *lda, const double *vl, const double *vu, const int *il, const int *iu, const double *abstol, int *m, double *W, double *Z, const int *ldz, int *ISUPPZ, double *work, const int *lwork, int *iwork, const int *liwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment dsyevr_2stage_$address() {
        return dsyevr_2stage_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dsyevr_2stage_(const char *jobz, const char *range, const char *uplo, const int *n, double *A, const int *lda, const double *vl, const double *vu, const int *il, const int *iu, const double *abstol, int *m, double *W, double *Z, const int *ldz, int *ISUPPZ, double *work, const int *lwork, int *iwork, const int *liwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static void dsyevr_2stage_(MemorySegment jobz, MemorySegment range, MemorySegment uplo, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment vl, MemorySegment vu, MemorySegment il, MemorySegment iu, MemorySegment abstol, MemorySegment m, MemorySegment W, MemorySegment Z, MemorySegment ldz, MemorySegment ISUPPZ, MemorySegment work, MemorySegment lwork, MemorySegment iwork, MemorySegment liwork, MemorySegment info, long x21, long x22, long x23) {
        var mh$ = dsyevr_2stage_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dsyevr_2stage_", jobz, range, uplo, n, A, lda, vl, vu, il, iu, abstol, m, W, Z, ldz, ISUPPZ, work, lwork, iwork, liwork, info, x21, x22, x23);
            }
            mh$.invokeExact(jobz, range, uplo, n, A, lda, vl, vu, il, iu, abstol, m, W, Z, ldz, ISUPPZ, work, lwork, iwork, liwork, info, x21, x22, x23);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ssyevr_2stage_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("ssyevr_2stage_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ssyevr_2stage_(const char *jobz, const char *range, const char *uplo, const int *n, float *A, const int *lda, const float *vl, const float *vu, const int *il, const int *iu, const float *abstol, int *m, float *W, float *Z, const int *ldz, int *ISUPPZ, float *work, const int *lwork, int *iwork, const int *liwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor ssyevr_2stage_$descriptor() {
        return ssyevr_2stage_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ssyevr_2stage_(const char *jobz, const char *range, const char *uplo, const int *n, float *A, const int *lda, const float *vl, const float *vu, const int *il, const int *iu, const float *abstol, int *m, float *W, float *Z, const int *ldz, int *ISUPPZ, float *work, const int *lwork, int *iwork, const int *liwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle ssyevr_2stage_$handle() {
        return ssyevr_2stage_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ssyevr_2stage_(const char *jobz, const char *range, const char *uplo, const int *n, float *A, const int *lda, const float *vl, const float *vu, const int *il, const int *iu, const float *abstol, int *m, float *W, float *Z, const int *ldz, int *ISUPPZ, float *work, const int *lwork, int *iwork, const int *liwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment ssyevr_2stage_$address() {
        return ssyevr_2stage_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ssyevr_2stage_(const char *jobz, const char *range, const char *uplo, const int *n, float *A, const int *lda, const float *vl, const float *vu, const int *il, const int *iu, const float *abstol, int *m, float *W, float *Z, const int *ldz, int *ISUPPZ, float *work, const int *lwork, int *iwork, const int *liwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static void ssyevr_2stage_(MemorySegment jobz, MemorySegment range, MemorySegment uplo, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment vl, MemorySegment vu, MemorySegment il, MemorySegment iu, MemorySegment abstol, MemorySegment m, MemorySegment W, MemorySegment Z, MemorySegment ldz, MemorySegment ISUPPZ, MemorySegment work, MemorySegment lwork, MemorySegment iwork, MemorySegment liwork, MemorySegment info, long x21, long x22, long x23) {
        var mh$ = ssyevr_2stage_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ssyevr_2stage_", jobz, range, uplo, n, A, lda, vl, vu, il, iu, abstol, m, W, Z, ldz, ISUPPZ, work, lwork, iwork, liwork, info, x21, x22, x23);
            }
            mh$.invokeExact(jobz, range, uplo, n, A, lda, vl, vu, il, iu, abstol, m, W, Z, ldz, ISUPPZ, work, lwork, iwork, liwork, info, x21, x22, x23);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dsyevx_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("dsyevx_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dsyevx_(const char *jobz, const char *range, const char *uplo, const int *n, double *A, const int *lda, const double *vl, const double *vu, const int *il, const int *iu, const double *abstol, int *m, double *W, double *Z, const int *ldz, double *work, const int *lwork, int *iwork, int *IFAIL, int *info, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor dsyevx_$descriptor() {
        return dsyevx_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dsyevx_(const char *jobz, const char *range, const char *uplo, const int *n, double *A, const int *lda, const double *vl, const double *vu, const int *il, const int *iu, const double *abstol, int *m, double *W, double *Z, const int *ldz, double *work, const int *lwork, int *iwork, int *IFAIL, int *info, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle dsyevx_$handle() {
        return dsyevx_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dsyevx_(const char *jobz, const char *range, const char *uplo, const int *n, double *A, const int *lda, const double *vl, const double *vu, const int *il, const int *iu, const double *abstol, int *m, double *W, double *Z, const int *ldz, double *work, const int *lwork, int *iwork, int *IFAIL, int *info, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment dsyevx_$address() {
        return dsyevx_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dsyevx_(const char *jobz, const char *range, const char *uplo, const int *n, double *A, const int *lda, const double *vl, const double *vu, const int *il, const int *iu, const double *abstol, int *m, double *W, double *Z, const int *ldz, double *work, const int *lwork, int *iwork, int *IFAIL, int *info, size_t, size_t, size_t)
     * }
     */
    public static void dsyevx_(MemorySegment jobz, MemorySegment range, MemorySegment uplo, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment vl, MemorySegment vu, MemorySegment il, MemorySegment iu, MemorySegment abstol, MemorySegment m, MemorySegment W, MemorySegment Z, MemorySegment ldz, MemorySegment work, MemorySegment lwork, MemorySegment iwork, MemorySegment IFAIL, MemorySegment info, long x20, long x21, long x22) {
        var mh$ = dsyevx_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dsyevx_", jobz, range, uplo, n, A, lda, vl, vu, il, iu, abstol, m, W, Z, ldz, work, lwork, iwork, IFAIL, info, x20, x21, x22);
            }
            mh$.invokeExact(jobz, range, uplo, n, A, lda, vl, vu, il, iu, abstol, m, W, Z, ldz, work, lwork, iwork, IFAIL, info, x20, x21, x22);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ssyevx_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("ssyevx_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ssyevx_(const char *jobz, const char *range, const char *uplo, const int *n, float *A, const int *lda, const float *vl, const float *vu, const int *il, const int *iu, const float *abstol, int *m, float *W, float *Z, const int *ldz, float *work, const int *lwork, int *iwork, int *IFAIL, int *info, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor ssyevx_$descriptor() {
        return ssyevx_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ssyevx_(const char *jobz, const char *range, const char *uplo, const int *n, float *A, const int *lda, const float *vl, const float *vu, const int *il, const int *iu, const float *abstol, int *m, float *W, float *Z, const int *ldz, float *work, const int *lwork, int *iwork, int *IFAIL, int *info, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle ssyevx_$handle() {
        return ssyevx_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ssyevx_(const char *jobz, const char *range, const char *uplo, const int *n, float *A, const int *lda, const float *vl, const float *vu, const int *il, const int *iu, const float *abstol, int *m, float *W, float *Z, const int *ldz, float *work, const int *lwork, int *iwork, int *IFAIL, int *info, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment ssyevx_$address() {
        return ssyevx_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ssyevx_(const char *jobz, const char *range, const char *uplo, const int *n, float *A, const int *lda, const float *vl, const float *vu, const int *il, const int *iu, const float *abstol, int *m, float *W, float *Z, const int *ldz, float *work, const int *lwork, int *iwork, int *IFAIL, int *info, size_t, size_t, size_t)
     * }
     */
    public static void ssyevx_(MemorySegment jobz, MemorySegment range, MemorySegment uplo, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment vl, MemorySegment vu, MemorySegment il, MemorySegment iu, MemorySegment abstol, MemorySegment m, MemorySegment W, MemorySegment Z, MemorySegment ldz, MemorySegment work, MemorySegment lwork, MemorySegment iwork, MemorySegment IFAIL, MemorySegment info, long x20, long x21, long x22) {
        var mh$ = ssyevx_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ssyevx_", jobz, range, uplo, n, A, lda, vl, vu, il, iu, abstol, m, W, Z, ldz, work, lwork, iwork, IFAIL, info, x20, x21, x22);
            }
            mh$.invokeExact(jobz, range, uplo, n, A, lda, vl, vu, il, iu, abstol, m, W, Z, ldz, work, lwork, iwork, IFAIL, info, x20, x21, x22);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dsyevx_2stage_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("dsyevx_2stage_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dsyevx_2stage_(const char *jobz, const char *range, const char *uplo, const int *n, double *A, const int *lda, const double *vl, const double *vu, const int *il, const int *iu, const double *abstol, int *m, double *W, double *Z, const int *ldz, double *work, const int *lwork, int *iwork, int *IFAIL, int *info, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor dsyevx_2stage_$descriptor() {
        return dsyevx_2stage_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dsyevx_2stage_(const char *jobz, const char *range, const char *uplo, const int *n, double *A, const int *lda, const double *vl, const double *vu, const int *il, const int *iu, const double *abstol, int *m, double *W, double *Z, const int *ldz, double *work, const int *lwork, int *iwork, int *IFAIL, int *info, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle dsyevx_2stage_$handle() {
        return dsyevx_2stage_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dsyevx_2stage_(const char *jobz, const char *range, const char *uplo, const int *n, double *A, const int *lda, const double *vl, const double *vu, const int *il, const int *iu, const double *abstol, int *m, double *W, double *Z, const int *ldz, double *work, const int *lwork, int *iwork, int *IFAIL, int *info, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment dsyevx_2stage_$address() {
        return dsyevx_2stage_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dsyevx_2stage_(const char *jobz, const char *range, const char *uplo, const int *n, double *A, const int *lda, const double *vl, const double *vu, const int *il, const int *iu, const double *abstol, int *m, double *W, double *Z, const int *ldz, double *work, const int *lwork, int *iwork, int *IFAIL, int *info, size_t, size_t, size_t)
     * }
     */
    public static void dsyevx_2stage_(MemorySegment jobz, MemorySegment range, MemorySegment uplo, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment vl, MemorySegment vu, MemorySegment il, MemorySegment iu, MemorySegment abstol, MemorySegment m, MemorySegment W, MemorySegment Z, MemorySegment ldz, MemorySegment work, MemorySegment lwork, MemorySegment iwork, MemorySegment IFAIL, MemorySegment info, long x20, long x21, long x22) {
        var mh$ = dsyevx_2stage_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dsyevx_2stage_", jobz, range, uplo, n, A, lda, vl, vu, il, iu, abstol, m, W, Z, ldz, work, lwork, iwork, IFAIL, info, x20, x21, x22);
            }
            mh$.invokeExact(jobz, range, uplo, n, A, lda, vl, vu, il, iu, abstol, m, W, Z, ldz, work, lwork, iwork, IFAIL, info, x20, x21, x22);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ssyevx_2stage_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("ssyevx_2stage_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ssyevx_2stage_(const char *jobz, const char *range, const char *uplo, const int *n, float *A, const int *lda, const float *vl, const float *vu, const int *il, const int *iu, const float *abstol, int *m, float *W, float *Z, const int *ldz, float *work, const int *lwork, int *iwork, int *IFAIL, int *info, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor ssyevx_2stage_$descriptor() {
        return ssyevx_2stage_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ssyevx_2stage_(const char *jobz, const char *range, const char *uplo, const int *n, float *A, const int *lda, const float *vl, const float *vu, const int *il, const int *iu, const float *abstol, int *m, float *W, float *Z, const int *ldz, float *work, const int *lwork, int *iwork, int *IFAIL, int *info, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle ssyevx_2stage_$handle() {
        return ssyevx_2stage_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ssyevx_2stage_(const char *jobz, const char *range, const char *uplo, const int *n, float *A, const int *lda, const float *vl, const float *vu, const int *il, const int *iu, const float *abstol, int *m, float *W, float *Z, const int *ldz, float *work, const int *lwork, int *iwork, int *IFAIL, int *info, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment ssyevx_2stage_$address() {
        return ssyevx_2stage_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ssyevx_2stage_(const char *jobz, const char *range, const char *uplo, const int *n, float *A, const int *lda, const float *vl, const float *vu, const int *il, const int *iu, const float *abstol, int *m, float *W, float *Z, const int *ldz, float *work, const int *lwork, int *iwork, int *IFAIL, int *info, size_t, size_t, size_t)
     * }
     */
    public static void ssyevx_2stage_(MemorySegment jobz, MemorySegment range, MemorySegment uplo, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment vl, MemorySegment vu, MemorySegment il, MemorySegment iu, MemorySegment abstol, MemorySegment m, MemorySegment W, MemorySegment Z, MemorySegment ldz, MemorySegment work, MemorySegment lwork, MemorySegment iwork, MemorySegment IFAIL, MemorySegment info, long x20, long x21, long x22) {
        var mh$ = ssyevx_2stage_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ssyevx_2stage_", jobz, range, uplo, n, A, lda, vl, vu, il, iu, abstol, m, W, Z, ldz, work, lwork, iwork, IFAIL, info, x20, x21, x22);
            }
            mh$.invokeExact(jobz, range, uplo, n, A, lda, vl, vu, il, iu, abstol, m, W, Z, ldz, work, lwork, iwork, IFAIL, info, x20, x21, x22);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dsygst_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("dsygst_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dsygst_(const int *itype, const char *uplo, const int *n, double *A, const int *lda, const double *B, const int *ldb, int *info, size_t)
     * }
     */
    public static FunctionDescriptor dsygst_$descriptor() {
        return dsygst_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dsygst_(const int *itype, const char *uplo, const int *n, double *A, const int *lda, const double *B, const int *ldb, int *info, size_t)
     * }
     */
    public static MethodHandle dsygst_$handle() {
        return dsygst_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dsygst_(const int *itype, const char *uplo, const int *n, double *A, const int *lda, const double *B, const int *ldb, int *info, size_t)
     * }
     */
    public static MemorySegment dsygst_$address() {
        return dsygst_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dsygst_(const int *itype, const char *uplo, const int *n, double *A, const int *lda, const double *B, const int *ldb, int *info, size_t)
     * }
     */
    public static void dsygst_(MemorySegment itype, MemorySegment uplo, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment B, MemorySegment ldb, MemorySegment info, long x8) {
        var mh$ = dsygst_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dsygst_", itype, uplo, n, A, lda, B, ldb, info, x8);
            }
            mh$.invokeExact(itype, uplo, n, A, lda, B, ldb, info, x8);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ssygst_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("ssygst_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ssygst_(const int *itype, const char *uplo, const int *n, float *A, const int *lda, const float *B, const int *ldb, int *info, size_t)
     * }
     */
    public static FunctionDescriptor ssygst_$descriptor() {
        return ssygst_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ssygst_(const int *itype, const char *uplo, const int *n, float *A, const int *lda, const float *B, const int *ldb, int *info, size_t)
     * }
     */
    public static MethodHandle ssygst_$handle() {
        return ssygst_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ssygst_(const int *itype, const char *uplo, const int *n, float *A, const int *lda, const float *B, const int *ldb, int *info, size_t)
     * }
     */
    public static MemorySegment ssygst_$address() {
        return ssygst_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ssygst_(const int *itype, const char *uplo, const int *n, float *A, const int *lda, const float *B, const int *ldb, int *info, size_t)
     * }
     */
    public static void ssygst_(MemorySegment itype, MemorySegment uplo, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment B, MemorySegment ldb, MemorySegment info, long x8) {
        var mh$ = ssygst_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ssygst_", itype, uplo, n, A, lda, B, ldb, info, x8);
            }
            mh$.invokeExact(itype, uplo, n, A, lda, B, ldb, info, x8);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dsygv_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("dsygv_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dsygv_(const int *itype, const char *jobz, const char *uplo, const int *n, double *A, const int *lda, double *B, const int *ldb, double *W, double *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor dsygv_$descriptor() {
        return dsygv_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dsygv_(const int *itype, const char *jobz, const char *uplo, const int *n, double *A, const int *lda, double *B, const int *ldb, double *W, double *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle dsygv_$handle() {
        return dsygv_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dsygv_(const int *itype, const char *jobz, const char *uplo, const int *n, double *A, const int *lda, double *B, const int *ldb, double *W, double *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment dsygv_$address() {
        return dsygv_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dsygv_(const int *itype, const char *jobz, const char *uplo, const int *n, double *A, const int *lda, double *B, const int *ldb, double *W, double *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static void dsygv_(MemorySegment itype, MemorySegment jobz, MemorySegment uplo, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment B, MemorySegment ldb, MemorySegment W, MemorySegment work, MemorySegment lwork, MemorySegment info, long x12, long x13) {
        var mh$ = dsygv_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dsygv_", itype, jobz, uplo, n, A, lda, B, ldb, W, work, lwork, info, x12, x13);
            }
            mh$.invokeExact(itype, jobz, uplo, n, A, lda, B, ldb, W, work, lwork, info, x12, x13);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ssygv_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("ssygv_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ssygv_(const int *itype, const char *jobz, const char *uplo, const int *n, float *A, const int *lda, float *B, const int *ldb, float *W, float *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor ssygv_$descriptor() {
        return ssygv_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ssygv_(const int *itype, const char *jobz, const char *uplo, const int *n, float *A, const int *lda, float *B, const int *ldb, float *W, float *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle ssygv_$handle() {
        return ssygv_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ssygv_(const int *itype, const char *jobz, const char *uplo, const int *n, float *A, const int *lda, float *B, const int *ldb, float *W, float *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment ssygv_$address() {
        return ssygv_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ssygv_(const int *itype, const char *jobz, const char *uplo, const int *n, float *A, const int *lda, float *B, const int *ldb, float *W, float *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static void ssygv_(MemorySegment itype, MemorySegment jobz, MemorySegment uplo, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment B, MemorySegment ldb, MemorySegment W, MemorySegment work, MemorySegment lwork, MemorySegment info, long x12, long x13) {
        var mh$ = ssygv_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ssygv_", itype, jobz, uplo, n, A, lda, B, ldb, W, work, lwork, info, x12, x13);
            }
            mh$.invokeExact(itype, jobz, uplo, n, A, lda, B, ldb, W, work, lwork, info, x12, x13);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dsygv_2stage_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("dsygv_2stage_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dsygv_2stage_(const int *itype, const char *jobz, const char *uplo, const int *n, double *A, const int *lda, double *B, const int *ldb, double *W, double *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor dsygv_2stage_$descriptor() {
        return dsygv_2stage_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dsygv_2stage_(const int *itype, const char *jobz, const char *uplo, const int *n, double *A, const int *lda, double *B, const int *ldb, double *W, double *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle dsygv_2stage_$handle() {
        return dsygv_2stage_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dsygv_2stage_(const int *itype, const char *jobz, const char *uplo, const int *n, double *A, const int *lda, double *B, const int *ldb, double *W, double *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment dsygv_2stage_$address() {
        return dsygv_2stage_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dsygv_2stage_(const int *itype, const char *jobz, const char *uplo, const int *n, double *A, const int *lda, double *B, const int *ldb, double *W, double *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static void dsygv_2stage_(MemorySegment itype, MemorySegment jobz, MemorySegment uplo, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment B, MemorySegment ldb, MemorySegment W, MemorySegment work, MemorySegment lwork, MemorySegment info, long x12, long x13) {
        var mh$ = dsygv_2stage_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dsygv_2stage_", itype, jobz, uplo, n, A, lda, B, ldb, W, work, lwork, info, x12, x13);
            }
            mh$.invokeExact(itype, jobz, uplo, n, A, lda, B, ldb, W, work, lwork, info, x12, x13);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ssygv_2stage_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("ssygv_2stage_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ssygv_2stage_(const int *itype, const char *jobz, const char *uplo, const int *n, float *A, const int *lda, float *B, const int *ldb, float *W, float *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor ssygv_2stage_$descriptor() {
        return ssygv_2stage_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ssygv_2stage_(const int *itype, const char *jobz, const char *uplo, const int *n, float *A, const int *lda, float *B, const int *ldb, float *W, float *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle ssygv_2stage_$handle() {
        return ssygv_2stage_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ssygv_2stage_(const int *itype, const char *jobz, const char *uplo, const int *n, float *A, const int *lda, float *B, const int *ldb, float *W, float *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment ssygv_2stage_$address() {
        return ssygv_2stage_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ssygv_2stage_(const int *itype, const char *jobz, const char *uplo, const int *n, float *A, const int *lda, float *B, const int *ldb, float *W, float *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static void ssygv_2stage_(MemorySegment itype, MemorySegment jobz, MemorySegment uplo, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment B, MemorySegment ldb, MemorySegment W, MemorySegment work, MemorySegment lwork, MemorySegment info, long x12, long x13) {
        var mh$ = ssygv_2stage_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ssygv_2stage_", itype, jobz, uplo, n, A, lda, B, ldb, W, work, lwork, info, x12, x13);
            }
            mh$.invokeExact(itype, jobz, uplo, n, A, lda, B, ldb, W, work, lwork, info, x12, x13);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dsygvd_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("dsygvd_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dsygvd_(const int *itype, const char *jobz, const char *uplo, const int *n, double *A, const int *lda, double *B, const int *ldb, double *W, double *work, const int *lwork, int *iwork, const int *liwork, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor dsygvd_$descriptor() {
        return dsygvd_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dsygvd_(const int *itype, const char *jobz, const char *uplo, const int *n, double *A, const int *lda, double *B, const int *ldb, double *W, double *work, const int *lwork, int *iwork, const int *liwork, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle dsygvd_$handle() {
        return dsygvd_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dsygvd_(const int *itype, const char *jobz, const char *uplo, const int *n, double *A, const int *lda, double *B, const int *ldb, double *W, double *work, const int *lwork, int *iwork, const int *liwork, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment dsygvd_$address() {
        return dsygvd_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dsygvd_(const int *itype, const char *jobz, const char *uplo, const int *n, double *A, const int *lda, double *B, const int *ldb, double *W, double *work, const int *lwork, int *iwork, const int *liwork, int *info, size_t, size_t)
     * }
     */
    public static void dsygvd_(MemorySegment itype, MemorySegment jobz, MemorySegment uplo, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment B, MemorySegment ldb, MemorySegment W, MemorySegment work, MemorySegment lwork, MemorySegment iwork, MemorySegment liwork, MemorySegment info, long x14, long x15) {
        var mh$ = dsygvd_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dsygvd_", itype, jobz, uplo, n, A, lda, B, ldb, W, work, lwork, iwork, liwork, info, x14, x15);
            }
            mh$.invokeExact(itype, jobz, uplo, n, A, lda, B, ldb, W, work, lwork, iwork, liwork, info, x14, x15);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ssygvd_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("ssygvd_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ssygvd_(const int *itype, const char *jobz, const char *uplo, const int *n, float *A, const int *lda, float *B, const int *ldb, float *W, float *work, const int *lwork, int *iwork, const int *liwork, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor ssygvd_$descriptor() {
        return ssygvd_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ssygvd_(const int *itype, const char *jobz, const char *uplo, const int *n, float *A, const int *lda, float *B, const int *ldb, float *W, float *work, const int *lwork, int *iwork, const int *liwork, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle ssygvd_$handle() {
        return ssygvd_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ssygvd_(const int *itype, const char *jobz, const char *uplo, const int *n, float *A, const int *lda, float *B, const int *ldb, float *W, float *work, const int *lwork, int *iwork, const int *liwork, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment ssygvd_$address() {
        return ssygvd_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ssygvd_(const int *itype, const char *jobz, const char *uplo, const int *n, float *A, const int *lda, float *B, const int *ldb, float *W, float *work, const int *lwork, int *iwork, const int *liwork, int *info, size_t, size_t)
     * }
     */
    public static void ssygvd_(MemorySegment itype, MemorySegment jobz, MemorySegment uplo, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment B, MemorySegment ldb, MemorySegment W, MemorySegment work, MemorySegment lwork, MemorySegment iwork, MemorySegment liwork, MemorySegment info, long x14, long x15) {
        var mh$ = ssygvd_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ssygvd_", itype, jobz, uplo, n, A, lda, B, ldb, W, work, lwork, iwork, liwork, info, x14, x15);
            }
            mh$.invokeExact(itype, jobz, uplo, n, A, lda, B, ldb, W, work, lwork, iwork, liwork, info, x14, x15);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dsygvx_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("dsygvx_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dsygvx_(const int *itype, const char *jobz, const char *range, const char *uplo, const int *n, double *A, const int *lda, double *B, const int *ldb, const double *vl, const double *vu, const int *il, const int *iu, const double *abstol, int *m, double *W, double *Z, const int *ldz, double *work, const int *lwork, int *iwork, int *IFAIL, int *info, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor dsygvx_$descriptor() {
        return dsygvx_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dsygvx_(const int *itype, const char *jobz, const char *range, const char *uplo, const int *n, double *A, const int *lda, double *B, const int *ldb, const double *vl, const double *vu, const int *il, const int *iu, const double *abstol, int *m, double *W, double *Z, const int *ldz, double *work, const int *lwork, int *iwork, int *IFAIL, int *info, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle dsygvx_$handle() {
        return dsygvx_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dsygvx_(const int *itype, const char *jobz, const char *range, const char *uplo, const int *n, double *A, const int *lda, double *B, const int *ldb, const double *vl, const double *vu, const int *il, const int *iu, const double *abstol, int *m, double *W, double *Z, const int *ldz, double *work, const int *lwork, int *iwork, int *IFAIL, int *info, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment dsygvx_$address() {
        return dsygvx_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dsygvx_(const int *itype, const char *jobz, const char *range, const char *uplo, const int *n, double *A, const int *lda, double *B, const int *ldb, const double *vl, const double *vu, const int *il, const int *iu, const double *abstol, int *m, double *W, double *Z, const int *ldz, double *work, const int *lwork, int *iwork, int *IFAIL, int *info, size_t, size_t, size_t)
     * }
     */
    public static void dsygvx_(MemorySegment itype, MemorySegment jobz, MemorySegment range, MemorySegment uplo, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment B, MemorySegment ldb, MemorySegment vl, MemorySegment vu, MemorySegment il, MemorySegment iu, MemorySegment abstol, MemorySegment m, MemorySegment W, MemorySegment Z, MemorySegment ldz, MemorySegment work, MemorySegment lwork, MemorySegment iwork, MemorySegment IFAIL, MemorySegment info, long x23, long x24, long x25) {
        var mh$ = dsygvx_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dsygvx_", itype, jobz, range, uplo, n, A, lda, B, ldb, vl, vu, il, iu, abstol, m, W, Z, ldz, work, lwork, iwork, IFAIL, info, x23, x24, x25);
            }
            mh$.invokeExact(itype, jobz, range, uplo, n, A, lda, B, ldb, vl, vu, il, iu, abstol, m, W, Z, ldz, work, lwork, iwork, IFAIL, info, x23, x24, x25);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ssygvx_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("ssygvx_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ssygvx_(const int *itype, const char *jobz, const char *range, const char *uplo, const int *n, float *A, const int *lda, float *B, const int *ldb, const float *vl, const float *vu, const int *il, const int *iu, const float *abstol, int *m, float *W, float *Z, const int *ldz, float *work, const int *lwork, int *iwork, int *IFAIL, int *info, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor ssygvx_$descriptor() {
        return ssygvx_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ssygvx_(const int *itype, const char *jobz, const char *range, const char *uplo, const int *n, float *A, const int *lda, float *B, const int *ldb, const float *vl, const float *vu, const int *il, const int *iu, const float *abstol, int *m, float *W, float *Z, const int *ldz, float *work, const int *lwork, int *iwork, int *IFAIL, int *info, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle ssygvx_$handle() {
        return ssygvx_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ssygvx_(const int *itype, const char *jobz, const char *range, const char *uplo, const int *n, float *A, const int *lda, float *B, const int *ldb, const float *vl, const float *vu, const int *il, const int *iu, const float *abstol, int *m, float *W, float *Z, const int *ldz, float *work, const int *lwork, int *iwork, int *IFAIL, int *info, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment ssygvx_$address() {
        return ssygvx_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ssygvx_(const int *itype, const char *jobz, const char *range, const char *uplo, const int *n, float *A, const int *lda, float *B, const int *ldb, const float *vl, const float *vu, const int *il, const int *iu, const float *abstol, int *m, float *W, float *Z, const int *ldz, float *work, const int *lwork, int *iwork, int *IFAIL, int *info, size_t, size_t, size_t)
     * }
     */
    public static void ssygvx_(MemorySegment itype, MemorySegment jobz, MemorySegment range, MemorySegment uplo, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment B, MemorySegment ldb, MemorySegment vl, MemorySegment vu, MemorySegment il, MemorySegment iu, MemorySegment abstol, MemorySegment m, MemorySegment W, MemorySegment Z, MemorySegment ldz, MemorySegment work, MemorySegment lwork, MemorySegment iwork, MemorySegment IFAIL, MemorySegment info, long x23, long x24, long x25) {
        var mh$ = ssygvx_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ssygvx_", itype, jobz, range, uplo, n, A, lda, B, ldb, vl, vu, il, iu, abstol, m, W, Z, ldz, work, lwork, iwork, IFAIL, info, x23, x24, x25);
            }
            mh$.invokeExact(itype, jobz, range, uplo, n, A, lda, B, ldb, vl, vu, il, iu, abstol, m, W, Z, ldz, work, lwork, iwork, IFAIL, info, x23, x24, x25);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class csyr_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("csyr_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void csyr_(const char *uplo, const int *n, const _Complex float *alpha, const _Complex float *X, const int *incx, _Complex float *A, const int *lda, size_t)
     * }
     */
    public static FunctionDescriptor csyr_$descriptor() {
        return csyr_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void csyr_(const char *uplo, const int *n, const _Complex float *alpha, const _Complex float *X, const int *incx, _Complex float *A, const int *lda, size_t)
     * }
     */
    public static MethodHandle csyr_$handle() {
        return csyr_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void csyr_(const char *uplo, const int *n, const _Complex float *alpha, const _Complex float *X, const int *incx, _Complex float *A, const int *lda, size_t)
     * }
     */
    public static MemorySegment csyr_$address() {
        return csyr_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void csyr_(const char *uplo, const int *n, const _Complex float *alpha, const _Complex float *X, const int *incx, _Complex float *A, const int *lda, size_t)
     * }
     */
    public static void csyr_(MemorySegment uplo, MemorySegment n, MemorySegment alpha, MemorySegment X, MemorySegment incx, MemorySegment A, MemorySegment lda, long x7) {
        var mh$ = csyr_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("csyr_", uplo, n, alpha, X, incx, A, lda, x7);
            }
            mh$.invokeExact(uplo, n, alpha, X, incx, A, lda, x7);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zsyr_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("zsyr_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zsyr_(const char *uplo, const int *n, const _Complex double *alpha, const _Complex double *X, const int *incx, _Complex double *A, const int *lda, size_t)
     * }
     */
    public static FunctionDescriptor zsyr_$descriptor() {
        return zsyr_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zsyr_(const char *uplo, const int *n, const _Complex double *alpha, const _Complex double *X, const int *incx, _Complex double *A, const int *lda, size_t)
     * }
     */
    public static MethodHandle zsyr_$handle() {
        return zsyr_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zsyr_(const char *uplo, const int *n, const _Complex double *alpha, const _Complex double *X, const int *incx, _Complex double *A, const int *lda, size_t)
     * }
     */
    public static MemorySegment zsyr_$address() {
        return zsyr_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zsyr_(const char *uplo, const int *n, const _Complex double *alpha, const _Complex double *X, const int *incx, _Complex double *A, const int *lda, size_t)
     * }
     */
    public static void zsyr_(MemorySegment uplo, MemorySegment n, MemorySegment alpha, MemorySegment X, MemorySegment incx, MemorySegment A, MemorySegment lda, long x7) {
        var mh$ = zsyr_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zsyr_", uplo, n, alpha, X, incx, A, lda, x7);
            }
            mh$.invokeExact(uplo, n, alpha, X, incx, A, lda, x7);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class csyrfs_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("csyrfs_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void csyrfs_(const char *uplo, const int *n, const int *nrhs, const _Complex float *A, const int *lda, const _Complex float *AF, const int *ldaf, const int *ipiv, const _Complex float *B, const int *ldb, _Complex float *X, const int *ldx, float *ferr, float *berr, _Complex float *work, float *rwork, int *info, size_t)
     * }
     */
    public static FunctionDescriptor csyrfs_$descriptor() {
        return csyrfs_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void csyrfs_(const char *uplo, const int *n, const int *nrhs, const _Complex float *A, const int *lda, const _Complex float *AF, const int *ldaf, const int *ipiv, const _Complex float *B, const int *ldb, _Complex float *X, const int *ldx, float *ferr, float *berr, _Complex float *work, float *rwork, int *info, size_t)
     * }
     */
    public static MethodHandle csyrfs_$handle() {
        return csyrfs_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void csyrfs_(const char *uplo, const int *n, const int *nrhs, const _Complex float *A, const int *lda, const _Complex float *AF, const int *ldaf, const int *ipiv, const _Complex float *B, const int *ldb, _Complex float *X, const int *ldx, float *ferr, float *berr, _Complex float *work, float *rwork, int *info, size_t)
     * }
     */
    public static MemorySegment csyrfs_$address() {
        return csyrfs_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void csyrfs_(const char *uplo, const int *n, const int *nrhs, const _Complex float *A, const int *lda, const _Complex float *AF, const int *ldaf, const int *ipiv, const _Complex float *B, const int *ldb, _Complex float *X, const int *ldx, float *ferr, float *berr, _Complex float *work, float *rwork, int *info, size_t)
     * }
     */
    public static void csyrfs_(MemorySegment uplo, MemorySegment n, MemorySegment nrhs, MemorySegment A, MemorySegment lda, MemorySegment AF, MemorySegment ldaf, MemorySegment ipiv, MemorySegment B, MemorySegment ldb, MemorySegment X, MemorySegment ldx, MemorySegment ferr, MemorySegment berr, MemorySegment work, MemorySegment rwork, MemorySegment info, long x17) {
        var mh$ = csyrfs_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("csyrfs_", uplo, n, nrhs, A, lda, AF, ldaf, ipiv, B, ldb, X, ldx, ferr, berr, work, rwork, info, x17);
            }
            mh$.invokeExact(uplo, n, nrhs, A, lda, AF, ldaf, ipiv, B, ldb, X, ldx, ferr, berr, work, rwork, info, x17);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dsyrfs_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("dsyrfs_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dsyrfs_(const char *uplo, const int *n, const int *nrhs, const double *A, const int *lda, const double *AF, const int *ldaf, const int *ipiv, const double *B, const int *ldb, double *X, const int *ldx, double *ferr, double *berr, double *work, int *iwork, int *info, size_t)
     * }
     */
    public static FunctionDescriptor dsyrfs_$descriptor() {
        return dsyrfs_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dsyrfs_(const char *uplo, const int *n, const int *nrhs, const double *A, const int *lda, const double *AF, const int *ldaf, const int *ipiv, const double *B, const int *ldb, double *X, const int *ldx, double *ferr, double *berr, double *work, int *iwork, int *info, size_t)
     * }
     */
    public static MethodHandle dsyrfs_$handle() {
        return dsyrfs_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dsyrfs_(const char *uplo, const int *n, const int *nrhs, const double *A, const int *lda, const double *AF, const int *ldaf, const int *ipiv, const double *B, const int *ldb, double *X, const int *ldx, double *ferr, double *berr, double *work, int *iwork, int *info, size_t)
     * }
     */
    public static MemorySegment dsyrfs_$address() {
        return dsyrfs_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dsyrfs_(const char *uplo, const int *n, const int *nrhs, const double *A, const int *lda, const double *AF, const int *ldaf, const int *ipiv, const double *B, const int *ldb, double *X, const int *ldx, double *ferr, double *berr, double *work, int *iwork, int *info, size_t)
     * }
     */
    public static void dsyrfs_(MemorySegment uplo, MemorySegment n, MemorySegment nrhs, MemorySegment A, MemorySegment lda, MemorySegment AF, MemorySegment ldaf, MemorySegment ipiv, MemorySegment B, MemorySegment ldb, MemorySegment X, MemorySegment ldx, MemorySegment ferr, MemorySegment berr, MemorySegment work, MemorySegment iwork, MemorySegment info, long x17) {
        var mh$ = dsyrfs_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dsyrfs_", uplo, n, nrhs, A, lda, AF, ldaf, ipiv, B, ldb, X, ldx, ferr, berr, work, iwork, info, x17);
            }
            mh$.invokeExact(uplo, n, nrhs, A, lda, AF, ldaf, ipiv, B, ldb, X, ldx, ferr, berr, work, iwork, info, x17);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ssyrfs_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("ssyrfs_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ssyrfs_(const char *uplo, const int *n, const int *nrhs, const float *A, const int *lda, const float *AF, const int *ldaf, const int *ipiv, const float *B, const int *ldb, float *X, const int *ldx, float *ferr, float *berr, float *work, int *iwork, int *info, size_t)
     * }
     */
    public static FunctionDescriptor ssyrfs_$descriptor() {
        return ssyrfs_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ssyrfs_(const char *uplo, const int *n, const int *nrhs, const float *A, const int *lda, const float *AF, const int *ldaf, const int *ipiv, const float *B, const int *ldb, float *X, const int *ldx, float *ferr, float *berr, float *work, int *iwork, int *info, size_t)
     * }
     */
    public static MethodHandle ssyrfs_$handle() {
        return ssyrfs_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ssyrfs_(const char *uplo, const int *n, const int *nrhs, const float *A, const int *lda, const float *AF, const int *ldaf, const int *ipiv, const float *B, const int *ldb, float *X, const int *ldx, float *ferr, float *berr, float *work, int *iwork, int *info, size_t)
     * }
     */
    public static MemorySegment ssyrfs_$address() {
        return ssyrfs_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ssyrfs_(const char *uplo, const int *n, const int *nrhs, const float *A, const int *lda, const float *AF, const int *ldaf, const int *ipiv, const float *B, const int *ldb, float *X, const int *ldx, float *ferr, float *berr, float *work, int *iwork, int *info, size_t)
     * }
     */
    public static void ssyrfs_(MemorySegment uplo, MemorySegment n, MemorySegment nrhs, MemorySegment A, MemorySegment lda, MemorySegment AF, MemorySegment ldaf, MemorySegment ipiv, MemorySegment B, MemorySegment ldb, MemorySegment X, MemorySegment ldx, MemorySegment ferr, MemorySegment berr, MemorySegment work, MemorySegment iwork, MemorySegment info, long x17) {
        var mh$ = ssyrfs_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ssyrfs_", uplo, n, nrhs, A, lda, AF, ldaf, ipiv, B, ldb, X, ldx, ferr, berr, work, iwork, info, x17);
            }
            mh$.invokeExact(uplo, n, nrhs, A, lda, AF, ldaf, ipiv, B, ldb, X, ldx, ferr, berr, work, iwork, info, x17);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zsyrfs_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("zsyrfs_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zsyrfs_(const char *uplo, const int *n, const int *nrhs, const _Complex double *A, const int *lda, const _Complex double *AF, const int *ldaf, const int *ipiv, const _Complex double *B, const int *ldb, _Complex double *X, const int *ldx, double *ferr, double *berr, _Complex double *work, double *rwork, int *info, size_t)
     * }
     */
    public static FunctionDescriptor zsyrfs_$descriptor() {
        return zsyrfs_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zsyrfs_(const char *uplo, const int *n, const int *nrhs, const _Complex double *A, const int *lda, const _Complex double *AF, const int *ldaf, const int *ipiv, const _Complex double *B, const int *ldb, _Complex double *X, const int *ldx, double *ferr, double *berr, _Complex double *work, double *rwork, int *info, size_t)
     * }
     */
    public static MethodHandle zsyrfs_$handle() {
        return zsyrfs_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zsyrfs_(const char *uplo, const int *n, const int *nrhs, const _Complex double *A, const int *lda, const _Complex double *AF, const int *ldaf, const int *ipiv, const _Complex double *B, const int *ldb, _Complex double *X, const int *ldx, double *ferr, double *berr, _Complex double *work, double *rwork, int *info, size_t)
     * }
     */
    public static MemorySegment zsyrfs_$address() {
        return zsyrfs_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zsyrfs_(const char *uplo, const int *n, const int *nrhs, const _Complex double *A, const int *lda, const _Complex double *AF, const int *ldaf, const int *ipiv, const _Complex double *B, const int *ldb, _Complex double *X, const int *ldx, double *ferr, double *berr, _Complex double *work, double *rwork, int *info, size_t)
     * }
     */
    public static void zsyrfs_(MemorySegment uplo, MemorySegment n, MemorySegment nrhs, MemorySegment A, MemorySegment lda, MemorySegment AF, MemorySegment ldaf, MemorySegment ipiv, MemorySegment B, MemorySegment ldb, MemorySegment X, MemorySegment ldx, MemorySegment ferr, MemorySegment berr, MemorySegment work, MemorySegment rwork, MemorySegment info, long x17) {
        var mh$ = zsyrfs_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zsyrfs_", uplo, n, nrhs, A, lda, AF, ldaf, ipiv, B, ldb, X, ldx, ferr, berr, work, rwork, info, x17);
            }
            mh$.invokeExact(uplo, n, nrhs, A, lda, AF, ldaf, ipiv, B, ldb, X, ldx, ferr, berr, work, rwork, info, x17);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class csyrfsx_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("csyrfsx_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void csyrfsx_(const char *uplo, const char *equed, const int *n, const int *nrhs, const _Complex float *A, const int *lda, const _Complex float *AF, const int *ldaf, const int *ipiv, const float *S, const _Complex float *B, const int *ldb, _Complex float *X, const int *ldx, float *rcond, float *berr, const int *n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, const int *nparams, float *params, _Complex float *work, float *rwork, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor csyrfsx_$descriptor() {
        return csyrfsx_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void csyrfsx_(const char *uplo, const char *equed, const int *n, const int *nrhs, const _Complex float *A, const int *lda, const _Complex float *AF, const int *ldaf, const int *ipiv, const float *S, const _Complex float *B, const int *ldb, _Complex float *X, const int *ldx, float *rcond, float *berr, const int *n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, const int *nparams, float *params, _Complex float *work, float *rwork, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle csyrfsx_$handle() {
        return csyrfsx_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void csyrfsx_(const char *uplo, const char *equed, const int *n, const int *nrhs, const _Complex float *A, const int *lda, const _Complex float *AF, const int *ldaf, const int *ipiv, const float *S, const _Complex float *B, const int *ldb, _Complex float *X, const int *ldx, float *rcond, float *berr, const int *n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, const int *nparams, float *params, _Complex float *work, float *rwork, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment csyrfsx_$address() {
        return csyrfsx_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void csyrfsx_(const char *uplo, const char *equed, const int *n, const int *nrhs, const _Complex float *A, const int *lda, const _Complex float *AF, const int *ldaf, const int *ipiv, const float *S, const _Complex float *B, const int *ldb, _Complex float *X, const int *ldx, float *rcond, float *berr, const int *n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, const int *nparams, float *params, _Complex float *work, float *rwork, int *info, size_t, size_t)
     * }
     */
    public static void csyrfsx_(MemorySegment uplo, MemorySegment equed, MemorySegment n, MemorySegment nrhs, MemorySegment A, MemorySegment lda, MemorySegment AF, MemorySegment ldaf, MemorySegment ipiv, MemorySegment S, MemorySegment B, MemorySegment ldb, MemorySegment X, MemorySegment ldx, MemorySegment rcond, MemorySegment berr, MemorySegment n_err_bnds, MemorySegment err_bnds_norm, MemorySegment err_bnds_comp, MemorySegment nparams, MemorySegment params, MemorySegment work, MemorySegment rwork, MemorySegment info, long x24, long x25) {
        var mh$ = csyrfsx_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("csyrfsx_", uplo, equed, n, nrhs, A, lda, AF, ldaf, ipiv, S, B, ldb, X, ldx, rcond, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params, work, rwork, info, x24, x25);
            }
            mh$.invokeExact(uplo, equed, n, nrhs, A, lda, AF, ldaf, ipiv, S, B, ldb, X, ldx, rcond, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params, work, rwork, info, x24, x25);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dsyrfsx_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("dsyrfsx_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dsyrfsx_(const char *uplo, const char *equed, const int *n, const int *nrhs, const double *A, const int *lda, const double *AF, const int *ldaf, const int *ipiv, const double *S, const double *B, const int *ldb, double *X, const int *ldx, double *rcond, double *berr, const int *n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, const int *nparams, double *params, double *work, int *iwork, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor dsyrfsx_$descriptor() {
        return dsyrfsx_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dsyrfsx_(const char *uplo, const char *equed, const int *n, const int *nrhs, const double *A, const int *lda, const double *AF, const int *ldaf, const int *ipiv, const double *S, const double *B, const int *ldb, double *X, const int *ldx, double *rcond, double *berr, const int *n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, const int *nparams, double *params, double *work, int *iwork, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle dsyrfsx_$handle() {
        return dsyrfsx_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dsyrfsx_(const char *uplo, const char *equed, const int *n, const int *nrhs, const double *A, const int *lda, const double *AF, const int *ldaf, const int *ipiv, const double *S, const double *B, const int *ldb, double *X, const int *ldx, double *rcond, double *berr, const int *n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, const int *nparams, double *params, double *work, int *iwork, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment dsyrfsx_$address() {
        return dsyrfsx_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dsyrfsx_(const char *uplo, const char *equed, const int *n, const int *nrhs, const double *A, const int *lda, const double *AF, const int *ldaf, const int *ipiv, const double *S, const double *B, const int *ldb, double *X, const int *ldx, double *rcond, double *berr, const int *n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, const int *nparams, double *params, double *work, int *iwork, int *info, size_t, size_t)
     * }
     */
    public static void dsyrfsx_(MemorySegment uplo, MemorySegment equed, MemorySegment n, MemorySegment nrhs, MemorySegment A, MemorySegment lda, MemorySegment AF, MemorySegment ldaf, MemorySegment ipiv, MemorySegment S, MemorySegment B, MemorySegment ldb, MemorySegment X, MemorySegment ldx, MemorySegment rcond, MemorySegment berr, MemorySegment n_err_bnds, MemorySegment err_bnds_norm, MemorySegment err_bnds_comp, MemorySegment nparams, MemorySegment params, MemorySegment work, MemorySegment iwork, MemorySegment info, long x24, long x25) {
        var mh$ = dsyrfsx_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dsyrfsx_", uplo, equed, n, nrhs, A, lda, AF, ldaf, ipiv, S, B, ldb, X, ldx, rcond, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params, work, iwork, info, x24, x25);
            }
            mh$.invokeExact(uplo, equed, n, nrhs, A, lda, AF, ldaf, ipiv, S, B, ldb, X, ldx, rcond, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params, work, iwork, info, x24, x25);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ssyrfsx_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("ssyrfsx_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ssyrfsx_(const char *uplo, const char *equed, const int *n, const int *nrhs, const float *A, const int *lda, const float *AF, const int *ldaf, const int *ipiv, const float *S, const float *B, const int *ldb, float *X, const int *ldx, float *rcond, float *berr, const int *n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, const int *nparams, float *params, float *work, int *iwork, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor ssyrfsx_$descriptor() {
        return ssyrfsx_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ssyrfsx_(const char *uplo, const char *equed, const int *n, const int *nrhs, const float *A, const int *lda, const float *AF, const int *ldaf, const int *ipiv, const float *S, const float *B, const int *ldb, float *X, const int *ldx, float *rcond, float *berr, const int *n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, const int *nparams, float *params, float *work, int *iwork, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle ssyrfsx_$handle() {
        return ssyrfsx_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ssyrfsx_(const char *uplo, const char *equed, const int *n, const int *nrhs, const float *A, const int *lda, const float *AF, const int *ldaf, const int *ipiv, const float *S, const float *B, const int *ldb, float *X, const int *ldx, float *rcond, float *berr, const int *n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, const int *nparams, float *params, float *work, int *iwork, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment ssyrfsx_$address() {
        return ssyrfsx_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ssyrfsx_(const char *uplo, const char *equed, const int *n, const int *nrhs, const float *A, const int *lda, const float *AF, const int *ldaf, const int *ipiv, const float *S, const float *B, const int *ldb, float *X, const int *ldx, float *rcond, float *berr, const int *n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, const int *nparams, float *params, float *work, int *iwork, int *info, size_t, size_t)
     * }
     */
    public static void ssyrfsx_(MemorySegment uplo, MemorySegment equed, MemorySegment n, MemorySegment nrhs, MemorySegment A, MemorySegment lda, MemorySegment AF, MemorySegment ldaf, MemorySegment ipiv, MemorySegment S, MemorySegment B, MemorySegment ldb, MemorySegment X, MemorySegment ldx, MemorySegment rcond, MemorySegment berr, MemorySegment n_err_bnds, MemorySegment err_bnds_norm, MemorySegment err_bnds_comp, MemorySegment nparams, MemorySegment params, MemorySegment work, MemorySegment iwork, MemorySegment info, long x24, long x25) {
        var mh$ = ssyrfsx_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ssyrfsx_", uplo, equed, n, nrhs, A, lda, AF, ldaf, ipiv, S, B, ldb, X, ldx, rcond, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params, work, iwork, info, x24, x25);
            }
            mh$.invokeExact(uplo, equed, n, nrhs, A, lda, AF, ldaf, ipiv, S, B, ldb, X, ldx, rcond, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params, work, iwork, info, x24, x25);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zsyrfsx_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("zsyrfsx_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zsyrfsx_(const char *uplo, const char *equed, const int *n, const int *nrhs, const _Complex double *A, const int *lda, const _Complex double *AF, const int *ldaf, const int *ipiv, const double *S, const _Complex double *B, const int *ldb, _Complex double *X, const int *ldx, double *rcond, double *berr, const int *n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, const int *nparams, double *params, _Complex double *work, double *rwork, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor zsyrfsx_$descriptor() {
        return zsyrfsx_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zsyrfsx_(const char *uplo, const char *equed, const int *n, const int *nrhs, const _Complex double *A, const int *lda, const _Complex double *AF, const int *ldaf, const int *ipiv, const double *S, const _Complex double *B, const int *ldb, _Complex double *X, const int *ldx, double *rcond, double *berr, const int *n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, const int *nparams, double *params, _Complex double *work, double *rwork, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle zsyrfsx_$handle() {
        return zsyrfsx_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zsyrfsx_(const char *uplo, const char *equed, const int *n, const int *nrhs, const _Complex double *A, const int *lda, const _Complex double *AF, const int *ldaf, const int *ipiv, const double *S, const _Complex double *B, const int *ldb, _Complex double *X, const int *ldx, double *rcond, double *berr, const int *n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, const int *nparams, double *params, _Complex double *work, double *rwork, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment zsyrfsx_$address() {
        return zsyrfsx_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zsyrfsx_(const char *uplo, const char *equed, const int *n, const int *nrhs, const _Complex double *A, const int *lda, const _Complex double *AF, const int *ldaf, const int *ipiv, const double *S, const _Complex double *B, const int *ldb, _Complex double *X, const int *ldx, double *rcond, double *berr, const int *n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, const int *nparams, double *params, _Complex double *work, double *rwork, int *info, size_t, size_t)
     * }
     */
    public static void zsyrfsx_(MemorySegment uplo, MemorySegment equed, MemorySegment n, MemorySegment nrhs, MemorySegment A, MemorySegment lda, MemorySegment AF, MemorySegment ldaf, MemorySegment ipiv, MemorySegment S, MemorySegment B, MemorySegment ldb, MemorySegment X, MemorySegment ldx, MemorySegment rcond, MemorySegment berr, MemorySegment n_err_bnds, MemorySegment err_bnds_norm, MemorySegment err_bnds_comp, MemorySegment nparams, MemorySegment params, MemorySegment work, MemorySegment rwork, MemorySegment info, long x24, long x25) {
        var mh$ = zsyrfsx_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zsyrfsx_", uplo, equed, n, nrhs, A, lda, AF, ldaf, ipiv, S, B, ldb, X, ldx, rcond, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params, work, rwork, info, x24, x25);
            }
            mh$.invokeExact(uplo, equed, n, nrhs, A, lda, AF, ldaf, ipiv, S, B, ldb, X, ldx, rcond, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params, work, rwork, info, x24, x25);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class csysv_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("csysv_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void csysv_(const char *uplo, const int *n, const int *nrhs, _Complex float *A, const int *lda, int *ipiv, _Complex float *B, const int *ldb, _Complex float *work, const int *lwork, int *info, size_t)
     * }
     */
    public static FunctionDescriptor csysv_$descriptor() {
        return csysv_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void csysv_(const char *uplo, const int *n, const int *nrhs, _Complex float *A, const int *lda, int *ipiv, _Complex float *B, const int *ldb, _Complex float *work, const int *lwork, int *info, size_t)
     * }
     */
    public static MethodHandle csysv_$handle() {
        return csysv_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void csysv_(const char *uplo, const int *n, const int *nrhs, _Complex float *A, const int *lda, int *ipiv, _Complex float *B, const int *ldb, _Complex float *work, const int *lwork, int *info, size_t)
     * }
     */
    public static MemorySegment csysv_$address() {
        return csysv_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void csysv_(const char *uplo, const int *n, const int *nrhs, _Complex float *A, const int *lda, int *ipiv, _Complex float *B, const int *ldb, _Complex float *work, const int *lwork, int *info, size_t)
     * }
     */
    public static void csysv_(MemorySegment uplo, MemorySegment n, MemorySegment nrhs, MemorySegment A, MemorySegment lda, MemorySegment ipiv, MemorySegment B, MemorySegment ldb, MemorySegment work, MemorySegment lwork, MemorySegment info, long x11) {
        var mh$ = csysv_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("csysv_", uplo, n, nrhs, A, lda, ipiv, B, ldb, work, lwork, info, x11);
            }
            mh$.invokeExact(uplo, n, nrhs, A, lda, ipiv, B, ldb, work, lwork, info, x11);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dsysv_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("dsysv_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dsysv_(const char *uplo, const int *n, const int *nrhs, double *A, const int *lda, int *ipiv, double *B, const int *ldb, double *work, const int *lwork, int *info, size_t)
     * }
     */
    public static FunctionDescriptor dsysv_$descriptor() {
        return dsysv_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dsysv_(const char *uplo, const int *n, const int *nrhs, double *A, const int *lda, int *ipiv, double *B, const int *ldb, double *work, const int *lwork, int *info, size_t)
     * }
     */
    public static MethodHandle dsysv_$handle() {
        return dsysv_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dsysv_(const char *uplo, const int *n, const int *nrhs, double *A, const int *lda, int *ipiv, double *B, const int *ldb, double *work, const int *lwork, int *info, size_t)
     * }
     */
    public static MemorySegment dsysv_$address() {
        return dsysv_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dsysv_(const char *uplo, const int *n, const int *nrhs, double *A, const int *lda, int *ipiv, double *B, const int *ldb, double *work, const int *lwork, int *info, size_t)
     * }
     */
    public static void dsysv_(MemorySegment uplo, MemorySegment n, MemorySegment nrhs, MemorySegment A, MemorySegment lda, MemorySegment ipiv, MemorySegment B, MemorySegment ldb, MemorySegment work, MemorySegment lwork, MemorySegment info, long x11) {
        var mh$ = dsysv_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dsysv_", uplo, n, nrhs, A, lda, ipiv, B, ldb, work, lwork, info, x11);
            }
            mh$.invokeExact(uplo, n, nrhs, A, lda, ipiv, B, ldb, work, lwork, info, x11);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ssysv_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("ssysv_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ssysv_(const char *uplo, const int *n, const int *nrhs, float *A, const int *lda, int *ipiv, float *B, const int *ldb, float *work, const int *lwork, int *info, size_t)
     * }
     */
    public static FunctionDescriptor ssysv_$descriptor() {
        return ssysv_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ssysv_(const char *uplo, const int *n, const int *nrhs, float *A, const int *lda, int *ipiv, float *B, const int *ldb, float *work, const int *lwork, int *info, size_t)
     * }
     */
    public static MethodHandle ssysv_$handle() {
        return ssysv_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ssysv_(const char *uplo, const int *n, const int *nrhs, float *A, const int *lda, int *ipiv, float *B, const int *ldb, float *work, const int *lwork, int *info, size_t)
     * }
     */
    public static MemorySegment ssysv_$address() {
        return ssysv_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ssysv_(const char *uplo, const int *n, const int *nrhs, float *A, const int *lda, int *ipiv, float *B, const int *ldb, float *work, const int *lwork, int *info, size_t)
     * }
     */
    public static void ssysv_(MemorySegment uplo, MemorySegment n, MemorySegment nrhs, MemorySegment A, MemorySegment lda, MemorySegment ipiv, MemorySegment B, MemorySegment ldb, MemorySegment work, MemorySegment lwork, MemorySegment info, long x11) {
        var mh$ = ssysv_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ssysv_", uplo, n, nrhs, A, lda, ipiv, B, ldb, work, lwork, info, x11);
            }
            mh$.invokeExact(uplo, n, nrhs, A, lda, ipiv, B, ldb, work, lwork, info, x11);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zsysv_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("zsysv_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zsysv_(const char *uplo, const int *n, const int *nrhs, _Complex double *A, const int *lda, int *ipiv, _Complex double *B, const int *ldb, _Complex double *work, const int *lwork, int *info, size_t)
     * }
     */
    public static FunctionDescriptor zsysv_$descriptor() {
        return zsysv_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zsysv_(const char *uplo, const int *n, const int *nrhs, _Complex double *A, const int *lda, int *ipiv, _Complex double *B, const int *ldb, _Complex double *work, const int *lwork, int *info, size_t)
     * }
     */
    public static MethodHandle zsysv_$handle() {
        return zsysv_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zsysv_(const char *uplo, const int *n, const int *nrhs, _Complex double *A, const int *lda, int *ipiv, _Complex double *B, const int *ldb, _Complex double *work, const int *lwork, int *info, size_t)
     * }
     */
    public static MemorySegment zsysv_$address() {
        return zsysv_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zsysv_(const char *uplo, const int *n, const int *nrhs, _Complex double *A, const int *lda, int *ipiv, _Complex double *B, const int *ldb, _Complex double *work, const int *lwork, int *info, size_t)
     * }
     */
    public static void zsysv_(MemorySegment uplo, MemorySegment n, MemorySegment nrhs, MemorySegment A, MemorySegment lda, MemorySegment ipiv, MemorySegment B, MemorySegment ldb, MemorySegment work, MemorySegment lwork, MemorySegment info, long x11) {
        var mh$ = zsysv_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zsysv_", uplo, n, nrhs, A, lda, ipiv, B, ldb, work, lwork, info, x11);
            }
            mh$.invokeExact(uplo, n, nrhs, A, lda, ipiv, B, ldb, work, lwork, info, x11);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class csysv_aa_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("csysv_aa_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void csysv_aa_(const char *uplo, const int *n, const int *nrhs, _Complex float *A, const int *lda, int *ipiv, _Complex float *B, const int *ldb, _Complex float *work, const int *lwork, int *info, size_t)
     * }
     */
    public static FunctionDescriptor csysv_aa_$descriptor() {
        return csysv_aa_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void csysv_aa_(const char *uplo, const int *n, const int *nrhs, _Complex float *A, const int *lda, int *ipiv, _Complex float *B, const int *ldb, _Complex float *work, const int *lwork, int *info, size_t)
     * }
     */
    public static MethodHandle csysv_aa_$handle() {
        return csysv_aa_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void csysv_aa_(const char *uplo, const int *n, const int *nrhs, _Complex float *A, const int *lda, int *ipiv, _Complex float *B, const int *ldb, _Complex float *work, const int *lwork, int *info, size_t)
     * }
     */
    public static MemorySegment csysv_aa_$address() {
        return csysv_aa_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void csysv_aa_(const char *uplo, const int *n, const int *nrhs, _Complex float *A, const int *lda, int *ipiv, _Complex float *B, const int *ldb, _Complex float *work, const int *lwork, int *info, size_t)
     * }
     */
    public static void csysv_aa_(MemorySegment uplo, MemorySegment n, MemorySegment nrhs, MemorySegment A, MemorySegment lda, MemorySegment ipiv, MemorySegment B, MemorySegment ldb, MemorySegment work, MemorySegment lwork, MemorySegment info, long x11) {
        var mh$ = csysv_aa_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("csysv_aa_", uplo, n, nrhs, A, lda, ipiv, B, ldb, work, lwork, info, x11);
            }
            mh$.invokeExact(uplo, n, nrhs, A, lda, ipiv, B, ldb, work, lwork, info, x11);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dsysv_aa_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("dsysv_aa_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dsysv_aa_(const char *uplo, const int *n, const int *nrhs, double *A, const int *lda, int *ipiv, double *B, const int *ldb, double *work, const int *lwork, int *info, size_t)
     * }
     */
    public static FunctionDescriptor dsysv_aa_$descriptor() {
        return dsysv_aa_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dsysv_aa_(const char *uplo, const int *n, const int *nrhs, double *A, const int *lda, int *ipiv, double *B, const int *ldb, double *work, const int *lwork, int *info, size_t)
     * }
     */
    public static MethodHandle dsysv_aa_$handle() {
        return dsysv_aa_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dsysv_aa_(const char *uplo, const int *n, const int *nrhs, double *A, const int *lda, int *ipiv, double *B, const int *ldb, double *work, const int *lwork, int *info, size_t)
     * }
     */
    public static MemorySegment dsysv_aa_$address() {
        return dsysv_aa_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dsysv_aa_(const char *uplo, const int *n, const int *nrhs, double *A, const int *lda, int *ipiv, double *B, const int *ldb, double *work, const int *lwork, int *info, size_t)
     * }
     */
    public static void dsysv_aa_(MemorySegment uplo, MemorySegment n, MemorySegment nrhs, MemorySegment A, MemorySegment lda, MemorySegment ipiv, MemorySegment B, MemorySegment ldb, MemorySegment work, MemorySegment lwork, MemorySegment info, long x11) {
        var mh$ = dsysv_aa_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dsysv_aa_", uplo, n, nrhs, A, lda, ipiv, B, ldb, work, lwork, info, x11);
            }
            mh$.invokeExact(uplo, n, nrhs, A, lda, ipiv, B, ldb, work, lwork, info, x11);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ssysv_aa_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("ssysv_aa_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ssysv_aa_(const char *uplo, const int *n, const int *nrhs, float *A, const int *lda, int *ipiv, float *B, const int *ldb, float *work, const int *lwork, int *info, size_t)
     * }
     */
    public static FunctionDescriptor ssysv_aa_$descriptor() {
        return ssysv_aa_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ssysv_aa_(const char *uplo, const int *n, const int *nrhs, float *A, const int *lda, int *ipiv, float *B, const int *ldb, float *work, const int *lwork, int *info, size_t)
     * }
     */
    public static MethodHandle ssysv_aa_$handle() {
        return ssysv_aa_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ssysv_aa_(const char *uplo, const int *n, const int *nrhs, float *A, const int *lda, int *ipiv, float *B, const int *ldb, float *work, const int *lwork, int *info, size_t)
     * }
     */
    public static MemorySegment ssysv_aa_$address() {
        return ssysv_aa_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ssysv_aa_(const char *uplo, const int *n, const int *nrhs, float *A, const int *lda, int *ipiv, float *B, const int *ldb, float *work, const int *lwork, int *info, size_t)
     * }
     */
    public static void ssysv_aa_(MemorySegment uplo, MemorySegment n, MemorySegment nrhs, MemorySegment A, MemorySegment lda, MemorySegment ipiv, MemorySegment B, MemorySegment ldb, MemorySegment work, MemorySegment lwork, MemorySegment info, long x11) {
        var mh$ = ssysv_aa_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ssysv_aa_", uplo, n, nrhs, A, lda, ipiv, B, ldb, work, lwork, info, x11);
            }
            mh$.invokeExact(uplo, n, nrhs, A, lda, ipiv, B, ldb, work, lwork, info, x11);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zsysv_aa_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("zsysv_aa_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zsysv_aa_(const char *uplo, const int *n, const int *nrhs, _Complex double *A, const int *lda, int *ipiv, _Complex double *B, const int *ldb, _Complex double *work, const int *lwork, int *info, size_t)
     * }
     */
    public static FunctionDescriptor zsysv_aa_$descriptor() {
        return zsysv_aa_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zsysv_aa_(const char *uplo, const int *n, const int *nrhs, _Complex double *A, const int *lda, int *ipiv, _Complex double *B, const int *ldb, _Complex double *work, const int *lwork, int *info, size_t)
     * }
     */
    public static MethodHandle zsysv_aa_$handle() {
        return zsysv_aa_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zsysv_aa_(const char *uplo, const int *n, const int *nrhs, _Complex double *A, const int *lda, int *ipiv, _Complex double *B, const int *ldb, _Complex double *work, const int *lwork, int *info, size_t)
     * }
     */
    public static MemorySegment zsysv_aa_$address() {
        return zsysv_aa_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zsysv_aa_(const char *uplo, const int *n, const int *nrhs, _Complex double *A, const int *lda, int *ipiv, _Complex double *B, const int *ldb, _Complex double *work, const int *lwork, int *info, size_t)
     * }
     */
    public static void zsysv_aa_(MemorySegment uplo, MemorySegment n, MemorySegment nrhs, MemorySegment A, MemorySegment lda, MemorySegment ipiv, MemorySegment B, MemorySegment ldb, MemorySegment work, MemorySegment lwork, MemorySegment info, long x11) {
        var mh$ = zsysv_aa_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zsysv_aa_", uplo, n, nrhs, A, lda, ipiv, B, ldb, work, lwork, info, x11);
            }
            mh$.invokeExact(uplo, n, nrhs, A, lda, ipiv, B, ldb, work, lwork, info, x11);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class csysv_aa_2stage_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("csysv_aa_2stage_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void csysv_aa_2stage_(const char *uplo, const int *n, const int *nrhs, _Complex float *A, const int *lda, _Complex float *TB, const int *ltb, int *ipiv, int *ipiv2, _Complex float *B, const int *ldb, _Complex float *work, const int *lwork, int *info, size_t)
     * }
     */
    public static FunctionDescriptor csysv_aa_2stage_$descriptor() {
        return csysv_aa_2stage_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void csysv_aa_2stage_(const char *uplo, const int *n, const int *nrhs, _Complex float *A, const int *lda, _Complex float *TB, const int *ltb, int *ipiv, int *ipiv2, _Complex float *B, const int *ldb, _Complex float *work, const int *lwork, int *info, size_t)
     * }
     */
    public static MethodHandle csysv_aa_2stage_$handle() {
        return csysv_aa_2stage_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void csysv_aa_2stage_(const char *uplo, const int *n, const int *nrhs, _Complex float *A, const int *lda, _Complex float *TB, const int *ltb, int *ipiv, int *ipiv2, _Complex float *B, const int *ldb, _Complex float *work, const int *lwork, int *info, size_t)
     * }
     */
    public static MemorySegment csysv_aa_2stage_$address() {
        return csysv_aa_2stage_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void csysv_aa_2stage_(const char *uplo, const int *n, const int *nrhs, _Complex float *A, const int *lda, _Complex float *TB, const int *ltb, int *ipiv, int *ipiv2, _Complex float *B, const int *ldb, _Complex float *work, const int *lwork, int *info, size_t)
     * }
     */
    public static void csysv_aa_2stage_(MemorySegment uplo, MemorySegment n, MemorySegment nrhs, MemorySegment A, MemorySegment lda, MemorySegment TB, MemorySegment ltb, MemorySegment ipiv, MemorySegment ipiv2, MemorySegment B, MemorySegment ldb, MemorySegment work, MemorySegment lwork, MemorySegment info, long x14) {
        var mh$ = csysv_aa_2stage_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("csysv_aa_2stage_", uplo, n, nrhs, A, lda, TB, ltb, ipiv, ipiv2, B, ldb, work, lwork, info, x14);
            }
            mh$.invokeExact(uplo, n, nrhs, A, lda, TB, ltb, ipiv, ipiv2, B, ldb, work, lwork, info, x14);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dsysv_aa_2stage_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("dsysv_aa_2stage_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dsysv_aa_2stage_(const char *uplo, const int *n, const int *nrhs, double *A, const int *lda, double *TB, const int *ltb, int *ipiv, int *ipiv2, double *B, const int *ldb, double *work, const int *lwork, int *info, size_t)
     * }
     */
    public static FunctionDescriptor dsysv_aa_2stage_$descriptor() {
        return dsysv_aa_2stage_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dsysv_aa_2stage_(const char *uplo, const int *n, const int *nrhs, double *A, const int *lda, double *TB, const int *ltb, int *ipiv, int *ipiv2, double *B, const int *ldb, double *work, const int *lwork, int *info, size_t)
     * }
     */
    public static MethodHandle dsysv_aa_2stage_$handle() {
        return dsysv_aa_2stage_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dsysv_aa_2stage_(const char *uplo, const int *n, const int *nrhs, double *A, const int *lda, double *TB, const int *ltb, int *ipiv, int *ipiv2, double *B, const int *ldb, double *work, const int *lwork, int *info, size_t)
     * }
     */
    public static MemorySegment dsysv_aa_2stage_$address() {
        return dsysv_aa_2stage_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dsysv_aa_2stage_(const char *uplo, const int *n, const int *nrhs, double *A, const int *lda, double *TB, const int *ltb, int *ipiv, int *ipiv2, double *B, const int *ldb, double *work, const int *lwork, int *info, size_t)
     * }
     */
    public static void dsysv_aa_2stage_(MemorySegment uplo, MemorySegment n, MemorySegment nrhs, MemorySegment A, MemorySegment lda, MemorySegment TB, MemorySegment ltb, MemorySegment ipiv, MemorySegment ipiv2, MemorySegment B, MemorySegment ldb, MemorySegment work, MemorySegment lwork, MemorySegment info, long x14) {
        var mh$ = dsysv_aa_2stage_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dsysv_aa_2stage_", uplo, n, nrhs, A, lda, TB, ltb, ipiv, ipiv2, B, ldb, work, lwork, info, x14);
            }
            mh$.invokeExact(uplo, n, nrhs, A, lda, TB, ltb, ipiv, ipiv2, B, ldb, work, lwork, info, x14);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ssysv_aa_2stage_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("ssysv_aa_2stage_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ssysv_aa_2stage_(const char *uplo, const int *n, const int *nrhs, float *A, const int *lda, float *TB, const int *ltb, int *ipiv, int *ipiv2, float *B, const int *ldb, float *work, const int *lwork, int *info, size_t)
     * }
     */
    public static FunctionDescriptor ssysv_aa_2stage_$descriptor() {
        return ssysv_aa_2stage_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ssysv_aa_2stage_(const char *uplo, const int *n, const int *nrhs, float *A, const int *lda, float *TB, const int *ltb, int *ipiv, int *ipiv2, float *B, const int *ldb, float *work, const int *lwork, int *info, size_t)
     * }
     */
    public static MethodHandle ssysv_aa_2stage_$handle() {
        return ssysv_aa_2stage_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ssysv_aa_2stage_(const char *uplo, const int *n, const int *nrhs, float *A, const int *lda, float *TB, const int *ltb, int *ipiv, int *ipiv2, float *B, const int *ldb, float *work, const int *lwork, int *info, size_t)
     * }
     */
    public static MemorySegment ssysv_aa_2stage_$address() {
        return ssysv_aa_2stage_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ssysv_aa_2stage_(const char *uplo, const int *n, const int *nrhs, float *A, const int *lda, float *TB, const int *ltb, int *ipiv, int *ipiv2, float *B, const int *ldb, float *work, const int *lwork, int *info, size_t)
     * }
     */
    public static void ssysv_aa_2stage_(MemorySegment uplo, MemorySegment n, MemorySegment nrhs, MemorySegment A, MemorySegment lda, MemorySegment TB, MemorySegment ltb, MemorySegment ipiv, MemorySegment ipiv2, MemorySegment B, MemorySegment ldb, MemorySegment work, MemorySegment lwork, MemorySegment info, long x14) {
        var mh$ = ssysv_aa_2stage_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ssysv_aa_2stage_", uplo, n, nrhs, A, lda, TB, ltb, ipiv, ipiv2, B, ldb, work, lwork, info, x14);
            }
            mh$.invokeExact(uplo, n, nrhs, A, lda, TB, ltb, ipiv, ipiv2, B, ldb, work, lwork, info, x14);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zsysv_aa_2stage_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("zsysv_aa_2stage_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zsysv_aa_2stage_(const char *uplo, const int *n, const int *nrhs, _Complex double *A, const int *lda, _Complex double *TB, const int *ltb, int *ipiv, int *ipiv2, _Complex double *B, const int *ldb, _Complex double *work, const int *lwork, int *info, size_t)
     * }
     */
    public static FunctionDescriptor zsysv_aa_2stage_$descriptor() {
        return zsysv_aa_2stage_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zsysv_aa_2stage_(const char *uplo, const int *n, const int *nrhs, _Complex double *A, const int *lda, _Complex double *TB, const int *ltb, int *ipiv, int *ipiv2, _Complex double *B, const int *ldb, _Complex double *work, const int *lwork, int *info, size_t)
     * }
     */
    public static MethodHandle zsysv_aa_2stage_$handle() {
        return zsysv_aa_2stage_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zsysv_aa_2stage_(const char *uplo, const int *n, const int *nrhs, _Complex double *A, const int *lda, _Complex double *TB, const int *ltb, int *ipiv, int *ipiv2, _Complex double *B, const int *ldb, _Complex double *work, const int *lwork, int *info, size_t)
     * }
     */
    public static MemorySegment zsysv_aa_2stage_$address() {
        return zsysv_aa_2stage_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zsysv_aa_2stage_(const char *uplo, const int *n, const int *nrhs, _Complex double *A, const int *lda, _Complex double *TB, const int *ltb, int *ipiv, int *ipiv2, _Complex double *B, const int *ldb, _Complex double *work, const int *lwork, int *info, size_t)
     * }
     */
    public static void zsysv_aa_2stage_(MemorySegment uplo, MemorySegment n, MemorySegment nrhs, MemorySegment A, MemorySegment lda, MemorySegment TB, MemorySegment ltb, MemorySegment ipiv, MemorySegment ipiv2, MemorySegment B, MemorySegment ldb, MemorySegment work, MemorySegment lwork, MemorySegment info, long x14) {
        var mh$ = zsysv_aa_2stage_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zsysv_aa_2stage_", uplo, n, nrhs, A, lda, TB, ltb, ipiv, ipiv2, B, ldb, work, lwork, info, x14);
            }
            mh$.invokeExact(uplo, n, nrhs, A, lda, TB, ltb, ipiv, ipiv2, B, ldb, work, lwork, info, x14);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class csysv_rk_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("csysv_rk_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void csysv_rk_(const char *uplo, const int *n, const int *nrhs, _Complex float *A, const int *lda, _Complex float *E, int *ipiv, _Complex float *B, const int *ldb, _Complex float *work, const int *lwork, int *info, size_t)
     * }
     */
    public static FunctionDescriptor csysv_rk_$descriptor() {
        return csysv_rk_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void csysv_rk_(const char *uplo, const int *n, const int *nrhs, _Complex float *A, const int *lda, _Complex float *E, int *ipiv, _Complex float *B, const int *ldb, _Complex float *work, const int *lwork, int *info, size_t)
     * }
     */
    public static MethodHandle csysv_rk_$handle() {
        return csysv_rk_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void csysv_rk_(const char *uplo, const int *n, const int *nrhs, _Complex float *A, const int *lda, _Complex float *E, int *ipiv, _Complex float *B, const int *ldb, _Complex float *work, const int *lwork, int *info, size_t)
     * }
     */
    public static MemorySegment csysv_rk_$address() {
        return csysv_rk_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void csysv_rk_(const char *uplo, const int *n, const int *nrhs, _Complex float *A, const int *lda, _Complex float *E, int *ipiv, _Complex float *B, const int *ldb, _Complex float *work, const int *lwork, int *info, size_t)
     * }
     */
    public static void csysv_rk_(MemorySegment uplo, MemorySegment n, MemorySegment nrhs, MemorySegment A, MemorySegment lda, MemorySegment E, MemorySegment ipiv, MemorySegment B, MemorySegment ldb, MemorySegment work, MemorySegment lwork, MemorySegment info, long x12) {
        var mh$ = csysv_rk_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("csysv_rk_", uplo, n, nrhs, A, lda, E, ipiv, B, ldb, work, lwork, info, x12);
            }
            mh$.invokeExact(uplo, n, nrhs, A, lda, E, ipiv, B, ldb, work, lwork, info, x12);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dsysv_rk_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("dsysv_rk_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dsysv_rk_(const char *uplo, const int *n, const int *nrhs, double *A, const int *lda, double *E, int *ipiv, double *B, const int *ldb, double *work, const int *lwork, int *info, size_t)
     * }
     */
    public static FunctionDescriptor dsysv_rk_$descriptor() {
        return dsysv_rk_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dsysv_rk_(const char *uplo, const int *n, const int *nrhs, double *A, const int *lda, double *E, int *ipiv, double *B, const int *ldb, double *work, const int *lwork, int *info, size_t)
     * }
     */
    public static MethodHandle dsysv_rk_$handle() {
        return dsysv_rk_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dsysv_rk_(const char *uplo, const int *n, const int *nrhs, double *A, const int *lda, double *E, int *ipiv, double *B, const int *ldb, double *work, const int *lwork, int *info, size_t)
     * }
     */
    public static MemorySegment dsysv_rk_$address() {
        return dsysv_rk_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dsysv_rk_(const char *uplo, const int *n, const int *nrhs, double *A, const int *lda, double *E, int *ipiv, double *B, const int *ldb, double *work, const int *lwork, int *info, size_t)
     * }
     */
    public static void dsysv_rk_(MemorySegment uplo, MemorySegment n, MemorySegment nrhs, MemorySegment A, MemorySegment lda, MemorySegment E, MemorySegment ipiv, MemorySegment B, MemorySegment ldb, MemorySegment work, MemorySegment lwork, MemorySegment info, long x12) {
        var mh$ = dsysv_rk_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dsysv_rk_", uplo, n, nrhs, A, lda, E, ipiv, B, ldb, work, lwork, info, x12);
            }
            mh$.invokeExact(uplo, n, nrhs, A, lda, E, ipiv, B, ldb, work, lwork, info, x12);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ssysv_rk_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("ssysv_rk_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ssysv_rk_(const char *uplo, const int *n, const int *nrhs, float *A, const int *lda, float *E, int *ipiv, float *B, const int *ldb, float *work, const int *lwork, int *info, size_t)
     * }
     */
    public static FunctionDescriptor ssysv_rk_$descriptor() {
        return ssysv_rk_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ssysv_rk_(const char *uplo, const int *n, const int *nrhs, float *A, const int *lda, float *E, int *ipiv, float *B, const int *ldb, float *work, const int *lwork, int *info, size_t)
     * }
     */
    public static MethodHandle ssysv_rk_$handle() {
        return ssysv_rk_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ssysv_rk_(const char *uplo, const int *n, const int *nrhs, float *A, const int *lda, float *E, int *ipiv, float *B, const int *ldb, float *work, const int *lwork, int *info, size_t)
     * }
     */
    public static MemorySegment ssysv_rk_$address() {
        return ssysv_rk_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ssysv_rk_(const char *uplo, const int *n, const int *nrhs, float *A, const int *lda, float *E, int *ipiv, float *B, const int *ldb, float *work, const int *lwork, int *info, size_t)
     * }
     */
    public static void ssysv_rk_(MemorySegment uplo, MemorySegment n, MemorySegment nrhs, MemorySegment A, MemorySegment lda, MemorySegment E, MemorySegment ipiv, MemorySegment B, MemorySegment ldb, MemorySegment work, MemorySegment lwork, MemorySegment info, long x12) {
        var mh$ = ssysv_rk_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ssysv_rk_", uplo, n, nrhs, A, lda, E, ipiv, B, ldb, work, lwork, info, x12);
            }
            mh$.invokeExact(uplo, n, nrhs, A, lda, E, ipiv, B, ldb, work, lwork, info, x12);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zsysv_rk_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("zsysv_rk_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zsysv_rk_(const char *uplo, const int *n, const int *nrhs, _Complex double *A, const int *lda, _Complex double *E, int *ipiv, _Complex double *B, const int *ldb, _Complex double *work, const int *lwork, int *info, size_t)
     * }
     */
    public static FunctionDescriptor zsysv_rk_$descriptor() {
        return zsysv_rk_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zsysv_rk_(const char *uplo, const int *n, const int *nrhs, _Complex double *A, const int *lda, _Complex double *E, int *ipiv, _Complex double *B, const int *ldb, _Complex double *work, const int *lwork, int *info, size_t)
     * }
     */
    public static MethodHandle zsysv_rk_$handle() {
        return zsysv_rk_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zsysv_rk_(const char *uplo, const int *n, const int *nrhs, _Complex double *A, const int *lda, _Complex double *E, int *ipiv, _Complex double *B, const int *ldb, _Complex double *work, const int *lwork, int *info, size_t)
     * }
     */
    public static MemorySegment zsysv_rk_$address() {
        return zsysv_rk_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zsysv_rk_(const char *uplo, const int *n, const int *nrhs, _Complex double *A, const int *lda, _Complex double *E, int *ipiv, _Complex double *B, const int *ldb, _Complex double *work, const int *lwork, int *info, size_t)
     * }
     */
    public static void zsysv_rk_(MemorySegment uplo, MemorySegment n, MemorySegment nrhs, MemorySegment A, MemorySegment lda, MemorySegment E, MemorySegment ipiv, MemorySegment B, MemorySegment ldb, MemorySegment work, MemorySegment lwork, MemorySegment info, long x12) {
        var mh$ = zsysv_rk_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zsysv_rk_", uplo, n, nrhs, A, lda, E, ipiv, B, ldb, work, lwork, info, x12);
            }
            mh$.invokeExact(uplo, n, nrhs, A, lda, E, ipiv, B, ldb, work, lwork, info, x12);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class csysv_rook_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("csysv_rook_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void csysv_rook_(const char *uplo, const int *n, const int *nrhs, _Complex float *A, const int *lda, int *ipiv, _Complex float *B, const int *ldb, _Complex float *work, const int *lwork, int *info, size_t)
     * }
     */
    public static FunctionDescriptor csysv_rook_$descriptor() {
        return csysv_rook_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void csysv_rook_(const char *uplo, const int *n, const int *nrhs, _Complex float *A, const int *lda, int *ipiv, _Complex float *B, const int *ldb, _Complex float *work, const int *lwork, int *info, size_t)
     * }
     */
    public static MethodHandle csysv_rook_$handle() {
        return csysv_rook_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void csysv_rook_(const char *uplo, const int *n, const int *nrhs, _Complex float *A, const int *lda, int *ipiv, _Complex float *B, const int *ldb, _Complex float *work, const int *lwork, int *info, size_t)
     * }
     */
    public static MemorySegment csysv_rook_$address() {
        return csysv_rook_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void csysv_rook_(const char *uplo, const int *n, const int *nrhs, _Complex float *A, const int *lda, int *ipiv, _Complex float *B, const int *ldb, _Complex float *work, const int *lwork, int *info, size_t)
     * }
     */
    public static void csysv_rook_(MemorySegment uplo, MemorySegment n, MemorySegment nrhs, MemorySegment A, MemorySegment lda, MemorySegment ipiv, MemorySegment B, MemorySegment ldb, MemorySegment work, MemorySegment lwork, MemorySegment info, long x11) {
        var mh$ = csysv_rook_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("csysv_rook_", uplo, n, nrhs, A, lda, ipiv, B, ldb, work, lwork, info, x11);
            }
            mh$.invokeExact(uplo, n, nrhs, A, lda, ipiv, B, ldb, work, lwork, info, x11);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dsysv_rook_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("dsysv_rook_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dsysv_rook_(const char *uplo, const int *n, const int *nrhs, double *A, const int *lda, int *ipiv, double *B, const int *ldb, double *work, const int *lwork, int *info, size_t)
     * }
     */
    public static FunctionDescriptor dsysv_rook_$descriptor() {
        return dsysv_rook_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dsysv_rook_(const char *uplo, const int *n, const int *nrhs, double *A, const int *lda, int *ipiv, double *B, const int *ldb, double *work, const int *lwork, int *info, size_t)
     * }
     */
    public static MethodHandle dsysv_rook_$handle() {
        return dsysv_rook_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dsysv_rook_(const char *uplo, const int *n, const int *nrhs, double *A, const int *lda, int *ipiv, double *B, const int *ldb, double *work, const int *lwork, int *info, size_t)
     * }
     */
    public static MemorySegment dsysv_rook_$address() {
        return dsysv_rook_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dsysv_rook_(const char *uplo, const int *n, const int *nrhs, double *A, const int *lda, int *ipiv, double *B, const int *ldb, double *work, const int *lwork, int *info, size_t)
     * }
     */
    public static void dsysv_rook_(MemorySegment uplo, MemorySegment n, MemorySegment nrhs, MemorySegment A, MemorySegment lda, MemorySegment ipiv, MemorySegment B, MemorySegment ldb, MemorySegment work, MemorySegment lwork, MemorySegment info, long x11) {
        var mh$ = dsysv_rook_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dsysv_rook_", uplo, n, nrhs, A, lda, ipiv, B, ldb, work, lwork, info, x11);
            }
            mh$.invokeExact(uplo, n, nrhs, A, lda, ipiv, B, ldb, work, lwork, info, x11);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ssysv_rook_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("ssysv_rook_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ssysv_rook_(const char *uplo, const int *n, const int *nrhs, float *A, const int *lda, int *ipiv, float *B, const int *ldb, float *work, const int *lwork, int *info, size_t)
     * }
     */
    public static FunctionDescriptor ssysv_rook_$descriptor() {
        return ssysv_rook_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ssysv_rook_(const char *uplo, const int *n, const int *nrhs, float *A, const int *lda, int *ipiv, float *B, const int *ldb, float *work, const int *lwork, int *info, size_t)
     * }
     */
    public static MethodHandle ssysv_rook_$handle() {
        return ssysv_rook_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ssysv_rook_(const char *uplo, const int *n, const int *nrhs, float *A, const int *lda, int *ipiv, float *B, const int *ldb, float *work, const int *lwork, int *info, size_t)
     * }
     */
    public static MemorySegment ssysv_rook_$address() {
        return ssysv_rook_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ssysv_rook_(const char *uplo, const int *n, const int *nrhs, float *A, const int *lda, int *ipiv, float *B, const int *ldb, float *work, const int *lwork, int *info, size_t)
     * }
     */
    public static void ssysv_rook_(MemorySegment uplo, MemorySegment n, MemorySegment nrhs, MemorySegment A, MemorySegment lda, MemorySegment ipiv, MemorySegment B, MemorySegment ldb, MemorySegment work, MemorySegment lwork, MemorySegment info, long x11) {
        var mh$ = ssysv_rook_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ssysv_rook_", uplo, n, nrhs, A, lda, ipiv, B, ldb, work, lwork, info, x11);
            }
            mh$.invokeExact(uplo, n, nrhs, A, lda, ipiv, B, ldb, work, lwork, info, x11);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zsysv_rook_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("zsysv_rook_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zsysv_rook_(const char *uplo, const int *n, const int *nrhs, _Complex double *A, const int *lda, int *ipiv, _Complex double *B, const int *ldb, _Complex double *work, const int *lwork, int *info, size_t)
     * }
     */
    public static FunctionDescriptor zsysv_rook_$descriptor() {
        return zsysv_rook_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zsysv_rook_(const char *uplo, const int *n, const int *nrhs, _Complex double *A, const int *lda, int *ipiv, _Complex double *B, const int *ldb, _Complex double *work, const int *lwork, int *info, size_t)
     * }
     */
    public static MethodHandle zsysv_rook_$handle() {
        return zsysv_rook_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zsysv_rook_(const char *uplo, const int *n, const int *nrhs, _Complex double *A, const int *lda, int *ipiv, _Complex double *B, const int *ldb, _Complex double *work, const int *lwork, int *info, size_t)
     * }
     */
    public static MemorySegment zsysv_rook_$address() {
        return zsysv_rook_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zsysv_rook_(const char *uplo, const int *n, const int *nrhs, _Complex double *A, const int *lda, int *ipiv, _Complex double *B, const int *ldb, _Complex double *work, const int *lwork, int *info, size_t)
     * }
     */
    public static void zsysv_rook_(MemorySegment uplo, MemorySegment n, MemorySegment nrhs, MemorySegment A, MemorySegment lda, MemorySegment ipiv, MemorySegment B, MemorySegment ldb, MemorySegment work, MemorySegment lwork, MemorySegment info, long x11) {
        var mh$ = zsysv_rook_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zsysv_rook_", uplo, n, nrhs, A, lda, ipiv, B, ldb, work, lwork, info, x11);
            }
            mh$.invokeExact(uplo, n, nrhs, A, lda, ipiv, B, ldb, work, lwork, info, x11);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class csysvx_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("csysvx_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void csysvx_(const char *fact, const char *uplo, const int *n, const int *nrhs, const _Complex float *A, const int *lda, _Complex float *AF, const int *ldaf, int *ipiv, const _Complex float *B, const int *ldb, _Complex float *X, const int *ldx, float *rcond, float *ferr, float *berr, _Complex float *work, const int *lwork, float *rwork, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor csysvx_$descriptor() {
        return csysvx_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void csysvx_(const char *fact, const char *uplo, const int *n, const int *nrhs, const _Complex float *A, const int *lda, _Complex float *AF, const int *ldaf, int *ipiv, const _Complex float *B, const int *ldb, _Complex float *X, const int *ldx, float *rcond, float *ferr, float *berr, _Complex float *work, const int *lwork, float *rwork, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle csysvx_$handle() {
        return csysvx_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void csysvx_(const char *fact, const char *uplo, const int *n, const int *nrhs, const _Complex float *A, const int *lda, _Complex float *AF, const int *ldaf, int *ipiv, const _Complex float *B, const int *ldb, _Complex float *X, const int *ldx, float *rcond, float *ferr, float *berr, _Complex float *work, const int *lwork, float *rwork, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment csysvx_$address() {
        return csysvx_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void csysvx_(const char *fact, const char *uplo, const int *n, const int *nrhs, const _Complex float *A, const int *lda, _Complex float *AF, const int *ldaf, int *ipiv, const _Complex float *B, const int *ldb, _Complex float *X, const int *ldx, float *rcond, float *ferr, float *berr, _Complex float *work, const int *lwork, float *rwork, int *info, size_t, size_t)
     * }
     */
    public static void csysvx_(MemorySegment fact, MemorySegment uplo, MemorySegment n, MemorySegment nrhs, MemorySegment A, MemorySegment lda, MemorySegment AF, MemorySegment ldaf, MemorySegment ipiv, MemorySegment B, MemorySegment ldb, MemorySegment X, MemorySegment ldx, MemorySegment rcond, MemorySegment ferr, MemorySegment berr, MemorySegment work, MemorySegment lwork, MemorySegment rwork, MemorySegment info, long x20, long x21) {
        var mh$ = csysvx_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("csysvx_", fact, uplo, n, nrhs, A, lda, AF, ldaf, ipiv, B, ldb, X, ldx, rcond, ferr, berr, work, lwork, rwork, info, x20, x21);
            }
            mh$.invokeExact(fact, uplo, n, nrhs, A, lda, AF, ldaf, ipiv, B, ldb, X, ldx, rcond, ferr, berr, work, lwork, rwork, info, x20, x21);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dsysvx_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("dsysvx_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dsysvx_(const char *fact, const char *uplo, const int *n, const int *nrhs, const double *A, const int *lda, double *AF, const int *ldaf, int *ipiv, const double *B, const int *ldb, double *X, const int *ldx, double *rcond, double *ferr, double *berr, double *work, const int *lwork, int *iwork, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor dsysvx_$descriptor() {
        return dsysvx_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dsysvx_(const char *fact, const char *uplo, const int *n, const int *nrhs, const double *A, const int *lda, double *AF, const int *ldaf, int *ipiv, const double *B, const int *ldb, double *X, const int *ldx, double *rcond, double *ferr, double *berr, double *work, const int *lwork, int *iwork, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle dsysvx_$handle() {
        return dsysvx_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dsysvx_(const char *fact, const char *uplo, const int *n, const int *nrhs, const double *A, const int *lda, double *AF, const int *ldaf, int *ipiv, const double *B, const int *ldb, double *X, const int *ldx, double *rcond, double *ferr, double *berr, double *work, const int *lwork, int *iwork, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment dsysvx_$address() {
        return dsysvx_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dsysvx_(const char *fact, const char *uplo, const int *n, const int *nrhs, const double *A, const int *lda, double *AF, const int *ldaf, int *ipiv, const double *B, const int *ldb, double *X, const int *ldx, double *rcond, double *ferr, double *berr, double *work, const int *lwork, int *iwork, int *info, size_t, size_t)
     * }
     */
    public static void dsysvx_(MemorySegment fact, MemorySegment uplo, MemorySegment n, MemorySegment nrhs, MemorySegment A, MemorySegment lda, MemorySegment AF, MemorySegment ldaf, MemorySegment ipiv, MemorySegment B, MemorySegment ldb, MemorySegment X, MemorySegment ldx, MemorySegment rcond, MemorySegment ferr, MemorySegment berr, MemorySegment work, MemorySegment lwork, MemorySegment iwork, MemorySegment info, long x20, long x21) {
        var mh$ = dsysvx_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dsysvx_", fact, uplo, n, nrhs, A, lda, AF, ldaf, ipiv, B, ldb, X, ldx, rcond, ferr, berr, work, lwork, iwork, info, x20, x21);
            }
            mh$.invokeExact(fact, uplo, n, nrhs, A, lda, AF, ldaf, ipiv, B, ldb, X, ldx, rcond, ferr, berr, work, lwork, iwork, info, x20, x21);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ssysvx_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("ssysvx_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ssysvx_(const char *fact, const char *uplo, const int *n, const int *nrhs, const float *A, const int *lda, float *AF, const int *ldaf, int *ipiv, const float *B, const int *ldb, float *X, const int *ldx, float *rcond, float *ferr, float *berr, float *work, const int *lwork, int *iwork, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor ssysvx_$descriptor() {
        return ssysvx_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ssysvx_(const char *fact, const char *uplo, const int *n, const int *nrhs, const float *A, const int *lda, float *AF, const int *ldaf, int *ipiv, const float *B, const int *ldb, float *X, const int *ldx, float *rcond, float *ferr, float *berr, float *work, const int *lwork, int *iwork, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle ssysvx_$handle() {
        return ssysvx_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ssysvx_(const char *fact, const char *uplo, const int *n, const int *nrhs, const float *A, const int *lda, float *AF, const int *ldaf, int *ipiv, const float *B, const int *ldb, float *X, const int *ldx, float *rcond, float *ferr, float *berr, float *work, const int *lwork, int *iwork, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment ssysvx_$address() {
        return ssysvx_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ssysvx_(const char *fact, const char *uplo, const int *n, const int *nrhs, const float *A, const int *lda, float *AF, const int *ldaf, int *ipiv, const float *B, const int *ldb, float *X, const int *ldx, float *rcond, float *ferr, float *berr, float *work, const int *lwork, int *iwork, int *info, size_t, size_t)
     * }
     */
    public static void ssysvx_(MemorySegment fact, MemorySegment uplo, MemorySegment n, MemorySegment nrhs, MemorySegment A, MemorySegment lda, MemorySegment AF, MemorySegment ldaf, MemorySegment ipiv, MemorySegment B, MemorySegment ldb, MemorySegment X, MemorySegment ldx, MemorySegment rcond, MemorySegment ferr, MemorySegment berr, MemorySegment work, MemorySegment lwork, MemorySegment iwork, MemorySegment info, long x20, long x21) {
        var mh$ = ssysvx_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ssysvx_", fact, uplo, n, nrhs, A, lda, AF, ldaf, ipiv, B, ldb, X, ldx, rcond, ferr, berr, work, lwork, iwork, info, x20, x21);
            }
            mh$.invokeExact(fact, uplo, n, nrhs, A, lda, AF, ldaf, ipiv, B, ldb, X, ldx, rcond, ferr, berr, work, lwork, iwork, info, x20, x21);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zsysvx_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("zsysvx_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zsysvx_(const char *fact, const char *uplo, const int *n, const int *nrhs, const _Complex double *A, const int *lda, _Complex double *AF, const int *ldaf, int *ipiv, const _Complex double *B, const int *ldb, _Complex double *X, const int *ldx, double *rcond, double *ferr, double *berr, _Complex double *work, const int *lwork, double *rwork, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor zsysvx_$descriptor() {
        return zsysvx_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zsysvx_(const char *fact, const char *uplo, const int *n, const int *nrhs, const _Complex double *A, const int *lda, _Complex double *AF, const int *ldaf, int *ipiv, const _Complex double *B, const int *ldb, _Complex double *X, const int *ldx, double *rcond, double *ferr, double *berr, _Complex double *work, const int *lwork, double *rwork, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle zsysvx_$handle() {
        return zsysvx_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zsysvx_(const char *fact, const char *uplo, const int *n, const int *nrhs, const _Complex double *A, const int *lda, _Complex double *AF, const int *ldaf, int *ipiv, const _Complex double *B, const int *ldb, _Complex double *X, const int *ldx, double *rcond, double *ferr, double *berr, _Complex double *work, const int *lwork, double *rwork, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment zsysvx_$address() {
        return zsysvx_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zsysvx_(const char *fact, const char *uplo, const int *n, const int *nrhs, const _Complex double *A, const int *lda, _Complex double *AF, const int *ldaf, int *ipiv, const _Complex double *B, const int *ldb, _Complex double *X, const int *ldx, double *rcond, double *ferr, double *berr, _Complex double *work, const int *lwork, double *rwork, int *info, size_t, size_t)
     * }
     */
    public static void zsysvx_(MemorySegment fact, MemorySegment uplo, MemorySegment n, MemorySegment nrhs, MemorySegment A, MemorySegment lda, MemorySegment AF, MemorySegment ldaf, MemorySegment ipiv, MemorySegment B, MemorySegment ldb, MemorySegment X, MemorySegment ldx, MemorySegment rcond, MemorySegment ferr, MemorySegment berr, MemorySegment work, MemorySegment lwork, MemorySegment rwork, MemorySegment info, long x20, long x21) {
        var mh$ = zsysvx_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zsysvx_", fact, uplo, n, nrhs, A, lda, AF, ldaf, ipiv, B, ldb, X, ldx, rcond, ferr, berr, work, lwork, rwork, info, x20, x21);
            }
            mh$.invokeExact(fact, uplo, n, nrhs, A, lda, AF, ldaf, ipiv, B, ldb, X, ldx, rcond, ferr, berr, work, lwork, rwork, info, x20, x21);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class csysvxx_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("csysvxx_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void csysvxx_(const char *fact, const char *uplo, const int *n, const int *nrhs, _Complex float *A, const int *lda, _Complex float *AF, const int *ldaf, int *ipiv, char *equed, float *S, _Complex float *B, const int *ldb, _Complex float *X, const int *ldx, float *rcond, float *rpvgrw, float *berr, const int *n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, const int *nparams, float *params, _Complex float *work, float *rwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor csysvxx_$descriptor() {
        return csysvxx_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void csysvxx_(const char *fact, const char *uplo, const int *n, const int *nrhs, _Complex float *A, const int *lda, _Complex float *AF, const int *ldaf, int *ipiv, char *equed, float *S, _Complex float *B, const int *ldb, _Complex float *X, const int *ldx, float *rcond, float *rpvgrw, float *berr, const int *n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, const int *nparams, float *params, _Complex float *work, float *rwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle csysvxx_$handle() {
        return csysvxx_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void csysvxx_(const char *fact, const char *uplo, const int *n, const int *nrhs, _Complex float *A, const int *lda, _Complex float *AF, const int *ldaf, int *ipiv, char *equed, float *S, _Complex float *B, const int *ldb, _Complex float *X, const int *ldx, float *rcond, float *rpvgrw, float *berr, const int *n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, const int *nparams, float *params, _Complex float *work, float *rwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment csysvxx_$address() {
        return csysvxx_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void csysvxx_(const char *fact, const char *uplo, const int *n, const int *nrhs, _Complex float *A, const int *lda, _Complex float *AF, const int *ldaf, int *ipiv, char *equed, float *S, _Complex float *B, const int *ldb, _Complex float *X, const int *ldx, float *rcond, float *rpvgrw, float *berr, const int *n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, const int *nparams, float *params, _Complex float *work, float *rwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static void csysvxx_(MemorySegment fact, MemorySegment uplo, MemorySegment n, MemorySegment nrhs, MemorySegment A, MemorySegment lda, MemorySegment AF, MemorySegment ldaf, MemorySegment ipiv, MemorySegment equed, MemorySegment S, MemorySegment B, MemorySegment ldb, MemorySegment X, MemorySegment ldx, MemorySegment rcond, MemorySegment rpvgrw, MemorySegment berr, MemorySegment n_err_bnds, MemorySegment err_bnds_norm, MemorySegment err_bnds_comp, MemorySegment nparams, MemorySegment params, MemorySegment work, MemorySegment rwork, MemorySegment info, long x26, long x27, long x28) {
        var mh$ = csysvxx_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("csysvxx_", fact, uplo, n, nrhs, A, lda, AF, ldaf, ipiv, equed, S, B, ldb, X, ldx, rcond, rpvgrw, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params, work, rwork, info, x26, x27, x28);
            }
            mh$.invokeExact(fact, uplo, n, nrhs, A, lda, AF, ldaf, ipiv, equed, S, B, ldb, X, ldx, rcond, rpvgrw, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params, work, rwork, info, x26, x27, x28);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dsysvxx_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("dsysvxx_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dsysvxx_(const char *fact, const char *uplo, const int *n, const int *nrhs, double *A, const int *lda, double *AF, const int *ldaf, int *ipiv, char *equed, double *S, double *B, const int *ldb, double *X, const int *ldx, double *rcond, double *rpvgrw, double *berr, const int *n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, const int *nparams, double *params, double *work, int *iwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor dsysvxx_$descriptor() {
        return dsysvxx_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dsysvxx_(const char *fact, const char *uplo, const int *n, const int *nrhs, double *A, const int *lda, double *AF, const int *ldaf, int *ipiv, char *equed, double *S, double *B, const int *ldb, double *X, const int *ldx, double *rcond, double *rpvgrw, double *berr, const int *n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, const int *nparams, double *params, double *work, int *iwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle dsysvxx_$handle() {
        return dsysvxx_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dsysvxx_(const char *fact, const char *uplo, const int *n, const int *nrhs, double *A, const int *lda, double *AF, const int *ldaf, int *ipiv, char *equed, double *S, double *B, const int *ldb, double *X, const int *ldx, double *rcond, double *rpvgrw, double *berr, const int *n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, const int *nparams, double *params, double *work, int *iwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment dsysvxx_$address() {
        return dsysvxx_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dsysvxx_(const char *fact, const char *uplo, const int *n, const int *nrhs, double *A, const int *lda, double *AF, const int *ldaf, int *ipiv, char *equed, double *S, double *B, const int *ldb, double *X, const int *ldx, double *rcond, double *rpvgrw, double *berr, const int *n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, const int *nparams, double *params, double *work, int *iwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static void dsysvxx_(MemorySegment fact, MemorySegment uplo, MemorySegment n, MemorySegment nrhs, MemorySegment A, MemorySegment lda, MemorySegment AF, MemorySegment ldaf, MemorySegment ipiv, MemorySegment equed, MemorySegment S, MemorySegment B, MemorySegment ldb, MemorySegment X, MemorySegment ldx, MemorySegment rcond, MemorySegment rpvgrw, MemorySegment berr, MemorySegment n_err_bnds, MemorySegment err_bnds_norm, MemorySegment err_bnds_comp, MemorySegment nparams, MemorySegment params, MemorySegment work, MemorySegment iwork, MemorySegment info, long x26, long x27, long x28) {
        var mh$ = dsysvxx_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dsysvxx_", fact, uplo, n, nrhs, A, lda, AF, ldaf, ipiv, equed, S, B, ldb, X, ldx, rcond, rpvgrw, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params, work, iwork, info, x26, x27, x28);
            }
            mh$.invokeExact(fact, uplo, n, nrhs, A, lda, AF, ldaf, ipiv, equed, S, B, ldb, X, ldx, rcond, rpvgrw, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params, work, iwork, info, x26, x27, x28);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ssysvxx_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("ssysvxx_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ssysvxx_(const char *fact, const char *uplo, const int *n, const int *nrhs, float *A, const int *lda, float *AF, const int *ldaf, int *ipiv, char *equed, float *S, float *B, const int *ldb, float *X, const int *ldx, float *rcond, float *rpvgrw, float *berr, const int *n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, const int *nparams, float *params, float *work, int *iwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor ssysvxx_$descriptor() {
        return ssysvxx_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ssysvxx_(const char *fact, const char *uplo, const int *n, const int *nrhs, float *A, const int *lda, float *AF, const int *ldaf, int *ipiv, char *equed, float *S, float *B, const int *ldb, float *X, const int *ldx, float *rcond, float *rpvgrw, float *berr, const int *n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, const int *nparams, float *params, float *work, int *iwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle ssysvxx_$handle() {
        return ssysvxx_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ssysvxx_(const char *fact, const char *uplo, const int *n, const int *nrhs, float *A, const int *lda, float *AF, const int *ldaf, int *ipiv, char *equed, float *S, float *B, const int *ldb, float *X, const int *ldx, float *rcond, float *rpvgrw, float *berr, const int *n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, const int *nparams, float *params, float *work, int *iwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment ssysvxx_$address() {
        return ssysvxx_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ssysvxx_(const char *fact, const char *uplo, const int *n, const int *nrhs, float *A, const int *lda, float *AF, const int *ldaf, int *ipiv, char *equed, float *S, float *B, const int *ldb, float *X, const int *ldx, float *rcond, float *rpvgrw, float *berr, const int *n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, const int *nparams, float *params, float *work, int *iwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static void ssysvxx_(MemorySegment fact, MemorySegment uplo, MemorySegment n, MemorySegment nrhs, MemorySegment A, MemorySegment lda, MemorySegment AF, MemorySegment ldaf, MemorySegment ipiv, MemorySegment equed, MemorySegment S, MemorySegment B, MemorySegment ldb, MemorySegment X, MemorySegment ldx, MemorySegment rcond, MemorySegment rpvgrw, MemorySegment berr, MemorySegment n_err_bnds, MemorySegment err_bnds_norm, MemorySegment err_bnds_comp, MemorySegment nparams, MemorySegment params, MemorySegment work, MemorySegment iwork, MemorySegment info, long x26, long x27, long x28) {
        var mh$ = ssysvxx_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ssysvxx_", fact, uplo, n, nrhs, A, lda, AF, ldaf, ipiv, equed, S, B, ldb, X, ldx, rcond, rpvgrw, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params, work, iwork, info, x26, x27, x28);
            }
            mh$.invokeExact(fact, uplo, n, nrhs, A, lda, AF, ldaf, ipiv, equed, S, B, ldb, X, ldx, rcond, rpvgrw, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params, work, iwork, info, x26, x27, x28);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zsysvxx_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("zsysvxx_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zsysvxx_(const char *fact, const char *uplo, const int *n, const int *nrhs, _Complex double *A, const int *lda, _Complex double *AF, const int *ldaf, int *ipiv, char *equed, double *S, _Complex double *B, const int *ldb, _Complex double *X, const int *ldx, double *rcond, double *rpvgrw, double *berr, const int *n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, const int *nparams, double *params, _Complex double *work, double *rwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor zsysvxx_$descriptor() {
        return zsysvxx_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zsysvxx_(const char *fact, const char *uplo, const int *n, const int *nrhs, _Complex double *A, const int *lda, _Complex double *AF, const int *ldaf, int *ipiv, char *equed, double *S, _Complex double *B, const int *ldb, _Complex double *X, const int *ldx, double *rcond, double *rpvgrw, double *berr, const int *n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, const int *nparams, double *params, _Complex double *work, double *rwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle zsysvxx_$handle() {
        return zsysvxx_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zsysvxx_(const char *fact, const char *uplo, const int *n, const int *nrhs, _Complex double *A, const int *lda, _Complex double *AF, const int *ldaf, int *ipiv, char *equed, double *S, _Complex double *B, const int *ldb, _Complex double *X, const int *ldx, double *rcond, double *rpvgrw, double *berr, const int *n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, const int *nparams, double *params, _Complex double *work, double *rwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment zsysvxx_$address() {
        return zsysvxx_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zsysvxx_(const char *fact, const char *uplo, const int *n, const int *nrhs, _Complex double *A, const int *lda, _Complex double *AF, const int *ldaf, int *ipiv, char *equed, double *S, _Complex double *B, const int *ldb, _Complex double *X, const int *ldx, double *rcond, double *rpvgrw, double *berr, const int *n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, const int *nparams, double *params, _Complex double *work, double *rwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static void zsysvxx_(MemorySegment fact, MemorySegment uplo, MemorySegment n, MemorySegment nrhs, MemorySegment A, MemorySegment lda, MemorySegment AF, MemorySegment ldaf, MemorySegment ipiv, MemorySegment equed, MemorySegment S, MemorySegment B, MemorySegment ldb, MemorySegment X, MemorySegment ldx, MemorySegment rcond, MemorySegment rpvgrw, MemorySegment berr, MemorySegment n_err_bnds, MemorySegment err_bnds_norm, MemorySegment err_bnds_comp, MemorySegment nparams, MemorySegment params, MemorySegment work, MemorySegment rwork, MemorySegment info, long x26, long x27, long x28) {
        var mh$ = zsysvxx_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zsysvxx_", fact, uplo, n, nrhs, A, lda, AF, ldaf, ipiv, equed, S, B, ldb, X, ldx, rcond, rpvgrw, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params, work, rwork, info, x26, x27, x28);
            }
            mh$.invokeExact(fact, uplo, n, nrhs, A, lda, AF, ldaf, ipiv, equed, S, B, ldb, X, ldx, rcond, rpvgrw, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params, work, rwork, info, x26, x27, x28);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class csyswapr_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("csyswapr_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void csyswapr_(const char *uplo, const int *n, _Complex float *A, const int *lda, const int *i1, const int *i2, size_t)
     * }
     */
    public static FunctionDescriptor csyswapr_$descriptor() {
        return csyswapr_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void csyswapr_(const char *uplo, const int *n, _Complex float *A, const int *lda, const int *i1, const int *i2, size_t)
     * }
     */
    public static MethodHandle csyswapr_$handle() {
        return csyswapr_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void csyswapr_(const char *uplo, const int *n, _Complex float *A, const int *lda, const int *i1, const int *i2, size_t)
     * }
     */
    public static MemorySegment csyswapr_$address() {
        return csyswapr_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void csyswapr_(const char *uplo, const int *n, _Complex float *A, const int *lda, const int *i1, const int *i2, size_t)
     * }
     */
    public static void csyswapr_(MemorySegment uplo, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment i1, MemorySegment i2, long x6) {
        var mh$ = csyswapr_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("csyswapr_", uplo, n, A, lda, i1, i2, x6);
            }
            mh$.invokeExact(uplo, n, A, lda, i1, i2, x6);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dsyswapr_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("dsyswapr_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dsyswapr_(const char *uplo, const int *n, double *A, const int *lda, const int *i1, const int *i2, size_t)
     * }
     */
    public static FunctionDescriptor dsyswapr_$descriptor() {
        return dsyswapr_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dsyswapr_(const char *uplo, const int *n, double *A, const int *lda, const int *i1, const int *i2, size_t)
     * }
     */
    public static MethodHandle dsyswapr_$handle() {
        return dsyswapr_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dsyswapr_(const char *uplo, const int *n, double *A, const int *lda, const int *i1, const int *i2, size_t)
     * }
     */
    public static MemorySegment dsyswapr_$address() {
        return dsyswapr_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dsyswapr_(const char *uplo, const int *n, double *A, const int *lda, const int *i1, const int *i2, size_t)
     * }
     */
    public static void dsyswapr_(MemorySegment uplo, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment i1, MemorySegment i2, long x6) {
        var mh$ = dsyswapr_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dsyswapr_", uplo, n, A, lda, i1, i2, x6);
            }
            mh$.invokeExact(uplo, n, A, lda, i1, i2, x6);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ssyswapr_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("ssyswapr_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ssyswapr_(const char *uplo, const int *n, float *A, const int *lda, const int *i1, const int *i2, size_t)
     * }
     */
    public static FunctionDescriptor ssyswapr_$descriptor() {
        return ssyswapr_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ssyswapr_(const char *uplo, const int *n, float *A, const int *lda, const int *i1, const int *i2, size_t)
     * }
     */
    public static MethodHandle ssyswapr_$handle() {
        return ssyswapr_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ssyswapr_(const char *uplo, const int *n, float *A, const int *lda, const int *i1, const int *i2, size_t)
     * }
     */
    public static MemorySegment ssyswapr_$address() {
        return ssyswapr_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ssyswapr_(const char *uplo, const int *n, float *A, const int *lda, const int *i1, const int *i2, size_t)
     * }
     */
    public static void ssyswapr_(MemorySegment uplo, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment i1, MemorySegment i2, long x6) {
        var mh$ = ssyswapr_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ssyswapr_", uplo, n, A, lda, i1, i2, x6);
            }
            mh$.invokeExact(uplo, n, A, lda, i1, i2, x6);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zsyswapr_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("zsyswapr_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zsyswapr_(const char *uplo, const int *n, _Complex double *A, const int *lda, const int *i1, const int *i2, size_t)
     * }
     */
    public static FunctionDescriptor zsyswapr_$descriptor() {
        return zsyswapr_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zsyswapr_(const char *uplo, const int *n, _Complex double *A, const int *lda, const int *i1, const int *i2, size_t)
     * }
     */
    public static MethodHandle zsyswapr_$handle() {
        return zsyswapr_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zsyswapr_(const char *uplo, const int *n, _Complex double *A, const int *lda, const int *i1, const int *i2, size_t)
     * }
     */
    public static MemorySegment zsyswapr_$address() {
        return zsyswapr_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zsyswapr_(const char *uplo, const int *n, _Complex double *A, const int *lda, const int *i1, const int *i2, size_t)
     * }
     */
    public static void zsyswapr_(MemorySegment uplo, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment i1, MemorySegment i2, long x6) {
        var mh$ = zsyswapr_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zsyswapr_", uplo, n, A, lda, i1, i2, x6);
            }
            mh$.invokeExact(uplo, n, A, lda, i1, i2, x6);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dsytrd_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("dsytrd_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dsytrd_(const char *uplo, const int *n, double *A, const int *lda, double *D, double *E, double *tau, double *work, const int *lwork, int *info, size_t)
     * }
     */
    public static FunctionDescriptor dsytrd_$descriptor() {
        return dsytrd_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dsytrd_(const char *uplo, const int *n, double *A, const int *lda, double *D, double *E, double *tau, double *work, const int *lwork, int *info, size_t)
     * }
     */
    public static MethodHandle dsytrd_$handle() {
        return dsytrd_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dsytrd_(const char *uplo, const int *n, double *A, const int *lda, double *D, double *E, double *tau, double *work, const int *lwork, int *info, size_t)
     * }
     */
    public static MemorySegment dsytrd_$address() {
        return dsytrd_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dsytrd_(const char *uplo, const int *n, double *A, const int *lda, double *D, double *E, double *tau, double *work, const int *lwork, int *info, size_t)
     * }
     */
    public static void dsytrd_(MemorySegment uplo, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment D, MemorySegment E, MemorySegment tau, MemorySegment work, MemorySegment lwork, MemorySegment info, long x10) {
        var mh$ = dsytrd_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dsytrd_", uplo, n, A, lda, D, E, tau, work, lwork, info, x10);
            }
            mh$.invokeExact(uplo, n, A, lda, D, E, tau, work, lwork, info, x10);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ssytrd_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("ssytrd_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ssytrd_(const char *uplo, const int *n, float *A, const int *lda, float *D, float *E, float *tau, float *work, const int *lwork, int *info, size_t)
     * }
     */
    public static FunctionDescriptor ssytrd_$descriptor() {
        return ssytrd_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ssytrd_(const char *uplo, const int *n, float *A, const int *lda, float *D, float *E, float *tau, float *work, const int *lwork, int *info, size_t)
     * }
     */
    public static MethodHandle ssytrd_$handle() {
        return ssytrd_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ssytrd_(const char *uplo, const int *n, float *A, const int *lda, float *D, float *E, float *tau, float *work, const int *lwork, int *info, size_t)
     * }
     */
    public static MemorySegment ssytrd_$address() {
        return ssytrd_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ssytrd_(const char *uplo, const int *n, float *A, const int *lda, float *D, float *E, float *tau, float *work, const int *lwork, int *info, size_t)
     * }
     */
    public static void ssytrd_(MemorySegment uplo, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment D, MemorySegment E, MemorySegment tau, MemorySegment work, MemorySegment lwork, MemorySegment info, long x10) {
        var mh$ = ssytrd_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ssytrd_", uplo, n, A, lda, D, E, tau, work, lwork, info, x10);
            }
            mh$.invokeExact(uplo, n, A, lda, D, E, tau, work, lwork, info, x10);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dsytrd_2stage_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("dsytrd_2stage_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dsytrd_2stage_(const char *vect, const char *uplo, const int *n, double *A, const int *lda, double *D, double *E, double *tau, double *HOUS2, const int *lhous2, double *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor dsytrd_2stage_$descriptor() {
        return dsytrd_2stage_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dsytrd_2stage_(const char *vect, const char *uplo, const int *n, double *A, const int *lda, double *D, double *E, double *tau, double *HOUS2, const int *lhous2, double *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle dsytrd_2stage_$handle() {
        return dsytrd_2stage_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dsytrd_2stage_(const char *vect, const char *uplo, const int *n, double *A, const int *lda, double *D, double *E, double *tau, double *HOUS2, const int *lhous2, double *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment dsytrd_2stage_$address() {
        return dsytrd_2stage_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dsytrd_2stage_(const char *vect, const char *uplo, const int *n, double *A, const int *lda, double *D, double *E, double *tau, double *HOUS2, const int *lhous2, double *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static void dsytrd_2stage_(MemorySegment vect, MemorySegment uplo, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment D, MemorySegment E, MemorySegment tau, MemorySegment HOUS2, MemorySegment lhous2, MemorySegment work, MemorySegment lwork, MemorySegment info, long x13, long x14) {
        var mh$ = dsytrd_2stage_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dsytrd_2stage_", vect, uplo, n, A, lda, D, E, tau, HOUS2, lhous2, work, lwork, info, x13, x14);
            }
            mh$.invokeExact(vect, uplo, n, A, lda, D, E, tau, HOUS2, lhous2, work, lwork, info, x13, x14);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ssytrd_2stage_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("ssytrd_2stage_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ssytrd_2stage_(const char *vect, const char *uplo, const int *n, float *A, const int *lda, float *D, float *E, float *tau, float *HOUS2, const int *lhous2, float *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor ssytrd_2stage_$descriptor() {
        return ssytrd_2stage_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ssytrd_2stage_(const char *vect, const char *uplo, const int *n, float *A, const int *lda, float *D, float *E, float *tau, float *HOUS2, const int *lhous2, float *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle ssytrd_2stage_$handle() {
        return ssytrd_2stage_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ssytrd_2stage_(const char *vect, const char *uplo, const int *n, float *A, const int *lda, float *D, float *E, float *tau, float *HOUS2, const int *lhous2, float *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment ssytrd_2stage_$address() {
        return ssytrd_2stage_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ssytrd_2stage_(const char *vect, const char *uplo, const int *n, float *A, const int *lda, float *D, float *E, float *tau, float *HOUS2, const int *lhous2, float *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static void ssytrd_2stage_(MemorySegment vect, MemorySegment uplo, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment D, MemorySegment E, MemorySegment tau, MemorySegment HOUS2, MemorySegment lhous2, MemorySegment work, MemorySegment lwork, MemorySegment info, long x13, long x14) {
        var mh$ = ssytrd_2stage_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ssytrd_2stage_", vect, uplo, n, A, lda, D, E, tau, HOUS2, lhous2, work, lwork, info, x13, x14);
            }
            mh$.invokeExact(vect, uplo, n, A, lda, D, E, tau, HOUS2, lhous2, work, lwork, info, x13, x14);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class csytrf_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("csytrf_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void csytrf_(const char *uplo, const int *n, _Complex float *A, const int *lda, int *ipiv, _Complex float *work, const int *lwork, int *info, size_t)
     * }
     */
    public static FunctionDescriptor csytrf_$descriptor() {
        return csytrf_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void csytrf_(const char *uplo, const int *n, _Complex float *A, const int *lda, int *ipiv, _Complex float *work, const int *lwork, int *info, size_t)
     * }
     */
    public static MethodHandle csytrf_$handle() {
        return csytrf_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void csytrf_(const char *uplo, const int *n, _Complex float *A, const int *lda, int *ipiv, _Complex float *work, const int *lwork, int *info, size_t)
     * }
     */
    public static MemorySegment csytrf_$address() {
        return csytrf_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void csytrf_(const char *uplo, const int *n, _Complex float *A, const int *lda, int *ipiv, _Complex float *work, const int *lwork, int *info, size_t)
     * }
     */
    public static void csytrf_(MemorySegment uplo, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment ipiv, MemorySegment work, MemorySegment lwork, MemorySegment info, long x8) {
        var mh$ = csytrf_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("csytrf_", uplo, n, A, lda, ipiv, work, lwork, info, x8);
            }
            mh$.invokeExact(uplo, n, A, lda, ipiv, work, lwork, info, x8);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dsytrf_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("dsytrf_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dsytrf_(const char *uplo, const int *n, double *A, const int *lda, int *ipiv, double *work, const int *lwork, int *info, size_t)
     * }
     */
    public static FunctionDescriptor dsytrf_$descriptor() {
        return dsytrf_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dsytrf_(const char *uplo, const int *n, double *A, const int *lda, int *ipiv, double *work, const int *lwork, int *info, size_t)
     * }
     */
    public static MethodHandle dsytrf_$handle() {
        return dsytrf_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dsytrf_(const char *uplo, const int *n, double *A, const int *lda, int *ipiv, double *work, const int *lwork, int *info, size_t)
     * }
     */
    public static MemorySegment dsytrf_$address() {
        return dsytrf_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dsytrf_(const char *uplo, const int *n, double *A, const int *lda, int *ipiv, double *work, const int *lwork, int *info, size_t)
     * }
     */
    public static void dsytrf_(MemorySegment uplo, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment ipiv, MemorySegment work, MemorySegment lwork, MemorySegment info, long x8) {
        var mh$ = dsytrf_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dsytrf_", uplo, n, A, lda, ipiv, work, lwork, info, x8);
            }
            mh$.invokeExact(uplo, n, A, lda, ipiv, work, lwork, info, x8);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ssytrf_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("ssytrf_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ssytrf_(const char *uplo, const int *n, float *A, const int *lda, int *ipiv, float *work, const int *lwork, int *info, size_t)
     * }
     */
    public static FunctionDescriptor ssytrf_$descriptor() {
        return ssytrf_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ssytrf_(const char *uplo, const int *n, float *A, const int *lda, int *ipiv, float *work, const int *lwork, int *info, size_t)
     * }
     */
    public static MethodHandle ssytrf_$handle() {
        return ssytrf_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ssytrf_(const char *uplo, const int *n, float *A, const int *lda, int *ipiv, float *work, const int *lwork, int *info, size_t)
     * }
     */
    public static MemorySegment ssytrf_$address() {
        return ssytrf_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ssytrf_(const char *uplo, const int *n, float *A, const int *lda, int *ipiv, float *work, const int *lwork, int *info, size_t)
     * }
     */
    public static void ssytrf_(MemorySegment uplo, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment ipiv, MemorySegment work, MemorySegment lwork, MemorySegment info, long x8) {
        var mh$ = ssytrf_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ssytrf_", uplo, n, A, lda, ipiv, work, lwork, info, x8);
            }
            mh$.invokeExact(uplo, n, A, lda, ipiv, work, lwork, info, x8);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zsytrf_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("zsytrf_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zsytrf_(const char *uplo, const int *n, _Complex double *A, const int *lda, int *ipiv, _Complex double *work, const int *lwork, int *info, size_t)
     * }
     */
    public static FunctionDescriptor zsytrf_$descriptor() {
        return zsytrf_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zsytrf_(const char *uplo, const int *n, _Complex double *A, const int *lda, int *ipiv, _Complex double *work, const int *lwork, int *info, size_t)
     * }
     */
    public static MethodHandle zsytrf_$handle() {
        return zsytrf_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zsytrf_(const char *uplo, const int *n, _Complex double *A, const int *lda, int *ipiv, _Complex double *work, const int *lwork, int *info, size_t)
     * }
     */
    public static MemorySegment zsytrf_$address() {
        return zsytrf_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zsytrf_(const char *uplo, const int *n, _Complex double *A, const int *lda, int *ipiv, _Complex double *work, const int *lwork, int *info, size_t)
     * }
     */
    public static void zsytrf_(MemorySegment uplo, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment ipiv, MemorySegment work, MemorySegment lwork, MemorySegment info, long x8) {
        var mh$ = zsytrf_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zsytrf_", uplo, n, A, lda, ipiv, work, lwork, info, x8);
            }
            mh$.invokeExact(uplo, n, A, lda, ipiv, work, lwork, info, x8);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class csytrf_aa_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("csytrf_aa_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void csytrf_aa_(const char *uplo, const int *n, _Complex float *A, const int *lda, int *ipiv, _Complex float *work, const int *lwork, int *info, size_t)
     * }
     */
    public static FunctionDescriptor csytrf_aa_$descriptor() {
        return csytrf_aa_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void csytrf_aa_(const char *uplo, const int *n, _Complex float *A, const int *lda, int *ipiv, _Complex float *work, const int *lwork, int *info, size_t)
     * }
     */
    public static MethodHandle csytrf_aa_$handle() {
        return csytrf_aa_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void csytrf_aa_(const char *uplo, const int *n, _Complex float *A, const int *lda, int *ipiv, _Complex float *work, const int *lwork, int *info, size_t)
     * }
     */
    public static MemorySegment csytrf_aa_$address() {
        return csytrf_aa_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void csytrf_aa_(const char *uplo, const int *n, _Complex float *A, const int *lda, int *ipiv, _Complex float *work, const int *lwork, int *info, size_t)
     * }
     */
    public static void csytrf_aa_(MemorySegment uplo, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment ipiv, MemorySegment work, MemorySegment lwork, MemorySegment info, long x8) {
        var mh$ = csytrf_aa_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("csytrf_aa_", uplo, n, A, lda, ipiv, work, lwork, info, x8);
            }
            mh$.invokeExact(uplo, n, A, lda, ipiv, work, lwork, info, x8);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dsytrf_aa_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("dsytrf_aa_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dsytrf_aa_(const char *uplo, const int *n, double *A, const int *lda, int *ipiv, double *work, const int *lwork, int *info, size_t)
     * }
     */
    public static FunctionDescriptor dsytrf_aa_$descriptor() {
        return dsytrf_aa_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dsytrf_aa_(const char *uplo, const int *n, double *A, const int *lda, int *ipiv, double *work, const int *lwork, int *info, size_t)
     * }
     */
    public static MethodHandle dsytrf_aa_$handle() {
        return dsytrf_aa_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dsytrf_aa_(const char *uplo, const int *n, double *A, const int *lda, int *ipiv, double *work, const int *lwork, int *info, size_t)
     * }
     */
    public static MemorySegment dsytrf_aa_$address() {
        return dsytrf_aa_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dsytrf_aa_(const char *uplo, const int *n, double *A, const int *lda, int *ipiv, double *work, const int *lwork, int *info, size_t)
     * }
     */
    public static void dsytrf_aa_(MemorySegment uplo, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment ipiv, MemorySegment work, MemorySegment lwork, MemorySegment info, long x8) {
        var mh$ = dsytrf_aa_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dsytrf_aa_", uplo, n, A, lda, ipiv, work, lwork, info, x8);
            }
            mh$.invokeExact(uplo, n, A, lda, ipiv, work, lwork, info, x8);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ssytrf_aa_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("ssytrf_aa_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ssytrf_aa_(const char *uplo, const int *n, float *A, const int *lda, int *ipiv, float *work, const int *lwork, int *info, size_t)
     * }
     */
    public static FunctionDescriptor ssytrf_aa_$descriptor() {
        return ssytrf_aa_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ssytrf_aa_(const char *uplo, const int *n, float *A, const int *lda, int *ipiv, float *work, const int *lwork, int *info, size_t)
     * }
     */
    public static MethodHandle ssytrf_aa_$handle() {
        return ssytrf_aa_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ssytrf_aa_(const char *uplo, const int *n, float *A, const int *lda, int *ipiv, float *work, const int *lwork, int *info, size_t)
     * }
     */
    public static MemorySegment ssytrf_aa_$address() {
        return ssytrf_aa_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ssytrf_aa_(const char *uplo, const int *n, float *A, const int *lda, int *ipiv, float *work, const int *lwork, int *info, size_t)
     * }
     */
    public static void ssytrf_aa_(MemorySegment uplo, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment ipiv, MemorySegment work, MemorySegment lwork, MemorySegment info, long x8) {
        var mh$ = ssytrf_aa_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ssytrf_aa_", uplo, n, A, lda, ipiv, work, lwork, info, x8);
            }
            mh$.invokeExact(uplo, n, A, lda, ipiv, work, lwork, info, x8);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zsytrf_aa_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("zsytrf_aa_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zsytrf_aa_(const char *uplo, const int *n, _Complex double *A, const int *lda, int *ipiv, _Complex double *work, const int *lwork, int *info, size_t)
     * }
     */
    public static FunctionDescriptor zsytrf_aa_$descriptor() {
        return zsytrf_aa_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zsytrf_aa_(const char *uplo, const int *n, _Complex double *A, const int *lda, int *ipiv, _Complex double *work, const int *lwork, int *info, size_t)
     * }
     */
    public static MethodHandle zsytrf_aa_$handle() {
        return zsytrf_aa_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zsytrf_aa_(const char *uplo, const int *n, _Complex double *A, const int *lda, int *ipiv, _Complex double *work, const int *lwork, int *info, size_t)
     * }
     */
    public static MemorySegment zsytrf_aa_$address() {
        return zsytrf_aa_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zsytrf_aa_(const char *uplo, const int *n, _Complex double *A, const int *lda, int *ipiv, _Complex double *work, const int *lwork, int *info, size_t)
     * }
     */
    public static void zsytrf_aa_(MemorySegment uplo, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment ipiv, MemorySegment work, MemorySegment lwork, MemorySegment info, long x8) {
        var mh$ = zsytrf_aa_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zsytrf_aa_", uplo, n, A, lda, ipiv, work, lwork, info, x8);
            }
            mh$.invokeExact(uplo, n, A, lda, ipiv, work, lwork, info, x8);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class csytrf_aa_2stage_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("csytrf_aa_2stage_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void csytrf_aa_2stage_(const char *uplo, const int *n, _Complex float *A, const int *lda, _Complex float *TB, const int *ltb, int *ipiv, int *ipiv2, _Complex float *work, const int *lwork, int *info, size_t)
     * }
     */
    public static FunctionDescriptor csytrf_aa_2stage_$descriptor() {
        return csytrf_aa_2stage_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void csytrf_aa_2stage_(const char *uplo, const int *n, _Complex float *A, const int *lda, _Complex float *TB, const int *ltb, int *ipiv, int *ipiv2, _Complex float *work, const int *lwork, int *info, size_t)
     * }
     */
    public static MethodHandle csytrf_aa_2stage_$handle() {
        return csytrf_aa_2stage_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void csytrf_aa_2stage_(const char *uplo, const int *n, _Complex float *A, const int *lda, _Complex float *TB, const int *ltb, int *ipiv, int *ipiv2, _Complex float *work, const int *lwork, int *info, size_t)
     * }
     */
    public static MemorySegment csytrf_aa_2stage_$address() {
        return csytrf_aa_2stage_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void csytrf_aa_2stage_(const char *uplo, const int *n, _Complex float *A, const int *lda, _Complex float *TB, const int *ltb, int *ipiv, int *ipiv2, _Complex float *work, const int *lwork, int *info, size_t)
     * }
     */
    public static void csytrf_aa_2stage_(MemorySegment uplo, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment TB, MemorySegment ltb, MemorySegment ipiv, MemorySegment ipiv2, MemorySegment work, MemorySegment lwork, MemorySegment info, long x11) {
        var mh$ = csytrf_aa_2stage_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("csytrf_aa_2stage_", uplo, n, A, lda, TB, ltb, ipiv, ipiv2, work, lwork, info, x11);
            }
            mh$.invokeExact(uplo, n, A, lda, TB, ltb, ipiv, ipiv2, work, lwork, info, x11);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dsytrf_aa_2stage_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("dsytrf_aa_2stage_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dsytrf_aa_2stage_(const char *uplo, const int *n, double *A, const int *lda, double *TB, const int *ltb, int *ipiv, int *ipiv2, double *work, const int *lwork, int *info, size_t)
     * }
     */
    public static FunctionDescriptor dsytrf_aa_2stage_$descriptor() {
        return dsytrf_aa_2stage_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dsytrf_aa_2stage_(const char *uplo, const int *n, double *A, const int *lda, double *TB, const int *ltb, int *ipiv, int *ipiv2, double *work, const int *lwork, int *info, size_t)
     * }
     */
    public static MethodHandle dsytrf_aa_2stage_$handle() {
        return dsytrf_aa_2stage_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dsytrf_aa_2stage_(const char *uplo, const int *n, double *A, const int *lda, double *TB, const int *ltb, int *ipiv, int *ipiv2, double *work, const int *lwork, int *info, size_t)
     * }
     */
    public static MemorySegment dsytrf_aa_2stage_$address() {
        return dsytrf_aa_2stage_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dsytrf_aa_2stage_(const char *uplo, const int *n, double *A, const int *lda, double *TB, const int *ltb, int *ipiv, int *ipiv2, double *work, const int *lwork, int *info, size_t)
     * }
     */
    public static void dsytrf_aa_2stage_(MemorySegment uplo, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment TB, MemorySegment ltb, MemorySegment ipiv, MemorySegment ipiv2, MemorySegment work, MemorySegment lwork, MemorySegment info, long x11) {
        var mh$ = dsytrf_aa_2stage_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dsytrf_aa_2stage_", uplo, n, A, lda, TB, ltb, ipiv, ipiv2, work, lwork, info, x11);
            }
            mh$.invokeExact(uplo, n, A, lda, TB, ltb, ipiv, ipiv2, work, lwork, info, x11);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ssytrf_aa_2stage_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("ssytrf_aa_2stage_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ssytrf_aa_2stage_(const char *uplo, const int *n, float *A, const int *lda, float *TB, const int *ltb, int *ipiv, int *ipiv2, float *work, const int *lwork, int *info, size_t)
     * }
     */
    public static FunctionDescriptor ssytrf_aa_2stage_$descriptor() {
        return ssytrf_aa_2stage_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ssytrf_aa_2stage_(const char *uplo, const int *n, float *A, const int *lda, float *TB, const int *ltb, int *ipiv, int *ipiv2, float *work, const int *lwork, int *info, size_t)
     * }
     */
    public static MethodHandle ssytrf_aa_2stage_$handle() {
        return ssytrf_aa_2stage_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ssytrf_aa_2stage_(const char *uplo, const int *n, float *A, const int *lda, float *TB, const int *ltb, int *ipiv, int *ipiv2, float *work, const int *lwork, int *info, size_t)
     * }
     */
    public static MemorySegment ssytrf_aa_2stage_$address() {
        return ssytrf_aa_2stage_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ssytrf_aa_2stage_(const char *uplo, const int *n, float *A, const int *lda, float *TB, const int *ltb, int *ipiv, int *ipiv2, float *work, const int *lwork, int *info, size_t)
     * }
     */
    public static void ssytrf_aa_2stage_(MemorySegment uplo, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment TB, MemorySegment ltb, MemorySegment ipiv, MemorySegment ipiv2, MemorySegment work, MemorySegment lwork, MemorySegment info, long x11) {
        var mh$ = ssytrf_aa_2stage_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ssytrf_aa_2stage_", uplo, n, A, lda, TB, ltb, ipiv, ipiv2, work, lwork, info, x11);
            }
            mh$.invokeExact(uplo, n, A, lda, TB, ltb, ipiv, ipiv2, work, lwork, info, x11);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zsytrf_aa_2stage_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("zsytrf_aa_2stage_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zsytrf_aa_2stage_(const char *uplo, const int *n, _Complex double *A, const int *lda, _Complex double *TB, const int *ltb, int *ipiv, int *ipiv2, _Complex double *work, const int *lwork, int *info, size_t)
     * }
     */
    public static FunctionDescriptor zsytrf_aa_2stage_$descriptor() {
        return zsytrf_aa_2stage_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zsytrf_aa_2stage_(const char *uplo, const int *n, _Complex double *A, const int *lda, _Complex double *TB, const int *ltb, int *ipiv, int *ipiv2, _Complex double *work, const int *lwork, int *info, size_t)
     * }
     */
    public static MethodHandle zsytrf_aa_2stage_$handle() {
        return zsytrf_aa_2stage_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zsytrf_aa_2stage_(const char *uplo, const int *n, _Complex double *A, const int *lda, _Complex double *TB, const int *ltb, int *ipiv, int *ipiv2, _Complex double *work, const int *lwork, int *info, size_t)
     * }
     */
    public static MemorySegment zsytrf_aa_2stage_$address() {
        return zsytrf_aa_2stage_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zsytrf_aa_2stage_(const char *uplo, const int *n, _Complex double *A, const int *lda, _Complex double *TB, const int *ltb, int *ipiv, int *ipiv2, _Complex double *work, const int *lwork, int *info, size_t)
     * }
     */
    public static void zsytrf_aa_2stage_(MemorySegment uplo, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment TB, MemorySegment ltb, MemorySegment ipiv, MemorySegment ipiv2, MemorySegment work, MemorySegment lwork, MemorySegment info, long x11) {
        var mh$ = zsytrf_aa_2stage_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zsytrf_aa_2stage_", uplo, n, A, lda, TB, ltb, ipiv, ipiv2, work, lwork, info, x11);
            }
            mh$.invokeExact(uplo, n, A, lda, TB, ltb, ipiv, ipiv2, work, lwork, info, x11);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class csytrf_rk_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("csytrf_rk_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void csytrf_rk_(const char *uplo, const int *n, _Complex float *A, const int *lda, _Complex float *E, int *ipiv, _Complex float *work, const int *lwork, int *info, size_t)
     * }
     */
    public static FunctionDescriptor csytrf_rk_$descriptor() {
        return csytrf_rk_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void csytrf_rk_(const char *uplo, const int *n, _Complex float *A, const int *lda, _Complex float *E, int *ipiv, _Complex float *work, const int *lwork, int *info, size_t)
     * }
     */
    public static MethodHandle csytrf_rk_$handle() {
        return csytrf_rk_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void csytrf_rk_(const char *uplo, const int *n, _Complex float *A, const int *lda, _Complex float *E, int *ipiv, _Complex float *work, const int *lwork, int *info, size_t)
     * }
     */
    public static MemorySegment csytrf_rk_$address() {
        return csytrf_rk_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void csytrf_rk_(const char *uplo, const int *n, _Complex float *A, const int *lda, _Complex float *E, int *ipiv, _Complex float *work, const int *lwork, int *info, size_t)
     * }
     */
    public static void csytrf_rk_(MemorySegment uplo, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment E, MemorySegment ipiv, MemorySegment work, MemorySegment lwork, MemorySegment info, long x9) {
        var mh$ = csytrf_rk_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("csytrf_rk_", uplo, n, A, lda, E, ipiv, work, lwork, info, x9);
            }
            mh$.invokeExact(uplo, n, A, lda, E, ipiv, work, lwork, info, x9);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dsytrf_rk_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("dsytrf_rk_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dsytrf_rk_(const char *uplo, const int *n, double *A, const int *lda, double *E, int *ipiv, double *work, const int *lwork, int *info, size_t)
     * }
     */
    public static FunctionDescriptor dsytrf_rk_$descriptor() {
        return dsytrf_rk_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dsytrf_rk_(const char *uplo, const int *n, double *A, const int *lda, double *E, int *ipiv, double *work, const int *lwork, int *info, size_t)
     * }
     */
    public static MethodHandle dsytrf_rk_$handle() {
        return dsytrf_rk_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dsytrf_rk_(const char *uplo, const int *n, double *A, const int *lda, double *E, int *ipiv, double *work, const int *lwork, int *info, size_t)
     * }
     */
    public static MemorySegment dsytrf_rk_$address() {
        return dsytrf_rk_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dsytrf_rk_(const char *uplo, const int *n, double *A, const int *lda, double *E, int *ipiv, double *work, const int *lwork, int *info, size_t)
     * }
     */
    public static void dsytrf_rk_(MemorySegment uplo, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment E, MemorySegment ipiv, MemorySegment work, MemorySegment lwork, MemorySegment info, long x9) {
        var mh$ = dsytrf_rk_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dsytrf_rk_", uplo, n, A, lda, E, ipiv, work, lwork, info, x9);
            }
            mh$.invokeExact(uplo, n, A, lda, E, ipiv, work, lwork, info, x9);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ssytrf_rk_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("ssytrf_rk_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ssytrf_rk_(const char *uplo, const int *n, float *A, const int *lda, float *E, int *ipiv, float *work, const int *lwork, int *info, size_t)
     * }
     */
    public static FunctionDescriptor ssytrf_rk_$descriptor() {
        return ssytrf_rk_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ssytrf_rk_(const char *uplo, const int *n, float *A, const int *lda, float *E, int *ipiv, float *work, const int *lwork, int *info, size_t)
     * }
     */
    public static MethodHandle ssytrf_rk_$handle() {
        return ssytrf_rk_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ssytrf_rk_(const char *uplo, const int *n, float *A, const int *lda, float *E, int *ipiv, float *work, const int *lwork, int *info, size_t)
     * }
     */
    public static MemorySegment ssytrf_rk_$address() {
        return ssytrf_rk_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ssytrf_rk_(const char *uplo, const int *n, float *A, const int *lda, float *E, int *ipiv, float *work, const int *lwork, int *info, size_t)
     * }
     */
    public static void ssytrf_rk_(MemorySegment uplo, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment E, MemorySegment ipiv, MemorySegment work, MemorySegment lwork, MemorySegment info, long x9) {
        var mh$ = ssytrf_rk_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ssytrf_rk_", uplo, n, A, lda, E, ipiv, work, lwork, info, x9);
            }
            mh$.invokeExact(uplo, n, A, lda, E, ipiv, work, lwork, info, x9);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zsytrf_rk_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("zsytrf_rk_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zsytrf_rk_(const char *uplo, const int *n, _Complex double *A, const int *lda, _Complex double *E, int *ipiv, _Complex double *work, const int *lwork, int *info, size_t)
     * }
     */
    public static FunctionDescriptor zsytrf_rk_$descriptor() {
        return zsytrf_rk_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zsytrf_rk_(const char *uplo, const int *n, _Complex double *A, const int *lda, _Complex double *E, int *ipiv, _Complex double *work, const int *lwork, int *info, size_t)
     * }
     */
    public static MethodHandle zsytrf_rk_$handle() {
        return zsytrf_rk_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zsytrf_rk_(const char *uplo, const int *n, _Complex double *A, const int *lda, _Complex double *E, int *ipiv, _Complex double *work, const int *lwork, int *info, size_t)
     * }
     */
    public static MemorySegment zsytrf_rk_$address() {
        return zsytrf_rk_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zsytrf_rk_(const char *uplo, const int *n, _Complex double *A, const int *lda, _Complex double *E, int *ipiv, _Complex double *work, const int *lwork, int *info, size_t)
     * }
     */
    public static void zsytrf_rk_(MemorySegment uplo, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment E, MemorySegment ipiv, MemorySegment work, MemorySegment lwork, MemorySegment info, long x9) {
        var mh$ = zsytrf_rk_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zsytrf_rk_", uplo, n, A, lda, E, ipiv, work, lwork, info, x9);
            }
            mh$.invokeExact(uplo, n, A, lda, E, ipiv, work, lwork, info, x9);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class csytrf_rook_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("csytrf_rook_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void csytrf_rook_(const char *uplo, const int *n, _Complex float *A, const int *lda, int *ipiv, _Complex float *work, const int *lwork, int *info, size_t)
     * }
     */
    public static FunctionDescriptor csytrf_rook_$descriptor() {
        return csytrf_rook_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void csytrf_rook_(const char *uplo, const int *n, _Complex float *A, const int *lda, int *ipiv, _Complex float *work, const int *lwork, int *info, size_t)
     * }
     */
    public static MethodHandle csytrf_rook_$handle() {
        return csytrf_rook_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void csytrf_rook_(const char *uplo, const int *n, _Complex float *A, const int *lda, int *ipiv, _Complex float *work, const int *lwork, int *info, size_t)
     * }
     */
    public static MemorySegment csytrf_rook_$address() {
        return csytrf_rook_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void csytrf_rook_(const char *uplo, const int *n, _Complex float *A, const int *lda, int *ipiv, _Complex float *work, const int *lwork, int *info, size_t)
     * }
     */
    public static void csytrf_rook_(MemorySegment uplo, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment ipiv, MemorySegment work, MemorySegment lwork, MemorySegment info, long x8) {
        var mh$ = csytrf_rook_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("csytrf_rook_", uplo, n, A, lda, ipiv, work, lwork, info, x8);
            }
            mh$.invokeExact(uplo, n, A, lda, ipiv, work, lwork, info, x8);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dsytrf_rook_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("dsytrf_rook_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dsytrf_rook_(const char *uplo, const int *n, double *A, const int *lda, int *ipiv, double *work, const int *lwork, int *info, size_t)
     * }
     */
    public static FunctionDescriptor dsytrf_rook_$descriptor() {
        return dsytrf_rook_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dsytrf_rook_(const char *uplo, const int *n, double *A, const int *lda, int *ipiv, double *work, const int *lwork, int *info, size_t)
     * }
     */
    public static MethodHandle dsytrf_rook_$handle() {
        return dsytrf_rook_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dsytrf_rook_(const char *uplo, const int *n, double *A, const int *lda, int *ipiv, double *work, const int *lwork, int *info, size_t)
     * }
     */
    public static MemorySegment dsytrf_rook_$address() {
        return dsytrf_rook_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dsytrf_rook_(const char *uplo, const int *n, double *A, const int *lda, int *ipiv, double *work, const int *lwork, int *info, size_t)
     * }
     */
    public static void dsytrf_rook_(MemorySegment uplo, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment ipiv, MemorySegment work, MemorySegment lwork, MemorySegment info, long x8) {
        var mh$ = dsytrf_rook_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dsytrf_rook_", uplo, n, A, lda, ipiv, work, lwork, info, x8);
            }
            mh$.invokeExact(uplo, n, A, lda, ipiv, work, lwork, info, x8);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ssytrf_rook_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("ssytrf_rook_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ssytrf_rook_(const char *uplo, const int *n, float *A, const int *lda, int *ipiv, float *work, const int *lwork, int *info, size_t)
     * }
     */
    public static FunctionDescriptor ssytrf_rook_$descriptor() {
        return ssytrf_rook_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ssytrf_rook_(const char *uplo, const int *n, float *A, const int *lda, int *ipiv, float *work, const int *lwork, int *info, size_t)
     * }
     */
    public static MethodHandle ssytrf_rook_$handle() {
        return ssytrf_rook_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ssytrf_rook_(const char *uplo, const int *n, float *A, const int *lda, int *ipiv, float *work, const int *lwork, int *info, size_t)
     * }
     */
    public static MemorySegment ssytrf_rook_$address() {
        return ssytrf_rook_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ssytrf_rook_(const char *uplo, const int *n, float *A, const int *lda, int *ipiv, float *work, const int *lwork, int *info, size_t)
     * }
     */
    public static void ssytrf_rook_(MemorySegment uplo, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment ipiv, MemorySegment work, MemorySegment lwork, MemorySegment info, long x8) {
        var mh$ = ssytrf_rook_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ssytrf_rook_", uplo, n, A, lda, ipiv, work, lwork, info, x8);
            }
            mh$.invokeExact(uplo, n, A, lda, ipiv, work, lwork, info, x8);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zsytrf_rook_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("zsytrf_rook_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zsytrf_rook_(const char *uplo, const int *n, _Complex double *A, const int *lda, int *ipiv, _Complex double *work, const int *lwork, int *info, size_t)
     * }
     */
    public static FunctionDescriptor zsytrf_rook_$descriptor() {
        return zsytrf_rook_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zsytrf_rook_(const char *uplo, const int *n, _Complex double *A, const int *lda, int *ipiv, _Complex double *work, const int *lwork, int *info, size_t)
     * }
     */
    public static MethodHandle zsytrf_rook_$handle() {
        return zsytrf_rook_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zsytrf_rook_(const char *uplo, const int *n, _Complex double *A, const int *lda, int *ipiv, _Complex double *work, const int *lwork, int *info, size_t)
     * }
     */
    public static MemorySegment zsytrf_rook_$address() {
        return zsytrf_rook_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zsytrf_rook_(const char *uplo, const int *n, _Complex double *A, const int *lda, int *ipiv, _Complex double *work, const int *lwork, int *info, size_t)
     * }
     */
    public static void zsytrf_rook_(MemorySegment uplo, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment ipiv, MemorySegment work, MemorySegment lwork, MemorySegment info, long x8) {
        var mh$ = zsytrf_rook_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zsytrf_rook_", uplo, n, A, lda, ipiv, work, lwork, info, x8);
            }
            mh$.invokeExact(uplo, n, A, lda, ipiv, work, lwork, info, x8);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class csytri_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("csytri_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void csytri_(const char *uplo, const int *n, _Complex float *A, const int *lda, const int *ipiv, _Complex float *work, int *info, size_t)
     * }
     */
    public static FunctionDescriptor csytri_$descriptor() {
        return csytri_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void csytri_(const char *uplo, const int *n, _Complex float *A, const int *lda, const int *ipiv, _Complex float *work, int *info, size_t)
     * }
     */
    public static MethodHandle csytri_$handle() {
        return csytri_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void csytri_(const char *uplo, const int *n, _Complex float *A, const int *lda, const int *ipiv, _Complex float *work, int *info, size_t)
     * }
     */
    public static MemorySegment csytri_$address() {
        return csytri_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void csytri_(const char *uplo, const int *n, _Complex float *A, const int *lda, const int *ipiv, _Complex float *work, int *info, size_t)
     * }
     */
    public static void csytri_(MemorySegment uplo, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment ipiv, MemorySegment work, MemorySegment info, long x7) {
        var mh$ = csytri_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("csytri_", uplo, n, A, lda, ipiv, work, info, x7);
            }
            mh$.invokeExact(uplo, n, A, lda, ipiv, work, info, x7);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dsytri_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("dsytri_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dsytri_(const char *uplo, const int *n, double *A, const int *lda, const int *ipiv, double *work, int *info, size_t)
     * }
     */
    public static FunctionDescriptor dsytri_$descriptor() {
        return dsytri_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dsytri_(const char *uplo, const int *n, double *A, const int *lda, const int *ipiv, double *work, int *info, size_t)
     * }
     */
    public static MethodHandle dsytri_$handle() {
        return dsytri_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dsytri_(const char *uplo, const int *n, double *A, const int *lda, const int *ipiv, double *work, int *info, size_t)
     * }
     */
    public static MemorySegment dsytri_$address() {
        return dsytri_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dsytri_(const char *uplo, const int *n, double *A, const int *lda, const int *ipiv, double *work, int *info, size_t)
     * }
     */
    public static void dsytri_(MemorySegment uplo, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment ipiv, MemorySegment work, MemorySegment info, long x7) {
        var mh$ = dsytri_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dsytri_", uplo, n, A, lda, ipiv, work, info, x7);
            }
            mh$.invokeExact(uplo, n, A, lda, ipiv, work, info, x7);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ssytri_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("ssytri_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ssytri_(const char *uplo, const int *n, float *A, const int *lda, const int *ipiv, float *work, int *info, size_t)
     * }
     */
    public static FunctionDescriptor ssytri_$descriptor() {
        return ssytri_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ssytri_(const char *uplo, const int *n, float *A, const int *lda, const int *ipiv, float *work, int *info, size_t)
     * }
     */
    public static MethodHandle ssytri_$handle() {
        return ssytri_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ssytri_(const char *uplo, const int *n, float *A, const int *lda, const int *ipiv, float *work, int *info, size_t)
     * }
     */
    public static MemorySegment ssytri_$address() {
        return ssytri_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ssytri_(const char *uplo, const int *n, float *A, const int *lda, const int *ipiv, float *work, int *info, size_t)
     * }
     */
    public static void ssytri_(MemorySegment uplo, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment ipiv, MemorySegment work, MemorySegment info, long x7) {
        var mh$ = ssytri_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ssytri_", uplo, n, A, lda, ipiv, work, info, x7);
            }
            mh$.invokeExact(uplo, n, A, lda, ipiv, work, info, x7);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zsytri_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("zsytri_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zsytri_(const char *uplo, const int *n, _Complex double *A, const int *lda, const int *ipiv, _Complex double *work, int *info, size_t)
     * }
     */
    public static FunctionDescriptor zsytri_$descriptor() {
        return zsytri_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zsytri_(const char *uplo, const int *n, _Complex double *A, const int *lda, const int *ipiv, _Complex double *work, int *info, size_t)
     * }
     */
    public static MethodHandle zsytri_$handle() {
        return zsytri_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zsytri_(const char *uplo, const int *n, _Complex double *A, const int *lda, const int *ipiv, _Complex double *work, int *info, size_t)
     * }
     */
    public static MemorySegment zsytri_$address() {
        return zsytri_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zsytri_(const char *uplo, const int *n, _Complex double *A, const int *lda, const int *ipiv, _Complex double *work, int *info, size_t)
     * }
     */
    public static void zsytri_(MemorySegment uplo, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment ipiv, MemorySegment work, MemorySegment info, long x7) {
        var mh$ = zsytri_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zsytri_", uplo, n, A, lda, ipiv, work, info, x7);
            }
            mh$.invokeExact(uplo, n, A, lda, ipiv, work, info, x7);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class csytri2_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("csytri2_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void csytri2_(const char *uplo, const int *n, _Complex float *A, const int *lda, const int *ipiv, _Complex float *work, const int *lwork, int *info, size_t)
     * }
     */
    public static FunctionDescriptor csytri2_$descriptor() {
        return csytri2_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void csytri2_(const char *uplo, const int *n, _Complex float *A, const int *lda, const int *ipiv, _Complex float *work, const int *lwork, int *info, size_t)
     * }
     */
    public static MethodHandle csytri2_$handle() {
        return csytri2_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void csytri2_(const char *uplo, const int *n, _Complex float *A, const int *lda, const int *ipiv, _Complex float *work, const int *lwork, int *info, size_t)
     * }
     */
    public static MemorySegment csytri2_$address() {
        return csytri2_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void csytri2_(const char *uplo, const int *n, _Complex float *A, const int *lda, const int *ipiv, _Complex float *work, const int *lwork, int *info, size_t)
     * }
     */
    public static void csytri2_(MemorySegment uplo, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment ipiv, MemorySegment work, MemorySegment lwork, MemorySegment info, long x8) {
        var mh$ = csytri2_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("csytri2_", uplo, n, A, lda, ipiv, work, lwork, info, x8);
            }
            mh$.invokeExact(uplo, n, A, lda, ipiv, work, lwork, info, x8);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dsytri2_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("dsytri2_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dsytri2_(const char *uplo, const int *n, double *A, const int *lda, const int *ipiv, double *work, const int *lwork, int *info, size_t)
     * }
     */
    public static FunctionDescriptor dsytri2_$descriptor() {
        return dsytri2_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dsytri2_(const char *uplo, const int *n, double *A, const int *lda, const int *ipiv, double *work, const int *lwork, int *info, size_t)
     * }
     */
    public static MethodHandle dsytri2_$handle() {
        return dsytri2_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dsytri2_(const char *uplo, const int *n, double *A, const int *lda, const int *ipiv, double *work, const int *lwork, int *info, size_t)
     * }
     */
    public static MemorySegment dsytri2_$address() {
        return dsytri2_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dsytri2_(const char *uplo, const int *n, double *A, const int *lda, const int *ipiv, double *work, const int *lwork, int *info, size_t)
     * }
     */
    public static void dsytri2_(MemorySegment uplo, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment ipiv, MemorySegment work, MemorySegment lwork, MemorySegment info, long x8) {
        var mh$ = dsytri2_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dsytri2_", uplo, n, A, lda, ipiv, work, lwork, info, x8);
            }
            mh$.invokeExact(uplo, n, A, lda, ipiv, work, lwork, info, x8);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ssytri2_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("ssytri2_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ssytri2_(const char *uplo, const int *n, float *A, const int *lda, const int *ipiv, float *work, const int *lwork, int *info, size_t)
     * }
     */
    public static FunctionDescriptor ssytri2_$descriptor() {
        return ssytri2_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ssytri2_(const char *uplo, const int *n, float *A, const int *lda, const int *ipiv, float *work, const int *lwork, int *info, size_t)
     * }
     */
    public static MethodHandle ssytri2_$handle() {
        return ssytri2_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ssytri2_(const char *uplo, const int *n, float *A, const int *lda, const int *ipiv, float *work, const int *lwork, int *info, size_t)
     * }
     */
    public static MemorySegment ssytri2_$address() {
        return ssytri2_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ssytri2_(const char *uplo, const int *n, float *A, const int *lda, const int *ipiv, float *work, const int *lwork, int *info, size_t)
     * }
     */
    public static void ssytri2_(MemorySegment uplo, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment ipiv, MemorySegment work, MemorySegment lwork, MemorySegment info, long x8) {
        var mh$ = ssytri2_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ssytri2_", uplo, n, A, lda, ipiv, work, lwork, info, x8);
            }
            mh$.invokeExact(uplo, n, A, lda, ipiv, work, lwork, info, x8);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zsytri2_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("zsytri2_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zsytri2_(const char *uplo, const int *n, _Complex double *A, const int *lda, const int *ipiv, _Complex double *work, const int *lwork, int *info, size_t)
     * }
     */
    public static FunctionDescriptor zsytri2_$descriptor() {
        return zsytri2_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zsytri2_(const char *uplo, const int *n, _Complex double *A, const int *lda, const int *ipiv, _Complex double *work, const int *lwork, int *info, size_t)
     * }
     */
    public static MethodHandle zsytri2_$handle() {
        return zsytri2_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zsytri2_(const char *uplo, const int *n, _Complex double *A, const int *lda, const int *ipiv, _Complex double *work, const int *lwork, int *info, size_t)
     * }
     */
    public static MemorySegment zsytri2_$address() {
        return zsytri2_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zsytri2_(const char *uplo, const int *n, _Complex double *A, const int *lda, const int *ipiv, _Complex double *work, const int *lwork, int *info, size_t)
     * }
     */
    public static void zsytri2_(MemorySegment uplo, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment ipiv, MemorySegment work, MemorySegment lwork, MemorySegment info, long x8) {
        var mh$ = zsytri2_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zsytri2_", uplo, n, A, lda, ipiv, work, lwork, info, x8);
            }
            mh$.invokeExact(uplo, n, A, lda, ipiv, work, lwork, info, x8);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class csytri2x_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("csytri2x_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void csytri2x_(const char *uplo, const int *n, _Complex float *A, const int *lda, const int *ipiv, _Complex float *work, const int *nb, int *info, size_t)
     * }
     */
    public static FunctionDescriptor csytri2x_$descriptor() {
        return csytri2x_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void csytri2x_(const char *uplo, const int *n, _Complex float *A, const int *lda, const int *ipiv, _Complex float *work, const int *nb, int *info, size_t)
     * }
     */
    public static MethodHandle csytri2x_$handle() {
        return csytri2x_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void csytri2x_(const char *uplo, const int *n, _Complex float *A, const int *lda, const int *ipiv, _Complex float *work, const int *nb, int *info, size_t)
     * }
     */
    public static MemorySegment csytri2x_$address() {
        return csytri2x_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void csytri2x_(const char *uplo, const int *n, _Complex float *A, const int *lda, const int *ipiv, _Complex float *work, const int *nb, int *info, size_t)
     * }
     */
    public static void csytri2x_(MemorySegment uplo, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment ipiv, MemorySegment work, MemorySegment nb, MemorySegment info, long x8) {
        var mh$ = csytri2x_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("csytri2x_", uplo, n, A, lda, ipiv, work, nb, info, x8);
            }
            mh$.invokeExact(uplo, n, A, lda, ipiv, work, nb, info, x8);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dsytri2x_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("dsytri2x_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dsytri2x_(const char *uplo, const int *n, double *A, const int *lda, const int *ipiv, double *work, const int *nb, int *info, size_t)
     * }
     */
    public static FunctionDescriptor dsytri2x_$descriptor() {
        return dsytri2x_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dsytri2x_(const char *uplo, const int *n, double *A, const int *lda, const int *ipiv, double *work, const int *nb, int *info, size_t)
     * }
     */
    public static MethodHandle dsytri2x_$handle() {
        return dsytri2x_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dsytri2x_(const char *uplo, const int *n, double *A, const int *lda, const int *ipiv, double *work, const int *nb, int *info, size_t)
     * }
     */
    public static MemorySegment dsytri2x_$address() {
        return dsytri2x_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dsytri2x_(const char *uplo, const int *n, double *A, const int *lda, const int *ipiv, double *work, const int *nb, int *info, size_t)
     * }
     */
    public static void dsytri2x_(MemorySegment uplo, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment ipiv, MemorySegment work, MemorySegment nb, MemorySegment info, long x8) {
        var mh$ = dsytri2x_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dsytri2x_", uplo, n, A, lda, ipiv, work, nb, info, x8);
            }
            mh$.invokeExact(uplo, n, A, lda, ipiv, work, nb, info, x8);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ssytri2x_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("ssytri2x_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ssytri2x_(const char *uplo, const int *n, float *A, const int *lda, const int *ipiv, float *work, const int *nb, int *info, size_t)
     * }
     */
    public static FunctionDescriptor ssytri2x_$descriptor() {
        return ssytri2x_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ssytri2x_(const char *uplo, const int *n, float *A, const int *lda, const int *ipiv, float *work, const int *nb, int *info, size_t)
     * }
     */
    public static MethodHandle ssytri2x_$handle() {
        return ssytri2x_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ssytri2x_(const char *uplo, const int *n, float *A, const int *lda, const int *ipiv, float *work, const int *nb, int *info, size_t)
     * }
     */
    public static MemorySegment ssytri2x_$address() {
        return ssytri2x_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ssytri2x_(const char *uplo, const int *n, float *A, const int *lda, const int *ipiv, float *work, const int *nb, int *info, size_t)
     * }
     */
    public static void ssytri2x_(MemorySegment uplo, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment ipiv, MemorySegment work, MemorySegment nb, MemorySegment info, long x8) {
        var mh$ = ssytri2x_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ssytri2x_", uplo, n, A, lda, ipiv, work, nb, info, x8);
            }
            mh$.invokeExact(uplo, n, A, lda, ipiv, work, nb, info, x8);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zsytri2x_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("zsytri2x_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zsytri2x_(const char *uplo, const int *n, _Complex double *A, const int *lda, const int *ipiv, _Complex double *work, const int *nb, int *info, size_t)
     * }
     */
    public static FunctionDescriptor zsytri2x_$descriptor() {
        return zsytri2x_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zsytri2x_(const char *uplo, const int *n, _Complex double *A, const int *lda, const int *ipiv, _Complex double *work, const int *nb, int *info, size_t)
     * }
     */
    public static MethodHandle zsytri2x_$handle() {
        return zsytri2x_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zsytri2x_(const char *uplo, const int *n, _Complex double *A, const int *lda, const int *ipiv, _Complex double *work, const int *nb, int *info, size_t)
     * }
     */
    public static MemorySegment zsytri2x_$address() {
        return zsytri2x_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zsytri2x_(const char *uplo, const int *n, _Complex double *A, const int *lda, const int *ipiv, _Complex double *work, const int *nb, int *info, size_t)
     * }
     */
    public static void zsytri2x_(MemorySegment uplo, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment ipiv, MemorySegment work, MemorySegment nb, MemorySegment info, long x8) {
        var mh$ = zsytri2x_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zsytri2x_", uplo, n, A, lda, ipiv, work, nb, info, x8);
            }
            mh$.invokeExact(uplo, n, A, lda, ipiv, work, nb, info, x8);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class csytri_3_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("csytri_3_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void csytri_3_(const char *uplo, const int *n, _Complex float *A, const int *lda, const _Complex float *E, const int *ipiv, _Complex float *work, const int *lwork, int *info, size_t)
     * }
     */
    public static FunctionDescriptor csytri_3_$descriptor() {
        return csytri_3_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void csytri_3_(const char *uplo, const int *n, _Complex float *A, const int *lda, const _Complex float *E, const int *ipiv, _Complex float *work, const int *lwork, int *info, size_t)
     * }
     */
    public static MethodHandle csytri_3_$handle() {
        return csytri_3_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void csytri_3_(const char *uplo, const int *n, _Complex float *A, const int *lda, const _Complex float *E, const int *ipiv, _Complex float *work, const int *lwork, int *info, size_t)
     * }
     */
    public static MemorySegment csytri_3_$address() {
        return csytri_3_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void csytri_3_(const char *uplo, const int *n, _Complex float *A, const int *lda, const _Complex float *E, const int *ipiv, _Complex float *work, const int *lwork, int *info, size_t)
     * }
     */
    public static void csytri_3_(MemorySegment uplo, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment E, MemorySegment ipiv, MemorySegment work, MemorySegment lwork, MemorySegment info, long x9) {
        var mh$ = csytri_3_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("csytri_3_", uplo, n, A, lda, E, ipiv, work, lwork, info, x9);
            }
            mh$.invokeExact(uplo, n, A, lda, E, ipiv, work, lwork, info, x9);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dsytri_3_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("dsytri_3_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dsytri_3_(const char *uplo, const int *n, double *A, const int *lda, const double *E, const int *ipiv, double *work, const int *lwork, int *info, size_t)
     * }
     */
    public static FunctionDescriptor dsytri_3_$descriptor() {
        return dsytri_3_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dsytri_3_(const char *uplo, const int *n, double *A, const int *lda, const double *E, const int *ipiv, double *work, const int *lwork, int *info, size_t)
     * }
     */
    public static MethodHandle dsytri_3_$handle() {
        return dsytri_3_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dsytri_3_(const char *uplo, const int *n, double *A, const int *lda, const double *E, const int *ipiv, double *work, const int *lwork, int *info, size_t)
     * }
     */
    public static MemorySegment dsytri_3_$address() {
        return dsytri_3_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dsytri_3_(const char *uplo, const int *n, double *A, const int *lda, const double *E, const int *ipiv, double *work, const int *lwork, int *info, size_t)
     * }
     */
    public static void dsytri_3_(MemorySegment uplo, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment E, MemorySegment ipiv, MemorySegment work, MemorySegment lwork, MemorySegment info, long x9) {
        var mh$ = dsytri_3_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dsytri_3_", uplo, n, A, lda, E, ipiv, work, lwork, info, x9);
            }
            mh$.invokeExact(uplo, n, A, lda, E, ipiv, work, lwork, info, x9);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ssytri_3_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("ssytri_3_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ssytri_3_(const char *uplo, const int *n, float *A, const int *lda, const float *E, const int *ipiv, float *work, const int *lwork, int *info, size_t)
     * }
     */
    public static FunctionDescriptor ssytri_3_$descriptor() {
        return ssytri_3_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ssytri_3_(const char *uplo, const int *n, float *A, const int *lda, const float *E, const int *ipiv, float *work, const int *lwork, int *info, size_t)
     * }
     */
    public static MethodHandle ssytri_3_$handle() {
        return ssytri_3_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ssytri_3_(const char *uplo, const int *n, float *A, const int *lda, const float *E, const int *ipiv, float *work, const int *lwork, int *info, size_t)
     * }
     */
    public static MemorySegment ssytri_3_$address() {
        return ssytri_3_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ssytri_3_(const char *uplo, const int *n, float *A, const int *lda, const float *E, const int *ipiv, float *work, const int *lwork, int *info, size_t)
     * }
     */
    public static void ssytri_3_(MemorySegment uplo, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment E, MemorySegment ipiv, MemorySegment work, MemorySegment lwork, MemorySegment info, long x9) {
        var mh$ = ssytri_3_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ssytri_3_", uplo, n, A, lda, E, ipiv, work, lwork, info, x9);
            }
            mh$.invokeExact(uplo, n, A, lda, E, ipiv, work, lwork, info, x9);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zsytri_3_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("zsytri_3_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zsytri_3_(const char *uplo, const int *n, _Complex double *A, const int *lda, const _Complex double *E, const int *ipiv, _Complex double *work, const int *lwork, int *info, size_t)
     * }
     */
    public static FunctionDescriptor zsytri_3_$descriptor() {
        return zsytri_3_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zsytri_3_(const char *uplo, const int *n, _Complex double *A, const int *lda, const _Complex double *E, const int *ipiv, _Complex double *work, const int *lwork, int *info, size_t)
     * }
     */
    public static MethodHandle zsytri_3_$handle() {
        return zsytri_3_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zsytri_3_(const char *uplo, const int *n, _Complex double *A, const int *lda, const _Complex double *E, const int *ipiv, _Complex double *work, const int *lwork, int *info, size_t)
     * }
     */
    public static MemorySegment zsytri_3_$address() {
        return zsytri_3_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zsytri_3_(const char *uplo, const int *n, _Complex double *A, const int *lda, const _Complex double *E, const int *ipiv, _Complex double *work, const int *lwork, int *info, size_t)
     * }
     */
    public static void zsytri_3_(MemorySegment uplo, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment E, MemorySegment ipiv, MemorySegment work, MemorySegment lwork, MemorySegment info, long x9) {
        var mh$ = zsytri_3_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zsytri_3_", uplo, n, A, lda, E, ipiv, work, lwork, info, x9);
            }
            mh$.invokeExact(uplo, n, A, lda, E, ipiv, work, lwork, info, x9);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class csytrs_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("csytrs_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void csytrs_(const char *uplo, const int *n, const int *nrhs, const _Complex float *A, const int *lda, const int *ipiv, _Complex float *B, const int *ldb, int *info, size_t)
     * }
     */
    public static FunctionDescriptor csytrs_$descriptor() {
        return csytrs_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void csytrs_(const char *uplo, const int *n, const int *nrhs, const _Complex float *A, const int *lda, const int *ipiv, _Complex float *B, const int *ldb, int *info, size_t)
     * }
     */
    public static MethodHandle csytrs_$handle() {
        return csytrs_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void csytrs_(const char *uplo, const int *n, const int *nrhs, const _Complex float *A, const int *lda, const int *ipiv, _Complex float *B, const int *ldb, int *info, size_t)
     * }
     */
    public static MemorySegment csytrs_$address() {
        return csytrs_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void csytrs_(const char *uplo, const int *n, const int *nrhs, const _Complex float *A, const int *lda, const int *ipiv, _Complex float *B, const int *ldb, int *info, size_t)
     * }
     */
    public static void csytrs_(MemorySegment uplo, MemorySegment n, MemorySegment nrhs, MemorySegment A, MemorySegment lda, MemorySegment ipiv, MemorySegment B, MemorySegment ldb, MemorySegment info, long x9) {
        var mh$ = csytrs_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("csytrs_", uplo, n, nrhs, A, lda, ipiv, B, ldb, info, x9);
            }
            mh$.invokeExact(uplo, n, nrhs, A, lda, ipiv, B, ldb, info, x9);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dsytrs_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("dsytrs_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dsytrs_(const char *uplo, const int *n, const int *nrhs, const double *A, const int *lda, const int *ipiv, double *B, const int *ldb, int *info, size_t)
     * }
     */
    public static FunctionDescriptor dsytrs_$descriptor() {
        return dsytrs_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dsytrs_(const char *uplo, const int *n, const int *nrhs, const double *A, const int *lda, const int *ipiv, double *B, const int *ldb, int *info, size_t)
     * }
     */
    public static MethodHandle dsytrs_$handle() {
        return dsytrs_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dsytrs_(const char *uplo, const int *n, const int *nrhs, const double *A, const int *lda, const int *ipiv, double *B, const int *ldb, int *info, size_t)
     * }
     */
    public static MemorySegment dsytrs_$address() {
        return dsytrs_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dsytrs_(const char *uplo, const int *n, const int *nrhs, const double *A, const int *lda, const int *ipiv, double *B, const int *ldb, int *info, size_t)
     * }
     */
    public static void dsytrs_(MemorySegment uplo, MemorySegment n, MemorySegment nrhs, MemorySegment A, MemorySegment lda, MemorySegment ipiv, MemorySegment B, MemorySegment ldb, MemorySegment info, long x9) {
        var mh$ = dsytrs_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dsytrs_", uplo, n, nrhs, A, lda, ipiv, B, ldb, info, x9);
            }
            mh$.invokeExact(uplo, n, nrhs, A, lda, ipiv, B, ldb, info, x9);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ssytrs_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("ssytrs_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ssytrs_(const char *uplo, const int *n, const int *nrhs, const float *A, const int *lda, const int *ipiv, float *B, const int *ldb, int *info, size_t)
     * }
     */
    public static FunctionDescriptor ssytrs_$descriptor() {
        return ssytrs_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ssytrs_(const char *uplo, const int *n, const int *nrhs, const float *A, const int *lda, const int *ipiv, float *B, const int *ldb, int *info, size_t)
     * }
     */
    public static MethodHandle ssytrs_$handle() {
        return ssytrs_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ssytrs_(const char *uplo, const int *n, const int *nrhs, const float *A, const int *lda, const int *ipiv, float *B, const int *ldb, int *info, size_t)
     * }
     */
    public static MemorySegment ssytrs_$address() {
        return ssytrs_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ssytrs_(const char *uplo, const int *n, const int *nrhs, const float *A, const int *lda, const int *ipiv, float *B, const int *ldb, int *info, size_t)
     * }
     */
    public static void ssytrs_(MemorySegment uplo, MemorySegment n, MemorySegment nrhs, MemorySegment A, MemorySegment lda, MemorySegment ipiv, MemorySegment B, MemorySegment ldb, MemorySegment info, long x9) {
        var mh$ = ssytrs_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ssytrs_", uplo, n, nrhs, A, lda, ipiv, B, ldb, info, x9);
            }
            mh$.invokeExact(uplo, n, nrhs, A, lda, ipiv, B, ldb, info, x9);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zsytrs_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("zsytrs_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zsytrs_(const char *uplo, const int *n, const int *nrhs, const _Complex double *A, const int *lda, const int *ipiv, _Complex double *B, const int *ldb, int *info, size_t)
     * }
     */
    public static FunctionDescriptor zsytrs_$descriptor() {
        return zsytrs_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zsytrs_(const char *uplo, const int *n, const int *nrhs, const _Complex double *A, const int *lda, const int *ipiv, _Complex double *B, const int *ldb, int *info, size_t)
     * }
     */
    public static MethodHandle zsytrs_$handle() {
        return zsytrs_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zsytrs_(const char *uplo, const int *n, const int *nrhs, const _Complex double *A, const int *lda, const int *ipiv, _Complex double *B, const int *ldb, int *info, size_t)
     * }
     */
    public static MemorySegment zsytrs_$address() {
        return zsytrs_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zsytrs_(const char *uplo, const int *n, const int *nrhs, const _Complex double *A, const int *lda, const int *ipiv, _Complex double *B, const int *ldb, int *info, size_t)
     * }
     */
    public static void zsytrs_(MemorySegment uplo, MemorySegment n, MemorySegment nrhs, MemorySegment A, MemorySegment lda, MemorySegment ipiv, MemorySegment B, MemorySegment ldb, MemorySegment info, long x9) {
        var mh$ = zsytrs_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zsytrs_", uplo, n, nrhs, A, lda, ipiv, B, ldb, info, x9);
            }
            mh$.invokeExact(uplo, n, nrhs, A, lda, ipiv, B, ldb, info, x9);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class csytrs2_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("csytrs2_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void csytrs2_(const char *uplo, const int *n, const int *nrhs, const _Complex float *A, const int *lda, const int *ipiv, _Complex float *B, const int *ldb, _Complex float *work, int *info, size_t)
     * }
     */
    public static FunctionDescriptor csytrs2_$descriptor() {
        return csytrs2_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void csytrs2_(const char *uplo, const int *n, const int *nrhs, const _Complex float *A, const int *lda, const int *ipiv, _Complex float *B, const int *ldb, _Complex float *work, int *info, size_t)
     * }
     */
    public static MethodHandle csytrs2_$handle() {
        return csytrs2_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void csytrs2_(const char *uplo, const int *n, const int *nrhs, const _Complex float *A, const int *lda, const int *ipiv, _Complex float *B, const int *ldb, _Complex float *work, int *info, size_t)
     * }
     */
    public static MemorySegment csytrs2_$address() {
        return csytrs2_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void csytrs2_(const char *uplo, const int *n, const int *nrhs, const _Complex float *A, const int *lda, const int *ipiv, _Complex float *B, const int *ldb, _Complex float *work, int *info, size_t)
     * }
     */
    public static void csytrs2_(MemorySegment uplo, MemorySegment n, MemorySegment nrhs, MemorySegment A, MemorySegment lda, MemorySegment ipiv, MemorySegment B, MemorySegment ldb, MemorySegment work, MemorySegment info, long x10) {
        var mh$ = csytrs2_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("csytrs2_", uplo, n, nrhs, A, lda, ipiv, B, ldb, work, info, x10);
            }
            mh$.invokeExact(uplo, n, nrhs, A, lda, ipiv, B, ldb, work, info, x10);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dsytrs2_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("dsytrs2_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dsytrs2_(const char *uplo, const int *n, const int *nrhs, const double *A, const int *lda, const int *ipiv, double *B, const int *ldb, double *work, int *info, size_t)
     * }
     */
    public static FunctionDescriptor dsytrs2_$descriptor() {
        return dsytrs2_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dsytrs2_(const char *uplo, const int *n, const int *nrhs, const double *A, const int *lda, const int *ipiv, double *B, const int *ldb, double *work, int *info, size_t)
     * }
     */
    public static MethodHandle dsytrs2_$handle() {
        return dsytrs2_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dsytrs2_(const char *uplo, const int *n, const int *nrhs, const double *A, const int *lda, const int *ipiv, double *B, const int *ldb, double *work, int *info, size_t)
     * }
     */
    public static MemorySegment dsytrs2_$address() {
        return dsytrs2_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dsytrs2_(const char *uplo, const int *n, const int *nrhs, const double *A, const int *lda, const int *ipiv, double *B, const int *ldb, double *work, int *info, size_t)
     * }
     */
    public static void dsytrs2_(MemorySegment uplo, MemorySegment n, MemorySegment nrhs, MemorySegment A, MemorySegment lda, MemorySegment ipiv, MemorySegment B, MemorySegment ldb, MemorySegment work, MemorySegment info, long x10) {
        var mh$ = dsytrs2_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dsytrs2_", uplo, n, nrhs, A, lda, ipiv, B, ldb, work, info, x10);
            }
            mh$.invokeExact(uplo, n, nrhs, A, lda, ipiv, B, ldb, work, info, x10);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ssytrs2_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("ssytrs2_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ssytrs2_(const char *uplo, const int *n, const int *nrhs, const float *A, const int *lda, const int *ipiv, float *B, const int *ldb, float *work, int *info, size_t)
     * }
     */
    public static FunctionDescriptor ssytrs2_$descriptor() {
        return ssytrs2_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ssytrs2_(const char *uplo, const int *n, const int *nrhs, const float *A, const int *lda, const int *ipiv, float *B, const int *ldb, float *work, int *info, size_t)
     * }
     */
    public static MethodHandle ssytrs2_$handle() {
        return ssytrs2_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ssytrs2_(const char *uplo, const int *n, const int *nrhs, const float *A, const int *lda, const int *ipiv, float *B, const int *ldb, float *work, int *info, size_t)
     * }
     */
    public static MemorySegment ssytrs2_$address() {
        return ssytrs2_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ssytrs2_(const char *uplo, const int *n, const int *nrhs, const float *A, const int *lda, const int *ipiv, float *B, const int *ldb, float *work, int *info, size_t)
     * }
     */
    public static void ssytrs2_(MemorySegment uplo, MemorySegment n, MemorySegment nrhs, MemorySegment A, MemorySegment lda, MemorySegment ipiv, MemorySegment B, MemorySegment ldb, MemorySegment work, MemorySegment info, long x10) {
        var mh$ = ssytrs2_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ssytrs2_", uplo, n, nrhs, A, lda, ipiv, B, ldb, work, info, x10);
            }
            mh$.invokeExact(uplo, n, nrhs, A, lda, ipiv, B, ldb, work, info, x10);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zsytrs2_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("zsytrs2_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zsytrs2_(const char *uplo, const int *n, const int *nrhs, const _Complex double *A, const int *lda, const int *ipiv, _Complex double *B, const int *ldb, _Complex double *work, int *info, size_t)
     * }
     */
    public static FunctionDescriptor zsytrs2_$descriptor() {
        return zsytrs2_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zsytrs2_(const char *uplo, const int *n, const int *nrhs, const _Complex double *A, const int *lda, const int *ipiv, _Complex double *B, const int *ldb, _Complex double *work, int *info, size_t)
     * }
     */
    public static MethodHandle zsytrs2_$handle() {
        return zsytrs2_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zsytrs2_(const char *uplo, const int *n, const int *nrhs, const _Complex double *A, const int *lda, const int *ipiv, _Complex double *B, const int *ldb, _Complex double *work, int *info, size_t)
     * }
     */
    public static MemorySegment zsytrs2_$address() {
        return zsytrs2_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zsytrs2_(const char *uplo, const int *n, const int *nrhs, const _Complex double *A, const int *lda, const int *ipiv, _Complex double *B, const int *ldb, _Complex double *work, int *info, size_t)
     * }
     */
    public static void zsytrs2_(MemorySegment uplo, MemorySegment n, MemorySegment nrhs, MemorySegment A, MemorySegment lda, MemorySegment ipiv, MemorySegment B, MemorySegment ldb, MemorySegment work, MemorySegment info, long x10) {
        var mh$ = zsytrs2_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zsytrs2_", uplo, n, nrhs, A, lda, ipiv, B, ldb, work, info, x10);
            }
            mh$.invokeExact(uplo, n, nrhs, A, lda, ipiv, B, ldb, work, info, x10);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class csytrs_3_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("csytrs_3_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void csytrs_3_(const char *uplo, const int *n, const int *nrhs, const _Complex float *A, const int *lda, const _Complex float *E, const int *ipiv, _Complex float *B, const int *ldb, int *info, size_t)
     * }
     */
    public static FunctionDescriptor csytrs_3_$descriptor() {
        return csytrs_3_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void csytrs_3_(const char *uplo, const int *n, const int *nrhs, const _Complex float *A, const int *lda, const _Complex float *E, const int *ipiv, _Complex float *B, const int *ldb, int *info, size_t)
     * }
     */
    public static MethodHandle csytrs_3_$handle() {
        return csytrs_3_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void csytrs_3_(const char *uplo, const int *n, const int *nrhs, const _Complex float *A, const int *lda, const _Complex float *E, const int *ipiv, _Complex float *B, const int *ldb, int *info, size_t)
     * }
     */
    public static MemorySegment csytrs_3_$address() {
        return csytrs_3_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void csytrs_3_(const char *uplo, const int *n, const int *nrhs, const _Complex float *A, const int *lda, const _Complex float *E, const int *ipiv, _Complex float *B, const int *ldb, int *info, size_t)
     * }
     */
    public static void csytrs_3_(MemorySegment uplo, MemorySegment n, MemorySegment nrhs, MemorySegment A, MemorySegment lda, MemorySegment E, MemorySegment ipiv, MemorySegment B, MemorySegment ldb, MemorySegment info, long x10) {
        var mh$ = csytrs_3_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("csytrs_3_", uplo, n, nrhs, A, lda, E, ipiv, B, ldb, info, x10);
            }
            mh$.invokeExact(uplo, n, nrhs, A, lda, E, ipiv, B, ldb, info, x10);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dsytrs_3_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("dsytrs_3_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dsytrs_3_(const char *uplo, const int *n, const int *nrhs, const double *A, const int *lda, const double *E, const int *ipiv, double *B, const int *ldb, int *info, size_t)
     * }
     */
    public static FunctionDescriptor dsytrs_3_$descriptor() {
        return dsytrs_3_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dsytrs_3_(const char *uplo, const int *n, const int *nrhs, const double *A, const int *lda, const double *E, const int *ipiv, double *B, const int *ldb, int *info, size_t)
     * }
     */
    public static MethodHandle dsytrs_3_$handle() {
        return dsytrs_3_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dsytrs_3_(const char *uplo, const int *n, const int *nrhs, const double *A, const int *lda, const double *E, const int *ipiv, double *B, const int *ldb, int *info, size_t)
     * }
     */
    public static MemorySegment dsytrs_3_$address() {
        return dsytrs_3_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dsytrs_3_(const char *uplo, const int *n, const int *nrhs, const double *A, const int *lda, const double *E, const int *ipiv, double *B, const int *ldb, int *info, size_t)
     * }
     */
    public static void dsytrs_3_(MemorySegment uplo, MemorySegment n, MemorySegment nrhs, MemorySegment A, MemorySegment lda, MemorySegment E, MemorySegment ipiv, MemorySegment B, MemorySegment ldb, MemorySegment info, long x10) {
        var mh$ = dsytrs_3_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dsytrs_3_", uplo, n, nrhs, A, lda, E, ipiv, B, ldb, info, x10);
            }
            mh$.invokeExact(uplo, n, nrhs, A, lda, E, ipiv, B, ldb, info, x10);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ssytrs_3_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("ssytrs_3_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ssytrs_3_(const char *uplo, const int *n, const int *nrhs, const float *A, const int *lda, const float *E, const int *ipiv, float *B, const int *ldb, int *info, size_t)
     * }
     */
    public static FunctionDescriptor ssytrs_3_$descriptor() {
        return ssytrs_3_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ssytrs_3_(const char *uplo, const int *n, const int *nrhs, const float *A, const int *lda, const float *E, const int *ipiv, float *B, const int *ldb, int *info, size_t)
     * }
     */
    public static MethodHandle ssytrs_3_$handle() {
        return ssytrs_3_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ssytrs_3_(const char *uplo, const int *n, const int *nrhs, const float *A, const int *lda, const float *E, const int *ipiv, float *B, const int *ldb, int *info, size_t)
     * }
     */
    public static MemorySegment ssytrs_3_$address() {
        return ssytrs_3_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ssytrs_3_(const char *uplo, const int *n, const int *nrhs, const float *A, const int *lda, const float *E, const int *ipiv, float *B, const int *ldb, int *info, size_t)
     * }
     */
    public static void ssytrs_3_(MemorySegment uplo, MemorySegment n, MemorySegment nrhs, MemorySegment A, MemorySegment lda, MemorySegment E, MemorySegment ipiv, MemorySegment B, MemorySegment ldb, MemorySegment info, long x10) {
        var mh$ = ssytrs_3_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ssytrs_3_", uplo, n, nrhs, A, lda, E, ipiv, B, ldb, info, x10);
            }
            mh$.invokeExact(uplo, n, nrhs, A, lda, E, ipiv, B, ldb, info, x10);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zsytrs_3_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("zsytrs_3_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zsytrs_3_(const char *uplo, const int *n, const int *nrhs, const _Complex double *A, const int *lda, const _Complex double *E, const int *ipiv, _Complex double *B, const int *ldb, int *info, size_t)
     * }
     */
    public static FunctionDescriptor zsytrs_3_$descriptor() {
        return zsytrs_3_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zsytrs_3_(const char *uplo, const int *n, const int *nrhs, const _Complex double *A, const int *lda, const _Complex double *E, const int *ipiv, _Complex double *B, const int *ldb, int *info, size_t)
     * }
     */
    public static MethodHandle zsytrs_3_$handle() {
        return zsytrs_3_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zsytrs_3_(const char *uplo, const int *n, const int *nrhs, const _Complex double *A, const int *lda, const _Complex double *E, const int *ipiv, _Complex double *B, const int *ldb, int *info, size_t)
     * }
     */
    public static MemorySegment zsytrs_3_$address() {
        return zsytrs_3_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zsytrs_3_(const char *uplo, const int *n, const int *nrhs, const _Complex double *A, const int *lda, const _Complex double *E, const int *ipiv, _Complex double *B, const int *ldb, int *info, size_t)
     * }
     */
    public static void zsytrs_3_(MemorySegment uplo, MemorySegment n, MemorySegment nrhs, MemorySegment A, MemorySegment lda, MemorySegment E, MemorySegment ipiv, MemorySegment B, MemorySegment ldb, MemorySegment info, long x10) {
        var mh$ = zsytrs_3_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zsytrs_3_", uplo, n, nrhs, A, lda, E, ipiv, B, ldb, info, x10);
            }
            mh$.invokeExact(uplo, n, nrhs, A, lda, E, ipiv, B, ldb, info, x10);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class csytrs_aa_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("csytrs_aa_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void csytrs_aa_(const char *uplo, const int *n, const int *nrhs, const _Complex float *A, const int *lda, const int *ipiv, _Complex float *B, const int *ldb, _Complex float *work, const int *lwork, int *info, size_t)
     * }
     */
    public static FunctionDescriptor csytrs_aa_$descriptor() {
        return csytrs_aa_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void csytrs_aa_(const char *uplo, const int *n, const int *nrhs, const _Complex float *A, const int *lda, const int *ipiv, _Complex float *B, const int *ldb, _Complex float *work, const int *lwork, int *info, size_t)
     * }
     */
    public static MethodHandle csytrs_aa_$handle() {
        return csytrs_aa_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void csytrs_aa_(const char *uplo, const int *n, const int *nrhs, const _Complex float *A, const int *lda, const int *ipiv, _Complex float *B, const int *ldb, _Complex float *work, const int *lwork, int *info, size_t)
     * }
     */
    public static MemorySegment csytrs_aa_$address() {
        return csytrs_aa_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void csytrs_aa_(const char *uplo, const int *n, const int *nrhs, const _Complex float *A, const int *lda, const int *ipiv, _Complex float *B, const int *ldb, _Complex float *work, const int *lwork, int *info, size_t)
     * }
     */
    public static void csytrs_aa_(MemorySegment uplo, MemorySegment n, MemorySegment nrhs, MemorySegment A, MemorySegment lda, MemorySegment ipiv, MemorySegment B, MemorySegment ldb, MemorySegment work, MemorySegment lwork, MemorySegment info, long x11) {
        var mh$ = csytrs_aa_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("csytrs_aa_", uplo, n, nrhs, A, lda, ipiv, B, ldb, work, lwork, info, x11);
            }
            mh$.invokeExact(uplo, n, nrhs, A, lda, ipiv, B, ldb, work, lwork, info, x11);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dsytrs_aa_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("dsytrs_aa_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dsytrs_aa_(const char *uplo, const int *n, const int *nrhs, const double *A, const int *lda, const int *ipiv, double *B, const int *ldb, double *work, const int *lwork, int *info, size_t)
     * }
     */
    public static FunctionDescriptor dsytrs_aa_$descriptor() {
        return dsytrs_aa_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dsytrs_aa_(const char *uplo, const int *n, const int *nrhs, const double *A, const int *lda, const int *ipiv, double *B, const int *ldb, double *work, const int *lwork, int *info, size_t)
     * }
     */
    public static MethodHandle dsytrs_aa_$handle() {
        return dsytrs_aa_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dsytrs_aa_(const char *uplo, const int *n, const int *nrhs, const double *A, const int *lda, const int *ipiv, double *B, const int *ldb, double *work, const int *lwork, int *info, size_t)
     * }
     */
    public static MemorySegment dsytrs_aa_$address() {
        return dsytrs_aa_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dsytrs_aa_(const char *uplo, const int *n, const int *nrhs, const double *A, const int *lda, const int *ipiv, double *B, const int *ldb, double *work, const int *lwork, int *info, size_t)
     * }
     */
    public static void dsytrs_aa_(MemorySegment uplo, MemorySegment n, MemorySegment nrhs, MemorySegment A, MemorySegment lda, MemorySegment ipiv, MemorySegment B, MemorySegment ldb, MemorySegment work, MemorySegment lwork, MemorySegment info, long x11) {
        var mh$ = dsytrs_aa_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dsytrs_aa_", uplo, n, nrhs, A, lda, ipiv, B, ldb, work, lwork, info, x11);
            }
            mh$.invokeExact(uplo, n, nrhs, A, lda, ipiv, B, ldb, work, lwork, info, x11);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ssytrs_aa_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("ssytrs_aa_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ssytrs_aa_(const char *uplo, const int *n, const int *nrhs, const float *A, const int *lda, const int *ipiv, float *B, const int *ldb, float *work, const int *lwork, int *info, size_t)
     * }
     */
    public static FunctionDescriptor ssytrs_aa_$descriptor() {
        return ssytrs_aa_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ssytrs_aa_(const char *uplo, const int *n, const int *nrhs, const float *A, const int *lda, const int *ipiv, float *B, const int *ldb, float *work, const int *lwork, int *info, size_t)
     * }
     */
    public static MethodHandle ssytrs_aa_$handle() {
        return ssytrs_aa_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ssytrs_aa_(const char *uplo, const int *n, const int *nrhs, const float *A, const int *lda, const int *ipiv, float *B, const int *ldb, float *work, const int *lwork, int *info, size_t)
     * }
     */
    public static MemorySegment ssytrs_aa_$address() {
        return ssytrs_aa_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ssytrs_aa_(const char *uplo, const int *n, const int *nrhs, const float *A, const int *lda, const int *ipiv, float *B, const int *ldb, float *work, const int *lwork, int *info, size_t)
     * }
     */
    public static void ssytrs_aa_(MemorySegment uplo, MemorySegment n, MemorySegment nrhs, MemorySegment A, MemorySegment lda, MemorySegment ipiv, MemorySegment B, MemorySegment ldb, MemorySegment work, MemorySegment lwork, MemorySegment info, long x11) {
        var mh$ = ssytrs_aa_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ssytrs_aa_", uplo, n, nrhs, A, lda, ipiv, B, ldb, work, lwork, info, x11);
            }
            mh$.invokeExact(uplo, n, nrhs, A, lda, ipiv, B, ldb, work, lwork, info, x11);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zsytrs_aa_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("zsytrs_aa_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zsytrs_aa_(const char *uplo, const int *n, const int *nrhs, const _Complex double *A, const int *lda, const int *ipiv, _Complex double *B, const int *ldb, _Complex double *work, const int *lwork, int *info, size_t)
     * }
     */
    public static FunctionDescriptor zsytrs_aa_$descriptor() {
        return zsytrs_aa_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zsytrs_aa_(const char *uplo, const int *n, const int *nrhs, const _Complex double *A, const int *lda, const int *ipiv, _Complex double *B, const int *ldb, _Complex double *work, const int *lwork, int *info, size_t)
     * }
     */
    public static MethodHandle zsytrs_aa_$handle() {
        return zsytrs_aa_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zsytrs_aa_(const char *uplo, const int *n, const int *nrhs, const _Complex double *A, const int *lda, const int *ipiv, _Complex double *B, const int *ldb, _Complex double *work, const int *lwork, int *info, size_t)
     * }
     */
    public static MemorySegment zsytrs_aa_$address() {
        return zsytrs_aa_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zsytrs_aa_(const char *uplo, const int *n, const int *nrhs, const _Complex double *A, const int *lda, const int *ipiv, _Complex double *B, const int *ldb, _Complex double *work, const int *lwork, int *info, size_t)
     * }
     */
    public static void zsytrs_aa_(MemorySegment uplo, MemorySegment n, MemorySegment nrhs, MemorySegment A, MemorySegment lda, MemorySegment ipiv, MemorySegment B, MemorySegment ldb, MemorySegment work, MemorySegment lwork, MemorySegment info, long x11) {
        var mh$ = zsytrs_aa_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zsytrs_aa_", uplo, n, nrhs, A, lda, ipiv, B, ldb, work, lwork, info, x11);
            }
            mh$.invokeExact(uplo, n, nrhs, A, lda, ipiv, B, ldb, work, lwork, info, x11);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class csytrs_aa_2stage_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("csytrs_aa_2stage_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void csytrs_aa_2stage_(const char *uplo, const int *n, const int *nrhs, const _Complex float *A, const int *lda, _Complex float *TB, const int *ltb, const int *ipiv, const int *ipiv2, _Complex float *B, const int *ldb, int *info, size_t)
     * }
     */
    public static FunctionDescriptor csytrs_aa_2stage_$descriptor() {
        return csytrs_aa_2stage_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void csytrs_aa_2stage_(const char *uplo, const int *n, const int *nrhs, const _Complex float *A, const int *lda, _Complex float *TB, const int *ltb, const int *ipiv, const int *ipiv2, _Complex float *B, const int *ldb, int *info, size_t)
     * }
     */
    public static MethodHandle csytrs_aa_2stage_$handle() {
        return csytrs_aa_2stage_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void csytrs_aa_2stage_(const char *uplo, const int *n, const int *nrhs, const _Complex float *A, const int *lda, _Complex float *TB, const int *ltb, const int *ipiv, const int *ipiv2, _Complex float *B, const int *ldb, int *info, size_t)
     * }
     */
    public static MemorySegment csytrs_aa_2stage_$address() {
        return csytrs_aa_2stage_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void csytrs_aa_2stage_(const char *uplo, const int *n, const int *nrhs, const _Complex float *A, const int *lda, _Complex float *TB, const int *ltb, const int *ipiv, const int *ipiv2, _Complex float *B, const int *ldb, int *info, size_t)
     * }
     */
    public static void csytrs_aa_2stage_(MemorySegment uplo, MemorySegment n, MemorySegment nrhs, MemorySegment A, MemorySegment lda, MemorySegment TB, MemorySegment ltb, MemorySegment ipiv, MemorySegment ipiv2, MemorySegment B, MemorySegment ldb, MemorySegment info, long x12) {
        var mh$ = csytrs_aa_2stage_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("csytrs_aa_2stage_", uplo, n, nrhs, A, lda, TB, ltb, ipiv, ipiv2, B, ldb, info, x12);
            }
            mh$.invokeExact(uplo, n, nrhs, A, lda, TB, ltb, ipiv, ipiv2, B, ldb, info, x12);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dsytrs_aa_2stage_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("dsytrs_aa_2stage_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dsytrs_aa_2stage_(const char *uplo, const int *n, const int *nrhs, const double *A, const int *lda, double *TB, const int *ltb, const int *ipiv, const int *ipiv2, double *B, const int *ldb, int *info, size_t)
     * }
     */
    public static FunctionDescriptor dsytrs_aa_2stage_$descriptor() {
        return dsytrs_aa_2stage_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dsytrs_aa_2stage_(const char *uplo, const int *n, const int *nrhs, const double *A, const int *lda, double *TB, const int *ltb, const int *ipiv, const int *ipiv2, double *B, const int *ldb, int *info, size_t)
     * }
     */
    public static MethodHandle dsytrs_aa_2stage_$handle() {
        return dsytrs_aa_2stage_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dsytrs_aa_2stage_(const char *uplo, const int *n, const int *nrhs, const double *A, const int *lda, double *TB, const int *ltb, const int *ipiv, const int *ipiv2, double *B, const int *ldb, int *info, size_t)
     * }
     */
    public static MemorySegment dsytrs_aa_2stage_$address() {
        return dsytrs_aa_2stage_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dsytrs_aa_2stage_(const char *uplo, const int *n, const int *nrhs, const double *A, const int *lda, double *TB, const int *ltb, const int *ipiv, const int *ipiv2, double *B, const int *ldb, int *info, size_t)
     * }
     */
    public static void dsytrs_aa_2stage_(MemorySegment uplo, MemorySegment n, MemorySegment nrhs, MemorySegment A, MemorySegment lda, MemorySegment TB, MemorySegment ltb, MemorySegment ipiv, MemorySegment ipiv2, MemorySegment B, MemorySegment ldb, MemorySegment info, long x12) {
        var mh$ = dsytrs_aa_2stage_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dsytrs_aa_2stage_", uplo, n, nrhs, A, lda, TB, ltb, ipiv, ipiv2, B, ldb, info, x12);
            }
            mh$.invokeExact(uplo, n, nrhs, A, lda, TB, ltb, ipiv, ipiv2, B, ldb, info, x12);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ssytrs_aa_2stage_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("ssytrs_aa_2stage_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ssytrs_aa_2stage_(const char *uplo, const int *n, const int *nrhs, const float *A, const int *lda, float *TB, const int *ltb, const int *ipiv, const int *ipiv2, float *B, const int *ldb, int *info, size_t)
     * }
     */
    public static FunctionDescriptor ssytrs_aa_2stage_$descriptor() {
        return ssytrs_aa_2stage_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ssytrs_aa_2stage_(const char *uplo, const int *n, const int *nrhs, const float *A, const int *lda, float *TB, const int *ltb, const int *ipiv, const int *ipiv2, float *B, const int *ldb, int *info, size_t)
     * }
     */
    public static MethodHandle ssytrs_aa_2stage_$handle() {
        return ssytrs_aa_2stage_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ssytrs_aa_2stage_(const char *uplo, const int *n, const int *nrhs, const float *A, const int *lda, float *TB, const int *ltb, const int *ipiv, const int *ipiv2, float *B, const int *ldb, int *info, size_t)
     * }
     */
    public static MemorySegment ssytrs_aa_2stage_$address() {
        return ssytrs_aa_2stage_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ssytrs_aa_2stage_(const char *uplo, const int *n, const int *nrhs, const float *A, const int *lda, float *TB, const int *ltb, const int *ipiv, const int *ipiv2, float *B, const int *ldb, int *info, size_t)
     * }
     */
    public static void ssytrs_aa_2stage_(MemorySegment uplo, MemorySegment n, MemorySegment nrhs, MemorySegment A, MemorySegment lda, MemorySegment TB, MemorySegment ltb, MemorySegment ipiv, MemorySegment ipiv2, MemorySegment B, MemorySegment ldb, MemorySegment info, long x12) {
        var mh$ = ssytrs_aa_2stage_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ssytrs_aa_2stage_", uplo, n, nrhs, A, lda, TB, ltb, ipiv, ipiv2, B, ldb, info, x12);
            }
            mh$.invokeExact(uplo, n, nrhs, A, lda, TB, ltb, ipiv, ipiv2, B, ldb, info, x12);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zsytrs_aa_2stage_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("zsytrs_aa_2stage_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zsytrs_aa_2stage_(const char *uplo, const int *n, const int *nrhs, const _Complex double *A, const int *lda, _Complex double *TB, const int *ltb, const int *ipiv, const int *ipiv2, _Complex double *B, const int *ldb, int *info, size_t)
     * }
     */
    public static FunctionDescriptor zsytrs_aa_2stage_$descriptor() {
        return zsytrs_aa_2stage_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zsytrs_aa_2stage_(const char *uplo, const int *n, const int *nrhs, const _Complex double *A, const int *lda, _Complex double *TB, const int *ltb, const int *ipiv, const int *ipiv2, _Complex double *B, const int *ldb, int *info, size_t)
     * }
     */
    public static MethodHandle zsytrs_aa_2stage_$handle() {
        return zsytrs_aa_2stage_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zsytrs_aa_2stage_(const char *uplo, const int *n, const int *nrhs, const _Complex double *A, const int *lda, _Complex double *TB, const int *ltb, const int *ipiv, const int *ipiv2, _Complex double *B, const int *ldb, int *info, size_t)
     * }
     */
    public static MemorySegment zsytrs_aa_2stage_$address() {
        return zsytrs_aa_2stage_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zsytrs_aa_2stage_(const char *uplo, const int *n, const int *nrhs, const _Complex double *A, const int *lda, _Complex double *TB, const int *ltb, const int *ipiv, const int *ipiv2, _Complex double *B, const int *ldb, int *info, size_t)
     * }
     */
    public static void zsytrs_aa_2stage_(MemorySegment uplo, MemorySegment n, MemorySegment nrhs, MemorySegment A, MemorySegment lda, MemorySegment TB, MemorySegment ltb, MemorySegment ipiv, MemorySegment ipiv2, MemorySegment B, MemorySegment ldb, MemorySegment info, long x12) {
        var mh$ = zsytrs_aa_2stage_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zsytrs_aa_2stage_", uplo, n, nrhs, A, lda, TB, ltb, ipiv, ipiv2, B, ldb, info, x12);
            }
            mh$.invokeExact(uplo, n, nrhs, A, lda, TB, ltb, ipiv, ipiv2, B, ldb, info, x12);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class csytrs_rook_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("csytrs_rook_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void csytrs_rook_(const char *uplo, const int *n, const int *nrhs, const _Complex float *A, const int *lda, const int *ipiv, _Complex float *B, const int *ldb, int *info, size_t)
     * }
     */
    public static FunctionDescriptor csytrs_rook_$descriptor() {
        return csytrs_rook_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void csytrs_rook_(const char *uplo, const int *n, const int *nrhs, const _Complex float *A, const int *lda, const int *ipiv, _Complex float *B, const int *ldb, int *info, size_t)
     * }
     */
    public static MethodHandle csytrs_rook_$handle() {
        return csytrs_rook_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void csytrs_rook_(const char *uplo, const int *n, const int *nrhs, const _Complex float *A, const int *lda, const int *ipiv, _Complex float *B, const int *ldb, int *info, size_t)
     * }
     */
    public static MemorySegment csytrs_rook_$address() {
        return csytrs_rook_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void csytrs_rook_(const char *uplo, const int *n, const int *nrhs, const _Complex float *A, const int *lda, const int *ipiv, _Complex float *B, const int *ldb, int *info, size_t)
     * }
     */
    public static void csytrs_rook_(MemorySegment uplo, MemorySegment n, MemorySegment nrhs, MemorySegment A, MemorySegment lda, MemorySegment ipiv, MemorySegment B, MemorySegment ldb, MemorySegment info, long x9) {
        var mh$ = csytrs_rook_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("csytrs_rook_", uplo, n, nrhs, A, lda, ipiv, B, ldb, info, x9);
            }
            mh$.invokeExact(uplo, n, nrhs, A, lda, ipiv, B, ldb, info, x9);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dsytrs_rook_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("dsytrs_rook_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dsytrs_rook_(const char *uplo, const int *n, const int *nrhs, const double *A, const int *lda, const int *ipiv, double *B, const int *ldb, int *info, size_t)
     * }
     */
    public static FunctionDescriptor dsytrs_rook_$descriptor() {
        return dsytrs_rook_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dsytrs_rook_(const char *uplo, const int *n, const int *nrhs, const double *A, const int *lda, const int *ipiv, double *B, const int *ldb, int *info, size_t)
     * }
     */
    public static MethodHandle dsytrs_rook_$handle() {
        return dsytrs_rook_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dsytrs_rook_(const char *uplo, const int *n, const int *nrhs, const double *A, const int *lda, const int *ipiv, double *B, const int *ldb, int *info, size_t)
     * }
     */
    public static MemorySegment dsytrs_rook_$address() {
        return dsytrs_rook_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dsytrs_rook_(const char *uplo, const int *n, const int *nrhs, const double *A, const int *lda, const int *ipiv, double *B, const int *ldb, int *info, size_t)
     * }
     */
    public static void dsytrs_rook_(MemorySegment uplo, MemorySegment n, MemorySegment nrhs, MemorySegment A, MemorySegment lda, MemorySegment ipiv, MemorySegment B, MemorySegment ldb, MemorySegment info, long x9) {
        var mh$ = dsytrs_rook_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dsytrs_rook_", uplo, n, nrhs, A, lda, ipiv, B, ldb, info, x9);
            }
            mh$.invokeExact(uplo, n, nrhs, A, lda, ipiv, B, ldb, info, x9);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ssytrs_rook_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("ssytrs_rook_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ssytrs_rook_(const char *uplo, const int *n, const int *nrhs, const float *A, const int *lda, const int *ipiv, float *B, const int *ldb, int *info, size_t)
     * }
     */
    public static FunctionDescriptor ssytrs_rook_$descriptor() {
        return ssytrs_rook_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ssytrs_rook_(const char *uplo, const int *n, const int *nrhs, const float *A, const int *lda, const int *ipiv, float *B, const int *ldb, int *info, size_t)
     * }
     */
    public static MethodHandle ssytrs_rook_$handle() {
        return ssytrs_rook_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ssytrs_rook_(const char *uplo, const int *n, const int *nrhs, const float *A, const int *lda, const int *ipiv, float *B, const int *ldb, int *info, size_t)
     * }
     */
    public static MemorySegment ssytrs_rook_$address() {
        return ssytrs_rook_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ssytrs_rook_(const char *uplo, const int *n, const int *nrhs, const float *A, const int *lda, const int *ipiv, float *B, const int *ldb, int *info, size_t)
     * }
     */
    public static void ssytrs_rook_(MemorySegment uplo, MemorySegment n, MemorySegment nrhs, MemorySegment A, MemorySegment lda, MemorySegment ipiv, MemorySegment B, MemorySegment ldb, MemorySegment info, long x9) {
        var mh$ = ssytrs_rook_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ssytrs_rook_", uplo, n, nrhs, A, lda, ipiv, B, ldb, info, x9);
            }
            mh$.invokeExact(uplo, n, nrhs, A, lda, ipiv, B, ldb, info, x9);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zsytrs_rook_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("zsytrs_rook_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zsytrs_rook_(const char *uplo, const int *n, const int *nrhs, const _Complex double *A, const int *lda, const int *ipiv, _Complex double *B, const int *ldb, int *info, size_t)
     * }
     */
    public static FunctionDescriptor zsytrs_rook_$descriptor() {
        return zsytrs_rook_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zsytrs_rook_(const char *uplo, const int *n, const int *nrhs, const _Complex double *A, const int *lda, const int *ipiv, _Complex double *B, const int *ldb, int *info, size_t)
     * }
     */
    public static MethodHandle zsytrs_rook_$handle() {
        return zsytrs_rook_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zsytrs_rook_(const char *uplo, const int *n, const int *nrhs, const _Complex double *A, const int *lda, const int *ipiv, _Complex double *B, const int *ldb, int *info, size_t)
     * }
     */
    public static MemorySegment zsytrs_rook_$address() {
        return zsytrs_rook_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zsytrs_rook_(const char *uplo, const int *n, const int *nrhs, const _Complex double *A, const int *lda, const int *ipiv, _Complex double *B, const int *ldb, int *info, size_t)
     * }
     */
    public static void zsytrs_rook_(MemorySegment uplo, MemorySegment n, MemorySegment nrhs, MemorySegment A, MemorySegment lda, MemorySegment ipiv, MemorySegment B, MemorySegment ldb, MemorySegment info, long x9) {
        var mh$ = zsytrs_rook_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zsytrs_rook_", uplo, n, nrhs, A, lda, ipiv, B, ldb, info, x9);
            }
            mh$.invokeExact(uplo, n, nrhs, A, lda, ipiv, B, ldb, info, x9);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ctbcon_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("ctbcon_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ctbcon_(const char *norm, const char *uplo, const char *diag, const int *n, const int *kd, const _Complex float *AB, const int *ldab, float *rcond, _Complex float *work, float *rwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor ctbcon_$descriptor() {
        return ctbcon_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ctbcon_(const char *norm, const char *uplo, const char *diag, const int *n, const int *kd, const _Complex float *AB, const int *ldab, float *rcond, _Complex float *work, float *rwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle ctbcon_$handle() {
        return ctbcon_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ctbcon_(const char *norm, const char *uplo, const char *diag, const int *n, const int *kd, const _Complex float *AB, const int *ldab, float *rcond, _Complex float *work, float *rwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment ctbcon_$address() {
        return ctbcon_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ctbcon_(const char *norm, const char *uplo, const char *diag, const int *n, const int *kd, const _Complex float *AB, const int *ldab, float *rcond, _Complex float *work, float *rwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static void ctbcon_(MemorySegment norm, MemorySegment uplo, MemorySegment diag, MemorySegment n, MemorySegment kd, MemorySegment AB, MemorySegment ldab, MemorySegment rcond, MemorySegment work, MemorySegment rwork, MemorySegment info, long x11, long x12, long x13) {
        var mh$ = ctbcon_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ctbcon_", norm, uplo, diag, n, kd, AB, ldab, rcond, work, rwork, info, x11, x12, x13);
            }
            mh$.invokeExact(norm, uplo, diag, n, kd, AB, ldab, rcond, work, rwork, info, x11, x12, x13);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dtbcon_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("dtbcon_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dtbcon_(const char *norm, const char *uplo, const char *diag, const int *n, const int *kd, const double *AB, const int *ldab, double *rcond, double *work, int *iwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor dtbcon_$descriptor() {
        return dtbcon_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dtbcon_(const char *norm, const char *uplo, const char *diag, const int *n, const int *kd, const double *AB, const int *ldab, double *rcond, double *work, int *iwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle dtbcon_$handle() {
        return dtbcon_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dtbcon_(const char *norm, const char *uplo, const char *diag, const int *n, const int *kd, const double *AB, const int *ldab, double *rcond, double *work, int *iwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment dtbcon_$address() {
        return dtbcon_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dtbcon_(const char *norm, const char *uplo, const char *diag, const int *n, const int *kd, const double *AB, const int *ldab, double *rcond, double *work, int *iwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static void dtbcon_(MemorySegment norm, MemorySegment uplo, MemorySegment diag, MemorySegment n, MemorySegment kd, MemorySegment AB, MemorySegment ldab, MemorySegment rcond, MemorySegment work, MemorySegment iwork, MemorySegment info, long x11, long x12, long x13) {
        var mh$ = dtbcon_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dtbcon_", norm, uplo, diag, n, kd, AB, ldab, rcond, work, iwork, info, x11, x12, x13);
            }
            mh$.invokeExact(norm, uplo, diag, n, kd, AB, ldab, rcond, work, iwork, info, x11, x12, x13);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class stbcon_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("stbcon_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void stbcon_(const char *norm, const char *uplo, const char *diag, const int *n, const int *kd, const float *AB, const int *ldab, float *rcond, float *work, int *iwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor stbcon_$descriptor() {
        return stbcon_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void stbcon_(const char *norm, const char *uplo, const char *diag, const int *n, const int *kd, const float *AB, const int *ldab, float *rcond, float *work, int *iwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle stbcon_$handle() {
        return stbcon_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void stbcon_(const char *norm, const char *uplo, const char *diag, const int *n, const int *kd, const float *AB, const int *ldab, float *rcond, float *work, int *iwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment stbcon_$address() {
        return stbcon_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void stbcon_(const char *norm, const char *uplo, const char *diag, const int *n, const int *kd, const float *AB, const int *ldab, float *rcond, float *work, int *iwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static void stbcon_(MemorySegment norm, MemorySegment uplo, MemorySegment diag, MemorySegment n, MemorySegment kd, MemorySegment AB, MemorySegment ldab, MemorySegment rcond, MemorySegment work, MemorySegment iwork, MemorySegment info, long x11, long x12, long x13) {
        var mh$ = stbcon_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("stbcon_", norm, uplo, diag, n, kd, AB, ldab, rcond, work, iwork, info, x11, x12, x13);
            }
            mh$.invokeExact(norm, uplo, diag, n, kd, AB, ldab, rcond, work, iwork, info, x11, x12, x13);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ztbcon_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("ztbcon_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ztbcon_(const char *norm, const char *uplo, const char *diag, const int *n, const int *kd, const _Complex double *AB, const int *ldab, double *rcond, _Complex double *work, double *rwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor ztbcon_$descriptor() {
        return ztbcon_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ztbcon_(const char *norm, const char *uplo, const char *diag, const int *n, const int *kd, const _Complex double *AB, const int *ldab, double *rcond, _Complex double *work, double *rwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle ztbcon_$handle() {
        return ztbcon_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ztbcon_(const char *norm, const char *uplo, const char *diag, const int *n, const int *kd, const _Complex double *AB, const int *ldab, double *rcond, _Complex double *work, double *rwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment ztbcon_$address() {
        return ztbcon_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ztbcon_(const char *norm, const char *uplo, const char *diag, const int *n, const int *kd, const _Complex double *AB, const int *ldab, double *rcond, _Complex double *work, double *rwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static void ztbcon_(MemorySegment norm, MemorySegment uplo, MemorySegment diag, MemorySegment n, MemorySegment kd, MemorySegment AB, MemorySegment ldab, MemorySegment rcond, MemorySegment work, MemorySegment rwork, MemorySegment info, long x11, long x12, long x13) {
        var mh$ = ztbcon_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ztbcon_", norm, uplo, diag, n, kd, AB, ldab, rcond, work, rwork, info, x11, x12, x13);
            }
            mh$.invokeExact(norm, uplo, diag, n, kd, AB, ldab, rcond, work, rwork, info, x11, x12, x13);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ctbrfs_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("ctbrfs_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ctbrfs_(const char *uplo, const char *trans, const char *diag, const int *n, const int *kd, const int *nrhs, const _Complex float *AB, const int *ldab, const _Complex float *B, const int *ldb, const _Complex float *X, const int *ldx, float *ferr, float *berr, _Complex float *work, float *rwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor ctbrfs_$descriptor() {
        return ctbrfs_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ctbrfs_(const char *uplo, const char *trans, const char *diag, const int *n, const int *kd, const int *nrhs, const _Complex float *AB, const int *ldab, const _Complex float *B, const int *ldb, const _Complex float *X, const int *ldx, float *ferr, float *berr, _Complex float *work, float *rwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle ctbrfs_$handle() {
        return ctbrfs_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ctbrfs_(const char *uplo, const char *trans, const char *diag, const int *n, const int *kd, const int *nrhs, const _Complex float *AB, const int *ldab, const _Complex float *B, const int *ldb, const _Complex float *X, const int *ldx, float *ferr, float *berr, _Complex float *work, float *rwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment ctbrfs_$address() {
        return ctbrfs_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ctbrfs_(const char *uplo, const char *trans, const char *diag, const int *n, const int *kd, const int *nrhs, const _Complex float *AB, const int *ldab, const _Complex float *B, const int *ldb, const _Complex float *X, const int *ldx, float *ferr, float *berr, _Complex float *work, float *rwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static void ctbrfs_(MemorySegment uplo, MemorySegment trans, MemorySegment diag, MemorySegment n, MemorySegment kd, MemorySegment nrhs, MemorySegment AB, MemorySegment ldab, MemorySegment B, MemorySegment ldb, MemorySegment X, MemorySegment ldx, MemorySegment ferr, MemorySegment berr, MemorySegment work, MemorySegment rwork, MemorySegment info, long x17, long x18, long x19) {
        var mh$ = ctbrfs_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ctbrfs_", uplo, trans, diag, n, kd, nrhs, AB, ldab, B, ldb, X, ldx, ferr, berr, work, rwork, info, x17, x18, x19);
            }
            mh$.invokeExact(uplo, trans, diag, n, kd, nrhs, AB, ldab, B, ldb, X, ldx, ferr, berr, work, rwork, info, x17, x18, x19);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dtbrfs_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("dtbrfs_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dtbrfs_(const char *uplo, const char *trans, const char *diag, const int *n, const int *kd, const int *nrhs, const double *AB, const int *ldab, const double *B, const int *ldb, const double *X, const int *ldx, double *ferr, double *berr, double *work, int *iwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor dtbrfs_$descriptor() {
        return dtbrfs_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dtbrfs_(const char *uplo, const char *trans, const char *diag, const int *n, const int *kd, const int *nrhs, const double *AB, const int *ldab, const double *B, const int *ldb, const double *X, const int *ldx, double *ferr, double *berr, double *work, int *iwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle dtbrfs_$handle() {
        return dtbrfs_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dtbrfs_(const char *uplo, const char *trans, const char *diag, const int *n, const int *kd, const int *nrhs, const double *AB, const int *ldab, const double *B, const int *ldb, const double *X, const int *ldx, double *ferr, double *berr, double *work, int *iwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment dtbrfs_$address() {
        return dtbrfs_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dtbrfs_(const char *uplo, const char *trans, const char *diag, const int *n, const int *kd, const int *nrhs, const double *AB, const int *ldab, const double *B, const int *ldb, const double *X, const int *ldx, double *ferr, double *berr, double *work, int *iwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static void dtbrfs_(MemorySegment uplo, MemorySegment trans, MemorySegment diag, MemorySegment n, MemorySegment kd, MemorySegment nrhs, MemorySegment AB, MemorySegment ldab, MemorySegment B, MemorySegment ldb, MemorySegment X, MemorySegment ldx, MemorySegment ferr, MemorySegment berr, MemorySegment work, MemorySegment iwork, MemorySegment info, long x17, long x18, long x19) {
        var mh$ = dtbrfs_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dtbrfs_", uplo, trans, diag, n, kd, nrhs, AB, ldab, B, ldb, X, ldx, ferr, berr, work, iwork, info, x17, x18, x19);
            }
            mh$.invokeExact(uplo, trans, diag, n, kd, nrhs, AB, ldab, B, ldb, X, ldx, ferr, berr, work, iwork, info, x17, x18, x19);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class stbrfs_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("stbrfs_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void stbrfs_(const char *uplo, const char *trans, const char *diag, const int *n, const int *kd, const int *nrhs, const float *AB, const int *ldab, const float *B, const int *ldb, const float *X, const int *ldx, float *ferr, float *berr, float *work, int *iwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor stbrfs_$descriptor() {
        return stbrfs_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void stbrfs_(const char *uplo, const char *trans, const char *diag, const int *n, const int *kd, const int *nrhs, const float *AB, const int *ldab, const float *B, const int *ldb, const float *X, const int *ldx, float *ferr, float *berr, float *work, int *iwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle stbrfs_$handle() {
        return stbrfs_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void stbrfs_(const char *uplo, const char *trans, const char *diag, const int *n, const int *kd, const int *nrhs, const float *AB, const int *ldab, const float *B, const int *ldb, const float *X, const int *ldx, float *ferr, float *berr, float *work, int *iwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment stbrfs_$address() {
        return stbrfs_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void stbrfs_(const char *uplo, const char *trans, const char *diag, const int *n, const int *kd, const int *nrhs, const float *AB, const int *ldab, const float *B, const int *ldb, const float *X, const int *ldx, float *ferr, float *berr, float *work, int *iwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static void stbrfs_(MemorySegment uplo, MemorySegment trans, MemorySegment diag, MemorySegment n, MemorySegment kd, MemorySegment nrhs, MemorySegment AB, MemorySegment ldab, MemorySegment B, MemorySegment ldb, MemorySegment X, MemorySegment ldx, MemorySegment ferr, MemorySegment berr, MemorySegment work, MemorySegment iwork, MemorySegment info, long x17, long x18, long x19) {
        var mh$ = stbrfs_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("stbrfs_", uplo, trans, diag, n, kd, nrhs, AB, ldab, B, ldb, X, ldx, ferr, berr, work, iwork, info, x17, x18, x19);
            }
            mh$.invokeExact(uplo, trans, diag, n, kd, nrhs, AB, ldab, B, ldb, X, ldx, ferr, berr, work, iwork, info, x17, x18, x19);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ztbrfs_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("ztbrfs_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ztbrfs_(const char *uplo, const char *trans, const char *diag, const int *n, const int *kd, const int *nrhs, const _Complex double *AB, const int *ldab, const _Complex double *B, const int *ldb, const _Complex double *X, const int *ldx, double *ferr, double *berr, _Complex double *work, double *rwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor ztbrfs_$descriptor() {
        return ztbrfs_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ztbrfs_(const char *uplo, const char *trans, const char *diag, const int *n, const int *kd, const int *nrhs, const _Complex double *AB, const int *ldab, const _Complex double *B, const int *ldb, const _Complex double *X, const int *ldx, double *ferr, double *berr, _Complex double *work, double *rwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle ztbrfs_$handle() {
        return ztbrfs_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ztbrfs_(const char *uplo, const char *trans, const char *diag, const int *n, const int *kd, const int *nrhs, const _Complex double *AB, const int *ldab, const _Complex double *B, const int *ldb, const _Complex double *X, const int *ldx, double *ferr, double *berr, _Complex double *work, double *rwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment ztbrfs_$address() {
        return ztbrfs_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ztbrfs_(const char *uplo, const char *trans, const char *diag, const int *n, const int *kd, const int *nrhs, const _Complex double *AB, const int *ldab, const _Complex double *B, const int *ldb, const _Complex double *X, const int *ldx, double *ferr, double *berr, _Complex double *work, double *rwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static void ztbrfs_(MemorySegment uplo, MemorySegment trans, MemorySegment diag, MemorySegment n, MemorySegment kd, MemorySegment nrhs, MemorySegment AB, MemorySegment ldab, MemorySegment B, MemorySegment ldb, MemorySegment X, MemorySegment ldx, MemorySegment ferr, MemorySegment berr, MemorySegment work, MemorySegment rwork, MemorySegment info, long x17, long x18, long x19) {
        var mh$ = ztbrfs_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ztbrfs_", uplo, trans, diag, n, kd, nrhs, AB, ldab, B, ldb, X, ldx, ferr, berr, work, rwork, info, x17, x18, x19);
            }
            mh$.invokeExact(uplo, trans, diag, n, kd, nrhs, AB, ldab, B, ldb, X, ldx, ferr, berr, work, rwork, info, x17, x18, x19);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ctbtrs_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("ctbtrs_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ctbtrs_(const char *uplo, const char *trans, const char *diag, const int *n, const int *kd, const int *nrhs, const _Complex float *AB, const int *ldab, _Complex float *B, const int *ldb, int *info, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor ctbtrs_$descriptor() {
        return ctbtrs_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ctbtrs_(const char *uplo, const char *trans, const char *diag, const int *n, const int *kd, const int *nrhs, const _Complex float *AB, const int *ldab, _Complex float *B, const int *ldb, int *info, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle ctbtrs_$handle() {
        return ctbtrs_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ctbtrs_(const char *uplo, const char *trans, const char *diag, const int *n, const int *kd, const int *nrhs, const _Complex float *AB, const int *ldab, _Complex float *B, const int *ldb, int *info, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment ctbtrs_$address() {
        return ctbtrs_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ctbtrs_(const char *uplo, const char *trans, const char *diag, const int *n, const int *kd, const int *nrhs, const _Complex float *AB, const int *ldab, _Complex float *B, const int *ldb, int *info, size_t, size_t, size_t)
     * }
     */
    public static void ctbtrs_(MemorySegment uplo, MemorySegment trans, MemorySegment diag, MemorySegment n, MemorySegment kd, MemorySegment nrhs, MemorySegment AB, MemorySegment ldab, MemorySegment B, MemorySegment ldb, MemorySegment info, long x11, long x12, long x13) {
        var mh$ = ctbtrs_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ctbtrs_", uplo, trans, diag, n, kd, nrhs, AB, ldab, B, ldb, info, x11, x12, x13);
            }
            mh$.invokeExact(uplo, trans, diag, n, kd, nrhs, AB, ldab, B, ldb, info, x11, x12, x13);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dtbtrs_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("dtbtrs_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dtbtrs_(const char *uplo, const char *trans, const char *diag, const int *n, const int *kd, const int *nrhs, const double *AB, const int *ldab, double *B, const int *ldb, int *info, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor dtbtrs_$descriptor() {
        return dtbtrs_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dtbtrs_(const char *uplo, const char *trans, const char *diag, const int *n, const int *kd, const int *nrhs, const double *AB, const int *ldab, double *B, const int *ldb, int *info, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle dtbtrs_$handle() {
        return dtbtrs_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dtbtrs_(const char *uplo, const char *trans, const char *diag, const int *n, const int *kd, const int *nrhs, const double *AB, const int *ldab, double *B, const int *ldb, int *info, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment dtbtrs_$address() {
        return dtbtrs_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dtbtrs_(const char *uplo, const char *trans, const char *diag, const int *n, const int *kd, const int *nrhs, const double *AB, const int *ldab, double *B, const int *ldb, int *info, size_t, size_t, size_t)
     * }
     */
    public static void dtbtrs_(MemorySegment uplo, MemorySegment trans, MemorySegment diag, MemorySegment n, MemorySegment kd, MemorySegment nrhs, MemorySegment AB, MemorySegment ldab, MemorySegment B, MemorySegment ldb, MemorySegment info, long x11, long x12, long x13) {
        var mh$ = dtbtrs_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dtbtrs_", uplo, trans, diag, n, kd, nrhs, AB, ldab, B, ldb, info, x11, x12, x13);
            }
            mh$.invokeExact(uplo, trans, diag, n, kd, nrhs, AB, ldab, B, ldb, info, x11, x12, x13);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class stbtrs_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("stbtrs_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void stbtrs_(const char *uplo, const char *trans, const char *diag, const int *n, const int *kd, const int *nrhs, const float *AB, const int *ldab, float *B, const int *ldb, int *info, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor stbtrs_$descriptor() {
        return stbtrs_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void stbtrs_(const char *uplo, const char *trans, const char *diag, const int *n, const int *kd, const int *nrhs, const float *AB, const int *ldab, float *B, const int *ldb, int *info, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle stbtrs_$handle() {
        return stbtrs_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void stbtrs_(const char *uplo, const char *trans, const char *diag, const int *n, const int *kd, const int *nrhs, const float *AB, const int *ldab, float *B, const int *ldb, int *info, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment stbtrs_$address() {
        return stbtrs_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void stbtrs_(const char *uplo, const char *trans, const char *diag, const int *n, const int *kd, const int *nrhs, const float *AB, const int *ldab, float *B, const int *ldb, int *info, size_t, size_t, size_t)
     * }
     */
    public static void stbtrs_(MemorySegment uplo, MemorySegment trans, MemorySegment diag, MemorySegment n, MemorySegment kd, MemorySegment nrhs, MemorySegment AB, MemorySegment ldab, MemorySegment B, MemorySegment ldb, MemorySegment info, long x11, long x12, long x13) {
        var mh$ = stbtrs_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("stbtrs_", uplo, trans, diag, n, kd, nrhs, AB, ldab, B, ldb, info, x11, x12, x13);
            }
            mh$.invokeExact(uplo, trans, diag, n, kd, nrhs, AB, ldab, B, ldb, info, x11, x12, x13);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ztbtrs_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("ztbtrs_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ztbtrs_(const char *uplo, const char *trans, const char *diag, const int *n, const int *kd, const int *nrhs, const _Complex double *AB, const int *ldab, _Complex double *B, const int *ldb, int *info, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor ztbtrs_$descriptor() {
        return ztbtrs_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ztbtrs_(const char *uplo, const char *trans, const char *diag, const int *n, const int *kd, const int *nrhs, const _Complex double *AB, const int *ldab, _Complex double *B, const int *ldb, int *info, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle ztbtrs_$handle() {
        return ztbtrs_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ztbtrs_(const char *uplo, const char *trans, const char *diag, const int *n, const int *kd, const int *nrhs, const _Complex double *AB, const int *ldab, _Complex double *B, const int *ldb, int *info, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment ztbtrs_$address() {
        return ztbtrs_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ztbtrs_(const char *uplo, const char *trans, const char *diag, const int *n, const int *kd, const int *nrhs, const _Complex double *AB, const int *ldab, _Complex double *B, const int *ldb, int *info, size_t, size_t, size_t)
     * }
     */
    public static void ztbtrs_(MemorySegment uplo, MemorySegment trans, MemorySegment diag, MemorySegment n, MemorySegment kd, MemorySegment nrhs, MemorySegment AB, MemorySegment ldab, MemorySegment B, MemorySegment ldb, MemorySegment info, long x11, long x12, long x13) {
        var mh$ = ztbtrs_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ztbtrs_", uplo, trans, diag, n, kd, nrhs, AB, ldab, B, ldb, info, x11, x12, x13);
            }
            mh$.invokeExact(uplo, trans, diag, n, kd, nrhs, AB, ldab, B, ldb, info, x11, x12, x13);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ctfsm_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("ctfsm_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ctfsm_(const char *transr, const char *side, const char *uplo, const char *trans, const char *diag, const int *m, const int *n, const _Complex float *alpha, const _Complex float *A, _Complex float *B, const int *ldb, size_t, size_t, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor ctfsm_$descriptor() {
        return ctfsm_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ctfsm_(const char *transr, const char *side, const char *uplo, const char *trans, const char *diag, const int *m, const int *n, const _Complex float *alpha, const _Complex float *A, _Complex float *B, const int *ldb, size_t, size_t, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle ctfsm_$handle() {
        return ctfsm_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ctfsm_(const char *transr, const char *side, const char *uplo, const char *trans, const char *diag, const int *m, const int *n, const _Complex float *alpha, const _Complex float *A, _Complex float *B, const int *ldb, size_t, size_t, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment ctfsm_$address() {
        return ctfsm_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ctfsm_(const char *transr, const char *side, const char *uplo, const char *trans, const char *diag, const int *m, const int *n, const _Complex float *alpha, const _Complex float *A, _Complex float *B, const int *ldb, size_t, size_t, size_t, size_t, size_t)
     * }
     */
    public static void ctfsm_(MemorySegment transr, MemorySegment side, MemorySegment uplo, MemorySegment trans, MemorySegment diag, MemorySegment m, MemorySegment n, MemorySegment alpha, MemorySegment A, MemorySegment B, MemorySegment ldb, long x11, long x12, long x13, long x14, long x15) {
        var mh$ = ctfsm_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ctfsm_", transr, side, uplo, trans, diag, m, n, alpha, A, B, ldb, x11, x12, x13, x14, x15);
            }
            mh$.invokeExact(transr, side, uplo, trans, diag, m, n, alpha, A, B, ldb, x11, x12, x13, x14, x15);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dtfsm_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("dtfsm_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dtfsm_(const char *transr, const char *side, const char *uplo, const char *trans, const char *diag, const int *m, const int *n, const double *alpha, const double *A, double *B, const int *ldb, size_t, size_t, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor dtfsm_$descriptor() {
        return dtfsm_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dtfsm_(const char *transr, const char *side, const char *uplo, const char *trans, const char *diag, const int *m, const int *n, const double *alpha, const double *A, double *B, const int *ldb, size_t, size_t, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle dtfsm_$handle() {
        return dtfsm_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dtfsm_(const char *transr, const char *side, const char *uplo, const char *trans, const char *diag, const int *m, const int *n, const double *alpha, const double *A, double *B, const int *ldb, size_t, size_t, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment dtfsm_$address() {
        return dtfsm_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dtfsm_(const char *transr, const char *side, const char *uplo, const char *trans, const char *diag, const int *m, const int *n, const double *alpha, const double *A, double *B, const int *ldb, size_t, size_t, size_t, size_t, size_t)
     * }
     */
    public static void dtfsm_(MemorySegment transr, MemorySegment side, MemorySegment uplo, MemorySegment trans, MemorySegment diag, MemorySegment m, MemorySegment n, MemorySegment alpha, MemorySegment A, MemorySegment B, MemorySegment ldb, long x11, long x12, long x13, long x14, long x15) {
        var mh$ = dtfsm_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dtfsm_", transr, side, uplo, trans, diag, m, n, alpha, A, B, ldb, x11, x12, x13, x14, x15);
            }
            mh$.invokeExact(transr, side, uplo, trans, diag, m, n, alpha, A, B, ldb, x11, x12, x13, x14, x15);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class stfsm_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("stfsm_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void stfsm_(const char *transr, const char *side, const char *uplo, const char *trans, const char *diag, const int *m, const int *n, const float *alpha, const float *A, float *B, const int *ldb, size_t, size_t, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor stfsm_$descriptor() {
        return stfsm_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void stfsm_(const char *transr, const char *side, const char *uplo, const char *trans, const char *diag, const int *m, const int *n, const float *alpha, const float *A, float *B, const int *ldb, size_t, size_t, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle stfsm_$handle() {
        return stfsm_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void stfsm_(const char *transr, const char *side, const char *uplo, const char *trans, const char *diag, const int *m, const int *n, const float *alpha, const float *A, float *B, const int *ldb, size_t, size_t, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment stfsm_$address() {
        return stfsm_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void stfsm_(const char *transr, const char *side, const char *uplo, const char *trans, const char *diag, const int *m, const int *n, const float *alpha, const float *A, float *B, const int *ldb, size_t, size_t, size_t, size_t, size_t)
     * }
     */
    public static void stfsm_(MemorySegment transr, MemorySegment side, MemorySegment uplo, MemorySegment trans, MemorySegment diag, MemorySegment m, MemorySegment n, MemorySegment alpha, MemorySegment A, MemorySegment B, MemorySegment ldb, long x11, long x12, long x13, long x14, long x15) {
        var mh$ = stfsm_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("stfsm_", transr, side, uplo, trans, diag, m, n, alpha, A, B, ldb, x11, x12, x13, x14, x15);
            }
            mh$.invokeExact(transr, side, uplo, trans, diag, m, n, alpha, A, B, ldb, x11, x12, x13, x14, x15);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ztfsm_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("ztfsm_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ztfsm_(const char *transr, const char *side, const char *uplo, const char *trans, const char *diag, const int *m, const int *n, const _Complex double *alpha, const _Complex double *A, _Complex double *B, const int *ldb, size_t, size_t, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor ztfsm_$descriptor() {
        return ztfsm_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ztfsm_(const char *transr, const char *side, const char *uplo, const char *trans, const char *diag, const int *m, const int *n, const _Complex double *alpha, const _Complex double *A, _Complex double *B, const int *ldb, size_t, size_t, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle ztfsm_$handle() {
        return ztfsm_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ztfsm_(const char *transr, const char *side, const char *uplo, const char *trans, const char *diag, const int *m, const int *n, const _Complex double *alpha, const _Complex double *A, _Complex double *B, const int *ldb, size_t, size_t, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment ztfsm_$address() {
        return ztfsm_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ztfsm_(const char *transr, const char *side, const char *uplo, const char *trans, const char *diag, const int *m, const int *n, const _Complex double *alpha, const _Complex double *A, _Complex double *B, const int *ldb, size_t, size_t, size_t, size_t, size_t)
     * }
     */
    public static void ztfsm_(MemorySegment transr, MemorySegment side, MemorySegment uplo, MemorySegment trans, MemorySegment diag, MemorySegment m, MemorySegment n, MemorySegment alpha, MemorySegment A, MemorySegment B, MemorySegment ldb, long x11, long x12, long x13, long x14, long x15) {
        var mh$ = ztfsm_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ztfsm_", transr, side, uplo, trans, diag, m, n, alpha, A, B, ldb, x11, x12, x13, x14, x15);
            }
            mh$.invokeExact(transr, side, uplo, trans, diag, m, n, alpha, A, B, ldb, x11, x12, x13, x14, x15);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ctftri_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("ctftri_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ctftri_(const char *transr, const char *uplo, const char *diag, const int *n, _Complex float *A, int *info, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor ctftri_$descriptor() {
        return ctftri_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ctftri_(const char *transr, const char *uplo, const char *diag, const int *n, _Complex float *A, int *info, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle ctftri_$handle() {
        return ctftri_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ctftri_(const char *transr, const char *uplo, const char *diag, const int *n, _Complex float *A, int *info, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment ctftri_$address() {
        return ctftri_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ctftri_(const char *transr, const char *uplo, const char *diag, const int *n, _Complex float *A, int *info, size_t, size_t, size_t)
     * }
     */
    public static void ctftri_(MemorySegment transr, MemorySegment uplo, MemorySegment diag, MemorySegment n, MemorySegment A, MemorySegment info, long x6, long x7, long x8) {
        var mh$ = ctftri_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ctftri_", transr, uplo, diag, n, A, info, x6, x7, x8);
            }
            mh$.invokeExact(transr, uplo, diag, n, A, info, x6, x7, x8);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dtftri_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("dtftri_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dtftri_(const char *transr, const char *uplo, const char *diag, const int *n, double *A, int *info, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor dtftri_$descriptor() {
        return dtftri_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dtftri_(const char *transr, const char *uplo, const char *diag, const int *n, double *A, int *info, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle dtftri_$handle() {
        return dtftri_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dtftri_(const char *transr, const char *uplo, const char *diag, const int *n, double *A, int *info, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment dtftri_$address() {
        return dtftri_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dtftri_(const char *transr, const char *uplo, const char *diag, const int *n, double *A, int *info, size_t, size_t, size_t)
     * }
     */
    public static void dtftri_(MemorySegment transr, MemorySegment uplo, MemorySegment diag, MemorySegment n, MemorySegment A, MemorySegment info, long x6, long x7, long x8) {
        var mh$ = dtftri_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dtftri_", transr, uplo, diag, n, A, info, x6, x7, x8);
            }
            mh$.invokeExact(transr, uplo, diag, n, A, info, x6, x7, x8);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class stftri_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("stftri_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void stftri_(const char *transr, const char *uplo, const char *diag, const int *n, float *A, int *info, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor stftri_$descriptor() {
        return stftri_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void stftri_(const char *transr, const char *uplo, const char *diag, const int *n, float *A, int *info, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle stftri_$handle() {
        return stftri_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void stftri_(const char *transr, const char *uplo, const char *diag, const int *n, float *A, int *info, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment stftri_$address() {
        return stftri_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void stftri_(const char *transr, const char *uplo, const char *diag, const int *n, float *A, int *info, size_t, size_t, size_t)
     * }
     */
    public static void stftri_(MemorySegment transr, MemorySegment uplo, MemorySegment diag, MemorySegment n, MemorySegment A, MemorySegment info, long x6, long x7, long x8) {
        var mh$ = stftri_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("stftri_", transr, uplo, diag, n, A, info, x6, x7, x8);
            }
            mh$.invokeExact(transr, uplo, diag, n, A, info, x6, x7, x8);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ztftri_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("ztftri_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ztftri_(const char *transr, const char *uplo, const char *diag, const int *n, _Complex double *A, int *info, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor ztftri_$descriptor() {
        return ztftri_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ztftri_(const char *transr, const char *uplo, const char *diag, const int *n, _Complex double *A, int *info, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle ztftri_$handle() {
        return ztftri_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ztftri_(const char *transr, const char *uplo, const char *diag, const int *n, _Complex double *A, int *info, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment ztftri_$address() {
        return ztftri_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ztftri_(const char *transr, const char *uplo, const char *diag, const int *n, _Complex double *A, int *info, size_t, size_t, size_t)
     * }
     */
    public static void ztftri_(MemorySegment transr, MemorySegment uplo, MemorySegment diag, MemorySegment n, MemorySegment A, MemorySegment info, long x6, long x7, long x8) {
        var mh$ = ztftri_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ztftri_", transr, uplo, diag, n, A, info, x6, x7, x8);
            }
            mh$.invokeExact(transr, uplo, diag, n, A, info, x6, x7, x8);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ctfttp_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("ctfttp_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ctfttp_(const char *transr, const char *uplo, const int *n, const _Complex float *ARF, _Complex float *AP, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor ctfttp_$descriptor() {
        return ctfttp_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ctfttp_(const char *transr, const char *uplo, const int *n, const _Complex float *ARF, _Complex float *AP, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle ctfttp_$handle() {
        return ctfttp_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ctfttp_(const char *transr, const char *uplo, const int *n, const _Complex float *ARF, _Complex float *AP, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment ctfttp_$address() {
        return ctfttp_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ctfttp_(const char *transr, const char *uplo, const int *n, const _Complex float *ARF, _Complex float *AP, int *info, size_t, size_t)
     * }
     */
    public static void ctfttp_(MemorySegment transr, MemorySegment uplo, MemorySegment n, MemorySegment ARF, MemorySegment AP, MemorySegment info, long x6, long x7) {
        var mh$ = ctfttp_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ctfttp_", transr, uplo, n, ARF, AP, info, x6, x7);
            }
            mh$.invokeExact(transr, uplo, n, ARF, AP, info, x6, x7);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dtfttp_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("dtfttp_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dtfttp_(const char *transr, const char *uplo, const int *n, const double *ARF, double *AP, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor dtfttp_$descriptor() {
        return dtfttp_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dtfttp_(const char *transr, const char *uplo, const int *n, const double *ARF, double *AP, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle dtfttp_$handle() {
        return dtfttp_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dtfttp_(const char *transr, const char *uplo, const int *n, const double *ARF, double *AP, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment dtfttp_$address() {
        return dtfttp_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dtfttp_(const char *transr, const char *uplo, const int *n, const double *ARF, double *AP, int *info, size_t, size_t)
     * }
     */
    public static void dtfttp_(MemorySegment transr, MemorySegment uplo, MemorySegment n, MemorySegment ARF, MemorySegment AP, MemorySegment info, long x6, long x7) {
        var mh$ = dtfttp_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dtfttp_", transr, uplo, n, ARF, AP, info, x6, x7);
            }
            mh$.invokeExact(transr, uplo, n, ARF, AP, info, x6, x7);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class stfttp_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("stfttp_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void stfttp_(const char *transr, const char *uplo, const int *n, const float *ARF, float *AP, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor stfttp_$descriptor() {
        return stfttp_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void stfttp_(const char *transr, const char *uplo, const int *n, const float *ARF, float *AP, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle stfttp_$handle() {
        return stfttp_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void stfttp_(const char *transr, const char *uplo, const int *n, const float *ARF, float *AP, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment stfttp_$address() {
        return stfttp_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void stfttp_(const char *transr, const char *uplo, const int *n, const float *ARF, float *AP, int *info, size_t, size_t)
     * }
     */
    public static void stfttp_(MemorySegment transr, MemorySegment uplo, MemorySegment n, MemorySegment ARF, MemorySegment AP, MemorySegment info, long x6, long x7) {
        var mh$ = stfttp_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("stfttp_", transr, uplo, n, ARF, AP, info, x6, x7);
            }
            mh$.invokeExact(transr, uplo, n, ARF, AP, info, x6, x7);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ztfttp_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("ztfttp_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ztfttp_(const char *transr, const char *uplo, const int *n, const _Complex double *ARF, _Complex double *AP, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor ztfttp_$descriptor() {
        return ztfttp_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ztfttp_(const char *transr, const char *uplo, const int *n, const _Complex double *ARF, _Complex double *AP, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle ztfttp_$handle() {
        return ztfttp_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ztfttp_(const char *transr, const char *uplo, const int *n, const _Complex double *ARF, _Complex double *AP, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment ztfttp_$address() {
        return ztfttp_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ztfttp_(const char *transr, const char *uplo, const int *n, const _Complex double *ARF, _Complex double *AP, int *info, size_t, size_t)
     * }
     */
    public static void ztfttp_(MemorySegment transr, MemorySegment uplo, MemorySegment n, MemorySegment ARF, MemorySegment AP, MemorySegment info, long x6, long x7) {
        var mh$ = ztfttp_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ztfttp_", transr, uplo, n, ARF, AP, info, x6, x7);
            }
            mh$.invokeExact(transr, uplo, n, ARF, AP, info, x6, x7);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ctfttr_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("ctfttr_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ctfttr_(const char *transr, const char *uplo, const int *n, const _Complex float *ARF, _Complex float *A, const int *lda, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor ctfttr_$descriptor() {
        return ctfttr_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ctfttr_(const char *transr, const char *uplo, const int *n, const _Complex float *ARF, _Complex float *A, const int *lda, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle ctfttr_$handle() {
        return ctfttr_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ctfttr_(const char *transr, const char *uplo, const int *n, const _Complex float *ARF, _Complex float *A, const int *lda, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment ctfttr_$address() {
        return ctfttr_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ctfttr_(const char *transr, const char *uplo, const int *n, const _Complex float *ARF, _Complex float *A, const int *lda, int *info, size_t, size_t)
     * }
     */
    public static void ctfttr_(MemorySegment transr, MemorySegment uplo, MemorySegment n, MemorySegment ARF, MemorySegment A, MemorySegment lda, MemorySegment info, long x7, long x8) {
        var mh$ = ctfttr_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ctfttr_", transr, uplo, n, ARF, A, lda, info, x7, x8);
            }
            mh$.invokeExact(transr, uplo, n, ARF, A, lda, info, x7, x8);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dtfttr_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("dtfttr_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dtfttr_(const char *transr, const char *uplo, const int *n, const double *ARF, double *A, const int *lda, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor dtfttr_$descriptor() {
        return dtfttr_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dtfttr_(const char *transr, const char *uplo, const int *n, const double *ARF, double *A, const int *lda, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle dtfttr_$handle() {
        return dtfttr_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dtfttr_(const char *transr, const char *uplo, const int *n, const double *ARF, double *A, const int *lda, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment dtfttr_$address() {
        return dtfttr_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dtfttr_(const char *transr, const char *uplo, const int *n, const double *ARF, double *A, const int *lda, int *info, size_t, size_t)
     * }
     */
    public static void dtfttr_(MemorySegment transr, MemorySegment uplo, MemorySegment n, MemorySegment ARF, MemorySegment A, MemorySegment lda, MemorySegment info, long x7, long x8) {
        var mh$ = dtfttr_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dtfttr_", transr, uplo, n, ARF, A, lda, info, x7, x8);
            }
            mh$.invokeExact(transr, uplo, n, ARF, A, lda, info, x7, x8);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class stfttr_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("stfttr_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void stfttr_(const char *transr, const char *uplo, const int *n, const float *ARF, float *A, const int *lda, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor stfttr_$descriptor() {
        return stfttr_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void stfttr_(const char *transr, const char *uplo, const int *n, const float *ARF, float *A, const int *lda, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle stfttr_$handle() {
        return stfttr_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void stfttr_(const char *transr, const char *uplo, const int *n, const float *ARF, float *A, const int *lda, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment stfttr_$address() {
        return stfttr_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void stfttr_(const char *transr, const char *uplo, const int *n, const float *ARF, float *A, const int *lda, int *info, size_t, size_t)
     * }
     */
    public static void stfttr_(MemorySegment transr, MemorySegment uplo, MemorySegment n, MemorySegment ARF, MemorySegment A, MemorySegment lda, MemorySegment info, long x7, long x8) {
        var mh$ = stfttr_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("stfttr_", transr, uplo, n, ARF, A, lda, info, x7, x8);
            }
            mh$.invokeExact(transr, uplo, n, ARF, A, lda, info, x7, x8);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ztfttr_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("ztfttr_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ztfttr_(const char *transr, const char *uplo, const int *n, const _Complex double *ARF, _Complex double *A, const int *lda, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor ztfttr_$descriptor() {
        return ztfttr_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ztfttr_(const char *transr, const char *uplo, const int *n, const _Complex double *ARF, _Complex double *A, const int *lda, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle ztfttr_$handle() {
        return ztfttr_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ztfttr_(const char *transr, const char *uplo, const int *n, const _Complex double *ARF, _Complex double *A, const int *lda, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment ztfttr_$address() {
        return ztfttr_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ztfttr_(const char *transr, const char *uplo, const int *n, const _Complex double *ARF, _Complex double *A, const int *lda, int *info, size_t, size_t)
     * }
     */
    public static void ztfttr_(MemorySegment transr, MemorySegment uplo, MemorySegment n, MemorySegment ARF, MemorySegment A, MemorySegment lda, MemorySegment info, long x7, long x8) {
        var mh$ = ztfttr_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ztfttr_", transr, uplo, n, ARF, A, lda, info, x7, x8);
            }
            mh$.invokeExact(transr, uplo, n, ARF, A, lda, info, x7, x8);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ctgevc_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("ctgevc_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ctgevc_(const char *side, const char *howmny, const int *select, const int *n, const _Complex float *S, const int *lds, const _Complex float *P, const int *ldp, _Complex float *VL, const int *ldvl, _Complex float *VR, const int *ldvr, const int *mm, int *m, _Complex float *work, float *rwork, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor ctgevc_$descriptor() {
        return ctgevc_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ctgevc_(const char *side, const char *howmny, const int *select, const int *n, const _Complex float *S, const int *lds, const _Complex float *P, const int *ldp, _Complex float *VL, const int *ldvl, _Complex float *VR, const int *ldvr, const int *mm, int *m, _Complex float *work, float *rwork, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle ctgevc_$handle() {
        return ctgevc_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ctgevc_(const char *side, const char *howmny, const int *select, const int *n, const _Complex float *S, const int *lds, const _Complex float *P, const int *ldp, _Complex float *VL, const int *ldvl, _Complex float *VR, const int *ldvr, const int *mm, int *m, _Complex float *work, float *rwork, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment ctgevc_$address() {
        return ctgevc_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ctgevc_(const char *side, const char *howmny, const int *select, const int *n, const _Complex float *S, const int *lds, const _Complex float *P, const int *ldp, _Complex float *VL, const int *ldvl, _Complex float *VR, const int *ldvr, const int *mm, int *m, _Complex float *work, float *rwork, int *info, size_t, size_t)
     * }
     */
    public static void ctgevc_(MemorySegment side, MemorySegment howmny, MemorySegment select, MemorySegment n, MemorySegment S, MemorySegment lds, MemorySegment P, MemorySegment ldp, MemorySegment VL, MemorySegment ldvl, MemorySegment VR, MemorySegment ldvr, MemorySegment mm, MemorySegment m, MemorySegment work, MemorySegment rwork, MemorySegment info, long x17, long x18) {
        var mh$ = ctgevc_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ctgevc_", side, howmny, select, n, S, lds, P, ldp, VL, ldvl, VR, ldvr, mm, m, work, rwork, info, x17, x18);
            }
            mh$.invokeExact(side, howmny, select, n, S, lds, P, ldp, VL, ldvl, VR, ldvr, mm, m, work, rwork, info, x17, x18);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dtgevc_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("dtgevc_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dtgevc_(const char *side, const char *howmny, const int *select, const int *n, const double *S, const int *lds, const double *P, const int *ldp, double *VL, const int *ldvl, double *VR, const int *ldvr, const int *mm, int *m, double *work, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor dtgevc_$descriptor() {
        return dtgevc_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dtgevc_(const char *side, const char *howmny, const int *select, const int *n, const double *S, const int *lds, const double *P, const int *ldp, double *VL, const int *ldvl, double *VR, const int *ldvr, const int *mm, int *m, double *work, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle dtgevc_$handle() {
        return dtgevc_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dtgevc_(const char *side, const char *howmny, const int *select, const int *n, const double *S, const int *lds, const double *P, const int *ldp, double *VL, const int *ldvl, double *VR, const int *ldvr, const int *mm, int *m, double *work, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment dtgevc_$address() {
        return dtgevc_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dtgevc_(const char *side, const char *howmny, const int *select, const int *n, const double *S, const int *lds, const double *P, const int *ldp, double *VL, const int *ldvl, double *VR, const int *ldvr, const int *mm, int *m, double *work, int *info, size_t, size_t)
     * }
     */
    public static void dtgevc_(MemorySegment side, MemorySegment howmny, MemorySegment select, MemorySegment n, MemorySegment S, MemorySegment lds, MemorySegment P, MemorySegment ldp, MemorySegment VL, MemorySegment ldvl, MemorySegment VR, MemorySegment ldvr, MemorySegment mm, MemorySegment m, MemorySegment work, MemorySegment info, long x16, long x17) {
        var mh$ = dtgevc_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dtgevc_", side, howmny, select, n, S, lds, P, ldp, VL, ldvl, VR, ldvr, mm, m, work, info, x16, x17);
            }
            mh$.invokeExact(side, howmny, select, n, S, lds, P, ldp, VL, ldvl, VR, ldvr, mm, m, work, info, x16, x17);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class stgevc_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("stgevc_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void stgevc_(const char *side, const char *howmny, const int *select, const int *n, const float *S, const int *lds, const float *P, const int *ldp, float *VL, const int *ldvl, float *VR, const int *ldvr, const int *mm, int *m, float *work, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor stgevc_$descriptor() {
        return stgevc_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void stgevc_(const char *side, const char *howmny, const int *select, const int *n, const float *S, const int *lds, const float *P, const int *ldp, float *VL, const int *ldvl, float *VR, const int *ldvr, const int *mm, int *m, float *work, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle stgevc_$handle() {
        return stgevc_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void stgevc_(const char *side, const char *howmny, const int *select, const int *n, const float *S, const int *lds, const float *P, const int *ldp, float *VL, const int *ldvl, float *VR, const int *ldvr, const int *mm, int *m, float *work, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment stgevc_$address() {
        return stgevc_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void stgevc_(const char *side, const char *howmny, const int *select, const int *n, const float *S, const int *lds, const float *P, const int *ldp, float *VL, const int *ldvl, float *VR, const int *ldvr, const int *mm, int *m, float *work, int *info, size_t, size_t)
     * }
     */
    public static void stgevc_(MemorySegment side, MemorySegment howmny, MemorySegment select, MemorySegment n, MemorySegment S, MemorySegment lds, MemorySegment P, MemorySegment ldp, MemorySegment VL, MemorySegment ldvl, MemorySegment VR, MemorySegment ldvr, MemorySegment mm, MemorySegment m, MemorySegment work, MemorySegment info, long x16, long x17) {
        var mh$ = stgevc_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("stgevc_", side, howmny, select, n, S, lds, P, ldp, VL, ldvl, VR, ldvr, mm, m, work, info, x16, x17);
            }
            mh$.invokeExact(side, howmny, select, n, S, lds, P, ldp, VL, ldvl, VR, ldvr, mm, m, work, info, x16, x17);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ztgevc_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("ztgevc_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ztgevc_(const char *side, const char *howmny, const int *select, const int *n, const _Complex double *S, const int *lds, const _Complex double *P, const int *ldp, _Complex double *VL, const int *ldvl, _Complex double *VR, const int *ldvr, const int *mm, int *m, _Complex double *work, double *rwork, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor ztgevc_$descriptor() {
        return ztgevc_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ztgevc_(const char *side, const char *howmny, const int *select, const int *n, const _Complex double *S, const int *lds, const _Complex double *P, const int *ldp, _Complex double *VL, const int *ldvl, _Complex double *VR, const int *ldvr, const int *mm, int *m, _Complex double *work, double *rwork, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle ztgevc_$handle() {
        return ztgevc_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ztgevc_(const char *side, const char *howmny, const int *select, const int *n, const _Complex double *S, const int *lds, const _Complex double *P, const int *ldp, _Complex double *VL, const int *ldvl, _Complex double *VR, const int *ldvr, const int *mm, int *m, _Complex double *work, double *rwork, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment ztgevc_$address() {
        return ztgevc_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ztgevc_(const char *side, const char *howmny, const int *select, const int *n, const _Complex double *S, const int *lds, const _Complex double *P, const int *ldp, _Complex double *VL, const int *ldvl, _Complex double *VR, const int *ldvr, const int *mm, int *m, _Complex double *work, double *rwork, int *info, size_t, size_t)
     * }
     */
    public static void ztgevc_(MemorySegment side, MemorySegment howmny, MemorySegment select, MemorySegment n, MemorySegment S, MemorySegment lds, MemorySegment P, MemorySegment ldp, MemorySegment VL, MemorySegment ldvl, MemorySegment VR, MemorySegment ldvr, MemorySegment mm, MemorySegment m, MemorySegment work, MemorySegment rwork, MemorySegment info, long x17, long x18) {
        var mh$ = ztgevc_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ztgevc_", side, howmny, select, n, S, lds, P, ldp, VL, ldvl, VR, ldvr, mm, m, work, rwork, info, x17, x18);
            }
            mh$.invokeExact(side, howmny, select, n, S, lds, P, ldp, VL, ldvl, VR, ldvr, mm, m, work, rwork, info, x17, x18);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ctgexc_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("ctgexc_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ctgexc_(const int *wantq, const int *wantz, const int *n, _Complex float *A, const int *lda, _Complex float *B, const int *ldb, _Complex float *Q, const int *ldq, _Complex float *Z, const int *ldz, const int *ifst, int *ilst, int *info)
     * }
     */
    public static FunctionDescriptor ctgexc_$descriptor() {
        return ctgexc_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ctgexc_(const int *wantq, const int *wantz, const int *n, _Complex float *A, const int *lda, _Complex float *B, const int *ldb, _Complex float *Q, const int *ldq, _Complex float *Z, const int *ldz, const int *ifst, int *ilst, int *info)
     * }
     */
    public static MethodHandle ctgexc_$handle() {
        return ctgexc_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ctgexc_(const int *wantq, const int *wantz, const int *n, _Complex float *A, const int *lda, _Complex float *B, const int *ldb, _Complex float *Q, const int *ldq, _Complex float *Z, const int *ldz, const int *ifst, int *ilst, int *info)
     * }
     */
    public static MemorySegment ctgexc_$address() {
        return ctgexc_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ctgexc_(const int *wantq, const int *wantz, const int *n, _Complex float *A, const int *lda, _Complex float *B, const int *ldb, _Complex float *Q, const int *ldq, _Complex float *Z, const int *ldz, const int *ifst, int *ilst, int *info)
     * }
     */
    public static void ctgexc_(MemorySegment wantq, MemorySegment wantz, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment B, MemorySegment ldb, MemorySegment Q, MemorySegment ldq, MemorySegment Z, MemorySegment ldz, MemorySegment ifst, MemorySegment ilst, MemorySegment info) {
        var mh$ = ctgexc_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ctgexc_", wantq, wantz, n, A, lda, B, ldb, Q, ldq, Z, ldz, ifst, ilst, info);
            }
            mh$.invokeExact(wantq, wantz, n, A, lda, B, ldb, Q, ldq, Z, ldz, ifst, ilst, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dtgexc_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("dtgexc_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dtgexc_(const int *wantq, const int *wantz, const int *n, double *A, const int *lda, double *B, const int *ldb, double *Q, const int *ldq, double *Z, const int *ldz, int *ifst, int *ilst, double *work, const int *lwork, int *info)
     * }
     */
    public static FunctionDescriptor dtgexc_$descriptor() {
        return dtgexc_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dtgexc_(const int *wantq, const int *wantz, const int *n, double *A, const int *lda, double *B, const int *ldb, double *Q, const int *ldq, double *Z, const int *ldz, int *ifst, int *ilst, double *work, const int *lwork, int *info)
     * }
     */
    public static MethodHandle dtgexc_$handle() {
        return dtgexc_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dtgexc_(const int *wantq, const int *wantz, const int *n, double *A, const int *lda, double *B, const int *ldb, double *Q, const int *ldq, double *Z, const int *ldz, int *ifst, int *ilst, double *work, const int *lwork, int *info)
     * }
     */
    public static MemorySegment dtgexc_$address() {
        return dtgexc_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dtgexc_(const int *wantq, const int *wantz, const int *n, double *A, const int *lda, double *B, const int *ldb, double *Q, const int *ldq, double *Z, const int *ldz, int *ifst, int *ilst, double *work, const int *lwork, int *info)
     * }
     */
    public static void dtgexc_(MemorySegment wantq, MemorySegment wantz, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment B, MemorySegment ldb, MemorySegment Q, MemorySegment ldq, MemorySegment Z, MemorySegment ldz, MemorySegment ifst, MemorySegment ilst, MemorySegment work, MemorySegment lwork, MemorySegment info) {
        var mh$ = dtgexc_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dtgexc_", wantq, wantz, n, A, lda, B, ldb, Q, ldq, Z, ldz, ifst, ilst, work, lwork, info);
            }
            mh$.invokeExact(wantq, wantz, n, A, lda, B, ldb, Q, ldq, Z, ldz, ifst, ilst, work, lwork, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class stgexc_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("stgexc_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void stgexc_(const int *wantq, const int *wantz, const int *n, float *A, const int *lda, float *B, const int *ldb, float *Q, const int *ldq, float *Z, const int *ldz, int *ifst, int *ilst, float *work, const int *lwork, int *info)
     * }
     */
    public static FunctionDescriptor stgexc_$descriptor() {
        return stgexc_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void stgexc_(const int *wantq, const int *wantz, const int *n, float *A, const int *lda, float *B, const int *ldb, float *Q, const int *ldq, float *Z, const int *ldz, int *ifst, int *ilst, float *work, const int *lwork, int *info)
     * }
     */
    public static MethodHandle stgexc_$handle() {
        return stgexc_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void stgexc_(const int *wantq, const int *wantz, const int *n, float *A, const int *lda, float *B, const int *ldb, float *Q, const int *ldq, float *Z, const int *ldz, int *ifst, int *ilst, float *work, const int *lwork, int *info)
     * }
     */
    public static MemorySegment stgexc_$address() {
        return stgexc_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void stgexc_(const int *wantq, const int *wantz, const int *n, float *A, const int *lda, float *B, const int *ldb, float *Q, const int *ldq, float *Z, const int *ldz, int *ifst, int *ilst, float *work, const int *lwork, int *info)
     * }
     */
    public static void stgexc_(MemorySegment wantq, MemorySegment wantz, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment B, MemorySegment ldb, MemorySegment Q, MemorySegment ldq, MemorySegment Z, MemorySegment ldz, MemorySegment ifst, MemorySegment ilst, MemorySegment work, MemorySegment lwork, MemorySegment info) {
        var mh$ = stgexc_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("stgexc_", wantq, wantz, n, A, lda, B, ldb, Q, ldq, Z, ldz, ifst, ilst, work, lwork, info);
            }
            mh$.invokeExact(wantq, wantz, n, A, lda, B, ldb, Q, ldq, Z, ldz, ifst, ilst, work, lwork, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ztgexc_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("ztgexc_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ztgexc_(const int *wantq, const int *wantz, const int *n, _Complex double *A, const int *lda, _Complex double *B, const int *ldb, _Complex double *Q, const int *ldq, _Complex double *Z, const int *ldz, const int *ifst, int *ilst, int *info)
     * }
     */
    public static FunctionDescriptor ztgexc_$descriptor() {
        return ztgexc_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ztgexc_(const int *wantq, const int *wantz, const int *n, _Complex double *A, const int *lda, _Complex double *B, const int *ldb, _Complex double *Q, const int *ldq, _Complex double *Z, const int *ldz, const int *ifst, int *ilst, int *info)
     * }
     */
    public static MethodHandle ztgexc_$handle() {
        return ztgexc_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ztgexc_(const int *wantq, const int *wantz, const int *n, _Complex double *A, const int *lda, _Complex double *B, const int *ldb, _Complex double *Q, const int *ldq, _Complex double *Z, const int *ldz, const int *ifst, int *ilst, int *info)
     * }
     */
    public static MemorySegment ztgexc_$address() {
        return ztgexc_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ztgexc_(const int *wantq, const int *wantz, const int *n, _Complex double *A, const int *lda, _Complex double *B, const int *ldb, _Complex double *Q, const int *ldq, _Complex double *Z, const int *ldz, const int *ifst, int *ilst, int *info)
     * }
     */
    public static void ztgexc_(MemorySegment wantq, MemorySegment wantz, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment B, MemorySegment ldb, MemorySegment Q, MemorySegment ldq, MemorySegment Z, MemorySegment ldz, MemorySegment ifst, MemorySegment ilst, MemorySegment info) {
        var mh$ = ztgexc_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ztgexc_", wantq, wantz, n, A, lda, B, ldb, Q, ldq, Z, ldz, ifst, ilst, info);
            }
            mh$.invokeExact(wantq, wantz, n, A, lda, B, ldb, Q, ldq, Z, ldz, ifst, ilst, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ctgsen_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("ctgsen_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ctgsen_(const int *ijob, const int *wantq, const int *wantz, const int *select, const int *n, _Complex float *A, const int *lda, _Complex float *B, const int *ldb, _Complex float *alpha, _Complex float *beta, _Complex float *Q, const int *ldq, _Complex float *Z, const int *ldz, int *m, float *pl, float *pr, float *DIF, _Complex float *work, const int *lwork, int *iwork, const int *liwork, int *info)
     * }
     */
    public static FunctionDescriptor ctgsen_$descriptor() {
        return ctgsen_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ctgsen_(const int *ijob, const int *wantq, const int *wantz, const int *select, const int *n, _Complex float *A, const int *lda, _Complex float *B, const int *ldb, _Complex float *alpha, _Complex float *beta, _Complex float *Q, const int *ldq, _Complex float *Z, const int *ldz, int *m, float *pl, float *pr, float *DIF, _Complex float *work, const int *lwork, int *iwork, const int *liwork, int *info)
     * }
     */
    public static MethodHandle ctgsen_$handle() {
        return ctgsen_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ctgsen_(const int *ijob, const int *wantq, const int *wantz, const int *select, const int *n, _Complex float *A, const int *lda, _Complex float *B, const int *ldb, _Complex float *alpha, _Complex float *beta, _Complex float *Q, const int *ldq, _Complex float *Z, const int *ldz, int *m, float *pl, float *pr, float *DIF, _Complex float *work, const int *lwork, int *iwork, const int *liwork, int *info)
     * }
     */
    public static MemorySegment ctgsen_$address() {
        return ctgsen_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ctgsen_(const int *ijob, const int *wantq, const int *wantz, const int *select, const int *n, _Complex float *A, const int *lda, _Complex float *B, const int *ldb, _Complex float *alpha, _Complex float *beta, _Complex float *Q, const int *ldq, _Complex float *Z, const int *ldz, int *m, float *pl, float *pr, float *DIF, _Complex float *work, const int *lwork, int *iwork, const int *liwork, int *info)
     * }
     */
    public static void ctgsen_(MemorySegment ijob, MemorySegment wantq, MemorySegment wantz, MemorySegment select, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment B, MemorySegment ldb, MemorySegment alpha, MemorySegment beta, MemorySegment Q, MemorySegment ldq, MemorySegment Z, MemorySegment ldz, MemorySegment m, MemorySegment pl, MemorySegment pr, MemorySegment DIF, MemorySegment work, MemorySegment lwork, MemorySegment iwork, MemorySegment liwork, MemorySegment info) {
        var mh$ = ctgsen_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ctgsen_", ijob, wantq, wantz, select, n, A, lda, B, ldb, alpha, beta, Q, ldq, Z, ldz, m, pl, pr, DIF, work, lwork, iwork, liwork, info);
            }
            mh$.invokeExact(ijob, wantq, wantz, select, n, A, lda, B, ldb, alpha, beta, Q, ldq, Z, ldz, m, pl, pr, DIF, work, lwork, iwork, liwork, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dtgsen_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("dtgsen_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dtgsen_(const int *ijob, const int *wantq, const int *wantz, const int *select, const int *n, double *A, const int *lda, double *B, const int *ldb, double *alphar, double *alphai, double *beta, double *Q, const int *ldq, double *Z, const int *ldz, int *m, double *pl, double *pr, double *DIF, double *work, const int *lwork, int *iwork, const int *liwork, int *info)
     * }
     */
    public static FunctionDescriptor dtgsen_$descriptor() {
        return dtgsen_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dtgsen_(const int *ijob, const int *wantq, const int *wantz, const int *select, const int *n, double *A, const int *lda, double *B, const int *ldb, double *alphar, double *alphai, double *beta, double *Q, const int *ldq, double *Z, const int *ldz, int *m, double *pl, double *pr, double *DIF, double *work, const int *lwork, int *iwork, const int *liwork, int *info)
     * }
     */
    public static MethodHandle dtgsen_$handle() {
        return dtgsen_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dtgsen_(const int *ijob, const int *wantq, const int *wantz, const int *select, const int *n, double *A, const int *lda, double *B, const int *ldb, double *alphar, double *alphai, double *beta, double *Q, const int *ldq, double *Z, const int *ldz, int *m, double *pl, double *pr, double *DIF, double *work, const int *lwork, int *iwork, const int *liwork, int *info)
     * }
     */
    public static MemorySegment dtgsen_$address() {
        return dtgsen_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dtgsen_(const int *ijob, const int *wantq, const int *wantz, const int *select, const int *n, double *A, const int *lda, double *B, const int *ldb, double *alphar, double *alphai, double *beta, double *Q, const int *ldq, double *Z, const int *ldz, int *m, double *pl, double *pr, double *DIF, double *work, const int *lwork, int *iwork, const int *liwork, int *info)
     * }
     */
    public static void dtgsen_(MemorySegment ijob, MemorySegment wantq, MemorySegment wantz, MemorySegment select, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment B, MemorySegment ldb, MemorySegment alphar, MemorySegment alphai, MemorySegment beta, MemorySegment Q, MemorySegment ldq, MemorySegment Z, MemorySegment ldz, MemorySegment m, MemorySegment pl, MemorySegment pr, MemorySegment DIF, MemorySegment work, MemorySegment lwork, MemorySegment iwork, MemorySegment liwork, MemorySegment info) {
        var mh$ = dtgsen_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dtgsen_", ijob, wantq, wantz, select, n, A, lda, B, ldb, alphar, alphai, beta, Q, ldq, Z, ldz, m, pl, pr, DIF, work, lwork, iwork, liwork, info);
            }
            mh$.invokeExact(ijob, wantq, wantz, select, n, A, lda, B, ldb, alphar, alphai, beta, Q, ldq, Z, ldz, m, pl, pr, DIF, work, lwork, iwork, liwork, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class stgsen_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("stgsen_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void stgsen_(const int *ijob, const int *wantq, const int *wantz, const int *select, const int *n, float *A, const int *lda, float *B, const int *ldb, float *alphar, float *alphai, float *beta, float *Q, const int *ldq, float *Z, const int *ldz, int *m, float *pl, float *pr, float *DIF, float *work, const int *lwork, int *iwork, const int *liwork, int *info)
     * }
     */
    public static FunctionDescriptor stgsen_$descriptor() {
        return stgsen_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void stgsen_(const int *ijob, const int *wantq, const int *wantz, const int *select, const int *n, float *A, const int *lda, float *B, const int *ldb, float *alphar, float *alphai, float *beta, float *Q, const int *ldq, float *Z, const int *ldz, int *m, float *pl, float *pr, float *DIF, float *work, const int *lwork, int *iwork, const int *liwork, int *info)
     * }
     */
    public static MethodHandle stgsen_$handle() {
        return stgsen_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void stgsen_(const int *ijob, const int *wantq, const int *wantz, const int *select, const int *n, float *A, const int *lda, float *B, const int *ldb, float *alphar, float *alphai, float *beta, float *Q, const int *ldq, float *Z, const int *ldz, int *m, float *pl, float *pr, float *DIF, float *work, const int *lwork, int *iwork, const int *liwork, int *info)
     * }
     */
    public static MemorySegment stgsen_$address() {
        return stgsen_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void stgsen_(const int *ijob, const int *wantq, const int *wantz, const int *select, const int *n, float *A, const int *lda, float *B, const int *ldb, float *alphar, float *alphai, float *beta, float *Q, const int *ldq, float *Z, const int *ldz, int *m, float *pl, float *pr, float *DIF, float *work, const int *lwork, int *iwork, const int *liwork, int *info)
     * }
     */
    public static void stgsen_(MemorySegment ijob, MemorySegment wantq, MemorySegment wantz, MemorySegment select, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment B, MemorySegment ldb, MemorySegment alphar, MemorySegment alphai, MemorySegment beta, MemorySegment Q, MemorySegment ldq, MemorySegment Z, MemorySegment ldz, MemorySegment m, MemorySegment pl, MemorySegment pr, MemorySegment DIF, MemorySegment work, MemorySegment lwork, MemorySegment iwork, MemorySegment liwork, MemorySegment info) {
        var mh$ = stgsen_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("stgsen_", ijob, wantq, wantz, select, n, A, lda, B, ldb, alphar, alphai, beta, Q, ldq, Z, ldz, m, pl, pr, DIF, work, lwork, iwork, liwork, info);
            }
            mh$.invokeExact(ijob, wantq, wantz, select, n, A, lda, B, ldb, alphar, alphai, beta, Q, ldq, Z, ldz, m, pl, pr, DIF, work, lwork, iwork, liwork, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ztgsen_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("ztgsen_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ztgsen_(const int *ijob, const int *wantq, const int *wantz, const int *select, const int *n, _Complex double *A, const int *lda, _Complex double *B, const int *ldb, _Complex double *alpha, _Complex double *beta, _Complex double *Q, const int *ldq, _Complex double *Z, const int *ldz, int *m, double *pl, double *pr, double *DIF, _Complex double *work, const int *lwork, int *iwork, const int *liwork, int *info)
     * }
     */
    public static FunctionDescriptor ztgsen_$descriptor() {
        return ztgsen_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ztgsen_(const int *ijob, const int *wantq, const int *wantz, const int *select, const int *n, _Complex double *A, const int *lda, _Complex double *B, const int *ldb, _Complex double *alpha, _Complex double *beta, _Complex double *Q, const int *ldq, _Complex double *Z, const int *ldz, int *m, double *pl, double *pr, double *DIF, _Complex double *work, const int *lwork, int *iwork, const int *liwork, int *info)
     * }
     */
    public static MethodHandle ztgsen_$handle() {
        return ztgsen_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ztgsen_(const int *ijob, const int *wantq, const int *wantz, const int *select, const int *n, _Complex double *A, const int *lda, _Complex double *B, const int *ldb, _Complex double *alpha, _Complex double *beta, _Complex double *Q, const int *ldq, _Complex double *Z, const int *ldz, int *m, double *pl, double *pr, double *DIF, _Complex double *work, const int *lwork, int *iwork, const int *liwork, int *info)
     * }
     */
    public static MemorySegment ztgsen_$address() {
        return ztgsen_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ztgsen_(const int *ijob, const int *wantq, const int *wantz, const int *select, const int *n, _Complex double *A, const int *lda, _Complex double *B, const int *ldb, _Complex double *alpha, _Complex double *beta, _Complex double *Q, const int *ldq, _Complex double *Z, const int *ldz, int *m, double *pl, double *pr, double *DIF, _Complex double *work, const int *lwork, int *iwork, const int *liwork, int *info)
     * }
     */
    public static void ztgsen_(MemorySegment ijob, MemorySegment wantq, MemorySegment wantz, MemorySegment select, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment B, MemorySegment ldb, MemorySegment alpha, MemorySegment beta, MemorySegment Q, MemorySegment ldq, MemorySegment Z, MemorySegment ldz, MemorySegment m, MemorySegment pl, MemorySegment pr, MemorySegment DIF, MemorySegment work, MemorySegment lwork, MemorySegment iwork, MemorySegment liwork, MemorySegment info) {
        var mh$ = ztgsen_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ztgsen_", ijob, wantq, wantz, select, n, A, lda, B, ldb, alpha, beta, Q, ldq, Z, ldz, m, pl, pr, DIF, work, lwork, iwork, liwork, info);
            }
            mh$.invokeExact(ijob, wantq, wantz, select, n, A, lda, B, ldb, alpha, beta, Q, ldq, Z, ldz, m, pl, pr, DIF, work, lwork, iwork, liwork, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ctgsja_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("ctgsja_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ctgsja_(const char *jobu, const char *jobv, const char *jobq, const int *m, const int *p, const int *n, const int *k, const int *l, _Complex float *A, const int *lda, _Complex float *B, const int *ldb, const float *tola, const float *tolb, float *alpha, float *beta, _Complex float *U, const int *ldu, _Complex float *V, const int *ldv, _Complex float *Q, const int *ldq, _Complex float *work, int *ncycle, int *info, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor ctgsja_$descriptor() {
        return ctgsja_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ctgsja_(const char *jobu, const char *jobv, const char *jobq, const int *m, const int *p, const int *n, const int *k, const int *l, _Complex float *A, const int *lda, _Complex float *B, const int *ldb, const float *tola, const float *tolb, float *alpha, float *beta, _Complex float *U, const int *ldu, _Complex float *V, const int *ldv, _Complex float *Q, const int *ldq, _Complex float *work, int *ncycle, int *info, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle ctgsja_$handle() {
        return ctgsja_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ctgsja_(const char *jobu, const char *jobv, const char *jobq, const int *m, const int *p, const int *n, const int *k, const int *l, _Complex float *A, const int *lda, _Complex float *B, const int *ldb, const float *tola, const float *tolb, float *alpha, float *beta, _Complex float *U, const int *ldu, _Complex float *V, const int *ldv, _Complex float *Q, const int *ldq, _Complex float *work, int *ncycle, int *info, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment ctgsja_$address() {
        return ctgsja_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ctgsja_(const char *jobu, const char *jobv, const char *jobq, const int *m, const int *p, const int *n, const int *k, const int *l, _Complex float *A, const int *lda, _Complex float *B, const int *ldb, const float *tola, const float *tolb, float *alpha, float *beta, _Complex float *U, const int *ldu, _Complex float *V, const int *ldv, _Complex float *Q, const int *ldq, _Complex float *work, int *ncycle, int *info, size_t, size_t, size_t)
     * }
     */
    public static void ctgsja_(MemorySegment jobu, MemorySegment jobv, MemorySegment jobq, MemorySegment m, MemorySegment p, MemorySegment n, MemorySegment k, MemorySegment l, MemorySegment A, MemorySegment lda, MemorySegment B, MemorySegment ldb, MemorySegment tola, MemorySegment tolb, MemorySegment alpha, MemorySegment beta, MemorySegment U, MemorySegment ldu, MemorySegment V, MemorySegment ldv, MemorySegment Q, MemorySegment ldq, MemorySegment work, MemorySegment ncycle, MemorySegment info, long x25, long x26, long x27) {
        var mh$ = ctgsja_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ctgsja_", jobu, jobv, jobq, m, p, n, k, l, A, lda, B, ldb, tola, tolb, alpha, beta, U, ldu, V, ldv, Q, ldq, work, ncycle, info, x25, x26, x27);
            }
            mh$.invokeExact(jobu, jobv, jobq, m, p, n, k, l, A, lda, B, ldb, tola, tolb, alpha, beta, U, ldu, V, ldv, Q, ldq, work, ncycle, info, x25, x26, x27);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dtgsja_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("dtgsja_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dtgsja_(const char *jobu, const char *jobv, const char *jobq, const int *m, const int *p, const int *n, const int *k, const int *l, double *A, const int *lda, double *B, const int *ldb, const double *tola, const double *tolb, double *alpha, double *beta, double *U, const int *ldu, double *V, const int *ldv, double *Q, const int *ldq, double *work, int *ncycle, int *info, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor dtgsja_$descriptor() {
        return dtgsja_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dtgsja_(const char *jobu, const char *jobv, const char *jobq, const int *m, const int *p, const int *n, const int *k, const int *l, double *A, const int *lda, double *B, const int *ldb, const double *tola, const double *tolb, double *alpha, double *beta, double *U, const int *ldu, double *V, const int *ldv, double *Q, const int *ldq, double *work, int *ncycle, int *info, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle dtgsja_$handle() {
        return dtgsja_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dtgsja_(const char *jobu, const char *jobv, const char *jobq, const int *m, const int *p, const int *n, const int *k, const int *l, double *A, const int *lda, double *B, const int *ldb, const double *tola, const double *tolb, double *alpha, double *beta, double *U, const int *ldu, double *V, const int *ldv, double *Q, const int *ldq, double *work, int *ncycle, int *info, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment dtgsja_$address() {
        return dtgsja_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dtgsja_(const char *jobu, const char *jobv, const char *jobq, const int *m, const int *p, const int *n, const int *k, const int *l, double *A, const int *lda, double *B, const int *ldb, const double *tola, const double *tolb, double *alpha, double *beta, double *U, const int *ldu, double *V, const int *ldv, double *Q, const int *ldq, double *work, int *ncycle, int *info, size_t, size_t, size_t)
     * }
     */
    public static void dtgsja_(MemorySegment jobu, MemorySegment jobv, MemorySegment jobq, MemorySegment m, MemorySegment p, MemorySegment n, MemorySegment k, MemorySegment l, MemorySegment A, MemorySegment lda, MemorySegment B, MemorySegment ldb, MemorySegment tola, MemorySegment tolb, MemorySegment alpha, MemorySegment beta, MemorySegment U, MemorySegment ldu, MemorySegment V, MemorySegment ldv, MemorySegment Q, MemorySegment ldq, MemorySegment work, MemorySegment ncycle, MemorySegment info, long x25, long x26, long x27) {
        var mh$ = dtgsja_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dtgsja_", jobu, jobv, jobq, m, p, n, k, l, A, lda, B, ldb, tola, tolb, alpha, beta, U, ldu, V, ldv, Q, ldq, work, ncycle, info, x25, x26, x27);
            }
            mh$.invokeExact(jobu, jobv, jobq, m, p, n, k, l, A, lda, B, ldb, tola, tolb, alpha, beta, U, ldu, V, ldv, Q, ldq, work, ncycle, info, x25, x26, x27);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class stgsja_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("stgsja_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void stgsja_(const char *jobu, const char *jobv, const char *jobq, const int *m, const int *p, const int *n, const int *k, const int *l, float *A, const int *lda, float *B, const int *ldb, const float *tola, const float *tolb, float *alpha, float *beta, float *U, const int *ldu, float *V, const int *ldv, float *Q, const int *ldq, float *work, int *ncycle, int *info, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor stgsja_$descriptor() {
        return stgsja_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void stgsja_(const char *jobu, const char *jobv, const char *jobq, const int *m, const int *p, const int *n, const int *k, const int *l, float *A, const int *lda, float *B, const int *ldb, const float *tola, const float *tolb, float *alpha, float *beta, float *U, const int *ldu, float *V, const int *ldv, float *Q, const int *ldq, float *work, int *ncycle, int *info, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle stgsja_$handle() {
        return stgsja_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void stgsja_(const char *jobu, const char *jobv, const char *jobq, const int *m, const int *p, const int *n, const int *k, const int *l, float *A, const int *lda, float *B, const int *ldb, const float *tola, const float *tolb, float *alpha, float *beta, float *U, const int *ldu, float *V, const int *ldv, float *Q, const int *ldq, float *work, int *ncycle, int *info, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment stgsja_$address() {
        return stgsja_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void stgsja_(const char *jobu, const char *jobv, const char *jobq, const int *m, const int *p, const int *n, const int *k, const int *l, float *A, const int *lda, float *B, const int *ldb, const float *tola, const float *tolb, float *alpha, float *beta, float *U, const int *ldu, float *V, const int *ldv, float *Q, const int *ldq, float *work, int *ncycle, int *info, size_t, size_t, size_t)
     * }
     */
    public static void stgsja_(MemorySegment jobu, MemorySegment jobv, MemorySegment jobq, MemorySegment m, MemorySegment p, MemorySegment n, MemorySegment k, MemorySegment l, MemorySegment A, MemorySegment lda, MemorySegment B, MemorySegment ldb, MemorySegment tola, MemorySegment tolb, MemorySegment alpha, MemorySegment beta, MemorySegment U, MemorySegment ldu, MemorySegment V, MemorySegment ldv, MemorySegment Q, MemorySegment ldq, MemorySegment work, MemorySegment ncycle, MemorySegment info, long x25, long x26, long x27) {
        var mh$ = stgsja_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("stgsja_", jobu, jobv, jobq, m, p, n, k, l, A, lda, B, ldb, tola, tolb, alpha, beta, U, ldu, V, ldv, Q, ldq, work, ncycle, info, x25, x26, x27);
            }
            mh$.invokeExact(jobu, jobv, jobq, m, p, n, k, l, A, lda, B, ldb, tola, tolb, alpha, beta, U, ldu, V, ldv, Q, ldq, work, ncycle, info, x25, x26, x27);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ztgsja_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("ztgsja_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ztgsja_(const char *jobu, const char *jobv, const char *jobq, const int *m, const int *p, const int *n, const int *k, const int *l, _Complex double *A, const int *lda, _Complex double *B, const int *ldb, const double *tola, const double *tolb, double *alpha, double *beta, _Complex double *U, const int *ldu, _Complex double *V, const int *ldv, _Complex double *Q, const int *ldq, _Complex double *work, int *ncycle, int *info, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor ztgsja_$descriptor() {
        return ztgsja_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ztgsja_(const char *jobu, const char *jobv, const char *jobq, const int *m, const int *p, const int *n, const int *k, const int *l, _Complex double *A, const int *lda, _Complex double *B, const int *ldb, const double *tola, const double *tolb, double *alpha, double *beta, _Complex double *U, const int *ldu, _Complex double *V, const int *ldv, _Complex double *Q, const int *ldq, _Complex double *work, int *ncycle, int *info, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle ztgsja_$handle() {
        return ztgsja_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ztgsja_(const char *jobu, const char *jobv, const char *jobq, const int *m, const int *p, const int *n, const int *k, const int *l, _Complex double *A, const int *lda, _Complex double *B, const int *ldb, const double *tola, const double *tolb, double *alpha, double *beta, _Complex double *U, const int *ldu, _Complex double *V, const int *ldv, _Complex double *Q, const int *ldq, _Complex double *work, int *ncycle, int *info, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment ztgsja_$address() {
        return ztgsja_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ztgsja_(const char *jobu, const char *jobv, const char *jobq, const int *m, const int *p, const int *n, const int *k, const int *l, _Complex double *A, const int *lda, _Complex double *B, const int *ldb, const double *tola, const double *tolb, double *alpha, double *beta, _Complex double *U, const int *ldu, _Complex double *V, const int *ldv, _Complex double *Q, const int *ldq, _Complex double *work, int *ncycle, int *info, size_t, size_t, size_t)
     * }
     */
    public static void ztgsja_(MemorySegment jobu, MemorySegment jobv, MemorySegment jobq, MemorySegment m, MemorySegment p, MemorySegment n, MemorySegment k, MemorySegment l, MemorySegment A, MemorySegment lda, MemorySegment B, MemorySegment ldb, MemorySegment tola, MemorySegment tolb, MemorySegment alpha, MemorySegment beta, MemorySegment U, MemorySegment ldu, MemorySegment V, MemorySegment ldv, MemorySegment Q, MemorySegment ldq, MemorySegment work, MemorySegment ncycle, MemorySegment info, long x25, long x26, long x27) {
        var mh$ = ztgsja_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ztgsja_", jobu, jobv, jobq, m, p, n, k, l, A, lda, B, ldb, tola, tolb, alpha, beta, U, ldu, V, ldv, Q, ldq, work, ncycle, info, x25, x26, x27);
            }
            mh$.invokeExact(jobu, jobv, jobq, m, p, n, k, l, A, lda, B, ldb, tola, tolb, alpha, beta, U, ldu, V, ldv, Q, ldq, work, ncycle, info, x25, x26, x27);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ctgsna_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("ctgsna_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ctgsna_(const char *job, const char *howmny, const int *select, const int *n, const _Complex float *A, const int *lda, const _Complex float *B, const int *ldb, const _Complex float *VL, const int *ldvl, const _Complex float *VR, const int *ldvr, float *S, float *DIF, const int *mm, int *m, _Complex float *work, const int *lwork, int *iwork, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor ctgsna_$descriptor() {
        return ctgsna_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ctgsna_(const char *job, const char *howmny, const int *select, const int *n, const _Complex float *A, const int *lda, const _Complex float *B, const int *ldb, const _Complex float *VL, const int *ldvl, const _Complex float *VR, const int *ldvr, float *S, float *DIF, const int *mm, int *m, _Complex float *work, const int *lwork, int *iwork, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle ctgsna_$handle() {
        return ctgsna_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ctgsna_(const char *job, const char *howmny, const int *select, const int *n, const _Complex float *A, const int *lda, const _Complex float *B, const int *ldb, const _Complex float *VL, const int *ldvl, const _Complex float *VR, const int *ldvr, float *S, float *DIF, const int *mm, int *m, _Complex float *work, const int *lwork, int *iwork, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment ctgsna_$address() {
        return ctgsna_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ctgsna_(const char *job, const char *howmny, const int *select, const int *n, const _Complex float *A, const int *lda, const _Complex float *B, const int *ldb, const _Complex float *VL, const int *ldvl, const _Complex float *VR, const int *ldvr, float *S, float *DIF, const int *mm, int *m, _Complex float *work, const int *lwork, int *iwork, int *info, size_t, size_t)
     * }
     */
    public static void ctgsna_(MemorySegment job, MemorySegment howmny, MemorySegment select, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment B, MemorySegment ldb, MemorySegment VL, MemorySegment ldvl, MemorySegment VR, MemorySegment ldvr, MemorySegment S, MemorySegment DIF, MemorySegment mm, MemorySegment m, MemorySegment work, MemorySegment lwork, MemorySegment iwork, MemorySegment info, long x20, long x21) {
        var mh$ = ctgsna_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ctgsna_", job, howmny, select, n, A, lda, B, ldb, VL, ldvl, VR, ldvr, S, DIF, mm, m, work, lwork, iwork, info, x20, x21);
            }
            mh$.invokeExact(job, howmny, select, n, A, lda, B, ldb, VL, ldvl, VR, ldvr, S, DIF, mm, m, work, lwork, iwork, info, x20, x21);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dtgsna_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("dtgsna_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dtgsna_(const char *job, const char *howmny, const int *select, const int *n, const double *A, const int *lda, const double *B, const int *ldb, const double *VL, const int *ldvl, const double *VR, const int *ldvr, double *S, double *DIF, const int *mm, int *m, double *work, const int *lwork, int *iwork, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor dtgsna_$descriptor() {
        return dtgsna_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dtgsna_(const char *job, const char *howmny, const int *select, const int *n, const double *A, const int *lda, const double *B, const int *ldb, const double *VL, const int *ldvl, const double *VR, const int *ldvr, double *S, double *DIF, const int *mm, int *m, double *work, const int *lwork, int *iwork, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle dtgsna_$handle() {
        return dtgsna_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dtgsna_(const char *job, const char *howmny, const int *select, const int *n, const double *A, const int *lda, const double *B, const int *ldb, const double *VL, const int *ldvl, const double *VR, const int *ldvr, double *S, double *DIF, const int *mm, int *m, double *work, const int *lwork, int *iwork, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment dtgsna_$address() {
        return dtgsna_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dtgsna_(const char *job, const char *howmny, const int *select, const int *n, const double *A, const int *lda, const double *B, const int *ldb, const double *VL, const int *ldvl, const double *VR, const int *ldvr, double *S, double *DIF, const int *mm, int *m, double *work, const int *lwork, int *iwork, int *info, size_t, size_t)
     * }
     */
    public static void dtgsna_(MemorySegment job, MemorySegment howmny, MemorySegment select, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment B, MemorySegment ldb, MemorySegment VL, MemorySegment ldvl, MemorySegment VR, MemorySegment ldvr, MemorySegment S, MemorySegment DIF, MemorySegment mm, MemorySegment m, MemorySegment work, MemorySegment lwork, MemorySegment iwork, MemorySegment info, long x20, long x21) {
        var mh$ = dtgsna_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dtgsna_", job, howmny, select, n, A, lda, B, ldb, VL, ldvl, VR, ldvr, S, DIF, mm, m, work, lwork, iwork, info, x20, x21);
            }
            mh$.invokeExact(job, howmny, select, n, A, lda, B, ldb, VL, ldvl, VR, ldvr, S, DIF, mm, m, work, lwork, iwork, info, x20, x21);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class stgsna_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("stgsna_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void stgsna_(const char *job, const char *howmny, const int *select, const int *n, const float *A, const int *lda, const float *B, const int *ldb, const float *VL, const int *ldvl, const float *VR, const int *ldvr, float *S, float *DIF, const int *mm, int *m, float *work, const int *lwork, int *iwork, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor stgsna_$descriptor() {
        return stgsna_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void stgsna_(const char *job, const char *howmny, const int *select, const int *n, const float *A, const int *lda, const float *B, const int *ldb, const float *VL, const int *ldvl, const float *VR, const int *ldvr, float *S, float *DIF, const int *mm, int *m, float *work, const int *lwork, int *iwork, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle stgsna_$handle() {
        return stgsna_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void stgsna_(const char *job, const char *howmny, const int *select, const int *n, const float *A, const int *lda, const float *B, const int *ldb, const float *VL, const int *ldvl, const float *VR, const int *ldvr, float *S, float *DIF, const int *mm, int *m, float *work, const int *lwork, int *iwork, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment stgsna_$address() {
        return stgsna_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void stgsna_(const char *job, const char *howmny, const int *select, const int *n, const float *A, const int *lda, const float *B, const int *ldb, const float *VL, const int *ldvl, const float *VR, const int *ldvr, float *S, float *DIF, const int *mm, int *m, float *work, const int *lwork, int *iwork, int *info, size_t, size_t)
     * }
     */
    public static void stgsna_(MemorySegment job, MemorySegment howmny, MemorySegment select, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment B, MemorySegment ldb, MemorySegment VL, MemorySegment ldvl, MemorySegment VR, MemorySegment ldvr, MemorySegment S, MemorySegment DIF, MemorySegment mm, MemorySegment m, MemorySegment work, MemorySegment lwork, MemorySegment iwork, MemorySegment info, long x20, long x21) {
        var mh$ = stgsna_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("stgsna_", job, howmny, select, n, A, lda, B, ldb, VL, ldvl, VR, ldvr, S, DIF, mm, m, work, lwork, iwork, info, x20, x21);
            }
            mh$.invokeExact(job, howmny, select, n, A, lda, B, ldb, VL, ldvl, VR, ldvr, S, DIF, mm, m, work, lwork, iwork, info, x20, x21);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ztgsna_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("ztgsna_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ztgsna_(const char *job, const char *howmny, const int *select, const int *n, const _Complex double *A, const int *lda, const _Complex double *B, const int *ldb, const _Complex double *VL, const int *ldvl, const _Complex double *VR, const int *ldvr, double *S, double *DIF, const int *mm, int *m, _Complex double *work, const int *lwork, int *iwork, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor ztgsna_$descriptor() {
        return ztgsna_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ztgsna_(const char *job, const char *howmny, const int *select, const int *n, const _Complex double *A, const int *lda, const _Complex double *B, const int *ldb, const _Complex double *VL, const int *ldvl, const _Complex double *VR, const int *ldvr, double *S, double *DIF, const int *mm, int *m, _Complex double *work, const int *lwork, int *iwork, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle ztgsna_$handle() {
        return ztgsna_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ztgsna_(const char *job, const char *howmny, const int *select, const int *n, const _Complex double *A, const int *lda, const _Complex double *B, const int *ldb, const _Complex double *VL, const int *ldvl, const _Complex double *VR, const int *ldvr, double *S, double *DIF, const int *mm, int *m, _Complex double *work, const int *lwork, int *iwork, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment ztgsna_$address() {
        return ztgsna_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ztgsna_(const char *job, const char *howmny, const int *select, const int *n, const _Complex double *A, const int *lda, const _Complex double *B, const int *ldb, const _Complex double *VL, const int *ldvl, const _Complex double *VR, const int *ldvr, double *S, double *DIF, const int *mm, int *m, _Complex double *work, const int *lwork, int *iwork, int *info, size_t, size_t)
     * }
     */
    public static void ztgsna_(MemorySegment job, MemorySegment howmny, MemorySegment select, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment B, MemorySegment ldb, MemorySegment VL, MemorySegment ldvl, MemorySegment VR, MemorySegment ldvr, MemorySegment S, MemorySegment DIF, MemorySegment mm, MemorySegment m, MemorySegment work, MemorySegment lwork, MemorySegment iwork, MemorySegment info, long x20, long x21) {
        var mh$ = ztgsna_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ztgsna_", job, howmny, select, n, A, lda, B, ldb, VL, ldvl, VR, ldvr, S, DIF, mm, m, work, lwork, iwork, info, x20, x21);
            }
            mh$.invokeExact(job, howmny, select, n, A, lda, B, ldb, VL, ldvl, VR, ldvr, S, DIF, mm, m, work, lwork, iwork, info, x20, x21);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ctgsyl_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("ctgsyl_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ctgsyl_(const char *trans, const int *ijob, const int *m, const int *n, const _Complex float *A, const int *lda, const _Complex float *B, const int *ldb, _Complex float *C, const int *ldc, const _Complex float *D, const int *ldd, const _Complex float *E, const int *lde, _Complex float *F, const int *ldf, float *dif, float *scale, _Complex float *work, const int *lwork, int *iwork, int *info, size_t)
     * }
     */
    public static FunctionDescriptor ctgsyl_$descriptor() {
        return ctgsyl_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ctgsyl_(const char *trans, const int *ijob, const int *m, const int *n, const _Complex float *A, const int *lda, const _Complex float *B, const int *ldb, _Complex float *C, const int *ldc, const _Complex float *D, const int *ldd, const _Complex float *E, const int *lde, _Complex float *F, const int *ldf, float *dif, float *scale, _Complex float *work, const int *lwork, int *iwork, int *info, size_t)
     * }
     */
    public static MethodHandle ctgsyl_$handle() {
        return ctgsyl_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ctgsyl_(const char *trans, const int *ijob, const int *m, const int *n, const _Complex float *A, const int *lda, const _Complex float *B, const int *ldb, _Complex float *C, const int *ldc, const _Complex float *D, const int *ldd, const _Complex float *E, const int *lde, _Complex float *F, const int *ldf, float *dif, float *scale, _Complex float *work, const int *lwork, int *iwork, int *info, size_t)
     * }
     */
    public static MemorySegment ctgsyl_$address() {
        return ctgsyl_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ctgsyl_(const char *trans, const int *ijob, const int *m, const int *n, const _Complex float *A, const int *lda, const _Complex float *B, const int *ldb, _Complex float *C, const int *ldc, const _Complex float *D, const int *ldd, const _Complex float *E, const int *lde, _Complex float *F, const int *ldf, float *dif, float *scale, _Complex float *work, const int *lwork, int *iwork, int *info, size_t)
     * }
     */
    public static void ctgsyl_(MemorySegment trans, MemorySegment ijob, MemorySegment m, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment B, MemorySegment ldb, MemorySegment C, MemorySegment ldc, MemorySegment D, MemorySegment ldd, MemorySegment E, MemorySegment lde, MemorySegment F, MemorySegment ldf, MemorySegment dif, MemorySegment scale, MemorySegment work, MemorySegment lwork, MemorySegment iwork, MemorySegment info, long x22) {
        var mh$ = ctgsyl_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ctgsyl_", trans, ijob, m, n, A, lda, B, ldb, C, ldc, D, ldd, E, lde, F, ldf, dif, scale, work, lwork, iwork, info, x22);
            }
            mh$.invokeExact(trans, ijob, m, n, A, lda, B, ldb, C, ldc, D, ldd, E, lde, F, ldf, dif, scale, work, lwork, iwork, info, x22);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dtgsyl_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("dtgsyl_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dtgsyl_(const char *trans, const int *ijob, const int *m, const int *n, const double *A, const int *lda, const double *B, const int *ldb, double *C, const int *ldc, const double *D, const int *ldd, const double *E, const int *lde, double *F, const int *ldf, double *dif, double *scale, double *work, const int *lwork, int *iwork, int *info, size_t)
     * }
     */
    public static FunctionDescriptor dtgsyl_$descriptor() {
        return dtgsyl_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dtgsyl_(const char *trans, const int *ijob, const int *m, const int *n, const double *A, const int *lda, const double *B, const int *ldb, double *C, const int *ldc, const double *D, const int *ldd, const double *E, const int *lde, double *F, const int *ldf, double *dif, double *scale, double *work, const int *lwork, int *iwork, int *info, size_t)
     * }
     */
    public static MethodHandle dtgsyl_$handle() {
        return dtgsyl_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dtgsyl_(const char *trans, const int *ijob, const int *m, const int *n, const double *A, const int *lda, const double *B, const int *ldb, double *C, const int *ldc, const double *D, const int *ldd, const double *E, const int *lde, double *F, const int *ldf, double *dif, double *scale, double *work, const int *lwork, int *iwork, int *info, size_t)
     * }
     */
    public static MemorySegment dtgsyl_$address() {
        return dtgsyl_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dtgsyl_(const char *trans, const int *ijob, const int *m, const int *n, const double *A, const int *lda, const double *B, const int *ldb, double *C, const int *ldc, const double *D, const int *ldd, const double *E, const int *lde, double *F, const int *ldf, double *dif, double *scale, double *work, const int *lwork, int *iwork, int *info, size_t)
     * }
     */
    public static void dtgsyl_(MemorySegment trans, MemorySegment ijob, MemorySegment m, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment B, MemorySegment ldb, MemorySegment C, MemorySegment ldc, MemorySegment D, MemorySegment ldd, MemorySegment E, MemorySegment lde, MemorySegment F, MemorySegment ldf, MemorySegment dif, MemorySegment scale, MemorySegment work, MemorySegment lwork, MemorySegment iwork, MemorySegment info, long x22) {
        var mh$ = dtgsyl_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dtgsyl_", trans, ijob, m, n, A, lda, B, ldb, C, ldc, D, ldd, E, lde, F, ldf, dif, scale, work, lwork, iwork, info, x22);
            }
            mh$.invokeExact(trans, ijob, m, n, A, lda, B, ldb, C, ldc, D, ldd, E, lde, F, ldf, dif, scale, work, lwork, iwork, info, x22);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class stgsyl_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("stgsyl_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void stgsyl_(const char *trans, const int *ijob, const int *m, const int *n, const float *A, const int *lda, const float *B, const int *ldb, float *C, const int *ldc, const float *D, const int *ldd, const float *E, const int *lde, float *F, const int *ldf, float *dif, float *scale, float *work, const int *lwork, int *iwork, int *info, size_t)
     * }
     */
    public static FunctionDescriptor stgsyl_$descriptor() {
        return stgsyl_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void stgsyl_(const char *trans, const int *ijob, const int *m, const int *n, const float *A, const int *lda, const float *B, const int *ldb, float *C, const int *ldc, const float *D, const int *ldd, const float *E, const int *lde, float *F, const int *ldf, float *dif, float *scale, float *work, const int *lwork, int *iwork, int *info, size_t)
     * }
     */
    public static MethodHandle stgsyl_$handle() {
        return stgsyl_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void stgsyl_(const char *trans, const int *ijob, const int *m, const int *n, const float *A, const int *lda, const float *B, const int *ldb, float *C, const int *ldc, const float *D, const int *ldd, const float *E, const int *lde, float *F, const int *ldf, float *dif, float *scale, float *work, const int *lwork, int *iwork, int *info, size_t)
     * }
     */
    public static MemorySegment stgsyl_$address() {
        return stgsyl_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void stgsyl_(const char *trans, const int *ijob, const int *m, const int *n, const float *A, const int *lda, const float *B, const int *ldb, float *C, const int *ldc, const float *D, const int *ldd, const float *E, const int *lde, float *F, const int *ldf, float *dif, float *scale, float *work, const int *lwork, int *iwork, int *info, size_t)
     * }
     */
    public static void stgsyl_(MemorySegment trans, MemorySegment ijob, MemorySegment m, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment B, MemorySegment ldb, MemorySegment C, MemorySegment ldc, MemorySegment D, MemorySegment ldd, MemorySegment E, MemorySegment lde, MemorySegment F, MemorySegment ldf, MemorySegment dif, MemorySegment scale, MemorySegment work, MemorySegment lwork, MemorySegment iwork, MemorySegment info, long x22) {
        var mh$ = stgsyl_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("stgsyl_", trans, ijob, m, n, A, lda, B, ldb, C, ldc, D, ldd, E, lde, F, ldf, dif, scale, work, lwork, iwork, info, x22);
            }
            mh$.invokeExact(trans, ijob, m, n, A, lda, B, ldb, C, ldc, D, ldd, E, lde, F, ldf, dif, scale, work, lwork, iwork, info, x22);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ztgsyl_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("ztgsyl_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ztgsyl_(const char *trans, const int *ijob, const int *m, const int *n, const _Complex double *A, const int *lda, const _Complex double *B, const int *ldb, _Complex double *C, const int *ldc, const _Complex double *D, const int *ldd, const _Complex double *E, const int *lde, _Complex double *F, const int *ldf, double *dif, double *scale, _Complex double *work, const int *lwork, int *iwork, int *info, size_t)
     * }
     */
    public static FunctionDescriptor ztgsyl_$descriptor() {
        return ztgsyl_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ztgsyl_(const char *trans, const int *ijob, const int *m, const int *n, const _Complex double *A, const int *lda, const _Complex double *B, const int *ldb, _Complex double *C, const int *ldc, const _Complex double *D, const int *ldd, const _Complex double *E, const int *lde, _Complex double *F, const int *ldf, double *dif, double *scale, _Complex double *work, const int *lwork, int *iwork, int *info, size_t)
     * }
     */
    public static MethodHandle ztgsyl_$handle() {
        return ztgsyl_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ztgsyl_(const char *trans, const int *ijob, const int *m, const int *n, const _Complex double *A, const int *lda, const _Complex double *B, const int *ldb, _Complex double *C, const int *ldc, const _Complex double *D, const int *ldd, const _Complex double *E, const int *lde, _Complex double *F, const int *ldf, double *dif, double *scale, _Complex double *work, const int *lwork, int *iwork, int *info, size_t)
     * }
     */
    public static MemorySegment ztgsyl_$address() {
        return ztgsyl_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ztgsyl_(const char *trans, const int *ijob, const int *m, const int *n, const _Complex double *A, const int *lda, const _Complex double *B, const int *ldb, _Complex double *C, const int *ldc, const _Complex double *D, const int *ldd, const _Complex double *E, const int *lde, _Complex double *F, const int *ldf, double *dif, double *scale, _Complex double *work, const int *lwork, int *iwork, int *info, size_t)
     * }
     */
    public static void ztgsyl_(MemorySegment trans, MemorySegment ijob, MemorySegment m, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment B, MemorySegment ldb, MemorySegment C, MemorySegment ldc, MemorySegment D, MemorySegment ldd, MemorySegment E, MemorySegment lde, MemorySegment F, MemorySegment ldf, MemorySegment dif, MemorySegment scale, MemorySegment work, MemorySegment lwork, MemorySegment iwork, MemorySegment info, long x22) {
        var mh$ = ztgsyl_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ztgsyl_", trans, ijob, m, n, A, lda, B, ldb, C, ldc, D, ldd, E, lde, F, ldf, dif, scale, work, lwork, iwork, info, x22);
            }
            mh$.invokeExact(trans, ijob, m, n, A, lda, B, ldb, C, ldc, D, ldd, E, lde, F, ldf, dif, scale, work, lwork, iwork, info, x22);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ctpcon_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("ctpcon_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ctpcon_(const char *norm, const char *uplo, const char *diag, const int *n, const _Complex float *AP, float *rcond, _Complex float *work, float *rwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor ctpcon_$descriptor() {
        return ctpcon_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ctpcon_(const char *norm, const char *uplo, const char *diag, const int *n, const _Complex float *AP, float *rcond, _Complex float *work, float *rwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle ctpcon_$handle() {
        return ctpcon_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ctpcon_(const char *norm, const char *uplo, const char *diag, const int *n, const _Complex float *AP, float *rcond, _Complex float *work, float *rwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment ctpcon_$address() {
        return ctpcon_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ctpcon_(const char *norm, const char *uplo, const char *diag, const int *n, const _Complex float *AP, float *rcond, _Complex float *work, float *rwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static void ctpcon_(MemorySegment norm, MemorySegment uplo, MemorySegment diag, MemorySegment n, MemorySegment AP, MemorySegment rcond, MemorySegment work, MemorySegment rwork, MemorySegment info, long x9, long x10, long x11) {
        var mh$ = ctpcon_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ctpcon_", norm, uplo, diag, n, AP, rcond, work, rwork, info, x9, x10, x11);
            }
            mh$.invokeExact(norm, uplo, diag, n, AP, rcond, work, rwork, info, x9, x10, x11);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dtpcon_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("dtpcon_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dtpcon_(const char *norm, const char *uplo, const char *diag, const int *n, const double *AP, double *rcond, double *work, int *iwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor dtpcon_$descriptor() {
        return dtpcon_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dtpcon_(const char *norm, const char *uplo, const char *diag, const int *n, const double *AP, double *rcond, double *work, int *iwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle dtpcon_$handle() {
        return dtpcon_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dtpcon_(const char *norm, const char *uplo, const char *diag, const int *n, const double *AP, double *rcond, double *work, int *iwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment dtpcon_$address() {
        return dtpcon_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dtpcon_(const char *norm, const char *uplo, const char *diag, const int *n, const double *AP, double *rcond, double *work, int *iwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static void dtpcon_(MemorySegment norm, MemorySegment uplo, MemorySegment diag, MemorySegment n, MemorySegment AP, MemorySegment rcond, MemorySegment work, MemorySegment iwork, MemorySegment info, long x9, long x10, long x11) {
        var mh$ = dtpcon_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dtpcon_", norm, uplo, diag, n, AP, rcond, work, iwork, info, x9, x10, x11);
            }
            mh$.invokeExact(norm, uplo, diag, n, AP, rcond, work, iwork, info, x9, x10, x11);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class stpcon_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("stpcon_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void stpcon_(const char *norm, const char *uplo, const char *diag, const int *n, const float *AP, float *rcond, float *work, int *iwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor stpcon_$descriptor() {
        return stpcon_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void stpcon_(const char *norm, const char *uplo, const char *diag, const int *n, const float *AP, float *rcond, float *work, int *iwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle stpcon_$handle() {
        return stpcon_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void stpcon_(const char *norm, const char *uplo, const char *diag, const int *n, const float *AP, float *rcond, float *work, int *iwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment stpcon_$address() {
        return stpcon_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void stpcon_(const char *norm, const char *uplo, const char *diag, const int *n, const float *AP, float *rcond, float *work, int *iwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static void stpcon_(MemorySegment norm, MemorySegment uplo, MemorySegment diag, MemorySegment n, MemorySegment AP, MemorySegment rcond, MemorySegment work, MemorySegment iwork, MemorySegment info, long x9, long x10, long x11) {
        var mh$ = stpcon_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("stpcon_", norm, uplo, diag, n, AP, rcond, work, iwork, info, x9, x10, x11);
            }
            mh$.invokeExact(norm, uplo, diag, n, AP, rcond, work, iwork, info, x9, x10, x11);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ztpcon_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("ztpcon_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ztpcon_(const char *norm, const char *uplo, const char *diag, const int *n, const _Complex double *AP, double *rcond, _Complex double *work, double *rwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor ztpcon_$descriptor() {
        return ztpcon_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ztpcon_(const char *norm, const char *uplo, const char *diag, const int *n, const _Complex double *AP, double *rcond, _Complex double *work, double *rwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle ztpcon_$handle() {
        return ztpcon_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ztpcon_(const char *norm, const char *uplo, const char *diag, const int *n, const _Complex double *AP, double *rcond, _Complex double *work, double *rwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment ztpcon_$address() {
        return ztpcon_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ztpcon_(const char *norm, const char *uplo, const char *diag, const int *n, const _Complex double *AP, double *rcond, _Complex double *work, double *rwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static void ztpcon_(MemorySegment norm, MemorySegment uplo, MemorySegment diag, MemorySegment n, MemorySegment AP, MemorySegment rcond, MemorySegment work, MemorySegment rwork, MemorySegment info, long x9, long x10, long x11) {
        var mh$ = ztpcon_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ztpcon_", norm, uplo, diag, n, AP, rcond, work, rwork, info, x9, x10, x11);
            }
            mh$.invokeExact(norm, uplo, diag, n, AP, rcond, work, rwork, info, x9, x10, x11);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ctplqt_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("ctplqt_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ctplqt_(const int *m, const int *n, const int *l, const int *mb, _Complex float *A, const int *lda, _Complex float *B, const int *ldb, _Complex float *T, const int *ldt, _Complex float *work, int *info)
     * }
     */
    public static FunctionDescriptor ctplqt_$descriptor() {
        return ctplqt_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ctplqt_(const int *m, const int *n, const int *l, const int *mb, _Complex float *A, const int *lda, _Complex float *B, const int *ldb, _Complex float *T, const int *ldt, _Complex float *work, int *info)
     * }
     */
    public static MethodHandle ctplqt_$handle() {
        return ctplqt_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ctplqt_(const int *m, const int *n, const int *l, const int *mb, _Complex float *A, const int *lda, _Complex float *B, const int *ldb, _Complex float *T, const int *ldt, _Complex float *work, int *info)
     * }
     */
    public static MemorySegment ctplqt_$address() {
        return ctplqt_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ctplqt_(const int *m, const int *n, const int *l, const int *mb, _Complex float *A, const int *lda, _Complex float *B, const int *ldb, _Complex float *T, const int *ldt, _Complex float *work, int *info)
     * }
     */
    public static void ctplqt_(MemorySegment m, MemorySegment n, MemorySegment l, MemorySegment mb, MemorySegment A, MemorySegment lda, MemorySegment B, MemorySegment ldb, MemorySegment T, MemorySegment ldt, MemorySegment work, MemorySegment info) {
        var mh$ = ctplqt_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ctplqt_", m, n, l, mb, A, lda, B, ldb, T, ldt, work, info);
            }
            mh$.invokeExact(m, n, l, mb, A, lda, B, ldb, T, ldt, work, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dtplqt_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("dtplqt_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dtplqt_(const int *m, const int *n, const int *l, const int *mb, double *A, const int *lda, double *B, const int *ldb, double *T, const int *ldt, double *work, int *info)
     * }
     */
    public static FunctionDescriptor dtplqt_$descriptor() {
        return dtplqt_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dtplqt_(const int *m, const int *n, const int *l, const int *mb, double *A, const int *lda, double *B, const int *ldb, double *T, const int *ldt, double *work, int *info)
     * }
     */
    public static MethodHandle dtplqt_$handle() {
        return dtplqt_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dtplqt_(const int *m, const int *n, const int *l, const int *mb, double *A, const int *lda, double *B, const int *ldb, double *T, const int *ldt, double *work, int *info)
     * }
     */
    public static MemorySegment dtplqt_$address() {
        return dtplqt_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dtplqt_(const int *m, const int *n, const int *l, const int *mb, double *A, const int *lda, double *B, const int *ldb, double *T, const int *ldt, double *work, int *info)
     * }
     */
    public static void dtplqt_(MemorySegment m, MemorySegment n, MemorySegment l, MemorySegment mb, MemorySegment A, MemorySegment lda, MemorySegment B, MemorySegment ldb, MemorySegment T, MemorySegment ldt, MemorySegment work, MemorySegment info) {
        var mh$ = dtplqt_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dtplqt_", m, n, l, mb, A, lda, B, ldb, T, ldt, work, info);
            }
            mh$.invokeExact(m, n, l, mb, A, lda, B, ldb, T, ldt, work, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class stplqt_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("stplqt_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void stplqt_(const int *m, const int *n, const int *l, const int *mb, float *A, const int *lda, float *B, const int *ldb, float *T, const int *ldt, float *work, int *info)
     * }
     */
    public static FunctionDescriptor stplqt_$descriptor() {
        return stplqt_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void stplqt_(const int *m, const int *n, const int *l, const int *mb, float *A, const int *lda, float *B, const int *ldb, float *T, const int *ldt, float *work, int *info)
     * }
     */
    public static MethodHandle stplqt_$handle() {
        return stplqt_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void stplqt_(const int *m, const int *n, const int *l, const int *mb, float *A, const int *lda, float *B, const int *ldb, float *T, const int *ldt, float *work, int *info)
     * }
     */
    public static MemorySegment stplqt_$address() {
        return stplqt_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void stplqt_(const int *m, const int *n, const int *l, const int *mb, float *A, const int *lda, float *B, const int *ldb, float *T, const int *ldt, float *work, int *info)
     * }
     */
    public static void stplqt_(MemorySegment m, MemorySegment n, MemorySegment l, MemorySegment mb, MemorySegment A, MemorySegment lda, MemorySegment B, MemorySegment ldb, MemorySegment T, MemorySegment ldt, MemorySegment work, MemorySegment info) {
        var mh$ = stplqt_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("stplqt_", m, n, l, mb, A, lda, B, ldb, T, ldt, work, info);
            }
            mh$.invokeExact(m, n, l, mb, A, lda, B, ldb, T, ldt, work, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ztplqt_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("ztplqt_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ztplqt_(const int *m, const int *n, const int *l, const int *mb, _Complex double *A, const int *lda, _Complex double *B, const int *ldb, _Complex double *T, const int *ldt, _Complex double *work, int *info)
     * }
     */
    public static FunctionDescriptor ztplqt_$descriptor() {
        return ztplqt_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ztplqt_(const int *m, const int *n, const int *l, const int *mb, _Complex double *A, const int *lda, _Complex double *B, const int *ldb, _Complex double *T, const int *ldt, _Complex double *work, int *info)
     * }
     */
    public static MethodHandle ztplqt_$handle() {
        return ztplqt_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ztplqt_(const int *m, const int *n, const int *l, const int *mb, _Complex double *A, const int *lda, _Complex double *B, const int *ldb, _Complex double *T, const int *ldt, _Complex double *work, int *info)
     * }
     */
    public static MemorySegment ztplqt_$address() {
        return ztplqt_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ztplqt_(const int *m, const int *n, const int *l, const int *mb, _Complex double *A, const int *lda, _Complex double *B, const int *ldb, _Complex double *T, const int *ldt, _Complex double *work, int *info)
     * }
     */
    public static void ztplqt_(MemorySegment m, MemorySegment n, MemorySegment l, MemorySegment mb, MemorySegment A, MemorySegment lda, MemorySegment B, MemorySegment ldb, MemorySegment T, MemorySegment ldt, MemorySegment work, MemorySegment info) {
        var mh$ = ztplqt_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ztplqt_", m, n, l, mb, A, lda, B, ldb, T, ldt, work, info);
            }
            mh$.invokeExact(m, n, l, mb, A, lda, B, ldb, T, ldt, work, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ctplqt2_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("ctplqt2_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ctplqt2_(const int *m, const int *n, const int *l, _Complex float *A, const int *lda, _Complex float *B, const int *ldb, _Complex float *T, const int *ldt, int *info)
     * }
     */
    public static FunctionDescriptor ctplqt2_$descriptor() {
        return ctplqt2_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ctplqt2_(const int *m, const int *n, const int *l, _Complex float *A, const int *lda, _Complex float *B, const int *ldb, _Complex float *T, const int *ldt, int *info)
     * }
     */
    public static MethodHandle ctplqt2_$handle() {
        return ctplqt2_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ctplqt2_(const int *m, const int *n, const int *l, _Complex float *A, const int *lda, _Complex float *B, const int *ldb, _Complex float *T, const int *ldt, int *info)
     * }
     */
    public static MemorySegment ctplqt2_$address() {
        return ctplqt2_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ctplqt2_(const int *m, const int *n, const int *l, _Complex float *A, const int *lda, _Complex float *B, const int *ldb, _Complex float *T, const int *ldt, int *info)
     * }
     */
    public static void ctplqt2_(MemorySegment m, MemorySegment n, MemorySegment l, MemorySegment A, MemorySegment lda, MemorySegment B, MemorySegment ldb, MemorySegment T, MemorySegment ldt, MemorySegment info) {
        var mh$ = ctplqt2_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ctplqt2_", m, n, l, A, lda, B, ldb, T, ldt, info);
            }
            mh$.invokeExact(m, n, l, A, lda, B, ldb, T, ldt, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dtplqt2_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("dtplqt2_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dtplqt2_(const int *m, const int *n, const int *l, double *A, const int *lda, double *B, const int *ldb, double *T, const int *ldt, int *info)
     * }
     */
    public static FunctionDescriptor dtplqt2_$descriptor() {
        return dtplqt2_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dtplqt2_(const int *m, const int *n, const int *l, double *A, const int *lda, double *B, const int *ldb, double *T, const int *ldt, int *info)
     * }
     */
    public static MethodHandle dtplqt2_$handle() {
        return dtplqt2_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dtplqt2_(const int *m, const int *n, const int *l, double *A, const int *lda, double *B, const int *ldb, double *T, const int *ldt, int *info)
     * }
     */
    public static MemorySegment dtplqt2_$address() {
        return dtplqt2_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dtplqt2_(const int *m, const int *n, const int *l, double *A, const int *lda, double *B, const int *ldb, double *T, const int *ldt, int *info)
     * }
     */
    public static void dtplqt2_(MemorySegment m, MemorySegment n, MemorySegment l, MemorySegment A, MemorySegment lda, MemorySegment B, MemorySegment ldb, MemorySegment T, MemorySegment ldt, MemorySegment info) {
        var mh$ = dtplqt2_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dtplqt2_", m, n, l, A, lda, B, ldb, T, ldt, info);
            }
            mh$.invokeExact(m, n, l, A, lda, B, ldb, T, ldt, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class stplqt2_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("stplqt2_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void stplqt2_(const int *m, const int *n, const int *l, float *A, const int *lda, float *B, const int *ldb, float *T, const int *ldt, int *info)
     * }
     */
    public static FunctionDescriptor stplqt2_$descriptor() {
        return stplqt2_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void stplqt2_(const int *m, const int *n, const int *l, float *A, const int *lda, float *B, const int *ldb, float *T, const int *ldt, int *info)
     * }
     */
    public static MethodHandle stplqt2_$handle() {
        return stplqt2_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void stplqt2_(const int *m, const int *n, const int *l, float *A, const int *lda, float *B, const int *ldb, float *T, const int *ldt, int *info)
     * }
     */
    public static MemorySegment stplqt2_$address() {
        return stplqt2_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void stplqt2_(const int *m, const int *n, const int *l, float *A, const int *lda, float *B, const int *ldb, float *T, const int *ldt, int *info)
     * }
     */
    public static void stplqt2_(MemorySegment m, MemorySegment n, MemorySegment l, MemorySegment A, MemorySegment lda, MemorySegment B, MemorySegment ldb, MemorySegment T, MemorySegment ldt, MemorySegment info) {
        var mh$ = stplqt2_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("stplqt2_", m, n, l, A, lda, B, ldb, T, ldt, info);
            }
            mh$.invokeExact(m, n, l, A, lda, B, ldb, T, ldt, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ztplqt2_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("ztplqt2_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ztplqt2_(const int *m, const int *n, const int *l, _Complex double *A, const int *lda, _Complex double *B, const int *ldb, _Complex double *T, const int *ldt, int *info)
     * }
     */
    public static FunctionDescriptor ztplqt2_$descriptor() {
        return ztplqt2_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ztplqt2_(const int *m, const int *n, const int *l, _Complex double *A, const int *lda, _Complex double *B, const int *ldb, _Complex double *T, const int *ldt, int *info)
     * }
     */
    public static MethodHandle ztplqt2_$handle() {
        return ztplqt2_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ztplqt2_(const int *m, const int *n, const int *l, _Complex double *A, const int *lda, _Complex double *B, const int *ldb, _Complex double *T, const int *ldt, int *info)
     * }
     */
    public static MemorySegment ztplqt2_$address() {
        return ztplqt2_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ztplqt2_(const int *m, const int *n, const int *l, _Complex double *A, const int *lda, _Complex double *B, const int *ldb, _Complex double *T, const int *ldt, int *info)
     * }
     */
    public static void ztplqt2_(MemorySegment m, MemorySegment n, MemorySegment l, MemorySegment A, MemorySegment lda, MemorySegment B, MemorySegment ldb, MemorySegment T, MemorySegment ldt, MemorySegment info) {
        var mh$ = ztplqt2_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ztplqt2_", m, n, l, A, lda, B, ldb, T, ldt, info);
            }
            mh$.invokeExact(m, n, l, A, lda, B, ldb, T, ldt, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ctpmlqt_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("ctpmlqt_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ctpmlqt_(const char *side, const char *trans, const int *m, const int *n, const int *k, const int *l, const int *mb, const _Complex float *V, const int *ldv, const _Complex float *T, const int *ldt, _Complex float *A, const int *lda, _Complex float *B, const int *ldb, _Complex float *work, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor ctpmlqt_$descriptor() {
        return ctpmlqt_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ctpmlqt_(const char *side, const char *trans, const int *m, const int *n, const int *k, const int *l, const int *mb, const _Complex float *V, const int *ldv, const _Complex float *T, const int *ldt, _Complex float *A, const int *lda, _Complex float *B, const int *ldb, _Complex float *work, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle ctpmlqt_$handle() {
        return ctpmlqt_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ctpmlqt_(const char *side, const char *trans, const int *m, const int *n, const int *k, const int *l, const int *mb, const _Complex float *V, const int *ldv, const _Complex float *T, const int *ldt, _Complex float *A, const int *lda, _Complex float *B, const int *ldb, _Complex float *work, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment ctpmlqt_$address() {
        return ctpmlqt_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ctpmlqt_(const char *side, const char *trans, const int *m, const int *n, const int *k, const int *l, const int *mb, const _Complex float *V, const int *ldv, const _Complex float *T, const int *ldt, _Complex float *A, const int *lda, _Complex float *B, const int *ldb, _Complex float *work, int *info, size_t, size_t)
     * }
     */
    public static void ctpmlqt_(MemorySegment side, MemorySegment trans, MemorySegment m, MemorySegment n, MemorySegment k, MemorySegment l, MemorySegment mb, MemorySegment V, MemorySegment ldv, MemorySegment T, MemorySegment ldt, MemorySegment A, MemorySegment lda, MemorySegment B, MemorySegment ldb, MemorySegment work, MemorySegment info, long x17, long x18) {
        var mh$ = ctpmlqt_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ctpmlqt_", side, trans, m, n, k, l, mb, V, ldv, T, ldt, A, lda, B, ldb, work, info, x17, x18);
            }
            mh$.invokeExact(side, trans, m, n, k, l, mb, V, ldv, T, ldt, A, lda, B, ldb, work, info, x17, x18);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dtpmlqt_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("dtpmlqt_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dtpmlqt_(const char *side, const char *trans, const int *m, const int *n, const int *k, const int *l, const int *mb, const double *V, const int *ldv, const double *T, const int *ldt, double *A, const int *lda, double *B, const int *ldb, double *work, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor dtpmlqt_$descriptor() {
        return dtpmlqt_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dtpmlqt_(const char *side, const char *trans, const int *m, const int *n, const int *k, const int *l, const int *mb, const double *V, const int *ldv, const double *T, const int *ldt, double *A, const int *lda, double *B, const int *ldb, double *work, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle dtpmlqt_$handle() {
        return dtpmlqt_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dtpmlqt_(const char *side, const char *trans, const int *m, const int *n, const int *k, const int *l, const int *mb, const double *V, const int *ldv, const double *T, const int *ldt, double *A, const int *lda, double *B, const int *ldb, double *work, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment dtpmlqt_$address() {
        return dtpmlqt_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dtpmlqt_(const char *side, const char *trans, const int *m, const int *n, const int *k, const int *l, const int *mb, const double *V, const int *ldv, const double *T, const int *ldt, double *A, const int *lda, double *B, const int *ldb, double *work, int *info, size_t, size_t)
     * }
     */
    public static void dtpmlqt_(MemorySegment side, MemorySegment trans, MemorySegment m, MemorySegment n, MemorySegment k, MemorySegment l, MemorySegment mb, MemorySegment V, MemorySegment ldv, MemorySegment T, MemorySegment ldt, MemorySegment A, MemorySegment lda, MemorySegment B, MemorySegment ldb, MemorySegment work, MemorySegment info, long x17, long x18) {
        var mh$ = dtpmlqt_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dtpmlqt_", side, trans, m, n, k, l, mb, V, ldv, T, ldt, A, lda, B, ldb, work, info, x17, x18);
            }
            mh$.invokeExact(side, trans, m, n, k, l, mb, V, ldv, T, ldt, A, lda, B, ldb, work, info, x17, x18);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class stpmlqt_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("stpmlqt_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void stpmlqt_(const char *side, const char *trans, const int *m, const int *n, const int *k, const int *l, const int *mb, const float *V, const int *ldv, const float *T, const int *ldt, float *A, const int *lda, float *B, const int *ldb, float *work, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor stpmlqt_$descriptor() {
        return stpmlqt_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void stpmlqt_(const char *side, const char *trans, const int *m, const int *n, const int *k, const int *l, const int *mb, const float *V, const int *ldv, const float *T, const int *ldt, float *A, const int *lda, float *B, const int *ldb, float *work, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle stpmlqt_$handle() {
        return stpmlqt_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void stpmlqt_(const char *side, const char *trans, const int *m, const int *n, const int *k, const int *l, const int *mb, const float *V, const int *ldv, const float *T, const int *ldt, float *A, const int *lda, float *B, const int *ldb, float *work, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment stpmlqt_$address() {
        return stpmlqt_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void stpmlqt_(const char *side, const char *trans, const int *m, const int *n, const int *k, const int *l, const int *mb, const float *V, const int *ldv, const float *T, const int *ldt, float *A, const int *lda, float *B, const int *ldb, float *work, int *info, size_t, size_t)
     * }
     */
    public static void stpmlqt_(MemorySegment side, MemorySegment trans, MemorySegment m, MemorySegment n, MemorySegment k, MemorySegment l, MemorySegment mb, MemorySegment V, MemorySegment ldv, MemorySegment T, MemorySegment ldt, MemorySegment A, MemorySegment lda, MemorySegment B, MemorySegment ldb, MemorySegment work, MemorySegment info, long x17, long x18) {
        var mh$ = stpmlqt_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("stpmlqt_", side, trans, m, n, k, l, mb, V, ldv, T, ldt, A, lda, B, ldb, work, info, x17, x18);
            }
            mh$.invokeExact(side, trans, m, n, k, l, mb, V, ldv, T, ldt, A, lda, B, ldb, work, info, x17, x18);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ztpmlqt_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("ztpmlqt_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ztpmlqt_(const char *side, const char *trans, const int *m, const int *n, const int *k, const int *l, const int *mb, const _Complex double *V, const int *ldv, const _Complex double *T, const int *ldt, _Complex double *A, const int *lda, _Complex double *B, const int *ldb, _Complex double *work, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor ztpmlqt_$descriptor() {
        return ztpmlqt_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ztpmlqt_(const char *side, const char *trans, const int *m, const int *n, const int *k, const int *l, const int *mb, const _Complex double *V, const int *ldv, const _Complex double *T, const int *ldt, _Complex double *A, const int *lda, _Complex double *B, const int *ldb, _Complex double *work, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle ztpmlqt_$handle() {
        return ztpmlqt_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ztpmlqt_(const char *side, const char *trans, const int *m, const int *n, const int *k, const int *l, const int *mb, const _Complex double *V, const int *ldv, const _Complex double *T, const int *ldt, _Complex double *A, const int *lda, _Complex double *B, const int *ldb, _Complex double *work, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment ztpmlqt_$address() {
        return ztpmlqt_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ztpmlqt_(const char *side, const char *trans, const int *m, const int *n, const int *k, const int *l, const int *mb, const _Complex double *V, const int *ldv, const _Complex double *T, const int *ldt, _Complex double *A, const int *lda, _Complex double *B, const int *ldb, _Complex double *work, int *info, size_t, size_t)
     * }
     */
    public static void ztpmlqt_(MemorySegment side, MemorySegment trans, MemorySegment m, MemorySegment n, MemorySegment k, MemorySegment l, MemorySegment mb, MemorySegment V, MemorySegment ldv, MemorySegment T, MemorySegment ldt, MemorySegment A, MemorySegment lda, MemorySegment B, MemorySegment ldb, MemorySegment work, MemorySegment info, long x17, long x18) {
        var mh$ = ztpmlqt_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ztpmlqt_", side, trans, m, n, k, l, mb, V, ldv, T, ldt, A, lda, B, ldb, work, info, x17, x18);
            }
            mh$.invokeExact(side, trans, m, n, k, l, mb, V, ldv, T, ldt, A, lda, B, ldb, work, info, x17, x18);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ctpmqrt_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("ctpmqrt_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ctpmqrt_(const char *side, const char *trans, const int *m, const int *n, const int *k, const int *l, const int *nb, const _Complex float *V, const int *ldv, const _Complex float *T, const int *ldt, _Complex float *A, const int *lda, _Complex float *B, const int *ldb, _Complex float *work, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor ctpmqrt_$descriptor() {
        return ctpmqrt_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ctpmqrt_(const char *side, const char *trans, const int *m, const int *n, const int *k, const int *l, const int *nb, const _Complex float *V, const int *ldv, const _Complex float *T, const int *ldt, _Complex float *A, const int *lda, _Complex float *B, const int *ldb, _Complex float *work, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle ctpmqrt_$handle() {
        return ctpmqrt_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ctpmqrt_(const char *side, const char *trans, const int *m, const int *n, const int *k, const int *l, const int *nb, const _Complex float *V, const int *ldv, const _Complex float *T, const int *ldt, _Complex float *A, const int *lda, _Complex float *B, const int *ldb, _Complex float *work, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment ctpmqrt_$address() {
        return ctpmqrt_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ctpmqrt_(const char *side, const char *trans, const int *m, const int *n, const int *k, const int *l, const int *nb, const _Complex float *V, const int *ldv, const _Complex float *T, const int *ldt, _Complex float *A, const int *lda, _Complex float *B, const int *ldb, _Complex float *work, int *info, size_t, size_t)
     * }
     */
    public static void ctpmqrt_(MemorySegment side, MemorySegment trans, MemorySegment m, MemorySegment n, MemorySegment k, MemorySegment l, MemorySegment nb, MemorySegment V, MemorySegment ldv, MemorySegment T, MemorySegment ldt, MemorySegment A, MemorySegment lda, MemorySegment B, MemorySegment ldb, MemorySegment work, MemorySegment info, long x17, long x18) {
        var mh$ = ctpmqrt_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ctpmqrt_", side, trans, m, n, k, l, nb, V, ldv, T, ldt, A, lda, B, ldb, work, info, x17, x18);
            }
            mh$.invokeExact(side, trans, m, n, k, l, nb, V, ldv, T, ldt, A, lda, B, ldb, work, info, x17, x18);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dtpmqrt_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_LONG,
            cblas_openblas_h.C_LONG
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("dtpmqrt_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dtpmqrt_(const char *side, const char *trans, const int *m, const int *n, const int *k, const int *l, const int *nb, const double *V, const int *ldv, const double *T, const int *ldt, double *A, const int *lda, double *B, const int *ldb, double *work, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor dtpmqrt_$descriptor() {
        return dtpmqrt_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dtpmqrt_(const char *side, const char *trans, const int *m, const int *n, const int *k, const int *l, const int *nb, const double *V, const int *ldv, const double *T, const int *ldt, double *A, const int *lda, double *B, const int *ldb, double *work, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle dtpmqrt_$handle() {
        return dtpmqrt_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dtpmqrt_(const char *side, const char *trans, const int *m, const int *n, const int *k, const int *l, const int *nb, const double *V, const int *ldv, const double *T, const int *ldt, double *A, const int *lda, double *B, const int *ldb, double *work, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment dtpmqrt_$address() {
        return dtpmqrt_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dtpmqrt_(const char *side, const char *trans, const int *m, const int *n, const int *k, const int *l, const int *nb, const double *V, const int *ldv, const double *T, const int *ldt, double *A, const int *lda, double *B, const int *ldb, double *work, int *info, size_t, size_t)
     * }
     */
    public static void dtpmqrt_(MemorySegment side, MemorySegment trans, MemorySegment m, MemorySegment n, MemorySegment k, MemorySegment l, MemorySegment nb, MemorySegment V, MemorySegment ldv, MemorySegment T, MemorySegment ldt, MemorySegment A, MemorySegment lda, MemorySegment B, MemorySegment ldb, MemorySegment work, MemorySegment info, long x17, long x18) {
        var mh$ = dtpmqrt_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dtpmqrt_", side, trans, m, n, k, l, nb, V, ldv, T, ldt, A, lda, B, ldb, work, info, x17, x18);
            }
            mh$.invokeExact(side, trans, m, n, k, l, nb, V, ldv, T, ldt, A, lda, B, ldb, work, info, x17, x18);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
}

