// Generated by jextract

package smile.math.blas.openblas;

import java.lang.invoke.*;
import java.lang.foreign.*;
import java.nio.ByteOrder;
import java.util.*;
import java.util.function.*;
import java.util.stream.*;

import static java.lang.foreign.ValueLayout.*;
import static java.lang.foreign.MemoryLayout.PathElement.*;

public class cblas_openblas_h extends cblas_openblas_h_1 {

    cblas_openblas_h() {
        // Should not be called directly
    }

    private static class cpotf2_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cpotf2_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int cpotf2_(char *, blasint *, float *, blasint *, blasint *)
     * }
     */
    public static FunctionDescriptor cpotf2_$descriptor() {
        return cpotf2_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int cpotf2_(char *, blasint *, float *, blasint *, blasint *)
     * }
     */
    public static MethodHandle cpotf2_$handle() {
        return cpotf2_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int cpotf2_(char *, blasint *, float *, blasint *, blasint *)
     * }
     */
    public static MemorySegment cpotf2_$address() {
        return cpotf2_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int cpotf2_(char *, blasint *, float *, blasint *, blasint *)
     * }
     */
    public static int cpotf2_(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = cpotf2_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cpotf2_", x0, x1, x2, x3, x4);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zpotf2_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("zpotf2_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int zpotf2_(char *, blasint *, double *, blasint *, blasint *)
     * }
     */
    public static FunctionDescriptor zpotf2_$descriptor() {
        return zpotf2_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int zpotf2_(char *, blasint *, double *, blasint *, blasint *)
     * }
     */
    public static MethodHandle zpotf2_$handle() {
        return zpotf2_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int zpotf2_(char *, blasint *, double *, blasint *, blasint *)
     * }
     */
    public static MemorySegment zpotf2_$address() {
        return zpotf2_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int zpotf2_(char *, blasint *, double *, blasint *, blasint *)
     * }
     */
    public static int zpotf2_(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = zpotf2_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zpotf2_", x0, x1, x2, x3, x4);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class xpotf2_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("xpotf2_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int xpotf2_(char *, blasint *, double *, blasint *, blasint *)
     * }
     */
    public static FunctionDescriptor xpotf2_$descriptor() {
        return xpotf2_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int xpotf2_(char *, blasint *, double *, blasint *, blasint *)
     * }
     */
    public static MethodHandle xpotf2_$handle() {
        return xpotf2_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int xpotf2_(char *, blasint *, double *, blasint *, blasint *)
     * }
     */
    public static MemorySegment xpotf2_$address() {
        return xpotf2_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int xpotf2_(char *, blasint *, double *, blasint *, blasint *)
     * }
     */
    public static int xpotf2_(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = xpotf2_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("xpotf2_", x0, x1, x2, x3, x4);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class spotrf_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("spotrf_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int spotrf_(char *, blasint *, float *, blasint *, blasint *)
     * }
     */
    public static FunctionDescriptor spotrf_$descriptor() {
        return spotrf_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int spotrf_(char *, blasint *, float *, blasint *, blasint *)
     * }
     */
    public static MethodHandle spotrf_$handle() {
        return spotrf_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int spotrf_(char *, blasint *, float *, blasint *, blasint *)
     * }
     */
    public static MemorySegment spotrf_$address() {
        return spotrf_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int spotrf_(char *, blasint *, float *, blasint *, blasint *)
     * }
     */
    public static int spotrf_(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = spotrf_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("spotrf_", x0, x1, x2, x3, x4);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dpotrf_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("dpotrf_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int dpotrf_(char *, blasint *, double *, blasint *, blasint *)
     * }
     */
    public static FunctionDescriptor dpotrf_$descriptor() {
        return dpotrf_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int dpotrf_(char *, blasint *, double *, blasint *, blasint *)
     * }
     */
    public static MethodHandle dpotrf_$handle() {
        return dpotrf_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int dpotrf_(char *, blasint *, double *, blasint *, blasint *)
     * }
     */
    public static MemorySegment dpotrf_$address() {
        return dpotrf_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int dpotrf_(char *, blasint *, double *, blasint *, blasint *)
     * }
     */
    public static int dpotrf_(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = dpotrf_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dpotrf_", x0, x1, x2, x3, x4);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class qpotrf_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("qpotrf_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int qpotrf_(char *, blasint *, double *, blasint *, blasint *)
     * }
     */
    public static FunctionDescriptor qpotrf_$descriptor() {
        return qpotrf_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int qpotrf_(char *, blasint *, double *, blasint *, blasint *)
     * }
     */
    public static MethodHandle qpotrf_$handle() {
        return qpotrf_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int qpotrf_(char *, blasint *, double *, blasint *, blasint *)
     * }
     */
    public static MemorySegment qpotrf_$address() {
        return qpotrf_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int qpotrf_(char *, blasint *, double *, blasint *, blasint *)
     * }
     */
    public static int qpotrf_(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = qpotrf_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("qpotrf_", x0, x1, x2, x3, x4);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cpotrf_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cpotrf_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int cpotrf_(char *, blasint *, float *, blasint *, blasint *)
     * }
     */
    public static FunctionDescriptor cpotrf_$descriptor() {
        return cpotrf_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int cpotrf_(char *, blasint *, float *, blasint *, blasint *)
     * }
     */
    public static MethodHandle cpotrf_$handle() {
        return cpotrf_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int cpotrf_(char *, blasint *, float *, blasint *, blasint *)
     * }
     */
    public static MemorySegment cpotrf_$address() {
        return cpotrf_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int cpotrf_(char *, blasint *, float *, blasint *, blasint *)
     * }
     */
    public static int cpotrf_(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = cpotrf_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cpotrf_", x0, x1, x2, x3, x4);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zpotrf_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("zpotrf_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int zpotrf_(char *, blasint *, double *, blasint *, blasint *)
     * }
     */
    public static FunctionDescriptor zpotrf_$descriptor() {
        return zpotrf_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int zpotrf_(char *, blasint *, double *, blasint *, blasint *)
     * }
     */
    public static MethodHandle zpotrf_$handle() {
        return zpotrf_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int zpotrf_(char *, blasint *, double *, blasint *, blasint *)
     * }
     */
    public static MemorySegment zpotrf_$address() {
        return zpotrf_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int zpotrf_(char *, blasint *, double *, blasint *, blasint *)
     * }
     */
    public static int zpotrf_(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = zpotrf_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zpotrf_", x0, x1, x2, x3, x4);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class xpotrf_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("xpotrf_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int xpotrf_(char *, blasint *, double *, blasint *, blasint *)
     * }
     */
    public static FunctionDescriptor xpotrf_$descriptor() {
        return xpotrf_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int xpotrf_(char *, blasint *, double *, blasint *, blasint *)
     * }
     */
    public static MethodHandle xpotrf_$handle() {
        return xpotrf_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int xpotrf_(char *, blasint *, double *, blasint *, blasint *)
     * }
     */
    public static MemorySegment xpotrf_$address() {
        return xpotrf_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int xpotrf_(char *, blasint *, double *, blasint *, blasint *)
     * }
     */
    public static int xpotrf_(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = xpotrf_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("xpotrf_", x0, x1, x2, x3, x4);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class spotri_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("spotri_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int spotri_(char *, blasint *, float *, blasint *, blasint *)
     * }
     */
    public static FunctionDescriptor spotri_$descriptor() {
        return spotri_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int spotri_(char *, blasint *, float *, blasint *, blasint *)
     * }
     */
    public static MethodHandle spotri_$handle() {
        return spotri_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int spotri_(char *, blasint *, float *, blasint *, blasint *)
     * }
     */
    public static MemorySegment spotri_$address() {
        return spotri_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int spotri_(char *, blasint *, float *, blasint *, blasint *)
     * }
     */
    public static int spotri_(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = spotri_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("spotri_", x0, x1, x2, x3, x4);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dpotri_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("dpotri_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int dpotri_(char *, blasint *, double *, blasint *, blasint *)
     * }
     */
    public static FunctionDescriptor dpotri_$descriptor() {
        return dpotri_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int dpotri_(char *, blasint *, double *, blasint *, blasint *)
     * }
     */
    public static MethodHandle dpotri_$handle() {
        return dpotri_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int dpotri_(char *, blasint *, double *, blasint *, blasint *)
     * }
     */
    public static MemorySegment dpotri_$address() {
        return dpotri_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int dpotri_(char *, blasint *, double *, blasint *, blasint *)
     * }
     */
    public static int dpotri_(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = dpotri_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dpotri_", x0, x1, x2, x3, x4);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class qpotri_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("qpotri_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int qpotri_(char *, blasint *, double *, blasint *, blasint *)
     * }
     */
    public static FunctionDescriptor qpotri_$descriptor() {
        return qpotri_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int qpotri_(char *, blasint *, double *, blasint *, blasint *)
     * }
     */
    public static MethodHandle qpotri_$handle() {
        return qpotri_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int qpotri_(char *, blasint *, double *, blasint *, blasint *)
     * }
     */
    public static MemorySegment qpotri_$address() {
        return qpotri_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int qpotri_(char *, blasint *, double *, blasint *, blasint *)
     * }
     */
    public static int qpotri_(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = qpotri_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("qpotri_", x0, x1, x2, x3, x4);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cpotri_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cpotri_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int cpotri_(char *, blasint *, float *, blasint *, blasint *)
     * }
     */
    public static FunctionDescriptor cpotri_$descriptor() {
        return cpotri_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int cpotri_(char *, blasint *, float *, blasint *, blasint *)
     * }
     */
    public static MethodHandle cpotri_$handle() {
        return cpotri_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int cpotri_(char *, blasint *, float *, blasint *, blasint *)
     * }
     */
    public static MemorySegment cpotri_$address() {
        return cpotri_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int cpotri_(char *, blasint *, float *, blasint *, blasint *)
     * }
     */
    public static int cpotri_(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = cpotri_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cpotri_", x0, x1, x2, x3, x4);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zpotri_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("zpotri_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int zpotri_(char *, blasint *, double *, blasint *, blasint *)
     * }
     */
    public static FunctionDescriptor zpotri_$descriptor() {
        return zpotri_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int zpotri_(char *, blasint *, double *, blasint *, blasint *)
     * }
     */
    public static MethodHandle zpotri_$handle() {
        return zpotri_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int zpotri_(char *, blasint *, double *, blasint *, blasint *)
     * }
     */
    public static MemorySegment zpotri_$address() {
        return zpotri_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int zpotri_(char *, blasint *, double *, blasint *, blasint *)
     * }
     */
    public static int zpotri_(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = zpotri_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zpotri_", x0, x1, x2, x3, x4);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class xpotri_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("xpotri_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int xpotri_(char *, blasint *, double *, blasint *, blasint *)
     * }
     */
    public static FunctionDescriptor xpotri_$descriptor() {
        return xpotri_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int xpotri_(char *, blasint *, double *, blasint *, blasint *)
     * }
     */
    public static MethodHandle xpotri_$handle() {
        return xpotri_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int xpotri_(char *, blasint *, double *, blasint *, blasint *)
     * }
     */
    public static MemorySegment xpotri_$address() {
        return xpotri_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int xpotri_(char *, blasint *, double *, blasint *, blasint *)
     * }
     */
    public static int xpotri_(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = xpotri_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("xpotri_", x0, x1, x2, x3, x4);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class spotrs_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("spotrs_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int spotrs_(char *, blasint *, blasint *, float *, blasint *, float *, blasint *, blasint *)
     * }
     */
    public static FunctionDescriptor spotrs_$descriptor() {
        return spotrs_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int spotrs_(char *, blasint *, blasint *, float *, blasint *, float *, blasint *, blasint *)
     * }
     */
    public static MethodHandle spotrs_$handle() {
        return spotrs_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int spotrs_(char *, blasint *, blasint *, float *, blasint *, float *, blasint *, blasint *)
     * }
     */
    public static MemorySegment spotrs_$address() {
        return spotrs_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int spotrs_(char *, blasint *, blasint *, float *, blasint *, float *, blasint *, blasint *)
     * }
     */
    public static int spotrs_(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, MemorySegment x5, MemorySegment x6, MemorySegment x7) {
        var mh$ = spotrs_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("spotrs_", x0, x1, x2, x3, x4, x5, x6, x7);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4, x5, x6, x7);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dpotrs_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("dpotrs_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int dpotrs_(char *, blasint *, blasint *, double *, blasint *, double *, blasint *, blasint *)
     * }
     */
    public static FunctionDescriptor dpotrs_$descriptor() {
        return dpotrs_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int dpotrs_(char *, blasint *, blasint *, double *, blasint *, double *, blasint *, blasint *)
     * }
     */
    public static MethodHandle dpotrs_$handle() {
        return dpotrs_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int dpotrs_(char *, blasint *, blasint *, double *, blasint *, double *, blasint *, blasint *)
     * }
     */
    public static MemorySegment dpotrs_$address() {
        return dpotrs_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int dpotrs_(char *, blasint *, blasint *, double *, blasint *, double *, blasint *, blasint *)
     * }
     */
    public static int dpotrs_(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, MemorySegment x5, MemorySegment x6, MemorySegment x7) {
        var mh$ = dpotrs_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dpotrs_", x0, x1, x2, x3, x4, x5, x6, x7);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4, x5, x6, x7);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class qpotrs_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("qpotrs_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int qpotrs_(char *, blasint *, blasint *, double *, blasint *, double *, blasint *, blasint *)
     * }
     */
    public static FunctionDescriptor qpotrs_$descriptor() {
        return qpotrs_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int qpotrs_(char *, blasint *, blasint *, double *, blasint *, double *, blasint *, blasint *)
     * }
     */
    public static MethodHandle qpotrs_$handle() {
        return qpotrs_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int qpotrs_(char *, blasint *, blasint *, double *, blasint *, double *, blasint *, blasint *)
     * }
     */
    public static MemorySegment qpotrs_$address() {
        return qpotrs_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int qpotrs_(char *, blasint *, blasint *, double *, blasint *, double *, blasint *, blasint *)
     * }
     */
    public static int qpotrs_(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, MemorySegment x5, MemorySegment x6, MemorySegment x7) {
        var mh$ = qpotrs_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("qpotrs_", x0, x1, x2, x3, x4, x5, x6, x7);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4, x5, x6, x7);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cpotrs_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cpotrs_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int cpotrs_(char *, blasint *, blasint *, float *, blasint *, float *, blasint *, blasint *)
     * }
     */
    public static FunctionDescriptor cpotrs_$descriptor() {
        return cpotrs_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int cpotrs_(char *, blasint *, blasint *, float *, blasint *, float *, blasint *, blasint *)
     * }
     */
    public static MethodHandle cpotrs_$handle() {
        return cpotrs_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int cpotrs_(char *, blasint *, blasint *, float *, blasint *, float *, blasint *, blasint *)
     * }
     */
    public static MemorySegment cpotrs_$address() {
        return cpotrs_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int cpotrs_(char *, blasint *, blasint *, float *, blasint *, float *, blasint *, blasint *)
     * }
     */
    public static int cpotrs_(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, MemorySegment x5, MemorySegment x6, MemorySegment x7) {
        var mh$ = cpotrs_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cpotrs_", x0, x1, x2, x3, x4, x5, x6, x7);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4, x5, x6, x7);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zpotrs_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("zpotrs_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int zpotrs_(char *, blasint *, blasint *, double *, blasint *, double *, blasint *, blasint *)
     * }
     */
    public static FunctionDescriptor zpotrs_$descriptor() {
        return zpotrs_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int zpotrs_(char *, blasint *, blasint *, double *, blasint *, double *, blasint *, blasint *)
     * }
     */
    public static MethodHandle zpotrs_$handle() {
        return zpotrs_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int zpotrs_(char *, blasint *, blasint *, double *, blasint *, double *, blasint *, blasint *)
     * }
     */
    public static MemorySegment zpotrs_$address() {
        return zpotrs_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int zpotrs_(char *, blasint *, blasint *, double *, blasint *, double *, blasint *, blasint *)
     * }
     */
    public static int zpotrs_(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, MemorySegment x5, MemorySegment x6, MemorySegment x7) {
        var mh$ = zpotrs_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zpotrs_", x0, x1, x2, x3, x4, x5, x6, x7);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4, x5, x6, x7);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class xpotrs_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("xpotrs_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int xpotrs_(char *, blasint *, blasint *, double *, blasint *, double *, blasint *, blasint *)
     * }
     */
    public static FunctionDescriptor xpotrs_$descriptor() {
        return xpotrs_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int xpotrs_(char *, blasint *, blasint *, double *, blasint *, double *, blasint *, blasint *)
     * }
     */
    public static MethodHandle xpotrs_$handle() {
        return xpotrs_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int xpotrs_(char *, blasint *, blasint *, double *, blasint *, double *, blasint *, blasint *)
     * }
     */
    public static MemorySegment xpotrs_$address() {
        return xpotrs_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int xpotrs_(char *, blasint *, blasint *, double *, blasint *, double *, blasint *, blasint *)
     * }
     */
    public static int xpotrs_(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, MemorySegment x5, MemorySegment x6, MemorySegment x7) {
        var mh$ = xpotrs_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("xpotrs_", x0, x1, x2, x3, x4, x5, x6, x7);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4, x5, x6, x7);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class slauu2_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("slauu2_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int slauu2_(char *, blasint *, float *, blasint *, blasint *)
     * }
     */
    public static FunctionDescriptor slauu2_$descriptor() {
        return slauu2_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int slauu2_(char *, blasint *, float *, blasint *, blasint *)
     * }
     */
    public static MethodHandle slauu2_$handle() {
        return slauu2_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int slauu2_(char *, blasint *, float *, blasint *, blasint *)
     * }
     */
    public static MemorySegment slauu2_$address() {
        return slauu2_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int slauu2_(char *, blasint *, float *, blasint *, blasint *)
     * }
     */
    public static int slauu2_(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = slauu2_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("slauu2_", x0, x1, x2, x3, x4);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dlauu2_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("dlauu2_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int dlauu2_(char *, blasint *, double *, blasint *, blasint *)
     * }
     */
    public static FunctionDescriptor dlauu2_$descriptor() {
        return dlauu2_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int dlauu2_(char *, blasint *, double *, blasint *, blasint *)
     * }
     */
    public static MethodHandle dlauu2_$handle() {
        return dlauu2_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int dlauu2_(char *, blasint *, double *, blasint *, blasint *)
     * }
     */
    public static MemorySegment dlauu2_$address() {
        return dlauu2_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int dlauu2_(char *, blasint *, double *, blasint *, blasint *)
     * }
     */
    public static int dlauu2_(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = dlauu2_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dlauu2_", x0, x1, x2, x3, x4);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class qlauu2_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("qlauu2_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int qlauu2_(char *, blasint *, double *, blasint *, blasint *)
     * }
     */
    public static FunctionDescriptor qlauu2_$descriptor() {
        return qlauu2_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int qlauu2_(char *, blasint *, double *, blasint *, blasint *)
     * }
     */
    public static MethodHandle qlauu2_$handle() {
        return qlauu2_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int qlauu2_(char *, blasint *, double *, blasint *, blasint *)
     * }
     */
    public static MemorySegment qlauu2_$address() {
        return qlauu2_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int qlauu2_(char *, blasint *, double *, blasint *, blasint *)
     * }
     */
    public static int qlauu2_(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = qlauu2_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("qlauu2_", x0, x1, x2, x3, x4);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clauu2_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("clauu2_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int clauu2_(char *, blasint *, float *, blasint *, blasint *)
     * }
     */
    public static FunctionDescriptor clauu2_$descriptor() {
        return clauu2_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int clauu2_(char *, blasint *, float *, blasint *, blasint *)
     * }
     */
    public static MethodHandle clauu2_$handle() {
        return clauu2_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int clauu2_(char *, blasint *, float *, blasint *, blasint *)
     * }
     */
    public static MemorySegment clauu2_$address() {
        return clauu2_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int clauu2_(char *, blasint *, float *, blasint *, blasint *)
     * }
     */
    public static int clauu2_(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = clauu2_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clauu2_", x0, x1, x2, x3, x4);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zlauu2_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("zlauu2_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int zlauu2_(char *, blasint *, double *, blasint *, blasint *)
     * }
     */
    public static FunctionDescriptor zlauu2_$descriptor() {
        return zlauu2_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int zlauu2_(char *, blasint *, double *, blasint *, blasint *)
     * }
     */
    public static MethodHandle zlauu2_$handle() {
        return zlauu2_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int zlauu2_(char *, blasint *, double *, blasint *, blasint *)
     * }
     */
    public static MemorySegment zlauu2_$address() {
        return zlauu2_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int zlauu2_(char *, blasint *, double *, blasint *, blasint *)
     * }
     */
    public static int zlauu2_(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = zlauu2_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zlauu2_", x0, x1, x2, x3, x4);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class xlauu2_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("xlauu2_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int xlauu2_(char *, blasint *, double *, blasint *, blasint *)
     * }
     */
    public static FunctionDescriptor xlauu2_$descriptor() {
        return xlauu2_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int xlauu2_(char *, blasint *, double *, blasint *, blasint *)
     * }
     */
    public static MethodHandle xlauu2_$handle() {
        return xlauu2_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int xlauu2_(char *, blasint *, double *, blasint *, blasint *)
     * }
     */
    public static MemorySegment xlauu2_$address() {
        return xlauu2_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int xlauu2_(char *, blasint *, double *, blasint *, blasint *)
     * }
     */
    public static int xlauu2_(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = xlauu2_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("xlauu2_", x0, x1, x2, x3, x4);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class slauum_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("slauum_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int slauum_(char *, blasint *, float *, blasint *, blasint *)
     * }
     */
    public static FunctionDescriptor slauum_$descriptor() {
        return slauum_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int slauum_(char *, blasint *, float *, blasint *, blasint *)
     * }
     */
    public static MethodHandle slauum_$handle() {
        return slauum_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int slauum_(char *, blasint *, float *, blasint *, blasint *)
     * }
     */
    public static MemorySegment slauum_$address() {
        return slauum_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int slauum_(char *, blasint *, float *, blasint *, blasint *)
     * }
     */
    public static int slauum_(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = slauum_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("slauum_", x0, x1, x2, x3, x4);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dlauum_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("dlauum_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int dlauum_(char *, blasint *, double *, blasint *, blasint *)
     * }
     */
    public static FunctionDescriptor dlauum_$descriptor() {
        return dlauum_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int dlauum_(char *, blasint *, double *, blasint *, blasint *)
     * }
     */
    public static MethodHandle dlauum_$handle() {
        return dlauum_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int dlauum_(char *, blasint *, double *, blasint *, blasint *)
     * }
     */
    public static MemorySegment dlauum_$address() {
        return dlauum_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int dlauum_(char *, blasint *, double *, blasint *, blasint *)
     * }
     */
    public static int dlauum_(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = dlauum_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dlauum_", x0, x1, x2, x3, x4);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class qlauum_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("qlauum_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int qlauum_(char *, blasint *, double *, blasint *, blasint *)
     * }
     */
    public static FunctionDescriptor qlauum_$descriptor() {
        return qlauum_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int qlauum_(char *, blasint *, double *, blasint *, blasint *)
     * }
     */
    public static MethodHandle qlauum_$handle() {
        return qlauum_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int qlauum_(char *, blasint *, double *, blasint *, blasint *)
     * }
     */
    public static MemorySegment qlauum_$address() {
        return qlauum_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int qlauum_(char *, blasint *, double *, blasint *, blasint *)
     * }
     */
    public static int qlauum_(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = qlauum_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("qlauum_", x0, x1, x2, x3, x4);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clauum_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("clauum_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int clauum_(char *, blasint *, float *, blasint *, blasint *)
     * }
     */
    public static FunctionDescriptor clauum_$descriptor() {
        return clauum_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int clauum_(char *, blasint *, float *, blasint *, blasint *)
     * }
     */
    public static MethodHandle clauum_$handle() {
        return clauum_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int clauum_(char *, blasint *, float *, blasint *, blasint *)
     * }
     */
    public static MemorySegment clauum_$address() {
        return clauum_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int clauum_(char *, blasint *, float *, blasint *, blasint *)
     * }
     */
    public static int clauum_(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = clauum_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clauum_", x0, x1, x2, x3, x4);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zlauum_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("zlauum_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int zlauum_(char *, blasint *, double *, blasint *, blasint *)
     * }
     */
    public static FunctionDescriptor zlauum_$descriptor() {
        return zlauum_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int zlauum_(char *, blasint *, double *, blasint *, blasint *)
     * }
     */
    public static MethodHandle zlauum_$handle() {
        return zlauum_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int zlauum_(char *, blasint *, double *, blasint *, blasint *)
     * }
     */
    public static MemorySegment zlauum_$address() {
        return zlauum_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int zlauum_(char *, blasint *, double *, blasint *, blasint *)
     * }
     */
    public static int zlauum_(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = zlauum_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zlauum_", x0, x1, x2, x3, x4);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class xlauum_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("xlauum_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int xlauum_(char *, blasint *, double *, blasint *, blasint *)
     * }
     */
    public static FunctionDescriptor xlauum_$descriptor() {
        return xlauum_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int xlauum_(char *, blasint *, double *, blasint *, blasint *)
     * }
     */
    public static MethodHandle xlauum_$handle() {
        return xlauum_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int xlauum_(char *, blasint *, double *, blasint *, blasint *)
     * }
     */
    public static MemorySegment xlauum_$address() {
        return xlauum_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int xlauum_(char *, blasint *, double *, blasint *, blasint *)
     * }
     */
    public static int xlauum_(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = xlauum_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("xlauum_", x0, x1, x2, x3, x4);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strti2_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("strti2_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int strti2_(char *, char *, blasint *, float *, blasint *, blasint *)
     * }
     */
    public static FunctionDescriptor strti2_$descriptor() {
        return strti2_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int strti2_(char *, char *, blasint *, float *, blasint *, blasint *)
     * }
     */
    public static MethodHandle strti2_$handle() {
        return strti2_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int strti2_(char *, char *, blasint *, float *, blasint *, blasint *)
     * }
     */
    public static MemorySegment strti2_$address() {
        return strti2_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int strti2_(char *, char *, blasint *, float *, blasint *, blasint *)
     * }
     */
    public static int strti2_(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, MemorySegment x5) {
        var mh$ = strti2_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strti2_", x0, x1, x2, x3, x4, x5);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dtrti2_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("dtrti2_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int dtrti2_(char *, char *, blasint *, double *, blasint *, blasint *)
     * }
     */
    public static FunctionDescriptor dtrti2_$descriptor() {
        return dtrti2_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int dtrti2_(char *, char *, blasint *, double *, blasint *, blasint *)
     * }
     */
    public static MethodHandle dtrti2_$handle() {
        return dtrti2_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int dtrti2_(char *, char *, blasint *, double *, blasint *, blasint *)
     * }
     */
    public static MemorySegment dtrti2_$address() {
        return dtrti2_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int dtrti2_(char *, char *, blasint *, double *, blasint *, blasint *)
     * }
     */
    public static int dtrti2_(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, MemorySegment x5) {
        var mh$ = dtrti2_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dtrti2_", x0, x1, x2, x3, x4, x5);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class qtrti2_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("qtrti2_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int qtrti2_(char *, char *, blasint *, double *, blasint *, blasint *)
     * }
     */
    public static FunctionDescriptor qtrti2_$descriptor() {
        return qtrti2_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int qtrti2_(char *, char *, blasint *, double *, blasint *, blasint *)
     * }
     */
    public static MethodHandle qtrti2_$handle() {
        return qtrti2_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int qtrti2_(char *, char *, blasint *, double *, blasint *, blasint *)
     * }
     */
    public static MemorySegment qtrti2_$address() {
        return qtrti2_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int qtrti2_(char *, char *, blasint *, double *, blasint *, blasint *)
     * }
     */
    public static int qtrti2_(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, MemorySegment x5) {
        var mh$ = qtrti2_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("qtrti2_", x0, x1, x2, x3, x4, x5);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ctrti2_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("ctrti2_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int ctrti2_(char *, char *, blasint *, float *, blasint *, blasint *)
     * }
     */
    public static FunctionDescriptor ctrti2_$descriptor() {
        return ctrti2_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int ctrti2_(char *, char *, blasint *, float *, blasint *, blasint *)
     * }
     */
    public static MethodHandle ctrti2_$handle() {
        return ctrti2_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int ctrti2_(char *, char *, blasint *, float *, blasint *, blasint *)
     * }
     */
    public static MemorySegment ctrti2_$address() {
        return ctrti2_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int ctrti2_(char *, char *, blasint *, float *, blasint *, blasint *)
     * }
     */
    public static int ctrti2_(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, MemorySegment x5) {
        var mh$ = ctrti2_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ctrti2_", x0, x1, x2, x3, x4, x5);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ztrti2_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("ztrti2_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int ztrti2_(char *, char *, blasint *, double *, blasint *, blasint *)
     * }
     */
    public static FunctionDescriptor ztrti2_$descriptor() {
        return ztrti2_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int ztrti2_(char *, char *, blasint *, double *, blasint *, blasint *)
     * }
     */
    public static MethodHandle ztrti2_$handle() {
        return ztrti2_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int ztrti2_(char *, char *, blasint *, double *, blasint *, blasint *)
     * }
     */
    public static MemorySegment ztrti2_$address() {
        return ztrti2_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int ztrti2_(char *, char *, blasint *, double *, blasint *, blasint *)
     * }
     */
    public static int ztrti2_(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, MemorySegment x5) {
        var mh$ = ztrti2_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ztrti2_", x0, x1, x2, x3, x4, x5);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class xtrti2_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("xtrti2_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int xtrti2_(char *, char *, blasint *, double *, blasint *, blasint *)
     * }
     */
    public static FunctionDescriptor xtrti2_$descriptor() {
        return xtrti2_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int xtrti2_(char *, char *, blasint *, double *, blasint *, blasint *)
     * }
     */
    public static MethodHandle xtrti2_$handle() {
        return xtrti2_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int xtrti2_(char *, char *, blasint *, double *, blasint *, blasint *)
     * }
     */
    public static MemorySegment xtrti2_$address() {
        return xtrti2_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int xtrti2_(char *, char *, blasint *, double *, blasint *, blasint *)
     * }
     */
    public static int xtrti2_(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, MemorySegment x5) {
        var mh$ = xtrti2_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("xtrti2_", x0, x1, x2, x3, x4, x5);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strtri_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("strtri_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int strtri_(char *, char *, blasint *, float *, blasint *, blasint *)
     * }
     */
    public static FunctionDescriptor strtri_$descriptor() {
        return strtri_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int strtri_(char *, char *, blasint *, float *, blasint *, blasint *)
     * }
     */
    public static MethodHandle strtri_$handle() {
        return strtri_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int strtri_(char *, char *, blasint *, float *, blasint *, blasint *)
     * }
     */
    public static MemorySegment strtri_$address() {
        return strtri_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int strtri_(char *, char *, blasint *, float *, blasint *, blasint *)
     * }
     */
    public static int strtri_(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, MemorySegment x5) {
        var mh$ = strtri_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strtri_", x0, x1, x2, x3, x4, x5);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dtrtri_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("dtrtri_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int dtrtri_(char *, char *, blasint *, double *, blasint *, blasint *)
     * }
     */
    public static FunctionDescriptor dtrtri_$descriptor() {
        return dtrtri_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int dtrtri_(char *, char *, blasint *, double *, blasint *, blasint *)
     * }
     */
    public static MethodHandle dtrtri_$handle() {
        return dtrtri_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int dtrtri_(char *, char *, blasint *, double *, blasint *, blasint *)
     * }
     */
    public static MemorySegment dtrtri_$address() {
        return dtrtri_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int dtrtri_(char *, char *, blasint *, double *, blasint *, blasint *)
     * }
     */
    public static int dtrtri_(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, MemorySegment x5) {
        var mh$ = dtrtri_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dtrtri_", x0, x1, x2, x3, x4, x5);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class qtrtri_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("qtrtri_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int qtrtri_(char *, char *, blasint *, double *, blasint *, blasint *)
     * }
     */
    public static FunctionDescriptor qtrtri_$descriptor() {
        return qtrtri_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int qtrtri_(char *, char *, blasint *, double *, blasint *, blasint *)
     * }
     */
    public static MethodHandle qtrtri_$handle() {
        return qtrtri_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int qtrtri_(char *, char *, blasint *, double *, blasint *, blasint *)
     * }
     */
    public static MemorySegment qtrtri_$address() {
        return qtrtri_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int qtrtri_(char *, char *, blasint *, double *, blasint *, blasint *)
     * }
     */
    public static int qtrtri_(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, MemorySegment x5) {
        var mh$ = qtrtri_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("qtrtri_", x0, x1, x2, x3, x4, x5);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ctrtri_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("ctrtri_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int ctrtri_(char *, char *, blasint *, float *, blasint *, blasint *)
     * }
     */
    public static FunctionDescriptor ctrtri_$descriptor() {
        return ctrtri_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int ctrtri_(char *, char *, blasint *, float *, blasint *, blasint *)
     * }
     */
    public static MethodHandle ctrtri_$handle() {
        return ctrtri_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int ctrtri_(char *, char *, blasint *, float *, blasint *, blasint *)
     * }
     */
    public static MemorySegment ctrtri_$address() {
        return ctrtri_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int ctrtri_(char *, char *, blasint *, float *, blasint *, blasint *)
     * }
     */
    public static int ctrtri_(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, MemorySegment x5) {
        var mh$ = ctrtri_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ctrtri_", x0, x1, x2, x3, x4, x5);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ztrtri_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("ztrtri_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int ztrtri_(char *, char *, blasint *, double *, blasint *, blasint *)
     * }
     */
    public static FunctionDescriptor ztrtri_$descriptor() {
        return ztrtri_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int ztrtri_(char *, char *, blasint *, double *, blasint *, blasint *)
     * }
     */
    public static MethodHandle ztrtri_$handle() {
        return ztrtri_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int ztrtri_(char *, char *, blasint *, double *, blasint *, blasint *)
     * }
     */
    public static MemorySegment ztrtri_$address() {
        return ztrtri_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int ztrtri_(char *, char *, blasint *, double *, blasint *, blasint *)
     * }
     */
    public static int ztrtri_(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, MemorySegment x5) {
        var mh$ = ztrtri_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ztrtri_", x0, x1, x2, x3, x4, x5);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class xtrtri_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("xtrtri_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int xtrtri_(char *, char *, blasint *, double *, blasint *, blasint *)
     * }
     */
    public static FunctionDescriptor xtrtri_$descriptor() {
        return xtrtri_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int xtrtri_(char *, char *, blasint *, double *, blasint *, blasint *)
     * }
     */
    public static MethodHandle xtrtri_$handle() {
        return xtrtri_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int xtrtri_(char *, char *, blasint *, double *, blasint *, blasint *)
     * }
     */
    public static MemorySegment xtrtri_$address() {
        return xtrtri_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int xtrtri_(char *, char *, blasint *, double *, blasint *, blasint *)
     * }
     */
    public static int xtrtri_(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, MemorySegment x5) {
        var mh$ = xtrtri_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("xtrtri_", x0, x1, x2, x3, x4, x5);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class slamch_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("slamch_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float slamch_(char *)
     * }
     */
    public static FunctionDescriptor slamch_$descriptor() {
        return slamch_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float slamch_(char *)
     * }
     */
    public static MethodHandle slamch_$handle() {
        return slamch_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float slamch_(char *)
     * }
     */
    public static MemorySegment slamch_$address() {
        return slamch_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float slamch_(char *)
     * }
     */
    public static float slamch_(MemorySegment x0) {
        var mh$ = slamch_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("slamch_", x0);
            }
            return (float)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dlamch_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("dlamch_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double dlamch_(char *)
     * }
     */
    public static FunctionDescriptor dlamch_$descriptor() {
        return dlamch_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double dlamch_(char *)
     * }
     */
    public static MethodHandle dlamch_$handle() {
        return dlamch_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double dlamch_(char *)
     * }
     */
    public static MemorySegment dlamch_$address() {
        return dlamch_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double dlamch_(char *)
     * }
     */
    public static double dlamch_(MemorySegment x0) {
        var mh$ = dlamch_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dlamch_", x0);
            }
            return (double)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class qlamch_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("qlamch_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double qlamch_(char *)
     * }
     */
    public static FunctionDescriptor qlamch_$descriptor() {
        return qlamch_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double qlamch_(char *)
     * }
     */
    public static MethodHandle qlamch_$handle() {
        return qlamch_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double qlamch_(char *)
     * }
     */
    public static MemorySegment qlamch_$address() {
        return qlamch_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double qlamch_(char *)
     * }
     */
    public static double qlamch_(MemorySegment x0) {
        var mh$ = qlamch_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("qlamch_", x0);
            }
            return (double)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class slamc3_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("slamc3_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float slamc3_(float *, float *)
     * }
     */
    public static FunctionDescriptor slamc3_$descriptor() {
        return slamc3_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float slamc3_(float *, float *)
     * }
     */
    public static MethodHandle slamc3_$handle() {
        return slamc3_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float slamc3_(float *, float *)
     * }
     */
    public static MemorySegment slamc3_$address() {
        return slamc3_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float slamc3_(float *, float *)
     * }
     */
    public static float slamc3_(MemorySegment x0, MemorySegment x1) {
        var mh$ = slamc3_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("slamc3_", x0, x1);
            }
            return (float)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dlamc3_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("dlamc3_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double dlamc3_(double *, double *)
     * }
     */
    public static FunctionDescriptor dlamc3_$descriptor() {
        return dlamc3_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double dlamc3_(double *, double *)
     * }
     */
    public static MethodHandle dlamc3_$handle() {
        return dlamc3_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double dlamc3_(double *, double *)
     * }
     */
    public static MemorySegment dlamc3_$address() {
        return dlamc3_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double dlamc3_(double *, double *)
     * }
     */
    public static double dlamc3_(MemorySegment x0, MemorySegment x1) {
        var mh$ = dlamc3_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dlamc3_", x0, x1);
            }
            return (double)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class qlamc3_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("qlamc3_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double qlamc3_(double *, double *)
     * }
     */
    public static FunctionDescriptor qlamc3_$descriptor() {
        return qlamc3_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double qlamc3_(double *, double *)
     * }
     */
    public static MethodHandle qlamc3_$handle() {
        return qlamc3_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double qlamc3_(double *, double *)
     * }
     */
    public static MemorySegment qlamc3_$address() {
        return qlamc3_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double qlamc3_(double *, double *)
     * }
     */
    public static double qlamc3_(MemorySegment x0, MemorySegment x1) {
        var mh$ = qlamc3_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("qlamc3_", x0, x1);
            }
            return (double)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class saxpby_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("saxpby_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void saxpby_(blasint *, float *, float *, blasint *, float *, float *, blasint *)
     * }
     */
    public static FunctionDescriptor saxpby_$descriptor() {
        return saxpby_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void saxpby_(blasint *, float *, float *, blasint *, float *, float *, blasint *)
     * }
     */
    public static MethodHandle saxpby_$handle() {
        return saxpby_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void saxpby_(blasint *, float *, float *, blasint *, float *, float *, blasint *)
     * }
     */
    public static MemorySegment saxpby_$address() {
        return saxpby_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void saxpby_(blasint *, float *, float *, blasint *, float *, float *, blasint *)
     * }
     */
    public static void saxpby_(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, MemorySegment x5, MemorySegment x6) {
        var mh$ = saxpby_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("saxpby_", x0, x1, x2, x3, x4, x5, x6);
            }
            mh$.invokeExact(x0, x1, x2, x3, x4, x5, x6);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class daxpby_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("daxpby_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void daxpby_(blasint *, double *, double *, blasint *, double *, double *, blasint *)
     * }
     */
    public static FunctionDescriptor daxpby_$descriptor() {
        return daxpby_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void daxpby_(blasint *, double *, double *, blasint *, double *, double *, blasint *)
     * }
     */
    public static MethodHandle daxpby_$handle() {
        return daxpby_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void daxpby_(blasint *, double *, double *, blasint *, double *, double *, blasint *)
     * }
     */
    public static MemorySegment daxpby_$address() {
        return daxpby_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void daxpby_(blasint *, double *, double *, blasint *, double *, double *, blasint *)
     * }
     */
    public static void daxpby_(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, MemorySegment x5, MemorySegment x6) {
        var mh$ = daxpby_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("daxpby_", x0, x1, x2, x3, x4, x5, x6);
            }
            mh$.invokeExact(x0, x1, x2, x3, x4, x5, x6);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class caxpby_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("caxpby_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void caxpby_(blasint *, float *, float *, blasint *, float *, float *, blasint *)
     * }
     */
    public static FunctionDescriptor caxpby_$descriptor() {
        return caxpby_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void caxpby_(blasint *, float *, float *, blasint *, float *, float *, blasint *)
     * }
     */
    public static MethodHandle caxpby_$handle() {
        return caxpby_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void caxpby_(blasint *, float *, float *, blasint *, float *, float *, blasint *)
     * }
     */
    public static MemorySegment caxpby_$address() {
        return caxpby_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void caxpby_(blasint *, float *, float *, blasint *, float *, float *, blasint *)
     * }
     */
    public static void caxpby_(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, MemorySegment x5, MemorySegment x6) {
        var mh$ = caxpby_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("caxpby_", x0, x1, x2, x3, x4, x5, x6);
            }
            mh$.invokeExact(x0, x1, x2, x3, x4, x5, x6);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zaxpby_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("zaxpby_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zaxpby_(blasint *, double *, double *, blasint *, double *, double *, blasint *)
     * }
     */
    public static FunctionDescriptor zaxpby_$descriptor() {
        return zaxpby_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zaxpby_(blasint *, double *, double *, blasint *, double *, double *, blasint *)
     * }
     */
    public static MethodHandle zaxpby_$handle() {
        return zaxpby_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zaxpby_(blasint *, double *, double *, blasint *, double *, double *, blasint *)
     * }
     */
    public static MemorySegment zaxpby_$address() {
        return zaxpby_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zaxpby_(blasint *, double *, double *, blasint *, double *, double *, blasint *)
     * }
     */
    public static void zaxpby_(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, MemorySegment x5, MemorySegment x6) {
        var mh$ = zaxpby_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zaxpby_", x0, x1, x2, x3, x4, x5, x6);
            }
            mh$.invokeExact(x0, x1, x2, x3, x4, x5, x6);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class somatcopy_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("somatcopy_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void somatcopy_(char *, char *, blasint *, blasint *, float *, float *, blasint *, float *, blasint *)
     * }
     */
    public static FunctionDescriptor somatcopy_$descriptor() {
        return somatcopy_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void somatcopy_(char *, char *, blasint *, blasint *, float *, float *, blasint *, float *, blasint *)
     * }
     */
    public static MethodHandle somatcopy_$handle() {
        return somatcopy_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void somatcopy_(char *, char *, blasint *, blasint *, float *, float *, blasint *, float *, blasint *)
     * }
     */
    public static MemorySegment somatcopy_$address() {
        return somatcopy_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void somatcopy_(char *, char *, blasint *, blasint *, float *, float *, blasint *, float *, blasint *)
     * }
     */
    public static void somatcopy_(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, MemorySegment x5, MemorySegment x6, MemorySegment x7, MemorySegment x8) {
        var mh$ = somatcopy_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("somatcopy_", x0, x1, x2, x3, x4, x5, x6, x7, x8);
            }
            mh$.invokeExact(x0, x1, x2, x3, x4, x5, x6, x7, x8);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class domatcopy_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("domatcopy_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void domatcopy_(char *, char *, blasint *, blasint *, double *, double *, blasint *, double *, blasint *)
     * }
     */
    public static FunctionDescriptor domatcopy_$descriptor() {
        return domatcopy_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void domatcopy_(char *, char *, blasint *, blasint *, double *, double *, blasint *, double *, blasint *)
     * }
     */
    public static MethodHandle domatcopy_$handle() {
        return domatcopy_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void domatcopy_(char *, char *, blasint *, blasint *, double *, double *, blasint *, double *, blasint *)
     * }
     */
    public static MemorySegment domatcopy_$address() {
        return domatcopy_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void domatcopy_(char *, char *, blasint *, blasint *, double *, double *, blasint *, double *, blasint *)
     * }
     */
    public static void domatcopy_(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, MemorySegment x5, MemorySegment x6, MemorySegment x7, MemorySegment x8) {
        var mh$ = domatcopy_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("domatcopy_", x0, x1, x2, x3, x4, x5, x6, x7, x8);
            }
            mh$.invokeExact(x0, x1, x2, x3, x4, x5, x6, x7, x8);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class comatcopy_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("comatcopy_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void comatcopy_(char *, char *, blasint *, blasint *, float *, float *, blasint *, float *, blasint *)
     * }
     */
    public static FunctionDescriptor comatcopy_$descriptor() {
        return comatcopy_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void comatcopy_(char *, char *, blasint *, blasint *, float *, float *, blasint *, float *, blasint *)
     * }
     */
    public static MethodHandle comatcopy_$handle() {
        return comatcopy_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void comatcopy_(char *, char *, blasint *, blasint *, float *, float *, blasint *, float *, blasint *)
     * }
     */
    public static MemorySegment comatcopy_$address() {
        return comatcopy_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void comatcopy_(char *, char *, blasint *, blasint *, float *, float *, blasint *, float *, blasint *)
     * }
     */
    public static void comatcopy_(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, MemorySegment x5, MemorySegment x6, MemorySegment x7, MemorySegment x8) {
        var mh$ = comatcopy_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("comatcopy_", x0, x1, x2, x3, x4, x5, x6, x7, x8);
            }
            mh$.invokeExact(x0, x1, x2, x3, x4, x5, x6, x7, x8);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zomatcopy_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("zomatcopy_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zomatcopy_(char *, char *, blasint *, blasint *, double *, double *, blasint *, double *, blasint *)
     * }
     */
    public static FunctionDescriptor zomatcopy_$descriptor() {
        return zomatcopy_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zomatcopy_(char *, char *, blasint *, blasint *, double *, double *, blasint *, double *, blasint *)
     * }
     */
    public static MethodHandle zomatcopy_$handle() {
        return zomatcopy_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zomatcopy_(char *, char *, blasint *, blasint *, double *, double *, blasint *, double *, blasint *)
     * }
     */
    public static MemorySegment zomatcopy_$address() {
        return zomatcopy_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zomatcopy_(char *, char *, blasint *, blasint *, double *, double *, blasint *, double *, blasint *)
     * }
     */
    public static void zomatcopy_(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, MemorySegment x5, MemorySegment x6, MemorySegment x7, MemorySegment x8) {
        var mh$ = zomatcopy_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zomatcopy_", x0, x1, x2, x3, x4, x5, x6, x7, x8);
            }
            mh$.invokeExact(x0, x1, x2, x3, x4, x5, x6, x7, x8);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class simatcopy_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("simatcopy_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void simatcopy_(char *, char *, blasint *, blasint *, float *, float *, blasint *, blasint *)
     * }
     */
    public static FunctionDescriptor simatcopy_$descriptor() {
        return simatcopy_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void simatcopy_(char *, char *, blasint *, blasint *, float *, float *, blasint *, blasint *)
     * }
     */
    public static MethodHandle simatcopy_$handle() {
        return simatcopy_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void simatcopy_(char *, char *, blasint *, blasint *, float *, float *, blasint *, blasint *)
     * }
     */
    public static MemorySegment simatcopy_$address() {
        return simatcopy_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void simatcopy_(char *, char *, blasint *, blasint *, float *, float *, blasint *, blasint *)
     * }
     */
    public static void simatcopy_(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, MemorySegment x5, MemorySegment x6, MemorySegment x7) {
        var mh$ = simatcopy_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("simatcopy_", x0, x1, x2, x3, x4, x5, x6, x7);
            }
            mh$.invokeExact(x0, x1, x2, x3, x4, x5, x6, x7);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dimatcopy_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("dimatcopy_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dimatcopy_(char *, char *, blasint *, blasint *, double *, double *, blasint *, blasint *)
     * }
     */
    public static FunctionDescriptor dimatcopy_$descriptor() {
        return dimatcopy_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dimatcopy_(char *, char *, blasint *, blasint *, double *, double *, blasint *, blasint *)
     * }
     */
    public static MethodHandle dimatcopy_$handle() {
        return dimatcopy_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dimatcopy_(char *, char *, blasint *, blasint *, double *, double *, blasint *, blasint *)
     * }
     */
    public static MemorySegment dimatcopy_$address() {
        return dimatcopy_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dimatcopy_(char *, char *, blasint *, blasint *, double *, double *, blasint *, blasint *)
     * }
     */
    public static void dimatcopy_(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, MemorySegment x5, MemorySegment x6, MemorySegment x7) {
        var mh$ = dimatcopy_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dimatcopy_", x0, x1, x2, x3, x4, x5, x6, x7);
            }
            mh$.invokeExact(x0, x1, x2, x3, x4, x5, x6, x7);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cimatcopy_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cimatcopy_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cimatcopy_(char *, char *, blasint *, blasint *, float *, float *, blasint *, blasint *)
     * }
     */
    public static FunctionDescriptor cimatcopy_$descriptor() {
        return cimatcopy_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cimatcopy_(char *, char *, blasint *, blasint *, float *, float *, blasint *, blasint *)
     * }
     */
    public static MethodHandle cimatcopy_$handle() {
        return cimatcopy_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cimatcopy_(char *, char *, blasint *, blasint *, float *, float *, blasint *, blasint *)
     * }
     */
    public static MemorySegment cimatcopy_$address() {
        return cimatcopy_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cimatcopy_(char *, char *, blasint *, blasint *, float *, float *, blasint *, blasint *)
     * }
     */
    public static void cimatcopy_(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, MemorySegment x5, MemorySegment x6, MemorySegment x7) {
        var mh$ = cimatcopy_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cimatcopy_", x0, x1, x2, x3, x4, x5, x6, x7);
            }
            mh$.invokeExact(x0, x1, x2, x3, x4, x5, x6, x7);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zimatcopy_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("zimatcopy_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zimatcopy_(char *, char *, blasint *, blasint *, double *, double *, blasint *, blasint *)
     * }
     */
    public static FunctionDescriptor zimatcopy_$descriptor() {
        return zimatcopy_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zimatcopy_(char *, char *, blasint *, blasint *, double *, double *, blasint *, blasint *)
     * }
     */
    public static MethodHandle zimatcopy_$handle() {
        return zimatcopy_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zimatcopy_(char *, char *, blasint *, blasint *, double *, double *, blasint *, blasint *)
     * }
     */
    public static MemorySegment zimatcopy_$address() {
        return zimatcopy_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zimatcopy_(char *, char *, blasint *, blasint *, double *, double *, blasint *, blasint *)
     * }
     */
    public static void zimatcopy_(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, MemorySegment x5, MemorySegment x6, MemorySegment x7) {
        var mh$ = zimatcopy_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zimatcopy_", x0, x1, x2, x3, x4, x5, x6, x7);
            }
            mh$.invokeExact(x0, x1, x2, x3, x4, x5, x6, x7);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sgeadd_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("sgeadd_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void sgeadd_(blasint *, blasint *, float *, float *, blasint *, float *, float *, blasint *)
     * }
     */
    public static FunctionDescriptor sgeadd_$descriptor() {
        return sgeadd_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void sgeadd_(blasint *, blasint *, float *, float *, blasint *, float *, float *, blasint *)
     * }
     */
    public static MethodHandle sgeadd_$handle() {
        return sgeadd_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void sgeadd_(blasint *, blasint *, float *, float *, blasint *, float *, float *, blasint *)
     * }
     */
    public static MemorySegment sgeadd_$address() {
        return sgeadd_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void sgeadd_(blasint *, blasint *, float *, float *, blasint *, float *, float *, blasint *)
     * }
     */
    public static void sgeadd_(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, MemorySegment x5, MemorySegment x6, MemorySegment x7) {
        var mh$ = sgeadd_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sgeadd_", x0, x1, x2, x3, x4, x5, x6, x7);
            }
            mh$.invokeExact(x0, x1, x2, x3, x4, x5, x6, x7);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dgeadd_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("dgeadd_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dgeadd_(blasint *, blasint *, double *, double *, blasint *, double *, double *, blasint *)
     * }
     */
    public static FunctionDescriptor dgeadd_$descriptor() {
        return dgeadd_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dgeadd_(blasint *, blasint *, double *, double *, blasint *, double *, double *, blasint *)
     * }
     */
    public static MethodHandle dgeadd_$handle() {
        return dgeadd_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dgeadd_(blasint *, blasint *, double *, double *, blasint *, double *, double *, blasint *)
     * }
     */
    public static MemorySegment dgeadd_$address() {
        return dgeadd_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dgeadd_(blasint *, blasint *, double *, double *, blasint *, double *, double *, blasint *)
     * }
     */
    public static void dgeadd_(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, MemorySegment x5, MemorySegment x6, MemorySegment x7) {
        var mh$ = dgeadd_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dgeadd_", x0, x1, x2, x3, x4, x5, x6, x7);
            }
            mh$.invokeExact(x0, x1, x2, x3, x4, x5, x6, x7);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cgeadd_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("cgeadd_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cgeadd_(blasint *, blasint *, float *, float *, blasint *, float *, float *, blasint *)
     * }
     */
    public static FunctionDescriptor cgeadd_$descriptor() {
        return cgeadd_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cgeadd_(blasint *, blasint *, float *, float *, blasint *, float *, float *, blasint *)
     * }
     */
    public static MethodHandle cgeadd_$handle() {
        return cgeadd_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cgeadd_(blasint *, blasint *, float *, float *, blasint *, float *, float *, blasint *)
     * }
     */
    public static MemorySegment cgeadd_$address() {
        return cgeadd_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cgeadd_(blasint *, blasint *, float *, float *, blasint *, float *, float *, blasint *)
     * }
     */
    public static void cgeadd_(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, MemorySegment x5, MemorySegment x6, MemorySegment x7) {
        var mh$ = cgeadd_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cgeadd_", x0, x1, x2, x3, x4, x5, x6, x7);
            }
            mh$.invokeExact(x0, x1, x2, x3, x4, x5, x6, x7);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zgeadd_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("zgeadd_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zgeadd_(blasint *, blasint *, double *, double *, blasint *, double *, double *, blasint *)
     * }
     */
    public static FunctionDescriptor zgeadd_$descriptor() {
        return zgeadd_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zgeadd_(blasint *, blasint *, double *, double *, blasint *, double *, double *, blasint *)
     * }
     */
    public static MethodHandle zgeadd_$handle() {
        return zgeadd_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zgeadd_(blasint *, blasint *, double *, double *, blasint *, double *, double *, blasint *)
     * }
     */
    public static MemorySegment zgeadd_$address() {
        return zgeadd_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zgeadd_(blasint *, blasint *, double *, double *, blasint *, double *, double *, blasint *)
     * }
     */
    public static void zgeadd_(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, MemorySegment x5, MemorySegment x6, MemorySegment x7) {
        var mh$ = zgeadd_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zgeadd_", x0, x1, x2, x3, x4, x5, x6, x7);
            }
            mh$.invokeExact(x0, x1, x2, x3, x4, x5, x6, x7);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final MemorySegment NULL = MemorySegment.ofAddress(0L);
    /**
     * {@snippet lang=c :
     * #define NULL (void*) 0
     * }
     */
    public static MemorySegment NULL() {
        return NULL;
    }
    /**
     * {@snippet lang=c :
     * #define OPENBLAS_CHAR_CORENAME "generic"
     * }
     */
    public static MemorySegment OPENBLAS_CHAR_CORENAME() {
        class Holder {
            static final MemorySegment OPENBLAS_CHAR_CORENAME
                = cblas_openblas_h.LIBRARY_ARENA.allocateFrom("generic");
        }
        return Holder.OPENBLAS_CHAR_CORENAME;
    }
    /**
     * {@snippet lang=c :
     * #define OPENBLAS_VERSION " OpenBLAS 0.3.20 "
     * }
     */
    public static MemorySegment OPENBLAS_VERSION() {
        class Holder {
            static final MemorySegment OPENBLAS_VERSION
                = cblas_openblas_h.LIBRARY_ARENA.allocateFrom(" OpenBLAS 0.3.20 ");
        }
        return Holder.OPENBLAS_VERSION;
    }
    private static final long _POSIX_C_SOURCE = 200809L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_C_SOURCE 200809
     * }
     */
    public static long _POSIX_C_SOURCE() {
        return _POSIX_C_SOURCE;
    }
    private static final int __TIMESIZE = (int)64L;
    /**
     * {@snippet lang=c :
     * #define __TIMESIZE 64
     * }
     */
    public static int __TIMESIZE() {
        return __TIMESIZE;
    }
    private static final long __STDC_IEC_60559_BFP__ = 201404L;
    /**
     * {@snippet lang=c :
     * #define __STDC_IEC_60559_BFP__ 201404
     * }
     */
    public static long __STDC_IEC_60559_BFP__() {
        return __STDC_IEC_60559_BFP__;
    }
    private static final long __STDC_IEC_60559_COMPLEX__ = 201404L;
    /**
     * {@snippet lang=c :
     * #define __STDC_IEC_60559_COMPLEX__ 201404
     * }
     */
    public static long __STDC_IEC_60559_COMPLEX__() {
        return __STDC_IEC_60559_COMPLEX__;
    }
    private static final long __STDC_ISO_10646__ = 201706L;
    /**
     * {@snippet lang=c :
     * #define __STDC_ISO_10646__ 201706
     * }
     */
    public static long __STDC_ISO_10646__() {
        return __STDC_ISO_10646__;
    }
    private static final int __WCHAR_MAX = (int)2147483647L;
    /**
     * {@snippet lang=c :
     * #define __WCHAR_MAX 2147483647
     * }
     */
    public static int __WCHAR_MAX() {
        return __WCHAR_MAX;
    }
    private static final int __WCHAR_MIN = (int)-2147483648L;
    /**
     * {@snippet lang=c :
     * #define __WCHAR_MIN -2147483648
     * }
     */
    public static int __WCHAR_MIN() {
        return __WCHAR_MIN;
    }
    private static final int INT8_MIN = (int)-128L;
    /**
     * {@snippet lang=c :
     * #define INT8_MIN -128
     * }
     */
    public static int INT8_MIN() {
        return INT8_MIN;
    }
    private static final int INT16_MIN = (int)-32768L;
    /**
     * {@snippet lang=c :
     * #define INT16_MIN -32768
     * }
     */
    public static int INT16_MIN() {
        return INT16_MIN;
    }
    private static final int INT32_MIN = (int)-2147483648L;
    /**
     * {@snippet lang=c :
     * #define INT32_MIN -2147483648
     * }
     */
    public static int INT32_MIN() {
        return INT32_MIN;
    }
    private static final long INT64_MIN = -9223372036854775808L;
    /**
     * {@snippet lang=c :
     * #define INT64_MIN -9223372036854775808
     * }
     */
    public static long INT64_MIN() {
        return INT64_MIN;
    }
    private static final int INT8_MAX = (int)127L;
    /**
     * {@snippet lang=c :
     * #define INT8_MAX 127
     * }
     */
    public static int INT8_MAX() {
        return INT8_MAX;
    }
    private static final int INT16_MAX = (int)32767L;
    /**
     * {@snippet lang=c :
     * #define INT16_MAX 32767
     * }
     */
    public static int INT16_MAX() {
        return INT16_MAX;
    }
    private static final int INT32_MAX = (int)2147483647L;
    /**
     * {@snippet lang=c :
     * #define INT32_MAX 2147483647
     * }
     */
    public static int INT32_MAX() {
        return INT32_MAX;
    }
    private static final long INT64_MAX = 9223372036854775807L;
    /**
     * {@snippet lang=c :
     * #define INT64_MAX 9223372036854775807
     * }
     */
    public static long INT64_MAX() {
        return INT64_MAX;
    }
    private static final int UINT8_MAX = (int)255L;
    /**
     * {@snippet lang=c :
     * #define UINT8_MAX 255
     * }
     */
    public static int UINT8_MAX() {
        return UINT8_MAX;
    }
    private static final int UINT16_MAX = (int)65535L;
    /**
     * {@snippet lang=c :
     * #define UINT16_MAX 65535
     * }
     */
    public static int UINT16_MAX() {
        return UINT16_MAX;
    }
    private static final int UINT32_MAX = (int)4294967295L;
    /**
     * {@snippet lang=c :
     * #define UINT32_MAX 4294967295
     * }
     */
    public static int UINT32_MAX() {
        return UINT32_MAX;
    }
    private static final long UINT64_MAX = -1L;
    /**
     * {@snippet lang=c :
     * #define UINT64_MAX -1
     * }
     */
    public static long UINT64_MAX() {
        return UINT64_MAX;
    }
    private static final int INT_LEAST8_MIN = (int)-128L;
    /**
     * {@snippet lang=c :
     * #define INT_LEAST8_MIN -128
     * }
     */
    public static int INT_LEAST8_MIN() {
        return INT_LEAST8_MIN;
    }
    private static final int INT_LEAST16_MIN = (int)-32768L;
    /**
     * {@snippet lang=c :
     * #define INT_LEAST16_MIN -32768
     * }
     */
    public static int INT_LEAST16_MIN() {
        return INT_LEAST16_MIN;
    }
    private static final int INT_LEAST32_MIN = (int)-2147483648L;
    /**
     * {@snippet lang=c :
     * #define INT_LEAST32_MIN -2147483648
     * }
     */
    public static int INT_LEAST32_MIN() {
        return INT_LEAST32_MIN;
    }
    private static final long INT_LEAST64_MIN = -9223372036854775808L;
    /**
     * {@snippet lang=c :
     * #define INT_LEAST64_MIN -9223372036854775808
     * }
     */
    public static long INT_LEAST64_MIN() {
        return INT_LEAST64_MIN;
    }
    private static final int INT_LEAST8_MAX = (int)127L;
    /**
     * {@snippet lang=c :
     * #define INT_LEAST8_MAX 127
     * }
     */
    public static int INT_LEAST8_MAX() {
        return INT_LEAST8_MAX;
    }
    private static final int INT_LEAST16_MAX = (int)32767L;
    /**
     * {@snippet lang=c :
     * #define INT_LEAST16_MAX 32767
     * }
     */
    public static int INT_LEAST16_MAX() {
        return INT_LEAST16_MAX;
    }
    private static final int INT_LEAST32_MAX = (int)2147483647L;
    /**
     * {@snippet lang=c :
     * #define INT_LEAST32_MAX 2147483647
     * }
     */
    public static int INT_LEAST32_MAX() {
        return INT_LEAST32_MAX;
    }
    private static final long INT_LEAST64_MAX = 9223372036854775807L;
    /**
     * {@snippet lang=c :
     * #define INT_LEAST64_MAX 9223372036854775807
     * }
     */
    public static long INT_LEAST64_MAX() {
        return INT_LEAST64_MAX;
    }
    private static final int UINT_LEAST8_MAX = (int)255L;
    /**
     * {@snippet lang=c :
     * #define UINT_LEAST8_MAX 255
     * }
     */
    public static int UINT_LEAST8_MAX() {
        return UINT_LEAST8_MAX;
    }
    private static final int UINT_LEAST16_MAX = (int)65535L;
    /**
     * {@snippet lang=c :
     * #define UINT_LEAST16_MAX 65535
     * }
     */
    public static int UINT_LEAST16_MAX() {
        return UINT_LEAST16_MAX;
    }
    private static final int UINT_LEAST32_MAX = (int)4294967295L;
    /**
     * {@snippet lang=c :
     * #define UINT_LEAST32_MAX 4294967295
     * }
     */
    public static int UINT_LEAST32_MAX() {
        return UINT_LEAST32_MAX;
    }
    private static final long UINT_LEAST64_MAX = -1L;
    /**
     * {@snippet lang=c :
     * #define UINT_LEAST64_MAX -1
     * }
     */
    public static long UINT_LEAST64_MAX() {
        return UINT_LEAST64_MAX;
    }
    private static final int INT_FAST8_MIN = (int)-128L;
    /**
     * {@snippet lang=c :
     * #define INT_FAST8_MIN -128
     * }
     */
    public static int INT_FAST8_MIN() {
        return INT_FAST8_MIN;
    }
    private static final long INT_FAST16_MIN = -9223372036854775808L;
    /**
     * {@snippet lang=c :
     * #define INT_FAST16_MIN -9223372036854775808
     * }
     */
    public static long INT_FAST16_MIN() {
        return INT_FAST16_MIN;
    }
    private static final long INT_FAST32_MIN = -9223372036854775808L;
    /**
     * {@snippet lang=c :
     * #define INT_FAST32_MIN -9223372036854775808
     * }
     */
    public static long INT_FAST32_MIN() {
        return INT_FAST32_MIN;
    }
    private static final long INT_FAST64_MIN = -9223372036854775808L;
    /**
     * {@snippet lang=c :
     * #define INT_FAST64_MIN -9223372036854775808
     * }
     */
    public static long INT_FAST64_MIN() {
        return INT_FAST64_MIN;
    }
    private static final int INT_FAST8_MAX = (int)127L;
    /**
     * {@snippet lang=c :
     * #define INT_FAST8_MAX 127
     * }
     */
    public static int INT_FAST8_MAX() {
        return INT_FAST8_MAX;
    }
    private static final long INT_FAST16_MAX = 9223372036854775807L;
    /**
     * {@snippet lang=c :
     * #define INT_FAST16_MAX 9223372036854775807
     * }
     */
    public static long INT_FAST16_MAX() {
        return INT_FAST16_MAX;
    }
    private static final long INT_FAST32_MAX = 9223372036854775807L;
    /**
     * {@snippet lang=c :
     * #define INT_FAST32_MAX 9223372036854775807
     * }
     */
    public static long INT_FAST32_MAX() {
        return INT_FAST32_MAX;
    }
    private static final long INT_FAST64_MAX = 9223372036854775807L;
    /**
     * {@snippet lang=c :
     * #define INT_FAST64_MAX 9223372036854775807
     * }
     */
    public static long INT_FAST64_MAX() {
        return INT_FAST64_MAX;
    }
    private static final int UINT_FAST8_MAX = (int)255L;
    /**
     * {@snippet lang=c :
     * #define UINT_FAST8_MAX 255
     * }
     */
    public static int UINT_FAST8_MAX() {
        return UINT_FAST8_MAX;
    }
    private static final long UINT_FAST16_MAX = -1L;
    /**
     * {@snippet lang=c :
     * #define UINT_FAST16_MAX -1
     * }
     */
    public static long UINT_FAST16_MAX() {
        return UINT_FAST16_MAX;
    }
    private static final long UINT_FAST32_MAX = -1L;
    /**
     * {@snippet lang=c :
     * #define UINT_FAST32_MAX -1
     * }
     */
    public static long UINT_FAST32_MAX() {
        return UINT_FAST32_MAX;
    }
    private static final long UINT_FAST64_MAX = -1L;
    /**
     * {@snippet lang=c :
     * #define UINT_FAST64_MAX -1
     * }
     */
    public static long UINT_FAST64_MAX() {
        return UINT_FAST64_MAX;
    }
    private static final long INTPTR_MIN = -9223372036854775808L;
    /**
     * {@snippet lang=c :
     * #define INTPTR_MIN -9223372036854775808
     * }
     */
    public static long INTPTR_MIN() {
        return INTPTR_MIN;
    }
    private static final long INTPTR_MAX = 9223372036854775807L;
    /**
     * {@snippet lang=c :
     * #define INTPTR_MAX 9223372036854775807
     * }
     */
    public static long INTPTR_MAX() {
        return INTPTR_MAX;
    }
    private static final long UINTPTR_MAX = -1L;
    /**
     * {@snippet lang=c :
     * #define UINTPTR_MAX -1
     * }
     */
    public static long UINTPTR_MAX() {
        return UINTPTR_MAX;
    }
    private static final long INTMAX_MIN = -9223372036854775808L;
    /**
     * {@snippet lang=c :
     * #define INTMAX_MIN -9223372036854775808
     * }
     */
    public static long INTMAX_MIN() {
        return INTMAX_MIN;
    }
    private static final long INTMAX_MAX = 9223372036854775807L;
    /**
     * {@snippet lang=c :
     * #define INTMAX_MAX 9223372036854775807
     * }
     */
    public static long INTMAX_MAX() {
        return INTMAX_MAX;
    }
    private static final long UINTMAX_MAX = -1L;
    /**
     * {@snippet lang=c :
     * #define UINTMAX_MAX -1
     * }
     */
    public static long UINTMAX_MAX() {
        return UINTMAX_MAX;
    }
    private static final long PTRDIFF_MIN = -9223372036854775808L;
    /**
     * {@snippet lang=c :
     * #define PTRDIFF_MIN -9223372036854775808
     * }
     */
    public static long PTRDIFF_MIN() {
        return PTRDIFF_MIN;
    }
    private static final long PTRDIFF_MAX = 9223372036854775807L;
    /**
     * {@snippet lang=c :
     * #define PTRDIFF_MAX 9223372036854775807
     * }
     */
    public static long PTRDIFF_MAX() {
        return PTRDIFF_MAX;
    }
    private static final int SIG_ATOMIC_MIN = (int)-2147483648L;
    /**
     * {@snippet lang=c :
     * #define SIG_ATOMIC_MIN -2147483648
     * }
     */
    public static int SIG_ATOMIC_MIN() {
        return SIG_ATOMIC_MIN;
    }
    private static final int SIG_ATOMIC_MAX = (int)2147483647L;
    /**
     * {@snippet lang=c :
     * #define SIG_ATOMIC_MAX 2147483647
     * }
     */
    public static int SIG_ATOMIC_MAX() {
        return SIG_ATOMIC_MAX;
    }
    private static final long SIZE_MAX = -1L;
    /**
     * {@snippet lang=c :
     * #define SIZE_MAX -1
     * }
     */
    public static long SIZE_MAX() {
        return SIZE_MAX;
    }
    private static final int WCHAR_MIN = (int)-2147483648L;
    /**
     * {@snippet lang=c :
     * #define WCHAR_MIN -2147483648
     * }
     */
    public static int WCHAR_MIN() {
        return WCHAR_MIN;
    }
    private static final int WCHAR_MAX = (int)2147483647L;
    /**
     * {@snippet lang=c :
     * #define WCHAR_MAX 2147483647
     * }
     */
    public static int WCHAR_MAX() {
        return WCHAR_MAX;
    }
    private static final int WINT_MIN = (int)0L;
    /**
     * {@snippet lang=c :
     * #define WINT_MIN 0
     * }
     */
    public static int WINT_MIN() {
        return WINT_MIN;
    }
    private static final int WINT_MAX = (int)4294967295L;
    /**
     * {@snippet lang=c :
     * #define WINT_MAX 4294967295
     * }
     */
    public static int WINT_MAX() {
        return WINT_MAX;
    }
    private static final int EOF = (int)-1L;
    /**
     * {@snippet lang=c :
     * #define EOF -1
     * }
     */
    public static int EOF() {
        return EOF;
    }
    /**
     * {@snippet lang=c :
     * #define P_tmpdir "/tmp"
     * }
     */
    public static MemorySegment P_tmpdir() {
        class Holder {
            static final MemorySegment P_tmpdir
                = cblas_openblas_h.LIBRARY_ARENA.allocateFrom("/tmp");
        }
        return Holder.P_tmpdir;
    }
    private static final int __HAVE_DISTINCT_FLOAT16 = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __HAVE_DISTINCT_FLOAT16 0
     * }
     */
    public static int __HAVE_DISTINCT_FLOAT16() {
        return __HAVE_DISTINCT_FLOAT16;
    }
    private static final int __HAVE_DISTINCT_FLOAT128X = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __HAVE_DISTINCT_FLOAT128X 0
     * }
     */
    public static int __HAVE_DISTINCT_FLOAT128X() {
        return __HAVE_DISTINCT_FLOAT128X;
    }
    private static final int __HAVE_FLOAT128_UNLIKE_LDBL = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __HAVE_FLOAT128_UNLIKE_LDBL 0
     * }
     */
    public static int __HAVE_FLOAT128_UNLIKE_LDBL() {
        return __HAVE_FLOAT128_UNLIKE_LDBL;
    }
    private static final float _Complex_I = 0f;
    /**
     * {@snippet lang=c :
     * #define _Complex_I 0
     * }
     */
    public static float _Complex_I() {
        return _Complex_I;
    }
    private static final float I = 0f;
    /**
     * {@snippet lang=c :
     * #define I 0
     * }
     */
    public static float I() {
        return I;
    }
    private static final int __BYTE_ORDER = (int)1234L;
    /**
     * {@snippet lang=c :
     * #define __BYTE_ORDER 1234
     * }
     */
    public static int __BYTE_ORDER() {
        return __BYTE_ORDER;
    }
    private static final int __FLOAT_WORD_ORDER = (int)1234L;
    /**
     * {@snippet lang=c :
     * #define __FLOAT_WORD_ORDER 1234
     * }
     */
    public static int __FLOAT_WORD_ORDER() {
        return __FLOAT_WORD_ORDER;
    }
    private static final long __NCPUBITS = 64L;
    /**
     * {@snippet lang=c :
     * #define __NCPUBITS 64
     * }
     */
    public static long __NCPUBITS() {
        return __NCPUBITS;
    }
}

