// Generated by jextract

package smile.math.blas.openblas;

import java.lang.invoke.*;
import java.lang.foreign.*;
import java.nio.ByteOrder;
import java.util.*;
import java.util.function.*;
import java.util.stream.*;

import static java.lang.foreign.ValueLayout.*;
import static java.lang.foreign.MemoryLayout.PathElement.*;

public class cblas_openblas_h extends cblas_openblas_h_1 {

    cblas_openblas_h() {
        // Should not be called directly
    }

    private static class LAPACKE_stbrfs_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_stbrfs_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_stbrfs_work(int matrix_layout, char uplo, char trans, char diag, int n, int kd, int nrhs, const float *ab, int ldab, const float *b, int ldb, const float *x, int ldx, float *ferr, float *berr, float *work, int *iwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_stbrfs_work$descriptor() {
        return LAPACKE_stbrfs_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_stbrfs_work(int matrix_layout, char uplo, char trans, char diag, int n, int kd, int nrhs, const float *ab, int ldab, const float *b, int ldb, const float *x, int ldx, float *ferr, float *berr, float *work, int *iwork)
     * }
     */
    public static MethodHandle LAPACKE_stbrfs_work$handle() {
        return LAPACKE_stbrfs_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_stbrfs_work(int matrix_layout, char uplo, char trans, char diag, int n, int kd, int nrhs, const float *ab, int ldab, const float *b, int ldb, const float *x, int ldx, float *ferr, float *berr, float *work, int *iwork)
     * }
     */
    public static MemorySegment LAPACKE_stbrfs_work$address() {
        return LAPACKE_stbrfs_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_stbrfs_work(int matrix_layout, char uplo, char trans, char diag, int n, int kd, int nrhs, const float *ab, int ldab, const float *b, int ldb, const float *x, int ldx, float *ferr, float *berr, float *work, int *iwork)
     * }
     */
    public static int LAPACKE_stbrfs_work(int matrix_layout, byte uplo, byte trans, byte diag, int n, int kd, int nrhs, MemorySegment ab, int ldab, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment ferr, MemorySegment berr, MemorySegment work, MemorySegment iwork) {
        var mh$ = LAPACKE_stbrfs_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_stbrfs_work", matrix_layout, uplo, trans, diag, n, kd, nrhs, ab, ldab, b, ldb, x, ldx, ferr, berr, work, iwork);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, trans, diag, n, kd, nrhs, ab, ldab, b, ldb, x, ldx, ferr, berr, work, iwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dtbrfs_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dtbrfs_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dtbrfs_work(int matrix_layout, char uplo, char trans, char diag, int n, int kd, int nrhs, const double *ab, int ldab, const double *b, int ldb, const double *x, int ldx, double *ferr, double *berr, double *work, int *iwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_dtbrfs_work$descriptor() {
        return LAPACKE_dtbrfs_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dtbrfs_work(int matrix_layout, char uplo, char trans, char diag, int n, int kd, int nrhs, const double *ab, int ldab, const double *b, int ldb, const double *x, int ldx, double *ferr, double *berr, double *work, int *iwork)
     * }
     */
    public static MethodHandle LAPACKE_dtbrfs_work$handle() {
        return LAPACKE_dtbrfs_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dtbrfs_work(int matrix_layout, char uplo, char trans, char diag, int n, int kd, int nrhs, const double *ab, int ldab, const double *b, int ldb, const double *x, int ldx, double *ferr, double *berr, double *work, int *iwork)
     * }
     */
    public static MemorySegment LAPACKE_dtbrfs_work$address() {
        return LAPACKE_dtbrfs_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dtbrfs_work(int matrix_layout, char uplo, char trans, char diag, int n, int kd, int nrhs, const double *ab, int ldab, const double *b, int ldb, const double *x, int ldx, double *ferr, double *berr, double *work, int *iwork)
     * }
     */
    public static int LAPACKE_dtbrfs_work(int matrix_layout, byte uplo, byte trans, byte diag, int n, int kd, int nrhs, MemorySegment ab, int ldab, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment ferr, MemorySegment berr, MemorySegment work, MemorySegment iwork) {
        var mh$ = LAPACKE_dtbrfs_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dtbrfs_work", matrix_layout, uplo, trans, diag, n, kd, nrhs, ab, ldab, b, ldb, x, ldx, ferr, berr, work, iwork);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, trans, diag, n, kd, nrhs, ab, ldab, b, ldb, x, ldx, ferr, berr, work, iwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ctbrfs_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_ctbrfs_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ctbrfs_work(int matrix_layout, char uplo, char trans, char diag, int n, int kd, int nrhs, const _Complex float *ab, int ldab, const _Complex float *b, int ldb, const _Complex float *x, int ldx, float *ferr, float *berr, _Complex float *work, float *rwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_ctbrfs_work$descriptor() {
        return LAPACKE_ctbrfs_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ctbrfs_work(int matrix_layout, char uplo, char trans, char diag, int n, int kd, int nrhs, const _Complex float *ab, int ldab, const _Complex float *b, int ldb, const _Complex float *x, int ldx, float *ferr, float *berr, _Complex float *work, float *rwork)
     * }
     */
    public static MethodHandle LAPACKE_ctbrfs_work$handle() {
        return LAPACKE_ctbrfs_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ctbrfs_work(int matrix_layout, char uplo, char trans, char diag, int n, int kd, int nrhs, const _Complex float *ab, int ldab, const _Complex float *b, int ldb, const _Complex float *x, int ldx, float *ferr, float *berr, _Complex float *work, float *rwork)
     * }
     */
    public static MemorySegment LAPACKE_ctbrfs_work$address() {
        return LAPACKE_ctbrfs_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ctbrfs_work(int matrix_layout, char uplo, char trans, char diag, int n, int kd, int nrhs, const _Complex float *ab, int ldab, const _Complex float *b, int ldb, const _Complex float *x, int ldx, float *ferr, float *berr, _Complex float *work, float *rwork)
     * }
     */
    public static int LAPACKE_ctbrfs_work(int matrix_layout, byte uplo, byte trans, byte diag, int n, int kd, int nrhs, MemorySegment ab, int ldab, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment ferr, MemorySegment berr, MemorySegment work, MemorySegment rwork) {
        var mh$ = LAPACKE_ctbrfs_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ctbrfs_work", matrix_layout, uplo, trans, diag, n, kd, nrhs, ab, ldab, b, ldb, x, ldx, ferr, berr, work, rwork);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, trans, diag, n, kd, nrhs, ab, ldab, b, ldb, x, ldx, ferr, berr, work, rwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ztbrfs_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_ztbrfs_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ztbrfs_work(int matrix_layout, char uplo, char trans, char diag, int n, int kd, int nrhs, const _Complex double *ab, int ldab, const _Complex double *b, int ldb, const _Complex double *x, int ldx, double *ferr, double *berr, _Complex double *work, double *rwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_ztbrfs_work$descriptor() {
        return LAPACKE_ztbrfs_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ztbrfs_work(int matrix_layout, char uplo, char trans, char diag, int n, int kd, int nrhs, const _Complex double *ab, int ldab, const _Complex double *b, int ldb, const _Complex double *x, int ldx, double *ferr, double *berr, _Complex double *work, double *rwork)
     * }
     */
    public static MethodHandle LAPACKE_ztbrfs_work$handle() {
        return LAPACKE_ztbrfs_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ztbrfs_work(int matrix_layout, char uplo, char trans, char diag, int n, int kd, int nrhs, const _Complex double *ab, int ldab, const _Complex double *b, int ldb, const _Complex double *x, int ldx, double *ferr, double *berr, _Complex double *work, double *rwork)
     * }
     */
    public static MemorySegment LAPACKE_ztbrfs_work$address() {
        return LAPACKE_ztbrfs_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ztbrfs_work(int matrix_layout, char uplo, char trans, char diag, int n, int kd, int nrhs, const _Complex double *ab, int ldab, const _Complex double *b, int ldb, const _Complex double *x, int ldx, double *ferr, double *berr, _Complex double *work, double *rwork)
     * }
     */
    public static int LAPACKE_ztbrfs_work(int matrix_layout, byte uplo, byte trans, byte diag, int n, int kd, int nrhs, MemorySegment ab, int ldab, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment ferr, MemorySegment berr, MemorySegment work, MemorySegment rwork) {
        var mh$ = LAPACKE_ztbrfs_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ztbrfs_work", matrix_layout, uplo, trans, diag, n, kd, nrhs, ab, ldab, b, ldb, x, ldx, ferr, berr, work, rwork);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, trans, diag, n, kd, nrhs, ab, ldab, b, ldb, x, ldx, ferr, berr, work, rwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_stbtrs_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_stbtrs_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_stbtrs_work(int matrix_layout, char uplo, char trans, char diag, int n, int kd, int nrhs, const float *ab, int ldab, float *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_stbtrs_work$descriptor() {
        return LAPACKE_stbtrs_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_stbtrs_work(int matrix_layout, char uplo, char trans, char diag, int n, int kd, int nrhs, const float *ab, int ldab, float *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_stbtrs_work$handle() {
        return LAPACKE_stbtrs_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_stbtrs_work(int matrix_layout, char uplo, char trans, char diag, int n, int kd, int nrhs, const float *ab, int ldab, float *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_stbtrs_work$address() {
        return LAPACKE_stbtrs_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_stbtrs_work(int matrix_layout, char uplo, char trans, char diag, int n, int kd, int nrhs, const float *ab, int ldab, float *b, int ldb)
     * }
     */
    public static int LAPACKE_stbtrs_work(int matrix_layout, byte uplo, byte trans, byte diag, int n, int kd, int nrhs, MemorySegment ab, int ldab, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_stbtrs_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_stbtrs_work", matrix_layout, uplo, trans, diag, n, kd, nrhs, ab, ldab, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, trans, diag, n, kd, nrhs, ab, ldab, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dtbtrs_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dtbtrs_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dtbtrs_work(int matrix_layout, char uplo, char trans, char diag, int n, int kd, int nrhs, const double *ab, int ldab, double *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_dtbtrs_work$descriptor() {
        return LAPACKE_dtbtrs_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dtbtrs_work(int matrix_layout, char uplo, char trans, char diag, int n, int kd, int nrhs, const double *ab, int ldab, double *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_dtbtrs_work$handle() {
        return LAPACKE_dtbtrs_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dtbtrs_work(int matrix_layout, char uplo, char trans, char diag, int n, int kd, int nrhs, const double *ab, int ldab, double *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_dtbtrs_work$address() {
        return LAPACKE_dtbtrs_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dtbtrs_work(int matrix_layout, char uplo, char trans, char diag, int n, int kd, int nrhs, const double *ab, int ldab, double *b, int ldb)
     * }
     */
    public static int LAPACKE_dtbtrs_work(int matrix_layout, byte uplo, byte trans, byte diag, int n, int kd, int nrhs, MemorySegment ab, int ldab, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_dtbtrs_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dtbtrs_work", matrix_layout, uplo, trans, diag, n, kd, nrhs, ab, ldab, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, trans, diag, n, kd, nrhs, ab, ldab, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ctbtrs_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_ctbtrs_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ctbtrs_work(int matrix_layout, char uplo, char trans, char diag, int n, int kd, int nrhs, const _Complex float *ab, int ldab, _Complex float *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_ctbtrs_work$descriptor() {
        return LAPACKE_ctbtrs_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ctbtrs_work(int matrix_layout, char uplo, char trans, char diag, int n, int kd, int nrhs, const _Complex float *ab, int ldab, _Complex float *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_ctbtrs_work$handle() {
        return LAPACKE_ctbtrs_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ctbtrs_work(int matrix_layout, char uplo, char trans, char diag, int n, int kd, int nrhs, const _Complex float *ab, int ldab, _Complex float *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_ctbtrs_work$address() {
        return LAPACKE_ctbtrs_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ctbtrs_work(int matrix_layout, char uplo, char trans, char diag, int n, int kd, int nrhs, const _Complex float *ab, int ldab, _Complex float *b, int ldb)
     * }
     */
    public static int LAPACKE_ctbtrs_work(int matrix_layout, byte uplo, byte trans, byte diag, int n, int kd, int nrhs, MemorySegment ab, int ldab, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_ctbtrs_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ctbtrs_work", matrix_layout, uplo, trans, diag, n, kd, nrhs, ab, ldab, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, trans, diag, n, kd, nrhs, ab, ldab, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ztbtrs_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_ztbtrs_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ztbtrs_work(int matrix_layout, char uplo, char trans, char diag, int n, int kd, int nrhs, const _Complex double *ab, int ldab, _Complex double *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_ztbtrs_work$descriptor() {
        return LAPACKE_ztbtrs_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ztbtrs_work(int matrix_layout, char uplo, char trans, char diag, int n, int kd, int nrhs, const _Complex double *ab, int ldab, _Complex double *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_ztbtrs_work$handle() {
        return LAPACKE_ztbtrs_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ztbtrs_work(int matrix_layout, char uplo, char trans, char diag, int n, int kd, int nrhs, const _Complex double *ab, int ldab, _Complex double *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_ztbtrs_work$address() {
        return LAPACKE_ztbtrs_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ztbtrs_work(int matrix_layout, char uplo, char trans, char diag, int n, int kd, int nrhs, const _Complex double *ab, int ldab, _Complex double *b, int ldb)
     * }
     */
    public static int LAPACKE_ztbtrs_work(int matrix_layout, byte uplo, byte trans, byte diag, int n, int kd, int nrhs, MemorySegment ab, int ldab, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_ztbtrs_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ztbtrs_work", matrix_layout, uplo, trans, diag, n, kd, nrhs, ab, ldab, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, trans, diag, n, kd, nrhs, ab, ldab, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_stfsm_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_stfsm_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_stfsm_work(int matrix_layout, char transr, char side, char uplo, char trans, char diag, int m, int n, float alpha, const float *a, float *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_stfsm_work$descriptor() {
        return LAPACKE_stfsm_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_stfsm_work(int matrix_layout, char transr, char side, char uplo, char trans, char diag, int m, int n, float alpha, const float *a, float *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_stfsm_work$handle() {
        return LAPACKE_stfsm_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_stfsm_work(int matrix_layout, char transr, char side, char uplo, char trans, char diag, int m, int n, float alpha, const float *a, float *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_stfsm_work$address() {
        return LAPACKE_stfsm_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_stfsm_work(int matrix_layout, char transr, char side, char uplo, char trans, char diag, int m, int n, float alpha, const float *a, float *b, int ldb)
     * }
     */
    public static int LAPACKE_stfsm_work(int matrix_layout, byte transr, byte side, byte uplo, byte trans, byte diag, int m, int n, float alpha, MemorySegment a, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_stfsm_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_stfsm_work", matrix_layout, transr, side, uplo, trans, diag, m, n, alpha, a, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, transr, side, uplo, trans, diag, m, n, alpha, a, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dtfsm_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dtfsm_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dtfsm_work(int matrix_layout, char transr, char side, char uplo, char trans, char diag, int m, int n, double alpha, const double *a, double *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_dtfsm_work$descriptor() {
        return LAPACKE_dtfsm_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dtfsm_work(int matrix_layout, char transr, char side, char uplo, char trans, char diag, int m, int n, double alpha, const double *a, double *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_dtfsm_work$handle() {
        return LAPACKE_dtfsm_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dtfsm_work(int matrix_layout, char transr, char side, char uplo, char trans, char diag, int m, int n, double alpha, const double *a, double *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_dtfsm_work$address() {
        return LAPACKE_dtfsm_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dtfsm_work(int matrix_layout, char transr, char side, char uplo, char trans, char diag, int m, int n, double alpha, const double *a, double *b, int ldb)
     * }
     */
    public static int LAPACKE_dtfsm_work(int matrix_layout, byte transr, byte side, byte uplo, byte trans, byte diag, int m, int n, double alpha, MemorySegment a, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_dtfsm_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dtfsm_work", matrix_layout, transr, side, uplo, trans, diag, m, n, alpha, a, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, transr, side, uplo, trans, diag, m, n, alpha, a, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ctfsm_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_ctfsm_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ctfsm_work(int matrix_layout, char transr, char side, char uplo, char trans, char diag, int m, int n, _Complex float alpha, const _Complex float *a, _Complex float *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_ctfsm_work$descriptor() {
        return LAPACKE_ctfsm_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ctfsm_work(int matrix_layout, char transr, char side, char uplo, char trans, char diag, int m, int n, _Complex float alpha, const _Complex float *a, _Complex float *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_ctfsm_work$handle() {
        return LAPACKE_ctfsm_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ctfsm_work(int matrix_layout, char transr, char side, char uplo, char trans, char diag, int m, int n, _Complex float alpha, const _Complex float *a, _Complex float *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_ctfsm_work$address() {
        return LAPACKE_ctfsm_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ctfsm_work(int matrix_layout, char transr, char side, char uplo, char trans, char diag, int m, int n, _Complex float alpha, const _Complex float *a, _Complex float *b, int ldb)
     * }
     */
    public static int LAPACKE_ctfsm_work(int matrix_layout, byte transr, byte side, byte uplo, byte trans, byte diag, int m, int n, float alpha, MemorySegment a, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_ctfsm_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ctfsm_work", matrix_layout, transr, side, uplo, trans, diag, m, n, alpha, a, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, transr, side, uplo, trans, diag, m, n, alpha, a, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ztfsm_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_ztfsm_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ztfsm_work(int matrix_layout, char transr, char side, char uplo, char trans, char diag, int m, int n, _Complex double alpha, const _Complex double *a, _Complex double *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_ztfsm_work$descriptor() {
        return LAPACKE_ztfsm_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ztfsm_work(int matrix_layout, char transr, char side, char uplo, char trans, char diag, int m, int n, _Complex double alpha, const _Complex double *a, _Complex double *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_ztfsm_work$handle() {
        return LAPACKE_ztfsm_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ztfsm_work(int matrix_layout, char transr, char side, char uplo, char trans, char diag, int m, int n, _Complex double alpha, const _Complex double *a, _Complex double *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_ztfsm_work$address() {
        return LAPACKE_ztfsm_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ztfsm_work(int matrix_layout, char transr, char side, char uplo, char trans, char diag, int m, int n, _Complex double alpha, const _Complex double *a, _Complex double *b, int ldb)
     * }
     */
    public static int LAPACKE_ztfsm_work(int matrix_layout, byte transr, byte side, byte uplo, byte trans, byte diag, int m, int n, double alpha, MemorySegment a, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_ztfsm_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ztfsm_work", matrix_layout, transr, side, uplo, trans, diag, m, n, alpha, a, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, transr, side, uplo, trans, diag, m, n, alpha, a, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_stftri_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_stftri_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_stftri_work(int matrix_layout, char transr, char uplo, char diag, int n, float *a)
     * }
     */
    public static FunctionDescriptor LAPACKE_stftri_work$descriptor() {
        return LAPACKE_stftri_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_stftri_work(int matrix_layout, char transr, char uplo, char diag, int n, float *a)
     * }
     */
    public static MethodHandle LAPACKE_stftri_work$handle() {
        return LAPACKE_stftri_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_stftri_work(int matrix_layout, char transr, char uplo, char diag, int n, float *a)
     * }
     */
    public static MemorySegment LAPACKE_stftri_work$address() {
        return LAPACKE_stftri_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_stftri_work(int matrix_layout, char transr, char uplo, char diag, int n, float *a)
     * }
     */
    public static int LAPACKE_stftri_work(int matrix_layout, byte transr, byte uplo, byte diag, int n, MemorySegment a) {
        var mh$ = LAPACKE_stftri_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_stftri_work", matrix_layout, transr, uplo, diag, n, a);
            }
            return (int)mh$.invokeExact(matrix_layout, transr, uplo, diag, n, a);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dtftri_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dtftri_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dtftri_work(int matrix_layout, char transr, char uplo, char diag, int n, double *a)
     * }
     */
    public static FunctionDescriptor LAPACKE_dtftri_work$descriptor() {
        return LAPACKE_dtftri_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dtftri_work(int matrix_layout, char transr, char uplo, char diag, int n, double *a)
     * }
     */
    public static MethodHandle LAPACKE_dtftri_work$handle() {
        return LAPACKE_dtftri_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dtftri_work(int matrix_layout, char transr, char uplo, char diag, int n, double *a)
     * }
     */
    public static MemorySegment LAPACKE_dtftri_work$address() {
        return LAPACKE_dtftri_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dtftri_work(int matrix_layout, char transr, char uplo, char diag, int n, double *a)
     * }
     */
    public static int LAPACKE_dtftri_work(int matrix_layout, byte transr, byte uplo, byte diag, int n, MemorySegment a) {
        var mh$ = LAPACKE_dtftri_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dtftri_work", matrix_layout, transr, uplo, diag, n, a);
            }
            return (int)mh$.invokeExact(matrix_layout, transr, uplo, diag, n, a);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ctftri_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_ctftri_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ctftri_work(int matrix_layout, char transr, char uplo, char diag, int n, _Complex float *a)
     * }
     */
    public static FunctionDescriptor LAPACKE_ctftri_work$descriptor() {
        return LAPACKE_ctftri_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ctftri_work(int matrix_layout, char transr, char uplo, char diag, int n, _Complex float *a)
     * }
     */
    public static MethodHandle LAPACKE_ctftri_work$handle() {
        return LAPACKE_ctftri_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ctftri_work(int matrix_layout, char transr, char uplo, char diag, int n, _Complex float *a)
     * }
     */
    public static MemorySegment LAPACKE_ctftri_work$address() {
        return LAPACKE_ctftri_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ctftri_work(int matrix_layout, char transr, char uplo, char diag, int n, _Complex float *a)
     * }
     */
    public static int LAPACKE_ctftri_work(int matrix_layout, byte transr, byte uplo, byte diag, int n, MemorySegment a) {
        var mh$ = LAPACKE_ctftri_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ctftri_work", matrix_layout, transr, uplo, diag, n, a);
            }
            return (int)mh$.invokeExact(matrix_layout, transr, uplo, diag, n, a);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ztftri_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_ztftri_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ztftri_work(int matrix_layout, char transr, char uplo, char diag, int n, _Complex double *a)
     * }
     */
    public static FunctionDescriptor LAPACKE_ztftri_work$descriptor() {
        return LAPACKE_ztftri_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ztftri_work(int matrix_layout, char transr, char uplo, char diag, int n, _Complex double *a)
     * }
     */
    public static MethodHandle LAPACKE_ztftri_work$handle() {
        return LAPACKE_ztftri_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ztftri_work(int matrix_layout, char transr, char uplo, char diag, int n, _Complex double *a)
     * }
     */
    public static MemorySegment LAPACKE_ztftri_work$address() {
        return LAPACKE_ztftri_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ztftri_work(int matrix_layout, char transr, char uplo, char diag, int n, _Complex double *a)
     * }
     */
    public static int LAPACKE_ztftri_work(int matrix_layout, byte transr, byte uplo, byte diag, int n, MemorySegment a) {
        var mh$ = LAPACKE_ztftri_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ztftri_work", matrix_layout, transr, uplo, diag, n, a);
            }
            return (int)mh$.invokeExact(matrix_layout, transr, uplo, diag, n, a);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_stfttp_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_stfttp_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_stfttp_work(int matrix_layout, char transr, char uplo, int n, const float *arf, float *ap)
     * }
     */
    public static FunctionDescriptor LAPACKE_stfttp_work$descriptor() {
        return LAPACKE_stfttp_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_stfttp_work(int matrix_layout, char transr, char uplo, int n, const float *arf, float *ap)
     * }
     */
    public static MethodHandle LAPACKE_stfttp_work$handle() {
        return LAPACKE_stfttp_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_stfttp_work(int matrix_layout, char transr, char uplo, int n, const float *arf, float *ap)
     * }
     */
    public static MemorySegment LAPACKE_stfttp_work$address() {
        return LAPACKE_stfttp_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_stfttp_work(int matrix_layout, char transr, char uplo, int n, const float *arf, float *ap)
     * }
     */
    public static int LAPACKE_stfttp_work(int matrix_layout, byte transr, byte uplo, int n, MemorySegment arf, MemorySegment ap) {
        var mh$ = LAPACKE_stfttp_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_stfttp_work", matrix_layout, transr, uplo, n, arf, ap);
            }
            return (int)mh$.invokeExact(matrix_layout, transr, uplo, n, arf, ap);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dtfttp_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dtfttp_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dtfttp_work(int matrix_layout, char transr, char uplo, int n, const double *arf, double *ap)
     * }
     */
    public static FunctionDescriptor LAPACKE_dtfttp_work$descriptor() {
        return LAPACKE_dtfttp_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dtfttp_work(int matrix_layout, char transr, char uplo, int n, const double *arf, double *ap)
     * }
     */
    public static MethodHandle LAPACKE_dtfttp_work$handle() {
        return LAPACKE_dtfttp_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dtfttp_work(int matrix_layout, char transr, char uplo, int n, const double *arf, double *ap)
     * }
     */
    public static MemorySegment LAPACKE_dtfttp_work$address() {
        return LAPACKE_dtfttp_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dtfttp_work(int matrix_layout, char transr, char uplo, int n, const double *arf, double *ap)
     * }
     */
    public static int LAPACKE_dtfttp_work(int matrix_layout, byte transr, byte uplo, int n, MemorySegment arf, MemorySegment ap) {
        var mh$ = LAPACKE_dtfttp_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dtfttp_work", matrix_layout, transr, uplo, n, arf, ap);
            }
            return (int)mh$.invokeExact(matrix_layout, transr, uplo, n, arf, ap);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ctfttp_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_ctfttp_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ctfttp_work(int matrix_layout, char transr, char uplo, int n, const _Complex float *arf, _Complex float *ap)
     * }
     */
    public static FunctionDescriptor LAPACKE_ctfttp_work$descriptor() {
        return LAPACKE_ctfttp_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ctfttp_work(int matrix_layout, char transr, char uplo, int n, const _Complex float *arf, _Complex float *ap)
     * }
     */
    public static MethodHandle LAPACKE_ctfttp_work$handle() {
        return LAPACKE_ctfttp_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ctfttp_work(int matrix_layout, char transr, char uplo, int n, const _Complex float *arf, _Complex float *ap)
     * }
     */
    public static MemorySegment LAPACKE_ctfttp_work$address() {
        return LAPACKE_ctfttp_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ctfttp_work(int matrix_layout, char transr, char uplo, int n, const _Complex float *arf, _Complex float *ap)
     * }
     */
    public static int LAPACKE_ctfttp_work(int matrix_layout, byte transr, byte uplo, int n, MemorySegment arf, MemorySegment ap) {
        var mh$ = LAPACKE_ctfttp_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ctfttp_work", matrix_layout, transr, uplo, n, arf, ap);
            }
            return (int)mh$.invokeExact(matrix_layout, transr, uplo, n, arf, ap);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ztfttp_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_ztfttp_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ztfttp_work(int matrix_layout, char transr, char uplo, int n, const _Complex double *arf, _Complex double *ap)
     * }
     */
    public static FunctionDescriptor LAPACKE_ztfttp_work$descriptor() {
        return LAPACKE_ztfttp_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ztfttp_work(int matrix_layout, char transr, char uplo, int n, const _Complex double *arf, _Complex double *ap)
     * }
     */
    public static MethodHandle LAPACKE_ztfttp_work$handle() {
        return LAPACKE_ztfttp_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ztfttp_work(int matrix_layout, char transr, char uplo, int n, const _Complex double *arf, _Complex double *ap)
     * }
     */
    public static MemorySegment LAPACKE_ztfttp_work$address() {
        return LAPACKE_ztfttp_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ztfttp_work(int matrix_layout, char transr, char uplo, int n, const _Complex double *arf, _Complex double *ap)
     * }
     */
    public static int LAPACKE_ztfttp_work(int matrix_layout, byte transr, byte uplo, int n, MemorySegment arf, MemorySegment ap) {
        var mh$ = LAPACKE_ztfttp_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ztfttp_work", matrix_layout, transr, uplo, n, arf, ap);
            }
            return (int)mh$.invokeExact(matrix_layout, transr, uplo, n, arf, ap);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_stfttr_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_stfttr_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_stfttr_work(int matrix_layout, char transr, char uplo, int n, const float *arf, float *a, int lda)
     * }
     */
    public static FunctionDescriptor LAPACKE_stfttr_work$descriptor() {
        return LAPACKE_stfttr_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_stfttr_work(int matrix_layout, char transr, char uplo, int n, const float *arf, float *a, int lda)
     * }
     */
    public static MethodHandle LAPACKE_stfttr_work$handle() {
        return LAPACKE_stfttr_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_stfttr_work(int matrix_layout, char transr, char uplo, int n, const float *arf, float *a, int lda)
     * }
     */
    public static MemorySegment LAPACKE_stfttr_work$address() {
        return LAPACKE_stfttr_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_stfttr_work(int matrix_layout, char transr, char uplo, int n, const float *arf, float *a, int lda)
     * }
     */
    public static int LAPACKE_stfttr_work(int matrix_layout, byte transr, byte uplo, int n, MemorySegment arf, MemorySegment a, int lda) {
        var mh$ = LAPACKE_stfttr_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_stfttr_work", matrix_layout, transr, uplo, n, arf, a, lda);
            }
            return (int)mh$.invokeExact(matrix_layout, transr, uplo, n, arf, a, lda);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dtfttr_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dtfttr_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dtfttr_work(int matrix_layout, char transr, char uplo, int n, const double *arf, double *a, int lda)
     * }
     */
    public static FunctionDescriptor LAPACKE_dtfttr_work$descriptor() {
        return LAPACKE_dtfttr_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dtfttr_work(int matrix_layout, char transr, char uplo, int n, const double *arf, double *a, int lda)
     * }
     */
    public static MethodHandle LAPACKE_dtfttr_work$handle() {
        return LAPACKE_dtfttr_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dtfttr_work(int matrix_layout, char transr, char uplo, int n, const double *arf, double *a, int lda)
     * }
     */
    public static MemorySegment LAPACKE_dtfttr_work$address() {
        return LAPACKE_dtfttr_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dtfttr_work(int matrix_layout, char transr, char uplo, int n, const double *arf, double *a, int lda)
     * }
     */
    public static int LAPACKE_dtfttr_work(int matrix_layout, byte transr, byte uplo, int n, MemorySegment arf, MemorySegment a, int lda) {
        var mh$ = LAPACKE_dtfttr_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dtfttr_work", matrix_layout, transr, uplo, n, arf, a, lda);
            }
            return (int)mh$.invokeExact(matrix_layout, transr, uplo, n, arf, a, lda);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ctfttr_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_ctfttr_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ctfttr_work(int matrix_layout, char transr, char uplo, int n, const _Complex float *arf, _Complex float *a, int lda)
     * }
     */
    public static FunctionDescriptor LAPACKE_ctfttr_work$descriptor() {
        return LAPACKE_ctfttr_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ctfttr_work(int matrix_layout, char transr, char uplo, int n, const _Complex float *arf, _Complex float *a, int lda)
     * }
     */
    public static MethodHandle LAPACKE_ctfttr_work$handle() {
        return LAPACKE_ctfttr_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ctfttr_work(int matrix_layout, char transr, char uplo, int n, const _Complex float *arf, _Complex float *a, int lda)
     * }
     */
    public static MemorySegment LAPACKE_ctfttr_work$address() {
        return LAPACKE_ctfttr_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ctfttr_work(int matrix_layout, char transr, char uplo, int n, const _Complex float *arf, _Complex float *a, int lda)
     * }
     */
    public static int LAPACKE_ctfttr_work(int matrix_layout, byte transr, byte uplo, int n, MemorySegment arf, MemorySegment a, int lda) {
        var mh$ = LAPACKE_ctfttr_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ctfttr_work", matrix_layout, transr, uplo, n, arf, a, lda);
            }
            return (int)mh$.invokeExact(matrix_layout, transr, uplo, n, arf, a, lda);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ztfttr_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_ztfttr_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ztfttr_work(int matrix_layout, char transr, char uplo, int n, const _Complex double *arf, _Complex double *a, int lda)
     * }
     */
    public static FunctionDescriptor LAPACKE_ztfttr_work$descriptor() {
        return LAPACKE_ztfttr_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ztfttr_work(int matrix_layout, char transr, char uplo, int n, const _Complex double *arf, _Complex double *a, int lda)
     * }
     */
    public static MethodHandle LAPACKE_ztfttr_work$handle() {
        return LAPACKE_ztfttr_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ztfttr_work(int matrix_layout, char transr, char uplo, int n, const _Complex double *arf, _Complex double *a, int lda)
     * }
     */
    public static MemorySegment LAPACKE_ztfttr_work$address() {
        return LAPACKE_ztfttr_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ztfttr_work(int matrix_layout, char transr, char uplo, int n, const _Complex double *arf, _Complex double *a, int lda)
     * }
     */
    public static int LAPACKE_ztfttr_work(int matrix_layout, byte transr, byte uplo, int n, MemorySegment arf, MemorySegment a, int lda) {
        var mh$ = LAPACKE_ztfttr_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ztfttr_work", matrix_layout, transr, uplo, n, arf, a, lda);
            }
            return (int)mh$.invokeExact(matrix_layout, transr, uplo, n, arf, a, lda);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_stgevc_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_stgevc_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_stgevc_work(int matrix_layout, char side, char howmny, const int *select, int n, const float *s, int lds, const float *p, int ldp, float *vl, int ldvl, float *vr, int ldvr, int mm, int *m, float *work)
     * }
     */
    public static FunctionDescriptor LAPACKE_stgevc_work$descriptor() {
        return LAPACKE_stgevc_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_stgevc_work(int matrix_layout, char side, char howmny, const int *select, int n, const float *s, int lds, const float *p, int ldp, float *vl, int ldvl, float *vr, int ldvr, int mm, int *m, float *work)
     * }
     */
    public static MethodHandle LAPACKE_stgevc_work$handle() {
        return LAPACKE_stgevc_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_stgevc_work(int matrix_layout, char side, char howmny, const int *select, int n, const float *s, int lds, const float *p, int ldp, float *vl, int ldvl, float *vr, int ldvr, int mm, int *m, float *work)
     * }
     */
    public static MemorySegment LAPACKE_stgevc_work$address() {
        return LAPACKE_stgevc_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_stgevc_work(int matrix_layout, char side, char howmny, const int *select, int n, const float *s, int lds, const float *p, int ldp, float *vl, int ldvl, float *vr, int ldvr, int mm, int *m, float *work)
     * }
     */
    public static int LAPACKE_stgevc_work(int matrix_layout, byte side, byte howmny, MemorySegment select, int n, MemorySegment s, int lds, MemorySegment p, int ldp, MemorySegment vl, int ldvl, MemorySegment vr, int ldvr, int mm, MemorySegment m, MemorySegment work) {
        var mh$ = LAPACKE_stgevc_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_stgevc_work", matrix_layout, side, howmny, select, n, s, lds, p, ldp, vl, ldvl, vr, ldvr, mm, m, work);
            }
            return (int)mh$.invokeExact(matrix_layout, side, howmny, select, n, s, lds, p, ldp, vl, ldvl, vr, ldvr, mm, m, work);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dtgevc_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dtgevc_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dtgevc_work(int matrix_layout, char side, char howmny, const int *select, int n, const double *s, int lds, const double *p, int ldp, double *vl, int ldvl, double *vr, int ldvr, int mm, int *m, double *work)
     * }
     */
    public static FunctionDescriptor LAPACKE_dtgevc_work$descriptor() {
        return LAPACKE_dtgevc_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dtgevc_work(int matrix_layout, char side, char howmny, const int *select, int n, const double *s, int lds, const double *p, int ldp, double *vl, int ldvl, double *vr, int ldvr, int mm, int *m, double *work)
     * }
     */
    public static MethodHandle LAPACKE_dtgevc_work$handle() {
        return LAPACKE_dtgevc_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dtgevc_work(int matrix_layout, char side, char howmny, const int *select, int n, const double *s, int lds, const double *p, int ldp, double *vl, int ldvl, double *vr, int ldvr, int mm, int *m, double *work)
     * }
     */
    public static MemorySegment LAPACKE_dtgevc_work$address() {
        return LAPACKE_dtgevc_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dtgevc_work(int matrix_layout, char side, char howmny, const int *select, int n, const double *s, int lds, const double *p, int ldp, double *vl, int ldvl, double *vr, int ldvr, int mm, int *m, double *work)
     * }
     */
    public static int LAPACKE_dtgevc_work(int matrix_layout, byte side, byte howmny, MemorySegment select, int n, MemorySegment s, int lds, MemorySegment p, int ldp, MemorySegment vl, int ldvl, MemorySegment vr, int ldvr, int mm, MemorySegment m, MemorySegment work) {
        var mh$ = LAPACKE_dtgevc_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dtgevc_work", matrix_layout, side, howmny, select, n, s, lds, p, ldp, vl, ldvl, vr, ldvr, mm, m, work);
            }
            return (int)mh$.invokeExact(matrix_layout, side, howmny, select, n, s, lds, p, ldp, vl, ldvl, vr, ldvr, mm, m, work);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ctgevc_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_ctgevc_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ctgevc_work(int matrix_layout, char side, char howmny, const int *select, int n, const _Complex float *s, int lds, const _Complex float *p, int ldp, _Complex float *vl, int ldvl, _Complex float *vr, int ldvr, int mm, int *m, _Complex float *work, float *rwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_ctgevc_work$descriptor() {
        return LAPACKE_ctgevc_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ctgevc_work(int matrix_layout, char side, char howmny, const int *select, int n, const _Complex float *s, int lds, const _Complex float *p, int ldp, _Complex float *vl, int ldvl, _Complex float *vr, int ldvr, int mm, int *m, _Complex float *work, float *rwork)
     * }
     */
    public static MethodHandle LAPACKE_ctgevc_work$handle() {
        return LAPACKE_ctgevc_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ctgevc_work(int matrix_layout, char side, char howmny, const int *select, int n, const _Complex float *s, int lds, const _Complex float *p, int ldp, _Complex float *vl, int ldvl, _Complex float *vr, int ldvr, int mm, int *m, _Complex float *work, float *rwork)
     * }
     */
    public static MemorySegment LAPACKE_ctgevc_work$address() {
        return LAPACKE_ctgevc_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ctgevc_work(int matrix_layout, char side, char howmny, const int *select, int n, const _Complex float *s, int lds, const _Complex float *p, int ldp, _Complex float *vl, int ldvl, _Complex float *vr, int ldvr, int mm, int *m, _Complex float *work, float *rwork)
     * }
     */
    public static int LAPACKE_ctgevc_work(int matrix_layout, byte side, byte howmny, MemorySegment select, int n, MemorySegment s, int lds, MemorySegment p, int ldp, MemorySegment vl, int ldvl, MemorySegment vr, int ldvr, int mm, MemorySegment m, MemorySegment work, MemorySegment rwork) {
        var mh$ = LAPACKE_ctgevc_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ctgevc_work", matrix_layout, side, howmny, select, n, s, lds, p, ldp, vl, ldvl, vr, ldvr, mm, m, work, rwork);
            }
            return (int)mh$.invokeExact(matrix_layout, side, howmny, select, n, s, lds, p, ldp, vl, ldvl, vr, ldvr, mm, m, work, rwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ztgevc_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_ztgevc_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ztgevc_work(int matrix_layout, char side, char howmny, const int *select, int n, const _Complex double *s, int lds, const _Complex double *p, int ldp, _Complex double *vl, int ldvl, _Complex double *vr, int ldvr, int mm, int *m, _Complex double *work, double *rwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_ztgevc_work$descriptor() {
        return LAPACKE_ztgevc_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ztgevc_work(int matrix_layout, char side, char howmny, const int *select, int n, const _Complex double *s, int lds, const _Complex double *p, int ldp, _Complex double *vl, int ldvl, _Complex double *vr, int ldvr, int mm, int *m, _Complex double *work, double *rwork)
     * }
     */
    public static MethodHandle LAPACKE_ztgevc_work$handle() {
        return LAPACKE_ztgevc_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ztgevc_work(int matrix_layout, char side, char howmny, const int *select, int n, const _Complex double *s, int lds, const _Complex double *p, int ldp, _Complex double *vl, int ldvl, _Complex double *vr, int ldvr, int mm, int *m, _Complex double *work, double *rwork)
     * }
     */
    public static MemorySegment LAPACKE_ztgevc_work$address() {
        return LAPACKE_ztgevc_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ztgevc_work(int matrix_layout, char side, char howmny, const int *select, int n, const _Complex double *s, int lds, const _Complex double *p, int ldp, _Complex double *vl, int ldvl, _Complex double *vr, int ldvr, int mm, int *m, _Complex double *work, double *rwork)
     * }
     */
    public static int LAPACKE_ztgevc_work(int matrix_layout, byte side, byte howmny, MemorySegment select, int n, MemorySegment s, int lds, MemorySegment p, int ldp, MemorySegment vl, int ldvl, MemorySegment vr, int ldvr, int mm, MemorySegment m, MemorySegment work, MemorySegment rwork) {
        var mh$ = LAPACKE_ztgevc_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ztgevc_work", matrix_layout, side, howmny, select, n, s, lds, p, ldp, vl, ldvl, vr, ldvr, mm, m, work, rwork);
            }
            return (int)mh$.invokeExact(matrix_layout, side, howmny, select, n, s, lds, p, ldp, vl, ldvl, vr, ldvr, mm, m, work, rwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_stgexc_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_stgexc_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_stgexc_work(int matrix_layout, int wantq, int wantz, int n, float *a, int lda, float *b, int ldb, float *q, int ldq, float *z, int ldz, int *ifst, int *ilst, float *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_stgexc_work$descriptor() {
        return LAPACKE_stgexc_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_stgexc_work(int matrix_layout, int wantq, int wantz, int n, float *a, int lda, float *b, int ldb, float *q, int ldq, float *z, int ldz, int *ifst, int *ilst, float *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_stgexc_work$handle() {
        return LAPACKE_stgexc_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_stgexc_work(int matrix_layout, int wantq, int wantz, int n, float *a, int lda, float *b, int ldb, float *q, int ldq, float *z, int ldz, int *ifst, int *ilst, float *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_stgexc_work$address() {
        return LAPACKE_stgexc_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_stgexc_work(int matrix_layout, int wantq, int wantz, int n, float *a, int lda, float *b, int ldb, float *q, int ldq, float *z, int ldz, int *ifst, int *ilst, float *work, int lwork)
     * }
     */
    public static int LAPACKE_stgexc_work(int matrix_layout, int wantq, int wantz, int n, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment q, int ldq, MemorySegment z, int ldz, MemorySegment ifst, MemorySegment ilst, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_stgexc_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_stgexc_work", matrix_layout, wantq, wantz, n, a, lda, b, ldb, q, ldq, z, ldz, ifst, ilst, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, wantq, wantz, n, a, lda, b, ldb, q, ldq, z, ldz, ifst, ilst, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dtgexc_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dtgexc_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dtgexc_work(int matrix_layout, int wantq, int wantz, int n, double *a, int lda, double *b, int ldb, double *q, int ldq, double *z, int ldz, int *ifst, int *ilst, double *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_dtgexc_work$descriptor() {
        return LAPACKE_dtgexc_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dtgexc_work(int matrix_layout, int wantq, int wantz, int n, double *a, int lda, double *b, int ldb, double *q, int ldq, double *z, int ldz, int *ifst, int *ilst, double *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_dtgexc_work$handle() {
        return LAPACKE_dtgexc_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dtgexc_work(int matrix_layout, int wantq, int wantz, int n, double *a, int lda, double *b, int ldb, double *q, int ldq, double *z, int ldz, int *ifst, int *ilst, double *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_dtgexc_work$address() {
        return LAPACKE_dtgexc_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dtgexc_work(int matrix_layout, int wantq, int wantz, int n, double *a, int lda, double *b, int ldb, double *q, int ldq, double *z, int ldz, int *ifst, int *ilst, double *work, int lwork)
     * }
     */
    public static int LAPACKE_dtgexc_work(int matrix_layout, int wantq, int wantz, int n, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment q, int ldq, MemorySegment z, int ldz, MemorySegment ifst, MemorySegment ilst, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_dtgexc_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dtgexc_work", matrix_layout, wantq, wantz, n, a, lda, b, ldb, q, ldq, z, ldz, ifst, ilst, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, wantq, wantz, n, a, lda, b, ldb, q, ldq, z, ldz, ifst, ilst, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ctgexc_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_ctgexc_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ctgexc_work(int matrix_layout, int wantq, int wantz, int n, _Complex float *a, int lda, _Complex float *b, int ldb, _Complex float *q, int ldq, _Complex float *z, int ldz, int ifst, int ilst)
     * }
     */
    public static FunctionDescriptor LAPACKE_ctgexc_work$descriptor() {
        return LAPACKE_ctgexc_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ctgexc_work(int matrix_layout, int wantq, int wantz, int n, _Complex float *a, int lda, _Complex float *b, int ldb, _Complex float *q, int ldq, _Complex float *z, int ldz, int ifst, int ilst)
     * }
     */
    public static MethodHandle LAPACKE_ctgexc_work$handle() {
        return LAPACKE_ctgexc_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ctgexc_work(int matrix_layout, int wantq, int wantz, int n, _Complex float *a, int lda, _Complex float *b, int ldb, _Complex float *q, int ldq, _Complex float *z, int ldz, int ifst, int ilst)
     * }
     */
    public static MemorySegment LAPACKE_ctgexc_work$address() {
        return LAPACKE_ctgexc_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ctgexc_work(int matrix_layout, int wantq, int wantz, int n, _Complex float *a, int lda, _Complex float *b, int ldb, _Complex float *q, int ldq, _Complex float *z, int ldz, int ifst, int ilst)
     * }
     */
    public static int LAPACKE_ctgexc_work(int matrix_layout, int wantq, int wantz, int n, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment q, int ldq, MemorySegment z, int ldz, int ifst, int ilst) {
        var mh$ = LAPACKE_ctgexc_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ctgexc_work", matrix_layout, wantq, wantz, n, a, lda, b, ldb, q, ldq, z, ldz, ifst, ilst);
            }
            return (int)mh$.invokeExact(matrix_layout, wantq, wantz, n, a, lda, b, ldb, q, ldq, z, ldz, ifst, ilst);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ztgexc_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_ztgexc_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ztgexc_work(int matrix_layout, int wantq, int wantz, int n, _Complex double *a, int lda, _Complex double *b, int ldb, _Complex double *q, int ldq, _Complex double *z, int ldz, int ifst, int ilst)
     * }
     */
    public static FunctionDescriptor LAPACKE_ztgexc_work$descriptor() {
        return LAPACKE_ztgexc_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ztgexc_work(int matrix_layout, int wantq, int wantz, int n, _Complex double *a, int lda, _Complex double *b, int ldb, _Complex double *q, int ldq, _Complex double *z, int ldz, int ifst, int ilst)
     * }
     */
    public static MethodHandle LAPACKE_ztgexc_work$handle() {
        return LAPACKE_ztgexc_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ztgexc_work(int matrix_layout, int wantq, int wantz, int n, _Complex double *a, int lda, _Complex double *b, int ldb, _Complex double *q, int ldq, _Complex double *z, int ldz, int ifst, int ilst)
     * }
     */
    public static MemorySegment LAPACKE_ztgexc_work$address() {
        return LAPACKE_ztgexc_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ztgexc_work(int matrix_layout, int wantq, int wantz, int n, _Complex double *a, int lda, _Complex double *b, int ldb, _Complex double *q, int ldq, _Complex double *z, int ldz, int ifst, int ilst)
     * }
     */
    public static int LAPACKE_ztgexc_work(int matrix_layout, int wantq, int wantz, int n, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment q, int ldq, MemorySegment z, int ldz, int ifst, int ilst) {
        var mh$ = LAPACKE_ztgexc_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ztgexc_work", matrix_layout, wantq, wantz, n, a, lda, b, ldb, q, ldq, z, ldz, ifst, ilst);
            }
            return (int)mh$.invokeExact(matrix_layout, wantq, wantz, n, a, lda, b, ldb, q, ldq, z, ldz, ifst, ilst);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_stgsen_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_stgsen_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_stgsen_work(int matrix_layout, int ijob, int wantq, int wantz, const int *select, int n, float *a, int lda, float *b, int ldb, float *alphar, float *alphai, float *beta, float *q, int ldq, float *z, int ldz, int *m, float *pl, float *pr, float *dif, float *work, int lwork, int *iwork, int liwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_stgsen_work$descriptor() {
        return LAPACKE_stgsen_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_stgsen_work(int matrix_layout, int ijob, int wantq, int wantz, const int *select, int n, float *a, int lda, float *b, int ldb, float *alphar, float *alphai, float *beta, float *q, int ldq, float *z, int ldz, int *m, float *pl, float *pr, float *dif, float *work, int lwork, int *iwork, int liwork)
     * }
     */
    public static MethodHandle LAPACKE_stgsen_work$handle() {
        return LAPACKE_stgsen_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_stgsen_work(int matrix_layout, int ijob, int wantq, int wantz, const int *select, int n, float *a, int lda, float *b, int ldb, float *alphar, float *alphai, float *beta, float *q, int ldq, float *z, int ldz, int *m, float *pl, float *pr, float *dif, float *work, int lwork, int *iwork, int liwork)
     * }
     */
    public static MemorySegment LAPACKE_stgsen_work$address() {
        return LAPACKE_stgsen_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_stgsen_work(int matrix_layout, int ijob, int wantq, int wantz, const int *select, int n, float *a, int lda, float *b, int ldb, float *alphar, float *alphai, float *beta, float *q, int ldq, float *z, int ldz, int *m, float *pl, float *pr, float *dif, float *work, int lwork, int *iwork, int liwork)
     * }
     */
    public static int LAPACKE_stgsen_work(int matrix_layout, int ijob, int wantq, int wantz, MemorySegment select, int n, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment alphar, MemorySegment alphai, MemorySegment beta, MemorySegment q, int ldq, MemorySegment z, int ldz, MemorySegment m, MemorySegment pl, MemorySegment pr, MemorySegment dif, MemorySegment work, int lwork, MemorySegment iwork, int liwork) {
        var mh$ = LAPACKE_stgsen_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_stgsen_work", matrix_layout, ijob, wantq, wantz, select, n, a, lda, b, ldb, alphar, alphai, beta, q, ldq, z, ldz, m, pl, pr, dif, work, lwork, iwork, liwork);
            }
            return (int)mh$.invokeExact(matrix_layout, ijob, wantq, wantz, select, n, a, lda, b, ldb, alphar, alphai, beta, q, ldq, z, ldz, m, pl, pr, dif, work, lwork, iwork, liwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dtgsen_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dtgsen_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dtgsen_work(int matrix_layout, int ijob, int wantq, int wantz, const int *select, int n, double *a, int lda, double *b, int ldb, double *alphar, double *alphai, double *beta, double *q, int ldq, double *z, int ldz, int *m, double *pl, double *pr, double *dif, double *work, int lwork, int *iwork, int liwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_dtgsen_work$descriptor() {
        return LAPACKE_dtgsen_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dtgsen_work(int matrix_layout, int ijob, int wantq, int wantz, const int *select, int n, double *a, int lda, double *b, int ldb, double *alphar, double *alphai, double *beta, double *q, int ldq, double *z, int ldz, int *m, double *pl, double *pr, double *dif, double *work, int lwork, int *iwork, int liwork)
     * }
     */
    public static MethodHandle LAPACKE_dtgsen_work$handle() {
        return LAPACKE_dtgsen_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dtgsen_work(int matrix_layout, int ijob, int wantq, int wantz, const int *select, int n, double *a, int lda, double *b, int ldb, double *alphar, double *alphai, double *beta, double *q, int ldq, double *z, int ldz, int *m, double *pl, double *pr, double *dif, double *work, int lwork, int *iwork, int liwork)
     * }
     */
    public static MemorySegment LAPACKE_dtgsen_work$address() {
        return LAPACKE_dtgsen_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dtgsen_work(int matrix_layout, int ijob, int wantq, int wantz, const int *select, int n, double *a, int lda, double *b, int ldb, double *alphar, double *alphai, double *beta, double *q, int ldq, double *z, int ldz, int *m, double *pl, double *pr, double *dif, double *work, int lwork, int *iwork, int liwork)
     * }
     */
    public static int LAPACKE_dtgsen_work(int matrix_layout, int ijob, int wantq, int wantz, MemorySegment select, int n, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment alphar, MemorySegment alphai, MemorySegment beta, MemorySegment q, int ldq, MemorySegment z, int ldz, MemorySegment m, MemorySegment pl, MemorySegment pr, MemorySegment dif, MemorySegment work, int lwork, MemorySegment iwork, int liwork) {
        var mh$ = LAPACKE_dtgsen_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dtgsen_work", matrix_layout, ijob, wantq, wantz, select, n, a, lda, b, ldb, alphar, alphai, beta, q, ldq, z, ldz, m, pl, pr, dif, work, lwork, iwork, liwork);
            }
            return (int)mh$.invokeExact(matrix_layout, ijob, wantq, wantz, select, n, a, lda, b, ldb, alphar, alphai, beta, q, ldq, z, ldz, m, pl, pr, dif, work, lwork, iwork, liwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ctgsen_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_ctgsen_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ctgsen_work(int matrix_layout, int ijob, int wantq, int wantz, const int *select, int n, _Complex float *a, int lda, _Complex float *b, int ldb, _Complex float *alpha, _Complex float *beta, _Complex float *q, int ldq, _Complex float *z, int ldz, int *m, float *pl, float *pr, float *dif, _Complex float *work, int lwork, int *iwork, int liwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_ctgsen_work$descriptor() {
        return LAPACKE_ctgsen_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ctgsen_work(int matrix_layout, int ijob, int wantq, int wantz, const int *select, int n, _Complex float *a, int lda, _Complex float *b, int ldb, _Complex float *alpha, _Complex float *beta, _Complex float *q, int ldq, _Complex float *z, int ldz, int *m, float *pl, float *pr, float *dif, _Complex float *work, int lwork, int *iwork, int liwork)
     * }
     */
    public static MethodHandle LAPACKE_ctgsen_work$handle() {
        return LAPACKE_ctgsen_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ctgsen_work(int matrix_layout, int ijob, int wantq, int wantz, const int *select, int n, _Complex float *a, int lda, _Complex float *b, int ldb, _Complex float *alpha, _Complex float *beta, _Complex float *q, int ldq, _Complex float *z, int ldz, int *m, float *pl, float *pr, float *dif, _Complex float *work, int lwork, int *iwork, int liwork)
     * }
     */
    public static MemorySegment LAPACKE_ctgsen_work$address() {
        return LAPACKE_ctgsen_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ctgsen_work(int matrix_layout, int ijob, int wantq, int wantz, const int *select, int n, _Complex float *a, int lda, _Complex float *b, int ldb, _Complex float *alpha, _Complex float *beta, _Complex float *q, int ldq, _Complex float *z, int ldz, int *m, float *pl, float *pr, float *dif, _Complex float *work, int lwork, int *iwork, int liwork)
     * }
     */
    public static int LAPACKE_ctgsen_work(int matrix_layout, int ijob, int wantq, int wantz, MemorySegment select, int n, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment alpha, MemorySegment beta, MemorySegment q, int ldq, MemorySegment z, int ldz, MemorySegment m, MemorySegment pl, MemorySegment pr, MemorySegment dif, MemorySegment work, int lwork, MemorySegment iwork, int liwork) {
        var mh$ = LAPACKE_ctgsen_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ctgsen_work", matrix_layout, ijob, wantq, wantz, select, n, a, lda, b, ldb, alpha, beta, q, ldq, z, ldz, m, pl, pr, dif, work, lwork, iwork, liwork);
            }
            return (int)mh$.invokeExact(matrix_layout, ijob, wantq, wantz, select, n, a, lda, b, ldb, alpha, beta, q, ldq, z, ldz, m, pl, pr, dif, work, lwork, iwork, liwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ztgsen_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_ztgsen_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ztgsen_work(int matrix_layout, int ijob, int wantq, int wantz, const int *select, int n, _Complex double *a, int lda, _Complex double *b, int ldb, _Complex double *alpha, _Complex double *beta, _Complex double *q, int ldq, _Complex double *z, int ldz, int *m, double *pl, double *pr, double *dif, _Complex double *work, int lwork, int *iwork, int liwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_ztgsen_work$descriptor() {
        return LAPACKE_ztgsen_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ztgsen_work(int matrix_layout, int ijob, int wantq, int wantz, const int *select, int n, _Complex double *a, int lda, _Complex double *b, int ldb, _Complex double *alpha, _Complex double *beta, _Complex double *q, int ldq, _Complex double *z, int ldz, int *m, double *pl, double *pr, double *dif, _Complex double *work, int lwork, int *iwork, int liwork)
     * }
     */
    public static MethodHandle LAPACKE_ztgsen_work$handle() {
        return LAPACKE_ztgsen_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ztgsen_work(int matrix_layout, int ijob, int wantq, int wantz, const int *select, int n, _Complex double *a, int lda, _Complex double *b, int ldb, _Complex double *alpha, _Complex double *beta, _Complex double *q, int ldq, _Complex double *z, int ldz, int *m, double *pl, double *pr, double *dif, _Complex double *work, int lwork, int *iwork, int liwork)
     * }
     */
    public static MemorySegment LAPACKE_ztgsen_work$address() {
        return LAPACKE_ztgsen_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ztgsen_work(int matrix_layout, int ijob, int wantq, int wantz, const int *select, int n, _Complex double *a, int lda, _Complex double *b, int ldb, _Complex double *alpha, _Complex double *beta, _Complex double *q, int ldq, _Complex double *z, int ldz, int *m, double *pl, double *pr, double *dif, _Complex double *work, int lwork, int *iwork, int liwork)
     * }
     */
    public static int LAPACKE_ztgsen_work(int matrix_layout, int ijob, int wantq, int wantz, MemorySegment select, int n, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment alpha, MemorySegment beta, MemorySegment q, int ldq, MemorySegment z, int ldz, MemorySegment m, MemorySegment pl, MemorySegment pr, MemorySegment dif, MemorySegment work, int lwork, MemorySegment iwork, int liwork) {
        var mh$ = LAPACKE_ztgsen_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ztgsen_work", matrix_layout, ijob, wantq, wantz, select, n, a, lda, b, ldb, alpha, beta, q, ldq, z, ldz, m, pl, pr, dif, work, lwork, iwork, liwork);
            }
            return (int)mh$.invokeExact(matrix_layout, ijob, wantq, wantz, select, n, a, lda, b, ldb, alpha, beta, q, ldq, z, ldz, m, pl, pr, dif, work, lwork, iwork, liwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_stgsja_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_stgsja_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_stgsja_work(int matrix_layout, char jobu, char jobv, char jobq, int m, int p, int n, int k, int l, float *a, int lda, float *b, int ldb, float tola, float tolb, float *alpha, float *beta, float *u, int ldu, float *v, int ldv, float *q, int ldq, float *work, int *ncycle)
     * }
     */
    public static FunctionDescriptor LAPACKE_stgsja_work$descriptor() {
        return LAPACKE_stgsja_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_stgsja_work(int matrix_layout, char jobu, char jobv, char jobq, int m, int p, int n, int k, int l, float *a, int lda, float *b, int ldb, float tola, float tolb, float *alpha, float *beta, float *u, int ldu, float *v, int ldv, float *q, int ldq, float *work, int *ncycle)
     * }
     */
    public static MethodHandle LAPACKE_stgsja_work$handle() {
        return LAPACKE_stgsja_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_stgsja_work(int matrix_layout, char jobu, char jobv, char jobq, int m, int p, int n, int k, int l, float *a, int lda, float *b, int ldb, float tola, float tolb, float *alpha, float *beta, float *u, int ldu, float *v, int ldv, float *q, int ldq, float *work, int *ncycle)
     * }
     */
    public static MemorySegment LAPACKE_stgsja_work$address() {
        return LAPACKE_stgsja_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_stgsja_work(int matrix_layout, char jobu, char jobv, char jobq, int m, int p, int n, int k, int l, float *a, int lda, float *b, int ldb, float tola, float tolb, float *alpha, float *beta, float *u, int ldu, float *v, int ldv, float *q, int ldq, float *work, int *ncycle)
     * }
     */
    public static int LAPACKE_stgsja_work(int matrix_layout, byte jobu, byte jobv, byte jobq, int m, int p, int n, int k, int l, MemorySegment a, int lda, MemorySegment b, int ldb, float tola, float tolb, MemorySegment alpha, MemorySegment beta, MemorySegment u, int ldu, MemorySegment v, int ldv, MemorySegment q, int ldq, MemorySegment work, MemorySegment ncycle) {
        var mh$ = LAPACKE_stgsja_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_stgsja_work", matrix_layout, jobu, jobv, jobq, m, p, n, k, l, a, lda, b, ldb, tola, tolb, alpha, beta, u, ldu, v, ldv, q, ldq, work, ncycle);
            }
            return (int)mh$.invokeExact(matrix_layout, jobu, jobv, jobq, m, p, n, k, l, a, lda, b, ldb, tola, tolb, alpha, beta, u, ldu, v, ldv, q, ldq, work, ncycle);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dtgsja_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dtgsja_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dtgsja_work(int matrix_layout, char jobu, char jobv, char jobq, int m, int p, int n, int k, int l, double *a, int lda, double *b, int ldb, double tola, double tolb, double *alpha, double *beta, double *u, int ldu, double *v, int ldv, double *q, int ldq, double *work, int *ncycle)
     * }
     */
    public static FunctionDescriptor LAPACKE_dtgsja_work$descriptor() {
        return LAPACKE_dtgsja_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dtgsja_work(int matrix_layout, char jobu, char jobv, char jobq, int m, int p, int n, int k, int l, double *a, int lda, double *b, int ldb, double tola, double tolb, double *alpha, double *beta, double *u, int ldu, double *v, int ldv, double *q, int ldq, double *work, int *ncycle)
     * }
     */
    public static MethodHandle LAPACKE_dtgsja_work$handle() {
        return LAPACKE_dtgsja_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dtgsja_work(int matrix_layout, char jobu, char jobv, char jobq, int m, int p, int n, int k, int l, double *a, int lda, double *b, int ldb, double tola, double tolb, double *alpha, double *beta, double *u, int ldu, double *v, int ldv, double *q, int ldq, double *work, int *ncycle)
     * }
     */
    public static MemorySegment LAPACKE_dtgsja_work$address() {
        return LAPACKE_dtgsja_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dtgsja_work(int matrix_layout, char jobu, char jobv, char jobq, int m, int p, int n, int k, int l, double *a, int lda, double *b, int ldb, double tola, double tolb, double *alpha, double *beta, double *u, int ldu, double *v, int ldv, double *q, int ldq, double *work, int *ncycle)
     * }
     */
    public static int LAPACKE_dtgsja_work(int matrix_layout, byte jobu, byte jobv, byte jobq, int m, int p, int n, int k, int l, MemorySegment a, int lda, MemorySegment b, int ldb, double tola, double tolb, MemorySegment alpha, MemorySegment beta, MemorySegment u, int ldu, MemorySegment v, int ldv, MemorySegment q, int ldq, MemorySegment work, MemorySegment ncycle) {
        var mh$ = LAPACKE_dtgsja_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dtgsja_work", matrix_layout, jobu, jobv, jobq, m, p, n, k, l, a, lda, b, ldb, tola, tolb, alpha, beta, u, ldu, v, ldv, q, ldq, work, ncycle);
            }
            return (int)mh$.invokeExact(matrix_layout, jobu, jobv, jobq, m, p, n, k, l, a, lda, b, ldb, tola, tolb, alpha, beta, u, ldu, v, ldv, q, ldq, work, ncycle);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ctgsja_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_ctgsja_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ctgsja_work(int matrix_layout, char jobu, char jobv, char jobq, int m, int p, int n, int k, int l, _Complex float *a, int lda, _Complex float *b, int ldb, float tola, float tolb, float *alpha, float *beta, _Complex float *u, int ldu, _Complex float *v, int ldv, _Complex float *q, int ldq, _Complex float *work, int *ncycle)
     * }
     */
    public static FunctionDescriptor LAPACKE_ctgsja_work$descriptor() {
        return LAPACKE_ctgsja_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ctgsja_work(int matrix_layout, char jobu, char jobv, char jobq, int m, int p, int n, int k, int l, _Complex float *a, int lda, _Complex float *b, int ldb, float tola, float tolb, float *alpha, float *beta, _Complex float *u, int ldu, _Complex float *v, int ldv, _Complex float *q, int ldq, _Complex float *work, int *ncycle)
     * }
     */
    public static MethodHandle LAPACKE_ctgsja_work$handle() {
        return LAPACKE_ctgsja_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ctgsja_work(int matrix_layout, char jobu, char jobv, char jobq, int m, int p, int n, int k, int l, _Complex float *a, int lda, _Complex float *b, int ldb, float tola, float tolb, float *alpha, float *beta, _Complex float *u, int ldu, _Complex float *v, int ldv, _Complex float *q, int ldq, _Complex float *work, int *ncycle)
     * }
     */
    public static MemorySegment LAPACKE_ctgsja_work$address() {
        return LAPACKE_ctgsja_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ctgsja_work(int matrix_layout, char jobu, char jobv, char jobq, int m, int p, int n, int k, int l, _Complex float *a, int lda, _Complex float *b, int ldb, float tola, float tolb, float *alpha, float *beta, _Complex float *u, int ldu, _Complex float *v, int ldv, _Complex float *q, int ldq, _Complex float *work, int *ncycle)
     * }
     */
    public static int LAPACKE_ctgsja_work(int matrix_layout, byte jobu, byte jobv, byte jobq, int m, int p, int n, int k, int l, MemorySegment a, int lda, MemorySegment b, int ldb, float tola, float tolb, MemorySegment alpha, MemorySegment beta, MemorySegment u, int ldu, MemorySegment v, int ldv, MemorySegment q, int ldq, MemorySegment work, MemorySegment ncycle) {
        var mh$ = LAPACKE_ctgsja_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ctgsja_work", matrix_layout, jobu, jobv, jobq, m, p, n, k, l, a, lda, b, ldb, tola, tolb, alpha, beta, u, ldu, v, ldv, q, ldq, work, ncycle);
            }
            return (int)mh$.invokeExact(matrix_layout, jobu, jobv, jobq, m, p, n, k, l, a, lda, b, ldb, tola, tolb, alpha, beta, u, ldu, v, ldv, q, ldq, work, ncycle);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ztgsja_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_ztgsja_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ztgsja_work(int matrix_layout, char jobu, char jobv, char jobq, int m, int p, int n, int k, int l, _Complex double *a, int lda, _Complex double *b, int ldb, double tola, double tolb, double *alpha, double *beta, _Complex double *u, int ldu, _Complex double *v, int ldv, _Complex double *q, int ldq, _Complex double *work, int *ncycle)
     * }
     */
    public static FunctionDescriptor LAPACKE_ztgsja_work$descriptor() {
        return LAPACKE_ztgsja_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ztgsja_work(int matrix_layout, char jobu, char jobv, char jobq, int m, int p, int n, int k, int l, _Complex double *a, int lda, _Complex double *b, int ldb, double tola, double tolb, double *alpha, double *beta, _Complex double *u, int ldu, _Complex double *v, int ldv, _Complex double *q, int ldq, _Complex double *work, int *ncycle)
     * }
     */
    public static MethodHandle LAPACKE_ztgsja_work$handle() {
        return LAPACKE_ztgsja_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ztgsja_work(int matrix_layout, char jobu, char jobv, char jobq, int m, int p, int n, int k, int l, _Complex double *a, int lda, _Complex double *b, int ldb, double tola, double tolb, double *alpha, double *beta, _Complex double *u, int ldu, _Complex double *v, int ldv, _Complex double *q, int ldq, _Complex double *work, int *ncycle)
     * }
     */
    public static MemorySegment LAPACKE_ztgsja_work$address() {
        return LAPACKE_ztgsja_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ztgsja_work(int matrix_layout, char jobu, char jobv, char jobq, int m, int p, int n, int k, int l, _Complex double *a, int lda, _Complex double *b, int ldb, double tola, double tolb, double *alpha, double *beta, _Complex double *u, int ldu, _Complex double *v, int ldv, _Complex double *q, int ldq, _Complex double *work, int *ncycle)
     * }
     */
    public static int LAPACKE_ztgsja_work(int matrix_layout, byte jobu, byte jobv, byte jobq, int m, int p, int n, int k, int l, MemorySegment a, int lda, MemorySegment b, int ldb, double tola, double tolb, MemorySegment alpha, MemorySegment beta, MemorySegment u, int ldu, MemorySegment v, int ldv, MemorySegment q, int ldq, MemorySegment work, MemorySegment ncycle) {
        var mh$ = LAPACKE_ztgsja_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ztgsja_work", matrix_layout, jobu, jobv, jobq, m, p, n, k, l, a, lda, b, ldb, tola, tolb, alpha, beta, u, ldu, v, ldv, q, ldq, work, ncycle);
            }
            return (int)mh$.invokeExact(matrix_layout, jobu, jobv, jobq, m, p, n, k, l, a, lda, b, ldb, tola, tolb, alpha, beta, u, ldu, v, ldv, q, ldq, work, ncycle);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_stgsna_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_stgsna_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_stgsna_work(int matrix_layout, char job, char howmny, const int *select, int n, const float *a, int lda, const float *b, int ldb, const float *vl, int ldvl, const float *vr, int ldvr, float *s, float *dif, int mm, int *m, float *work, int lwork, int *iwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_stgsna_work$descriptor() {
        return LAPACKE_stgsna_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_stgsna_work(int matrix_layout, char job, char howmny, const int *select, int n, const float *a, int lda, const float *b, int ldb, const float *vl, int ldvl, const float *vr, int ldvr, float *s, float *dif, int mm, int *m, float *work, int lwork, int *iwork)
     * }
     */
    public static MethodHandle LAPACKE_stgsna_work$handle() {
        return LAPACKE_stgsna_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_stgsna_work(int matrix_layout, char job, char howmny, const int *select, int n, const float *a, int lda, const float *b, int ldb, const float *vl, int ldvl, const float *vr, int ldvr, float *s, float *dif, int mm, int *m, float *work, int lwork, int *iwork)
     * }
     */
    public static MemorySegment LAPACKE_stgsna_work$address() {
        return LAPACKE_stgsna_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_stgsna_work(int matrix_layout, char job, char howmny, const int *select, int n, const float *a, int lda, const float *b, int ldb, const float *vl, int ldvl, const float *vr, int ldvr, float *s, float *dif, int mm, int *m, float *work, int lwork, int *iwork)
     * }
     */
    public static int LAPACKE_stgsna_work(int matrix_layout, byte job, byte howmny, MemorySegment select, int n, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment vl, int ldvl, MemorySegment vr, int ldvr, MemorySegment s, MemorySegment dif, int mm, MemorySegment m, MemorySegment work, int lwork, MemorySegment iwork) {
        var mh$ = LAPACKE_stgsna_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_stgsna_work", matrix_layout, job, howmny, select, n, a, lda, b, ldb, vl, ldvl, vr, ldvr, s, dif, mm, m, work, lwork, iwork);
            }
            return (int)mh$.invokeExact(matrix_layout, job, howmny, select, n, a, lda, b, ldb, vl, ldvl, vr, ldvr, s, dif, mm, m, work, lwork, iwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dtgsna_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dtgsna_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dtgsna_work(int matrix_layout, char job, char howmny, const int *select, int n, const double *a, int lda, const double *b, int ldb, const double *vl, int ldvl, const double *vr, int ldvr, double *s, double *dif, int mm, int *m, double *work, int lwork, int *iwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_dtgsna_work$descriptor() {
        return LAPACKE_dtgsna_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dtgsna_work(int matrix_layout, char job, char howmny, const int *select, int n, const double *a, int lda, const double *b, int ldb, const double *vl, int ldvl, const double *vr, int ldvr, double *s, double *dif, int mm, int *m, double *work, int lwork, int *iwork)
     * }
     */
    public static MethodHandle LAPACKE_dtgsna_work$handle() {
        return LAPACKE_dtgsna_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dtgsna_work(int matrix_layout, char job, char howmny, const int *select, int n, const double *a, int lda, const double *b, int ldb, const double *vl, int ldvl, const double *vr, int ldvr, double *s, double *dif, int mm, int *m, double *work, int lwork, int *iwork)
     * }
     */
    public static MemorySegment LAPACKE_dtgsna_work$address() {
        return LAPACKE_dtgsna_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dtgsna_work(int matrix_layout, char job, char howmny, const int *select, int n, const double *a, int lda, const double *b, int ldb, const double *vl, int ldvl, const double *vr, int ldvr, double *s, double *dif, int mm, int *m, double *work, int lwork, int *iwork)
     * }
     */
    public static int LAPACKE_dtgsna_work(int matrix_layout, byte job, byte howmny, MemorySegment select, int n, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment vl, int ldvl, MemorySegment vr, int ldvr, MemorySegment s, MemorySegment dif, int mm, MemorySegment m, MemorySegment work, int lwork, MemorySegment iwork) {
        var mh$ = LAPACKE_dtgsna_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dtgsna_work", matrix_layout, job, howmny, select, n, a, lda, b, ldb, vl, ldvl, vr, ldvr, s, dif, mm, m, work, lwork, iwork);
            }
            return (int)mh$.invokeExact(matrix_layout, job, howmny, select, n, a, lda, b, ldb, vl, ldvl, vr, ldvr, s, dif, mm, m, work, lwork, iwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ctgsna_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_ctgsna_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ctgsna_work(int matrix_layout, char job, char howmny, const int *select, int n, const _Complex float *a, int lda, const _Complex float *b, int ldb, const _Complex float *vl, int ldvl, const _Complex float *vr, int ldvr, float *s, float *dif, int mm, int *m, _Complex float *work, int lwork, int *iwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_ctgsna_work$descriptor() {
        return LAPACKE_ctgsna_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ctgsna_work(int matrix_layout, char job, char howmny, const int *select, int n, const _Complex float *a, int lda, const _Complex float *b, int ldb, const _Complex float *vl, int ldvl, const _Complex float *vr, int ldvr, float *s, float *dif, int mm, int *m, _Complex float *work, int lwork, int *iwork)
     * }
     */
    public static MethodHandle LAPACKE_ctgsna_work$handle() {
        return LAPACKE_ctgsna_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ctgsna_work(int matrix_layout, char job, char howmny, const int *select, int n, const _Complex float *a, int lda, const _Complex float *b, int ldb, const _Complex float *vl, int ldvl, const _Complex float *vr, int ldvr, float *s, float *dif, int mm, int *m, _Complex float *work, int lwork, int *iwork)
     * }
     */
    public static MemorySegment LAPACKE_ctgsna_work$address() {
        return LAPACKE_ctgsna_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ctgsna_work(int matrix_layout, char job, char howmny, const int *select, int n, const _Complex float *a, int lda, const _Complex float *b, int ldb, const _Complex float *vl, int ldvl, const _Complex float *vr, int ldvr, float *s, float *dif, int mm, int *m, _Complex float *work, int lwork, int *iwork)
     * }
     */
    public static int LAPACKE_ctgsna_work(int matrix_layout, byte job, byte howmny, MemorySegment select, int n, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment vl, int ldvl, MemorySegment vr, int ldvr, MemorySegment s, MemorySegment dif, int mm, MemorySegment m, MemorySegment work, int lwork, MemorySegment iwork) {
        var mh$ = LAPACKE_ctgsna_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ctgsna_work", matrix_layout, job, howmny, select, n, a, lda, b, ldb, vl, ldvl, vr, ldvr, s, dif, mm, m, work, lwork, iwork);
            }
            return (int)mh$.invokeExact(matrix_layout, job, howmny, select, n, a, lda, b, ldb, vl, ldvl, vr, ldvr, s, dif, mm, m, work, lwork, iwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ztgsna_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_ztgsna_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ztgsna_work(int matrix_layout, char job, char howmny, const int *select, int n, const _Complex double *a, int lda, const _Complex double *b, int ldb, const _Complex double *vl, int ldvl, const _Complex double *vr, int ldvr, double *s, double *dif, int mm, int *m, _Complex double *work, int lwork, int *iwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_ztgsna_work$descriptor() {
        return LAPACKE_ztgsna_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ztgsna_work(int matrix_layout, char job, char howmny, const int *select, int n, const _Complex double *a, int lda, const _Complex double *b, int ldb, const _Complex double *vl, int ldvl, const _Complex double *vr, int ldvr, double *s, double *dif, int mm, int *m, _Complex double *work, int lwork, int *iwork)
     * }
     */
    public static MethodHandle LAPACKE_ztgsna_work$handle() {
        return LAPACKE_ztgsna_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ztgsna_work(int matrix_layout, char job, char howmny, const int *select, int n, const _Complex double *a, int lda, const _Complex double *b, int ldb, const _Complex double *vl, int ldvl, const _Complex double *vr, int ldvr, double *s, double *dif, int mm, int *m, _Complex double *work, int lwork, int *iwork)
     * }
     */
    public static MemorySegment LAPACKE_ztgsna_work$address() {
        return LAPACKE_ztgsna_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ztgsna_work(int matrix_layout, char job, char howmny, const int *select, int n, const _Complex double *a, int lda, const _Complex double *b, int ldb, const _Complex double *vl, int ldvl, const _Complex double *vr, int ldvr, double *s, double *dif, int mm, int *m, _Complex double *work, int lwork, int *iwork)
     * }
     */
    public static int LAPACKE_ztgsna_work(int matrix_layout, byte job, byte howmny, MemorySegment select, int n, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment vl, int ldvl, MemorySegment vr, int ldvr, MemorySegment s, MemorySegment dif, int mm, MemorySegment m, MemorySegment work, int lwork, MemorySegment iwork) {
        var mh$ = LAPACKE_ztgsna_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ztgsna_work", matrix_layout, job, howmny, select, n, a, lda, b, ldb, vl, ldvl, vr, ldvr, s, dif, mm, m, work, lwork, iwork);
            }
            return (int)mh$.invokeExact(matrix_layout, job, howmny, select, n, a, lda, b, ldb, vl, ldvl, vr, ldvr, s, dif, mm, m, work, lwork, iwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_stgsyl_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_stgsyl_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_stgsyl_work(int matrix_layout, char trans, int ijob, int m, int n, const float *a, int lda, const float *b, int ldb, float *c, int ldc, const float *d, int ldd, const float *e, int lde, float *f, int ldf, float *scale, float *dif, float *work, int lwork, int *iwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_stgsyl_work$descriptor() {
        return LAPACKE_stgsyl_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_stgsyl_work(int matrix_layout, char trans, int ijob, int m, int n, const float *a, int lda, const float *b, int ldb, float *c, int ldc, const float *d, int ldd, const float *e, int lde, float *f, int ldf, float *scale, float *dif, float *work, int lwork, int *iwork)
     * }
     */
    public static MethodHandle LAPACKE_stgsyl_work$handle() {
        return LAPACKE_stgsyl_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_stgsyl_work(int matrix_layout, char trans, int ijob, int m, int n, const float *a, int lda, const float *b, int ldb, float *c, int ldc, const float *d, int ldd, const float *e, int lde, float *f, int ldf, float *scale, float *dif, float *work, int lwork, int *iwork)
     * }
     */
    public static MemorySegment LAPACKE_stgsyl_work$address() {
        return LAPACKE_stgsyl_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_stgsyl_work(int matrix_layout, char trans, int ijob, int m, int n, const float *a, int lda, const float *b, int ldb, float *c, int ldc, const float *d, int ldd, const float *e, int lde, float *f, int ldf, float *scale, float *dif, float *work, int lwork, int *iwork)
     * }
     */
    public static int LAPACKE_stgsyl_work(int matrix_layout, byte trans, int ijob, int m, int n, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment c, int ldc, MemorySegment d, int ldd, MemorySegment e, int lde, MemorySegment f, int ldf, MemorySegment scale, MemorySegment dif, MemorySegment work, int lwork, MemorySegment iwork) {
        var mh$ = LAPACKE_stgsyl_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_stgsyl_work", matrix_layout, trans, ijob, m, n, a, lda, b, ldb, c, ldc, d, ldd, e, lde, f, ldf, scale, dif, work, lwork, iwork);
            }
            return (int)mh$.invokeExact(matrix_layout, trans, ijob, m, n, a, lda, b, ldb, c, ldc, d, ldd, e, lde, f, ldf, scale, dif, work, lwork, iwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dtgsyl_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dtgsyl_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dtgsyl_work(int matrix_layout, char trans, int ijob, int m, int n, const double *a, int lda, const double *b, int ldb, double *c, int ldc, const double *d, int ldd, const double *e, int lde, double *f, int ldf, double *scale, double *dif, double *work, int lwork, int *iwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_dtgsyl_work$descriptor() {
        return LAPACKE_dtgsyl_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dtgsyl_work(int matrix_layout, char trans, int ijob, int m, int n, const double *a, int lda, const double *b, int ldb, double *c, int ldc, const double *d, int ldd, const double *e, int lde, double *f, int ldf, double *scale, double *dif, double *work, int lwork, int *iwork)
     * }
     */
    public static MethodHandle LAPACKE_dtgsyl_work$handle() {
        return LAPACKE_dtgsyl_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dtgsyl_work(int matrix_layout, char trans, int ijob, int m, int n, const double *a, int lda, const double *b, int ldb, double *c, int ldc, const double *d, int ldd, const double *e, int lde, double *f, int ldf, double *scale, double *dif, double *work, int lwork, int *iwork)
     * }
     */
    public static MemorySegment LAPACKE_dtgsyl_work$address() {
        return LAPACKE_dtgsyl_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dtgsyl_work(int matrix_layout, char trans, int ijob, int m, int n, const double *a, int lda, const double *b, int ldb, double *c, int ldc, const double *d, int ldd, const double *e, int lde, double *f, int ldf, double *scale, double *dif, double *work, int lwork, int *iwork)
     * }
     */
    public static int LAPACKE_dtgsyl_work(int matrix_layout, byte trans, int ijob, int m, int n, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment c, int ldc, MemorySegment d, int ldd, MemorySegment e, int lde, MemorySegment f, int ldf, MemorySegment scale, MemorySegment dif, MemorySegment work, int lwork, MemorySegment iwork) {
        var mh$ = LAPACKE_dtgsyl_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dtgsyl_work", matrix_layout, trans, ijob, m, n, a, lda, b, ldb, c, ldc, d, ldd, e, lde, f, ldf, scale, dif, work, lwork, iwork);
            }
            return (int)mh$.invokeExact(matrix_layout, trans, ijob, m, n, a, lda, b, ldb, c, ldc, d, ldd, e, lde, f, ldf, scale, dif, work, lwork, iwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ctgsyl_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_ctgsyl_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ctgsyl_work(int matrix_layout, char trans, int ijob, int m, int n, const _Complex float *a, int lda, const _Complex float *b, int ldb, _Complex float *c, int ldc, const _Complex float *d, int ldd, const _Complex float *e, int lde, _Complex float *f, int ldf, float *scale, float *dif, _Complex float *work, int lwork, int *iwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_ctgsyl_work$descriptor() {
        return LAPACKE_ctgsyl_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ctgsyl_work(int matrix_layout, char trans, int ijob, int m, int n, const _Complex float *a, int lda, const _Complex float *b, int ldb, _Complex float *c, int ldc, const _Complex float *d, int ldd, const _Complex float *e, int lde, _Complex float *f, int ldf, float *scale, float *dif, _Complex float *work, int lwork, int *iwork)
     * }
     */
    public static MethodHandle LAPACKE_ctgsyl_work$handle() {
        return LAPACKE_ctgsyl_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ctgsyl_work(int matrix_layout, char trans, int ijob, int m, int n, const _Complex float *a, int lda, const _Complex float *b, int ldb, _Complex float *c, int ldc, const _Complex float *d, int ldd, const _Complex float *e, int lde, _Complex float *f, int ldf, float *scale, float *dif, _Complex float *work, int lwork, int *iwork)
     * }
     */
    public static MemorySegment LAPACKE_ctgsyl_work$address() {
        return LAPACKE_ctgsyl_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ctgsyl_work(int matrix_layout, char trans, int ijob, int m, int n, const _Complex float *a, int lda, const _Complex float *b, int ldb, _Complex float *c, int ldc, const _Complex float *d, int ldd, const _Complex float *e, int lde, _Complex float *f, int ldf, float *scale, float *dif, _Complex float *work, int lwork, int *iwork)
     * }
     */
    public static int LAPACKE_ctgsyl_work(int matrix_layout, byte trans, int ijob, int m, int n, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment c, int ldc, MemorySegment d, int ldd, MemorySegment e, int lde, MemorySegment f, int ldf, MemorySegment scale, MemorySegment dif, MemorySegment work, int lwork, MemorySegment iwork) {
        var mh$ = LAPACKE_ctgsyl_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ctgsyl_work", matrix_layout, trans, ijob, m, n, a, lda, b, ldb, c, ldc, d, ldd, e, lde, f, ldf, scale, dif, work, lwork, iwork);
            }
            return (int)mh$.invokeExact(matrix_layout, trans, ijob, m, n, a, lda, b, ldb, c, ldc, d, ldd, e, lde, f, ldf, scale, dif, work, lwork, iwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ztgsyl_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_ztgsyl_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ztgsyl_work(int matrix_layout, char trans, int ijob, int m, int n, const _Complex double *a, int lda, const _Complex double *b, int ldb, _Complex double *c, int ldc, const _Complex double *d, int ldd, const _Complex double *e, int lde, _Complex double *f, int ldf, double *scale, double *dif, _Complex double *work, int lwork, int *iwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_ztgsyl_work$descriptor() {
        return LAPACKE_ztgsyl_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ztgsyl_work(int matrix_layout, char trans, int ijob, int m, int n, const _Complex double *a, int lda, const _Complex double *b, int ldb, _Complex double *c, int ldc, const _Complex double *d, int ldd, const _Complex double *e, int lde, _Complex double *f, int ldf, double *scale, double *dif, _Complex double *work, int lwork, int *iwork)
     * }
     */
    public static MethodHandle LAPACKE_ztgsyl_work$handle() {
        return LAPACKE_ztgsyl_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ztgsyl_work(int matrix_layout, char trans, int ijob, int m, int n, const _Complex double *a, int lda, const _Complex double *b, int ldb, _Complex double *c, int ldc, const _Complex double *d, int ldd, const _Complex double *e, int lde, _Complex double *f, int ldf, double *scale, double *dif, _Complex double *work, int lwork, int *iwork)
     * }
     */
    public static MemorySegment LAPACKE_ztgsyl_work$address() {
        return LAPACKE_ztgsyl_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ztgsyl_work(int matrix_layout, char trans, int ijob, int m, int n, const _Complex double *a, int lda, const _Complex double *b, int ldb, _Complex double *c, int ldc, const _Complex double *d, int ldd, const _Complex double *e, int lde, _Complex double *f, int ldf, double *scale, double *dif, _Complex double *work, int lwork, int *iwork)
     * }
     */
    public static int LAPACKE_ztgsyl_work(int matrix_layout, byte trans, int ijob, int m, int n, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment c, int ldc, MemorySegment d, int ldd, MemorySegment e, int lde, MemorySegment f, int ldf, MemorySegment scale, MemorySegment dif, MemorySegment work, int lwork, MemorySegment iwork) {
        var mh$ = LAPACKE_ztgsyl_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ztgsyl_work", matrix_layout, trans, ijob, m, n, a, lda, b, ldb, c, ldc, d, ldd, e, lde, f, ldf, scale, dif, work, lwork, iwork);
            }
            return (int)mh$.invokeExact(matrix_layout, trans, ijob, m, n, a, lda, b, ldb, c, ldc, d, ldd, e, lde, f, ldf, scale, dif, work, lwork, iwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_stpcon_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_stpcon_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_stpcon_work(int matrix_layout, char norm, char uplo, char diag, int n, const float *ap, float *rcond, float *work, int *iwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_stpcon_work$descriptor() {
        return LAPACKE_stpcon_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_stpcon_work(int matrix_layout, char norm, char uplo, char diag, int n, const float *ap, float *rcond, float *work, int *iwork)
     * }
     */
    public static MethodHandle LAPACKE_stpcon_work$handle() {
        return LAPACKE_stpcon_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_stpcon_work(int matrix_layout, char norm, char uplo, char diag, int n, const float *ap, float *rcond, float *work, int *iwork)
     * }
     */
    public static MemorySegment LAPACKE_stpcon_work$address() {
        return LAPACKE_stpcon_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_stpcon_work(int matrix_layout, char norm, char uplo, char diag, int n, const float *ap, float *rcond, float *work, int *iwork)
     * }
     */
    public static int LAPACKE_stpcon_work(int matrix_layout, byte norm, byte uplo, byte diag, int n, MemorySegment ap, MemorySegment rcond, MemorySegment work, MemorySegment iwork) {
        var mh$ = LAPACKE_stpcon_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_stpcon_work", matrix_layout, norm, uplo, diag, n, ap, rcond, work, iwork);
            }
            return (int)mh$.invokeExact(matrix_layout, norm, uplo, diag, n, ap, rcond, work, iwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dtpcon_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dtpcon_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dtpcon_work(int matrix_layout, char norm, char uplo, char diag, int n, const double *ap, double *rcond, double *work, int *iwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_dtpcon_work$descriptor() {
        return LAPACKE_dtpcon_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dtpcon_work(int matrix_layout, char norm, char uplo, char diag, int n, const double *ap, double *rcond, double *work, int *iwork)
     * }
     */
    public static MethodHandle LAPACKE_dtpcon_work$handle() {
        return LAPACKE_dtpcon_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dtpcon_work(int matrix_layout, char norm, char uplo, char diag, int n, const double *ap, double *rcond, double *work, int *iwork)
     * }
     */
    public static MemorySegment LAPACKE_dtpcon_work$address() {
        return LAPACKE_dtpcon_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dtpcon_work(int matrix_layout, char norm, char uplo, char diag, int n, const double *ap, double *rcond, double *work, int *iwork)
     * }
     */
    public static int LAPACKE_dtpcon_work(int matrix_layout, byte norm, byte uplo, byte diag, int n, MemorySegment ap, MemorySegment rcond, MemorySegment work, MemorySegment iwork) {
        var mh$ = LAPACKE_dtpcon_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dtpcon_work", matrix_layout, norm, uplo, diag, n, ap, rcond, work, iwork);
            }
            return (int)mh$.invokeExact(matrix_layout, norm, uplo, diag, n, ap, rcond, work, iwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ctpcon_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_ctpcon_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ctpcon_work(int matrix_layout, char norm, char uplo, char diag, int n, const _Complex float *ap, float *rcond, _Complex float *work, float *rwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_ctpcon_work$descriptor() {
        return LAPACKE_ctpcon_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ctpcon_work(int matrix_layout, char norm, char uplo, char diag, int n, const _Complex float *ap, float *rcond, _Complex float *work, float *rwork)
     * }
     */
    public static MethodHandle LAPACKE_ctpcon_work$handle() {
        return LAPACKE_ctpcon_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ctpcon_work(int matrix_layout, char norm, char uplo, char diag, int n, const _Complex float *ap, float *rcond, _Complex float *work, float *rwork)
     * }
     */
    public static MemorySegment LAPACKE_ctpcon_work$address() {
        return LAPACKE_ctpcon_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ctpcon_work(int matrix_layout, char norm, char uplo, char diag, int n, const _Complex float *ap, float *rcond, _Complex float *work, float *rwork)
     * }
     */
    public static int LAPACKE_ctpcon_work(int matrix_layout, byte norm, byte uplo, byte diag, int n, MemorySegment ap, MemorySegment rcond, MemorySegment work, MemorySegment rwork) {
        var mh$ = LAPACKE_ctpcon_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ctpcon_work", matrix_layout, norm, uplo, diag, n, ap, rcond, work, rwork);
            }
            return (int)mh$.invokeExact(matrix_layout, norm, uplo, diag, n, ap, rcond, work, rwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ztpcon_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_ztpcon_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ztpcon_work(int matrix_layout, char norm, char uplo, char diag, int n, const _Complex double *ap, double *rcond, _Complex double *work, double *rwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_ztpcon_work$descriptor() {
        return LAPACKE_ztpcon_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ztpcon_work(int matrix_layout, char norm, char uplo, char diag, int n, const _Complex double *ap, double *rcond, _Complex double *work, double *rwork)
     * }
     */
    public static MethodHandle LAPACKE_ztpcon_work$handle() {
        return LAPACKE_ztpcon_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ztpcon_work(int matrix_layout, char norm, char uplo, char diag, int n, const _Complex double *ap, double *rcond, _Complex double *work, double *rwork)
     * }
     */
    public static MemorySegment LAPACKE_ztpcon_work$address() {
        return LAPACKE_ztpcon_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ztpcon_work(int matrix_layout, char norm, char uplo, char diag, int n, const _Complex double *ap, double *rcond, _Complex double *work, double *rwork)
     * }
     */
    public static int LAPACKE_ztpcon_work(int matrix_layout, byte norm, byte uplo, byte diag, int n, MemorySegment ap, MemorySegment rcond, MemorySegment work, MemorySegment rwork) {
        var mh$ = LAPACKE_ztpcon_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ztpcon_work", matrix_layout, norm, uplo, diag, n, ap, rcond, work, rwork);
            }
            return (int)mh$.invokeExact(matrix_layout, norm, uplo, diag, n, ap, rcond, work, rwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_stprfs_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_stprfs_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_stprfs_work(int matrix_layout, char uplo, char trans, char diag, int n, int nrhs, const float *ap, const float *b, int ldb, const float *x, int ldx, float *ferr, float *berr, float *work, int *iwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_stprfs_work$descriptor() {
        return LAPACKE_stprfs_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_stprfs_work(int matrix_layout, char uplo, char trans, char diag, int n, int nrhs, const float *ap, const float *b, int ldb, const float *x, int ldx, float *ferr, float *berr, float *work, int *iwork)
     * }
     */
    public static MethodHandle LAPACKE_stprfs_work$handle() {
        return LAPACKE_stprfs_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_stprfs_work(int matrix_layout, char uplo, char trans, char diag, int n, int nrhs, const float *ap, const float *b, int ldb, const float *x, int ldx, float *ferr, float *berr, float *work, int *iwork)
     * }
     */
    public static MemorySegment LAPACKE_stprfs_work$address() {
        return LAPACKE_stprfs_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_stprfs_work(int matrix_layout, char uplo, char trans, char diag, int n, int nrhs, const float *ap, const float *b, int ldb, const float *x, int ldx, float *ferr, float *berr, float *work, int *iwork)
     * }
     */
    public static int LAPACKE_stprfs_work(int matrix_layout, byte uplo, byte trans, byte diag, int n, int nrhs, MemorySegment ap, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment ferr, MemorySegment berr, MemorySegment work, MemorySegment iwork) {
        var mh$ = LAPACKE_stprfs_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_stprfs_work", matrix_layout, uplo, trans, diag, n, nrhs, ap, b, ldb, x, ldx, ferr, berr, work, iwork);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, trans, diag, n, nrhs, ap, b, ldb, x, ldx, ferr, berr, work, iwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dtprfs_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dtprfs_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dtprfs_work(int matrix_layout, char uplo, char trans, char diag, int n, int nrhs, const double *ap, const double *b, int ldb, const double *x, int ldx, double *ferr, double *berr, double *work, int *iwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_dtprfs_work$descriptor() {
        return LAPACKE_dtprfs_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dtprfs_work(int matrix_layout, char uplo, char trans, char diag, int n, int nrhs, const double *ap, const double *b, int ldb, const double *x, int ldx, double *ferr, double *berr, double *work, int *iwork)
     * }
     */
    public static MethodHandle LAPACKE_dtprfs_work$handle() {
        return LAPACKE_dtprfs_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dtprfs_work(int matrix_layout, char uplo, char trans, char diag, int n, int nrhs, const double *ap, const double *b, int ldb, const double *x, int ldx, double *ferr, double *berr, double *work, int *iwork)
     * }
     */
    public static MemorySegment LAPACKE_dtprfs_work$address() {
        return LAPACKE_dtprfs_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dtprfs_work(int matrix_layout, char uplo, char trans, char diag, int n, int nrhs, const double *ap, const double *b, int ldb, const double *x, int ldx, double *ferr, double *berr, double *work, int *iwork)
     * }
     */
    public static int LAPACKE_dtprfs_work(int matrix_layout, byte uplo, byte trans, byte diag, int n, int nrhs, MemorySegment ap, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment ferr, MemorySegment berr, MemorySegment work, MemorySegment iwork) {
        var mh$ = LAPACKE_dtprfs_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dtprfs_work", matrix_layout, uplo, trans, diag, n, nrhs, ap, b, ldb, x, ldx, ferr, berr, work, iwork);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, trans, diag, n, nrhs, ap, b, ldb, x, ldx, ferr, berr, work, iwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ctprfs_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_ctprfs_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ctprfs_work(int matrix_layout, char uplo, char trans, char diag, int n, int nrhs, const _Complex float *ap, const _Complex float *b, int ldb, const _Complex float *x, int ldx, float *ferr, float *berr, _Complex float *work, float *rwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_ctprfs_work$descriptor() {
        return LAPACKE_ctprfs_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ctprfs_work(int matrix_layout, char uplo, char trans, char diag, int n, int nrhs, const _Complex float *ap, const _Complex float *b, int ldb, const _Complex float *x, int ldx, float *ferr, float *berr, _Complex float *work, float *rwork)
     * }
     */
    public static MethodHandle LAPACKE_ctprfs_work$handle() {
        return LAPACKE_ctprfs_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ctprfs_work(int matrix_layout, char uplo, char trans, char diag, int n, int nrhs, const _Complex float *ap, const _Complex float *b, int ldb, const _Complex float *x, int ldx, float *ferr, float *berr, _Complex float *work, float *rwork)
     * }
     */
    public static MemorySegment LAPACKE_ctprfs_work$address() {
        return LAPACKE_ctprfs_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ctprfs_work(int matrix_layout, char uplo, char trans, char diag, int n, int nrhs, const _Complex float *ap, const _Complex float *b, int ldb, const _Complex float *x, int ldx, float *ferr, float *berr, _Complex float *work, float *rwork)
     * }
     */
    public static int LAPACKE_ctprfs_work(int matrix_layout, byte uplo, byte trans, byte diag, int n, int nrhs, MemorySegment ap, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment ferr, MemorySegment berr, MemorySegment work, MemorySegment rwork) {
        var mh$ = LAPACKE_ctprfs_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ctprfs_work", matrix_layout, uplo, trans, diag, n, nrhs, ap, b, ldb, x, ldx, ferr, berr, work, rwork);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, trans, diag, n, nrhs, ap, b, ldb, x, ldx, ferr, berr, work, rwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ztprfs_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_ztprfs_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ztprfs_work(int matrix_layout, char uplo, char trans, char diag, int n, int nrhs, const _Complex double *ap, const _Complex double *b, int ldb, const _Complex double *x, int ldx, double *ferr, double *berr, _Complex double *work, double *rwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_ztprfs_work$descriptor() {
        return LAPACKE_ztprfs_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ztprfs_work(int matrix_layout, char uplo, char trans, char diag, int n, int nrhs, const _Complex double *ap, const _Complex double *b, int ldb, const _Complex double *x, int ldx, double *ferr, double *berr, _Complex double *work, double *rwork)
     * }
     */
    public static MethodHandle LAPACKE_ztprfs_work$handle() {
        return LAPACKE_ztprfs_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ztprfs_work(int matrix_layout, char uplo, char trans, char diag, int n, int nrhs, const _Complex double *ap, const _Complex double *b, int ldb, const _Complex double *x, int ldx, double *ferr, double *berr, _Complex double *work, double *rwork)
     * }
     */
    public static MemorySegment LAPACKE_ztprfs_work$address() {
        return LAPACKE_ztprfs_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ztprfs_work(int matrix_layout, char uplo, char trans, char diag, int n, int nrhs, const _Complex double *ap, const _Complex double *b, int ldb, const _Complex double *x, int ldx, double *ferr, double *berr, _Complex double *work, double *rwork)
     * }
     */
    public static int LAPACKE_ztprfs_work(int matrix_layout, byte uplo, byte trans, byte diag, int n, int nrhs, MemorySegment ap, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment ferr, MemorySegment berr, MemorySegment work, MemorySegment rwork) {
        var mh$ = LAPACKE_ztprfs_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ztprfs_work", matrix_layout, uplo, trans, diag, n, nrhs, ap, b, ldb, x, ldx, ferr, berr, work, rwork);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, trans, diag, n, nrhs, ap, b, ldb, x, ldx, ferr, berr, work, rwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_stptri_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_stptri_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_stptri_work(int matrix_layout, char uplo, char diag, int n, float *ap)
     * }
     */
    public static FunctionDescriptor LAPACKE_stptri_work$descriptor() {
        return LAPACKE_stptri_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_stptri_work(int matrix_layout, char uplo, char diag, int n, float *ap)
     * }
     */
    public static MethodHandle LAPACKE_stptri_work$handle() {
        return LAPACKE_stptri_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_stptri_work(int matrix_layout, char uplo, char diag, int n, float *ap)
     * }
     */
    public static MemorySegment LAPACKE_stptri_work$address() {
        return LAPACKE_stptri_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_stptri_work(int matrix_layout, char uplo, char diag, int n, float *ap)
     * }
     */
    public static int LAPACKE_stptri_work(int matrix_layout, byte uplo, byte diag, int n, MemorySegment ap) {
        var mh$ = LAPACKE_stptri_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_stptri_work", matrix_layout, uplo, diag, n, ap);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, diag, n, ap);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dtptri_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dtptri_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dtptri_work(int matrix_layout, char uplo, char diag, int n, double *ap)
     * }
     */
    public static FunctionDescriptor LAPACKE_dtptri_work$descriptor() {
        return LAPACKE_dtptri_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dtptri_work(int matrix_layout, char uplo, char diag, int n, double *ap)
     * }
     */
    public static MethodHandle LAPACKE_dtptri_work$handle() {
        return LAPACKE_dtptri_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dtptri_work(int matrix_layout, char uplo, char diag, int n, double *ap)
     * }
     */
    public static MemorySegment LAPACKE_dtptri_work$address() {
        return LAPACKE_dtptri_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dtptri_work(int matrix_layout, char uplo, char diag, int n, double *ap)
     * }
     */
    public static int LAPACKE_dtptri_work(int matrix_layout, byte uplo, byte diag, int n, MemorySegment ap) {
        var mh$ = LAPACKE_dtptri_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dtptri_work", matrix_layout, uplo, diag, n, ap);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, diag, n, ap);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ctptri_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_ctptri_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ctptri_work(int matrix_layout, char uplo, char diag, int n, _Complex float *ap)
     * }
     */
    public static FunctionDescriptor LAPACKE_ctptri_work$descriptor() {
        return LAPACKE_ctptri_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ctptri_work(int matrix_layout, char uplo, char diag, int n, _Complex float *ap)
     * }
     */
    public static MethodHandle LAPACKE_ctptri_work$handle() {
        return LAPACKE_ctptri_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ctptri_work(int matrix_layout, char uplo, char diag, int n, _Complex float *ap)
     * }
     */
    public static MemorySegment LAPACKE_ctptri_work$address() {
        return LAPACKE_ctptri_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ctptri_work(int matrix_layout, char uplo, char diag, int n, _Complex float *ap)
     * }
     */
    public static int LAPACKE_ctptri_work(int matrix_layout, byte uplo, byte diag, int n, MemorySegment ap) {
        var mh$ = LAPACKE_ctptri_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ctptri_work", matrix_layout, uplo, diag, n, ap);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, diag, n, ap);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ztptri_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_ztptri_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ztptri_work(int matrix_layout, char uplo, char diag, int n, _Complex double *ap)
     * }
     */
    public static FunctionDescriptor LAPACKE_ztptri_work$descriptor() {
        return LAPACKE_ztptri_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ztptri_work(int matrix_layout, char uplo, char diag, int n, _Complex double *ap)
     * }
     */
    public static MethodHandle LAPACKE_ztptri_work$handle() {
        return LAPACKE_ztptri_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ztptri_work(int matrix_layout, char uplo, char diag, int n, _Complex double *ap)
     * }
     */
    public static MemorySegment LAPACKE_ztptri_work$address() {
        return LAPACKE_ztptri_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ztptri_work(int matrix_layout, char uplo, char diag, int n, _Complex double *ap)
     * }
     */
    public static int LAPACKE_ztptri_work(int matrix_layout, byte uplo, byte diag, int n, MemorySegment ap) {
        var mh$ = LAPACKE_ztptri_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ztptri_work", matrix_layout, uplo, diag, n, ap);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, diag, n, ap);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_stptrs_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_stptrs_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_stptrs_work(int matrix_layout, char uplo, char trans, char diag, int n, int nrhs, const float *ap, float *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_stptrs_work$descriptor() {
        return LAPACKE_stptrs_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_stptrs_work(int matrix_layout, char uplo, char trans, char diag, int n, int nrhs, const float *ap, float *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_stptrs_work$handle() {
        return LAPACKE_stptrs_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_stptrs_work(int matrix_layout, char uplo, char trans, char diag, int n, int nrhs, const float *ap, float *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_stptrs_work$address() {
        return LAPACKE_stptrs_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_stptrs_work(int matrix_layout, char uplo, char trans, char diag, int n, int nrhs, const float *ap, float *b, int ldb)
     * }
     */
    public static int LAPACKE_stptrs_work(int matrix_layout, byte uplo, byte trans, byte diag, int n, int nrhs, MemorySegment ap, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_stptrs_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_stptrs_work", matrix_layout, uplo, trans, diag, n, nrhs, ap, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, trans, diag, n, nrhs, ap, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dtptrs_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dtptrs_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dtptrs_work(int matrix_layout, char uplo, char trans, char diag, int n, int nrhs, const double *ap, double *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_dtptrs_work$descriptor() {
        return LAPACKE_dtptrs_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dtptrs_work(int matrix_layout, char uplo, char trans, char diag, int n, int nrhs, const double *ap, double *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_dtptrs_work$handle() {
        return LAPACKE_dtptrs_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dtptrs_work(int matrix_layout, char uplo, char trans, char diag, int n, int nrhs, const double *ap, double *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_dtptrs_work$address() {
        return LAPACKE_dtptrs_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dtptrs_work(int matrix_layout, char uplo, char trans, char diag, int n, int nrhs, const double *ap, double *b, int ldb)
     * }
     */
    public static int LAPACKE_dtptrs_work(int matrix_layout, byte uplo, byte trans, byte diag, int n, int nrhs, MemorySegment ap, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_dtptrs_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dtptrs_work", matrix_layout, uplo, trans, diag, n, nrhs, ap, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, trans, diag, n, nrhs, ap, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ctptrs_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_ctptrs_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ctptrs_work(int matrix_layout, char uplo, char trans, char diag, int n, int nrhs, const _Complex float *ap, _Complex float *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_ctptrs_work$descriptor() {
        return LAPACKE_ctptrs_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ctptrs_work(int matrix_layout, char uplo, char trans, char diag, int n, int nrhs, const _Complex float *ap, _Complex float *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_ctptrs_work$handle() {
        return LAPACKE_ctptrs_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ctptrs_work(int matrix_layout, char uplo, char trans, char diag, int n, int nrhs, const _Complex float *ap, _Complex float *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_ctptrs_work$address() {
        return LAPACKE_ctptrs_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ctptrs_work(int matrix_layout, char uplo, char trans, char diag, int n, int nrhs, const _Complex float *ap, _Complex float *b, int ldb)
     * }
     */
    public static int LAPACKE_ctptrs_work(int matrix_layout, byte uplo, byte trans, byte diag, int n, int nrhs, MemorySegment ap, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_ctptrs_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ctptrs_work", matrix_layout, uplo, trans, diag, n, nrhs, ap, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, trans, diag, n, nrhs, ap, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ztptrs_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_ztptrs_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ztptrs_work(int matrix_layout, char uplo, char trans, char diag, int n, int nrhs, const _Complex double *ap, _Complex double *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_ztptrs_work$descriptor() {
        return LAPACKE_ztptrs_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ztptrs_work(int matrix_layout, char uplo, char trans, char diag, int n, int nrhs, const _Complex double *ap, _Complex double *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_ztptrs_work$handle() {
        return LAPACKE_ztptrs_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ztptrs_work(int matrix_layout, char uplo, char trans, char diag, int n, int nrhs, const _Complex double *ap, _Complex double *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_ztptrs_work$address() {
        return LAPACKE_ztptrs_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ztptrs_work(int matrix_layout, char uplo, char trans, char diag, int n, int nrhs, const _Complex double *ap, _Complex double *b, int ldb)
     * }
     */
    public static int LAPACKE_ztptrs_work(int matrix_layout, byte uplo, byte trans, byte diag, int n, int nrhs, MemorySegment ap, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_ztptrs_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ztptrs_work", matrix_layout, uplo, trans, diag, n, nrhs, ap, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, trans, diag, n, nrhs, ap, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_stpttf_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_stpttf_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_stpttf_work(int matrix_layout, char transr, char uplo, int n, const float *ap, float *arf)
     * }
     */
    public static FunctionDescriptor LAPACKE_stpttf_work$descriptor() {
        return LAPACKE_stpttf_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_stpttf_work(int matrix_layout, char transr, char uplo, int n, const float *ap, float *arf)
     * }
     */
    public static MethodHandle LAPACKE_stpttf_work$handle() {
        return LAPACKE_stpttf_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_stpttf_work(int matrix_layout, char transr, char uplo, int n, const float *ap, float *arf)
     * }
     */
    public static MemorySegment LAPACKE_stpttf_work$address() {
        return LAPACKE_stpttf_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_stpttf_work(int matrix_layout, char transr, char uplo, int n, const float *ap, float *arf)
     * }
     */
    public static int LAPACKE_stpttf_work(int matrix_layout, byte transr, byte uplo, int n, MemorySegment ap, MemorySegment arf) {
        var mh$ = LAPACKE_stpttf_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_stpttf_work", matrix_layout, transr, uplo, n, ap, arf);
            }
            return (int)mh$.invokeExact(matrix_layout, transr, uplo, n, ap, arf);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dtpttf_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dtpttf_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dtpttf_work(int matrix_layout, char transr, char uplo, int n, const double *ap, double *arf)
     * }
     */
    public static FunctionDescriptor LAPACKE_dtpttf_work$descriptor() {
        return LAPACKE_dtpttf_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dtpttf_work(int matrix_layout, char transr, char uplo, int n, const double *ap, double *arf)
     * }
     */
    public static MethodHandle LAPACKE_dtpttf_work$handle() {
        return LAPACKE_dtpttf_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dtpttf_work(int matrix_layout, char transr, char uplo, int n, const double *ap, double *arf)
     * }
     */
    public static MemorySegment LAPACKE_dtpttf_work$address() {
        return LAPACKE_dtpttf_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dtpttf_work(int matrix_layout, char transr, char uplo, int n, const double *ap, double *arf)
     * }
     */
    public static int LAPACKE_dtpttf_work(int matrix_layout, byte transr, byte uplo, int n, MemorySegment ap, MemorySegment arf) {
        var mh$ = LAPACKE_dtpttf_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dtpttf_work", matrix_layout, transr, uplo, n, ap, arf);
            }
            return (int)mh$.invokeExact(matrix_layout, transr, uplo, n, ap, arf);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ctpttf_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_ctpttf_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ctpttf_work(int matrix_layout, char transr, char uplo, int n, const _Complex float *ap, _Complex float *arf)
     * }
     */
    public static FunctionDescriptor LAPACKE_ctpttf_work$descriptor() {
        return LAPACKE_ctpttf_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ctpttf_work(int matrix_layout, char transr, char uplo, int n, const _Complex float *ap, _Complex float *arf)
     * }
     */
    public static MethodHandle LAPACKE_ctpttf_work$handle() {
        return LAPACKE_ctpttf_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ctpttf_work(int matrix_layout, char transr, char uplo, int n, const _Complex float *ap, _Complex float *arf)
     * }
     */
    public static MemorySegment LAPACKE_ctpttf_work$address() {
        return LAPACKE_ctpttf_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ctpttf_work(int matrix_layout, char transr, char uplo, int n, const _Complex float *ap, _Complex float *arf)
     * }
     */
    public static int LAPACKE_ctpttf_work(int matrix_layout, byte transr, byte uplo, int n, MemorySegment ap, MemorySegment arf) {
        var mh$ = LAPACKE_ctpttf_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ctpttf_work", matrix_layout, transr, uplo, n, ap, arf);
            }
            return (int)mh$.invokeExact(matrix_layout, transr, uplo, n, ap, arf);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ztpttf_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_ztpttf_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ztpttf_work(int matrix_layout, char transr, char uplo, int n, const _Complex double *ap, _Complex double *arf)
     * }
     */
    public static FunctionDescriptor LAPACKE_ztpttf_work$descriptor() {
        return LAPACKE_ztpttf_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ztpttf_work(int matrix_layout, char transr, char uplo, int n, const _Complex double *ap, _Complex double *arf)
     * }
     */
    public static MethodHandle LAPACKE_ztpttf_work$handle() {
        return LAPACKE_ztpttf_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ztpttf_work(int matrix_layout, char transr, char uplo, int n, const _Complex double *ap, _Complex double *arf)
     * }
     */
    public static MemorySegment LAPACKE_ztpttf_work$address() {
        return LAPACKE_ztpttf_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ztpttf_work(int matrix_layout, char transr, char uplo, int n, const _Complex double *ap, _Complex double *arf)
     * }
     */
    public static int LAPACKE_ztpttf_work(int matrix_layout, byte transr, byte uplo, int n, MemorySegment ap, MemorySegment arf) {
        var mh$ = LAPACKE_ztpttf_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ztpttf_work", matrix_layout, transr, uplo, n, ap, arf);
            }
            return (int)mh$.invokeExact(matrix_layout, transr, uplo, n, ap, arf);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_stpttr_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_stpttr_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_stpttr_work(int matrix_layout, char uplo, int n, const float *ap, float *a, int lda)
     * }
     */
    public static FunctionDescriptor LAPACKE_stpttr_work$descriptor() {
        return LAPACKE_stpttr_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_stpttr_work(int matrix_layout, char uplo, int n, const float *ap, float *a, int lda)
     * }
     */
    public static MethodHandle LAPACKE_stpttr_work$handle() {
        return LAPACKE_stpttr_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_stpttr_work(int matrix_layout, char uplo, int n, const float *ap, float *a, int lda)
     * }
     */
    public static MemorySegment LAPACKE_stpttr_work$address() {
        return LAPACKE_stpttr_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_stpttr_work(int matrix_layout, char uplo, int n, const float *ap, float *a, int lda)
     * }
     */
    public static int LAPACKE_stpttr_work(int matrix_layout, byte uplo, int n, MemorySegment ap, MemorySegment a, int lda) {
        var mh$ = LAPACKE_stpttr_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_stpttr_work", matrix_layout, uplo, n, ap, a, lda);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, ap, a, lda);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dtpttr_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dtpttr_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dtpttr_work(int matrix_layout, char uplo, int n, const double *ap, double *a, int lda)
     * }
     */
    public static FunctionDescriptor LAPACKE_dtpttr_work$descriptor() {
        return LAPACKE_dtpttr_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dtpttr_work(int matrix_layout, char uplo, int n, const double *ap, double *a, int lda)
     * }
     */
    public static MethodHandle LAPACKE_dtpttr_work$handle() {
        return LAPACKE_dtpttr_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dtpttr_work(int matrix_layout, char uplo, int n, const double *ap, double *a, int lda)
     * }
     */
    public static MemorySegment LAPACKE_dtpttr_work$address() {
        return LAPACKE_dtpttr_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dtpttr_work(int matrix_layout, char uplo, int n, const double *ap, double *a, int lda)
     * }
     */
    public static int LAPACKE_dtpttr_work(int matrix_layout, byte uplo, int n, MemorySegment ap, MemorySegment a, int lda) {
        var mh$ = LAPACKE_dtpttr_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dtpttr_work", matrix_layout, uplo, n, ap, a, lda);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, ap, a, lda);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ctpttr_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_ctpttr_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ctpttr_work(int matrix_layout, char uplo, int n, const _Complex float *ap, _Complex float *a, int lda)
     * }
     */
    public static FunctionDescriptor LAPACKE_ctpttr_work$descriptor() {
        return LAPACKE_ctpttr_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ctpttr_work(int matrix_layout, char uplo, int n, const _Complex float *ap, _Complex float *a, int lda)
     * }
     */
    public static MethodHandle LAPACKE_ctpttr_work$handle() {
        return LAPACKE_ctpttr_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ctpttr_work(int matrix_layout, char uplo, int n, const _Complex float *ap, _Complex float *a, int lda)
     * }
     */
    public static MemorySegment LAPACKE_ctpttr_work$address() {
        return LAPACKE_ctpttr_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ctpttr_work(int matrix_layout, char uplo, int n, const _Complex float *ap, _Complex float *a, int lda)
     * }
     */
    public static int LAPACKE_ctpttr_work(int matrix_layout, byte uplo, int n, MemorySegment ap, MemorySegment a, int lda) {
        var mh$ = LAPACKE_ctpttr_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ctpttr_work", matrix_layout, uplo, n, ap, a, lda);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, ap, a, lda);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ztpttr_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_ztpttr_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ztpttr_work(int matrix_layout, char uplo, int n, const _Complex double *ap, _Complex double *a, int lda)
     * }
     */
    public static FunctionDescriptor LAPACKE_ztpttr_work$descriptor() {
        return LAPACKE_ztpttr_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ztpttr_work(int matrix_layout, char uplo, int n, const _Complex double *ap, _Complex double *a, int lda)
     * }
     */
    public static MethodHandle LAPACKE_ztpttr_work$handle() {
        return LAPACKE_ztpttr_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ztpttr_work(int matrix_layout, char uplo, int n, const _Complex double *ap, _Complex double *a, int lda)
     * }
     */
    public static MemorySegment LAPACKE_ztpttr_work$address() {
        return LAPACKE_ztpttr_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ztpttr_work(int matrix_layout, char uplo, int n, const _Complex double *ap, _Complex double *a, int lda)
     * }
     */
    public static int LAPACKE_ztpttr_work(int matrix_layout, byte uplo, int n, MemorySegment ap, MemorySegment a, int lda) {
        var mh$ = LAPACKE_ztpttr_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ztpttr_work", matrix_layout, uplo, n, ap, a, lda);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, ap, a, lda);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_strcon_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_strcon_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_strcon_work(int matrix_layout, char norm, char uplo, char diag, int n, const float *a, int lda, float *rcond, float *work, int *iwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_strcon_work$descriptor() {
        return LAPACKE_strcon_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_strcon_work(int matrix_layout, char norm, char uplo, char diag, int n, const float *a, int lda, float *rcond, float *work, int *iwork)
     * }
     */
    public static MethodHandle LAPACKE_strcon_work$handle() {
        return LAPACKE_strcon_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_strcon_work(int matrix_layout, char norm, char uplo, char diag, int n, const float *a, int lda, float *rcond, float *work, int *iwork)
     * }
     */
    public static MemorySegment LAPACKE_strcon_work$address() {
        return LAPACKE_strcon_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_strcon_work(int matrix_layout, char norm, char uplo, char diag, int n, const float *a, int lda, float *rcond, float *work, int *iwork)
     * }
     */
    public static int LAPACKE_strcon_work(int matrix_layout, byte norm, byte uplo, byte diag, int n, MemorySegment a, int lda, MemorySegment rcond, MemorySegment work, MemorySegment iwork) {
        var mh$ = LAPACKE_strcon_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_strcon_work", matrix_layout, norm, uplo, diag, n, a, lda, rcond, work, iwork);
            }
            return (int)mh$.invokeExact(matrix_layout, norm, uplo, diag, n, a, lda, rcond, work, iwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dtrcon_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dtrcon_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dtrcon_work(int matrix_layout, char norm, char uplo, char diag, int n, const double *a, int lda, double *rcond, double *work, int *iwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_dtrcon_work$descriptor() {
        return LAPACKE_dtrcon_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dtrcon_work(int matrix_layout, char norm, char uplo, char diag, int n, const double *a, int lda, double *rcond, double *work, int *iwork)
     * }
     */
    public static MethodHandle LAPACKE_dtrcon_work$handle() {
        return LAPACKE_dtrcon_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dtrcon_work(int matrix_layout, char norm, char uplo, char diag, int n, const double *a, int lda, double *rcond, double *work, int *iwork)
     * }
     */
    public static MemorySegment LAPACKE_dtrcon_work$address() {
        return LAPACKE_dtrcon_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dtrcon_work(int matrix_layout, char norm, char uplo, char diag, int n, const double *a, int lda, double *rcond, double *work, int *iwork)
     * }
     */
    public static int LAPACKE_dtrcon_work(int matrix_layout, byte norm, byte uplo, byte diag, int n, MemorySegment a, int lda, MemorySegment rcond, MemorySegment work, MemorySegment iwork) {
        var mh$ = LAPACKE_dtrcon_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dtrcon_work", matrix_layout, norm, uplo, diag, n, a, lda, rcond, work, iwork);
            }
            return (int)mh$.invokeExact(matrix_layout, norm, uplo, diag, n, a, lda, rcond, work, iwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ctrcon_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_ctrcon_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ctrcon_work(int matrix_layout, char norm, char uplo, char diag, int n, const _Complex float *a, int lda, float *rcond, _Complex float *work, float *rwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_ctrcon_work$descriptor() {
        return LAPACKE_ctrcon_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ctrcon_work(int matrix_layout, char norm, char uplo, char diag, int n, const _Complex float *a, int lda, float *rcond, _Complex float *work, float *rwork)
     * }
     */
    public static MethodHandle LAPACKE_ctrcon_work$handle() {
        return LAPACKE_ctrcon_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ctrcon_work(int matrix_layout, char norm, char uplo, char diag, int n, const _Complex float *a, int lda, float *rcond, _Complex float *work, float *rwork)
     * }
     */
    public static MemorySegment LAPACKE_ctrcon_work$address() {
        return LAPACKE_ctrcon_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ctrcon_work(int matrix_layout, char norm, char uplo, char diag, int n, const _Complex float *a, int lda, float *rcond, _Complex float *work, float *rwork)
     * }
     */
    public static int LAPACKE_ctrcon_work(int matrix_layout, byte norm, byte uplo, byte diag, int n, MemorySegment a, int lda, MemorySegment rcond, MemorySegment work, MemorySegment rwork) {
        var mh$ = LAPACKE_ctrcon_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ctrcon_work", matrix_layout, norm, uplo, diag, n, a, lda, rcond, work, rwork);
            }
            return (int)mh$.invokeExact(matrix_layout, norm, uplo, diag, n, a, lda, rcond, work, rwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ztrcon_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_ztrcon_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ztrcon_work(int matrix_layout, char norm, char uplo, char diag, int n, const _Complex double *a, int lda, double *rcond, _Complex double *work, double *rwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_ztrcon_work$descriptor() {
        return LAPACKE_ztrcon_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ztrcon_work(int matrix_layout, char norm, char uplo, char diag, int n, const _Complex double *a, int lda, double *rcond, _Complex double *work, double *rwork)
     * }
     */
    public static MethodHandle LAPACKE_ztrcon_work$handle() {
        return LAPACKE_ztrcon_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ztrcon_work(int matrix_layout, char norm, char uplo, char diag, int n, const _Complex double *a, int lda, double *rcond, _Complex double *work, double *rwork)
     * }
     */
    public static MemorySegment LAPACKE_ztrcon_work$address() {
        return LAPACKE_ztrcon_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ztrcon_work(int matrix_layout, char norm, char uplo, char diag, int n, const _Complex double *a, int lda, double *rcond, _Complex double *work, double *rwork)
     * }
     */
    public static int LAPACKE_ztrcon_work(int matrix_layout, byte norm, byte uplo, byte diag, int n, MemorySegment a, int lda, MemorySegment rcond, MemorySegment work, MemorySegment rwork) {
        var mh$ = LAPACKE_ztrcon_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ztrcon_work", matrix_layout, norm, uplo, diag, n, a, lda, rcond, work, rwork);
            }
            return (int)mh$.invokeExact(matrix_layout, norm, uplo, diag, n, a, lda, rcond, work, rwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_strevc_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_strevc_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_strevc_work(int matrix_layout, char side, char howmny, int *select, int n, const float *t, int ldt, float *vl, int ldvl, float *vr, int ldvr, int mm, int *m, float *work)
     * }
     */
    public static FunctionDescriptor LAPACKE_strevc_work$descriptor() {
        return LAPACKE_strevc_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_strevc_work(int matrix_layout, char side, char howmny, int *select, int n, const float *t, int ldt, float *vl, int ldvl, float *vr, int ldvr, int mm, int *m, float *work)
     * }
     */
    public static MethodHandle LAPACKE_strevc_work$handle() {
        return LAPACKE_strevc_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_strevc_work(int matrix_layout, char side, char howmny, int *select, int n, const float *t, int ldt, float *vl, int ldvl, float *vr, int ldvr, int mm, int *m, float *work)
     * }
     */
    public static MemorySegment LAPACKE_strevc_work$address() {
        return LAPACKE_strevc_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_strevc_work(int matrix_layout, char side, char howmny, int *select, int n, const float *t, int ldt, float *vl, int ldvl, float *vr, int ldvr, int mm, int *m, float *work)
     * }
     */
    public static int LAPACKE_strevc_work(int matrix_layout, byte side, byte howmny, MemorySegment select, int n, MemorySegment t, int ldt, MemorySegment vl, int ldvl, MemorySegment vr, int ldvr, int mm, MemorySegment m, MemorySegment work) {
        var mh$ = LAPACKE_strevc_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_strevc_work", matrix_layout, side, howmny, select, n, t, ldt, vl, ldvl, vr, ldvr, mm, m, work);
            }
            return (int)mh$.invokeExact(matrix_layout, side, howmny, select, n, t, ldt, vl, ldvl, vr, ldvr, mm, m, work);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dtrevc_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dtrevc_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dtrevc_work(int matrix_layout, char side, char howmny, int *select, int n, const double *t, int ldt, double *vl, int ldvl, double *vr, int ldvr, int mm, int *m, double *work)
     * }
     */
    public static FunctionDescriptor LAPACKE_dtrevc_work$descriptor() {
        return LAPACKE_dtrevc_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dtrevc_work(int matrix_layout, char side, char howmny, int *select, int n, const double *t, int ldt, double *vl, int ldvl, double *vr, int ldvr, int mm, int *m, double *work)
     * }
     */
    public static MethodHandle LAPACKE_dtrevc_work$handle() {
        return LAPACKE_dtrevc_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dtrevc_work(int matrix_layout, char side, char howmny, int *select, int n, const double *t, int ldt, double *vl, int ldvl, double *vr, int ldvr, int mm, int *m, double *work)
     * }
     */
    public static MemorySegment LAPACKE_dtrevc_work$address() {
        return LAPACKE_dtrevc_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dtrevc_work(int matrix_layout, char side, char howmny, int *select, int n, const double *t, int ldt, double *vl, int ldvl, double *vr, int ldvr, int mm, int *m, double *work)
     * }
     */
    public static int LAPACKE_dtrevc_work(int matrix_layout, byte side, byte howmny, MemorySegment select, int n, MemorySegment t, int ldt, MemorySegment vl, int ldvl, MemorySegment vr, int ldvr, int mm, MemorySegment m, MemorySegment work) {
        var mh$ = LAPACKE_dtrevc_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dtrevc_work", matrix_layout, side, howmny, select, n, t, ldt, vl, ldvl, vr, ldvr, mm, m, work);
            }
            return (int)mh$.invokeExact(matrix_layout, side, howmny, select, n, t, ldt, vl, ldvl, vr, ldvr, mm, m, work);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ctrevc_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_ctrevc_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ctrevc_work(int matrix_layout, char side, char howmny, const int *select, int n, _Complex float *t, int ldt, _Complex float *vl, int ldvl, _Complex float *vr, int ldvr, int mm, int *m, _Complex float *work, float *rwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_ctrevc_work$descriptor() {
        return LAPACKE_ctrevc_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ctrevc_work(int matrix_layout, char side, char howmny, const int *select, int n, _Complex float *t, int ldt, _Complex float *vl, int ldvl, _Complex float *vr, int ldvr, int mm, int *m, _Complex float *work, float *rwork)
     * }
     */
    public static MethodHandle LAPACKE_ctrevc_work$handle() {
        return LAPACKE_ctrevc_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ctrevc_work(int matrix_layout, char side, char howmny, const int *select, int n, _Complex float *t, int ldt, _Complex float *vl, int ldvl, _Complex float *vr, int ldvr, int mm, int *m, _Complex float *work, float *rwork)
     * }
     */
    public static MemorySegment LAPACKE_ctrevc_work$address() {
        return LAPACKE_ctrevc_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ctrevc_work(int matrix_layout, char side, char howmny, const int *select, int n, _Complex float *t, int ldt, _Complex float *vl, int ldvl, _Complex float *vr, int ldvr, int mm, int *m, _Complex float *work, float *rwork)
     * }
     */
    public static int LAPACKE_ctrevc_work(int matrix_layout, byte side, byte howmny, MemorySegment select, int n, MemorySegment t, int ldt, MemorySegment vl, int ldvl, MemorySegment vr, int ldvr, int mm, MemorySegment m, MemorySegment work, MemorySegment rwork) {
        var mh$ = LAPACKE_ctrevc_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ctrevc_work", matrix_layout, side, howmny, select, n, t, ldt, vl, ldvl, vr, ldvr, mm, m, work, rwork);
            }
            return (int)mh$.invokeExact(matrix_layout, side, howmny, select, n, t, ldt, vl, ldvl, vr, ldvr, mm, m, work, rwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ztrevc_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_ztrevc_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ztrevc_work(int matrix_layout, char side, char howmny, const int *select, int n, _Complex double *t, int ldt, _Complex double *vl, int ldvl, _Complex double *vr, int ldvr, int mm, int *m, _Complex double *work, double *rwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_ztrevc_work$descriptor() {
        return LAPACKE_ztrevc_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ztrevc_work(int matrix_layout, char side, char howmny, const int *select, int n, _Complex double *t, int ldt, _Complex double *vl, int ldvl, _Complex double *vr, int ldvr, int mm, int *m, _Complex double *work, double *rwork)
     * }
     */
    public static MethodHandle LAPACKE_ztrevc_work$handle() {
        return LAPACKE_ztrevc_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ztrevc_work(int matrix_layout, char side, char howmny, const int *select, int n, _Complex double *t, int ldt, _Complex double *vl, int ldvl, _Complex double *vr, int ldvr, int mm, int *m, _Complex double *work, double *rwork)
     * }
     */
    public static MemorySegment LAPACKE_ztrevc_work$address() {
        return LAPACKE_ztrevc_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ztrevc_work(int matrix_layout, char side, char howmny, const int *select, int n, _Complex double *t, int ldt, _Complex double *vl, int ldvl, _Complex double *vr, int ldvr, int mm, int *m, _Complex double *work, double *rwork)
     * }
     */
    public static int LAPACKE_ztrevc_work(int matrix_layout, byte side, byte howmny, MemorySegment select, int n, MemorySegment t, int ldt, MemorySegment vl, int ldvl, MemorySegment vr, int ldvr, int mm, MemorySegment m, MemorySegment work, MemorySegment rwork) {
        var mh$ = LAPACKE_ztrevc_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ztrevc_work", matrix_layout, side, howmny, select, n, t, ldt, vl, ldvl, vr, ldvr, mm, m, work, rwork);
            }
            return (int)mh$.invokeExact(matrix_layout, side, howmny, select, n, t, ldt, vl, ldvl, vr, ldvr, mm, m, work, rwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_strexc_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_strexc_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_strexc_work(int matrix_layout, char compq, int n, float *t, int ldt, float *q, int ldq, int *ifst, int *ilst, float *work)
     * }
     */
    public static FunctionDescriptor LAPACKE_strexc_work$descriptor() {
        return LAPACKE_strexc_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_strexc_work(int matrix_layout, char compq, int n, float *t, int ldt, float *q, int ldq, int *ifst, int *ilst, float *work)
     * }
     */
    public static MethodHandle LAPACKE_strexc_work$handle() {
        return LAPACKE_strexc_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_strexc_work(int matrix_layout, char compq, int n, float *t, int ldt, float *q, int ldq, int *ifst, int *ilst, float *work)
     * }
     */
    public static MemorySegment LAPACKE_strexc_work$address() {
        return LAPACKE_strexc_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_strexc_work(int matrix_layout, char compq, int n, float *t, int ldt, float *q, int ldq, int *ifst, int *ilst, float *work)
     * }
     */
    public static int LAPACKE_strexc_work(int matrix_layout, byte compq, int n, MemorySegment t, int ldt, MemorySegment q, int ldq, MemorySegment ifst, MemorySegment ilst, MemorySegment work) {
        var mh$ = LAPACKE_strexc_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_strexc_work", matrix_layout, compq, n, t, ldt, q, ldq, ifst, ilst, work);
            }
            return (int)mh$.invokeExact(matrix_layout, compq, n, t, ldt, q, ldq, ifst, ilst, work);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dtrexc_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dtrexc_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dtrexc_work(int matrix_layout, char compq, int n, double *t, int ldt, double *q, int ldq, int *ifst, int *ilst, double *work)
     * }
     */
    public static FunctionDescriptor LAPACKE_dtrexc_work$descriptor() {
        return LAPACKE_dtrexc_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dtrexc_work(int matrix_layout, char compq, int n, double *t, int ldt, double *q, int ldq, int *ifst, int *ilst, double *work)
     * }
     */
    public static MethodHandle LAPACKE_dtrexc_work$handle() {
        return LAPACKE_dtrexc_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dtrexc_work(int matrix_layout, char compq, int n, double *t, int ldt, double *q, int ldq, int *ifst, int *ilst, double *work)
     * }
     */
    public static MemorySegment LAPACKE_dtrexc_work$address() {
        return LAPACKE_dtrexc_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dtrexc_work(int matrix_layout, char compq, int n, double *t, int ldt, double *q, int ldq, int *ifst, int *ilst, double *work)
     * }
     */
    public static int LAPACKE_dtrexc_work(int matrix_layout, byte compq, int n, MemorySegment t, int ldt, MemorySegment q, int ldq, MemorySegment ifst, MemorySegment ilst, MemorySegment work) {
        var mh$ = LAPACKE_dtrexc_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dtrexc_work", matrix_layout, compq, n, t, ldt, q, ldq, ifst, ilst, work);
            }
            return (int)mh$.invokeExact(matrix_layout, compq, n, t, ldt, q, ldq, ifst, ilst, work);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ctrexc_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_ctrexc_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ctrexc_work(int matrix_layout, char compq, int n, _Complex float *t, int ldt, _Complex float *q, int ldq, int ifst, int ilst)
     * }
     */
    public static FunctionDescriptor LAPACKE_ctrexc_work$descriptor() {
        return LAPACKE_ctrexc_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ctrexc_work(int matrix_layout, char compq, int n, _Complex float *t, int ldt, _Complex float *q, int ldq, int ifst, int ilst)
     * }
     */
    public static MethodHandle LAPACKE_ctrexc_work$handle() {
        return LAPACKE_ctrexc_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ctrexc_work(int matrix_layout, char compq, int n, _Complex float *t, int ldt, _Complex float *q, int ldq, int ifst, int ilst)
     * }
     */
    public static MemorySegment LAPACKE_ctrexc_work$address() {
        return LAPACKE_ctrexc_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ctrexc_work(int matrix_layout, char compq, int n, _Complex float *t, int ldt, _Complex float *q, int ldq, int ifst, int ilst)
     * }
     */
    public static int LAPACKE_ctrexc_work(int matrix_layout, byte compq, int n, MemorySegment t, int ldt, MemorySegment q, int ldq, int ifst, int ilst) {
        var mh$ = LAPACKE_ctrexc_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ctrexc_work", matrix_layout, compq, n, t, ldt, q, ldq, ifst, ilst);
            }
            return (int)mh$.invokeExact(matrix_layout, compq, n, t, ldt, q, ldq, ifst, ilst);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ztrexc_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_ztrexc_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ztrexc_work(int matrix_layout, char compq, int n, _Complex double *t, int ldt, _Complex double *q, int ldq, int ifst, int ilst)
     * }
     */
    public static FunctionDescriptor LAPACKE_ztrexc_work$descriptor() {
        return LAPACKE_ztrexc_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ztrexc_work(int matrix_layout, char compq, int n, _Complex double *t, int ldt, _Complex double *q, int ldq, int ifst, int ilst)
     * }
     */
    public static MethodHandle LAPACKE_ztrexc_work$handle() {
        return LAPACKE_ztrexc_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ztrexc_work(int matrix_layout, char compq, int n, _Complex double *t, int ldt, _Complex double *q, int ldq, int ifst, int ilst)
     * }
     */
    public static MemorySegment LAPACKE_ztrexc_work$address() {
        return LAPACKE_ztrexc_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ztrexc_work(int matrix_layout, char compq, int n, _Complex double *t, int ldt, _Complex double *q, int ldq, int ifst, int ilst)
     * }
     */
    public static int LAPACKE_ztrexc_work(int matrix_layout, byte compq, int n, MemorySegment t, int ldt, MemorySegment q, int ldq, int ifst, int ilst) {
        var mh$ = LAPACKE_ztrexc_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ztrexc_work", matrix_layout, compq, n, t, ldt, q, ldq, ifst, ilst);
            }
            return (int)mh$.invokeExact(matrix_layout, compq, n, t, ldt, q, ldq, ifst, ilst);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_strrfs_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_strrfs_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_strrfs_work(int matrix_layout, char uplo, char trans, char diag, int n, int nrhs, const float *a, int lda, const float *b, int ldb, const float *x, int ldx, float *ferr, float *berr, float *work, int *iwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_strrfs_work$descriptor() {
        return LAPACKE_strrfs_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_strrfs_work(int matrix_layout, char uplo, char trans, char diag, int n, int nrhs, const float *a, int lda, const float *b, int ldb, const float *x, int ldx, float *ferr, float *berr, float *work, int *iwork)
     * }
     */
    public static MethodHandle LAPACKE_strrfs_work$handle() {
        return LAPACKE_strrfs_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_strrfs_work(int matrix_layout, char uplo, char trans, char diag, int n, int nrhs, const float *a, int lda, const float *b, int ldb, const float *x, int ldx, float *ferr, float *berr, float *work, int *iwork)
     * }
     */
    public static MemorySegment LAPACKE_strrfs_work$address() {
        return LAPACKE_strrfs_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_strrfs_work(int matrix_layout, char uplo, char trans, char diag, int n, int nrhs, const float *a, int lda, const float *b, int ldb, const float *x, int ldx, float *ferr, float *berr, float *work, int *iwork)
     * }
     */
    public static int LAPACKE_strrfs_work(int matrix_layout, byte uplo, byte trans, byte diag, int n, int nrhs, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment ferr, MemorySegment berr, MemorySegment work, MemorySegment iwork) {
        var mh$ = LAPACKE_strrfs_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_strrfs_work", matrix_layout, uplo, trans, diag, n, nrhs, a, lda, b, ldb, x, ldx, ferr, berr, work, iwork);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, trans, diag, n, nrhs, a, lda, b, ldb, x, ldx, ferr, berr, work, iwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dtrrfs_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dtrrfs_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dtrrfs_work(int matrix_layout, char uplo, char trans, char diag, int n, int nrhs, const double *a, int lda, const double *b, int ldb, const double *x, int ldx, double *ferr, double *berr, double *work, int *iwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_dtrrfs_work$descriptor() {
        return LAPACKE_dtrrfs_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dtrrfs_work(int matrix_layout, char uplo, char trans, char diag, int n, int nrhs, const double *a, int lda, const double *b, int ldb, const double *x, int ldx, double *ferr, double *berr, double *work, int *iwork)
     * }
     */
    public static MethodHandle LAPACKE_dtrrfs_work$handle() {
        return LAPACKE_dtrrfs_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dtrrfs_work(int matrix_layout, char uplo, char trans, char diag, int n, int nrhs, const double *a, int lda, const double *b, int ldb, const double *x, int ldx, double *ferr, double *berr, double *work, int *iwork)
     * }
     */
    public static MemorySegment LAPACKE_dtrrfs_work$address() {
        return LAPACKE_dtrrfs_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dtrrfs_work(int matrix_layout, char uplo, char trans, char diag, int n, int nrhs, const double *a, int lda, const double *b, int ldb, const double *x, int ldx, double *ferr, double *berr, double *work, int *iwork)
     * }
     */
    public static int LAPACKE_dtrrfs_work(int matrix_layout, byte uplo, byte trans, byte diag, int n, int nrhs, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment ferr, MemorySegment berr, MemorySegment work, MemorySegment iwork) {
        var mh$ = LAPACKE_dtrrfs_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dtrrfs_work", matrix_layout, uplo, trans, diag, n, nrhs, a, lda, b, ldb, x, ldx, ferr, berr, work, iwork);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, trans, diag, n, nrhs, a, lda, b, ldb, x, ldx, ferr, berr, work, iwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ctrrfs_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_ctrrfs_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ctrrfs_work(int matrix_layout, char uplo, char trans, char diag, int n, int nrhs, const _Complex float *a, int lda, const _Complex float *b, int ldb, const _Complex float *x, int ldx, float *ferr, float *berr, _Complex float *work, float *rwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_ctrrfs_work$descriptor() {
        return LAPACKE_ctrrfs_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ctrrfs_work(int matrix_layout, char uplo, char trans, char diag, int n, int nrhs, const _Complex float *a, int lda, const _Complex float *b, int ldb, const _Complex float *x, int ldx, float *ferr, float *berr, _Complex float *work, float *rwork)
     * }
     */
    public static MethodHandle LAPACKE_ctrrfs_work$handle() {
        return LAPACKE_ctrrfs_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ctrrfs_work(int matrix_layout, char uplo, char trans, char diag, int n, int nrhs, const _Complex float *a, int lda, const _Complex float *b, int ldb, const _Complex float *x, int ldx, float *ferr, float *berr, _Complex float *work, float *rwork)
     * }
     */
    public static MemorySegment LAPACKE_ctrrfs_work$address() {
        return LAPACKE_ctrrfs_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ctrrfs_work(int matrix_layout, char uplo, char trans, char diag, int n, int nrhs, const _Complex float *a, int lda, const _Complex float *b, int ldb, const _Complex float *x, int ldx, float *ferr, float *berr, _Complex float *work, float *rwork)
     * }
     */
    public static int LAPACKE_ctrrfs_work(int matrix_layout, byte uplo, byte trans, byte diag, int n, int nrhs, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment ferr, MemorySegment berr, MemorySegment work, MemorySegment rwork) {
        var mh$ = LAPACKE_ctrrfs_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ctrrfs_work", matrix_layout, uplo, trans, diag, n, nrhs, a, lda, b, ldb, x, ldx, ferr, berr, work, rwork);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, trans, diag, n, nrhs, a, lda, b, ldb, x, ldx, ferr, berr, work, rwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ztrrfs_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_ztrrfs_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ztrrfs_work(int matrix_layout, char uplo, char trans, char diag, int n, int nrhs, const _Complex double *a, int lda, const _Complex double *b, int ldb, const _Complex double *x, int ldx, double *ferr, double *berr, _Complex double *work, double *rwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_ztrrfs_work$descriptor() {
        return LAPACKE_ztrrfs_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ztrrfs_work(int matrix_layout, char uplo, char trans, char diag, int n, int nrhs, const _Complex double *a, int lda, const _Complex double *b, int ldb, const _Complex double *x, int ldx, double *ferr, double *berr, _Complex double *work, double *rwork)
     * }
     */
    public static MethodHandle LAPACKE_ztrrfs_work$handle() {
        return LAPACKE_ztrrfs_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ztrrfs_work(int matrix_layout, char uplo, char trans, char diag, int n, int nrhs, const _Complex double *a, int lda, const _Complex double *b, int ldb, const _Complex double *x, int ldx, double *ferr, double *berr, _Complex double *work, double *rwork)
     * }
     */
    public static MemorySegment LAPACKE_ztrrfs_work$address() {
        return LAPACKE_ztrrfs_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ztrrfs_work(int matrix_layout, char uplo, char trans, char diag, int n, int nrhs, const _Complex double *a, int lda, const _Complex double *b, int ldb, const _Complex double *x, int ldx, double *ferr, double *berr, _Complex double *work, double *rwork)
     * }
     */
    public static int LAPACKE_ztrrfs_work(int matrix_layout, byte uplo, byte trans, byte diag, int n, int nrhs, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment ferr, MemorySegment berr, MemorySegment work, MemorySegment rwork) {
        var mh$ = LAPACKE_ztrrfs_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ztrrfs_work", matrix_layout, uplo, trans, diag, n, nrhs, a, lda, b, ldb, x, ldx, ferr, berr, work, rwork);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, trans, diag, n, nrhs, a, lda, b, ldb, x, ldx, ferr, berr, work, rwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_strsen_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_strsen_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_strsen_work(int matrix_layout, char job, char compq, const int *select, int n, float *t, int ldt, float *q, int ldq, float *wr, float *wi, int *m, float *s, float *sep, float *work, int lwork, int *iwork, int liwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_strsen_work$descriptor() {
        return LAPACKE_strsen_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_strsen_work(int matrix_layout, char job, char compq, const int *select, int n, float *t, int ldt, float *q, int ldq, float *wr, float *wi, int *m, float *s, float *sep, float *work, int lwork, int *iwork, int liwork)
     * }
     */
    public static MethodHandle LAPACKE_strsen_work$handle() {
        return LAPACKE_strsen_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_strsen_work(int matrix_layout, char job, char compq, const int *select, int n, float *t, int ldt, float *q, int ldq, float *wr, float *wi, int *m, float *s, float *sep, float *work, int lwork, int *iwork, int liwork)
     * }
     */
    public static MemorySegment LAPACKE_strsen_work$address() {
        return LAPACKE_strsen_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_strsen_work(int matrix_layout, char job, char compq, const int *select, int n, float *t, int ldt, float *q, int ldq, float *wr, float *wi, int *m, float *s, float *sep, float *work, int lwork, int *iwork, int liwork)
     * }
     */
    public static int LAPACKE_strsen_work(int matrix_layout, byte job, byte compq, MemorySegment select, int n, MemorySegment t, int ldt, MemorySegment q, int ldq, MemorySegment wr, MemorySegment wi, MemorySegment m, MemorySegment s, MemorySegment sep, MemorySegment work, int lwork, MemorySegment iwork, int liwork) {
        var mh$ = LAPACKE_strsen_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_strsen_work", matrix_layout, job, compq, select, n, t, ldt, q, ldq, wr, wi, m, s, sep, work, lwork, iwork, liwork);
            }
            return (int)mh$.invokeExact(matrix_layout, job, compq, select, n, t, ldt, q, ldq, wr, wi, m, s, sep, work, lwork, iwork, liwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dtrsen_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dtrsen_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dtrsen_work(int matrix_layout, char job, char compq, const int *select, int n, double *t, int ldt, double *q, int ldq, double *wr, double *wi, int *m, double *s, double *sep, double *work, int lwork, int *iwork, int liwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_dtrsen_work$descriptor() {
        return LAPACKE_dtrsen_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dtrsen_work(int matrix_layout, char job, char compq, const int *select, int n, double *t, int ldt, double *q, int ldq, double *wr, double *wi, int *m, double *s, double *sep, double *work, int lwork, int *iwork, int liwork)
     * }
     */
    public static MethodHandle LAPACKE_dtrsen_work$handle() {
        return LAPACKE_dtrsen_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dtrsen_work(int matrix_layout, char job, char compq, const int *select, int n, double *t, int ldt, double *q, int ldq, double *wr, double *wi, int *m, double *s, double *sep, double *work, int lwork, int *iwork, int liwork)
     * }
     */
    public static MemorySegment LAPACKE_dtrsen_work$address() {
        return LAPACKE_dtrsen_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dtrsen_work(int matrix_layout, char job, char compq, const int *select, int n, double *t, int ldt, double *q, int ldq, double *wr, double *wi, int *m, double *s, double *sep, double *work, int lwork, int *iwork, int liwork)
     * }
     */
    public static int LAPACKE_dtrsen_work(int matrix_layout, byte job, byte compq, MemorySegment select, int n, MemorySegment t, int ldt, MemorySegment q, int ldq, MemorySegment wr, MemorySegment wi, MemorySegment m, MemorySegment s, MemorySegment sep, MemorySegment work, int lwork, MemorySegment iwork, int liwork) {
        var mh$ = LAPACKE_dtrsen_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dtrsen_work", matrix_layout, job, compq, select, n, t, ldt, q, ldq, wr, wi, m, s, sep, work, lwork, iwork, liwork);
            }
            return (int)mh$.invokeExact(matrix_layout, job, compq, select, n, t, ldt, q, ldq, wr, wi, m, s, sep, work, lwork, iwork, liwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ctrsen_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_ctrsen_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ctrsen_work(int matrix_layout, char job, char compq, const int *select, int n, _Complex float *t, int ldt, _Complex float *q, int ldq, _Complex float *w, int *m, float *s, float *sep, _Complex float *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_ctrsen_work$descriptor() {
        return LAPACKE_ctrsen_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ctrsen_work(int matrix_layout, char job, char compq, const int *select, int n, _Complex float *t, int ldt, _Complex float *q, int ldq, _Complex float *w, int *m, float *s, float *sep, _Complex float *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_ctrsen_work$handle() {
        return LAPACKE_ctrsen_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ctrsen_work(int matrix_layout, char job, char compq, const int *select, int n, _Complex float *t, int ldt, _Complex float *q, int ldq, _Complex float *w, int *m, float *s, float *sep, _Complex float *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_ctrsen_work$address() {
        return LAPACKE_ctrsen_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ctrsen_work(int matrix_layout, char job, char compq, const int *select, int n, _Complex float *t, int ldt, _Complex float *q, int ldq, _Complex float *w, int *m, float *s, float *sep, _Complex float *work, int lwork)
     * }
     */
    public static int LAPACKE_ctrsen_work(int matrix_layout, byte job, byte compq, MemorySegment select, int n, MemorySegment t, int ldt, MemorySegment q, int ldq, MemorySegment w, MemorySegment m, MemorySegment s, MemorySegment sep, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_ctrsen_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ctrsen_work", matrix_layout, job, compq, select, n, t, ldt, q, ldq, w, m, s, sep, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, job, compq, select, n, t, ldt, q, ldq, w, m, s, sep, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ztrsen_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_ztrsen_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ztrsen_work(int matrix_layout, char job, char compq, const int *select, int n, _Complex double *t, int ldt, _Complex double *q, int ldq, _Complex double *w, int *m, double *s, double *sep, _Complex double *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_ztrsen_work$descriptor() {
        return LAPACKE_ztrsen_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ztrsen_work(int matrix_layout, char job, char compq, const int *select, int n, _Complex double *t, int ldt, _Complex double *q, int ldq, _Complex double *w, int *m, double *s, double *sep, _Complex double *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_ztrsen_work$handle() {
        return LAPACKE_ztrsen_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ztrsen_work(int matrix_layout, char job, char compq, const int *select, int n, _Complex double *t, int ldt, _Complex double *q, int ldq, _Complex double *w, int *m, double *s, double *sep, _Complex double *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_ztrsen_work$address() {
        return LAPACKE_ztrsen_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ztrsen_work(int matrix_layout, char job, char compq, const int *select, int n, _Complex double *t, int ldt, _Complex double *q, int ldq, _Complex double *w, int *m, double *s, double *sep, _Complex double *work, int lwork)
     * }
     */
    public static int LAPACKE_ztrsen_work(int matrix_layout, byte job, byte compq, MemorySegment select, int n, MemorySegment t, int ldt, MemorySegment q, int ldq, MemorySegment w, MemorySegment m, MemorySegment s, MemorySegment sep, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_ztrsen_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ztrsen_work", matrix_layout, job, compq, select, n, t, ldt, q, ldq, w, m, s, sep, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, job, compq, select, n, t, ldt, q, ldq, w, m, s, sep, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_strsna_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_strsna_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_strsna_work(int matrix_layout, char job, char howmny, const int *select, int n, const float *t, int ldt, const float *vl, int ldvl, const float *vr, int ldvr, float *s, float *sep, int mm, int *m, float *work, int ldwork, int *iwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_strsna_work$descriptor() {
        return LAPACKE_strsna_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_strsna_work(int matrix_layout, char job, char howmny, const int *select, int n, const float *t, int ldt, const float *vl, int ldvl, const float *vr, int ldvr, float *s, float *sep, int mm, int *m, float *work, int ldwork, int *iwork)
     * }
     */
    public static MethodHandle LAPACKE_strsna_work$handle() {
        return LAPACKE_strsna_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_strsna_work(int matrix_layout, char job, char howmny, const int *select, int n, const float *t, int ldt, const float *vl, int ldvl, const float *vr, int ldvr, float *s, float *sep, int mm, int *m, float *work, int ldwork, int *iwork)
     * }
     */
    public static MemorySegment LAPACKE_strsna_work$address() {
        return LAPACKE_strsna_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_strsna_work(int matrix_layout, char job, char howmny, const int *select, int n, const float *t, int ldt, const float *vl, int ldvl, const float *vr, int ldvr, float *s, float *sep, int mm, int *m, float *work, int ldwork, int *iwork)
     * }
     */
    public static int LAPACKE_strsna_work(int matrix_layout, byte job, byte howmny, MemorySegment select, int n, MemorySegment t, int ldt, MemorySegment vl, int ldvl, MemorySegment vr, int ldvr, MemorySegment s, MemorySegment sep, int mm, MemorySegment m, MemorySegment work, int ldwork, MemorySegment iwork) {
        var mh$ = LAPACKE_strsna_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_strsna_work", matrix_layout, job, howmny, select, n, t, ldt, vl, ldvl, vr, ldvr, s, sep, mm, m, work, ldwork, iwork);
            }
            return (int)mh$.invokeExact(matrix_layout, job, howmny, select, n, t, ldt, vl, ldvl, vr, ldvr, s, sep, mm, m, work, ldwork, iwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dtrsna_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dtrsna_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dtrsna_work(int matrix_layout, char job, char howmny, const int *select, int n, const double *t, int ldt, const double *vl, int ldvl, const double *vr, int ldvr, double *s, double *sep, int mm, int *m, double *work, int ldwork, int *iwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_dtrsna_work$descriptor() {
        return LAPACKE_dtrsna_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dtrsna_work(int matrix_layout, char job, char howmny, const int *select, int n, const double *t, int ldt, const double *vl, int ldvl, const double *vr, int ldvr, double *s, double *sep, int mm, int *m, double *work, int ldwork, int *iwork)
     * }
     */
    public static MethodHandle LAPACKE_dtrsna_work$handle() {
        return LAPACKE_dtrsna_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dtrsna_work(int matrix_layout, char job, char howmny, const int *select, int n, const double *t, int ldt, const double *vl, int ldvl, const double *vr, int ldvr, double *s, double *sep, int mm, int *m, double *work, int ldwork, int *iwork)
     * }
     */
    public static MemorySegment LAPACKE_dtrsna_work$address() {
        return LAPACKE_dtrsna_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dtrsna_work(int matrix_layout, char job, char howmny, const int *select, int n, const double *t, int ldt, const double *vl, int ldvl, const double *vr, int ldvr, double *s, double *sep, int mm, int *m, double *work, int ldwork, int *iwork)
     * }
     */
    public static int LAPACKE_dtrsna_work(int matrix_layout, byte job, byte howmny, MemorySegment select, int n, MemorySegment t, int ldt, MemorySegment vl, int ldvl, MemorySegment vr, int ldvr, MemorySegment s, MemorySegment sep, int mm, MemorySegment m, MemorySegment work, int ldwork, MemorySegment iwork) {
        var mh$ = LAPACKE_dtrsna_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dtrsna_work", matrix_layout, job, howmny, select, n, t, ldt, vl, ldvl, vr, ldvr, s, sep, mm, m, work, ldwork, iwork);
            }
            return (int)mh$.invokeExact(matrix_layout, job, howmny, select, n, t, ldt, vl, ldvl, vr, ldvr, s, sep, mm, m, work, ldwork, iwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ctrsna_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_ctrsna_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ctrsna_work(int matrix_layout, char job, char howmny, const int *select, int n, const _Complex float *t, int ldt, const _Complex float *vl, int ldvl, const _Complex float *vr, int ldvr, float *s, float *sep, int mm, int *m, _Complex float *work, int ldwork, float *rwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_ctrsna_work$descriptor() {
        return LAPACKE_ctrsna_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ctrsna_work(int matrix_layout, char job, char howmny, const int *select, int n, const _Complex float *t, int ldt, const _Complex float *vl, int ldvl, const _Complex float *vr, int ldvr, float *s, float *sep, int mm, int *m, _Complex float *work, int ldwork, float *rwork)
     * }
     */
    public static MethodHandle LAPACKE_ctrsna_work$handle() {
        return LAPACKE_ctrsna_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ctrsna_work(int matrix_layout, char job, char howmny, const int *select, int n, const _Complex float *t, int ldt, const _Complex float *vl, int ldvl, const _Complex float *vr, int ldvr, float *s, float *sep, int mm, int *m, _Complex float *work, int ldwork, float *rwork)
     * }
     */
    public static MemorySegment LAPACKE_ctrsna_work$address() {
        return LAPACKE_ctrsna_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ctrsna_work(int matrix_layout, char job, char howmny, const int *select, int n, const _Complex float *t, int ldt, const _Complex float *vl, int ldvl, const _Complex float *vr, int ldvr, float *s, float *sep, int mm, int *m, _Complex float *work, int ldwork, float *rwork)
     * }
     */
    public static int LAPACKE_ctrsna_work(int matrix_layout, byte job, byte howmny, MemorySegment select, int n, MemorySegment t, int ldt, MemorySegment vl, int ldvl, MemorySegment vr, int ldvr, MemorySegment s, MemorySegment sep, int mm, MemorySegment m, MemorySegment work, int ldwork, MemorySegment rwork) {
        var mh$ = LAPACKE_ctrsna_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ctrsna_work", matrix_layout, job, howmny, select, n, t, ldt, vl, ldvl, vr, ldvr, s, sep, mm, m, work, ldwork, rwork);
            }
            return (int)mh$.invokeExact(matrix_layout, job, howmny, select, n, t, ldt, vl, ldvl, vr, ldvr, s, sep, mm, m, work, ldwork, rwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ztrsna_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_ztrsna_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ztrsna_work(int matrix_layout, char job, char howmny, const int *select, int n, const _Complex double *t, int ldt, const _Complex double *vl, int ldvl, const _Complex double *vr, int ldvr, double *s, double *sep, int mm, int *m, _Complex double *work, int ldwork, double *rwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_ztrsna_work$descriptor() {
        return LAPACKE_ztrsna_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ztrsna_work(int matrix_layout, char job, char howmny, const int *select, int n, const _Complex double *t, int ldt, const _Complex double *vl, int ldvl, const _Complex double *vr, int ldvr, double *s, double *sep, int mm, int *m, _Complex double *work, int ldwork, double *rwork)
     * }
     */
    public static MethodHandle LAPACKE_ztrsna_work$handle() {
        return LAPACKE_ztrsna_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ztrsna_work(int matrix_layout, char job, char howmny, const int *select, int n, const _Complex double *t, int ldt, const _Complex double *vl, int ldvl, const _Complex double *vr, int ldvr, double *s, double *sep, int mm, int *m, _Complex double *work, int ldwork, double *rwork)
     * }
     */
    public static MemorySegment LAPACKE_ztrsna_work$address() {
        return LAPACKE_ztrsna_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ztrsna_work(int matrix_layout, char job, char howmny, const int *select, int n, const _Complex double *t, int ldt, const _Complex double *vl, int ldvl, const _Complex double *vr, int ldvr, double *s, double *sep, int mm, int *m, _Complex double *work, int ldwork, double *rwork)
     * }
     */
    public static int LAPACKE_ztrsna_work(int matrix_layout, byte job, byte howmny, MemorySegment select, int n, MemorySegment t, int ldt, MemorySegment vl, int ldvl, MemorySegment vr, int ldvr, MemorySegment s, MemorySegment sep, int mm, MemorySegment m, MemorySegment work, int ldwork, MemorySegment rwork) {
        var mh$ = LAPACKE_ztrsna_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ztrsna_work", matrix_layout, job, howmny, select, n, t, ldt, vl, ldvl, vr, ldvr, s, sep, mm, m, work, ldwork, rwork);
            }
            return (int)mh$.invokeExact(matrix_layout, job, howmny, select, n, t, ldt, vl, ldvl, vr, ldvr, s, sep, mm, m, work, ldwork, rwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_strsyl_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_strsyl_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_strsyl_work(int matrix_layout, char trana, char tranb, int isgn, int m, int n, const float *a, int lda, const float *b, int ldb, float *c, int ldc, float *scale)
     * }
     */
    public static FunctionDescriptor LAPACKE_strsyl_work$descriptor() {
        return LAPACKE_strsyl_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_strsyl_work(int matrix_layout, char trana, char tranb, int isgn, int m, int n, const float *a, int lda, const float *b, int ldb, float *c, int ldc, float *scale)
     * }
     */
    public static MethodHandle LAPACKE_strsyl_work$handle() {
        return LAPACKE_strsyl_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_strsyl_work(int matrix_layout, char trana, char tranb, int isgn, int m, int n, const float *a, int lda, const float *b, int ldb, float *c, int ldc, float *scale)
     * }
     */
    public static MemorySegment LAPACKE_strsyl_work$address() {
        return LAPACKE_strsyl_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_strsyl_work(int matrix_layout, char trana, char tranb, int isgn, int m, int n, const float *a, int lda, const float *b, int ldb, float *c, int ldc, float *scale)
     * }
     */
    public static int LAPACKE_strsyl_work(int matrix_layout, byte trana, byte tranb, int isgn, int m, int n, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment c, int ldc, MemorySegment scale) {
        var mh$ = LAPACKE_strsyl_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_strsyl_work", matrix_layout, trana, tranb, isgn, m, n, a, lda, b, ldb, c, ldc, scale);
            }
            return (int)mh$.invokeExact(matrix_layout, trana, tranb, isgn, m, n, a, lda, b, ldb, c, ldc, scale);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dtrsyl_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dtrsyl_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dtrsyl_work(int matrix_layout, char trana, char tranb, int isgn, int m, int n, const double *a, int lda, const double *b, int ldb, double *c, int ldc, double *scale)
     * }
     */
    public static FunctionDescriptor LAPACKE_dtrsyl_work$descriptor() {
        return LAPACKE_dtrsyl_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dtrsyl_work(int matrix_layout, char trana, char tranb, int isgn, int m, int n, const double *a, int lda, const double *b, int ldb, double *c, int ldc, double *scale)
     * }
     */
    public static MethodHandle LAPACKE_dtrsyl_work$handle() {
        return LAPACKE_dtrsyl_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dtrsyl_work(int matrix_layout, char trana, char tranb, int isgn, int m, int n, const double *a, int lda, const double *b, int ldb, double *c, int ldc, double *scale)
     * }
     */
    public static MemorySegment LAPACKE_dtrsyl_work$address() {
        return LAPACKE_dtrsyl_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dtrsyl_work(int matrix_layout, char trana, char tranb, int isgn, int m, int n, const double *a, int lda, const double *b, int ldb, double *c, int ldc, double *scale)
     * }
     */
    public static int LAPACKE_dtrsyl_work(int matrix_layout, byte trana, byte tranb, int isgn, int m, int n, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment c, int ldc, MemorySegment scale) {
        var mh$ = LAPACKE_dtrsyl_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dtrsyl_work", matrix_layout, trana, tranb, isgn, m, n, a, lda, b, ldb, c, ldc, scale);
            }
            return (int)mh$.invokeExact(matrix_layout, trana, tranb, isgn, m, n, a, lda, b, ldb, c, ldc, scale);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ctrsyl_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_ctrsyl_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ctrsyl_work(int matrix_layout, char trana, char tranb, int isgn, int m, int n, const _Complex float *a, int lda, const _Complex float *b, int ldb, _Complex float *c, int ldc, float *scale)
     * }
     */
    public static FunctionDescriptor LAPACKE_ctrsyl_work$descriptor() {
        return LAPACKE_ctrsyl_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ctrsyl_work(int matrix_layout, char trana, char tranb, int isgn, int m, int n, const _Complex float *a, int lda, const _Complex float *b, int ldb, _Complex float *c, int ldc, float *scale)
     * }
     */
    public static MethodHandle LAPACKE_ctrsyl_work$handle() {
        return LAPACKE_ctrsyl_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ctrsyl_work(int matrix_layout, char trana, char tranb, int isgn, int m, int n, const _Complex float *a, int lda, const _Complex float *b, int ldb, _Complex float *c, int ldc, float *scale)
     * }
     */
    public static MemorySegment LAPACKE_ctrsyl_work$address() {
        return LAPACKE_ctrsyl_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ctrsyl_work(int matrix_layout, char trana, char tranb, int isgn, int m, int n, const _Complex float *a, int lda, const _Complex float *b, int ldb, _Complex float *c, int ldc, float *scale)
     * }
     */
    public static int LAPACKE_ctrsyl_work(int matrix_layout, byte trana, byte tranb, int isgn, int m, int n, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment c, int ldc, MemorySegment scale) {
        var mh$ = LAPACKE_ctrsyl_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ctrsyl_work", matrix_layout, trana, tranb, isgn, m, n, a, lda, b, ldb, c, ldc, scale);
            }
            return (int)mh$.invokeExact(matrix_layout, trana, tranb, isgn, m, n, a, lda, b, ldb, c, ldc, scale);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ztrsyl_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_ztrsyl_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ztrsyl_work(int matrix_layout, char trana, char tranb, int isgn, int m, int n, const _Complex double *a, int lda, const _Complex double *b, int ldb, _Complex double *c, int ldc, double *scale)
     * }
     */
    public static FunctionDescriptor LAPACKE_ztrsyl_work$descriptor() {
        return LAPACKE_ztrsyl_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ztrsyl_work(int matrix_layout, char trana, char tranb, int isgn, int m, int n, const _Complex double *a, int lda, const _Complex double *b, int ldb, _Complex double *c, int ldc, double *scale)
     * }
     */
    public static MethodHandle LAPACKE_ztrsyl_work$handle() {
        return LAPACKE_ztrsyl_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ztrsyl_work(int matrix_layout, char trana, char tranb, int isgn, int m, int n, const _Complex double *a, int lda, const _Complex double *b, int ldb, _Complex double *c, int ldc, double *scale)
     * }
     */
    public static MemorySegment LAPACKE_ztrsyl_work$address() {
        return LAPACKE_ztrsyl_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ztrsyl_work(int matrix_layout, char trana, char tranb, int isgn, int m, int n, const _Complex double *a, int lda, const _Complex double *b, int ldb, _Complex double *c, int ldc, double *scale)
     * }
     */
    public static int LAPACKE_ztrsyl_work(int matrix_layout, byte trana, byte tranb, int isgn, int m, int n, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment c, int ldc, MemorySegment scale) {
        var mh$ = LAPACKE_ztrsyl_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ztrsyl_work", matrix_layout, trana, tranb, isgn, m, n, a, lda, b, ldb, c, ldc, scale);
            }
            return (int)mh$.invokeExact(matrix_layout, trana, tranb, isgn, m, n, a, lda, b, ldb, c, ldc, scale);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_strtri_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_strtri_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_strtri_work(int matrix_layout, char uplo, char diag, int n, float *a, int lda)
     * }
     */
    public static FunctionDescriptor LAPACKE_strtri_work$descriptor() {
        return LAPACKE_strtri_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_strtri_work(int matrix_layout, char uplo, char diag, int n, float *a, int lda)
     * }
     */
    public static MethodHandle LAPACKE_strtri_work$handle() {
        return LAPACKE_strtri_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_strtri_work(int matrix_layout, char uplo, char diag, int n, float *a, int lda)
     * }
     */
    public static MemorySegment LAPACKE_strtri_work$address() {
        return LAPACKE_strtri_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_strtri_work(int matrix_layout, char uplo, char diag, int n, float *a, int lda)
     * }
     */
    public static int LAPACKE_strtri_work(int matrix_layout, byte uplo, byte diag, int n, MemorySegment a, int lda) {
        var mh$ = LAPACKE_strtri_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_strtri_work", matrix_layout, uplo, diag, n, a, lda);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, diag, n, a, lda);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dtrtri_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dtrtri_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dtrtri_work(int matrix_layout, char uplo, char diag, int n, double *a, int lda)
     * }
     */
    public static FunctionDescriptor LAPACKE_dtrtri_work$descriptor() {
        return LAPACKE_dtrtri_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dtrtri_work(int matrix_layout, char uplo, char diag, int n, double *a, int lda)
     * }
     */
    public static MethodHandle LAPACKE_dtrtri_work$handle() {
        return LAPACKE_dtrtri_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dtrtri_work(int matrix_layout, char uplo, char diag, int n, double *a, int lda)
     * }
     */
    public static MemorySegment LAPACKE_dtrtri_work$address() {
        return LAPACKE_dtrtri_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dtrtri_work(int matrix_layout, char uplo, char diag, int n, double *a, int lda)
     * }
     */
    public static int LAPACKE_dtrtri_work(int matrix_layout, byte uplo, byte diag, int n, MemorySegment a, int lda) {
        var mh$ = LAPACKE_dtrtri_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dtrtri_work", matrix_layout, uplo, diag, n, a, lda);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, diag, n, a, lda);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ctrtri_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_ctrtri_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ctrtri_work(int matrix_layout, char uplo, char diag, int n, _Complex float *a, int lda)
     * }
     */
    public static FunctionDescriptor LAPACKE_ctrtri_work$descriptor() {
        return LAPACKE_ctrtri_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ctrtri_work(int matrix_layout, char uplo, char diag, int n, _Complex float *a, int lda)
     * }
     */
    public static MethodHandle LAPACKE_ctrtri_work$handle() {
        return LAPACKE_ctrtri_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ctrtri_work(int matrix_layout, char uplo, char diag, int n, _Complex float *a, int lda)
     * }
     */
    public static MemorySegment LAPACKE_ctrtri_work$address() {
        return LAPACKE_ctrtri_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ctrtri_work(int matrix_layout, char uplo, char diag, int n, _Complex float *a, int lda)
     * }
     */
    public static int LAPACKE_ctrtri_work(int matrix_layout, byte uplo, byte diag, int n, MemorySegment a, int lda) {
        var mh$ = LAPACKE_ctrtri_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ctrtri_work", matrix_layout, uplo, diag, n, a, lda);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, diag, n, a, lda);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ztrtri_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_ztrtri_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ztrtri_work(int matrix_layout, char uplo, char diag, int n, _Complex double *a, int lda)
     * }
     */
    public static FunctionDescriptor LAPACKE_ztrtri_work$descriptor() {
        return LAPACKE_ztrtri_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ztrtri_work(int matrix_layout, char uplo, char diag, int n, _Complex double *a, int lda)
     * }
     */
    public static MethodHandle LAPACKE_ztrtri_work$handle() {
        return LAPACKE_ztrtri_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ztrtri_work(int matrix_layout, char uplo, char diag, int n, _Complex double *a, int lda)
     * }
     */
    public static MemorySegment LAPACKE_ztrtri_work$address() {
        return LAPACKE_ztrtri_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ztrtri_work(int matrix_layout, char uplo, char diag, int n, _Complex double *a, int lda)
     * }
     */
    public static int LAPACKE_ztrtri_work(int matrix_layout, byte uplo, byte diag, int n, MemorySegment a, int lda) {
        var mh$ = LAPACKE_ztrtri_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ztrtri_work", matrix_layout, uplo, diag, n, a, lda);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, diag, n, a, lda);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_strtrs_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_strtrs_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_strtrs_work(int matrix_layout, char uplo, char trans, char diag, int n, int nrhs, const float *a, int lda, float *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_strtrs_work$descriptor() {
        return LAPACKE_strtrs_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_strtrs_work(int matrix_layout, char uplo, char trans, char diag, int n, int nrhs, const float *a, int lda, float *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_strtrs_work$handle() {
        return LAPACKE_strtrs_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_strtrs_work(int matrix_layout, char uplo, char trans, char diag, int n, int nrhs, const float *a, int lda, float *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_strtrs_work$address() {
        return LAPACKE_strtrs_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_strtrs_work(int matrix_layout, char uplo, char trans, char diag, int n, int nrhs, const float *a, int lda, float *b, int ldb)
     * }
     */
    public static int LAPACKE_strtrs_work(int matrix_layout, byte uplo, byte trans, byte diag, int n, int nrhs, MemorySegment a, int lda, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_strtrs_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_strtrs_work", matrix_layout, uplo, trans, diag, n, nrhs, a, lda, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, trans, diag, n, nrhs, a, lda, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dtrtrs_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dtrtrs_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dtrtrs_work(int matrix_layout, char uplo, char trans, char diag, int n, int nrhs, const double *a, int lda, double *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_dtrtrs_work$descriptor() {
        return LAPACKE_dtrtrs_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dtrtrs_work(int matrix_layout, char uplo, char trans, char diag, int n, int nrhs, const double *a, int lda, double *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_dtrtrs_work$handle() {
        return LAPACKE_dtrtrs_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dtrtrs_work(int matrix_layout, char uplo, char trans, char diag, int n, int nrhs, const double *a, int lda, double *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_dtrtrs_work$address() {
        return LAPACKE_dtrtrs_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dtrtrs_work(int matrix_layout, char uplo, char trans, char diag, int n, int nrhs, const double *a, int lda, double *b, int ldb)
     * }
     */
    public static int LAPACKE_dtrtrs_work(int matrix_layout, byte uplo, byte trans, byte diag, int n, int nrhs, MemorySegment a, int lda, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_dtrtrs_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dtrtrs_work", matrix_layout, uplo, trans, diag, n, nrhs, a, lda, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, trans, diag, n, nrhs, a, lda, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ctrtrs_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_ctrtrs_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ctrtrs_work(int matrix_layout, char uplo, char trans, char diag, int n, int nrhs, const _Complex float *a, int lda, _Complex float *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_ctrtrs_work$descriptor() {
        return LAPACKE_ctrtrs_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ctrtrs_work(int matrix_layout, char uplo, char trans, char diag, int n, int nrhs, const _Complex float *a, int lda, _Complex float *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_ctrtrs_work$handle() {
        return LAPACKE_ctrtrs_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ctrtrs_work(int matrix_layout, char uplo, char trans, char diag, int n, int nrhs, const _Complex float *a, int lda, _Complex float *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_ctrtrs_work$address() {
        return LAPACKE_ctrtrs_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ctrtrs_work(int matrix_layout, char uplo, char trans, char diag, int n, int nrhs, const _Complex float *a, int lda, _Complex float *b, int ldb)
     * }
     */
    public static int LAPACKE_ctrtrs_work(int matrix_layout, byte uplo, byte trans, byte diag, int n, int nrhs, MemorySegment a, int lda, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_ctrtrs_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ctrtrs_work", matrix_layout, uplo, trans, diag, n, nrhs, a, lda, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, trans, diag, n, nrhs, a, lda, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ztrtrs_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_ztrtrs_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ztrtrs_work(int matrix_layout, char uplo, char trans, char diag, int n, int nrhs, const _Complex double *a, int lda, _Complex double *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_ztrtrs_work$descriptor() {
        return LAPACKE_ztrtrs_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ztrtrs_work(int matrix_layout, char uplo, char trans, char diag, int n, int nrhs, const _Complex double *a, int lda, _Complex double *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_ztrtrs_work$handle() {
        return LAPACKE_ztrtrs_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ztrtrs_work(int matrix_layout, char uplo, char trans, char diag, int n, int nrhs, const _Complex double *a, int lda, _Complex double *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_ztrtrs_work$address() {
        return LAPACKE_ztrtrs_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ztrtrs_work(int matrix_layout, char uplo, char trans, char diag, int n, int nrhs, const _Complex double *a, int lda, _Complex double *b, int ldb)
     * }
     */
    public static int LAPACKE_ztrtrs_work(int matrix_layout, byte uplo, byte trans, byte diag, int n, int nrhs, MemorySegment a, int lda, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_ztrtrs_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ztrtrs_work", matrix_layout, uplo, trans, diag, n, nrhs, a, lda, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, trans, diag, n, nrhs, a, lda, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_strttf_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_strttf_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_strttf_work(int matrix_layout, char transr, char uplo, int n, const float *a, int lda, float *arf)
     * }
     */
    public static FunctionDescriptor LAPACKE_strttf_work$descriptor() {
        return LAPACKE_strttf_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_strttf_work(int matrix_layout, char transr, char uplo, int n, const float *a, int lda, float *arf)
     * }
     */
    public static MethodHandle LAPACKE_strttf_work$handle() {
        return LAPACKE_strttf_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_strttf_work(int matrix_layout, char transr, char uplo, int n, const float *a, int lda, float *arf)
     * }
     */
    public static MemorySegment LAPACKE_strttf_work$address() {
        return LAPACKE_strttf_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_strttf_work(int matrix_layout, char transr, char uplo, int n, const float *a, int lda, float *arf)
     * }
     */
    public static int LAPACKE_strttf_work(int matrix_layout, byte transr, byte uplo, int n, MemorySegment a, int lda, MemorySegment arf) {
        var mh$ = LAPACKE_strttf_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_strttf_work", matrix_layout, transr, uplo, n, a, lda, arf);
            }
            return (int)mh$.invokeExact(matrix_layout, transr, uplo, n, a, lda, arf);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dtrttf_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dtrttf_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dtrttf_work(int matrix_layout, char transr, char uplo, int n, const double *a, int lda, double *arf)
     * }
     */
    public static FunctionDescriptor LAPACKE_dtrttf_work$descriptor() {
        return LAPACKE_dtrttf_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dtrttf_work(int matrix_layout, char transr, char uplo, int n, const double *a, int lda, double *arf)
     * }
     */
    public static MethodHandle LAPACKE_dtrttf_work$handle() {
        return LAPACKE_dtrttf_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dtrttf_work(int matrix_layout, char transr, char uplo, int n, const double *a, int lda, double *arf)
     * }
     */
    public static MemorySegment LAPACKE_dtrttf_work$address() {
        return LAPACKE_dtrttf_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dtrttf_work(int matrix_layout, char transr, char uplo, int n, const double *a, int lda, double *arf)
     * }
     */
    public static int LAPACKE_dtrttf_work(int matrix_layout, byte transr, byte uplo, int n, MemorySegment a, int lda, MemorySegment arf) {
        var mh$ = LAPACKE_dtrttf_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dtrttf_work", matrix_layout, transr, uplo, n, a, lda, arf);
            }
            return (int)mh$.invokeExact(matrix_layout, transr, uplo, n, a, lda, arf);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ctrttf_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_ctrttf_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ctrttf_work(int matrix_layout, char transr, char uplo, int n, const _Complex float *a, int lda, _Complex float *arf)
     * }
     */
    public static FunctionDescriptor LAPACKE_ctrttf_work$descriptor() {
        return LAPACKE_ctrttf_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ctrttf_work(int matrix_layout, char transr, char uplo, int n, const _Complex float *a, int lda, _Complex float *arf)
     * }
     */
    public static MethodHandle LAPACKE_ctrttf_work$handle() {
        return LAPACKE_ctrttf_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ctrttf_work(int matrix_layout, char transr, char uplo, int n, const _Complex float *a, int lda, _Complex float *arf)
     * }
     */
    public static MemorySegment LAPACKE_ctrttf_work$address() {
        return LAPACKE_ctrttf_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ctrttf_work(int matrix_layout, char transr, char uplo, int n, const _Complex float *a, int lda, _Complex float *arf)
     * }
     */
    public static int LAPACKE_ctrttf_work(int matrix_layout, byte transr, byte uplo, int n, MemorySegment a, int lda, MemorySegment arf) {
        var mh$ = LAPACKE_ctrttf_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ctrttf_work", matrix_layout, transr, uplo, n, a, lda, arf);
            }
            return (int)mh$.invokeExact(matrix_layout, transr, uplo, n, a, lda, arf);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ztrttf_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_ztrttf_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ztrttf_work(int matrix_layout, char transr, char uplo, int n, const _Complex double *a, int lda, _Complex double *arf)
     * }
     */
    public static FunctionDescriptor LAPACKE_ztrttf_work$descriptor() {
        return LAPACKE_ztrttf_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ztrttf_work(int matrix_layout, char transr, char uplo, int n, const _Complex double *a, int lda, _Complex double *arf)
     * }
     */
    public static MethodHandle LAPACKE_ztrttf_work$handle() {
        return LAPACKE_ztrttf_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ztrttf_work(int matrix_layout, char transr, char uplo, int n, const _Complex double *a, int lda, _Complex double *arf)
     * }
     */
    public static MemorySegment LAPACKE_ztrttf_work$address() {
        return LAPACKE_ztrttf_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ztrttf_work(int matrix_layout, char transr, char uplo, int n, const _Complex double *a, int lda, _Complex double *arf)
     * }
     */
    public static int LAPACKE_ztrttf_work(int matrix_layout, byte transr, byte uplo, int n, MemorySegment a, int lda, MemorySegment arf) {
        var mh$ = LAPACKE_ztrttf_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ztrttf_work", matrix_layout, transr, uplo, n, a, lda, arf);
            }
            return (int)mh$.invokeExact(matrix_layout, transr, uplo, n, a, lda, arf);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_strttp_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_strttp_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_strttp_work(int matrix_layout, char uplo, int n, const float *a, int lda, float *ap)
     * }
     */
    public static FunctionDescriptor LAPACKE_strttp_work$descriptor() {
        return LAPACKE_strttp_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_strttp_work(int matrix_layout, char uplo, int n, const float *a, int lda, float *ap)
     * }
     */
    public static MethodHandle LAPACKE_strttp_work$handle() {
        return LAPACKE_strttp_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_strttp_work(int matrix_layout, char uplo, int n, const float *a, int lda, float *ap)
     * }
     */
    public static MemorySegment LAPACKE_strttp_work$address() {
        return LAPACKE_strttp_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_strttp_work(int matrix_layout, char uplo, int n, const float *a, int lda, float *ap)
     * }
     */
    public static int LAPACKE_strttp_work(int matrix_layout, byte uplo, int n, MemorySegment a, int lda, MemorySegment ap) {
        var mh$ = LAPACKE_strttp_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_strttp_work", matrix_layout, uplo, n, a, lda, ap);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, a, lda, ap);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dtrttp_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dtrttp_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dtrttp_work(int matrix_layout, char uplo, int n, const double *a, int lda, double *ap)
     * }
     */
    public static FunctionDescriptor LAPACKE_dtrttp_work$descriptor() {
        return LAPACKE_dtrttp_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dtrttp_work(int matrix_layout, char uplo, int n, const double *a, int lda, double *ap)
     * }
     */
    public static MethodHandle LAPACKE_dtrttp_work$handle() {
        return LAPACKE_dtrttp_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dtrttp_work(int matrix_layout, char uplo, int n, const double *a, int lda, double *ap)
     * }
     */
    public static MemorySegment LAPACKE_dtrttp_work$address() {
        return LAPACKE_dtrttp_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dtrttp_work(int matrix_layout, char uplo, int n, const double *a, int lda, double *ap)
     * }
     */
    public static int LAPACKE_dtrttp_work(int matrix_layout, byte uplo, int n, MemorySegment a, int lda, MemorySegment ap) {
        var mh$ = LAPACKE_dtrttp_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dtrttp_work", matrix_layout, uplo, n, a, lda, ap);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, a, lda, ap);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ctrttp_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_ctrttp_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ctrttp_work(int matrix_layout, char uplo, int n, const _Complex float *a, int lda, _Complex float *ap)
     * }
     */
    public static FunctionDescriptor LAPACKE_ctrttp_work$descriptor() {
        return LAPACKE_ctrttp_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ctrttp_work(int matrix_layout, char uplo, int n, const _Complex float *a, int lda, _Complex float *ap)
     * }
     */
    public static MethodHandle LAPACKE_ctrttp_work$handle() {
        return LAPACKE_ctrttp_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ctrttp_work(int matrix_layout, char uplo, int n, const _Complex float *a, int lda, _Complex float *ap)
     * }
     */
    public static MemorySegment LAPACKE_ctrttp_work$address() {
        return LAPACKE_ctrttp_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ctrttp_work(int matrix_layout, char uplo, int n, const _Complex float *a, int lda, _Complex float *ap)
     * }
     */
    public static int LAPACKE_ctrttp_work(int matrix_layout, byte uplo, int n, MemorySegment a, int lda, MemorySegment ap) {
        var mh$ = LAPACKE_ctrttp_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ctrttp_work", matrix_layout, uplo, n, a, lda, ap);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, a, lda, ap);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ztrttp_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_ztrttp_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ztrttp_work(int matrix_layout, char uplo, int n, const _Complex double *a, int lda, _Complex double *ap)
     * }
     */
    public static FunctionDescriptor LAPACKE_ztrttp_work$descriptor() {
        return LAPACKE_ztrttp_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ztrttp_work(int matrix_layout, char uplo, int n, const _Complex double *a, int lda, _Complex double *ap)
     * }
     */
    public static MethodHandle LAPACKE_ztrttp_work$handle() {
        return LAPACKE_ztrttp_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ztrttp_work(int matrix_layout, char uplo, int n, const _Complex double *a, int lda, _Complex double *ap)
     * }
     */
    public static MemorySegment LAPACKE_ztrttp_work$address() {
        return LAPACKE_ztrttp_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ztrttp_work(int matrix_layout, char uplo, int n, const _Complex double *a, int lda, _Complex double *ap)
     * }
     */
    public static int LAPACKE_ztrttp_work(int matrix_layout, byte uplo, int n, MemorySegment a, int lda, MemorySegment ap) {
        var mh$ = LAPACKE_ztrttp_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ztrttp_work", matrix_layout, uplo, n, a, lda, ap);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, a, lda, ap);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_stzrzf_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_stzrzf_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_stzrzf_work(int matrix_layout, int m, int n, float *a, int lda, float *tau, float *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_stzrzf_work$descriptor() {
        return LAPACKE_stzrzf_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_stzrzf_work(int matrix_layout, int m, int n, float *a, int lda, float *tau, float *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_stzrzf_work$handle() {
        return LAPACKE_stzrzf_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_stzrzf_work(int matrix_layout, int m, int n, float *a, int lda, float *tau, float *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_stzrzf_work$address() {
        return LAPACKE_stzrzf_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_stzrzf_work(int matrix_layout, int m, int n, float *a, int lda, float *tau, float *work, int lwork)
     * }
     */
    public static int LAPACKE_stzrzf_work(int matrix_layout, int m, int n, MemorySegment a, int lda, MemorySegment tau, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_stzrzf_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_stzrzf_work", matrix_layout, m, n, a, lda, tau, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, a, lda, tau, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dtzrzf_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dtzrzf_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dtzrzf_work(int matrix_layout, int m, int n, double *a, int lda, double *tau, double *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_dtzrzf_work$descriptor() {
        return LAPACKE_dtzrzf_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dtzrzf_work(int matrix_layout, int m, int n, double *a, int lda, double *tau, double *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_dtzrzf_work$handle() {
        return LAPACKE_dtzrzf_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dtzrzf_work(int matrix_layout, int m, int n, double *a, int lda, double *tau, double *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_dtzrzf_work$address() {
        return LAPACKE_dtzrzf_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dtzrzf_work(int matrix_layout, int m, int n, double *a, int lda, double *tau, double *work, int lwork)
     * }
     */
    public static int LAPACKE_dtzrzf_work(int matrix_layout, int m, int n, MemorySegment a, int lda, MemorySegment tau, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_dtzrzf_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dtzrzf_work", matrix_layout, m, n, a, lda, tau, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, a, lda, tau, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ctzrzf_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_ctzrzf_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ctzrzf_work(int matrix_layout, int m, int n, _Complex float *a, int lda, _Complex float *tau, _Complex float *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_ctzrzf_work$descriptor() {
        return LAPACKE_ctzrzf_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ctzrzf_work(int matrix_layout, int m, int n, _Complex float *a, int lda, _Complex float *tau, _Complex float *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_ctzrzf_work$handle() {
        return LAPACKE_ctzrzf_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ctzrzf_work(int matrix_layout, int m, int n, _Complex float *a, int lda, _Complex float *tau, _Complex float *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_ctzrzf_work$address() {
        return LAPACKE_ctzrzf_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ctzrzf_work(int matrix_layout, int m, int n, _Complex float *a, int lda, _Complex float *tau, _Complex float *work, int lwork)
     * }
     */
    public static int LAPACKE_ctzrzf_work(int matrix_layout, int m, int n, MemorySegment a, int lda, MemorySegment tau, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_ctzrzf_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ctzrzf_work", matrix_layout, m, n, a, lda, tau, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, a, lda, tau, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ztzrzf_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_ztzrzf_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ztzrzf_work(int matrix_layout, int m, int n, _Complex double *a, int lda, _Complex double *tau, _Complex double *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_ztzrzf_work$descriptor() {
        return LAPACKE_ztzrzf_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ztzrzf_work(int matrix_layout, int m, int n, _Complex double *a, int lda, _Complex double *tau, _Complex double *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_ztzrzf_work$handle() {
        return LAPACKE_ztzrzf_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ztzrzf_work(int matrix_layout, int m, int n, _Complex double *a, int lda, _Complex double *tau, _Complex double *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_ztzrzf_work$address() {
        return LAPACKE_ztzrzf_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ztzrzf_work(int matrix_layout, int m, int n, _Complex double *a, int lda, _Complex double *tau, _Complex double *work, int lwork)
     * }
     */
    public static int LAPACKE_ztzrzf_work(int matrix_layout, int m, int n, MemorySegment a, int lda, MemorySegment tau, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_ztzrzf_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ztzrzf_work", matrix_layout, m, n, a, lda, tau, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, a, lda, tau, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cungbr_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_cungbr_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cungbr_work(int matrix_layout, char vect, int m, int n, int k, _Complex float *a, int lda, const _Complex float *tau, _Complex float *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_cungbr_work$descriptor() {
        return LAPACKE_cungbr_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cungbr_work(int matrix_layout, char vect, int m, int n, int k, _Complex float *a, int lda, const _Complex float *tau, _Complex float *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_cungbr_work$handle() {
        return LAPACKE_cungbr_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cungbr_work(int matrix_layout, char vect, int m, int n, int k, _Complex float *a, int lda, const _Complex float *tau, _Complex float *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_cungbr_work$address() {
        return LAPACKE_cungbr_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cungbr_work(int matrix_layout, char vect, int m, int n, int k, _Complex float *a, int lda, const _Complex float *tau, _Complex float *work, int lwork)
     * }
     */
    public static int LAPACKE_cungbr_work(int matrix_layout, byte vect, int m, int n, int k, MemorySegment a, int lda, MemorySegment tau, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_cungbr_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cungbr_work", matrix_layout, vect, m, n, k, a, lda, tau, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, vect, m, n, k, a, lda, tau, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zungbr_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zungbr_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zungbr_work(int matrix_layout, char vect, int m, int n, int k, _Complex double *a, int lda, const _Complex double *tau, _Complex double *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_zungbr_work$descriptor() {
        return LAPACKE_zungbr_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zungbr_work(int matrix_layout, char vect, int m, int n, int k, _Complex double *a, int lda, const _Complex double *tau, _Complex double *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_zungbr_work$handle() {
        return LAPACKE_zungbr_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zungbr_work(int matrix_layout, char vect, int m, int n, int k, _Complex double *a, int lda, const _Complex double *tau, _Complex double *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_zungbr_work$address() {
        return LAPACKE_zungbr_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zungbr_work(int matrix_layout, char vect, int m, int n, int k, _Complex double *a, int lda, const _Complex double *tau, _Complex double *work, int lwork)
     * }
     */
    public static int LAPACKE_zungbr_work(int matrix_layout, byte vect, int m, int n, int k, MemorySegment a, int lda, MemorySegment tau, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_zungbr_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zungbr_work", matrix_layout, vect, m, n, k, a, lda, tau, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, vect, m, n, k, a, lda, tau, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cunghr_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_cunghr_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cunghr_work(int matrix_layout, int n, int ilo, int ihi, _Complex float *a, int lda, const _Complex float *tau, _Complex float *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_cunghr_work$descriptor() {
        return LAPACKE_cunghr_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cunghr_work(int matrix_layout, int n, int ilo, int ihi, _Complex float *a, int lda, const _Complex float *tau, _Complex float *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_cunghr_work$handle() {
        return LAPACKE_cunghr_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cunghr_work(int matrix_layout, int n, int ilo, int ihi, _Complex float *a, int lda, const _Complex float *tau, _Complex float *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_cunghr_work$address() {
        return LAPACKE_cunghr_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cunghr_work(int matrix_layout, int n, int ilo, int ihi, _Complex float *a, int lda, const _Complex float *tau, _Complex float *work, int lwork)
     * }
     */
    public static int LAPACKE_cunghr_work(int matrix_layout, int n, int ilo, int ihi, MemorySegment a, int lda, MemorySegment tau, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_cunghr_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cunghr_work", matrix_layout, n, ilo, ihi, a, lda, tau, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, n, ilo, ihi, a, lda, tau, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zunghr_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zunghr_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zunghr_work(int matrix_layout, int n, int ilo, int ihi, _Complex double *a, int lda, const _Complex double *tau, _Complex double *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_zunghr_work$descriptor() {
        return LAPACKE_zunghr_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zunghr_work(int matrix_layout, int n, int ilo, int ihi, _Complex double *a, int lda, const _Complex double *tau, _Complex double *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_zunghr_work$handle() {
        return LAPACKE_zunghr_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zunghr_work(int matrix_layout, int n, int ilo, int ihi, _Complex double *a, int lda, const _Complex double *tau, _Complex double *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_zunghr_work$address() {
        return LAPACKE_zunghr_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zunghr_work(int matrix_layout, int n, int ilo, int ihi, _Complex double *a, int lda, const _Complex double *tau, _Complex double *work, int lwork)
     * }
     */
    public static int LAPACKE_zunghr_work(int matrix_layout, int n, int ilo, int ihi, MemorySegment a, int lda, MemorySegment tau, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_zunghr_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zunghr_work", matrix_layout, n, ilo, ihi, a, lda, tau, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, n, ilo, ihi, a, lda, tau, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cunglq_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_cunglq_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cunglq_work(int matrix_layout, int m, int n, int k, _Complex float *a, int lda, const _Complex float *tau, _Complex float *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_cunglq_work$descriptor() {
        return LAPACKE_cunglq_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cunglq_work(int matrix_layout, int m, int n, int k, _Complex float *a, int lda, const _Complex float *tau, _Complex float *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_cunglq_work$handle() {
        return LAPACKE_cunglq_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cunglq_work(int matrix_layout, int m, int n, int k, _Complex float *a, int lda, const _Complex float *tau, _Complex float *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_cunglq_work$address() {
        return LAPACKE_cunglq_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cunglq_work(int matrix_layout, int m, int n, int k, _Complex float *a, int lda, const _Complex float *tau, _Complex float *work, int lwork)
     * }
     */
    public static int LAPACKE_cunglq_work(int matrix_layout, int m, int n, int k, MemorySegment a, int lda, MemorySegment tau, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_cunglq_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cunglq_work", matrix_layout, m, n, k, a, lda, tau, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, k, a, lda, tau, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zunglq_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zunglq_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zunglq_work(int matrix_layout, int m, int n, int k, _Complex double *a, int lda, const _Complex double *tau, _Complex double *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_zunglq_work$descriptor() {
        return LAPACKE_zunglq_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zunglq_work(int matrix_layout, int m, int n, int k, _Complex double *a, int lda, const _Complex double *tau, _Complex double *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_zunglq_work$handle() {
        return LAPACKE_zunglq_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zunglq_work(int matrix_layout, int m, int n, int k, _Complex double *a, int lda, const _Complex double *tau, _Complex double *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_zunglq_work$address() {
        return LAPACKE_zunglq_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zunglq_work(int matrix_layout, int m, int n, int k, _Complex double *a, int lda, const _Complex double *tau, _Complex double *work, int lwork)
     * }
     */
    public static int LAPACKE_zunglq_work(int matrix_layout, int m, int n, int k, MemorySegment a, int lda, MemorySegment tau, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_zunglq_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zunglq_work", matrix_layout, m, n, k, a, lda, tau, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, k, a, lda, tau, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cungql_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_cungql_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cungql_work(int matrix_layout, int m, int n, int k, _Complex float *a, int lda, const _Complex float *tau, _Complex float *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_cungql_work$descriptor() {
        return LAPACKE_cungql_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cungql_work(int matrix_layout, int m, int n, int k, _Complex float *a, int lda, const _Complex float *tau, _Complex float *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_cungql_work$handle() {
        return LAPACKE_cungql_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cungql_work(int matrix_layout, int m, int n, int k, _Complex float *a, int lda, const _Complex float *tau, _Complex float *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_cungql_work$address() {
        return LAPACKE_cungql_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cungql_work(int matrix_layout, int m, int n, int k, _Complex float *a, int lda, const _Complex float *tau, _Complex float *work, int lwork)
     * }
     */
    public static int LAPACKE_cungql_work(int matrix_layout, int m, int n, int k, MemorySegment a, int lda, MemorySegment tau, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_cungql_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cungql_work", matrix_layout, m, n, k, a, lda, tau, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, k, a, lda, tau, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zungql_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zungql_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zungql_work(int matrix_layout, int m, int n, int k, _Complex double *a, int lda, const _Complex double *tau, _Complex double *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_zungql_work$descriptor() {
        return LAPACKE_zungql_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zungql_work(int matrix_layout, int m, int n, int k, _Complex double *a, int lda, const _Complex double *tau, _Complex double *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_zungql_work$handle() {
        return LAPACKE_zungql_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zungql_work(int matrix_layout, int m, int n, int k, _Complex double *a, int lda, const _Complex double *tau, _Complex double *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_zungql_work$address() {
        return LAPACKE_zungql_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zungql_work(int matrix_layout, int m, int n, int k, _Complex double *a, int lda, const _Complex double *tau, _Complex double *work, int lwork)
     * }
     */
    public static int LAPACKE_zungql_work(int matrix_layout, int m, int n, int k, MemorySegment a, int lda, MemorySegment tau, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_zungql_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zungql_work", matrix_layout, m, n, k, a, lda, tau, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, k, a, lda, tau, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cungqr_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_cungqr_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cungqr_work(int matrix_layout, int m, int n, int k, _Complex float *a, int lda, const _Complex float *tau, _Complex float *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_cungqr_work$descriptor() {
        return LAPACKE_cungqr_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cungqr_work(int matrix_layout, int m, int n, int k, _Complex float *a, int lda, const _Complex float *tau, _Complex float *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_cungqr_work$handle() {
        return LAPACKE_cungqr_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cungqr_work(int matrix_layout, int m, int n, int k, _Complex float *a, int lda, const _Complex float *tau, _Complex float *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_cungqr_work$address() {
        return LAPACKE_cungqr_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cungqr_work(int matrix_layout, int m, int n, int k, _Complex float *a, int lda, const _Complex float *tau, _Complex float *work, int lwork)
     * }
     */
    public static int LAPACKE_cungqr_work(int matrix_layout, int m, int n, int k, MemorySegment a, int lda, MemorySegment tau, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_cungqr_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cungqr_work", matrix_layout, m, n, k, a, lda, tau, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, k, a, lda, tau, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zungqr_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zungqr_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zungqr_work(int matrix_layout, int m, int n, int k, _Complex double *a, int lda, const _Complex double *tau, _Complex double *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_zungqr_work$descriptor() {
        return LAPACKE_zungqr_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zungqr_work(int matrix_layout, int m, int n, int k, _Complex double *a, int lda, const _Complex double *tau, _Complex double *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_zungqr_work$handle() {
        return LAPACKE_zungqr_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zungqr_work(int matrix_layout, int m, int n, int k, _Complex double *a, int lda, const _Complex double *tau, _Complex double *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_zungqr_work$address() {
        return LAPACKE_zungqr_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zungqr_work(int matrix_layout, int m, int n, int k, _Complex double *a, int lda, const _Complex double *tau, _Complex double *work, int lwork)
     * }
     */
    public static int LAPACKE_zungqr_work(int matrix_layout, int m, int n, int k, MemorySegment a, int lda, MemorySegment tau, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_zungqr_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zungqr_work", matrix_layout, m, n, k, a, lda, tau, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, k, a, lda, tau, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cungrq_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_cungrq_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cungrq_work(int matrix_layout, int m, int n, int k, _Complex float *a, int lda, const _Complex float *tau, _Complex float *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_cungrq_work$descriptor() {
        return LAPACKE_cungrq_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cungrq_work(int matrix_layout, int m, int n, int k, _Complex float *a, int lda, const _Complex float *tau, _Complex float *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_cungrq_work$handle() {
        return LAPACKE_cungrq_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cungrq_work(int matrix_layout, int m, int n, int k, _Complex float *a, int lda, const _Complex float *tau, _Complex float *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_cungrq_work$address() {
        return LAPACKE_cungrq_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cungrq_work(int matrix_layout, int m, int n, int k, _Complex float *a, int lda, const _Complex float *tau, _Complex float *work, int lwork)
     * }
     */
    public static int LAPACKE_cungrq_work(int matrix_layout, int m, int n, int k, MemorySegment a, int lda, MemorySegment tau, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_cungrq_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cungrq_work", matrix_layout, m, n, k, a, lda, tau, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, k, a, lda, tau, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zungrq_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zungrq_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zungrq_work(int matrix_layout, int m, int n, int k, _Complex double *a, int lda, const _Complex double *tau, _Complex double *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_zungrq_work$descriptor() {
        return LAPACKE_zungrq_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zungrq_work(int matrix_layout, int m, int n, int k, _Complex double *a, int lda, const _Complex double *tau, _Complex double *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_zungrq_work$handle() {
        return LAPACKE_zungrq_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zungrq_work(int matrix_layout, int m, int n, int k, _Complex double *a, int lda, const _Complex double *tau, _Complex double *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_zungrq_work$address() {
        return LAPACKE_zungrq_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zungrq_work(int matrix_layout, int m, int n, int k, _Complex double *a, int lda, const _Complex double *tau, _Complex double *work, int lwork)
     * }
     */
    public static int LAPACKE_zungrq_work(int matrix_layout, int m, int n, int k, MemorySegment a, int lda, MemorySegment tau, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_zungrq_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zungrq_work", matrix_layout, m, n, k, a, lda, tau, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, k, a, lda, tau, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cungtr_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_cungtr_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cungtr_work(int matrix_layout, char uplo, int n, _Complex float *a, int lda, const _Complex float *tau, _Complex float *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_cungtr_work$descriptor() {
        return LAPACKE_cungtr_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cungtr_work(int matrix_layout, char uplo, int n, _Complex float *a, int lda, const _Complex float *tau, _Complex float *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_cungtr_work$handle() {
        return LAPACKE_cungtr_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cungtr_work(int matrix_layout, char uplo, int n, _Complex float *a, int lda, const _Complex float *tau, _Complex float *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_cungtr_work$address() {
        return LAPACKE_cungtr_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cungtr_work(int matrix_layout, char uplo, int n, _Complex float *a, int lda, const _Complex float *tau, _Complex float *work, int lwork)
     * }
     */
    public static int LAPACKE_cungtr_work(int matrix_layout, byte uplo, int n, MemorySegment a, int lda, MemorySegment tau, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_cungtr_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cungtr_work", matrix_layout, uplo, n, a, lda, tau, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, a, lda, tau, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zungtr_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zungtr_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zungtr_work(int matrix_layout, char uplo, int n, _Complex double *a, int lda, const _Complex double *tau, _Complex double *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_zungtr_work$descriptor() {
        return LAPACKE_zungtr_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zungtr_work(int matrix_layout, char uplo, int n, _Complex double *a, int lda, const _Complex double *tau, _Complex double *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_zungtr_work$handle() {
        return LAPACKE_zungtr_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zungtr_work(int matrix_layout, char uplo, int n, _Complex double *a, int lda, const _Complex double *tau, _Complex double *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_zungtr_work$address() {
        return LAPACKE_zungtr_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zungtr_work(int matrix_layout, char uplo, int n, _Complex double *a, int lda, const _Complex double *tau, _Complex double *work, int lwork)
     * }
     */
    public static int LAPACKE_zungtr_work(int matrix_layout, byte uplo, int n, MemorySegment a, int lda, MemorySegment tau, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_zungtr_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zungtr_work", matrix_layout, uplo, n, a, lda, tau, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, a, lda, tau, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cungtsqr_row_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_cungtsqr_row_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cungtsqr_row_work(int matrix_layout, int m, int n, int mb, int nb, _Complex float *a, int lda, const _Complex float *t, int ldt, _Complex float *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_cungtsqr_row_work$descriptor() {
        return LAPACKE_cungtsqr_row_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cungtsqr_row_work(int matrix_layout, int m, int n, int mb, int nb, _Complex float *a, int lda, const _Complex float *t, int ldt, _Complex float *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_cungtsqr_row_work$handle() {
        return LAPACKE_cungtsqr_row_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cungtsqr_row_work(int matrix_layout, int m, int n, int mb, int nb, _Complex float *a, int lda, const _Complex float *t, int ldt, _Complex float *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_cungtsqr_row_work$address() {
        return LAPACKE_cungtsqr_row_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cungtsqr_row_work(int matrix_layout, int m, int n, int mb, int nb, _Complex float *a, int lda, const _Complex float *t, int ldt, _Complex float *work, int lwork)
     * }
     */
    public static int LAPACKE_cungtsqr_row_work(int matrix_layout, int m, int n, int mb, int nb, MemorySegment a, int lda, MemorySegment t, int ldt, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_cungtsqr_row_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cungtsqr_row_work", matrix_layout, m, n, mb, nb, a, lda, t, ldt, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, mb, nb, a, lda, t, ldt, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zungtsqr_row_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zungtsqr_row_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zungtsqr_row_work(int matrix_layout, int m, int n, int mb, int nb, _Complex double *a, int lda, const _Complex double *t, int ldt, _Complex double *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_zungtsqr_row_work$descriptor() {
        return LAPACKE_zungtsqr_row_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zungtsqr_row_work(int matrix_layout, int m, int n, int mb, int nb, _Complex double *a, int lda, const _Complex double *t, int ldt, _Complex double *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_zungtsqr_row_work$handle() {
        return LAPACKE_zungtsqr_row_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zungtsqr_row_work(int matrix_layout, int m, int n, int mb, int nb, _Complex double *a, int lda, const _Complex double *t, int ldt, _Complex double *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_zungtsqr_row_work$address() {
        return LAPACKE_zungtsqr_row_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zungtsqr_row_work(int matrix_layout, int m, int n, int mb, int nb, _Complex double *a, int lda, const _Complex double *t, int ldt, _Complex double *work, int lwork)
     * }
     */
    public static int LAPACKE_zungtsqr_row_work(int matrix_layout, int m, int n, int mb, int nb, MemorySegment a, int lda, MemorySegment t, int ldt, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_zungtsqr_row_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zungtsqr_row_work", matrix_layout, m, n, mb, nb, a, lda, t, ldt, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, mb, nb, a, lda, t, ldt, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cunmbr_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_cunmbr_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cunmbr_work(int matrix_layout, char vect, char side, char trans, int m, int n, int k, const _Complex float *a, int lda, const _Complex float *tau, _Complex float *c, int ldc, _Complex float *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_cunmbr_work$descriptor() {
        return LAPACKE_cunmbr_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cunmbr_work(int matrix_layout, char vect, char side, char trans, int m, int n, int k, const _Complex float *a, int lda, const _Complex float *tau, _Complex float *c, int ldc, _Complex float *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_cunmbr_work$handle() {
        return LAPACKE_cunmbr_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cunmbr_work(int matrix_layout, char vect, char side, char trans, int m, int n, int k, const _Complex float *a, int lda, const _Complex float *tau, _Complex float *c, int ldc, _Complex float *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_cunmbr_work$address() {
        return LAPACKE_cunmbr_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cunmbr_work(int matrix_layout, char vect, char side, char trans, int m, int n, int k, const _Complex float *a, int lda, const _Complex float *tau, _Complex float *c, int ldc, _Complex float *work, int lwork)
     * }
     */
    public static int LAPACKE_cunmbr_work(int matrix_layout, byte vect, byte side, byte trans, int m, int n, int k, MemorySegment a, int lda, MemorySegment tau, MemorySegment c, int ldc, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_cunmbr_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cunmbr_work", matrix_layout, vect, side, trans, m, n, k, a, lda, tau, c, ldc, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, vect, side, trans, m, n, k, a, lda, tau, c, ldc, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zunmbr_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zunmbr_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zunmbr_work(int matrix_layout, char vect, char side, char trans, int m, int n, int k, const _Complex double *a, int lda, const _Complex double *tau, _Complex double *c, int ldc, _Complex double *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_zunmbr_work$descriptor() {
        return LAPACKE_zunmbr_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zunmbr_work(int matrix_layout, char vect, char side, char trans, int m, int n, int k, const _Complex double *a, int lda, const _Complex double *tau, _Complex double *c, int ldc, _Complex double *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_zunmbr_work$handle() {
        return LAPACKE_zunmbr_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zunmbr_work(int matrix_layout, char vect, char side, char trans, int m, int n, int k, const _Complex double *a, int lda, const _Complex double *tau, _Complex double *c, int ldc, _Complex double *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_zunmbr_work$address() {
        return LAPACKE_zunmbr_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zunmbr_work(int matrix_layout, char vect, char side, char trans, int m, int n, int k, const _Complex double *a, int lda, const _Complex double *tau, _Complex double *c, int ldc, _Complex double *work, int lwork)
     * }
     */
    public static int LAPACKE_zunmbr_work(int matrix_layout, byte vect, byte side, byte trans, int m, int n, int k, MemorySegment a, int lda, MemorySegment tau, MemorySegment c, int ldc, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_zunmbr_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zunmbr_work", matrix_layout, vect, side, trans, m, n, k, a, lda, tau, c, ldc, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, vect, side, trans, m, n, k, a, lda, tau, c, ldc, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cunmhr_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_cunmhr_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cunmhr_work(int matrix_layout, char side, char trans, int m, int n, int ilo, int ihi, const _Complex float *a, int lda, const _Complex float *tau, _Complex float *c, int ldc, _Complex float *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_cunmhr_work$descriptor() {
        return LAPACKE_cunmhr_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cunmhr_work(int matrix_layout, char side, char trans, int m, int n, int ilo, int ihi, const _Complex float *a, int lda, const _Complex float *tau, _Complex float *c, int ldc, _Complex float *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_cunmhr_work$handle() {
        return LAPACKE_cunmhr_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cunmhr_work(int matrix_layout, char side, char trans, int m, int n, int ilo, int ihi, const _Complex float *a, int lda, const _Complex float *tau, _Complex float *c, int ldc, _Complex float *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_cunmhr_work$address() {
        return LAPACKE_cunmhr_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cunmhr_work(int matrix_layout, char side, char trans, int m, int n, int ilo, int ihi, const _Complex float *a, int lda, const _Complex float *tau, _Complex float *c, int ldc, _Complex float *work, int lwork)
     * }
     */
    public static int LAPACKE_cunmhr_work(int matrix_layout, byte side, byte trans, int m, int n, int ilo, int ihi, MemorySegment a, int lda, MemorySegment tau, MemorySegment c, int ldc, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_cunmhr_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cunmhr_work", matrix_layout, side, trans, m, n, ilo, ihi, a, lda, tau, c, ldc, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, side, trans, m, n, ilo, ihi, a, lda, tau, c, ldc, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zunmhr_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zunmhr_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zunmhr_work(int matrix_layout, char side, char trans, int m, int n, int ilo, int ihi, const _Complex double *a, int lda, const _Complex double *tau, _Complex double *c, int ldc, _Complex double *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_zunmhr_work$descriptor() {
        return LAPACKE_zunmhr_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zunmhr_work(int matrix_layout, char side, char trans, int m, int n, int ilo, int ihi, const _Complex double *a, int lda, const _Complex double *tau, _Complex double *c, int ldc, _Complex double *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_zunmhr_work$handle() {
        return LAPACKE_zunmhr_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zunmhr_work(int matrix_layout, char side, char trans, int m, int n, int ilo, int ihi, const _Complex double *a, int lda, const _Complex double *tau, _Complex double *c, int ldc, _Complex double *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_zunmhr_work$address() {
        return LAPACKE_zunmhr_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zunmhr_work(int matrix_layout, char side, char trans, int m, int n, int ilo, int ihi, const _Complex double *a, int lda, const _Complex double *tau, _Complex double *c, int ldc, _Complex double *work, int lwork)
     * }
     */
    public static int LAPACKE_zunmhr_work(int matrix_layout, byte side, byte trans, int m, int n, int ilo, int ihi, MemorySegment a, int lda, MemorySegment tau, MemorySegment c, int ldc, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_zunmhr_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zunmhr_work", matrix_layout, side, trans, m, n, ilo, ihi, a, lda, tau, c, ldc, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, side, trans, m, n, ilo, ihi, a, lda, tau, c, ldc, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cunmlq_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_cunmlq_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cunmlq_work(int matrix_layout, char side, char trans, int m, int n, int k, const _Complex float *a, int lda, const _Complex float *tau, _Complex float *c, int ldc, _Complex float *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_cunmlq_work$descriptor() {
        return LAPACKE_cunmlq_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cunmlq_work(int matrix_layout, char side, char trans, int m, int n, int k, const _Complex float *a, int lda, const _Complex float *tau, _Complex float *c, int ldc, _Complex float *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_cunmlq_work$handle() {
        return LAPACKE_cunmlq_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cunmlq_work(int matrix_layout, char side, char trans, int m, int n, int k, const _Complex float *a, int lda, const _Complex float *tau, _Complex float *c, int ldc, _Complex float *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_cunmlq_work$address() {
        return LAPACKE_cunmlq_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cunmlq_work(int matrix_layout, char side, char trans, int m, int n, int k, const _Complex float *a, int lda, const _Complex float *tau, _Complex float *c, int ldc, _Complex float *work, int lwork)
     * }
     */
    public static int LAPACKE_cunmlq_work(int matrix_layout, byte side, byte trans, int m, int n, int k, MemorySegment a, int lda, MemorySegment tau, MemorySegment c, int ldc, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_cunmlq_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cunmlq_work", matrix_layout, side, trans, m, n, k, a, lda, tau, c, ldc, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, side, trans, m, n, k, a, lda, tau, c, ldc, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zunmlq_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zunmlq_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zunmlq_work(int matrix_layout, char side, char trans, int m, int n, int k, const _Complex double *a, int lda, const _Complex double *tau, _Complex double *c, int ldc, _Complex double *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_zunmlq_work$descriptor() {
        return LAPACKE_zunmlq_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zunmlq_work(int matrix_layout, char side, char trans, int m, int n, int k, const _Complex double *a, int lda, const _Complex double *tau, _Complex double *c, int ldc, _Complex double *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_zunmlq_work$handle() {
        return LAPACKE_zunmlq_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zunmlq_work(int matrix_layout, char side, char trans, int m, int n, int k, const _Complex double *a, int lda, const _Complex double *tau, _Complex double *c, int ldc, _Complex double *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_zunmlq_work$address() {
        return LAPACKE_zunmlq_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zunmlq_work(int matrix_layout, char side, char trans, int m, int n, int k, const _Complex double *a, int lda, const _Complex double *tau, _Complex double *c, int ldc, _Complex double *work, int lwork)
     * }
     */
    public static int LAPACKE_zunmlq_work(int matrix_layout, byte side, byte trans, int m, int n, int k, MemorySegment a, int lda, MemorySegment tau, MemorySegment c, int ldc, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_zunmlq_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zunmlq_work", matrix_layout, side, trans, m, n, k, a, lda, tau, c, ldc, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, side, trans, m, n, k, a, lda, tau, c, ldc, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cunmql_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_cunmql_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cunmql_work(int matrix_layout, char side, char trans, int m, int n, int k, const _Complex float *a, int lda, const _Complex float *tau, _Complex float *c, int ldc, _Complex float *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_cunmql_work$descriptor() {
        return LAPACKE_cunmql_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cunmql_work(int matrix_layout, char side, char trans, int m, int n, int k, const _Complex float *a, int lda, const _Complex float *tau, _Complex float *c, int ldc, _Complex float *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_cunmql_work$handle() {
        return LAPACKE_cunmql_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cunmql_work(int matrix_layout, char side, char trans, int m, int n, int k, const _Complex float *a, int lda, const _Complex float *tau, _Complex float *c, int ldc, _Complex float *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_cunmql_work$address() {
        return LAPACKE_cunmql_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cunmql_work(int matrix_layout, char side, char trans, int m, int n, int k, const _Complex float *a, int lda, const _Complex float *tau, _Complex float *c, int ldc, _Complex float *work, int lwork)
     * }
     */
    public static int LAPACKE_cunmql_work(int matrix_layout, byte side, byte trans, int m, int n, int k, MemorySegment a, int lda, MemorySegment tau, MemorySegment c, int ldc, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_cunmql_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cunmql_work", matrix_layout, side, trans, m, n, k, a, lda, tau, c, ldc, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, side, trans, m, n, k, a, lda, tau, c, ldc, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zunmql_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zunmql_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zunmql_work(int matrix_layout, char side, char trans, int m, int n, int k, const _Complex double *a, int lda, const _Complex double *tau, _Complex double *c, int ldc, _Complex double *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_zunmql_work$descriptor() {
        return LAPACKE_zunmql_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zunmql_work(int matrix_layout, char side, char trans, int m, int n, int k, const _Complex double *a, int lda, const _Complex double *tau, _Complex double *c, int ldc, _Complex double *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_zunmql_work$handle() {
        return LAPACKE_zunmql_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zunmql_work(int matrix_layout, char side, char trans, int m, int n, int k, const _Complex double *a, int lda, const _Complex double *tau, _Complex double *c, int ldc, _Complex double *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_zunmql_work$address() {
        return LAPACKE_zunmql_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zunmql_work(int matrix_layout, char side, char trans, int m, int n, int k, const _Complex double *a, int lda, const _Complex double *tau, _Complex double *c, int ldc, _Complex double *work, int lwork)
     * }
     */
    public static int LAPACKE_zunmql_work(int matrix_layout, byte side, byte trans, int m, int n, int k, MemorySegment a, int lda, MemorySegment tau, MemorySegment c, int ldc, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_zunmql_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zunmql_work", matrix_layout, side, trans, m, n, k, a, lda, tau, c, ldc, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, side, trans, m, n, k, a, lda, tau, c, ldc, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cunmqr_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_cunmqr_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cunmqr_work(int matrix_layout, char side, char trans, int m, int n, int k, const _Complex float *a, int lda, const _Complex float *tau, _Complex float *c, int ldc, _Complex float *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_cunmqr_work$descriptor() {
        return LAPACKE_cunmqr_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cunmqr_work(int matrix_layout, char side, char trans, int m, int n, int k, const _Complex float *a, int lda, const _Complex float *tau, _Complex float *c, int ldc, _Complex float *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_cunmqr_work$handle() {
        return LAPACKE_cunmqr_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cunmqr_work(int matrix_layout, char side, char trans, int m, int n, int k, const _Complex float *a, int lda, const _Complex float *tau, _Complex float *c, int ldc, _Complex float *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_cunmqr_work$address() {
        return LAPACKE_cunmqr_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cunmqr_work(int matrix_layout, char side, char trans, int m, int n, int k, const _Complex float *a, int lda, const _Complex float *tau, _Complex float *c, int ldc, _Complex float *work, int lwork)
     * }
     */
    public static int LAPACKE_cunmqr_work(int matrix_layout, byte side, byte trans, int m, int n, int k, MemorySegment a, int lda, MemorySegment tau, MemorySegment c, int ldc, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_cunmqr_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cunmqr_work", matrix_layout, side, trans, m, n, k, a, lda, tau, c, ldc, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, side, trans, m, n, k, a, lda, tau, c, ldc, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zunmqr_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zunmqr_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zunmqr_work(int matrix_layout, char side, char trans, int m, int n, int k, const _Complex double *a, int lda, const _Complex double *tau, _Complex double *c, int ldc, _Complex double *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_zunmqr_work$descriptor() {
        return LAPACKE_zunmqr_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zunmqr_work(int matrix_layout, char side, char trans, int m, int n, int k, const _Complex double *a, int lda, const _Complex double *tau, _Complex double *c, int ldc, _Complex double *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_zunmqr_work$handle() {
        return LAPACKE_zunmqr_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zunmqr_work(int matrix_layout, char side, char trans, int m, int n, int k, const _Complex double *a, int lda, const _Complex double *tau, _Complex double *c, int ldc, _Complex double *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_zunmqr_work$address() {
        return LAPACKE_zunmqr_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zunmqr_work(int matrix_layout, char side, char trans, int m, int n, int k, const _Complex double *a, int lda, const _Complex double *tau, _Complex double *c, int ldc, _Complex double *work, int lwork)
     * }
     */
    public static int LAPACKE_zunmqr_work(int matrix_layout, byte side, byte trans, int m, int n, int k, MemorySegment a, int lda, MemorySegment tau, MemorySegment c, int ldc, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_zunmqr_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zunmqr_work", matrix_layout, side, trans, m, n, k, a, lda, tau, c, ldc, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, side, trans, m, n, k, a, lda, tau, c, ldc, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cunmrq_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_cunmrq_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cunmrq_work(int matrix_layout, char side, char trans, int m, int n, int k, const _Complex float *a, int lda, const _Complex float *tau, _Complex float *c, int ldc, _Complex float *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_cunmrq_work$descriptor() {
        return LAPACKE_cunmrq_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cunmrq_work(int matrix_layout, char side, char trans, int m, int n, int k, const _Complex float *a, int lda, const _Complex float *tau, _Complex float *c, int ldc, _Complex float *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_cunmrq_work$handle() {
        return LAPACKE_cunmrq_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cunmrq_work(int matrix_layout, char side, char trans, int m, int n, int k, const _Complex float *a, int lda, const _Complex float *tau, _Complex float *c, int ldc, _Complex float *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_cunmrq_work$address() {
        return LAPACKE_cunmrq_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cunmrq_work(int matrix_layout, char side, char trans, int m, int n, int k, const _Complex float *a, int lda, const _Complex float *tau, _Complex float *c, int ldc, _Complex float *work, int lwork)
     * }
     */
    public static int LAPACKE_cunmrq_work(int matrix_layout, byte side, byte trans, int m, int n, int k, MemorySegment a, int lda, MemorySegment tau, MemorySegment c, int ldc, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_cunmrq_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cunmrq_work", matrix_layout, side, trans, m, n, k, a, lda, tau, c, ldc, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, side, trans, m, n, k, a, lda, tau, c, ldc, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zunmrq_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zunmrq_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zunmrq_work(int matrix_layout, char side, char trans, int m, int n, int k, const _Complex double *a, int lda, const _Complex double *tau, _Complex double *c, int ldc, _Complex double *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_zunmrq_work$descriptor() {
        return LAPACKE_zunmrq_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zunmrq_work(int matrix_layout, char side, char trans, int m, int n, int k, const _Complex double *a, int lda, const _Complex double *tau, _Complex double *c, int ldc, _Complex double *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_zunmrq_work$handle() {
        return LAPACKE_zunmrq_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zunmrq_work(int matrix_layout, char side, char trans, int m, int n, int k, const _Complex double *a, int lda, const _Complex double *tau, _Complex double *c, int ldc, _Complex double *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_zunmrq_work$address() {
        return LAPACKE_zunmrq_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zunmrq_work(int matrix_layout, char side, char trans, int m, int n, int k, const _Complex double *a, int lda, const _Complex double *tau, _Complex double *c, int ldc, _Complex double *work, int lwork)
     * }
     */
    public static int LAPACKE_zunmrq_work(int matrix_layout, byte side, byte trans, int m, int n, int k, MemorySegment a, int lda, MemorySegment tau, MemorySegment c, int ldc, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_zunmrq_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zunmrq_work", matrix_layout, side, trans, m, n, k, a, lda, tau, c, ldc, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, side, trans, m, n, k, a, lda, tau, c, ldc, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cunmrz_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_cunmrz_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cunmrz_work(int matrix_layout, char side, char trans, int m, int n, int k, int l, const _Complex float *a, int lda, const _Complex float *tau, _Complex float *c, int ldc, _Complex float *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_cunmrz_work$descriptor() {
        return LAPACKE_cunmrz_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cunmrz_work(int matrix_layout, char side, char trans, int m, int n, int k, int l, const _Complex float *a, int lda, const _Complex float *tau, _Complex float *c, int ldc, _Complex float *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_cunmrz_work$handle() {
        return LAPACKE_cunmrz_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cunmrz_work(int matrix_layout, char side, char trans, int m, int n, int k, int l, const _Complex float *a, int lda, const _Complex float *tau, _Complex float *c, int ldc, _Complex float *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_cunmrz_work$address() {
        return LAPACKE_cunmrz_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cunmrz_work(int matrix_layout, char side, char trans, int m, int n, int k, int l, const _Complex float *a, int lda, const _Complex float *tau, _Complex float *c, int ldc, _Complex float *work, int lwork)
     * }
     */
    public static int LAPACKE_cunmrz_work(int matrix_layout, byte side, byte trans, int m, int n, int k, int l, MemorySegment a, int lda, MemorySegment tau, MemorySegment c, int ldc, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_cunmrz_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cunmrz_work", matrix_layout, side, trans, m, n, k, l, a, lda, tau, c, ldc, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, side, trans, m, n, k, l, a, lda, tau, c, ldc, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zunmrz_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zunmrz_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zunmrz_work(int matrix_layout, char side, char trans, int m, int n, int k, int l, const _Complex double *a, int lda, const _Complex double *tau, _Complex double *c, int ldc, _Complex double *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_zunmrz_work$descriptor() {
        return LAPACKE_zunmrz_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zunmrz_work(int matrix_layout, char side, char trans, int m, int n, int k, int l, const _Complex double *a, int lda, const _Complex double *tau, _Complex double *c, int ldc, _Complex double *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_zunmrz_work$handle() {
        return LAPACKE_zunmrz_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zunmrz_work(int matrix_layout, char side, char trans, int m, int n, int k, int l, const _Complex double *a, int lda, const _Complex double *tau, _Complex double *c, int ldc, _Complex double *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_zunmrz_work$address() {
        return LAPACKE_zunmrz_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zunmrz_work(int matrix_layout, char side, char trans, int m, int n, int k, int l, const _Complex double *a, int lda, const _Complex double *tau, _Complex double *c, int ldc, _Complex double *work, int lwork)
     * }
     */
    public static int LAPACKE_zunmrz_work(int matrix_layout, byte side, byte trans, int m, int n, int k, int l, MemorySegment a, int lda, MemorySegment tau, MemorySegment c, int ldc, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_zunmrz_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zunmrz_work", matrix_layout, side, trans, m, n, k, l, a, lda, tau, c, ldc, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, side, trans, m, n, k, l, a, lda, tau, c, ldc, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cunmtr_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_cunmtr_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cunmtr_work(int matrix_layout, char side, char uplo, char trans, int m, int n, const _Complex float *a, int lda, const _Complex float *tau, _Complex float *c, int ldc, _Complex float *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_cunmtr_work$descriptor() {
        return LAPACKE_cunmtr_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cunmtr_work(int matrix_layout, char side, char uplo, char trans, int m, int n, const _Complex float *a, int lda, const _Complex float *tau, _Complex float *c, int ldc, _Complex float *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_cunmtr_work$handle() {
        return LAPACKE_cunmtr_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cunmtr_work(int matrix_layout, char side, char uplo, char trans, int m, int n, const _Complex float *a, int lda, const _Complex float *tau, _Complex float *c, int ldc, _Complex float *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_cunmtr_work$address() {
        return LAPACKE_cunmtr_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cunmtr_work(int matrix_layout, char side, char uplo, char trans, int m, int n, const _Complex float *a, int lda, const _Complex float *tau, _Complex float *c, int ldc, _Complex float *work, int lwork)
     * }
     */
    public static int LAPACKE_cunmtr_work(int matrix_layout, byte side, byte uplo, byte trans, int m, int n, MemorySegment a, int lda, MemorySegment tau, MemorySegment c, int ldc, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_cunmtr_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cunmtr_work", matrix_layout, side, uplo, trans, m, n, a, lda, tau, c, ldc, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, side, uplo, trans, m, n, a, lda, tau, c, ldc, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zunmtr_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zunmtr_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zunmtr_work(int matrix_layout, char side, char uplo, char trans, int m, int n, const _Complex double *a, int lda, const _Complex double *tau, _Complex double *c, int ldc, _Complex double *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_zunmtr_work$descriptor() {
        return LAPACKE_zunmtr_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zunmtr_work(int matrix_layout, char side, char uplo, char trans, int m, int n, const _Complex double *a, int lda, const _Complex double *tau, _Complex double *c, int ldc, _Complex double *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_zunmtr_work$handle() {
        return LAPACKE_zunmtr_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zunmtr_work(int matrix_layout, char side, char uplo, char trans, int m, int n, const _Complex double *a, int lda, const _Complex double *tau, _Complex double *c, int ldc, _Complex double *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_zunmtr_work$address() {
        return LAPACKE_zunmtr_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zunmtr_work(int matrix_layout, char side, char uplo, char trans, int m, int n, const _Complex double *a, int lda, const _Complex double *tau, _Complex double *c, int ldc, _Complex double *work, int lwork)
     * }
     */
    public static int LAPACKE_zunmtr_work(int matrix_layout, byte side, byte uplo, byte trans, int m, int n, MemorySegment a, int lda, MemorySegment tau, MemorySegment c, int ldc, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_zunmtr_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zunmtr_work", matrix_layout, side, uplo, trans, m, n, a, lda, tau, c, ldc, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, side, uplo, trans, m, n, a, lda, tau, c, ldc, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cupgtr_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_cupgtr_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cupgtr_work(int matrix_layout, char uplo, int n, const _Complex float *ap, const _Complex float *tau, _Complex float *q, int ldq, _Complex float *work)
     * }
     */
    public static FunctionDescriptor LAPACKE_cupgtr_work$descriptor() {
        return LAPACKE_cupgtr_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cupgtr_work(int matrix_layout, char uplo, int n, const _Complex float *ap, const _Complex float *tau, _Complex float *q, int ldq, _Complex float *work)
     * }
     */
    public static MethodHandle LAPACKE_cupgtr_work$handle() {
        return LAPACKE_cupgtr_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cupgtr_work(int matrix_layout, char uplo, int n, const _Complex float *ap, const _Complex float *tau, _Complex float *q, int ldq, _Complex float *work)
     * }
     */
    public static MemorySegment LAPACKE_cupgtr_work$address() {
        return LAPACKE_cupgtr_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cupgtr_work(int matrix_layout, char uplo, int n, const _Complex float *ap, const _Complex float *tau, _Complex float *q, int ldq, _Complex float *work)
     * }
     */
    public static int LAPACKE_cupgtr_work(int matrix_layout, byte uplo, int n, MemorySegment ap, MemorySegment tau, MemorySegment q, int ldq, MemorySegment work) {
        var mh$ = LAPACKE_cupgtr_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cupgtr_work", matrix_layout, uplo, n, ap, tau, q, ldq, work);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, ap, tau, q, ldq, work);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zupgtr_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zupgtr_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zupgtr_work(int matrix_layout, char uplo, int n, const _Complex double *ap, const _Complex double *tau, _Complex double *q, int ldq, _Complex double *work)
     * }
     */
    public static FunctionDescriptor LAPACKE_zupgtr_work$descriptor() {
        return LAPACKE_zupgtr_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zupgtr_work(int matrix_layout, char uplo, int n, const _Complex double *ap, const _Complex double *tau, _Complex double *q, int ldq, _Complex double *work)
     * }
     */
    public static MethodHandle LAPACKE_zupgtr_work$handle() {
        return LAPACKE_zupgtr_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zupgtr_work(int matrix_layout, char uplo, int n, const _Complex double *ap, const _Complex double *tau, _Complex double *q, int ldq, _Complex double *work)
     * }
     */
    public static MemorySegment LAPACKE_zupgtr_work$address() {
        return LAPACKE_zupgtr_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zupgtr_work(int matrix_layout, char uplo, int n, const _Complex double *ap, const _Complex double *tau, _Complex double *q, int ldq, _Complex double *work)
     * }
     */
    public static int LAPACKE_zupgtr_work(int matrix_layout, byte uplo, int n, MemorySegment ap, MemorySegment tau, MemorySegment q, int ldq, MemorySegment work) {
        var mh$ = LAPACKE_zupgtr_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zupgtr_work", matrix_layout, uplo, n, ap, tau, q, ldq, work);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, ap, tau, q, ldq, work);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cupmtr_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_cupmtr_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cupmtr_work(int matrix_layout, char side, char uplo, char trans, int m, int n, const _Complex float *ap, const _Complex float *tau, _Complex float *c, int ldc, _Complex float *work)
     * }
     */
    public static FunctionDescriptor LAPACKE_cupmtr_work$descriptor() {
        return LAPACKE_cupmtr_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cupmtr_work(int matrix_layout, char side, char uplo, char trans, int m, int n, const _Complex float *ap, const _Complex float *tau, _Complex float *c, int ldc, _Complex float *work)
     * }
     */
    public static MethodHandle LAPACKE_cupmtr_work$handle() {
        return LAPACKE_cupmtr_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cupmtr_work(int matrix_layout, char side, char uplo, char trans, int m, int n, const _Complex float *ap, const _Complex float *tau, _Complex float *c, int ldc, _Complex float *work)
     * }
     */
    public static MemorySegment LAPACKE_cupmtr_work$address() {
        return LAPACKE_cupmtr_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cupmtr_work(int matrix_layout, char side, char uplo, char trans, int m, int n, const _Complex float *ap, const _Complex float *tau, _Complex float *c, int ldc, _Complex float *work)
     * }
     */
    public static int LAPACKE_cupmtr_work(int matrix_layout, byte side, byte uplo, byte trans, int m, int n, MemorySegment ap, MemorySegment tau, MemorySegment c, int ldc, MemorySegment work) {
        var mh$ = LAPACKE_cupmtr_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cupmtr_work", matrix_layout, side, uplo, trans, m, n, ap, tau, c, ldc, work);
            }
            return (int)mh$.invokeExact(matrix_layout, side, uplo, trans, m, n, ap, tau, c, ldc, work);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zupmtr_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zupmtr_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zupmtr_work(int matrix_layout, char side, char uplo, char trans, int m, int n, const _Complex double *ap, const _Complex double *tau, _Complex double *c, int ldc, _Complex double *work)
     * }
     */
    public static FunctionDescriptor LAPACKE_zupmtr_work$descriptor() {
        return LAPACKE_zupmtr_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zupmtr_work(int matrix_layout, char side, char uplo, char trans, int m, int n, const _Complex double *ap, const _Complex double *tau, _Complex double *c, int ldc, _Complex double *work)
     * }
     */
    public static MethodHandle LAPACKE_zupmtr_work$handle() {
        return LAPACKE_zupmtr_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zupmtr_work(int matrix_layout, char side, char uplo, char trans, int m, int n, const _Complex double *ap, const _Complex double *tau, _Complex double *c, int ldc, _Complex double *work)
     * }
     */
    public static MemorySegment LAPACKE_zupmtr_work$address() {
        return LAPACKE_zupmtr_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zupmtr_work(int matrix_layout, char side, char uplo, char trans, int m, int n, const _Complex double *ap, const _Complex double *tau, _Complex double *c, int ldc, _Complex double *work)
     * }
     */
    public static int LAPACKE_zupmtr_work(int matrix_layout, byte side, byte uplo, byte trans, int m, int n, MemorySegment ap, MemorySegment tau, MemorySegment c, int ldc, MemorySegment work) {
        var mh$ = LAPACKE_zupmtr_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zupmtr_work", matrix_layout, side, uplo, trans, m, n, ap, tau, c, ldc, work);
            }
            return (int)mh$.invokeExact(matrix_layout, side, uplo, trans, m, n, ap, tau, c, ldc, work);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_claghe {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_claghe");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_claghe(int matrix_layout, int n, int k, const float *d, _Complex float *a, int lda, int *iseed)
     * }
     */
    public static FunctionDescriptor LAPACKE_claghe$descriptor() {
        return LAPACKE_claghe.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_claghe(int matrix_layout, int n, int k, const float *d, _Complex float *a, int lda, int *iseed)
     * }
     */
    public static MethodHandle LAPACKE_claghe$handle() {
        return LAPACKE_claghe.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_claghe(int matrix_layout, int n, int k, const float *d, _Complex float *a, int lda, int *iseed)
     * }
     */
    public static MemorySegment LAPACKE_claghe$address() {
        return LAPACKE_claghe.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_claghe(int matrix_layout, int n, int k, const float *d, _Complex float *a, int lda, int *iseed)
     * }
     */
    public static int LAPACKE_claghe(int matrix_layout, int n, int k, MemorySegment d, MemorySegment a, int lda, MemorySegment iseed) {
        var mh$ = LAPACKE_claghe.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_claghe", matrix_layout, n, k, d, a, lda, iseed);
            }
            return (int)mh$.invokeExact(matrix_layout, n, k, d, a, lda, iseed);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zlaghe {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zlaghe");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zlaghe(int matrix_layout, int n, int k, const double *d, _Complex double *a, int lda, int *iseed)
     * }
     */
    public static FunctionDescriptor LAPACKE_zlaghe$descriptor() {
        return LAPACKE_zlaghe.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zlaghe(int matrix_layout, int n, int k, const double *d, _Complex double *a, int lda, int *iseed)
     * }
     */
    public static MethodHandle LAPACKE_zlaghe$handle() {
        return LAPACKE_zlaghe.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zlaghe(int matrix_layout, int n, int k, const double *d, _Complex double *a, int lda, int *iseed)
     * }
     */
    public static MemorySegment LAPACKE_zlaghe$address() {
        return LAPACKE_zlaghe.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zlaghe(int matrix_layout, int n, int k, const double *d, _Complex double *a, int lda, int *iseed)
     * }
     */
    public static int LAPACKE_zlaghe(int matrix_layout, int n, int k, MemorySegment d, MemorySegment a, int lda, MemorySegment iseed) {
        var mh$ = LAPACKE_zlaghe.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zlaghe", matrix_layout, n, k, d, a, lda, iseed);
            }
            return (int)mh$.invokeExact(matrix_layout, n, k, d, a, lda, iseed);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_slagsy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_slagsy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_slagsy(int matrix_layout, int n, int k, const float *d, float *a, int lda, int *iseed)
     * }
     */
    public static FunctionDescriptor LAPACKE_slagsy$descriptor() {
        return LAPACKE_slagsy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_slagsy(int matrix_layout, int n, int k, const float *d, float *a, int lda, int *iseed)
     * }
     */
    public static MethodHandle LAPACKE_slagsy$handle() {
        return LAPACKE_slagsy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_slagsy(int matrix_layout, int n, int k, const float *d, float *a, int lda, int *iseed)
     * }
     */
    public static MemorySegment LAPACKE_slagsy$address() {
        return LAPACKE_slagsy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_slagsy(int matrix_layout, int n, int k, const float *d, float *a, int lda, int *iseed)
     * }
     */
    public static int LAPACKE_slagsy(int matrix_layout, int n, int k, MemorySegment d, MemorySegment a, int lda, MemorySegment iseed) {
        var mh$ = LAPACKE_slagsy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_slagsy", matrix_layout, n, k, d, a, lda, iseed);
            }
            return (int)mh$.invokeExact(matrix_layout, n, k, d, a, lda, iseed);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dlagsy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dlagsy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dlagsy(int matrix_layout, int n, int k, const double *d, double *a, int lda, int *iseed)
     * }
     */
    public static FunctionDescriptor LAPACKE_dlagsy$descriptor() {
        return LAPACKE_dlagsy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dlagsy(int matrix_layout, int n, int k, const double *d, double *a, int lda, int *iseed)
     * }
     */
    public static MethodHandle LAPACKE_dlagsy$handle() {
        return LAPACKE_dlagsy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dlagsy(int matrix_layout, int n, int k, const double *d, double *a, int lda, int *iseed)
     * }
     */
    public static MemorySegment LAPACKE_dlagsy$address() {
        return LAPACKE_dlagsy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dlagsy(int matrix_layout, int n, int k, const double *d, double *a, int lda, int *iseed)
     * }
     */
    public static int LAPACKE_dlagsy(int matrix_layout, int n, int k, MemorySegment d, MemorySegment a, int lda, MemorySegment iseed) {
        var mh$ = LAPACKE_dlagsy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dlagsy", matrix_layout, n, k, d, a, lda, iseed);
            }
            return (int)mh$.invokeExact(matrix_layout, n, k, d, a, lda, iseed);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_clagsy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_clagsy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_clagsy(int matrix_layout, int n, int k, const float *d, _Complex float *a, int lda, int *iseed)
     * }
     */
    public static FunctionDescriptor LAPACKE_clagsy$descriptor() {
        return LAPACKE_clagsy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_clagsy(int matrix_layout, int n, int k, const float *d, _Complex float *a, int lda, int *iseed)
     * }
     */
    public static MethodHandle LAPACKE_clagsy$handle() {
        return LAPACKE_clagsy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_clagsy(int matrix_layout, int n, int k, const float *d, _Complex float *a, int lda, int *iseed)
     * }
     */
    public static MemorySegment LAPACKE_clagsy$address() {
        return LAPACKE_clagsy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_clagsy(int matrix_layout, int n, int k, const float *d, _Complex float *a, int lda, int *iseed)
     * }
     */
    public static int LAPACKE_clagsy(int matrix_layout, int n, int k, MemorySegment d, MemorySegment a, int lda, MemorySegment iseed) {
        var mh$ = LAPACKE_clagsy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_clagsy", matrix_layout, n, k, d, a, lda, iseed);
            }
            return (int)mh$.invokeExact(matrix_layout, n, k, d, a, lda, iseed);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zlagsy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zlagsy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zlagsy(int matrix_layout, int n, int k, const double *d, _Complex double *a, int lda, int *iseed)
     * }
     */
    public static FunctionDescriptor LAPACKE_zlagsy$descriptor() {
        return LAPACKE_zlagsy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zlagsy(int matrix_layout, int n, int k, const double *d, _Complex double *a, int lda, int *iseed)
     * }
     */
    public static MethodHandle LAPACKE_zlagsy$handle() {
        return LAPACKE_zlagsy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zlagsy(int matrix_layout, int n, int k, const double *d, _Complex double *a, int lda, int *iseed)
     * }
     */
    public static MemorySegment LAPACKE_zlagsy$address() {
        return LAPACKE_zlagsy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zlagsy(int matrix_layout, int n, int k, const double *d, _Complex double *a, int lda, int *iseed)
     * }
     */
    public static int LAPACKE_zlagsy(int matrix_layout, int n, int k, MemorySegment d, MemorySegment a, int lda, MemorySegment iseed) {
        var mh$ = LAPACKE_zlagsy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zlagsy", matrix_layout, n, k, d, a, lda, iseed);
            }
            return (int)mh$.invokeExact(matrix_layout, n, k, d, a, lda, iseed);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_slapmr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_slapmr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_slapmr(int matrix_layout, int forwrd, int m, int n, float *x, int ldx, int *k)
     * }
     */
    public static FunctionDescriptor LAPACKE_slapmr$descriptor() {
        return LAPACKE_slapmr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_slapmr(int matrix_layout, int forwrd, int m, int n, float *x, int ldx, int *k)
     * }
     */
    public static MethodHandle LAPACKE_slapmr$handle() {
        return LAPACKE_slapmr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_slapmr(int matrix_layout, int forwrd, int m, int n, float *x, int ldx, int *k)
     * }
     */
    public static MemorySegment LAPACKE_slapmr$address() {
        return LAPACKE_slapmr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_slapmr(int matrix_layout, int forwrd, int m, int n, float *x, int ldx, int *k)
     * }
     */
    public static int LAPACKE_slapmr(int matrix_layout, int forwrd, int m, int n, MemorySegment x, int ldx, MemorySegment k) {
        var mh$ = LAPACKE_slapmr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_slapmr", matrix_layout, forwrd, m, n, x, ldx, k);
            }
            return (int)mh$.invokeExact(matrix_layout, forwrd, m, n, x, ldx, k);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dlapmr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dlapmr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dlapmr(int matrix_layout, int forwrd, int m, int n, double *x, int ldx, int *k)
     * }
     */
    public static FunctionDescriptor LAPACKE_dlapmr$descriptor() {
        return LAPACKE_dlapmr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dlapmr(int matrix_layout, int forwrd, int m, int n, double *x, int ldx, int *k)
     * }
     */
    public static MethodHandle LAPACKE_dlapmr$handle() {
        return LAPACKE_dlapmr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dlapmr(int matrix_layout, int forwrd, int m, int n, double *x, int ldx, int *k)
     * }
     */
    public static MemorySegment LAPACKE_dlapmr$address() {
        return LAPACKE_dlapmr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dlapmr(int matrix_layout, int forwrd, int m, int n, double *x, int ldx, int *k)
     * }
     */
    public static int LAPACKE_dlapmr(int matrix_layout, int forwrd, int m, int n, MemorySegment x, int ldx, MemorySegment k) {
        var mh$ = LAPACKE_dlapmr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dlapmr", matrix_layout, forwrd, m, n, x, ldx, k);
            }
            return (int)mh$.invokeExact(matrix_layout, forwrd, m, n, x, ldx, k);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_clapmr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_clapmr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_clapmr(int matrix_layout, int forwrd, int m, int n, _Complex float *x, int ldx, int *k)
     * }
     */
    public static FunctionDescriptor LAPACKE_clapmr$descriptor() {
        return LAPACKE_clapmr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_clapmr(int matrix_layout, int forwrd, int m, int n, _Complex float *x, int ldx, int *k)
     * }
     */
    public static MethodHandle LAPACKE_clapmr$handle() {
        return LAPACKE_clapmr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_clapmr(int matrix_layout, int forwrd, int m, int n, _Complex float *x, int ldx, int *k)
     * }
     */
    public static MemorySegment LAPACKE_clapmr$address() {
        return LAPACKE_clapmr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_clapmr(int matrix_layout, int forwrd, int m, int n, _Complex float *x, int ldx, int *k)
     * }
     */
    public static int LAPACKE_clapmr(int matrix_layout, int forwrd, int m, int n, MemorySegment x, int ldx, MemorySegment k) {
        var mh$ = LAPACKE_clapmr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_clapmr", matrix_layout, forwrd, m, n, x, ldx, k);
            }
            return (int)mh$.invokeExact(matrix_layout, forwrd, m, n, x, ldx, k);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zlapmr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zlapmr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zlapmr(int matrix_layout, int forwrd, int m, int n, _Complex double *x, int ldx, int *k)
     * }
     */
    public static FunctionDescriptor LAPACKE_zlapmr$descriptor() {
        return LAPACKE_zlapmr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zlapmr(int matrix_layout, int forwrd, int m, int n, _Complex double *x, int ldx, int *k)
     * }
     */
    public static MethodHandle LAPACKE_zlapmr$handle() {
        return LAPACKE_zlapmr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zlapmr(int matrix_layout, int forwrd, int m, int n, _Complex double *x, int ldx, int *k)
     * }
     */
    public static MemorySegment LAPACKE_zlapmr$address() {
        return LAPACKE_zlapmr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zlapmr(int matrix_layout, int forwrd, int m, int n, _Complex double *x, int ldx, int *k)
     * }
     */
    public static int LAPACKE_zlapmr(int matrix_layout, int forwrd, int m, int n, MemorySegment x, int ldx, MemorySegment k) {
        var mh$ = LAPACKE_zlapmr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zlapmr", matrix_layout, forwrd, m, n, x, ldx, k);
            }
            return (int)mh$.invokeExact(matrix_layout, forwrd, m, n, x, ldx, k);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_slapmt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_slapmt");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_slapmt(int matrix_layout, int forwrd, int m, int n, float *x, int ldx, int *k)
     * }
     */
    public static FunctionDescriptor LAPACKE_slapmt$descriptor() {
        return LAPACKE_slapmt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_slapmt(int matrix_layout, int forwrd, int m, int n, float *x, int ldx, int *k)
     * }
     */
    public static MethodHandle LAPACKE_slapmt$handle() {
        return LAPACKE_slapmt.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_slapmt(int matrix_layout, int forwrd, int m, int n, float *x, int ldx, int *k)
     * }
     */
    public static MemorySegment LAPACKE_slapmt$address() {
        return LAPACKE_slapmt.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_slapmt(int matrix_layout, int forwrd, int m, int n, float *x, int ldx, int *k)
     * }
     */
    public static int LAPACKE_slapmt(int matrix_layout, int forwrd, int m, int n, MemorySegment x, int ldx, MemorySegment k) {
        var mh$ = LAPACKE_slapmt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_slapmt", matrix_layout, forwrd, m, n, x, ldx, k);
            }
            return (int)mh$.invokeExact(matrix_layout, forwrd, m, n, x, ldx, k);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dlapmt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dlapmt");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dlapmt(int matrix_layout, int forwrd, int m, int n, double *x, int ldx, int *k)
     * }
     */
    public static FunctionDescriptor LAPACKE_dlapmt$descriptor() {
        return LAPACKE_dlapmt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dlapmt(int matrix_layout, int forwrd, int m, int n, double *x, int ldx, int *k)
     * }
     */
    public static MethodHandle LAPACKE_dlapmt$handle() {
        return LAPACKE_dlapmt.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dlapmt(int matrix_layout, int forwrd, int m, int n, double *x, int ldx, int *k)
     * }
     */
    public static MemorySegment LAPACKE_dlapmt$address() {
        return LAPACKE_dlapmt.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dlapmt(int matrix_layout, int forwrd, int m, int n, double *x, int ldx, int *k)
     * }
     */
    public static int LAPACKE_dlapmt(int matrix_layout, int forwrd, int m, int n, MemorySegment x, int ldx, MemorySegment k) {
        var mh$ = LAPACKE_dlapmt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dlapmt", matrix_layout, forwrd, m, n, x, ldx, k);
            }
            return (int)mh$.invokeExact(matrix_layout, forwrd, m, n, x, ldx, k);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_clapmt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_clapmt");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_clapmt(int matrix_layout, int forwrd, int m, int n, _Complex float *x, int ldx, int *k)
     * }
     */
    public static FunctionDescriptor LAPACKE_clapmt$descriptor() {
        return LAPACKE_clapmt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_clapmt(int matrix_layout, int forwrd, int m, int n, _Complex float *x, int ldx, int *k)
     * }
     */
    public static MethodHandle LAPACKE_clapmt$handle() {
        return LAPACKE_clapmt.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_clapmt(int matrix_layout, int forwrd, int m, int n, _Complex float *x, int ldx, int *k)
     * }
     */
    public static MemorySegment LAPACKE_clapmt$address() {
        return LAPACKE_clapmt.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_clapmt(int matrix_layout, int forwrd, int m, int n, _Complex float *x, int ldx, int *k)
     * }
     */
    public static int LAPACKE_clapmt(int matrix_layout, int forwrd, int m, int n, MemorySegment x, int ldx, MemorySegment k) {
        var mh$ = LAPACKE_clapmt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_clapmt", matrix_layout, forwrd, m, n, x, ldx, k);
            }
            return (int)mh$.invokeExact(matrix_layout, forwrd, m, n, x, ldx, k);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zlapmt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zlapmt");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zlapmt(int matrix_layout, int forwrd, int m, int n, _Complex double *x, int ldx, int *k)
     * }
     */
    public static FunctionDescriptor LAPACKE_zlapmt$descriptor() {
        return LAPACKE_zlapmt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zlapmt(int matrix_layout, int forwrd, int m, int n, _Complex double *x, int ldx, int *k)
     * }
     */
    public static MethodHandle LAPACKE_zlapmt$handle() {
        return LAPACKE_zlapmt.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zlapmt(int matrix_layout, int forwrd, int m, int n, _Complex double *x, int ldx, int *k)
     * }
     */
    public static MemorySegment LAPACKE_zlapmt$address() {
        return LAPACKE_zlapmt.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zlapmt(int matrix_layout, int forwrd, int m, int n, _Complex double *x, int ldx, int *k)
     * }
     */
    public static int LAPACKE_zlapmt(int matrix_layout, int forwrd, int m, int n, MemorySegment x, int ldx, MemorySegment k) {
        var mh$ = LAPACKE_zlapmt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zlapmt", matrix_layout, forwrd, m, n, x, ldx, k);
            }
            return (int)mh$.invokeExact(matrix_layout, forwrd, m, n, x, ldx, k);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_slapy2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_FLOAT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_slapy2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float LAPACKE_slapy2(float x, float y)
     * }
     */
    public static FunctionDescriptor LAPACKE_slapy2$descriptor() {
        return LAPACKE_slapy2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float LAPACKE_slapy2(float x, float y)
     * }
     */
    public static MethodHandle LAPACKE_slapy2$handle() {
        return LAPACKE_slapy2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float LAPACKE_slapy2(float x, float y)
     * }
     */
    public static MemorySegment LAPACKE_slapy2$address() {
        return LAPACKE_slapy2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float LAPACKE_slapy2(float x, float y)
     * }
     */
    public static float LAPACKE_slapy2(float x, float y) {
        var mh$ = LAPACKE_slapy2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_slapy2", x, y);
            }
            return (float)mh$.invokeExact(x, y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dlapy2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dlapy2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double LAPACKE_dlapy2(double x, double y)
     * }
     */
    public static FunctionDescriptor LAPACKE_dlapy2$descriptor() {
        return LAPACKE_dlapy2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double LAPACKE_dlapy2(double x, double y)
     * }
     */
    public static MethodHandle LAPACKE_dlapy2$handle() {
        return LAPACKE_dlapy2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double LAPACKE_dlapy2(double x, double y)
     * }
     */
    public static MemorySegment LAPACKE_dlapy2$address() {
        return LAPACKE_dlapy2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double LAPACKE_dlapy2(double x, double y)
     * }
     */
    public static double LAPACKE_dlapy2(double x, double y) {
        var mh$ = LAPACKE_dlapy2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dlapy2", x, y);
            }
            return (double)mh$.invokeExact(x, y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_slapy3 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_FLOAT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_slapy3");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float LAPACKE_slapy3(float x, float y, float z)
     * }
     */
    public static FunctionDescriptor LAPACKE_slapy3$descriptor() {
        return LAPACKE_slapy3.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float LAPACKE_slapy3(float x, float y, float z)
     * }
     */
    public static MethodHandle LAPACKE_slapy3$handle() {
        return LAPACKE_slapy3.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float LAPACKE_slapy3(float x, float y, float z)
     * }
     */
    public static MemorySegment LAPACKE_slapy3$address() {
        return LAPACKE_slapy3.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float LAPACKE_slapy3(float x, float y, float z)
     * }
     */
    public static float LAPACKE_slapy3(float x, float y, float z) {
        var mh$ = LAPACKE_slapy3.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_slapy3", x, y, z);
            }
            return (float)mh$.invokeExact(x, y, z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dlapy3 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dlapy3");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double LAPACKE_dlapy3(double x, double y, double z)
     * }
     */
    public static FunctionDescriptor LAPACKE_dlapy3$descriptor() {
        return LAPACKE_dlapy3.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double LAPACKE_dlapy3(double x, double y, double z)
     * }
     */
    public static MethodHandle LAPACKE_dlapy3$handle() {
        return LAPACKE_dlapy3.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double LAPACKE_dlapy3(double x, double y, double z)
     * }
     */
    public static MemorySegment LAPACKE_dlapy3$address() {
        return LAPACKE_dlapy3.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double LAPACKE_dlapy3(double x, double y, double z)
     * }
     */
    public static double LAPACKE_dlapy3(double x, double y, double z) {
        var mh$ = LAPACKE_dlapy3.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dlapy3", x, y, z);
            }
            return (double)mh$.invokeExact(x, y, z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_slartgp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_slartgp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_slartgp(float f, float g, float *cs, float *sn, float *r)
     * }
     */
    public static FunctionDescriptor LAPACKE_slartgp$descriptor() {
        return LAPACKE_slartgp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_slartgp(float f, float g, float *cs, float *sn, float *r)
     * }
     */
    public static MethodHandle LAPACKE_slartgp$handle() {
        return LAPACKE_slartgp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_slartgp(float f, float g, float *cs, float *sn, float *r)
     * }
     */
    public static MemorySegment LAPACKE_slartgp$address() {
        return LAPACKE_slartgp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_slartgp(float f, float g, float *cs, float *sn, float *r)
     * }
     */
    public static int LAPACKE_slartgp(float f, float g, MemorySegment cs, MemorySegment sn, MemorySegment r) {
        var mh$ = LAPACKE_slartgp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_slartgp", f, g, cs, sn, r);
            }
            return (int)mh$.invokeExact(f, g, cs, sn, r);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dlartgp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dlartgp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dlartgp(double f, double g, double *cs, double *sn, double *r)
     * }
     */
    public static FunctionDescriptor LAPACKE_dlartgp$descriptor() {
        return LAPACKE_dlartgp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dlartgp(double f, double g, double *cs, double *sn, double *r)
     * }
     */
    public static MethodHandle LAPACKE_dlartgp$handle() {
        return LAPACKE_dlartgp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dlartgp(double f, double g, double *cs, double *sn, double *r)
     * }
     */
    public static MemorySegment LAPACKE_dlartgp$address() {
        return LAPACKE_dlartgp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dlartgp(double f, double g, double *cs, double *sn, double *r)
     * }
     */
    public static int LAPACKE_dlartgp(double f, double g, MemorySegment cs, MemorySegment sn, MemorySegment r) {
        var mh$ = LAPACKE_dlartgp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dlartgp", f, g, cs, sn, r);
            }
            return (int)mh$.invokeExact(f, g, cs, sn, r);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_slartgs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_slartgs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_slartgs(float x, float y, float sigma, float *cs, float *sn)
     * }
     */
    public static FunctionDescriptor LAPACKE_slartgs$descriptor() {
        return LAPACKE_slartgs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_slartgs(float x, float y, float sigma, float *cs, float *sn)
     * }
     */
    public static MethodHandle LAPACKE_slartgs$handle() {
        return LAPACKE_slartgs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_slartgs(float x, float y, float sigma, float *cs, float *sn)
     * }
     */
    public static MemorySegment LAPACKE_slartgs$address() {
        return LAPACKE_slartgs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_slartgs(float x, float y, float sigma, float *cs, float *sn)
     * }
     */
    public static int LAPACKE_slartgs(float x, float y, float sigma, MemorySegment cs, MemorySegment sn) {
        var mh$ = LAPACKE_slartgs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_slartgs", x, y, sigma, cs, sn);
            }
            return (int)mh$.invokeExact(x, y, sigma, cs, sn);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dlartgs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dlartgs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dlartgs(double x, double y, double sigma, double *cs, double *sn)
     * }
     */
    public static FunctionDescriptor LAPACKE_dlartgs$descriptor() {
        return LAPACKE_dlartgs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dlartgs(double x, double y, double sigma, double *cs, double *sn)
     * }
     */
    public static MethodHandle LAPACKE_dlartgs$handle() {
        return LAPACKE_dlartgs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dlartgs(double x, double y, double sigma, double *cs, double *sn)
     * }
     */
    public static MemorySegment LAPACKE_dlartgs$address() {
        return LAPACKE_dlartgs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dlartgs(double x, double y, double sigma, double *cs, double *sn)
     * }
     */
    public static int LAPACKE_dlartgs(double x, double y, double sigma, MemorySegment cs, MemorySegment sn) {
        var mh$ = LAPACKE_dlartgs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dlartgs", x, y, sigma, cs, sn);
            }
            return (int)mh$.invokeExact(x, y, sigma, cs, sn);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cbbcsd {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_cbbcsd");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cbbcsd(int matrix_layout, char jobu1, char jobu2, char jobv1t, char jobv2t, char trans, int m, int p, int q, float *theta, float *phi, _Complex float *u1, int ldu1, _Complex float *u2, int ldu2, _Complex float *v1t, int ldv1t, _Complex float *v2t, int ldv2t, float *b11d, float *b11e, float *b12d, float *b12e, float *b21d, float *b21e, float *b22d, float *b22e)
     * }
     */
    public static FunctionDescriptor LAPACKE_cbbcsd$descriptor() {
        return LAPACKE_cbbcsd.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cbbcsd(int matrix_layout, char jobu1, char jobu2, char jobv1t, char jobv2t, char trans, int m, int p, int q, float *theta, float *phi, _Complex float *u1, int ldu1, _Complex float *u2, int ldu2, _Complex float *v1t, int ldv1t, _Complex float *v2t, int ldv2t, float *b11d, float *b11e, float *b12d, float *b12e, float *b21d, float *b21e, float *b22d, float *b22e)
     * }
     */
    public static MethodHandle LAPACKE_cbbcsd$handle() {
        return LAPACKE_cbbcsd.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cbbcsd(int matrix_layout, char jobu1, char jobu2, char jobv1t, char jobv2t, char trans, int m, int p, int q, float *theta, float *phi, _Complex float *u1, int ldu1, _Complex float *u2, int ldu2, _Complex float *v1t, int ldv1t, _Complex float *v2t, int ldv2t, float *b11d, float *b11e, float *b12d, float *b12e, float *b21d, float *b21e, float *b22d, float *b22e)
     * }
     */
    public static MemorySegment LAPACKE_cbbcsd$address() {
        return LAPACKE_cbbcsd.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cbbcsd(int matrix_layout, char jobu1, char jobu2, char jobv1t, char jobv2t, char trans, int m, int p, int q, float *theta, float *phi, _Complex float *u1, int ldu1, _Complex float *u2, int ldu2, _Complex float *v1t, int ldv1t, _Complex float *v2t, int ldv2t, float *b11d, float *b11e, float *b12d, float *b12e, float *b21d, float *b21e, float *b22d, float *b22e)
     * }
     */
    public static int LAPACKE_cbbcsd(int matrix_layout, byte jobu1, byte jobu2, byte jobv1t, byte jobv2t, byte trans, int m, int p, int q, MemorySegment theta, MemorySegment phi, MemorySegment u1, int ldu1, MemorySegment u2, int ldu2, MemorySegment v1t, int ldv1t, MemorySegment v2t, int ldv2t, MemorySegment b11d, MemorySegment b11e, MemorySegment b12d, MemorySegment b12e, MemorySegment b21d, MemorySegment b21e, MemorySegment b22d, MemorySegment b22e) {
        var mh$ = LAPACKE_cbbcsd.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cbbcsd", matrix_layout, jobu1, jobu2, jobv1t, jobv2t, trans, m, p, q, theta, phi, u1, ldu1, u2, ldu2, v1t, ldv1t, v2t, ldv2t, b11d, b11e, b12d, b12e, b21d, b21e, b22d, b22e);
            }
            return (int)mh$.invokeExact(matrix_layout, jobu1, jobu2, jobv1t, jobv2t, trans, m, p, q, theta, phi, u1, ldu1, u2, ldu2, v1t, ldv1t, v2t, ldv2t, b11d, b11e, b12d, b12e, b21d, b21e, b22d, b22e);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cbbcsd_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_cbbcsd_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cbbcsd_work(int matrix_layout, char jobu1, char jobu2, char jobv1t, char jobv2t, char trans, int m, int p, int q, float *theta, float *phi, _Complex float *u1, int ldu1, _Complex float *u2, int ldu2, _Complex float *v1t, int ldv1t, _Complex float *v2t, int ldv2t, float *b11d, float *b11e, float *b12d, float *b12e, float *b21d, float *b21e, float *b22d, float *b22e, float *rwork, int lrwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_cbbcsd_work$descriptor() {
        return LAPACKE_cbbcsd_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cbbcsd_work(int matrix_layout, char jobu1, char jobu2, char jobv1t, char jobv2t, char trans, int m, int p, int q, float *theta, float *phi, _Complex float *u1, int ldu1, _Complex float *u2, int ldu2, _Complex float *v1t, int ldv1t, _Complex float *v2t, int ldv2t, float *b11d, float *b11e, float *b12d, float *b12e, float *b21d, float *b21e, float *b22d, float *b22e, float *rwork, int lrwork)
     * }
     */
    public static MethodHandle LAPACKE_cbbcsd_work$handle() {
        return LAPACKE_cbbcsd_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cbbcsd_work(int matrix_layout, char jobu1, char jobu2, char jobv1t, char jobv2t, char trans, int m, int p, int q, float *theta, float *phi, _Complex float *u1, int ldu1, _Complex float *u2, int ldu2, _Complex float *v1t, int ldv1t, _Complex float *v2t, int ldv2t, float *b11d, float *b11e, float *b12d, float *b12e, float *b21d, float *b21e, float *b22d, float *b22e, float *rwork, int lrwork)
     * }
     */
    public static MemorySegment LAPACKE_cbbcsd_work$address() {
        return LAPACKE_cbbcsd_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cbbcsd_work(int matrix_layout, char jobu1, char jobu2, char jobv1t, char jobv2t, char trans, int m, int p, int q, float *theta, float *phi, _Complex float *u1, int ldu1, _Complex float *u2, int ldu2, _Complex float *v1t, int ldv1t, _Complex float *v2t, int ldv2t, float *b11d, float *b11e, float *b12d, float *b12e, float *b21d, float *b21e, float *b22d, float *b22e, float *rwork, int lrwork)
     * }
     */
    public static int LAPACKE_cbbcsd_work(int matrix_layout, byte jobu1, byte jobu2, byte jobv1t, byte jobv2t, byte trans, int m, int p, int q, MemorySegment theta, MemorySegment phi, MemorySegment u1, int ldu1, MemorySegment u2, int ldu2, MemorySegment v1t, int ldv1t, MemorySegment v2t, int ldv2t, MemorySegment b11d, MemorySegment b11e, MemorySegment b12d, MemorySegment b12e, MemorySegment b21d, MemorySegment b21e, MemorySegment b22d, MemorySegment b22e, MemorySegment rwork, int lrwork) {
        var mh$ = LAPACKE_cbbcsd_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cbbcsd_work", matrix_layout, jobu1, jobu2, jobv1t, jobv2t, trans, m, p, q, theta, phi, u1, ldu1, u2, ldu2, v1t, ldv1t, v2t, ldv2t, b11d, b11e, b12d, b12e, b21d, b21e, b22d, b22e, rwork, lrwork);
            }
            return (int)mh$.invokeExact(matrix_layout, jobu1, jobu2, jobv1t, jobv2t, trans, m, p, q, theta, phi, u1, ldu1, u2, ldu2, v1t, ldv1t, v2t, ldv2t, b11d, b11e, b12d, b12e, b21d, b21e, b22d, b22e, rwork, lrwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cheswapr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_cheswapr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cheswapr(int matrix_layout, char uplo, int n, _Complex float *a, int lda, int i1, int i2)
     * }
     */
    public static FunctionDescriptor LAPACKE_cheswapr$descriptor() {
        return LAPACKE_cheswapr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cheswapr(int matrix_layout, char uplo, int n, _Complex float *a, int lda, int i1, int i2)
     * }
     */
    public static MethodHandle LAPACKE_cheswapr$handle() {
        return LAPACKE_cheswapr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cheswapr(int matrix_layout, char uplo, int n, _Complex float *a, int lda, int i1, int i2)
     * }
     */
    public static MemorySegment LAPACKE_cheswapr$address() {
        return LAPACKE_cheswapr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cheswapr(int matrix_layout, char uplo, int n, _Complex float *a, int lda, int i1, int i2)
     * }
     */
    public static int LAPACKE_cheswapr(int matrix_layout, byte uplo, int n, MemorySegment a, int lda, int i1, int i2) {
        var mh$ = LAPACKE_cheswapr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cheswapr", matrix_layout, uplo, n, a, lda, i1, i2);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, a, lda, i1, i2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cheswapr_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_cheswapr_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cheswapr_work(int matrix_layout, char uplo, int n, _Complex float *a, int lda, int i1, int i2)
     * }
     */
    public static FunctionDescriptor LAPACKE_cheswapr_work$descriptor() {
        return LAPACKE_cheswapr_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cheswapr_work(int matrix_layout, char uplo, int n, _Complex float *a, int lda, int i1, int i2)
     * }
     */
    public static MethodHandle LAPACKE_cheswapr_work$handle() {
        return LAPACKE_cheswapr_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cheswapr_work(int matrix_layout, char uplo, int n, _Complex float *a, int lda, int i1, int i2)
     * }
     */
    public static MemorySegment LAPACKE_cheswapr_work$address() {
        return LAPACKE_cheswapr_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cheswapr_work(int matrix_layout, char uplo, int n, _Complex float *a, int lda, int i1, int i2)
     * }
     */
    public static int LAPACKE_cheswapr_work(int matrix_layout, byte uplo, int n, MemorySegment a, int lda, int i1, int i2) {
        var mh$ = LAPACKE_cheswapr_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cheswapr_work", matrix_layout, uplo, n, a, lda, i1, i2);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, a, lda, i1, i2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_chetri2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_chetri2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_chetri2(int matrix_layout, char uplo, int n, _Complex float *a, int lda, const int *ipiv)
     * }
     */
    public static FunctionDescriptor LAPACKE_chetri2$descriptor() {
        return LAPACKE_chetri2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_chetri2(int matrix_layout, char uplo, int n, _Complex float *a, int lda, const int *ipiv)
     * }
     */
    public static MethodHandle LAPACKE_chetri2$handle() {
        return LAPACKE_chetri2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_chetri2(int matrix_layout, char uplo, int n, _Complex float *a, int lda, const int *ipiv)
     * }
     */
    public static MemorySegment LAPACKE_chetri2$address() {
        return LAPACKE_chetri2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_chetri2(int matrix_layout, char uplo, int n, _Complex float *a, int lda, const int *ipiv)
     * }
     */
    public static int LAPACKE_chetri2(int matrix_layout, byte uplo, int n, MemorySegment a, int lda, MemorySegment ipiv) {
        var mh$ = LAPACKE_chetri2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_chetri2", matrix_layout, uplo, n, a, lda, ipiv);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, a, lda, ipiv);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_chetri2_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_chetri2_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_chetri2_work(int matrix_layout, char uplo, int n, _Complex float *a, int lda, const int *ipiv, _Complex float *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_chetri2_work$descriptor() {
        return LAPACKE_chetri2_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_chetri2_work(int matrix_layout, char uplo, int n, _Complex float *a, int lda, const int *ipiv, _Complex float *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_chetri2_work$handle() {
        return LAPACKE_chetri2_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_chetri2_work(int matrix_layout, char uplo, int n, _Complex float *a, int lda, const int *ipiv, _Complex float *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_chetri2_work$address() {
        return LAPACKE_chetri2_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_chetri2_work(int matrix_layout, char uplo, int n, _Complex float *a, int lda, const int *ipiv, _Complex float *work, int lwork)
     * }
     */
    public static int LAPACKE_chetri2_work(int matrix_layout, byte uplo, int n, MemorySegment a, int lda, MemorySegment ipiv, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_chetri2_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_chetri2_work", matrix_layout, uplo, n, a, lda, ipiv, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, a, lda, ipiv, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_chetri2x {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_chetri2x");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_chetri2x(int matrix_layout, char uplo, int n, _Complex float *a, int lda, const int *ipiv, int nb)
     * }
     */
    public static FunctionDescriptor LAPACKE_chetri2x$descriptor() {
        return LAPACKE_chetri2x.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_chetri2x(int matrix_layout, char uplo, int n, _Complex float *a, int lda, const int *ipiv, int nb)
     * }
     */
    public static MethodHandle LAPACKE_chetri2x$handle() {
        return LAPACKE_chetri2x.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_chetri2x(int matrix_layout, char uplo, int n, _Complex float *a, int lda, const int *ipiv, int nb)
     * }
     */
    public static MemorySegment LAPACKE_chetri2x$address() {
        return LAPACKE_chetri2x.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_chetri2x(int matrix_layout, char uplo, int n, _Complex float *a, int lda, const int *ipiv, int nb)
     * }
     */
    public static int LAPACKE_chetri2x(int matrix_layout, byte uplo, int n, MemorySegment a, int lda, MemorySegment ipiv, int nb) {
        var mh$ = LAPACKE_chetri2x.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_chetri2x", matrix_layout, uplo, n, a, lda, ipiv, nb);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, a, lda, ipiv, nb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_chetri2x_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_chetri2x_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_chetri2x_work(int matrix_layout, char uplo, int n, _Complex float *a, int lda, const int *ipiv, _Complex float *work, int nb)
     * }
     */
    public static FunctionDescriptor LAPACKE_chetri2x_work$descriptor() {
        return LAPACKE_chetri2x_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_chetri2x_work(int matrix_layout, char uplo, int n, _Complex float *a, int lda, const int *ipiv, _Complex float *work, int nb)
     * }
     */
    public static MethodHandle LAPACKE_chetri2x_work$handle() {
        return LAPACKE_chetri2x_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_chetri2x_work(int matrix_layout, char uplo, int n, _Complex float *a, int lda, const int *ipiv, _Complex float *work, int nb)
     * }
     */
    public static MemorySegment LAPACKE_chetri2x_work$address() {
        return LAPACKE_chetri2x_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_chetri2x_work(int matrix_layout, char uplo, int n, _Complex float *a, int lda, const int *ipiv, _Complex float *work, int nb)
     * }
     */
    public static int LAPACKE_chetri2x_work(int matrix_layout, byte uplo, int n, MemorySegment a, int lda, MemorySegment ipiv, MemorySegment work, int nb) {
        var mh$ = LAPACKE_chetri2x_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_chetri2x_work", matrix_layout, uplo, n, a, lda, ipiv, work, nb);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, a, lda, ipiv, work, nb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_chetrs2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_chetrs2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_chetrs2(int matrix_layout, char uplo, int n, int nrhs, const _Complex float *a, int lda, const int *ipiv, _Complex float *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_chetrs2$descriptor() {
        return LAPACKE_chetrs2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_chetrs2(int matrix_layout, char uplo, int n, int nrhs, const _Complex float *a, int lda, const int *ipiv, _Complex float *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_chetrs2$handle() {
        return LAPACKE_chetrs2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_chetrs2(int matrix_layout, char uplo, int n, int nrhs, const _Complex float *a, int lda, const int *ipiv, _Complex float *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_chetrs2$address() {
        return LAPACKE_chetrs2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_chetrs2(int matrix_layout, char uplo, int n, int nrhs, const _Complex float *a, int lda, const int *ipiv, _Complex float *b, int ldb)
     * }
     */
    public static int LAPACKE_chetrs2(int matrix_layout, byte uplo, int n, int nrhs, MemorySegment a, int lda, MemorySegment ipiv, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_chetrs2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_chetrs2", matrix_layout, uplo, n, nrhs, a, lda, ipiv, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, nrhs, a, lda, ipiv, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_chetrs2_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_chetrs2_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_chetrs2_work(int matrix_layout, char uplo, int n, int nrhs, const _Complex float *a, int lda, const int *ipiv, _Complex float *b, int ldb, _Complex float *work)
     * }
     */
    public static FunctionDescriptor LAPACKE_chetrs2_work$descriptor() {
        return LAPACKE_chetrs2_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_chetrs2_work(int matrix_layout, char uplo, int n, int nrhs, const _Complex float *a, int lda, const int *ipiv, _Complex float *b, int ldb, _Complex float *work)
     * }
     */
    public static MethodHandle LAPACKE_chetrs2_work$handle() {
        return LAPACKE_chetrs2_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_chetrs2_work(int matrix_layout, char uplo, int n, int nrhs, const _Complex float *a, int lda, const int *ipiv, _Complex float *b, int ldb, _Complex float *work)
     * }
     */
    public static MemorySegment LAPACKE_chetrs2_work$address() {
        return LAPACKE_chetrs2_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_chetrs2_work(int matrix_layout, char uplo, int n, int nrhs, const _Complex float *a, int lda, const int *ipiv, _Complex float *b, int ldb, _Complex float *work)
     * }
     */
    public static int LAPACKE_chetrs2_work(int matrix_layout, byte uplo, int n, int nrhs, MemorySegment a, int lda, MemorySegment ipiv, MemorySegment b, int ldb, MemorySegment work) {
        var mh$ = LAPACKE_chetrs2_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_chetrs2_work", matrix_layout, uplo, n, nrhs, a, lda, ipiv, b, ldb, work);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, nrhs, a, lda, ipiv, b, ldb, work);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_csyconv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_csyconv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_csyconv(int matrix_layout, char uplo, char way, int n, _Complex float *a, int lda, const int *ipiv, _Complex float *e)
     * }
     */
    public static FunctionDescriptor LAPACKE_csyconv$descriptor() {
        return LAPACKE_csyconv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_csyconv(int matrix_layout, char uplo, char way, int n, _Complex float *a, int lda, const int *ipiv, _Complex float *e)
     * }
     */
    public static MethodHandle LAPACKE_csyconv$handle() {
        return LAPACKE_csyconv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_csyconv(int matrix_layout, char uplo, char way, int n, _Complex float *a, int lda, const int *ipiv, _Complex float *e)
     * }
     */
    public static MemorySegment LAPACKE_csyconv$address() {
        return LAPACKE_csyconv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_csyconv(int matrix_layout, char uplo, char way, int n, _Complex float *a, int lda, const int *ipiv, _Complex float *e)
     * }
     */
    public static int LAPACKE_csyconv(int matrix_layout, byte uplo, byte way, int n, MemorySegment a, int lda, MemorySegment ipiv, MemorySegment e) {
        var mh$ = LAPACKE_csyconv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_csyconv", matrix_layout, uplo, way, n, a, lda, ipiv, e);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, way, n, a, lda, ipiv, e);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_csyconv_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_csyconv_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_csyconv_work(int matrix_layout, char uplo, char way, int n, _Complex float *a, int lda, const int *ipiv, _Complex float *e)
     * }
     */
    public static FunctionDescriptor LAPACKE_csyconv_work$descriptor() {
        return LAPACKE_csyconv_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_csyconv_work(int matrix_layout, char uplo, char way, int n, _Complex float *a, int lda, const int *ipiv, _Complex float *e)
     * }
     */
    public static MethodHandle LAPACKE_csyconv_work$handle() {
        return LAPACKE_csyconv_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_csyconv_work(int matrix_layout, char uplo, char way, int n, _Complex float *a, int lda, const int *ipiv, _Complex float *e)
     * }
     */
    public static MemorySegment LAPACKE_csyconv_work$address() {
        return LAPACKE_csyconv_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_csyconv_work(int matrix_layout, char uplo, char way, int n, _Complex float *a, int lda, const int *ipiv, _Complex float *e)
     * }
     */
    public static int LAPACKE_csyconv_work(int matrix_layout, byte uplo, byte way, int n, MemorySegment a, int lda, MemorySegment ipiv, MemorySegment e) {
        var mh$ = LAPACKE_csyconv_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_csyconv_work", matrix_layout, uplo, way, n, a, lda, ipiv, e);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, way, n, a, lda, ipiv, e);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_csyswapr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_csyswapr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_csyswapr(int matrix_layout, char uplo, int n, _Complex float *a, int lda, int i1, int i2)
     * }
     */
    public static FunctionDescriptor LAPACKE_csyswapr$descriptor() {
        return LAPACKE_csyswapr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_csyswapr(int matrix_layout, char uplo, int n, _Complex float *a, int lda, int i1, int i2)
     * }
     */
    public static MethodHandle LAPACKE_csyswapr$handle() {
        return LAPACKE_csyswapr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_csyswapr(int matrix_layout, char uplo, int n, _Complex float *a, int lda, int i1, int i2)
     * }
     */
    public static MemorySegment LAPACKE_csyswapr$address() {
        return LAPACKE_csyswapr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_csyswapr(int matrix_layout, char uplo, int n, _Complex float *a, int lda, int i1, int i2)
     * }
     */
    public static int LAPACKE_csyswapr(int matrix_layout, byte uplo, int n, MemorySegment a, int lda, int i1, int i2) {
        var mh$ = LAPACKE_csyswapr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_csyswapr", matrix_layout, uplo, n, a, lda, i1, i2);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, a, lda, i1, i2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_csyswapr_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_csyswapr_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_csyswapr_work(int matrix_layout, char uplo, int n, _Complex float *a, int lda, int i1, int i2)
     * }
     */
    public static FunctionDescriptor LAPACKE_csyswapr_work$descriptor() {
        return LAPACKE_csyswapr_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_csyswapr_work(int matrix_layout, char uplo, int n, _Complex float *a, int lda, int i1, int i2)
     * }
     */
    public static MethodHandle LAPACKE_csyswapr_work$handle() {
        return LAPACKE_csyswapr_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_csyswapr_work(int matrix_layout, char uplo, int n, _Complex float *a, int lda, int i1, int i2)
     * }
     */
    public static MemorySegment LAPACKE_csyswapr_work$address() {
        return LAPACKE_csyswapr_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_csyswapr_work(int matrix_layout, char uplo, int n, _Complex float *a, int lda, int i1, int i2)
     * }
     */
    public static int LAPACKE_csyswapr_work(int matrix_layout, byte uplo, int n, MemorySegment a, int lda, int i1, int i2) {
        var mh$ = LAPACKE_csyswapr_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_csyswapr_work", matrix_layout, uplo, n, a, lda, i1, i2);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, a, lda, i1, i2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_csytri2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_csytri2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_csytri2(int matrix_layout, char uplo, int n, _Complex float *a, int lda, const int *ipiv)
     * }
     */
    public static FunctionDescriptor LAPACKE_csytri2$descriptor() {
        return LAPACKE_csytri2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_csytri2(int matrix_layout, char uplo, int n, _Complex float *a, int lda, const int *ipiv)
     * }
     */
    public static MethodHandle LAPACKE_csytri2$handle() {
        return LAPACKE_csytri2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_csytri2(int matrix_layout, char uplo, int n, _Complex float *a, int lda, const int *ipiv)
     * }
     */
    public static MemorySegment LAPACKE_csytri2$address() {
        return LAPACKE_csytri2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_csytri2(int matrix_layout, char uplo, int n, _Complex float *a, int lda, const int *ipiv)
     * }
     */
    public static int LAPACKE_csytri2(int matrix_layout, byte uplo, int n, MemorySegment a, int lda, MemorySegment ipiv) {
        var mh$ = LAPACKE_csytri2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_csytri2", matrix_layout, uplo, n, a, lda, ipiv);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, a, lda, ipiv);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_csytri2_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_csytri2_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_csytri2_work(int matrix_layout, char uplo, int n, _Complex float *a, int lda, const int *ipiv, _Complex float *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_csytri2_work$descriptor() {
        return LAPACKE_csytri2_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_csytri2_work(int matrix_layout, char uplo, int n, _Complex float *a, int lda, const int *ipiv, _Complex float *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_csytri2_work$handle() {
        return LAPACKE_csytri2_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_csytri2_work(int matrix_layout, char uplo, int n, _Complex float *a, int lda, const int *ipiv, _Complex float *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_csytri2_work$address() {
        return LAPACKE_csytri2_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_csytri2_work(int matrix_layout, char uplo, int n, _Complex float *a, int lda, const int *ipiv, _Complex float *work, int lwork)
     * }
     */
    public static int LAPACKE_csytri2_work(int matrix_layout, byte uplo, int n, MemorySegment a, int lda, MemorySegment ipiv, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_csytri2_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_csytri2_work", matrix_layout, uplo, n, a, lda, ipiv, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, a, lda, ipiv, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_csytri2x {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_csytri2x");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_csytri2x(int matrix_layout, char uplo, int n, _Complex float *a, int lda, const int *ipiv, int nb)
     * }
     */
    public static FunctionDescriptor LAPACKE_csytri2x$descriptor() {
        return LAPACKE_csytri2x.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_csytri2x(int matrix_layout, char uplo, int n, _Complex float *a, int lda, const int *ipiv, int nb)
     * }
     */
    public static MethodHandle LAPACKE_csytri2x$handle() {
        return LAPACKE_csytri2x.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_csytri2x(int matrix_layout, char uplo, int n, _Complex float *a, int lda, const int *ipiv, int nb)
     * }
     */
    public static MemorySegment LAPACKE_csytri2x$address() {
        return LAPACKE_csytri2x.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_csytri2x(int matrix_layout, char uplo, int n, _Complex float *a, int lda, const int *ipiv, int nb)
     * }
     */
    public static int LAPACKE_csytri2x(int matrix_layout, byte uplo, int n, MemorySegment a, int lda, MemorySegment ipiv, int nb) {
        var mh$ = LAPACKE_csytri2x.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_csytri2x", matrix_layout, uplo, n, a, lda, ipiv, nb);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, a, lda, ipiv, nb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_csytri2x_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_csytri2x_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_csytri2x_work(int matrix_layout, char uplo, int n, _Complex float *a, int lda, const int *ipiv, _Complex float *work, int nb)
     * }
     */
    public static FunctionDescriptor LAPACKE_csytri2x_work$descriptor() {
        return LAPACKE_csytri2x_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_csytri2x_work(int matrix_layout, char uplo, int n, _Complex float *a, int lda, const int *ipiv, _Complex float *work, int nb)
     * }
     */
    public static MethodHandle LAPACKE_csytri2x_work$handle() {
        return LAPACKE_csytri2x_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_csytri2x_work(int matrix_layout, char uplo, int n, _Complex float *a, int lda, const int *ipiv, _Complex float *work, int nb)
     * }
     */
    public static MemorySegment LAPACKE_csytri2x_work$address() {
        return LAPACKE_csytri2x_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_csytri2x_work(int matrix_layout, char uplo, int n, _Complex float *a, int lda, const int *ipiv, _Complex float *work, int nb)
     * }
     */
    public static int LAPACKE_csytri2x_work(int matrix_layout, byte uplo, int n, MemorySegment a, int lda, MemorySegment ipiv, MemorySegment work, int nb) {
        var mh$ = LAPACKE_csytri2x_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_csytri2x_work", matrix_layout, uplo, n, a, lda, ipiv, work, nb);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, a, lda, ipiv, work, nb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_csytrs2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_csytrs2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_csytrs2(int matrix_layout, char uplo, int n, int nrhs, const _Complex float *a, int lda, const int *ipiv, _Complex float *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_csytrs2$descriptor() {
        return LAPACKE_csytrs2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_csytrs2(int matrix_layout, char uplo, int n, int nrhs, const _Complex float *a, int lda, const int *ipiv, _Complex float *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_csytrs2$handle() {
        return LAPACKE_csytrs2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_csytrs2(int matrix_layout, char uplo, int n, int nrhs, const _Complex float *a, int lda, const int *ipiv, _Complex float *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_csytrs2$address() {
        return LAPACKE_csytrs2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_csytrs2(int matrix_layout, char uplo, int n, int nrhs, const _Complex float *a, int lda, const int *ipiv, _Complex float *b, int ldb)
     * }
     */
    public static int LAPACKE_csytrs2(int matrix_layout, byte uplo, int n, int nrhs, MemorySegment a, int lda, MemorySegment ipiv, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_csytrs2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_csytrs2", matrix_layout, uplo, n, nrhs, a, lda, ipiv, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, nrhs, a, lda, ipiv, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_csytrs2_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_csytrs2_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_csytrs2_work(int matrix_layout, char uplo, int n, int nrhs, const _Complex float *a, int lda, const int *ipiv, _Complex float *b, int ldb, _Complex float *work)
     * }
     */
    public static FunctionDescriptor LAPACKE_csytrs2_work$descriptor() {
        return LAPACKE_csytrs2_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_csytrs2_work(int matrix_layout, char uplo, int n, int nrhs, const _Complex float *a, int lda, const int *ipiv, _Complex float *b, int ldb, _Complex float *work)
     * }
     */
    public static MethodHandle LAPACKE_csytrs2_work$handle() {
        return LAPACKE_csytrs2_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_csytrs2_work(int matrix_layout, char uplo, int n, int nrhs, const _Complex float *a, int lda, const int *ipiv, _Complex float *b, int ldb, _Complex float *work)
     * }
     */
    public static MemorySegment LAPACKE_csytrs2_work$address() {
        return LAPACKE_csytrs2_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_csytrs2_work(int matrix_layout, char uplo, int n, int nrhs, const _Complex float *a, int lda, const int *ipiv, _Complex float *b, int ldb, _Complex float *work)
     * }
     */
    public static int LAPACKE_csytrs2_work(int matrix_layout, byte uplo, int n, int nrhs, MemorySegment a, int lda, MemorySegment ipiv, MemorySegment b, int ldb, MemorySegment work) {
        var mh$ = LAPACKE_csytrs2_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_csytrs2_work", matrix_layout, uplo, n, nrhs, a, lda, ipiv, b, ldb, work);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, nrhs, a, lda, ipiv, b, ldb, work);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cunbdb {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_cunbdb");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cunbdb(int matrix_layout, char trans, char signs, int m, int p, int q, _Complex float *x11, int ldx11, _Complex float *x12, int ldx12, _Complex float *x21, int ldx21, _Complex float *x22, int ldx22, float *theta, float *phi, _Complex float *taup1, _Complex float *taup2, _Complex float *tauq1, _Complex float *tauq2)
     * }
     */
    public static FunctionDescriptor LAPACKE_cunbdb$descriptor() {
        return LAPACKE_cunbdb.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cunbdb(int matrix_layout, char trans, char signs, int m, int p, int q, _Complex float *x11, int ldx11, _Complex float *x12, int ldx12, _Complex float *x21, int ldx21, _Complex float *x22, int ldx22, float *theta, float *phi, _Complex float *taup1, _Complex float *taup2, _Complex float *tauq1, _Complex float *tauq2)
     * }
     */
    public static MethodHandle LAPACKE_cunbdb$handle() {
        return LAPACKE_cunbdb.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cunbdb(int matrix_layout, char trans, char signs, int m, int p, int q, _Complex float *x11, int ldx11, _Complex float *x12, int ldx12, _Complex float *x21, int ldx21, _Complex float *x22, int ldx22, float *theta, float *phi, _Complex float *taup1, _Complex float *taup2, _Complex float *tauq1, _Complex float *tauq2)
     * }
     */
    public static MemorySegment LAPACKE_cunbdb$address() {
        return LAPACKE_cunbdb.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cunbdb(int matrix_layout, char trans, char signs, int m, int p, int q, _Complex float *x11, int ldx11, _Complex float *x12, int ldx12, _Complex float *x21, int ldx21, _Complex float *x22, int ldx22, float *theta, float *phi, _Complex float *taup1, _Complex float *taup2, _Complex float *tauq1, _Complex float *tauq2)
     * }
     */
    public static int LAPACKE_cunbdb(int matrix_layout, byte trans, byte signs, int m, int p, int q, MemorySegment x11, int ldx11, MemorySegment x12, int ldx12, MemorySegment x21, int ldx21, MemorySegment x22, int ldx22, MemorySegment theta, MemorySegment phi, MemorySegment taup1, MemorySegment taup2, MemorySegment tauq1, MemorySegment tauq2) {
        var mh$ = LAPACKE_cunbdb.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cunbdb", matrix_layout, trans, signs, m, p, q, x11, ldx11, x12, ldx12, x21, ldx21, x22, ldx22, theta, phi, taup1, taup2, tauq1, tauq2);
            }
            return (int)mh$.invokeExact(matrix_layout, trans, signs, m, p, q, x11, ldx11, x12, ldx12, x21, ldx21, x22, ldx22, theta, phi, taup1, taup2, tauq1, tauq2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cunbdb_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_cunbdb_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cunbdb_work(int matrix_layout, char trans, char signs, int m, int p, int q, _Complex float *x11, int ldx11, _Complex float *x12, int ldx12, _Complex float *x21, int ldx21, _Complex float *x22, int ldx22, float *theta, float *phi, _Complex float *taup1, _Complex float *taup2, _Complex float *tauq1, _Complex float *tauq2, _Complex float *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_cunbdb_work$descriptor() {
        return LAPACKE_cunbdb_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cunbdb_work(int matrix_layout, char trans, char signs, int m, int p, int q, _Complex float *x11, int ldx11, _Complex float *x12, int ldx12, _Complex float *x21, int ldx21, _Complex float *x22, int ldx22, float *theta, float *phi, _Complex float *taup1, _Complex float *taup2, _Complex float *tauq1, _Complex float *tauq2, _Complex float *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_cunbdb_work$handle() {
        return LAPACKE_cunbdb_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cunbdb_work(int matrix_layout, char trans, char signs, int m, int p, int q, _Complex float *x11, int ldx11, _Complex float *x12, int ldx12, _Complex float *x21, int ldx21, _Complex float *x22, int ldx22, float *theta, float *phi, _Complex float *taup1, _Complex float *taup2, _Complex float *tauq1, _Complex float *tauq2, _Complex float *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_cunbdb_work$address() {
        return LAPACKE_cunbdb_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cunbdb_work(int matrix_layout, char trans, char signs, int m, int p, int q, _Complex float *x11, int ldx11, _Complex float *x12, int ldx12, _Complex float *x21, int ldx21, _Complex float *x22, int ldx22, float *theta, float *phi, _Complex float *taup1, _Complex float *taup2, _Complex float *tauq1, _Complex float *tauq2, _Complex float *work, int lwork)
     * }
     */
    public static int LAPACKE_cunbdb_work(int matrix_layout, byte trans, byte signs, int m, int p, int q, MemorySegment x11, int ldx11, MemorySegment x12, int ldx12, MemorySegment x21, int ldx21, MemorySegment x22, int ldx22, MemorySegment theta, MemorySegment phi, MemorySegment taup1, MemorySegment taup2, MemorySegment tauq1, MemorySegment tauq2, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_cunbdb_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cunbdb_work", matrix_layout, trans, signs, m, p, q, x11, ldx11, x12, ldx12, x21, ldx21, x22, ldx22, theta, phi, taup1, taup2, tauq1, tauq2, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, trans, signs, m, p, q, x11, ldx11, x12, ldx12, x21, ldx21, x22, ldx22, theta, phi, taup1, taup2, tauq1, tauq2, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cuncsd {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_cuncsd");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cuncsd(int matrix_layout, char jobu1, char jobu2, char jobv1t, char jobv2t, char trans, char signs, int m, int p, int q, _Complex float *x11, int ldx11, _Complex float *x12, int ldx12, _Complex float *x21, int ldx21, _Complex float *x22, int ldx22, float *theta, _Complex float *u1, int ldu1, _Complex float *u2, int ldu2, _Complex float *v1t, int ldv1t, _Complex float *v2t, int ldv2t)
     * }
     */
    public static FunctionDescriptor LAPACKE_cuncsd$descriptor() {
        return LAPACKE_cuncsd.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cuncsd(int matrix_layout, char jobu1, char jobu2, char jobv1t, char jobv2t, char trans, char signs, int m, int p, int q, _Complex float *x11, int ldx11, _Complex float *x12, int ldx12, _Complex float *x21, int ldx21, _Complex float *x22, int ldx22, float *theta, _Complex float *u1, int ldu1, _Complex float *u2, int ldu2, _Complex float *v1t, int ldv1t, _Complex float *v2t, int ldv2t)
     * }
     */
    public static MethodHandle LAPACKE_cuncsd$handle() {
        return LAPACKE_cuncsd.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cuncsd(int matrix_layout, char jobu1, char jobu2, char jobv1t, char jobv2t, char trans, char signs, int m, int p, int q, _Complex float *x11, int ldx11, _Complex float *x12, int ldx12, _Complex float *x21, int ldx21, _Complex float *x22, int ldx22, float *theta, _Complex float *u1, int ldu1, _Complex float *u2, int ldu2, _Complex float *v1t, int ldv1t, _Complex float *v2t, int ldv2t)
     * }
     */
    public static MemorySegment LAPACKE_cuncsd$address() {
        return LAPACKE_cuncsd.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cuncsd(int matrix_layout, char jobu1, char jobu2, char jobv1t, char jobv2t, char trans, char signs, int m, int p, int q, _Complex float *x11, int ldx11, _Complex float *x12, int ldx12, _Complex float *x21, int ldx21, _Complex float *x22, int ldx22, float *theta, _Complex float *u1, int ldu1, _Complex float *u2, int ldu2, _Complex float *v1t, int ldv1t, _Complex float *v2t, int ldv2t)
     * }
     */
    public static int LAPACKE_cuncsd(int matrix_layout, byte jobu1, byte jobu2, byte jobv1t, byte jobv2t, byte trans, byte signs, int m, int p, int q, MemorySegment x11, int ldx11, MemorySegment x12, int ldx12, MemorySegment x21, int ldx21, MemorySegment x22, int ldx22, MemorySegment theta, MemorySegment u1, int ldu1, MemorySegment u2, int ldu2, MemorySegment v1t, int ldv1t, MemorySegment v2t, int ldv2t) {
        var mh$ = LAPACKE_cuncsd.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cuncsd", matrix_layout, jobu1, jobu2, jobv1t, jobv2t, trans, signs, m, p, q, x11, ldx11, x12, ldx12, x21, ldx21, x22, ldx22, theta, u1, ldu1, u2, ldu2, v1t, ldv1t, v2t, ldv2t);
            }
            return (int)mh$.invokeExact(matrix_layout, jobu1, jobu2, jobv1t, jobv2t, trans, signs, m, p, q, x11, ldx11, x12, ldx12, x21, ldx21, x22, ldx22, theta, u1, ldu1, u2, ldu2, v1t, ldv1t, v2t, ldv2t);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cuncsd_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_cuncsd_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cuncsd_work(int matrix_layout, char jobu1, char jobu2, char jobv1t, char jobv2t, char trans, char signs, int m, int p, int q, _Complex float *x11, int ldx11, _Complex float *x12, int ldx12, _Complex float *x21, int ldx21, _Complex float *x22, int ldx22, float *theta, _Complex float *u1, int ldu1, _Complex float *u2, int ldu2, _Complex float *v1t, int ldv1t, _Complex float *v2t, int ldv2t, _Complex float *work, int lwork, float *rwork, int lrwork, int *iwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_cuncsd_work$descriptor() {
        return LAPACKE_cuncsd_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cuncsd_work(int matrix_layout, char jobu1, char jobu2, char jobv1t, char jobv2t, char trans, char signs, int m, int p, int q, _Complex float *x11, int ldx11, _Complex float *x12, int ldx12, _Complex float *x21, int ldx21, _Complex float *x22, int ldx22, float *theta, _Complex float *u1, int ldu1, _Complex float *u2, int ldu2, _Complex float *v1t, int ldv1t, _Complex float *v2t, int ldv2t, _Complex float *work, int lwork, float *rwork, int lrwork, int *iwork)
     * }
     */
    public static MethodHandle LAPACKE_cuncsd_work$handle() {
        return LAPACKE_cuncsd_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cuncsd_work(int matrix_layout, char jobu1, char jobu2, char jobv1t, char jobv2t, char trans, char signs, int m, int p, int q, _Complex float *x11, int ldx11, _Complex float *x12, int ldx12, _Complex float *x21, int ldx21, _Complex float *x22, int ldx22, float *theta, _Complex float *u1, int ldu1, _Complex float *u2, int ldu2, _Complex float *v1t, int ldv1t, _Complex float *v2t, int ldv2t, _Complex float *work, int lwork, float *rwork, int lrwork, int *iwork)
     * }
     */
    public static MemorySegment LAPACKE_cuncsd_work$address() {
        return LAPACKE_cuncsd_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cuncsd_work(int matrix_layout, char jobu1, char jobu2, char jobv1t, char jobv2t, char trans, char signs, int m, int p, int q, _Complex float *x11, int ldx11, _Complex float *x12, int ldx12, _Complex float *x21, int ldx21, _Complex float *x22, int ldx22, float *theta, _Complex float *u1, int ldu1, _Complex float *u2, int ldu2, _Complex float *v1t, int ldv1t, _Complex float *v2t, int ldv2t, _Complex float *work, int lwork, float *rwork, int lrwork, int *iwork)
     * }
     */
    public static int LAPACKE_cuncsd_work(int matrix_layout, byte jobu1, byte jobu2, byte jobv1t, byte jobv2t, byte trans, byte signs, int m, int p, int q, MemorySegment x11, int ldx11, MemorySegment x12, int ldx12, MemorySegment x21, int ldx21, MemorySegment x22, int ldx22, MemorySegment theta, MemorySegment u1, int ldu1, MemorySegment u2, int ldu2, MemorySegment v1t, int ldv1t, MemorySegment v2t, int ldv2t, MemorySegment work, int lwork, MemorySegment rwork, int lrwork, MemorySegment iwork) {
        var mh$ = LAPACKE_cuncsd_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cuncsd_work", matrix_layout, jobu1, jobu2, jobv1t, jobv2t, trans, signs, m, p, q, x11, ldx11, x12, ldx12, x21, ldx21, x22, ldx22, theta, u1, ldu1, u2, ldu2, v1t, ldv1t, v2t, ldv2t, work, lwork, rwork, lrwork, iwork);
            }
            return (int)mh$.invokeExact(matrix_layout, jobu1, jobu2, jobv1t, jobv2t, trans, signs, m, p, q, x11, ldx11, x12, ldx12, x21, ldx21, x22, ldx22, theta, u1, ldu1, u2, ldu2, v1t, ldv1t, v2t, ldv2t, work, lwork, rwork, lrwork, iwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cuncsd2by1 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_cuncsd2by1");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cuncsd2by1(int matrix_layout, char jobu1, char jobu2, char jobv1t, int m, int p, int q, _Complex float *x11, int ldx11, _Complex float *x21, int ldx21, float *theta, _Complex float *u1, int ldu1, _Complex float *u2, int ldu2, _Complex float *v1t, int ldv1t)
     * }
     */
    public static FunctionDescriptor LAPACKE_cuncsd2by1$descriptor() {
        return LAPACKE_cuncsd2by1.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cuncsd2by1(int matrix_layout, char jobu1, char jobu2, char jobv1t, int m, int p, int q, _Complex float *x11, int ldx11, _Complex float *x21, int ldx21, float *theta, _Complex float *u1, int ldu1, _Complex float *u2, int ldu2, _Complex float *v1t, int ldv1t)
     * }
     */
    public static MethodHandle LAPACKE_cuncsd2by1$handle() {
        return LAPACKE_cuncsd2by1.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cuncsd2by1(int matrix_layout, char jobu1, char jobu2, char jobv1t, int m, int p, int q, _Complex float *x11, int ldx11, _Complex float *x21, int ldx21, float *theta, _Complex float *u1, int ldu1, _Complex float *u2, int ldu2, _Complex float *v1t, int ldv1t)
     * }
     */
    public static MemorySegment LAPACKE_cuncsd2by1$address() {
        return LAPACKE_cuncsd2by1.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cuncsd2by1(int matrix_layout, char jobu1, char jobu2, char jobv1t, int m, int p, int q, _Complex float *x11, int ldx11, _Complex float *x21, int ldx21, float *theta, _Complex float *u1, int ldu1, _Complex float *u2, int ldu2, _Complex float *v1t, int ldv1t)
     * }
     */
    public static int LAPACKE_cuncsd2by1(int matrix_layout, byte jobu1, byte jobu2, byte jobv1t, int m, int p, int q, MemorySegment x11, int ldx11, MemorySegment x21, int ldx21, MemorySegment theta, MemorySegment u1, int ldu1, MemorySegment u2, int ldu2, MemorySegment v1t, int ldv1t) {
        var mh$ = LAPACKE_cuncsd2by1.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cuncsd2by1", matrix_layout, jobu1, jobu2, jobv1t, m, p, q, x11, ldx11, x21, ldx21, theta, u1, ldu1, u2, ldu2, v1t, ldv1t);
            }
            return (int)mh$.invokeExact(matrix_layout, jobu1, jobu2, jobv1t, m, p, q, x11, ldx11, x21, ldx21, theta, u1, ldu1, u2, ldu2, v1t, ldv1t);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cuncsd2by1_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_cuncsd2by1_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cuncsd2by1_work(int matrix_layout, char jobu1, char jobu2, char jobv1t, int m, int p, int q, _Complex float *x11, int ldx11, _Complex float *x21, int ldx21, float *theta, _Complex float *u1, int ldu1, _Complex float *u2, int ldu2, _Complex float *v1t, int ldv1t, _Complex float *work, int lwork, float *rwork, int lrwork, int *iwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_cuncsd2by1_work$descriptor() {
        return LAPACKE_cuncsd2by1_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cuncsd2by1_work(int matrix_layout, char jobu1, char jobu2, char jobv1t, int m, int p, int q, _Complex float *x11, int ldx11, _Complex float *x21, int ldx21, float *theta, _Complex float *u1, int ldu1, _Complex float *u2, int ldu2, _Complex float *v1t, int ldv1t, _Complex float *work, int lwork, float *rwork, int lrwork, int *iwork)
     * }
     */
    public static MethodHandle LAPACKE_cuncsd2by1_work$handle() {
        return LAPACKE_cuncsd2by1_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cuncsd2by1_work(int matrix_layout, char jobu1, char jobu2, char jobv1t, int m, int p, int q, _Complex float *x11, int ldx11, _Complex float *x21, int ldx21, float *theta, _Complex float *u1, int ldu1, _Complex float *u2, int ldu2, _Complex float *v1t, int ldv1t, _Complex float *work, int lwork, float *rwork, int lrwork, int *iwork)
     * }
     */
    public static MemorySegment LAPACKE_cuncsd2by1_work$address() {
        return LAPACKE_cuncsd2by1_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cuncsd2by1_work(int matrix_layout, char jobu1, char jobu2, char jobv1t, int m, int p, int q, _Complex float *x11, int ldx11, _Complex float *x21, int ldx21, float *theta, _Complex float *u1, int ldu1, _Complex float *u2, int ldu2, _Complex float *v1t, int ldv1t, _Complex float *work, int lwork, float *rwork, int lrwork, int *iwork)
     * }
     */
    public static int LAPACKE_cuncsd2by1_work(int matrix_layout, byte jobu1, byte jobu2, byte jobv1t, int m, int p, int q, MemorySegment x11, int ldx11, MemorySegment x21, int ldx21, MemorySegment theta, MemorySegment u1, int ldu1, MemorySegment u2, int ldu2, MemorySegment v1t, int ldv1t, MemorySegment work, int lwork, MemorySegment rwork, int lrwork, MemorySegment iwork) {
        var mh$ = LAPACKE_cuncsd2by1_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cuncsd2by1_work", matrix_layout, jobu1, jobu2, jobv1t, m, p, q, x11, ldx11, x21, ldx21, theta, u1, ldu1, u2, ldu2, v1t, ldv1t, work, lwork, rwork, lrwork, iwork);
            }
            return (int)mh$.invokeExact(matrix_layout, jobu1, jobu2, jobv1t, m, p, q, x11, ldx11, x21, ldx21, theta, u1, ldu1, u2, ldu2, v1t, ldv1t, work, lwork, rwork, lrwork, iwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dbbcsd {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dbbcsd");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dbbcsd(int matrix_layout, char jobu1, char jobu2, char jobv1t, char jobv2t, char trans, int m, int p, int q, double *theta, double *phi, double *u1, int ldu1, double *u2, int ldu2, double *v1t, int ldv1t, double *v2t, int ldv2t, double *b11d, double *b11e, double *b12d, double *b12e, double *b21d, double *b21e, double *b22d, double *b22e)
     * }
     */
    public static FunctionDescriptor LAPACKE_dbbcsd$descriptor() {
        return LAPACKE_dbbcsd.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dbbcsd(int matrix_layout, char jobu1, char jobu2, char jobv1t, char jobv2t, char trans, int m, int p, int q, double *theta, double *phi, double *u1, int ldu1, double *u2, int ldu2, double *v1t, int ldv1t, double *v2t, int ldv2t, double *b11d, double *b11e, double *b12d, double *b12e, double *b21d, double *b21e, double *b22d, double *b22e)
     * }
     */
    public static MethodHandle LAPACKE_dbbcsd$handle() {
        return LAPACKE_dbbcsd.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dbbcsd(int matrix_layout, char jobu1, char jobu2, char jobv1t, char jobv2t, char trans, int m, int p, int q, double *theta, double *phi, double *u1, int ldu1, double *u2, int ldu2, double *v1t, int ldv1t, double *v2t, int ldv2t, double *b11d, double *b11e, double *b12d, double *b12e, double *b21d, double *b21e, double *b22d, double *b22e)
     * }
     */
    public static MemorySegment LAPACKE_dbbcsd$address() {
        return LAPACKE_dbbcsd.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dbbcsd(int matrix_layout, char jobu1, char jobu2, char jobv1t, char jobv2t, char trans, int m, int p, int q, double *theta, double *phi, double *u1, int ldu1, double *u2, int ldu2, double *v1t, int ldv1t, double *v2t, int ldv2t, double *b11d, double *b11e, double *b12d, double *b12e, double *b21d, double *b21e, double *b22d, double *b22e)
     * }
     */
    public static int LAPACKE_dbbcsd(int matrix_layout, byte jobu1, byte jobu2, byte jobv1t, byte jobv2t, byte trans, int m, int p, int q, MemorySegment theta, MemorySegment phi, MemorySegment u1, int ldu1, MemorySegment u2, int ldu2, MemorySegment v1t, int ldv1t, MemorySegment v2t, int ldv2t, MemorySegment b11d, MemorySegment b11e, MemorySegment b12d, MemorySegment b12e, MemorySegment b21d, MemorySegment b21e, MemorySegment b22d, MemorySegment b22e) {
        var mh$ = LAPACKE_dbbcsd.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dbbcsd", matrix_layout, jobu1, jobu2, jobv1t, jobv2t, trans, m, p, q, theta, phi, u1, ldu1, u2, ldu2, v1t, ldv1t, v2t, ldv2t, b11d, b11e, b12d, b12e, b21d, b21e, b22d, b22e);
            }
            return (int)mh$.invokeExact(matrix_layout, jobu1, jobu2, jobv1t, jobv2t, trans, m, p, q, theta, phi, u1, ldu1, u2, ldu2, v1t, ldv1t, v2t, ldv2t, b11d, b11e, b12d, b12e, b21d, b21e, b22d, b22e);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dbbcsd_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dbbcsd_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dbbcsd_work(int matrix_layout, char jobu1, char jobu2, char jobv1t, char jobv2t, char trans, int m, int p, int q, double *theta, double *phi, double *u1, int ldu1, double *u2, int ldu2, double *v1t, int ldv1t, double *v2t, int ldv2t, double *b11d, double *b11e, double *b12d, double *b12e, double *b21d, double *b21e, double *b22d, double *b22e, double *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_dbbcsd_work$descriptor() {
        return LAPACKE_dbbcsd_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dbbcsd_work(int matrix_layout, char jobu1, char jobu2, char jobv1t, char jobv2t, char trans, int m, int p, int q, double *theta, double *phi, double *u1, int ldu1, double *u2, int ldu2, double *v1t, int ldv1t, double *v2t, int ldv2t, double *b11d, double *b11e, double *b12d, double *b12e, double *b21d, double *b21e, double *b22d, double *b22e, double *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_dbbcsd_work$handle() {
        return LAPACKE_dbbcsd_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dbbcsd_work(int matrix_layout, char jobu1, char jobu2, char jobv1t, char jobv2t, char trans, int m, int p, int q, double *theta, double *phi, double *u1, int ldu1, double *u2, int ldu2, double *v1t, int ldv1t, double *v2t, int ldv2t, double *b11d, double *b11e, double *b12d, double *b12e, double *b21d, double *b21e, double *b22d, double *b22e, double *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_dbbcsd_work$address() {
        return LAPACKE_dbbcsd_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dbbcsd_work(int matrix_layout, char jobu1, char jobu2, char jobv1t, char jobv2t, char trans, int m, int p, int q, double *theta, double *phi, double *u1, int ldu1, double *u2, int ldu2, double *v1t, int ldv1t, double *v2t, int ldv2t, double *b11d, double *b11e, double *b12d, double *b12e, double *b21d, double *b21e, double *b22d, double *b22e, double *work, int lwork)
     * }
     */
    public static int LAPACKE_dbbcsd_work(int matrix_layout, byte jobu1, byte jobu2, byte jobv1t, byte jobv2t, byte trans, int m, int p, int q, MemorySegment theta, MemorySegment phi, MemorySegment u1, int ldu1, MemorySegment u2, int ldu2, MemorySegment v1t, int ldv1t, MemorySegment v2t, int ldv2t, MemorySegment b11d, MemorySegment b11e, MemorySegment b12d, MemorySegment b12e, MemorySegment b21d, MemorySegment b21e, MemorySegment b22d, MemorySegment b22e, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_dbbcsd_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dbbcsd_work", matrix_layout, jobu1, jobu2, jobv1t, jobv2t, trans, m, p, q, theta, phi, u1, ldu1, u2, ldu2, v1t, ldv1t, v2t, ldv2t, b11d, b11e, b12d, b12e, b21d, b21e, b22d, b22e, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, jobu1, jobu2, jobv1t, jobv2t, trans, m, p, q, theta, phi, u1, ldu1, u2, ldu2, v1t, ldv1t, v2t, ldv2t, b11d, b11e, b12d, b12e, b21d, b21e, b22d, b22e, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dorbdb {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dorbdb");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dorbdb(int matrix_layout, char trans, char signs, int m, int p, int q, double *x11, int ldx11, double *x12, int ldx12, double *x21, int ldx21, double *x22, int ldx22, double *theta, double *phi, double *taup1, double *taup2, double *tauq1, double *tauq2)
     * }
     */
    public static FunctionDescriptor LAPACKE_dorbdb$descriptor() {
        return LAPACKE_dorbdb.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dorbdb(int matrix_layout, char trans, char signs, int m, int p, int q, double *x11, int ldx11, double *x12, int ldx12, double *x21, int ldx21, double *x22, int ldx22, double *theta, double *phi, double *taup1, double *taup2, double *tauq1, double *tauq2)
     * }
     */
    public static MethodHandle LAPACKE_dorbdb$handle() {
        return LAPACKE_dorbdb.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dorbdb(int matrix_layout, char trans, char signs, int m, int p, int q, double *x11, int ldx11, double *x12, int ldx12, double *x21, int ldx21, double *x22, int ldx22, double *theta, double *phi, double *taup1, double *taup2, double *tauq1, double *tauq2)
     * }
     */
    public static MemorySegment LAPACKE_dorbdb$address() {
        return LAPACKE_dorbdb.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dorbdb(int matrix_layout, char trans, char signs, int m, int p, int q, double *x11, int ldx11, double *x12, int ldx12, double *x21, int ldx21, double *x22, int ldx22, double *theta, double *phi, double *taup1, double *taup2, double *tauq1, double *tauq2)
     * }
     */
    public static int LAPACKE_dorbdb(int matrix_layout, byte trans, byte signs, int m, int p, int q, MemorySegment x11, int ldx11, MemorySegment x12, int ldx12, MemorySegment x21, int ldx21, MemorySegment x22, int ldx22, MemorySegment theta, MemorySegment phi, MemorySegment taup1, MemorySegment taup2, MemorySegment tauq1, MemorySegment tauq2) {
        var mh$ = LAPACKE_dorbdb.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dorbdb", matrix_layout, trans, signs, m, p, q, x11, ldx11, x12, ldx12, x21, ldx21, x22, ldx22, theta, phi, taup1, taup2, tauq1, tauq2);
            }
            return (int)mh$.invokeExact(matrix_layout, trans, signs, m, p, q, x11, ldx11, x12, ldx12, x21, ldx21, x22, ldx22, theta, phi, taup1, taup2, tauq1, tauq2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dorbdb_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dorbdb_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dorbdb_work(int matrix_layout, char trans, char signs, int m, int p, int q, double *x11, int ldx11, double *x12, int ldx12, double *x21, int ldx21, double *x22, int ldx22, double *theta, double *phi, double *taup1, double *taup2, double *tauq1, double *tauq2, double *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_dorbdb_work$descriptor() {
        return LAPACKE_dorbdb_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dorbdb_work(int matrix_layout, char trans, char signs, int m, int p, int q, double *x11, int ldx11, double *x12, int ldx12, double *x21, int ldx21, double *x22, int ldx22, double *theta, double *phi, double *taup1, double *taup2, double *tauq1, double *tauq2, double *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_dorbdb_work$handle() {
        return LAPACKE_dorbdb_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dorbdb_work(int matrix_layout, char trans, char signs, int m, int p, int q, double *x11, int ldx11, double *x12, int ldx12, double *x21, int ldx21, double *x22, int ldx22, double *theta, double *phi, double *taup1, double *taup2, double *tauq1, double *tauq2, double *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_dorbdb_work$address() {
        return LAPACKE_dorbdb_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dorbdb_work(int matrix_layout, char trans, char signs, int m, int p, int q, double *x11, int ldx11, double *x12, int ldx12, double *x21, int ldx21, double *x22, int ldx22, double *theta, double *phi, double *taup1, double *taup2, double *tauq1, double *tauq2, double *work, int lwork)
     * }
     */
    public static int LAPACKE_dorbdb_work(int matrix_layout, byte trans, byte signs, int m, int p, int q, MemorySegment x11, int ldx11, MemorySegment x12, int ldx12, MemorySegment x21, int ldx21, MemorySegment x22, int ldx22, MemorySegment theta, MemorySegment phi, MemorySegment taup1, MemorySegment taup2, MemorySegment tauq1, MemorySegment tauq2, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_dorbdb_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dorbdb_work", matrix_layout, trans, signs, m, p, q, x11, ldx11, x12, ldx12, x21, ldx21, x22, ldx22, theta, phi, taup1, taup2, tauq1, tauq2, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, trans, signs, m, p, q, x11, ldx11, x12, ldx12, x21, ldx21, x22, ldx22, theta, phi, taup1, taup2, tauq1, tauq2, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dorcsd {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dorcsd");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dorcsd(int matrix_layout, char jobu1, char jobu2, char jobv1t, char jobv2t, char trans, char signs, int m, int p, int q, double *x11, int ldx11, double *x12, int ldx12, double *x21, int ldx21, double *x22, int ldx22, double *theta, double *u1, int ldu1, double *u2, int ldu2, double *v1t, int ldv1t, double *v2t, int ldv2t)
     * }
     */
    public static FunctionDescriptor LAPACKE_dorcsd$descriptor() {
        return LAPACKE_dorcsd.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dorcsd(int matrix_layout, char jobu1, char jobu2, char jobv1t, char jobv2t, char trans, char signs, int m, int p, int q, double *x11, int ldx11, double *x12, int ldx12, double *x21, int ldx21, double *x22, int ldx22, double *theta, double *u1, int ldu1, double *u2, int ldu2, double *v1t, int ldv1t, double *v2t, int ldv2t)
     * }
     */
    public static MethodHandle LAPACKE_dorcsd$handle() {
        return LAPACKE_dorcsd.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dorcsd(int matrix_layout, char jobu1, char jobu2, char jobv1t, char jobv2t, char trans, char signs, int m, int p, int q, double *x11, int ldx11, double *x12, int ldx12, double *x21, int ldx21, double *x22, int ldx22, double *theta, double *u1, int ldu1, double *u2, int ldu2, double *v1t, int ldv1t, double *v2t, int ldv2t)
     * }
     */
    public static MemorySegment LAPACKE_dorcsd$address() {
        return LAPACKE_dorcsd.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dorcsd(int matrix_layout, char jobu1, char jobu2, char jobv1t, char jobv2t, char trans, char signs, int m, int p, int q, double *x11, int ldx11, double *x12, int ldx12, double *x21, int ldx21, double *x22, int ldx22, double *theta, double *u1, int ldu1, double *u2, int ldu2, double *v1t, int ldv1t, double *v2t, int ldv2t)
     * }
     */
    public static int LAPACKE_dorcsd(int matrix_layout, byte jobu1, byte jobu2, byte jobv1t, byte jobv2t, byte trans, byte signs, int m, int p, int q, MemorySegment x11, int ldx11, MemorySegment x12, int ldx12, MemorySegment x21, int ldx21, MemorySegment x22, int ldx22, MemorySegment theta, MemorySegment u1, int ldu1, MemorySegment u2, int ldu2, MemorySegment v1t, int ldv1t, MemorySegment v2t, int ldv2t) {
        var mh$ = LAPACKE_dorcsd.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dorcsd", matrix_layout, jobu1, jobu2, jobv1t, jobv2t, trans, signs, m, p, q, x11, ldx11, x12, ldx12, x21, ldx21, x22, ldx22, theta, u1, ldu1, u2, ldu2, v1t, ldv1t, v2t, ldv2t);
            }
            return (int)mh$.invokeExact(matrix_layout, jobu1, jobu2, jobv1t, jobv2t, trans, signs, m, p, q, x11, ldx11, x12, ldx12, x21, ldx21, x22, ldx22, theta, u1, ldu1, u2, ldu2, v1t, ldv1t, v2t, ldv2t);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dorcsd_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dorcsd_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dorcsd_work(int matrix_layout, char jobu1, char jobu2, char jobv1t, char jobv2t, char trans, char signs, int m, int p, int q, double *x11, int ldx11, double *x12, int ldx12, double *x21, int ldx21, double *x22, int ldx22, double *theta, double *u1, int ldu1, double *u2, int ldu2, double *v1t, int ldv1t, double *v2t, int ldv2t, double *work, int lwork, int *iwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_dorcsd_work$descriptor() {
        return LAPACKE_dorcsd_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dorcsd_work(int matrix_layout, char jobu1, char jobu2, char jobv1t, char jobv2t, char trans, char signs, int m, int p, int q, double *x11, int ldx11, double *x12, int ldx12, double *x21, int ldx21, double *x22, int ldx22, double *theta, double *u1, int ldu1, double *u2, int ldu2, double *v1t, int ldv1t, double *v2t, int ldv2t, double *work, int lwork, int *iwork)
     * }
     */
    public static MethodHandle LAPACKE_dorcsd_work$handle() {
        return LAPACKE_dorcsd_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dorcsd_work(int matrix_layout, char jobu1, char jobu2, char jobv1t, char jobv2t, char trans, char signs, int m, int p, int q, double *x11, int ldx11, double *x12, int ldx12, double *x21, int ldx21, double *x22, int ldx22, double *theta, double *u1, int ldu1, double *u2, int ldu2, double *v1t, int ldv1t, double *v2t, int ldv2t, double *work, int lwork, int *iwork)
     * }
     */
    public static MemorySegment LAPACKE_dorcsd_work$address() {
        return LAPACKE_dorcsd_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dorcsd_work(int matrix_layout, char jobu1, char jobu2, char jobv1t, char jobv2t, char trans, char signs, int m, int p, int q, double *x11, int ldx11, double *x12, int ldx12, double *x21, int ldx21, double *x22, int ldx22, double *theta, double *u1, int ldu1, double *u2, int ldu2, double *v1t, int ldv1t, double *v2t, int ldv2t, double *work, int lwork, int *iwork)
     * }
     */
    public static int LAPACKE_dorcsd_work(int matrix_layout, byte jobu1, byte jobu2, byte jobv1t, byte jobv2t, byte trans, byte signs, int m, int p, int q, MemorySegment x11, int ldx11, MemorySegment x12, int ldx12, MemorySegment x21, int ldx21, MemorySegment x22, int ldx22, MemorySegment theta, MemorySegment u1, int ldu1, MemorySegment u2, int ldu2, MemorySegment v1t, int ldv1t, MemorySegment v2t, int ldv2t, MemorySegment work, int lwork, MemorySegment iwork) {
        var mh$ = LAPACKE_dorcsd_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dorcsd_work", matrix_layout, jobu1, jobu2, jobv1t, jobv2t, trans, signs, m, p, q, x11, ldx11, x12, ldx12, x21, ldx21, x22, ldx22, theta, u1, ldu1, u2, ldu2, v1t, ldv1t, v2t, ldv2t, work, lwork, iwork);
            }
            return (int)mh$.invokeExact(matrix_layout, jobu1, jobu2, jobv1t, jobv2t, trans, signs, m, p, q, x11, ldx11, x12, ldx12, x21, ldx21, x22, ldx22, theta, u1, ldu1, u2, ldu2, v1t, ldv1t, v2t, ldv2t, work, lwork, iwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dorcsd2by1 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dorcsd2by1");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dorcsd2by1(int matrix_layout, char jobu1, char jobu2, char jobv1t, int m, int p, int q, double *x11, int ldx11, double *x21, int ldx21, double *theta, double *u1, int ldu1, double *u2, int ldu2, double *v1t, int ldv1t)
     * }
     */
    public static FunctionDescriptor LAPACKE_dorcsd2by1$descriptor() {
        return LAPACKE_dorcsd2by1.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dorcsd2by1(int matrix_layout, char jobu1, char jobu2, char jobv1t, int m, int p, int q, double *x11, int ldx11, double *x21, int ldx21, double *theta, double *u1, int ldu1, double *u2, int ldu2, double *v1t, int ldv1t)
     * }
     */
    public static MethodHandle LAPACKE_dorcsd2by1$handle() {
        return LAPACKE_dorcsd2by1.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dorcsd2by1(int matrix_layout, char jobu1, char jobu2, char jobv1t, int m, int p, int q, double *x11, int ldx11, double *x21, int ldx21, double *theta, double *u1, int ldu1, double *u2, int ldu2, double *v1t, int ldv1t)
     * }
     */
    public static MemorySegment LAPACKE_dorcsd2by1$address() {
        return LAPACKE_dorcsd2by1.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dorcsd2by1(int matrix_layout, char jobu1, char jobu2, char jobv1t, int m, int p, int q, double *x11, int ldx11, double *x21, int ldx21, double *theta, double *u1, int ldu1, double *u2, int ldu2, double *v1t, int ldv1t)
     * }
     */
    public static int LAPACKE_dorcsd2by1(int matrix_layout, byte jobu1, byte jobu2, byte jobv1t, int m, int p, int q, MemorySegment x11, int ldx11, MemorySegment x21, int ldx21, MemorySegment theta, MemorySegment u1, int ldu1, MemorySegment u2, int ldu2, MemorySegment v1t, int ldv1t) {
        var mh$ = LAPACKE_dorcsd2by1.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dorcsd2by1", matrix_layout, jobu1, jobu2, jobv1t, m, p, q, x11, ldx11, x21, ldx21, theta, u1, ldu1, u2, ldu2, v1t, ldv1t);
            }
            return (int)mh$.invokeExact(matrix_layout, jobu1, jobu2, jobv1t, m, p, q, x11, ldx11, x21, ldx21, theta, u1, ldu1, u2, ldu2, v1t, ldv1t);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dorcsd2by1_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dorcsd2by1_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dorcsd2by1_work(int matrix_layout, char jobu1, char jobu2, char jobv1t, int m, int p, int q, double *x11, int ldx11, double *x21, int ldx21, double *theta, double *u1, int ldu1, double *u2, int ldu2, double *v1t, int ldv1t, double *work, int lwork, int *iwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_dorcsd2by1_work$descriptor() {
        return LAPACKE_dorcsd2by1_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dorcsd2by1_work(int matrix_layout, char jobu1, char jobu2, char jobv1t, int m, int p, int q, double *x11, int ldx11, double *x21, int ldx21, double *theta, double *u1, int ldu1, double *u2, int ldu2, double *v1t, int ldv1t, double *work, int lwork, int *iwork)
     * }
     */
    public static MethodHandle LAPACKE_dorcsd2by1_work$handle() {
        return LAPACKE_dorcsd2by1_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dorcsd2by1_work(int matrix_layout, char jobu1, char jobu2, char jobv1t, int m, int p, int q, double *x11, int ldx11, double *x21, int ldx21, double *theta, double *u1, int ldu1, double *u2, int ldu2, double *v1t, int ldv1t, double *work, int lwork, int *iwork)
     * }
     */
    public static MemorySegment LAPACKE_dorcsd2by1_work$address() {
        return LAPACKE_dorcsd2by1_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dorcsd2by1_work(int matrix_layout, char jobu1, char jobu2, char jobv1t, int m, int p, int q, double *x11, int ldx11, double *x21, int ldx21, double *theta, double *u1, int ldu1, double *u2, int ldu2, double *v1t, int ldv1t, double *work, int lwork, int *iwork)
     * }
     */
    public static int LAPACKE_dorcsd2by1_work(int matrix_layout, byte jobu1, byte jobu2, byte jobv1t, int m, int p, int q, MemorySegment x11, int ldx11, MemorySegment x21, int ldx21, MemorySegment theta, MemorySegment u1, int ldu1, MemorySegment u2, int ldu2, MemorySegment v1t, int ldv1t, MemorySegment work, int lwork, MemorySegment iwork) {
        var mh$ = LAPACKE_dorcsd2by1_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dorcsd2by1_work", matrix_layout, jobu1, jobu2, jobv1t, m, p, q, x11, ldx11, x21, ldx21, theta, u1, ldu1, u2, ldu2, v1t, ldv1t, work, lwork, iwork);
            }
            return (int)mh$.invokeExact(matrix_layout, jobu1, jobu2, jobv1t, m, p, q, x11, ldx11, x21, ldx21, theta, u1, ldu1, u2, ldu2, v1t, ldv1t, work, lwork, iwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dsyconv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dsyconv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dsyconv(int matrix_layout, char uplo, char way, int n, double *a, int lda, const int *ipiv, double *e)
     * }
     */
    public static FunctionDescriptor LAPACKE_dsyconv$descriptor() {
        return LAPACKE_dsyconv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dsyconv(int matrix_layout, char uplo, char way, int n, double *a, int lda, const int *ipiv, double *e)
     * }
     */
    public static MethodHandle LAPACKE_dsyconv$handle() {
        return LAPACKE_dsyconv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dsyconv(int matrix_layout, char uplo, char way, int n, double *a, int lda, const int *ipiv, double *e)
     * }
     */
    public static MemorySegment LAPACKE_dsyconv$address() {
        return LAPACKE_dsyconv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dsyconv(int matrix_layout, char uplo, char way, int n, double *a, int lda, const int *ipiv, double *e)
     * }
     */
    public static int LAPACKE_dsyconv(int matrix_layout, byte uplo, byte way, int n, MemorySegment a, int lda, MemorySegment ipiv, MemorySegment e) {
        var mh$ = LAPACKE_dsyconv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dsyconv", matrix_layout, uplo, way, n, a, lda, ipiv, e);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, way, n, a, lda, ipiv, e);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dsyconv_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dsyconv_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dsyconv_work(int matrix_layout, char uplo, char way, int n, double *a, int lda, const int *ipiv, double *e)
     * }
     */
    public static FunctionDescriptor LAPACKE_dsyconv_work$descriptor() {
        return LAPACKE_dsyconv_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dsyconv_work(int matrix_layout, char uplo, char way, int n, double *a, int lda, const int *ipiv, double *e)
     * }
     */
    public static MethodHandle LAPACKE_dsyconv_work$handle() {
        return LAPACKE_dsyconv_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dsyconv_work(int matrix_layout, char uplo, char way, int n, double *a, int lda, const int *ipiv, double *e)
     * }
     */
    public static MemorySegment LAPACKE_dsyconv_work$address() {
        return LAPACKE_dsyconv_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dsyconv_work(int matrix_layout, char uplo, char way, int n, double *a, int lda, const int *ipiv, double *e)
     * }
     */
    public static int LAPACKE_dsyconv_work(int matrix_layout, byte uplo, byte way, int n, MemorySegment a, int lda, MemorySegment ipiv, MemorySegment e) {
        var mh$ = LAPACKE_dsyconv_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dsyconv_work", matrix_layout, uplo, way, n, a, lda, ipiv, e);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, way, n, a, lda, ipiv, e);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dsyswapr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dsyswapr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dsyswapr(int matrix_layout, char uplo, int n, double *a, int lda, int i1, int i2)
     * }
     */
    public static FunctionDescriptor LAPACKE_dsyswapr$descriptor() {
        return LAPACKE_dsyswapr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dsyswapr(int matrix_layout, char uplo, int n, double *a, int lda, int i1, int i2)
     * }
     */
    public static MethodHandle LAPACKE_dsyswapr$handle() {
        return LAPACKE_dsyswapr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dsyswapr(int matrix_layout, char uplo, int n, double *a, int lda, int i1, int i2)
     * }
     */
    public static MemorySegment LAPACKE_dsyswapr$address() {
        return LAPACKE_dsyswapr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dsyswapr(int matrix_layout, char uplo, int n, double *a, int lda, int i1, int i2)
     * }
     */
    public static int LAPACKE_dsyswapr(int matrix_layout, byte uplo, int n, MemorySegment a, int lda, int i1, int i2) {
        var mh$ = LAPACKE_dsyswapr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dsyswapr", matrix_layout, uplo, n, a, lda, i1, i2);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, a, lda, i1, i2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dsyswapr_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dsyswapr_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dsyswapr_work(int matrix_layout, char uplo, int n, double *a, int lda, int i1, int i2)
     * }
     */
    public static FunctionDescriptor LAPACKE_dsyswapr_work$descriptor() {
        return LAPACKE_dsyswapr_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dsyswapr_work(int matrix_layout, char uplo, int n, double *a, int lda, int i1, int i2)
     * }
     */
    public static MethodHandle LAPACKE_dsyswapr_work$handle() {
        return LAPACKE_dsyswapr_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dsyswapr_work(int matrix_layout, char uplo, int n, double *a, int lda, int i1, int i2)
     * }
     */
    public static MemorySegment LAPACKE_dsyswapr_work$address() {
        return LAPACKE_dsyswapr_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dsyswapr_work(int matrix_layout, char uplo, int n, double *a, int lda, int i1, int i2)
     * }
     */
    public static int LAPACKE_dsyswapr_work(int matrix_layout, byte uplo, int n, MemorySegment a, int lda, int i1, int i2) {
        var mh$ = LAPACKE_dsyswapr_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dsyswapr_work", matrix_layout, uplo, n, a, lda, i1, i2);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, a, lda, i1, i2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dsytri2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dsytri2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dsytri2(int matrix_layout, char uplo, int n, double *a, int lda, const int *ipiv)
     * }
     */
    public static FunctionDescriptor LAPACKE_dsytri2$descriptor() {
        return LAPACKE_dsytri2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dsytri2(int matrix_layout, char uplo, int n, double *a, int lda, const int *ipiv)
     * }
     */
    public static MethodHandle LAPACKE_dsytri2$handle() {
        return LAPACKE_dsytri2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dsytri2(int matrix_layout, char uplo, int n, double *a, int lda, const int *ipiv)
     * }
     */
    public static MemorySegment LAPACKE_dsytri2$address() {
        return LAPACKE_dsytri2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dsytri2(int matrix_layout, char uplo, int n, double *a, int lda, const int *ipiv)
     * }
     */
    public static int LAPACKE_dsytri2(int matrix_layout, byte uplo, int n, MemorySegment a, int lda, MemorySegment ipiv) {
        var mh$ = LAPACKE_dsytri2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dsytri2", matrix_layout, uplo, n, a, lda, ipiv);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, a, lda, ipiv);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dsytri2_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dsytri2_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dsytri2_work(int matrix_layout, char uplo, int n, double *a, int lda, const int *ipiv, double *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_dsytri2_work$descriptor() {
        return LAPACKE_dsytri2_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dsytri2_work(int matrix_layout, char uplo, int n, double *a, int lda, const int *ipiv, double *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_dsytri2_work$handle() {
        return LAPACKE_dsytri2_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dsytri2_work(int matrix_layout, char uplo, int n, double *a, int lda, const int *ipiv, double *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_dsytri2_work$address() {
        return LAPACKE_dsytri2_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dsytri2_work(int matrix_layout, char uplo, int n, double *a, int lda, const int *ipiv, double *work, int lwork)
     * }
     */
    public static int LAPACKE_dsytri2_work(int matrix_layout, byte uplo, int n, MemorySegment a, int lda, MemorySegment ipiv, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_dsytri2_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dsytri2_work", matrix_layout, uplo, n, a, lda, ipiv, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, a, lda, ipiv, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dsytri2x {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dsytri2x");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dsytri2x(int matrix_layout, char uplo, int n, double *a, int lda, const int *ipiv, int nb)
     * }
     */
    public static FunctionDescriptor LAPACKE_dsytri2x$descriptor() {
        return LAPACKE_dsytri2x.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dsytri2x(int matrix_layout, char uplo, int n, double *a, int lda, const int *ipiv, int nb)
     * }
     */
    public static MethodHandle LAPACKE_dsytri2x$handle() {
        return LAPACKE_dsytri2x.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dsytri2x(int matrix_layout, char uplo, int n, double *a, int lda, const int *ipiv, int nb)
     * }
     */
    public static MemorySegment LAPACKE_dsytri2x$address() {
        return LAPACKE_dsytri2x.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dsytri2x(int matrix_layout, char uplo, int n, double *a, int lda, const int *ipiv, int nb)
     * }
     */
    public static int LAPACKE_dsytri2x(int matrix_layout, byte uplo, int n, MemorySegment a, int lda, MemorySegment ipiv, int nb) {
        var mh$ = LAPACKE_dsytri2x.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dsytri2x", matrix_layout, uplo, n, a, lda, ipiv, nb);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, a, lda, ipiv, nb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dsytri2x_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dsytri2x_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dsytri2x_work(int matrix_layout, char uplo, int n, double *a, int lda, const int *ipiv, double *work, int nb)
     * }
     */
    public static FunctionDescriptor LAPACKE_dsytri2x_work$descriptor() {
        return LAPACKE_dsytri2x_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dsytri2x_work(int matrix_layout, char uplo, int n, double *a, int lda, const int *ipiv, double *work, int nb)
     * }
     */
    public static MethodHandle LAPACKE_dsytri2x_work$handle() {
        return LAPACKE_dsytri2x_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dsytri2x_work(int matrix_layout, char uplo, int n, double *a, int lda, const int *ipiv, double *work, int nb)
     * }
     */
    public static MemorySegment LAPACKE_dsytri2x_work$address() {
        return LAPACKE_dsytri2x_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dsytri2x_work(int matrix_layout, char uplo, int n, double *a, int lda, const int *ipiv, double *work, int nb)
     * }
     */
    public static int LAPACKE_dsytri2x_work(int matrix_layout, byte uplo, int n, MemorySegment a, int lda, MemorySegment ipiv, MemorySegment work, int nb) {
        var mh$ = LAPACKE_dsytri2x_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dsytri2x_work", matrix_layout, uplo, n, a, lda, ipiv, work, nb);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, a, lda, ipiv, work, nb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dsytrs2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dsytrs2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dsytrs2(int matrix_layout, char uplo, int n, int nrhs, const double *a, int lda, const int *ipiv, double *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_dsytrs2$descriptor() {
        return LAPACKE_dsytrs2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dsytrs2(int matrix_layout, char uplo, int n, int nrhs, const double *a, int lda, const int *ipiv, double *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_dsytrs2$handle() {
        return LAPACKE_dsytrs2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dsytrs2(int matrix_layout, char uplo, int n, int nrhs, const double *a, int lda, const int *ipiv, double *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_dsytrs2$address() {
        return LAPACKE_dsytrs2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dsytrs2(int matrix_layout, char uplo, int n, int nrhs, const double *a, int lda, const int *ipiv, double *b, int ldb)
     * }
     */
    public static int LAPACKE_dsytrs2(int matrix_layout, byte uplo, int n, int nrhs, MemorySegment a, int lda, MemorySegment ipiv, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_dsytrs2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dsytrs2", matrix_layout, uplo, n, nrhs, a, lda, ipiv, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, nrhs, a, lda, ipiv, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dsytrs2_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dsytrs2_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dsytrs2_work(int matrix_layout, char uplo, int n, int nrhs, const double *a, int lda, const int *ipiv, double *b, int ldb, double *work)
     * }
     */
    public static FunctionDescriptor LAPACKE_dsytrs2_work$descriptor() {
        return LAPACKE_dsytrs2_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dsytrs2_work(int matrix_layout, char uplo, int n, int nrhs, const double *a, int lda, const int *ipiv, double *b, int ldb, double *work)
     * }
     */
    public static MethodHandle LAPACKE_dsytrs2_work$handle() {
        return LAPACKE_dsytrs2_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dsytrs2_work(int matrix_layout, char uplo, int n, int nrhs, const double *a, int lda, const int *ipiv, double *b, int ldb, double *work)
     * }
     */
    public static MemorySegment LAPACKE_dsytrs2_work$address() {
        return LAPACKE_dsytrs2_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dsytrs2_work(int matrix_layout, char uplo, int n, int nrhs, const double *a, int lda, const int *ipiv, double *b, int ldb, double *work)
     * }
     */
    public static int LAPACKE_dsytrs2_work(int matrix_layout, byte uplo, int n, int nrhs, MemorySegment a, int lda, MemorySegment ipiv, MemorySegment b, int ldb, MemorySegment work) {
        var mh$ = LAPACKE_dsytrs2_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dsytrs2_work", matrix_layout, uplo, n, nrhs, a, lda, ipiv, b, ldb, work);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, nrhs, a, lda, ipiv, b, ldb, work);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sbbcsd {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_sbbcsd");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sbbcsd(int matrix_layout, char jobu1, char jobu2, char jobv1t, char jobv2t, char trans, int m, int p, int q, float *theta, float *phi, float *u1, int ldu1, float *u2, int ldu2, float *v1t, int ldv1t, float *v2t, int ldv2t, float *b11d, float *b11e, float *b12d, float *b12e, float *b21d, float *b21e, float *b22d, float *b22e)
     * }
     */
    public static FunctionDescriptor LAPACKE_sbbcsd$descriptor() {
        return LAPACKE_sbbcsd.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sbbcsd(int matrix_layout, char jobu1, char jobu2, char jobv1t, char jobv2t, char trans, int m, int p, int q, float *theta, float *phi, float *u1, int ldu1, float *u2, int ldu2, float *v1t, int ldv1t, float *v2t, int ldv2t, float *b11d, float *b11e, float *b12d, float *b12e, float *b21d, float *b21e, float *b22d, float *b22e)
     * }
     */
    public static MethodHandle LAPACKE_sbbcsd$handle() {
        return LAPACKE_sbbcsd.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sbbcsd(int matrix_layout, char jobu1, char jobu2, char jobv1t, char jobv2t, char trans, int m, int p, int q, float *theta, float *phi, float *u1, int ldu1, float *u2, int ldu2, float *v1t, int ldv1t, float *v2t, int ldv2t, float *b11d, float *b11e, float *b12d, float *b12e, float *b21d, float *b21e, float *b22d, float *b22e)
     * }
     */
    public static MemorySegment LAPACKE_sbbcsd$address() {
        return LAPACKE_sbbcsd.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sbbcsd(int matrix_layout, char jobu1, char jobu2, char jobv1t, char jobv2t, char trans, int m, int p, int q, float *theta, float *phi, float *u1, int ldu1, float *u2, int ldu2, float *v1t, int ldv1t, float *v2t, int ldv2t, float *b11d, float *b11e, float *b12d, float *b12e, float *b21d, float *b21e, float *b22d, float *b22e)
     * }
     */
    public static int LAPACKE_sbbcsd(int matrix_layout, byte jobu1, byte jobu2, byte jobv1t, byte jobv2t, byte trans, int m, int p, int q, MemorySegment theta, MemorySegment phi, MemorySegment u1, int ldu1, MemorySegment u2, int ldu2, MemorySegment v1t, int ldv1t, MemorySegment v2t, int ldv2t, MemorySegment b11d, MemorySegment b11e, MemorySegment b12d, MemorySegment b12e, MemorySegment b21d, MemorySegment b21e, MemorySegment b22d, MemorySegment b22e) {
        var mh$ = LAPACKE_sbbcsd.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sbbcsd", matrix_layout, jobu1, jobu2, jobv1t, jobv2t, trans, m, p, q, theta, phi, u1, ldu1, u2, ldu2, v1t, ldv1t, v2t, ldv2t, b11d, b11e, b12d, b12e, b21d, b21e, b22d, b22e);
            }
            return (int)mh$.invokeExact(matrix_layout, jobu1, jobu2, jobv1t, jobv2t, trans, m, p, q, theta, phi, u1, ldu1, u2, ldu2, v1t, ldv1t, v2t, ldv2t, b11d, b11e, b12d, b12e, b21d, b21e, b22d, b22e);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sbbcsd_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_sbbcsd_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sbbcsd_work(int matrix_layout, char jobu1, char jobu2, char jobv1t, char jobv2t, char trans, int m, int p, int q, float *theta, float *phi, float *u1, int ldu1, float *u2, int ldu2, float *v1t, int ldv1t, float *v2t, int ldv2t, float *b11d, float *b11e, float *b12d, float *b12e, float *b21d, float *b21e, float *b22d, float *b22e, float *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_sbbcsd_work$descriptor() {
        return LAPACKE_sbbcsd_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sbbcsd_work(int matrix_layout, char jobu1, char jobu2, char jobv1t, char jobv2t, char trans, int m, int p, int q, float *theta, float *phi, float *u1, int ldu1, float *u2, int ldu2, float *v1t, int ldv1t, float *v2t, int ldv2t, float *b11d, float *b11e, float *b12d, float *b12e, float *b21d, float *b21e, float *b22d, float *b22e, float *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_sbbcsd_work$handle() {
        return LAPACKE_sbbcsd_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sbbcsd_work(int matrix_layout, char jobu1, char jobu2, char jobv1t, char jobv2t, char trans, int m, int p, int q, float *theta, float *phi, float *u1, int ldu1, float *u2, int ldu2, float *v1t, int ldv1t, float *v2t, int ldv2t, float *b11d, float *b11e, float *b12d, float *b12e, float *b21d, float *b21e, float *b22d, float *b22e, float *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_sbbcsd_work$address() {
        return LAPACKE_sbbcsd_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sbbcsd_work(int matrix_layout, char jobu1, char jobu2, char jobv1t, char jobv2t, char trans, int m, int p, int q, float *theta, float *phi, float *u1, int ldu1, float *u2, int ldu2, float *v1t, int ldv1t, float *v2t, int ldv2t, float *b11d, float *b11e, float *b12d, float *b12e, float *b21d, float *b21e, float *b22d, float *b22e, float *work, int lwork)
     * }
     */
    public static int LAPACKE_sbbcsd_work(int matrix_layout, byte jobu1, byte jobu2, byte jobv1t, byte jobv2t, byte trans, int m, int p, int q, MemorySegment theta, MemorySegment phi, MemorySegment u1, int ldu1, MemorySegment u2, int ldu2, MemorySegment v1t, int ldv1t, MemorySegment v2t, int ldv2t, MemorySegment b11d, MemorySegment b11e, MemorySegment b12d, MemorySegment b12e, MemorySegment b21d, MemorySegment b21e, MemorySegment b22d, MemorySegment b22e, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_sbbcsd_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sbbcsd_work", matrix_layout, jobu1, jobu2, jobv1t, jobv2t, trans, m, p, q, theta, phi, u1, ldu1, u2, ldu2, v1t, ldv1t, v2t, ldv2t, b11d, b11e, b12d, b12e, b21d, b21e, b22d, b22e, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, jobu1, jobu2, jobv1t, jobv2t, trans, m, p, q, theta, phi, u1, ldu1, u2, ldu2, v1t, ldv1t, v2t, ldv2t, b11d, b11e, b12d, b12e, b21d, b21e, b22d, b22e, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sorbdb {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_sorbdb");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sorbdb(int matrix_layout, char trans, char signs, int m, int p, int q, float *x11, int ldx11, float *x12, int ldx12, float *x21, int ldx21, float *x22, int ldx22, float *theta, float *phi, float *taup1, float *taup2, float *tauq1, float *tauq2)
     * }
     */
    public static FunctionDescriptor LAPACKE_sorbdb$descriptor() {
        return LAPACKE_sorbdb.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sorbdb(int matrix_layout, char trans, char signs, int m, int p, int q, float *x11, int ldx11, float *x12, int ldx12, float *x21, int ldx21, float *x22, int ldx22, float *theta, float *phi, float *taup1, float *taup2, float *tauq1, float *tauq2)
     * }
     */
    public static MethodHandle LAPACKE_sorbdb$handle() {
        return LAPACKE_sorbdb.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sorbdb(int matrix_layout, char trans, char signs, int m, int p, int q, float *x11, int ldx11, float *x12, int ldx12, float *x21, int ldx21, float *x22, int ldx22, float *theta, float *phi, float *taup1, float *taup2, float *tauq1, float *tauq2)
     * }
     */
    public static MemorySegment LAPACKE_sorbdb$address() {
        return LAPACKE_sorbdb.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sorbdb(int matrix_layout, char trans, char signs, int m, int p, int q, float *x11, int ldx11, float *x12, int ldx12, float *x21, int ldx21, float *x22, int ldx22, float *theta, float *phi, float *taup1, float *taup2, float *tauq1, float *tauq2)
     * }
     */
    public static int LAPACKE_sorbdb(int matrix_layout, byte trans, byte signs, int m, int p, int q, MemorySegment x11, int ldx11, MemorySegment x12, int ldx12, MemorySegment x21, int ldx21, MemorySegment x22, int ldx22, MemorySegment theta, MemorySegment phi, MemorySegment taup1, MemorySegment taup2, MemorySegment tauq1, MemorySegment tauq2) {
        var mh$ = LAPACKE_sorbdb.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sorbdb", matrix_layout, trans, signs, m, p, q, x11, ldx11, x12, ldx12, x21, ldx21, x22, ldx22, theta, phi, taup1, taup2, tauq1, tauq2);
            }
            return (int)mh$.invokeExact(matrix_layout, trans, signs, m, p, q, x11, ldx11, x12, ldx12, x21, ldx21, x22, ldx22, theta, phi, taup1, taup2, tauq1, tauq2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sorbdb_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_sorbdb_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sorbdb_work(int matrix_layout, char trans, char signs, int m, int p, int q, float *x11, int ldx11, float *x12, int ldx12, float *x21, int ldx21, float *x22, int ldx22, float *theta, float *phi, float *taup1, float *taup2, float *tauq1, float *tauq2, float *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_sorbdb_work$descriptor() {
        return LAPACKE_sorbdb_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sorbdb_work(int matrix_layout, char trans, char signs, int m, int p, int q, float *x11, int ldx11, float *x12, int ldx12, float *x21, int ldx21, float *x22, int ldx22, float *theta, float *phi, float *taup1, float *taup2, float *tauq1, float *tauq2, float *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_sorbdb_work$handle() {
        return LAPACKE_sorbdb_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sorbdb_work(int matrix_layout, char trans, char signs, int m, int p, int q, float *x11, int ldx11, float *x12, int ldx12, float *x21, int ldx21, float *x22, int ldx22, float *theta, float *phi, float *taup1, float *taup2, float *tauq1, float *tauq2, float *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_sorbdb_work$address() {
        return LAPACKE_sorbdb_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sorbdb_work(int matrix_layout, char trans, char signs, int m, int p, int q, float *x11, int ldx11, float *x12, int ldx12, float *x21, int ldx21, float *x22, int ldx22, float *theta, float *phi, float *taup1, float *taup2, float *tauq1, float *tauq2, float *work, int lwork)
     * }
     */
    public static int LAPACKE_sorbdb_work(int matrix_layout, byte trans, byte signs, int m, int p, int q, MemorySegment x11, int ldx11, MemorySegment x12, int ldx12, MemorySegment x21, int ldx21, MemorySegment x22, int ldx22, MemorySegment theta, MemorySegment phi, MemorySegment taup1, MemorySegment taup2, MemorySegment tauq1, MemorySegment tauq2, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_sorbdb_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sorbdb_work", matrix_layout, trans, signs, m, p, q, x11, ldx11, x12, ldx12, x21, ldx21, x22, ldx22, theta, phi, taup1, taup2, tauq1, tauq2, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, trans, signs, m, p, q, x11, ldx11, x12, ldx12, x21, ldx21, x22, ldx22, theta, phi, taup1, taup2, tauq1, tauq2, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sorcsd {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_sorcsd");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sorcsd(int matrix_layout, char jobu1, char jobu2, char jobv1t, char jobv2t, char trans, char signs, int m, int p, int q, float *x11, int ldx11, float *x12, int ldx12, float *x21, int ldx21, float *x22, int ldx22, float *theta, float *u1, int ldu1, float *u2, int ldu2, float *v1t, int ldv1t, float *v2t, int ldv2t)
     * }
     */
    public static FunctionDescriptor LAPACKE_sorcsd$descriptor() {
        return LAPACKE_sorcsd.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sorcsd(int matrix_layout, char jobu1, char jobu2, char jobv1t, char jobv2t, char trans, char signs, int m, int p, int q, float *x11, int ldx11, float *x12, int ldx12, float *x21, int ldx21, float *x22, int ldx22, float *theta, float *u1, int ldu1, float *u2, int ldu2, float *v1t, int ldv1t, float *v2t, int ldv2t)
     * }
     */
    public static MethodHandle LAPACKE_sorcsd$handle() {
        return LAPACKE_sorcsd.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sorcsd(int matrix_layout, char jobu1, char jobu2, char jobv1t, char jobv2t, char trans, char signs, int m, int p, int q, float *x11, int ldx11, float *x12, int ldx12, float *x21, int ldx21, float *x22, int ldx22, float *theta, float *u1, int ldu1, float *u2, int ldu2, float *v1t, int ldv1t, float *v2t, int ldv2t)
     * }
     */
    public static MemorySegment LAPACKE_sorcsd$address() {
        return LAPACKE_sorcsd.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sorcsd(int matrix_layout, char jobu1, char jobu2, char jobv1t, char jobv2t, char trans, char signs, int m, int p, int q, float *x11, int ldx11, float *x12, int ldx12, float *x21, int ldx21, float *x22, int ldx22, float *theta, float *u1, int ldu1, float *u2, int ldu2, float *v1t, int ldv1t, float *v2t, int ldv2t)
     * }
     */
    public static int LAPACKE_sorcsd(int matrix_layout, byte jobu1, byte jobu2, byte jobv1t, byte jobv2t, byte trans, byte signs, int m, int p, int q, MemorySegment x11, int ldx11, MemorySegment x12, int ldx12, MemorySegment x21, int ldx21, MemorySegment x22, int ldx22, MemorySegment theta, MemorySegment u1, int ldu1, MemorySegment u2, int ldu2, MemorySegment v1t, int ldv1t, MemorySegment v2t, int ldv2t) {
        var mh$ = LAPACKE_sorcsd.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sorcsd", matrix_layout, jobu1, jobu2, jobv1t, jobv2t, trans, signs, m, p, q, x11, ldx11, x12, ldx12, x21, ldx21, x22, ldx22, theta, u1, ldu1, u2, ldu2, v1t, ldv1t, v2t, ldv2t);
            }
            return (int)mh$.invokeExact(matrix_layout, jobu1, jobu2, jobv1t, jobv2t, trans, signs, m, p, q, x11, ldx11, x12, ldx12, x21, ldx21, x22, ldx22, theta, u1, ldu1, u2, ldu2, v1t, ldv1t, v2t, ldv2t);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sorcsd_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_sorcsd_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sorcsd_work(int matrix_layout, char jobu1, char jobu2, char jobv1t, char jobv2t, char trans, char signs, int m, int p, int q, float *x11, int ldx11, float *x12, int ldx12, float *x21, int ldx21, float *x22, int ldx22, float *theta, float *u1, int ldu1, float *u2, int ldu2, float *v1t, int ldv1t, float *v2t, int ldv2t, float *work, int lwork, int *iwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_sorcsd_work$descriptor() {
        return LAPACKE_sorcsd_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sorcsd_work(int matrix_layout, char jobu1, char jobu2, char jobv1t, char jobv2t, char trans, char signs, int m, int p, int q, float *x11, int ldx11, float *x12, int ldx12, float *x21, int ldx21, float *x22, int ldx22, float *theta, float *u1, int ldu1, float *u2, int ldu2, float *v1t, int ldv1t, float *v2t, int ldv2t, float *work, int lwork, int *iwork)
     * }
     */
    public static MethodHandle LAPACKE_sorcsd_work$handle() {
        return LAPACKE_sorcsd_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sorcsd_work(int matrix_layout, char jobu1, char jobu2, char jobv1t, char jobv2t, char trans, char signs, int m, int p, int q, float *x11, int ldx11, float *x12, int ldx12, float *x21, int ldx21, float *x22, int ldx22, float *theta, float *u1, int ldu1, float *u2, int ldu2, float *v1t, int ldv1t, float *v2t, int ldv2t, float *work, int lwork, int *iwork)
     * }
     */
    public static MemorySegment LAPACKE_sorcsd_work$address() {
        return LAPACKE_sorcsd_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sorcsd_work(int matrix_layout, char jobu1, char jobu2, char jobv1t, char jobv2t, char trans, char signs, int m, int p, int q, float *x11, int ldx11, float *x12, int ldx12, float *x21, int ldx21, float *x22, int ldx22, float *theta, float *u1, int ldu1, float *u2, int ldu2, float *v1t, int ldv1t, float *v2t, int ldv2t, float *work, int lwork, int *iwork)
     * }
     */
    public static int LAPACKE_sorcsd_work(int matrix_layout, byte jobu1, byte jobu2, byte jobv1t, byte jobv2t, byte trans, byte signs, int m, int p, int q, MemorySegment x11, int ldx11, MemorySegment x12, int ldx12, MemorySegment x21, int ldx21, MemorySegment x22, int ldx22, MemorySegment theta, MemorySegment u1, int ldu1, MemorySegment u2, int ldu2, MemorySegment v1t, int ldv1t, MemorySegment v2t, int ldv2t, MemorySegment work, int lwork, MemorySegment iwork) {
        var mh$ = LAPACKE_sorcsd_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sorcsd_work", matrix_layout, jobu1, jobu2, jobv1t, jobv2t, trans, signs, m, p, q, x11, ldx11, x12, ldx12, x21, ldx21, x22, ldx22, theta, u1, ldu1, u2, ldu2, v1t, ldv1t, v2t, ldv2t, work, lwork, iwork);
            }
            return (int)mh$.invokeExact(matrix_layout, jobu1, jobu2, jobv1t, jobv2t, trans, signs, m, p, q, x11, ldx11, x12, ldx12, x21, ldx21, x22, ldx22, theta, u1, ldu1, u2, ldu2, v1t, ldv1t, v2t, ldv2t, work, lwork, iwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sorcsd2by1 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_sorcsd2by1");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sorcsd2by1(int matrix_layout, char jobu1, char jobu2, char jobv1t, int m, int p, int q, float *x11, int ldx11, float *x21, int ldx21, float *theta, float *u1, int ldu1, float *u2, int ldu2, float *v1t, int ldv1t)
     * }
     */
    public static FunctionDescriptor LAPACKE_sorcsd2by1$descriptor() {
        return LAPACKE_sorcsd2by1.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sorcsd2by1(int matrix_layout, char jobu1, char jobu2, char jobv1t, int m, int p, int q, float *x11, int ldx11, float *x21, int ldx21, float *theta, float *u1, int ldu1, float *u2, int ldu2, float *v1t, int ldv1t)
     * }
     */
    public static MethodHandle LAPACKE_sorcsd2by1$handle() {
        return LAPACKE_sorcsd2by1.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sorcsd2by1(int matrix_layout, char jobu1, char jobu2, char jobv1t, int m, int p, int q, float *x11, int ldx11, float *x21, int ldx21, float *theta, float *u1, int ldu1, float *u2, int ldu2, float *v1t, int ldv1t)
     * }
     */
    public static MemorySegment LAPACKE_sorcsd2by1$address() {
        return LAPACKE_sorcsd2by1.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sorcsd2by1(int matrix_layout, char jobu1, char jobu2, char jobv1t, int m, int p, int q, float *x11, int ldx11, float *x21, int ldx21, float *theta, float *u1, int ldu1, float *u2, int ldu2, float *v1t, int ldv1t)
     * }
     */
    public static int LAPACKE_sorcsd2by1(int matrix_layout, byte jobu1, byte jobu2, byte jobv1t, int m, int p, int q, MemorySegment x11, int ldx11, MemorySegment x21, int ldx21, MemorySegment theta, MemorySegment u1, int ldu1, MemorySegment u2, int ldu2, MemorySegment v1t, int ldv1t) {
        var mh$ = LAPACKE_sorcsd2by1.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sorcsd2by1", matrix_layout, jobu1, jobu2, jobv1t, m, p, q, x11, ldx11, x21, ldx21, theta, u1, ldu1, u2, ldu2, v1t, ldv1t);
            }
            return (int)mh$.invokeExact(matrix_layout, jobu1, jobu2, jobv1t, m, p, q, x11, ldx11, x21, ldx21, theta, u1, ldu1, u2, ldu2, v1t, ldv1t);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sorcsd2by1_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_sorcsd2by1_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sorcsd2by1_work(int matrix_layout, char jobu1, char jobu2, char jobv1t, int m, int p, int q, float *x11, int ldx11, float *x21, int ldx21, float *theta, float *u1, int ldu1, float *u2, int ldu2, float *v1t, int ldv1t, float *work, int lwork, int *iwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_sorcsd2by1_work$descriptor() {
        return LAPACKE_sorcsd2by1_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sorcsd2by1_work(int matrix_layout, char jobu1, char jobu2, char jobv1t, int m, int p, int q, float *x11, int ldx11, float *x21, int ldx21, float *theta, float *u1, int ldu1, float *u2, int ldu2, float *v1t, int ldv1t, float *work, int lwork, int *iwork)
     * }
     */
    public static MethodHandle LAPACKE_sorcsd2by1_work$handle() {
        return LAPACKE_sorcsd2by1_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sorcsd2by1_work(int matrix_layout, char jobu1, char jobu2, char jobv1t, int m, int p, int q, float *x11, int ldx11, float *x21, int ldx21, float *theta, float *u1, int ldu1, float *u2, int ldu2, float *v1t, int ldv1t, float *work, int lwork, int *iwork)
     * }
     */
    public static MemorySegment LAPACKE_sorcsd2by1_work$address() {
        return LAPACKE_sorcsd2by1_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sorcsd2by1_work(int matrix_layout, char jobu1, char jobu2, char jobv1t, int m, int p, int q, float *x11, int ldx11, float *x21, int ldx21, float *theta, float *u1, int ldu1, float *u2, int ldu2, float *v1t, int ldv1t, float *work, int lwork, int *iwork)
     * }
     */
    public static int LAPACKE_sorcsd2by1_work(int matrix_layout, byte jobu1, byte jobu2, byte jobv1t, int m, int p, int q, MemorySegment x11, int ldx11, MemorySegment x21, int ldx21, MemorySegment theta, MemorySegment u1, int ldu1, MemorySegment u2, int ldu2, MemorySegment v1t, int ldv1t, MemorySegment work, int lwork, MemorySegment iwork) {
        var mh$ = LAPACKE_sorcsd2by1_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sorcsd2by1_work", matrix_layout, jobu1, jobu2, jobv1t, m, p, q, x11, ldx11, x21, ldx21, theta, u1, ldu1, u2, ldu2, v1t, ldv1t, work, lwork, iwork);
            }
            return (int)mh$.invokeExact(matrix_layout, jobu1, jobu2, jobv1t, m, p, q, x11, ldx11, x21, ldx21, theta, u1, ldu1, u2, ldu2, v1t, ldv1t, work, lwork, iwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ssyconv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_ssyconv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ssyconv(int matrix_layout, char uplo, char way, int n, float *a, int lda, const int *ipiv, float *e)
     * }
     */
    public static FunctionDescriptor LAPACKE_ssyconv$descriptor() {
        return LAPACKE_ssyconv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ssyconv(int matrix_layout, char uplo, char way, int n, float *a, int lda, const int *ipiv, float *e)
     * }
     */
    public static MethodHandle LAPACKE_ssyconv$handle() {
        return LAPACKE_ssyconv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ssyconv(int matrix_layout, char uplo, char way, int n, float *a, int lda, const int *ipiv, float *e)
     * }
     */
    public static MemorySegment LAPACKE_ssyconv$address() {
        return LAPACKE_ssyconv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ssyconv(int matrix_layout, char uplo, char way, int n, float *a, int lda, const int *ipiv, float *e)
     * }
     */
    public static int LAPACKE_ssyconv(int matrix_layout, byte uplo, byte way, int n, MemorySegment a, int lda, MemorySegment ipiv, MemorySegment e) {
        var mh$ = LAPACKE_ssyconv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ssyconv", matrix_layout, uplo, way, n, a, lda, ipiv, e);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, way, n, a, lda, ipiv, e);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ssyconv_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_ssyconv_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ssyconv_work(int matrix_layout, char uplo, char way, int n, float *a, int lda, const int *ipiv, float *e)
     * }
     */
    public static FunctionDescriptor LAPACKE_ssyconv_work$descriptor() {
        return LAPACKE_ssyconv_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ssyconv_work(int matrix_layout, char uplo, char way, int n, float *a, int lda, const int *ipiv, float *e)
     * }
     */
    public static MethodHandle LAPACKE_ssyconv_work$handle() {
        return LAPACKE_ssyconv_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ssyconv_work(int matrix_layout, char uplo, char way, int n, float *a, int lda, const int *ipiv, float *e)
     * }
     */
    public static MemorySegment LAPACKE_ssyconv_work$address() {
        return LAPACKE_ssyconv_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ssyconv_work(int matrix_layout, char uplo, char way, int n, float *a, int lda, const int *ipiv, float *e)
     * }
     */
    public static int LAPACKE_ssyconv_work(int matrix_layout, byte uplo, byte way, int n, MemorySegment a, int lda, MemorySegment ipiv, MemorySegment e) {
        var mh$ = LAPACKE_ssyconv_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ssyconv_work", matrix_layout, uplo, way, n, a, lda, ipiv, e);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, way, n, a, lda, ipiv, e);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ssyswapr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_ssyswapr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ssyswapr(int matrix_layout, char uplo, int n, float *a, int lda, int i1, int i2)
     * }
     */
    public static FunctionDescriptor LAPACKE_ssyswapr$descriptor() {
        return LAPACKE_ssyswapr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ssyswapr(int matrix_layout, char uplo, int n, float *a, int lda, int i1, int i2)
     * }
     */
    public static MethodHandle LAPACKE_ssyswapr$handle() {
        return LAPACKE_ssyswapr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ssyswapr(int matrix_layout, char uplo, int n, float *a, int lda, int i1, int i2)
     * }
     */
    public static MemorySegment LAPACKE_ssyswapr$address() {
        return LAPACKE_ssyswapr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ssyswapr(int matrix_layout, char uplo, int n, float *a, int lda, int i1, int i2)
     * }
     */
    public static int LAPACKE_ssyswapr(int matrix_layout, byte uplo, int n, MemorySegment a, int lda, int i1, int i2) {
        var mh$ = LAPACKE_ssyswapr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ssyswapr", matrix_layout, uplo, n, a, lda, i1, i2);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, a, lda, i1, i2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ssyswapr_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_ssyswapr_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ssyswapr_work(int matrix_layout, char uplo, int n, float *a, int lda, int i1, int i2)
     * }
     */
    public static FunctionDescriptor LAPACKE_ssyswapr_work$descriptor() {
        return LAPACKE_ssyswapr_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ssyswapr_work(int matrix_layout, char uplo, int n, float *a, int lda, int i1, int i2)
     * }
     */
    public static MethodHandle LAPACKE_ssyswapr_work$handle() {
        return LAPACKE_ssyswapr_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ssyswapr_work(int matrix_layout, char uplo, int n, float *a, int lda, int i1, int i2)
     * }
     */
    public static MemorySegment LAPACKE_ssyswapr_work$address() {
        return LAPACKE_ssyswapr_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ssyswapr_work(int matrix_layout, char uplo, int n, float *a, int lda, int i1, int i2)
     * }
     */
    public static int LAPACKE_ssyswapr_work(int matrix_layout, byte uplo, int n, MemorySegment a, int lda, int i1, int i2) {
        var mh$ = LAPACKE_ssyswapr_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ssyswapr_work", matrix_layout, uplo, n, a, lda, i1, i2);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, a, lda, i1, i2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ssytri2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_ssytri2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ssytri2(int matrix_layout, char uplo, int n, float *a, int lda, const int *ipiv)
     * }
     */
    public static FunctionDescriptor LAPACKE_ssytri2$descriptor() {
        return LAPACKE_ssytri2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ssytri2(int matrix_layout, char uplo, int n, float *a, int lda, const int *ipiv)
     * }
     */
    public static MethodHandle LAPACKE_ssytri2$handle() {
        return LAPACKE_ssytri2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ssytri2(int matrix_layout, char uplo, int n, float *a, int lda, const int *ipiv)
     * }
     */
    public static MemorySegment LAPACKE_ssytri2$address() {
        return LAPACKE_ssytri2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ssytri2(int matrix_layout, char uplo, int n, float *a, int lda, const int *ipiv)
     * }
     */
    public static int LAPACKE_ssytri2(int matrix_layout, byte uplo, int n, MemorySegment a, int lda, MemorySegment ipiv) {
        var mh$ = LAPACKE_ssytri2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ssytri2", matrix_layout, uplo, n, a, lda, ipiv);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, a, lda, ipiv);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ssytri2_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_ssytri2_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ssytri2_work(int matrix_layout, char uplo, int n, float *a, int lda, const int *ipiv, float *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_ssytri2_work$descriptor() {
        return LAPACKE_ssytri2_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ssytri2_work(int matrix_layout, char uplo, int n, float *a, int lda, const int *ipiv, float *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_ssytri2_work$handle() {
        return LAPACKE_ssytri2_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ssytri2_work(int matrix_layout, char uplo, int n, float *a, int lda, const int *ipiv, float *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_ssytri2_work$address() {
        return LAPACKE_ssytri2_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ssytri2_work(int matrix_layout, char uplo, int n, float *a, int lda, const int *ipiv, float *work, int lwork)
     * }
     */
    public static int LAPACKE_ssytri2_work(int matrix_layout, byte uplo, int n, MemorySegment a, int lda, MemorySegment ipiv, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_ssytri2_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ssytri2_work", matrix_layout, uplo, n, a, lda, ipiv, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, a, lda, ipiv, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ssytri2x {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_ssytri2x");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ssytri2x(int matrix_layout, char uplo, int n, float *a, int lda, const int *ipiv, int nb)
     * }
     */
    public static FunctionDescriptor LAPACKE_ssytri2x$descriptor() {
        return LAPACKE_ssytri2x.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ssytri2x(int matrix_layout, char uplo, int n, float *a, int lda, const int *ipiv, int nb)
     * }
     */
    public static MethodHandle LAPACKE_ssytri2x$handle() {
        return LAPACKE_ssytri2x.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ssytri2x(int matrix_layout, char uplo, int n, float *a, int lda, const int *ipiv, int nb)
     * }
     */
    public static MemorySegment LAPACKE_ssytri2x$address() {
        return LAPACKE_ssytri2x.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ssytri2x(int matrix_layout, char uplo, int n, float *a, int lda, const int *ipiv, int nb)
     * }
     */
    public static int LAPACKE_ssytri2x(int matrix_layout, byte uplo, int n, MemorySegment a, int lda, MemorySegment ipiv, int nb) {
        var mh$ = LAPACKE_ssytri2x.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ssytri2x", matrix_layout, uplo, n, a, lda, ipiv, nb);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, a, lda, ipiv, nb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ssytri2x_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_ssytri2x_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ssytri2x_work(int matrix_layout, char uplo, int n, float *a, int lda, const int *ipiv, float *work, int nb)
     * }
     */
    public static FunctionDescriptor LAPACKE_ssytri2x_work$descriptor() {
        return LAPACKE_ssytri2x_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ssytri2x_work(int matrix_layout, char uplo, int n, float *a, int lda, const int *ipiv, float *work, int nb)
     * }
     */
    public static MethodHandle LAPACKE_ssytri2x_work$handle() {
        return LAPACKE_ssytri2x_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ssytri2x_work(int matrix_layout, char uplo, int n, float *a, int lda, const int *ipiv, float *work, int nb)
     * }
     */
    public static MemorySegment LAPACKE_ssytri2x_work$address() {
        return LAPACKE_ssytri2x_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ssytri2x_work(int matrix_layout, char uplo, int n, float *a, int lda, const int *ipiv, float *work, int nb)
     * }
     */
    public static int LAPACKE_ssytri2x_work(int matrix_layout, byte uplo, int n, MemorySegment a, int lda, MemorySegment ipiv, MemorySegment work, int nb) {
        var mh$ = LAPACKE_ssytri2x_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ssytri2x_work", matrix_layout, uplo, n, a, lda, ipiv, work, nb);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, a, lda, ipiv, work, nb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ssytrs2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_ssytrs2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ssytrs2(int matrix_layout, char uplo, int n, int nrhs, const float *a, int lda, const int *ipiv, float *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_ssytrs2$descriptor() {
        return LAPACKE_ssytrs2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ssytrs2(int matrix_layout, char uplo, int n, int nrhs, const float *a, int lda, const int *ipiv, float *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_ssytrs2$handle() {
        return LAPACKE_ssytrs2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ssytrs2(int matrix_layout, char uplo, int n, int nrhs, const float *a, int lda, const int *ipiv, float *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_ssytrs2$address() {
        return LAPACKE_ssytrs2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ssytrs2(int matrix_layout, char uplo, int n, int nrhs, const float *a, int lda, const int *ipiv, float *b, int ldb)
     * }
     */
    public static int LAPACKE_ssytrs2(int matrix_layout, byte uplo, int n, int nrhs, MemorySegment a, int lda, MemorySegment ipiv, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_ssytrs2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ssytrs2", matrix_layout, uplo, n, nrhs, a, lda, ipiv, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, nrhs, a, lda, ipiv, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ssytrs2_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_ssytrs2_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ssytrs2_work(int matrix_layout, char uplo, int n, int nrhs, const float *a, int lda, const int *ipiv, float *b, int ldb, float *work)
     * }
     */
    public static FunctionDescriptor LAPACKE_ssytrs2_work$descriptor() {
        return LAPACKE_ssytrs2_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ssytrs2_work(int matrix_layout, char uplo, int n, int nrhs, const float *a, int lda, const int *ipiv, float *b, int ldb, float *work)
     * }
     */
    public static MethodHandle LAPACKE_ssytrs2_work$handle() {
        return LAPACKE_ssytrs2_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ssytrs2_work(int matrix_layout, char uplo, int n, int nrhs, const float *a, int lda, const int *ipiv, float *b, int ldb, float *work)
     * }
     */
    public static MemorySegment LAPACKE_ssytrs2_work$address() {
        return LAPACKE_ssytrs2_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ssytrs2_work(int matrix_layout, char uplo, int n, int nrhs, const float *a, int lda, const int *ipiv, float *b, int ldb, float *work)
     * }
     */
    public static int LAPACKE_ssytrs2_work(int matrix_layout, byte uplo, int n, int nrhs, MemorySegment a, int lda, MemorySegment ipiv, MemorySegment b, int ldb, MemorySegment work) {
        var mh$ = LAPACKE_ssytrs2_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ssytrs2_work", matrix_layout, uplo, n, nrhs, a, lda, ipiv, b, ldb, work);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, nrhs, a, lda, ipiv, b, ldb, work);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zbbcsd {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zbbcsd");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zbbcsd(int matrix_layout, char jobu1, char jobu2, char jobv1t, char jobv2t, char trans, int m, int p, int q, double *theta, double *phi, _Complex double *u1, int ldu1, _Complex double *u2, int ldu2, _Complex double *v1t, int ldv1t, _Complex double *v2t, int ldv2t, double *b11d, double *b11e, double *b12d, double *b12e, double *b21d, double *b21e, double *b22d, double *b22e)
     * }
     */
    public static FunctionDescriptor LAPACKE_zbbcsd$descriptor() {
        return LAPACKE_zbbcsd.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zbbcsd(int matrix_layout, char jobu1, char jobu2, char jobv1t, char jobv2t, char trans, int m, int p, int q, double *theta, double *phi, _Complex double *u1, int ldu1, _Complex double *u2, int ldu2, _Complex double *v1t, int ldv1t, _Complex double *v2t, int ldv2t, double *b11d, double *b11e, double *b12d, double *b12e, double *b21d, double *b21e, double *b22d, double *b22e)
     * }
     */
    public static MethodHandle LAPACKE_zbbcsd$handle() {
        return LAPACKE_zbbcsd.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zbbcsd(int matrix_layout, char jobu1, char jobu2, char jobv1t, char jobv2t, char trans, int m, int p, int q, double *theta, double *phi, _Complex double *u1, int ldu1, _Complex double *u2, int ldu2, _Complex double *v1t, int ldv1t, _Complex double *v2t, int ldv2t, double *b11d, double *b11e, double *b12d, double *b12e, double *b21d, double *b21e, double *b22d, double *b22e)
     * }
     */
    public static MemorySegment LAPACKE_zbbcsd$address() {
        return LAPACKE_zbbcsd.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zbbcsd(int matrix_layout, char jobu1, char jobu2, char jobv1t, char jobv2t, char trans, int m, int p, int q, double *theta, double *phi, _Complex double *u1, int ldu1, _Complex double *u2, int ldu2, _Complex double *v1t, int ldv1t, _Complex double *v2t, int ldv2t, double *b11d, double *b11e, double *b12d, double *b12e, double *b21d, double *b21e, double *b22d, double *b22e)
     * }
     */
    public static int LAPACKE_zbbcsd(int matrix_layout, byte jobu1, byte jobu2, byte jobv1t, byte jobv2t, byte trans, int m, int p, int q, MemorySegment theta, MemorySegment phi, MemorySegment u1, int ldu1, MemorySegment u2, int ldu2, MemorySegment v1t, int ldv1t, MemorySegment v2t, int ldv2t, MemorySegment b11d, MemorySegment b11e, MemorySegment b12d, MemorySegment b12e, MemorySegment b21d, MemorySegment b21e, MemorySegment b22d, MemorySegment b22e) {
        var mh$ = LAPACKE_zbbcsd.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zbbcsd", matrix_layout, jobu1, jobu2, jobv1t, jobv2t, trans, m, p, q, theta, phi, u1, ldu1, u2, ldu2, v1t, ldv1t, v2t, ldv2t, b11d, b11e, b12d, b12e, b21d, b21e, b22d, b22e);
            }
            return (int)mh$.invokeExact(matrix_layout, jobu1, jobu2, jobv1t, jobv2t, trans, m, p, q, theta, phi, u1, ldu1, u2, ldu2, v1t, ldv1t, v2t, ldv2t, b11d, b11e, b12d, b12e, b21d, b21e, b22d, b22e);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zbbcsd_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zbbcsd_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zbbcsd_work(int matrix_layout, char jobu1, char jobu2, char jobv1t, char jobv2t, char trans, int m, int p, int q, double *theta, double *phi, _Complex double *u1, int ldu1, _Complex double *u2, int ldu2, _Complex double *v1t, int ldv1t, _Complex double *v2t, int ldv2t, double *b11d, double *b11e, double *b12d, double *b12e, double *b21d, double *b21e, double *b22d, double *b22e, double *rwork, int lrwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_zbbcsd_work$descriptor() {
        return LAPACKE_zbbcsd_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zbbcsd_work(int matrix_layout, char jobu1, char jobu2, char jobv1t, char jobv2t, char trans, int m, int p, int q, double *theta, double *phi, _Complex double *u1, int ldu1, _Complex double *u2, int ldu2, _Complex double *v1t, int ldv1t, _Complex double *v2t, int ldv2t, double *b11d, double *b11e, double *b12d, double *b12e, double *b21d, double *b21e, double *b22d, double *b22e, double *rwork, int lrwork)
     * }
     */
    public static MethodHandle LAPACKE_zbbcsd_work$handle() {
        return LAPACKE_zbbcsd_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zbbcsd_work(int matrix_layout, char jobu1, char jobu2, char jobv1t, char jobv2t, char trans, int m, int p, int q, double *theta, double *phi, _Complex double *u1, int ldu1, _Complex double *u2, int ldu2, _Complex double *v1t, int ldv1t, _Complex double *v2t, int ldv2t, double *b11d, double *b11e, double *b12d, double *b12e, double *b21d, double *b21e, double *b22d, double *b22e, double *rwork, int lrwork)
     * }
     */
    public static MemorySegment LAPACKE_zbbcsd_work$address() {
        return LAPACKE_zbbcsd_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zbbcsd_work(int matrix_layout, char jobu1, char jobu2, char jobv1t, char jobv2t, char trans, int m, int p, int q, double *theta, double *phi, _Complex double *u1, int ldu1, _Complex double *u2, int ldu2, _Complex double *v1t, int ldv1t, _Complex double *v2t, int ldv2t, double *b11d, double *b11e, double *b12d, double *b12e, double *b21d, double *b21e, double *b22d, double *b22e, double *rwork, int lrwork)
     * }
     */
    public static int LAPACKE_zbbcsd_work(int matrix_layout, byte jobu1, byte jobu2, byte jobv1t, byte jobv2t, byte trans, int m, int p, int q, MemorySegment theta, MemorySegment phi, MemorySegment u1, int ldu1, MemorySegment u2, int ldu2, MemorySegment v1t, int ldv1t, MemorySegment v2t, int ldv2t, MemorySegment b11d, MemorySegment b11e, MemorySegment b12d, MemorySegment b12e, MemorySegment b21d, MemorySegment b21e, MemorySegment b22d, MemorySegment b22e, MemorySegment rwork, int lrwork) {
        var mh$ = LAPACKE_zbbcsd_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zbbcsd_work", matrix_layout, jobu1, jobu2, jobv1t, jobv2t, trans, m, p, q, theta, phi, u1, ldu1, u2, ldu2, v1t, ldv1t, v2t, ldv2t, b11d, b11e, b12d, b12e, b21d, b21e, b22d, b22e, rwork, lrwork);
            }
            return (int)mh$.invokeExact(matrix_layout, jobu1, jobu2, jobv1t, jobv2t, trans, m, p, q, theta, phi, u1, ldu1, u2, ldu2, v1t, ldv1t, v2t, ldv2t, b11d, b11e, b12d, b12e, b21d, b21e, b22d, b22e, rwork, lrwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zheswapr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zheswapr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zheswapr(int matrix_layout, char uplo, int n, _Complex double *a, int lda, int i1, int i2)
     * }
     */
    public static FunctionDescriptor LAPACKE_zheswapr$descriptor() {
        return LAPACKE_zheswapr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zheswapr(int matrix_layout, char uplo, int n, _Complex double *a, int lda, int i1, int i2)
     * }
     */
    public static MethodHandle LAPACKE_zheswapr$handle() {
        return LAPACKE_zheswapr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zheswapr(int matrix_layout, char uplo, int n, _Complex double *a, int lda, int i1, int i2)
     * }
     */
    public static MemorySegment LAPACKE_zheswapr$address() {
        return LAPACKE_zheswapr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zheswapr(int matrix_layout, char uplo, int n, _Complex double *a, int lda, int i1, int i2)
     * }
     */
    public static int LAPACKE_zheswapr(int matrix_layout, byte uplo, int n, MemorySegment a, int lda, int i1, int i2) {
        var mh$ = LAPACKE_zheswapr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zheswapr", matrix_layout, uplo, n, a, lda, i1, i2);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, a, lda, i1, i2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zheswapr_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zheswapr_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zheswapr_work(int matrix_layout, char uplo, int n, _Complex double *a, int lda, int i1, int i2)
     * }
     */
    public static FunctionDescriptor LAPACKE_zheswapr_work$descriptor() {
        return LAPACKE_zheswapr_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zheswapr_work(int matrix_layout, char uplo, int n, _Complex double *a, int lda, int i1, int i2)
     * }
     */
    public static MethodHandle LAPACKE_zheswapr_work$handle() {
        return LAPACKE_zheswapr_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zheswapr_work(int matrix_layout, char uplo, int n, _Complex double *a, int lda, int i1, int i2)
     * }
     */
    public static MemorySegment LAPACKE_zheswapr_work$address() {
        return LAPACKE_zheswapr_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zheswapr_work(int matrix_layout, char uplo, int n, _Complex double *a, int lda, int i1, int i2)
     * }
     */
    public static int LAPACKE_zheswapr_work(int matrix_layout, byte uplo, int n, MemorySegment a, int lda, int i1, int i2) {
        var mh$ = LAPACKE_zheswapr_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zheswapr_work", matrix_layout, uplo, n, a, lda, i1, i2);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, a, lda, i1, i2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zhetri2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zhetri2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zhetri2(int matrix_layout, char uplo, int n, _Complex double *a, int lda, const int *ipiv)
     * }
     */
    public static FunctionDescriptor LAPACKE_zhetri2$descriptor() {
        return LAPACKE_zhetri2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zhetri2(int matrix_layout, char uplo, int n, _Complex double *a, int lda, const int *ipiv)
     * }
     */
    public static MethodHandle LAPACKE_zhetri2$handle() {
        return LAPACKE_zhetri2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zhetri2(int matrix_layout, char uplo, int n, _Complex double *a, int lda, const int *ipiv)
     * }
     */
    public static MemorySegment LAPACKE_zhetri2$address() {
        return LAPACKE_zhetri2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zhetri2(int matrix_layout, char uplo, int n, _Complex double *a, int lda, const int *ipiv)
     * }
     */
    public static int LAPACKE_zhetri2(int matrix_layout, byte uplo, int n, MemorySegment a, int lda, MemorySegment ipiv) {
        var mh$ = LAPACKE_zhetri2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zhetri2", matrix_layout, uplo, n, a, lda, ipiv);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, a, lda, ipiv);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zhetri2_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zhetri2_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zhetri2_work(int matrix_layout, char uplo, int n, _Complex double *a, int lda, const int *ipiv, _Complex double *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_zhetri2_work$descriptor() {
        return LAPACKE_zhetri2_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zhetri2_work(int matrix_layout, char uplo, int n, _Complex double *a, int lda, const int *ipiv, _Complex double *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_zhetri2_work$handle() {
        return LAPACKE_zhetri2_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zhetri2_work(int matrix_layout, char uplo, int n, _Complex double *a, int lda, const int *ipiv, _Complex double *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_zhetri2_work$address() {
        return LAPACKE_zhetri2_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zhetri2_work(int matrix_layout, char uplo, int n, _Complex double *a, int lda, const int *ipiv, _Complex double *work, int lwork)
     * }
     */
    public static int LAPACKE_zhetri2_work(int matrix_layout, byte uplo, int n, MemorySegment a, int lda, MemorySegment ipiv, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_zhetri2_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zhetri2_work", matrix_layout, uplo, n, a, lda, ipiv, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, a, lda, ipiv, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zhetri2x {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zhetri2x");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zhetri2x(int matrix_layout, char uplo, int n, _Complex double *a, int lda, const int *ipiv, int nb)
     * }
     */
    public static FunctionDescriptor LAPACKE_zhetri2x$descriptor() {
        return LAPACKE_zhetri2x.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zhetri2x(int matrix_layout, char uplo, int n, _Complex double *a, int lda, const int *ipiv, int nb)
     * }
     */
    public static MethodHandle LAPACKE_zhetri2x$handle() {
        return LAPACKE_zhetri2x.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zhetri2x(int matrix_layout, char uplo, int n, _Complex double *a, int lda, const int *ipiv, int nb)
     * }
     */
    public static MemorySegment LAPACKE_zhetri2x$address() {
        return LAPACKE_zhetri2x.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zhetri2x(int matrix_layout, char uplo, int n, _Complex double *a, int lda, const int *ipiv, int nb)
     * }
     */
    public static int LAPACKE_zhetri2x(int matrix_layout, byte uplo, int n, MemorySegment a, int lda, MemorySegment ipiv, int nb) {
        var mh$ = LAPACKE_zhetri2x.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zhetri2x", matrix_layout, uplo, n, a, lda, ipiv, nb);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, a, lda, ipiv, nb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zhetri2x_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zhetri2x_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zhetri2x_work(int matrix_layout, char uplo, int n, _Complex double *a, int lda, const int *ipiv, _Complex double *work, int nb)
     * }
     */
    public static FunctionDescriptor LAPACKE_zhetri2x_work$descriptor() {
        return LAPACKE_zhetri2x_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zhetri2x_work(int matrix_layout, char uplo, int n, _Complex double *a, int lda, const int *ipiv, _Complex double *work, int nb)
     * }
     */
    public static MethodHandle LAPACKE_zhetri2x_work$handle() {
        return LAPACKE_zhetri2x_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zhetri2x_work(int matrix_layout, char uplo, int n, _Complex double *a, int lda, const int *ipiv, _Complex double *work, int nb)
     * }
     */
    public static MemorySegment LAPACKE_zhetri2x_work$address() {
        return LAPACKE_zhetri2x_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zhetri2x_work(int matrix_layout, char uplo, int n, _Complex double *a, int lda, const int *ipiv, _Complex double *work, int nb)
     * }
     */
    public static int LAPACKE_zhetri2x_work(int matrix_layout, byte uplo, int n, MemorySegment a, int lda, MemorySegment ipiv, MemorySegment work, int nb) {
        var mh$ = LAPACKE_zhetri2x_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zhetri2x_work", matrix_layout, uplo, n, a, lda, ipiv, work, nb);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, a, lda, ipiv, work, nb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zhetrs2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zhetrs2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zhetrs2(int matrix_layout, char uplo, int n, int nrhs, const _Complex double *a, int lda, const int *ipiv, _Complex double *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_zhetrs2$descriptor() {
        return LAPACKE_zhetrs2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zhetrs2(int matrix_layout, char uplo, int n, int nrhs, const _Complex double *a, int lda, const int *ipiv, _Complex double *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_zhetrs2$handle() {
        return LAPACKE_zhetrs2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zhetrs2(int matrix_layout, char uplo, int n, int nrhs, const _Complex double *a, int lda, const int *ipiv, _Complex double *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_zhetrs2$address() {
        return LAPACKE_zhetrs2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zhetrs2(int matrix_layout, char uplo, int n, int nrhs, const _Complex double *a, int lda, const int *ipiv, _Complex double *b, int ldb)
     * }
     */
    public static int LAPACKE_zhetrs2(int matrix_layout, byte uplo, int n, int nrhs, MemorySegment a, int lda, MemorySegment ipiv, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_zhetrs2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zhetrs2", matrix_layout, uplo, n, nrhs, a, lda, ipiv, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, nrhs, a, lda, ipiv, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zhetrs2_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zhetrs2_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zhetrs2_work(int matrix_layout, char uplo, int n, int nrhs, const _Complex double *a, int lda, const int *ipiv, _Complex double *b, int ldb, _Complex double *work)
     * }
     */
    public static FunctionDescriptor LAPACKE_zhetrs2_work$descriptor() {
        return LAPACKE_zhetrs2_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zhetrs2_work(int matrix_layout, char uplo, int n, int nrhs, const _Complex double *a, int lda, const int *ipiv, _Complex double *b, int ldb, _Complex double *work)
     * }
     */
    public static MethodHandle LAPACKE_zhetrs2_work$handle() {
        return LAPACKE_zhetrs2_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zhetrs2_work(int matrix_layout, char uplo, int n, int nrhs, const _Complex double *a, int lda, const int *ipiv, _Complex double *b, int ldb, _Complex double *work)
     * }
     */
    public static MemorySegment LAPACKE_zhetrs2_work$address() {
        return LAPACKE_zhetrs2_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zhetrs2_work(int matrix_layout, char uplo, int n, int nrhs, const _Complex double *a, int lda, const int *ipiv, _Complex double *b, int ldb, _Complex double *work)
     * }
     */
    public static int LAPACKE_zhetrs2_work(int matrix_layout, byte uplo, int n, int nrhs, MemorySegment a, int lda, MemorySegment ipiv, MemorySegment b, int ldb, MemorySegment work) {
        var mh$ = LAPACKE_zhetrs2_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zhetrs2_work", matrix_layout, uplo, n, nrhs, a, lda, ipiv, b, ldb, work);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, nrhs, a, lda, ipiv, b, ldb, work);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zsyconv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zsyconv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zsyconv(int matrix_layout, char uplo, char way, int n, _Complex double *a, int lda, const int *ipiv, _Complex double *e)
     * }
     */
    public static FunctionDescriptor LAPACKE_zsyconv$descriptor() {
        return LAPACKE_zsyconv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zsyconv(int matrix_layout, char uplo, char way, int n, _Complex double *a, int lda, const int *ipiv, _Complex double *e)
     * }
     */
    public static MethodHandle LAPACKE_zsyconv$handle() {
        return LAPACKE_zsyconv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zsyconv(int matrix_layout, char uplo, char way, int n, _Complex double *a, int lda, const int *ipiv, _Complex double *e)
     * }
     */
    public static MemorySegment LAPACKE_zsyconv$address() {
        return LAPACKE_zsyconv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zsyconv(int matrix_layout, char uplo, char way, int n, _Complex double *a, int lda, const int *ipiv, _Complex double *e)
     * }
     */
    public static int LAPACKE_zsyconv(int matrix_layout, byte uplo, byte way, int n, MemorySegment a, int lda, MemorySegment ipiv, MemorySegment e) {
        var mh$ = LAPACKE_zsyconv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zsyconv", matrix_layout, uplo, way, n, a, lda, ipiv, e);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, way, n, a, lda, ipiv, e);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zsyconv_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zsyconv_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zsyconv_work(int matrix_layout, char uplo, char way, int n, _Complex double *a, int lda, const int *ipiv, _Complex double *e)
     * }
     */
    public static FunctionDescriptor LAPACKE_zsyconv_work$descriptor() {
        return LAPACKE_zsyconv_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zsyconv_work(int matrix_layout, char uplo, char way, int n, _Complex double *a, int lda, const int *ipiv, _Complex double *e)
     * }
     */
    public static MethodHandle LAPACKE_zsyconv_work$handle() {
        return LAPACKE_zsyconv_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zsyconv_work(int matrix_layout, char uplo, char way, int n, _Complex double *a, int lda, const int *ipiv, _Complex double *e)
     * }
     */
    public static MemorySegment LAPACKE_zsyconv_work$address() {
        return LAPACKE_zsyconv_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zsyconv_work(int matrix_layout, char uplo, char way, int n, _Complex double *a, int lda, const int *ipiv, _Complex double *e)
     * }
     */
    public static int LAPACKE_zsyconv_work(int matrix_layout, byte uplo, byte way, int n, MemorySegment a, int lda, MemorySegment ipiv, MemorySegment e) {
        var mh$ = LAPACKE_zsyconv_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zsyconv_work", matrix_layout, uplo, way, n, a, lda, ipiv, e);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, way, n, a, lda, ipiv, e);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zsyswapr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zsyswapr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zsyswapr(int matrix_layout, char uplo, int n, _Complex double *a, int lda, int i1, int i2)
     * }
     */
    public static FunctionDescriptor LAPACKE_zsyswapr$descriptor() {
        return LAPACKE_zsyswapr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zsyswapr(int matrix_layout, char uplo, int n, _Complex double *a, int lda, int i1, int i2)
     * }
     */
    public static MethodHandle LAPACKE_zsyswapr$handle() {
        return LAPACKE_zsyswapr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zsyswapr(int matrix_layout, char uplo, int n, _Complex double *a, int lda, int i1, int i2)
     * }
     */
    public static MemorySegment LAPACKE_zsyswapr$address() {
        return LAPACKE_zsyswapr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zsyswapr(int matrix_layout, char uplo, int n, _Complex double *a, int lda, int i1, int i2)
     * }
     */
    public static int LAPACKE_zsyswapr(int matrix_layout, byte uplo, int n, MemorySegment a, int lda, int i1, int i2) {
        var mh$ = LAPACKE_zsyswapr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zsyswapr", matrix_layout, uplo, n, a, lda, i1, i2);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, a, lda, i1, i2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zsyswapr_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zsyswapr_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zsyswapr_work(int matrix_layout, char uplo, int n, _Complex double *a, int lda, int i1, int i2)
     * }
     */
    public static FunctionDescriptor LAPACKE_zsyswapr_work$descriptor() {
        return LAPACKE_zsyswapr_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zsyswapr_work(int matrix_layout, char uplo, int n, _Complex double *a, int lda, int i1, int i2)
     * }
     */
    public static MethodHandle LAPACKE_zsyswapr_work$handle() {
        return LAPACKE_zsyswapr_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zsyswapr_work(int matrix_layout, char uplo, int n, _Complex double *a, int lda, int i1, int i2)
     * }
     */
    public static MemorySegment LAPACKE_zsyswapr_work$address() {
        return LAPACKE_zsyswapr_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zsyswapr_work(int matrix_layout, char uplo, int n, _Complex double *a, int lda, int i1, int i2)
     * }
     */
    public static int LAPACKE_zsyswapr_work(int matrix_layout, byte uplo, int n, MemorySegment a, int lda, int i1, int i2) {
        var mh$ = LAPACKE_zsyswapr_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zsyswapr_work", matrix_layout, uplo, n, a, lda, i1, i2);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, a, lda, i1, i2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zsytri2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zsytri2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zsytri2(int matrix_layout, char uplo, int n, _Complex double *a, int lda, const int *ipiv)
     * }
     */
    public static FunctionDescriptor LAPACKE_zsytri2$descriptor() {
        return LAPACKE_zsytri2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zsytri2(int matrix_layout, char uplo, int n, _Complex double *a, int lda, const int *ipiv)
     * }
     */
    public static MethodHandle LAPACKE_zsytri2$handle() {
        return LAPACKE_zsytri2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zsytri2(int matrix_layout, char uplo, int n, _Complex double *a, int lda, const int *ipiv)
     * }
     */
    public static MemorySegment LAPACKE_zsytri2$address() {
        return LAPACKE_zsytri2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zsytri2(int matrix_layout, char uplo, int n, _Complex double *a, int lda, const int *ipiv)
     * }
     */
    public static int LAPACKE_zsytri2(int matrix_layout, byte uplo, int n, MemorySegment a, int lda, MemorySegment ipiv) {
        var mh$ = LAPACKE_zsytri2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zsytri2", matrix_layout, uplo, n, a, lda, ipiv);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, a, lda, ipiv);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zsytri2_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zsytri2_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zsytri2_work(int matrix_layout, char uplo, int n, _Complex double *a, int lda, const int *ipiv, _Complex double *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_zsytri2_work$descriptor() {
        return LAPACKE_zsytri2_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zsytri2_work(int matrix_layout, char uplo, int n, _Complex double *a, int lda, const int *ipiv, _Complex double *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_zsytri2_work$handle() {
        return LAPACKE_zsytri2_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zsytri2_work(int matrix_layout, char uplo, int n, _Complex double *a, int lda, const int *ipiv, _Complex double *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_zsytri2_work$address() {
        return LAPACKE_zsytri2_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zsytri2_work(int matrix_layout, char uplo, int n, _Complex double *a, int lda, const int *ipiv, _Complex double *work, int lwork)
     * }
     */
    public static int LAPACKE_zsytri2_work(int matrix_layout, byte uplo, int n, MemorySegment a, int lda, MemorySegment ipiv, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_zsytri2_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zsytri2_work", matrix_layout, uplo, n, a, lda, ipiv, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, a, lda, ipiv, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zsytri2x {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zsytri2x");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zsytri2x(int matrix_layout, char uplo, int n, _Complex double *a, int lda, const int *ipiv, int nb)
     * }
     */
    public static FunctionDescriptor LAPACKE_zsytri2x$descriptor() {
        return LAPACKE_zsytri2x.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zsytri2x(int matrix_layout, char uplo, int n, _Complex double *a, int lda, const int *ipiv, int nb)
     * }
     */
    public static MethodHandle LAPACKE_zsytri2x$handle() {
        return LAPACKE_zsytri2x.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zsytri2x(int matrix_layout, char uplo, int n, _Complex double *a, int lda, const int *ipiv, int nb)
     * }
     */
    public static MemorySegment LAPACKE_zsytri2x$address() {
        return LAPACKE_zsytri2x.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zsytri2x(int matrix_layout, char uplo, int n, _Complex double *a, int lda, const int *ipiv, int nb)
     * }
     */
    public static int LAPACKE_zsytri2x(int matrix_layout, byte uplo, int n, MemorySegment a, int lda, MemorySegment ipiv, int nb) {
        var mh$ = LAPACKE_zsytri2x.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zsytri2x", matrix_layout, uplo, n, a, lda, ipiv, nb);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, a, lda, ipiv, nb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zsytri2x_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zsytri2x_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zsytri2x_work(int matrix_layout, char uplo, int n, _Complex double *a, int lda, const int *ipiv, _Complex double *work, int nb)
     * }
     */
    public static FunctionDescriptor LAPACKE_zsytri2x_work$descriptor() {
        return LAPACKE_zsytri2x_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zsytri2x_work(int matrix_layout, char uplo, int n, _Complex double *a, int lda, const int *ipiv, _Complex double *work, int nb)
     * }
     */
    public static MethodHandle LAPACKE_zsytri2x_work$handle() {
        return LAPACKE_zsytri2x_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zsytri2x_work(int matrix_layout, char uplo, int n, _Complex double *a, int lda, const int *ipiv, _Complex double *work, int nb)
     * }
     */
    public static MemorySegment LAPACKE_zsytri2x_work$address() {
        return LAPACKE_zsytri2x_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zsytri2x_work(int matrix_layout, char uplo, int n, _Complex double *a, int lda, const int *ipiv, _Complex double *work, int nb)
     * }
     */
    public static int LAPACKE_zsytri2x_work(int matrix_layout, byte uplo, int n, MemorySegment a, int lda, MemorySegment ipiv, MemorySegment work, int nb) {
        var mh$ = LAPACKE_zsytri2x_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zsytri2x_work", matrix_layout, uplo, n, a, lda, ipiv, work, nb);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, a, lda, ipiv, work, nb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zsytrs2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zsytrs2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zsytrs2(int matrix_layout, char uplo, int n, int nrhs, const _Complex double *a, int lda, const int *ipiv, _Complex double *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_zsytrs2$descriptor() {
        return LAPACKE_zsytrs2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zsytrs2(int matrix_layout, char uplo, int n, int nrhs, const _Complex double *a, int lda, const int *ipiv, _Complex double *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_zsytrs2$handle() {
        return LAPACKE_zsytrs2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zsytrs2(int matrix_layout, char uplo, int n, int nrhs, const _Complex double *a, int lda, const int *ipiv, _Complex double *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_zsytrs2$address() {
        return LAPACKE_zsytrs2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zsytrs2(int matrix_layout, char uplo, int n, int nrhs, const _Complex double *a, int lda, const int *ipiv, _Complex double *b, int ldb)
     * }
     */
    public static int LAPACKE_zsytrs2(int matrix_layout, byte uplo, int n, int nrhs, MemorySegment a, int lda, MemorySegment ipiv, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_zsytrs2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zsytrs2", matrix_layout, uplo, n, nrhs, a, lda, ipiv, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, nrhs, a, lda, ipiv, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zsytrs2_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zsytrs2_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zsytrs2_work(int matrix_layout, char uplo, int n, int nrhs, const _Complex double *a, int lda, const int *ipiv, _Complex double *b, int ldb, _Complex double *work)
     * }
     */
    public static FunctionDescriptor LAPACKE_zsytrs2_work$descriptor() {
        return LAPACKE_zsytrs2_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zsytrs2_work(int matrix_layout, char uplo, int n, int nrhs, const _Complex double *a, int lda, const int *ipiv, _Complex double *b, int ldb, _Complex double *work)
     * }
     */
    public static MethodHandle LAPACKE_zsytrs2_work$handle() {
        return LAPACKE_zsytrs2_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zsytrs2_work(int matrix_layout, char uplo, int n, int nrhs, const _Complex double *a, int lda, const int *ipiv, _Complex double *b, int ldb, _Complex double *work)
     * }
     */
    public static MemorySegment LAPACKE_zsytrs2_work$address() {
        return LAPACKE_zsytrs2_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zsytrs2_work(int matrix_layout, char uplo, int n, int nrhs, const _Complex double *a, int lda, const int *ipiv, _Complex double *b, int ldb, _Complex double *work)
     * }
     */
    public static int LAPACKE_zsytrs2_work(int matrix_layout, byte uplo, int n, int nrhs, MemorySegment a, int lda, MemorySegment ipiv, MemorySegment b, int ldb, MemorySegment work) {
        var mh$ = LAPACKE_zsytrs2_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zsytrs2_work", matrix_layout, uplo, n, nrhs, a, lda, ipiv, b, ldb, work);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, nrhs, a, lda, ipiv, b, ldb, work);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zunbdb {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zunbdb");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zunbdb(int matrix_layout, char trans, char signs, int m, int p, int q, _Complex double *x11, int ldx11, _Complex double *x12, int ldx12, _Complex double *x21, int ldx21, _Complex double *x22, int ldx22, double *theta, double *phi, _Complex double *taup1, _Complex double *taup2, _Complex double *tauq1, _Complex double *tauq2)
     * }
     */
    public static FunctionDescriptor LAPACKE_zunbdb$descriptor() {
        return LAPACKE_zunbdb.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zunbdb(int matrix_layout, char trans, char signs, int m, int p, int q, _Complex double *x11, int ldx11, _Complex double *x12, int ldx12, _Complex double *x21, int ldx21, _Complex double *x22, int ldx22, double *theta, double *phi, _Complex double *taup1, _Complex double *taup2, _Complex double *tauq1, _Complex double *tauq2)
     * }
     */
    public static MethodHandle LAPACKE_zunbdb$handle() {
        return LAPACKE_zunbdb.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zunbdb(int matrix_layout, char trans, char signs, int m, int p, int q, _Complex double *x11, int ldx11, _Complex double *x12, int ldx12, _Complex double *x21, int ldx21, _Complex double *x22, int ldx22, double *theta, double *phi, _Complex double *taup1, _Complex double *taup2, _Complex double *tauq1, _Complex double *tauq2)
     * }
     */
    public static MemorySegment LAPACKE_zunbdb$address() {
        return LAPACKE_zunbdb.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zunbdb(int matrix_layout, char trans, char signs, int m, int p, int q, _Complex double *x11, int ldx11, _Complex double *x12, int ldx12, _Complex double *x21, int ldx21, _Complex double *x22, int ldx22, double *theta, double *phi, _Complex double *taup1, _Complex double *taup2, _Complex double *tauq1, _Complex double *tauq2)
     * }
     */
    public static int LAPACKE_zunbdb(int matrix_layout, byte trans, byte signs, int m, int p, int q, MemorySegment x11, int ldx11, MemorySegment x12, int ldx12, MemorySegment x21, int ldx21, MemorySegment x22, int ldx22, MemorySegment theta, MemorySegment phi, MemorySegment taup1, MemorySegment taup2, MemorySegment tauq1, MemorySegment tauq2) {
        var mh$ = LAPACKE_zunbdb.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zunbdb", matrix_layout, trans, signs, m, p, q, x11, ldx11, x12, ldx12, x21, ldx21, x22, ldx22, theta, phi, taup1, taup2, tauq1, tauq2);
            }
            return (int)mh$.invokeExact(matrix_layout, trans, signs, m, p, q, x11, ldx11, x12, ldx12, x21, ldx21, x22, ldx22, theta, phi, taup1, taup2, tauq1, tauq2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zunbdb_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zunbdb_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zunbdb_work(int matrix_layout, char trans, char signs, int m, int p, int q, _Complex double *x11, int ldx11, _Complex double *x12, int ldx12, _Complex double *x21, int ldx21, _Complex double *x22, int ldx22, double *theta, double *phi, _Complex double *taup1, _Complex double *taup2, _Complex double *tauq1, _Complex double *tauq2, _Complex double *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_zunbdb_work$descriptor() {
        return LAPACKE_zunbdb_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zunbdb_work(int matrix_layout, char trans, char signs, int m, int p, int q, _Complex double *x11, int ldx11, _Complex double *x12, int ldx12, _Complex double *x21, int ldx21, _Complex double *x22, int ldx22, double *theta, double *phi, _Complex double *taup1, _Complex double *taup2, _Complex double *tauq1, _Complex double *tauq2, _Complex double *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_zunbdb_work$handle() {
        return LAPACKE_zunbdb_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zunbdb_work(int matrix_layout, char trans, char signs, int m, int p, int q, _Complex double *x11, int ldx11, _Complex double *x12, int ldx12, _Complex double *x21, int ldx21, _Complex double *x22, int ldx22, double *theta, double *phi, _Complex double *taup1, _Complex double *taup2, _Complex double *tauq1, _Complex double *tauq2, _Complex double *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_zunbdb_work$address() {
        return LAPACKE_zunbdb_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zunbdb_work(int matrix_layout, char trans, char signs, int m, int p, int q, _Complex double *x11, int ldx11, _Complex double *x12, int ldx12, _Complex double *x21, int ldx21, _Complex double *x22, int ldx22, double *theta, double *phi, _Complex double *taup1, _Complex double *taup2, _Complex double *tauq1, _Complex double *tauq2, _Complex double *work, int lwork)
     * }
     */
    public static int LAPACKE_zunbdb_work(int matrix_layout, byte trans, byte signs, int m, int p, int q, MemorySegment x11, int ldx11, MemorySegment x12, int ldx12, MemorySegment x21, int ldx21, MemorySegment x22, int ldx22, MemorySegment theta, MemorySegment phi, MemorySegment taup1, MemorySegment taup2, MemorySegment tauq1, MemorySegment tauq2, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_zunbdb_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zunbdb_work", matrix_layout, trans, signs, m, p, q, x11, ldx11, x12, ldx12, x21, ldx21, x22, ldx22, theta, phi, taup1, taup2, tauq1, tauq2, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, trans, signs, m, p, q, x11, ldx11, x12, ldx12, x21, ldx21, x22, ldx22, theta, phi, taup1, taup2, tauq1, tauq2, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zuncsd {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zuncsd");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zuncsd(int matrix_layout, char jobu1, char jobu2, char jobv1t, char jobv2t, char trans, char signs, int m, int p, int q, _Complex double *x11, int ldx11, _Complex double *x12, int ldx12, _Complex double *x21, int ldx21, _Complex double *x22, int ldx22, double *theta, _Complex double *u1, int ldu1, _Complex double *u2, int ldu2, _Complex double *v1t, int ldv1t, _Complex double *v2t, int ldv2t)
     * }
     */
    public static FunctionDescriptor LAPACKE_zuncsd$descriptor() {
        return LAPACKE_zuncsd.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zuncsd(int matrix_layout, char jobu1, char jobu2, char jobv1t, char jobv2t, char trans, char signs, int m, int p, int q, _Complex double *x11, int ldx11, _Complex double *x12, int ldx12, _Complex double *x21, int ldx21, _Complex double *x22, int ldx22, double *theta, _Complex double *u1, int ldu1, _Complex double *u2, int ldu2, _Complex double *v1t, int ldv1t, _Complex double *v2t, int ldv2t)
     * }
     */
    public static MethodHandle LAPACKE_zuncsd$handle() {
        return LAPACKE_zuncsd.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zuncsd(int matrix_layout, char jobu1, char jobu2, char jobv1t, char jobv2t, char trans, char signs, int m, int p, int q, _Complex double *x11, int ldx11, _Complex double *x12, int ldx12, _Complex double *x21, int ldx21, _Complex double *x22, int ldx22, double *theta, _Complex double *u1, int ldu1, _Complex double *u2, int ldu2, _Complex double *v1t, int ldv1t, _Complex double *v2t, int ldv2t)
     * }
     */
    public static MemorySegment LAPACKE_zuncsd$address() {
        return LAPACKE_zuncsd.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zuncsd(int matrix_layout, char jobu1, char jobu2, char jobv1t, char jobv2t, char trans, char signs, int m, int p, int q, _Complex double *x11, int ldx11, _Complex double *x12, int ldx12, _Complex double *x21, int ldx21, _Complex double *x22, int ldx22, double *theta, _Complex double *u1, int ldu1, _Complex double *u2, int ldu2, _Complex double *v1t, int ldv1t, _Complex double *v2t, int ldv2t)
     * }
     */
    public static int LAPACKE_zuncsd(int matrix_layout, byte jobu1, byte jobu2, byte jobv1t, byte jobv2t, byte trans, byte signs, int m, int p, int q, MemorySegment x11, int ldx11, MemorySegment x12, int ldx12, MemorySegment x21, int ldx21, MemorySegment x22, int ldx22, MemorySegment theta, MemorySegment u1, int ldu1, MemorySegment u2, int ldu2, MemorySegment v1t, int ldv1t, MemorySegment v2t, int ldv2t) {
        var mh$ = LAPACKE_zuncsd.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zuncsd", matrix_layout, jobu1, jobu2, jobv1t, jobv2t, trans, signs, m, p, q, x11, ldx11, x12, ldx12, x21, ldx21, x22, ldx22, theta, u1, ldu1, u2, ldu2, v1t, ldv1t, v2t, ldv2t);
            }
            return (int)mh$.invokeExact(matrix_layout, jobu1, jobu2, jobv1t, jobv2t, trans, signs, m, p, q, x11, ldx11, x12, ldx12, x21, ldx21, x22, ldx22, theta, u1, ldu1, u2, ldu2, v1t, ldv1t, v2t, ldv2t);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zuncsd_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zuncsd_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zuncsd_work(int matrix_layout, char jobu1, char jobu2, char jobv1t, char jobv2t, char trans, char signs, int m, int p, int q, _Complex double *x11, int ldx11, _Complex double *x12, int ldx12, _Complex double *x21, int ldx21, _Complex double *x22, int ldx22, double *theta, _Complex double *u1, int ldu1, _Complex double *u2, int ldu2, _Complex double *v1t, int ldv1t, _Complex double *v2t, int ldv2t, _Complex double *work, int lwork, double *rwork, int lrwork, int *iwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_zuncsd_work$descriptor() {
        return LAPACKE_zuncsd_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zuncsd_work(int matrix_layout, char jobu1, char jobu2, char jobv1t, char jobv2t, char trans, char signs, int m, int p, int q, _Complex double *x11, int ldx11, _Complex double *x12, int ldx12, _Complex double *x21, int ldx21, _Complex double *x22, int ldx22, double *theta, _Complex double *u1, int ldu1, _Complex double *u2, int ldu2, _Complex double *v1t, int ldv1t, _Complex double *v2t, int ldv2t, _Complex double *work, int lwork, double *rwork, int lrwork, int *iwork)
     * }
     */
    public static MethodHandle LAPACKE_zuncsd_work$handle() {
        return LAPACKE_zuncsd_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zuncsd_work(int matrix_layout, char jobu1, char jobu2, char jobv1t, char jobv2t, char trans, char signs, int m, int p, int q, _Complex double *x11, int ldx11, _Complex double *x12, int ldx12, _Complex double *x21, int ldx21, _Complex double *x22, int ldx22, double *theta, _Complex double *u1, int ldu1, _Complex double *u2, int ldu2, _Complex double *v1t, int ldv1t, _Complex double *v2t, int ldv2t, _Complex double *work, int lwork, double *rwork, int lrwork, int *iwork)
     * }
     */
    public static MemorySegment LAPACKE_zuncsd_work$address() {
        return LAPACKE_zuncsd_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zuncsd_work(int matrix_layout, char jobu1, char jobu2, char jobv1t, char jobv2t, char trans, char signs, int m, int p, int q, _Complex double *x11, int ldx11, _Complex double *x12, int ldx12, _Complex double *x21, int ldx21, _Complex double *x22, int ldx22, double *theta, _Complex double *u1, int ldu1, _Complex double *u2, int ldu2, _Complex double *v1t, int ldv1t, _Complex double *v2t, int ldv2t, _Complex double *work, int lwork, double *rwork, int lrwork, int *iwork)
     * }
     */
    public static int LAPACKE_zuncsd_work(int matrix_layout, byte jobu1, byte jobu2, byte jobv1t, byte jobv2t, byte trans, byte signs, int m, int p, int q, MemorySegment x11, int ldx11, MemorySegment x12, int ldx12, MemorySegment x21, int ldx21, MemorySegment x22, int ldx22, MemorySegment theta, MemorySegment u1, int ldu1, MemorySegment u2, int ldu2, MemorySegment v1t, int ldv1t, MemorySegment v2t, int ldv2t, MemorySegment work, int lwork, MemorySegment rwork, int lrwork, MemorySegment iwork) {
        var mh$ = LAPACKE_zuncsd_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zuncsd_work", matrix_layout, jobu1, jobu2, jobv1t, jobv2t, trans, signs, m, p, q, x11, ldx11, x12, ldx12, x21, ldx21, x22, ldx22, theta, u1, ldu1, u2, ldu2, v1t, ldv1t, v2t, ldv2t, work, lwork, rwork, lrwork, iwork);
            }
            return (int)mh$.invokeExact(matrix_layout, jobu1, jobu2, jobv1t, jobv2t, trans, signs, m, p, q, x11, ldx11, x12, ldx12, x21, ldx21, x22, ldx22, theta, u1, ldu1, u2, ldu2, v1t, ldv1t, v2t, ldv2t, work, lwork, rwork, lrwork, iwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zuncsd2by1 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zuncsd2by1");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zuncsd2by1(int matrix_layout, char jobu1, char jobu2, char jobv1t, int m, int p, int q, _Complex double *x11, int ldx11, _Complex double *x21, int ldx21, double *theta, _Complex double *u1, int ldu1, _Complex double *u2, int ldu2, _Complex double *v1t, int ldv1t)
     * }
     */
    public static FunctionDescriptor LAPACKE_zuncsd2by1$descriptor() {
        return LAPACKE_zuncsd2by1.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zuncsd2by1(int matrix_layout, char jobu1, char jobu2, char jobv1t, int m, int p, int q, _Complex double *x11, int ldx11, _Complex double *x21, int ldx21, double *theta, _Complex double *u1, int ldu1, _Complex double *u2, int ldu2, _Complex double *v1t, int ldv1t)
     * }
     */
    public static MethodHandle LAPACKE_zuncsd2by1$handle() {
        return LAPACKE_zuncsd2by1.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zuncsd2by1(int matrix_layout, char jobu1, char jobu2, char jobv1t, int m, int p, int q, _Complex double *x11, int ldx11, _Complex double *x21, int ldx21, double *theta, _Complex double *u1, int ldu1, _Complex double *u2, int ldu2, _Complex double *v1t, int ldv1t)
     * }
     */
    public static MemorySegment LAPACKE_zuncsd2by1$address() {
        return LAPACKE_zuncsd2by1.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zuncsd2by1(int matrix_layout, char jobu1, char jobu2, char jobv1t, int m, int p, int q, _Complex double *x11, int ldx11, _Complex double *x21, int ldx21, double *theta, _Complex double *u1, int ldu1, _Complex double *u2, int ldu2, _Complex double *v1t, int ldv1t)
     * }
     */
    public static int LAPACKE_zuncsd2by1(int matrix_layout, byte jobu1, byte jobu2, byte jobv1t, int m, int p, int q, MemorySegment x11, int ldx11, MemorySegment x21, int ldx21, MemorySegment theta, MemorySegment u1, int ldu1, MemorySegment u2, int ldu2, MemorySegment v1t, int ldv1t) {
        var mh$ = LAPACKE_zuncsd2by1.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zuncsd2by1", matrix_layout, jobu1, jobu2, jobv1t, m, p, q, x11, ldx11, x21, ldx21, theta, u1, ldu1, u2, ldu2, v1t, ldv1t);
            }
            return (int)mh$.invokeExact(matrix_layout, jobu1, jobu2, jobv1t, m, p, q, x11, ldx11, x21, ldx21, theta, u1, ldu1, u2, ldu2, v1t, ldv1t);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zuncsd2by1_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zuncsd2by1_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zuncsd2by1_work(int matrix_layout, char jobu1, char jobu2, char jobv1t, int m, int p, int q, _Complex double *x11, int ldx11, _Complex double *x21, int ldx21, double *theta, _Complex double *u1, int ldu1, _Complex double *u2, int ldu2, _Complex double *v1t, int ldv1t, _Complex double *work, int lwork, double *rwork, int lrwork, int *iwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_zuncsd2by1_work$descriptor() {
        return LAPACKE_zuncsd2by1_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zuncsd2by1_work(int matrix_layout, char jobu1, char jobu2, char jobv1t, int m, int p, int q, _Complex double *x11, int ldx11, _Complex double *x21, int ldx21, double *theta, _Complex double *u1, int ldu1, _Complex double *u2, int ldu2, _Complex double *v1t, int ldv1t, _Complex double *work, int lwork, double *rwork, int lrwork, int *iwork)
     * }
     */
    public static MethodHandle LAPACKE_zuncsd2by1_work$handle() {
        return LAPACKE_zuncsd2by1_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zuncsd2by1_work(int matrix_layout, char jobu1, char jobu2, char jobv1t, int m, int p, int q, _Complex double *x11, int ldx11, _Complex double *x21, int ldx21, double *theta, _Complex double *u1, int ldu1, _Complex double *u2, int ldu2, _Complex double *v1t, int ldv1t, _Complex double *work, int lwork, double *rwork, int lrwork, int *iwork)
     * }
     */
    public static MemorySegment LAPACKE_zuncsd2by1_work$address() {
        return LAPACKE_zuncsd2by1_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zuncsd2by1_work(int matrix_layout, char jobu1, char jobu2, char jobv1t, int m, int p, int q, _Complex double *x11, int ldx11, _Complex double *x21, int ldx21, double *theta, _Complex double *u1, int ldu1, _Complex double *u2, int ldu2, _Complex double *v1t, int ldv1t, _Complex double *work, int lwork, double *rwork, int lrwork, int *iwork)
     * }
     */
    public static int LAPACKE_zuncsd2by1_work(int matrix_layout, byte jobu1, byte jobu2, byte jobv1t, int m, int p, int q, MemorySegment x11, int ldx11, MemorySegment x21, int ldx21, MemorySegment theta, MemorySegment u1, int ldu1, MemorySegment u2, int ldu2, MemorySegment v1t, int ldv1t, MemorySegment work, int lwork, MemorySegment rwork, int lrwork, MemorySegment iwork) {
        var mh$ = LAPACKE_zuncsd2by1_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zuncsd2by1_work", matrix_layout, jobu1, jobu2, jobv1t, m, p, q, x11, ldx11, x21, ldx21, theta, u1, ldu1, u2, ldu2, v1t, ldv1t, work, lwork, rwork, lrwork, iwork);
            }
            return (int)mh$.invokeExact(matrix_layout, jobu1, jobu2, jobv1t, m, p, q, x11, ldx11, x21, ldx21, theta, u1, ldu1, u2, ldu2, v1t, ldv1t, work, lwork, rwork, lrwork, iwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sgemqrt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_sgemqrt");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sgemqrt(int matrix_layout, char side, char trans, int m, int n, int k, int nb, const float *v, int ldv, const float *t, int ldt, float *c, int ldc)
     * }
     */
    public static FunctionDescriptor LAPACKE_sgemqrt$descriptor() {
        return LAPACKE_sgemqrt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sgemqrt(int matrix_layout, char side, char trans, int m, int n, int k, int nb, const float *v, int ldv, const float *t, int ldt, float *c, int ldc)
     * }
     */
    public static MethodHandle LAPACKE_sgemqrt$handle() {
        return LAPACKE_sgemqrt.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sgemqrt(int matrix_layout, char side, char trans, int m, int n, int k, int nb, const float *v, int ldv, const float *t, int ldt, float *c, int ldc)
     * }
     */
    public static MemorySegment LAPACKE_sgemqrt$address() {
        return LAPACKE_sgemqrt.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sgemqrt(int matrix_layout, char side, char trans, int m, int n, int k, int nb, const float *v, int ldv, const float *t, int ldt, float *c, int ldc)
     * }
     */
    public static int LAPACKE_sgemqrt(int matrix_layout, byte side, byte trans, int m, int n, int k, int nb, MemorySegment v, int ldv, MemorySegment t, int ldt, MemorySegment c, int ldc) {
        var mh$ = LAPACKE_sgemqrt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sgemqrt", matrix_layout, side, trans, m, n, k, nb, v, ldv, t, ldt, c, ldc);
            }
            return (int)mh$.invokeExact(matrix_layout, side, trans, m, n, k, nb, v, ldv, t, ldt, c, ldc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dgemqrt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dgemqrt");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dgemqrt(int matrix_layout, char side, char trans, int m, int n, int k, int nb, const double *v, int ldv, const double *t, int ldt, double *c, int ldc)
     * }
     */
    public static FunctionDescriptor LAPACKE_dgemqrt$descriptor() {
        return LAPACKE_dgemqrt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dgemqrt(int matrix_layout, char side, char trans, int m, int n, int k, int nb, const double *v, int ldv, const double *t, int ldt, double *c, int ldc)
     * }
     */
    public static MethodHandle LAPACKE_dgemqrt$handle() {
        return LAPACKE_dgemqrt.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dgemqrt(int matrix_layout, char side, char trans, int m, int n, int k, int nb, const double *v, int ldv, const double *t, int ldt, double *c, int ldc)
     * }
     */
    public static MemorySegment LAPACKE_dgemqrt$address() {
        return LAPACKE_dgemqrt.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dgemqrt(int matrix_layout, char side, char trans, int m, int n, int k, int nb, const double *v, int ldv, const double *t, int ldt, double *c, int ldc)
     * }
     */
    public static int LAPACKE_dgemqrt(int matrix_layout, byte side, byte trans, int m, int n, int k, int nb, MemorySegment v, int ldv, MemorySegment t, int ldt, MemorySegment c, int ldc) {
        var mh$ = LAPACKE_dgemqrt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dgemqrt", matrix_layout, side, trans, m, n, k, nb, v, ldv, t, ldt, c, ldc);
            }
            return (int)mh$.invokeExact(matrix_layout, side, trans, m, n, k, nb, v, ldv, t, ldt, c, ldc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cgemqrt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_cgemqrt");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cgemqrt(int matrix_layout, char side, char trans, int m, int n, int k, int nb, const _Complex float *v, int ldv, const _Complex float *t, int ldt, _Complex float *c, int ldc)
     * }
     */
    public static FunctionDescriptor LAPACKE_cgemqrt$descriptor() {
        return LAPACKE_cgemqrt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cgemqrt(int matrix_layout, char side, char trans, int m, int n, int k, int nb, const _Complex float *v, int ldv, const _Complex float *t, int ldt, _Complex float *c, int ldc)
     * }
     */
    public static MethodHandle LAPACKE_cgemqrt$handle() {
        return LAPACKE_cgemqrt.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cgemqrt(int matrix_layout, char side, char trans, int m, int n, int k, int nb, const _Complex float *v, int ldv, const _Complex float *t, int ldt, _Complex float *c, int ldc)
     * }
     */
    public static MemorySegment LAPACKE_cgemqrt$address() {
        return LAPACKE_cgemqrt.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cgemqrt(int matrix_layout, char side, char trans, int m, int n, int k, int nb, const _Complex float *v, int ldv, const _Complex float *t, int ldt, _Complex float *c, int ldc)
     * }
     */
    public static int LAPACKE_cgemqrt(int matrix_layout, byte side, byte trans, int m, int n, int k, int nb, MemorySegment v, int ldv, MemorySegment t, int ldt, MemorySegment c, int ldc) {
        var mh$ = LAPACKE_cgemqrt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cgemqrt", matrix_layout, side, trans, m, n, k, nb, v, ldv, t, ldt, c, ldc);
            }
            return (int)mh$.invokeExact(matrix_layout, side, trans, m, n, k, nb, v, ldv, t, ldt, c, ldc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zgemqrt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zgemqrt");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zgemqrt(int matrix_layout, char side, char trans, int m, int n, int k, int nb, const _Complex double *v, int ldv, const _Complex double *t, int ldt, _Complex double *c, int ldc)
     * }
     */
    public static FunctionDescriptor LAPACKE_zgemqrt$descriptor() {
        return LAPACKE_zgemqrt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zgemqrt(int matrix_layout, char side, char trans, int m, int n, int k, int nb, const _Complex double *v, int ldv, const _Complex double *t, int ldt, _Complex double *c, int ldc)
     * }
     */
    public static MethodHandle LAPACKE_zgemqrt$handle() {
        return LAPACKE_zgemqrt.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zgemqrt(int matrix_layout, char side, char trans, int m, int n, int k, int nb, const _Complex double *v, int ldv, const _Complex double *t, int ldt, _Complex double *c, int ldc)
     * }
     */
    public static MemorySegment LAPACKE_zgemqrt$address() {
        return LAPACKE_zgemqrt.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zgemqrt(int matrix_layout, char side, char trans, int m, int n, int k, int nb, const _Complex double *v, int ldv, const _Complex double *t, int ldt, _Complex double *c, int ldc)
     * }
     */
    public static int LAPACKE_zgemqrt(int matrix_layout, byte side, byte trans, int m, int n, int k, int nb, MemorySegment v, int ldv, MemorySegment t, int ldt, MemorySegment c, int ldc) {
        var mh$ = LAPACKE_zgemqrt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zgemqrt", matrix_layout, side, trans, m, n, k, nb, v, ldv, t, ldt, c, ldc);
            }
            return (int)mh$.invokeExact(matrix_layout, side, trans, m, n, k, nb, v, ldv, t, ldt, c, ldc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sgeqrt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_sgeqrt");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sgeqrt(int matrix_layout, int m, int n, int nb, float *a, int lda, float *t, int ldt)
     * }
     */
    public static FunctionDescriptor LAPACKE_sgeqrt$descriptor() {
        return LAPACKE_sgeqrt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sgeqrt(int matrix_layout, int m, int n, int nb, float *a, int lda, float *t, int ldt)
     * }
     */
    public static MethodHandle LAPACKE_sgeqrt$handle() {
        return LAPACKE_sgeqrt.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sgeqrt(int matrix_layout, int m, int n, int nb, float *a, int lda, float *t, int ldt)
     * }
     */
    public static MemorySegment LAPACKE_sgeqrt$address() {
        return LAPACKE_sgeqrt.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sgeqrt(int matrix_layout, int m, int n, int nb, float *a, int lda, float *t, int ldt)
     * }
     */
    public static int LAPACKE_sgeqrt(int matrix_layout, int m, int n, int nb, MemorySegment a, int lda, MemorySegment t, int ldt) {
        var mh$ = LAPACKE_sgeqrt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sgeqrt", matrix_layout, m, n, nb, a, lda, t, ldt);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, nb, a, lda, t, ldt);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dgeqrt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dgeqrt");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dgeqrt(int matrix_layout, int m, int n, int nb, double *a, int lda, double *t, int ldt)
     * }
     */
    public static FunctionDescriptor LAPACKE_dgeqrt$descriptor() {
        return LAPACKE_dgeqrt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dgeqrt(int matrix_layout, int m, int n, int nb, double *a, int lda, double *t, int ldt)
     * }
     */
    public static MethodHandle LAPACKE_dgeqrt$handle() {
        return LAPACKE_dgeqrt.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dgeqrt(int matrix_layout, int m, int n, int nb, double *a, int lda, double *t, int ldt)
     * }
     */
    public static MemorySegment LAPACKE_dgeqrt$address() {
        return LAPACKE_dgeqrt.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dgeqrt(int matrix_layout, int m, int n, int nb, double *a, int lda, double *t, int ldt)
     * }
     */
    public static int LAPACKE_dgeqrt(int matrix_layout, int m, int n, int nb, MemorySegment a, int lda, MemorySegment t, int ldt) {
        var mh$ = LAPACKE_dgeqrt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dgeqrt", matrix_layout, m, n, nb, a, lda, t, ldt);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, nb, a, lda, t, ldt);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cgeqrt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_cgeqrt");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cgeqrt(int matrix_layout, int m, int n, int nb, _Complex float *a, int lda, _Complex float *t, int ldt)
     * }
     */
    public static FunctionDescriptor LAPACKE_cgeqrt$descriptor() {
        return LAPACKE_cgeqrt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cgeqrt(int matrix_layout, int m, int n, int nb, _Complex float *a, int lda, _Complex float *t, int ldt)
     * }
     */
    public static MethodHandle LAPACKE_cgeqrt$handle() {
        return LAPACKE_cgeqrt.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cgeqrt(int matrix_layout, int m, int n, int nb, _Complex float *a, int lda, _Complex float *t, int ldt)
     * }
     */
    public static MemorySegment LAPACKE_cgeqrt$address() {
        return LAPACKE_cgeqrt.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cgeqrt(int matrix_layout, int m, int n, int nb, _Complex float *a, int lda, _Complex float *t, int ldt)
     * }
     */
    public static int LAPACKE_cgeqrt(int matrix_layout, int m, int n, int nb, MemorySegment a, int lda, MemorySegment t, int ldt) {
        var mh$ = LAPACKE_cgeqrt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cgeqrt", matrix_layout, m, n, nb, a, lda, t, ldt);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, nb, a, lda, t, ldt);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zgeqrt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zgeqrt");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zgeqrt(int matrix_layout, int m, int n, int nb, _Complex double *a, int lda, _Complex double *t, int ldt)
     * }
     */
    public static FunctionDescriptor LAPACKE_zgeqrt$descriptor() {
        return LAPACKE_zgeqrt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zgeqrt(int matrix_layout, int m, int n, int nb, _Complex double *a, int lda, _Complex double *t, int ldt)
     * }
     */
    public static MethodHandle LAPACKE_zgeqrt$handle() {
        return LAPACKE_zgeqrt.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zgeqrt(int matrix_layout, int m, int n, int nb, _Complex double *a, int lda, _Complex double *t, int ldt)
     * }
     */
    public static MemorySegment LAPACKE_zgeqrt$address() {
        return LAPACKE_zgeqrt.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zgeqrt(int matrix_layout, int m, int n, int nb, _Complex double *a, int lda, _Complex double *t, int ldt)
     * }
     */
    public static int LAPACKE_zgeqrt(int matrix_layout, int m, int n, int nb, MemorySegment a, int lda, MemorySegment t, int ldt) {
        var mh$ = LAPACKE_zgeqrt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zgeqrt", matrix_layout, m, n, nb, a, lda, t, ldt);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, nb, a, lda, t, ldt);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sgeqrt2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_sgeqrt2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sgeqrt2(int matrix_layout, int m, int n, float *a, int lda, float *t, int ldt)
     * }
     */
    public static FunctionDescriptor LAPACKE_sgeqrt2$descriptor() {
        return LAPACKE_sgeqrt2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sgeqrt2(int matrix_layout, int m, int n, float *a, int lda, float *t, int ldt)
     * }
     */
    public static MethodHandle LAPACKE_sgeqrt2$handle() {
        return LAPACKE_sgeqrt2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sgeqrt2(int matrix_layout, int m, int n, float *a, int lda, float *t, int ldt)
     * }
     */
    public static MemorySegment LAPACKE_sgeqrt2$address() {
        return LAPACKE_sgeqrt2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sgeqrt2(int matrix_layout, int m, int n, float *a, int lda, float *t, int ldt)
     * }
     */
    public static int LAPACKE_sgeqrt2(int matrix_layout, int m, int n, MemorySegment a, int lda, MemorySegment t, int ldt) {
        var mh$ = LAPACKE_sgeqrt2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sgeqrt2", matrix_layout, m, n, a, lda, t, ldt);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, a, lda, t, ldt);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dgeqrt2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dgeqrt2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dgeqrt2(int matrix_layout, int m, int n, double *a, int lda, double *t, int ldt)
     * }
     */
    public static FunctionDescriptor LAPACKE_dgeqrt2$descriptor() {
        return LAPACKE_dgeqrt2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dgeqrt2(int matrix_layout, int m, int n, double *a, int lda, double *t, int ldt)
     * }
     */
    public static MethodHandle LAPACKE_dgeqrt2$handle() {
        return LAPACKE_dgeqrt2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dgeqrt2(int matrix_layout, int m, int n, double *a, int lda, double *t, int ldt)
     * }
     */
    public static MemorySegment LAPACKE_dgeqrt2$address() {
        return LAPACKE_dgeqrt2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dgeqrt2(int matrix_layout, int m, int n, double *a, int lda, double *t, int ldt)
     * }
     */
    public static int LAPACKE_dgeqrt2(int matrix_layout, int m, int n, MemorySegment a, int lda, MemorySegment t, int ldt) {
        var mh$ = LAPACKE_dgeqrt2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dgeqrt2", matrix_layout, m, n, a, lda, t, ldt);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, a, lda, t, ldt);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cgeqrt2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_cgeqrt2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cgeqrt2(int matrix_layout, int m, int n, _Complex float *a, int lda, _Complex float *t, int ldt)
     * }
     */
    public static FunctionDescriptor LAPACKE_cgeqrt2$descriptor() {
        return LAPACKE_cgeqrt2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cgeqrt2(int matrix_layout, int m, int n, _Complex float *a, int lda, _Complex float *t, int ldt)
     * }
     */
    public static MethodHandle LAPACKE_cgeqrt2$handle() {
        return LAPACKE_cgeqrt2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cgeqrt2(int matrix_layout, int m, int n, _Complex float *a, int lda, _Complex float *t, int ldt)
     * }
     */
    public static MemorySegment LAPACKE_cgeqrt2$address() {
        return LAPACKE_cgeqrt2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cgeqrt2(int matrix_layout, int m, int n, _Complex float *a, int lda, _Complex float *t, int ldt)
     * }
     */
    public static int LAPACKE_cgeqrt2(int matrix_layout, int m, int n, MemorySegment a, int lda, MemorySegment t, int ldt) {
        var mh$ = LAPACKE_cgeqrt2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cgeqrt2", matrix_layout, m, n, a, lda, t, ldt);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, a, lda, t, ldt);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zgeqrt2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zgeqrt2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zgeqrt2(int matrix_layout, int m, int n, _Complex double *a, int lda, _Complex double *t, int ldt)
     * }
     */
    public static FunctionDescriptor LAPACKE_zgeqrt2$descriptor() {
        return LAPACKE_zgeqrt2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zgeqrt2(int matrix_layout, int m, int n, _Complex double *a, int lda, _Complex double *t, int ldt)
     * }
     */
    public static MethodHandle LAPACKE_zgeqrt2$handle() {
        return LAPACKE_zgeqrt2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zgeqrt2(int matrix_layout, int m, int n, _Complex double *a, int lda, _Complex double *t, int ldt)
     * }
     */
    public static MemorySegment LAPACKE_zgeqrt2$address() {
        return LAPACKE_zgeqrt2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zgeqrt2(int matrix_layout, int m, int n, _Complex double *a, int lda, _Complex double *t, int ldt)
     * }
     */
    public static int LAPACKE_zgeqrt2(int matrix_layout, int m, int n, MemorySegment a, int lda, MemorySegment t, int ldt) {
        var mh$ = LAPACKE_zgeqrt2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zgeqrt2", matrix_layout, m, n, a, lda, t, ldt);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, a, lda, t, ldt);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sgeqrt3 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_sgeqrt3");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sgeqrt3(int matrix_layout, int m, int n, float *a, int lda, float *t, int ldt)
     * }
     */
    public static FunctionDescriptor LAPACKE_sgeqrt3$descriptor() {
        return LAPACKE_sgeqrt3.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sgeqrt3(int matrix_layout, int m, int n, float *a, int lda, float *t, int ldt)
     * }
     */
    public static MethodHandle LAPACKE_sgeqrt3$handle() {
        return LAPACKE_sgeqrt3.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sgeqrt3(int matrix_layout, int m, int n, float *a, int lda, float *t, int ldt)
     * }
     */
    public static MemorySegment LAPACKE_sgeqrt3$address() {
        return LAPACKE_sgeqrt3.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sgeqrt3(int matrix_layout, int m, int n, float *a, int lda, float *t, int ldt)
     * }
     */
    public static int LAPACKE_sgeqrt3(int matrix_layout, int m, int n, MemorySegment a, int lda, MemorySegment t, int ldt) {
        var mh$ = LAPACKE_sgeqrt3.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sgeqrt3", matrix_layout, m, n, a, lda, t, ldt);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, a, lda, t, ldt);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dgeqrt3 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dgeqrt3");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dgeqrt3(int matrix_layout, int m, int n, double *a, int lda, double *t, int ldt)
     * }
     */
    public static FunctionDescriptor LAPACKE_dgeqrt3$descriptor() {
        return LAPACKE_dgeqrt3.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dgeqrt3(int matrix_layout, int m, int n, double *a, int lda, double *t, int ldt)
     * }
     */
    public static MethodHandle LAPACKE_dgeqrt3$handle() {
        return LAPACKE_dgeqrt3.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dgeqrt3(int matrix_layout, int m, int n, double *a, int lda, double *t, int ldt)
     * }
     */
    public static MemorySegment LAPACKE_dgeqrt3$address() {
        return LAPACKE_dgeqrt3.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dgeqrt3(int matrix_layout, int m, int n, double *a, int lda, double *t, int ldt)
     * }
     */
    public static int LAPACKE_dgeqrt3(int matrix_layout, int m, int n, MemorySegment a, int lda, MemorySegment t, int ldt) {
        var mh$ = LAPACKE_dgeqrt3.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dgeqrt3", matrix_layout, m, n, a, lda, t, ldt);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, a, lda, t, ldt);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cgeqrt3 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_cgeqrt3");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cgeqrt3(int matrix_layout, int m, int n, _Complex float *a, int lda, _Complex float *t, int ldt)
     * }
     */
    public static FunctionDescriptor LAPACKE_cgeqrt3$descriptor() {
        return LAPACKE_cgeqrt3.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cgeqrt3(int matrix_layout, int m, int n, _Complex float *a, int lda, _Complex float *t, int ldt)
     * }
     */
    public static MethodHandle LAPACKE_cgeqrt3$handle() {
        return LAPACKE_cgeqrt3.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cgeqrt3(int matrix_layout, int m, int n, _Complex float *a, int lda, _Complex float *t, int ldt)
     * }
     */
    public static MemorySegment LAPACKE_cgeqrt3$address() {
        return LAPACKE_cgeqrt3.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cgeqrt3(int matrix_layout, int m, int n, _Complex float *a, int lda, _Complex float *t, int ldt)
     * }
     */
    public static int LAPACKE_cgeqrt3(int matrix_layout, int m, int n, MemorySegment a, int lda, MemorySegment t, int ldt) {
        var mh$ = LAPACKE_cgeqrt3.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cgeqrt3", matrix_layout, m, n, a, lda, t, ldt);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, a, lda, t, ldt);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zgeqrt3 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zgeqrt3");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zgeqrt3(int matrix_layout, int m, int n, _Complex double *a, int lda, _Complex double *t, int ldt)
     * }
     */
    public static FunctionDescriptor LAPACKE_zgeqrt3$descriptor() {
        return LAPACKE_zgeqrt3.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zgeqrt3(int matrix_layout, int m, int n, _Complex double *a, int lda, _Complex double *t, int ldt)
     * }
     */
    public static MethodHandle LAPACKE_zgeqrt3$handle() {
        return LAPACKE_zgeqrt3.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zgeqrt3(int matrix_layout, int m, int n, _Complex double *a, int lda, _Complex double *t, int ldt)
     * }
     */
    public static MemorySegment LAPACKE_zgeqrt3$address() {
        return LAPACKE_zgeqrt3.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zgeqrt3(int matrix_layout, int m, int n, _Complex double *a, int lda, _Complex double *t, int ldt)
     * }
     */
    public static int LAPACKE_zgeqrt3(int matrix_layout, int m, int n, MemorySegment a, int lda, MemorySegment t, int ldt) {
        var mh$ = LAPACKE_zgeqrt3.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zgeqrt3", matrix_layout, m, n, a, lda, t, ldt);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, a, lda, t, ldt);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_stpmqrt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_stpmqrt");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_stpmqrt(int matrix_layout, char side, char trans, int m, int n, int k, int l, int nb, const float *v, int ldv, const float *t, int ldt, float *a, int lda, float *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_stpmqrt$descriptor() {
        return LAPACKE_stpmqrt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_stpmqrt(int matrix_layout, char side, char trans, int m, int n, int k, int l, int nb, const float *v, int ldv, const float *t, int ldt, float *a, int lda, float *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_stpmqrt$handle() {
        return LAPACKE_stpmqrt.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_stpmqrt(int matrix_layout, char side, char trans, int m, int n, int k, int l, int nb, const float *v, int ldv, const float *t, int ldt, float *a, int lda, float *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_stpmqrt$address() {
        return LAPACKE_stpmqrt.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_stpmqrt(int matrix_layout, char side, char trans, int m, int n, int k, int l, int nb, const float *v, int ldv, const float *t, int ldt, float *a, int lda, float *b, int ldb)
     * }
     */
    public static int LAPACKE_stpmqrt(int matrix_layout, byte side, byte trans, int m, int n, int k, int l, int nb, MemorySegment v, int ldv, MemorySegment t, int ldt, MemorySegment a, int lda, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_stpmqrt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_stpmqrt", matrix_layout, side, trans, m, n, k, l, nb, v, ldv, t, ldt, a, lda, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, side, trans, m, n, k, l, nb, v, ldv, t, ldt, a, lda, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dtpmqrt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dtpmqrt");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dtpmqrt(int matrix_layout, char side, char trans, int m, int n, int k, int l, int nb, const double *v, int ldv, const double *t, int ldt, double *a, int lda, double *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_dtpmqrt$descriptor() {
        return LAPACKE_dtpmqrt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dtpmqrt(int matrix_layout, char side, char trans, int m, int n, int k, int l, int nb, const double *v, int ldv, const double *t, int ldt, double *a, int lda, double *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_dtpmqrt$handle() {
        return LAPACKE_dtpmqrt.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dtpmqrt(int matrix_layout, char side, char trans, int m, int n, int k, int l, int nb, const double *v, int ldv, const double *t, int ldt, double *a, int lda, double *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_dtpmqrt$address() {
        return LAPACKE_dtpmqrt.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dtpmqrt(int matrix_layout, char side, char trans, int m, int n, int k, int l, int nb, const double *v, int ldv, const double *t, int ldt, double *a, int lda, double *b, int ldb)
     * }
     */
    public static int LAPACKE_dtpmqrt(int matrix_layout, byte side, byte trans, int m, int n, int k, int l, int nb, MemorySegment v, int ldv, MemorySegment t, int ldt, MemorySegment a, int lda, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_dtpmqrt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dtpmqrt", matrix_layout, side, trans, m, n, k, l, nb, v, ldv, t, ldt, a, lda, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, side, trans, m, n, k, l, nb, v, ldv, t, ldt, a, lda, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ctpmqrt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_ctpmqrt");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ctpmqrt(int matrix_layout, char side, char trans, int m, int n, int k, int l, int nb, const _Complex float *v, int ldv, const _Complex float *t, int ldt, _Complex float *a, int lda, _Complex float *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_ctpmqrt$descriptor() {
        return LAPACKE_ctpmqrt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ctpmqrt(int matrix_layout, char side, char trans, int m, int n, int k, int l, int nb, const _Complex float *v, int ldv, const _Complex float *t, int ldt, _Complex float *a, int lda, _Complex float *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_ctpmqrt$handle() {
        return LAPACKE_ctpmqrt.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ctpmqrt(int matrix_layout, char side, char trans, int m, int n, int k, int l, int nb, const _Complex float *v, int ldv, const _Complex float *t, int ldt, _Complex float *a, int lda, _Complex float *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_ctpmqrt$address() {
        return LAPACKE_ctpmqrt.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ctpmqrt(int matrix_layout, char side, char trans, int m, int n, int k, int l, int nb, const _Complex float *v, int ldv, const _Complex float *t, int ldt, _Complex float *a, int lda, _Complex float *b, int ldb)
     * }
     */
    public static int LAPACKE_ctpmqrt(int matrix_layout, byte side, byte trans, int m, int n, int k, int l, int nb, MemorySegment v, int ldv, MemorySegment t, int ldt, MemorySegment a, int lda, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_ctpmqrt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ctpmqrt", matrix_layout, side, trans, m, n, k, l, nb, v, ldv, t, ldt, a, lda, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, side, trans, m, n, k, l, nb, v, ldv, t, ldt, a, lda, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ztpmqrt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_ztpmqrt");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ztpmqrt(int matrix_layout, char side, char trans, int m, int n, int k, int l, int nb, const _Complex double *v, int ldv, const _Complex double *t, int ldt, _Complex double *a, int lda, _Complex double *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_ztpmqrt$descriptor() {
        return LAPACKE_ztpmqrt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ztpmqrt(int matrix_layout, char side, char trans, int m, int n, int k, int l, int nb, const _Complex double *v, int ldv, const _Complex double *t, int ldt, _Complex double *a, int lda, _Complex double *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_ztpmqrt$handle() {
        return LAPACKE_ztpmqrt.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ztpmqrt(int matrix_layout, char side, char trans, int m, int n, int k, int l, int nb, const _Complex double *v, int ldv, const _Complex double *t, int ldt, _Complex double *a, int lda, _Complex double *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_ztpmqrt$address() {
        return LAPACKE_ztpmqrt.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ztpmqrt(int matrix_layout, char side, char trans, int m, int n, int k, int l, int nb, const _Complex double *v, int ldv, const _Complex double *t, int ldt, _Complex double *a, int lda, _Complex double *b, int ldb)
     * }
     */
    public static int LAPACKE_ztpmqrt(int matrix_layout, byte side, byte trans, int m, int n, int k, int l, int nb, MemorySegment v, int ldv, MemorySegment t, int ldt, MemorySegment a, int lda, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_ztpmqrt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ztpmqrt", matrix_layout, side, trans, m, n, k, l, nb, v, ldv, t, ldt, a, lda, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, side, trans, m, n, k, l, nb, v, ldv, t, ldt, a, lda, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_stpqrt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_stpqrt");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_stpqrt(int matrix_layout, int m, int n, int l, int nb, float *a, int lda, float *b, int ldb, float *t, int ldt)
     * }
     */
    public static FunctionDescriptor LAPACKE_stpqrt$descriptor() {
        return LAPACKE_stpqrt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_stpqrt(int matrix_layout, int m, int n, int l, int nb, float *a, int lda, float *b, int ldb, float *t, int ldt)
     * }
     */
    public static MethodHandle LAPACKE_stpqrt$handle() {
        return LAPACKE_stpqrt.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_stpqrt(int matrix_layout, int m, int n, int l, int nb, float *a, int lda, float *b, int ldb, float *t, int ldt)
     * }
     */
    public static MemorySegment LAPACKE_stpqrt$address() {
        return LAPACKE_stpqrt.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_stpqrt(int matrix_layout, int m, int n, int l, int nb, float *a, int lda, float *b, int ldb, float *t, int ldt)
     * }
     */
    public static int LAPACKE_stpqrt(int matrix_layout, int m, int n, int l, int nb, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment t, int ldt) {
        var mh$ = LAPACKE_stpqrt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_stpqrt", matrix_layout, m, n, l, nb, a, lda, b, ldb, t, ldt);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, l, nb, a, lda, b, ldb, t, ldt);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dtpqrt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dtpqrt");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dtpqrt(int matrix_layout, int m, int n, int l, int nb, double *a, int lda, double *b, int ldb, double *t, int ldt)
     * }
     */
    public static FunctionDescriptor LAPACKE_dtpqrt$descriptor() {
        return LAPACKE_dtpqrt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dtpqrt(int matrix_layout, int m, int n, int l, int nb, double *a, int lda, double *b, int ldb, double *t, int ldt)
     * }
     */
    public static MethodHandle LAPACKE_dtpqrt$handle() {
        return LAPACKE_dtpqrt.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dtpqrt(int matrix_layout, int m, int n, int l, int nb, double *a, int lda, double *b, int ldb, double *t, int ldt)
     * }
     */
    public static MemorySegment LAPACKE_dtpqrt$address() {
        return LAPACKE_dtpqrt.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dtpqrt(int matrix_layout, int m, int n, int l, int nb, double *a, int lda, double *b, int ldb, double *t, int ldt)
     * }
     */
    public static int LAPACKE_dtpqrt(int matrix_layout, int m, int n, int l, int nb, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment t, int ldt) {
        var mh$ = LAPACKE_dtpqrt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dtpqrt", matrix_layout, m, n, l, nb, a, lda, b, ldb, t, ldt);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, l, nb, a, lda, b, ldb, t, ldt);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ctpqrt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_ctpqrt");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ctpqrt(int matrix_layout, int m, int n, int l, int nb, _Complex float *a, int lda, _Complex float *b, int ldb, _Complex float *t, int ldt)
     * }
     */
    public static FunctionDescriptor LAPACKE_ctpqrt$descriptor() {
        return LAPACKE_ctpqrt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ctpqrt(int matrix_layout, int m, int n, int l, int nb, _Complex float *a, int lda, _Complex float *b, int ldb, _Complex float *t, int ldt)
     * }
     */
    public static MethodHandle LAPACKE_ctpqrt$handle() {
        return LAPACKE_ctpqrt.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ctpqrt(int matrix_layout, int m, int n, int l, int nb, _Complex float *a, int lda, _Complex float *b, int ldb, _Complex float *t, int ldt)
     * }
     */
    public static MemorySegment LAPACKE_ctpqrt$address() {
        return LAPACKE_ctpqrt.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ctpqrt(int matrix_layout, int m, int n, int l, int nb, _Complex float *a, int lda, _Complex float *b, int ldb, _Complex float *t, int ldt)
     * }
     */
    public static int LAPACKE_ctpqrt(int matrix_layout, int m, int n, int l, int nb, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment t, int ldt) {
        var mh$ = LAPACKE_ctpqrt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ctpqrt", matrix_layout, m, n, l, nb, a, lda, b, ldb, t, ldt);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, l, nb, a, lda, b, ldb, t, ldt);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ztpqrt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_ztpqrt");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ztpqrt(int matrix_layout, int m, int n, int l, int nb, _Complex double *a, int lda, _Complex double *b, int ldb, _Complex double *t, int ldt)
     * }
     */
    public static FunctionDescriptor LAPACKE_ztpqrt$descriptor() {
        return LAPACKE_ztpqrt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ztpqrt(int matrix_layout, int m, int n, int l, int nb, _Complex double *a, int lda, _Complex double *b, int ldb, _Complex double *t, int ldt)
     * }
     */
    public static MethodHandle LAPACKE_ztpqrt$handle() {
        return LAPACKE_ztpqrt.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ztpqrt(int matrix_layout, int m, int n, int l, int nb, _Complex double *a, int lda, _Complex double *b, int ldb, _Complex double *t, int ldt)
     * }
     */
    public static MemorySegment LAPACKE_ztpqrt$address() {
        return LAPACKE_ztpqrt.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ztpqrt(int matrix_layout, int m, int n, int l, int nb, _Complex double *a, int lda, _Complex double *b, int ldb, _Complex double *t, int ldt)
     * }
     */
    public static int LAPACKE_ztpqrt(int matrix_layout, int m, int n, int l, int nb, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment t, int ldt) {
        var mh$ = LAPACKE_ztpqrt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ztpqrt", matrix_layout, m, n, l, nb, a, lda, b, ldb, t, ldt);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, l, nb, a, lda, b, ldb, t, ldt);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_stpqrt2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_stpqrt2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_stpqrt2(int matrix_layout, int m, int n, int l, float *a, int lda, float *b, int ldb, float *t, int ldt)
     * }
     */
    public static FunctionDescriptor LAPACKE_stpqrt2$descriptor() {
        return LAPACKE_stpqrt2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_stpqrt2(int matrix_layout, int m, int n, int l, float *a, int lda, float *b, int ldb, float *t, int ldt)
     * }
     */
    public static MethodHandle LAPACKE_stpqrt2$handle() {
        return LAPACKE_stpqrt2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_stpqrt2(int matrix_layout, int m, int n, int l, float *a, int lda, float *b, int ldb, float *t, int ldt)
     * }
     */
    public static MemorySegment LAPACKE_stpqrt2$address() {
        return LAPACKE_stpqrt2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_stpqrt2(int matrix_layout, int m, int n, int l, float *a, int lda, float *b, int ldb, float *t, int ldt)
     * }
     */
    public static int LAPACKE_stpqrt2(int matrix_layout, int m, int n, int l, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment t, int ldt) {
        var mh$ = LAPACKE_stpqrt2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_stpqrt2", matrix_layout, m, n, l, a, lda, b, ldb, t, ldt);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, l, a, lda, b, ldb, t, ldt);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dtpqrt2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dtpqrt2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dtpqrt2(int matrix_layout, int m, int n, int l, double *a, int lda, double *b, int ldb, double *t, int ldt)
     * }
     */
    public static FunctionDescriptor LAPACKE_dtpqrt2$descriptor() {
        return LAPACKE_dtpqrt2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dtpqrt2(int matrix_layout, int m, int n, int l, double *a, int lda, double *b, int ldb, double *t, int ldt)
     * }
     */
    public static MethodHandle LAPACKE_dtpqrt2$handle() {
        return LAPACKE_dtpqrt2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dtpqrt2(int matrix_layout, int m, int n, int l, double *a, int lda, double *b, int ldb, double *t, int ldt)
     * }
     */
    public static MemorySegment LAPACKE_dtpqrt2$address() {
        return LAPACKE_dtpqrt2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dtpqrt2(int matrix_layout, int m, int n, int l, double *a, int lda, double *b, int ldb, double *t, int ldt)
     * }
     */
    public static int LAPACKE_dtpqrt2(int matrix_layout, int m, int n, int l, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment t, int ldt) {
        var mh$ = LAPACKE_dtpqrt2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dtpqrt2", matrix_layout, m, n, l, a, lda, b, ldb, t, ldt);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, l, a, lda, b, ldb, t, ldt);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ctpqrt2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_ctpqrt2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ctpqrt2(int matrix_layout, int m, int n, int l, _Complex float *a, int lda, _Complex float *b, int ldb, _Complex float *t, int ldt)
     * }
     */
    public static FunctionDescriptor LAPACKE_ctpqrt2$descriptor() {
        return LAPACKE_ctpqrt2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ctpqrt2(int matrix_layout, int m, int n, int l, _Complex float *a, int lda, _Complex float *b, int ldb, _Complex float *t, int ldt)
     * }
     */
    public static MethodHandle LAPACKE_ctpqrt2$handle() {
        return LAPACKE_ctpqrt2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ctpqrt2(int matrix_layout, int m, int n, int l, _Complex float *a, int lda, _Complex float *b, int ldb, _Complex float *t, int ldt)
     * }
     */
    public static MemorySegment LAPACKE_ctpqrt2$address() {
        return LAPACKE_ctpqrt2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ctpqrt2(int matrix_layout, int m, int n, int l, _Complex float *a, int lda, _Complex float *b, int ldb, _Complex float *t, int ldt)
     * }
     */
    public static int LAPACKE_ctpqrt2(int matrix_layout, int m, int n, int l, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment t, int ldt) {
        var mh$ = LAPACKE_ctpqrt2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ctpqrt2", matrix_layout, m, n, l, a, lda, b, ldb, t, ldt);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, l, a, lda, b, ldb, t, ldt);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ztpqrt2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_ztpqrt2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ztpqrt2(int matrix_layout, int m, int n, int l, _Complex double *a, int lda, _Complex double *b, int ldb, _Complex double *t, int ldt)
     * }
     */
    public static FunctionDescriptor LAPACKE_ztpqrt2$descriptor() {
        return LAPACKE_ztpqrt2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ztpqrt2(int matrix_layout, int m, int n, int l, _Complex double *a, int lda, _Complex double *b, int ldb, _Complex double *t, int ldt)
     * }
     */
    public static MethodHandle LAPACKE_ztpqrt2$handle() {
        return LAPACKE_ztpqrt2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ztpqrt2(int matrix_layout, int m, int n, int l, _Complex double *a, int lda, _Complex double *b, int ldb, _Complex double *t, int ldt)
     * }
     */
    public static MemorySegment LAPACKE_ztpqrt2$address() {
        return LAPACKE_ztpqrt2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ztpqrt2(int matrix_layout, int m, int n, int l, _Complex double *a, int lda, _Complex double *b, int ldb, _Complex double *t, int ldt)
     * }
     */
    public static int LAPACKE_ztpqrt2(int matrix_layout, int m, int n, int l, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment t, int ldt) {
        var mh$ = LAPACKE_ztpqrt2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ztpqrt2", matrix_layout, m, n, l, a, lda, b, ldb, t, ldt);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, l, a, lda, b, ldb, t, ldt);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_stprfb {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_stprfb");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_stprfb(int matrix_layout, char side, char trans, char direct, char storev, int m, int n, int k, int l, const float *v, int ldv, const float *t, int ldt, float *a, int lda, float *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_stprfb$descriptor() {
        return LAPACKE_stprfb.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_stprfb(int matrix_layout, char side, char trans, char direct, char storev, int m, int n, int k, int l, const float *v, int ldv, const float *t, int ldt, float *a, int lda, float *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_stprfb$handle() {
        return LAPACKE_stprfb.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_stprfb(int matrix_layout, char side, char trans, char direct, char storev, int m, int n, int k, int l, const float *v, int ldv, const float *t, int ldt, float *a, int lda, float *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_stprfb$address() {
        return LAPACKE_stprfb.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_stprfb(int matrix_layout, char side, char trans, char direct, char storev, int m, int n, int k, int l, const float *v, int ldv, const float *t, int ldt, float *a, int lda, float *b, int ldb)
     * }
     */
    public static int LAPACKE_stprfb(int matrix_layout, byte side, byte trans, byte direct, byte storev, int m, int n, int k, int l, MemorySegment v, int ldv, MemorySegment t, int ldt, MemorySegment a, int lda, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_stprfb.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_stprfb", matrix_layout, side, trans, direct, storev, m, n, k, l, v, ldv, t, ldt, a, lda, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, side, trans, direct, storev, m, n, k, l, v, ldv, t, ldt, a, lda, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dtprfb {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dtprfb");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dtprfb(int matrix_layout, char side, char trans, char direct, char storev, int m, int n, int k, int l, const double *v, int ldv, const double *t, int ldt, double *a, int lda, double *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_dtprfb$descriptor() {
        return LAPACKE_dtprfb.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dtprfb(int matrix_layout, char side, char trans, char direct, char storev, int m, int n, int k, int l, const double *v, int ldv, const double *t, int ldt, double *a, int lda, double *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_dtprfb$handle() {
        return LAPACKE_dtprfb.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dtprfb(int matrix_layout, char side, char trans, char direct, char storev, int m, int n, int k, int l, const double *v, int ldv, const double *t, int ldt, double *a, int lda, double *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_dtprfb$address() {
        return LAPACKE_dtprfb.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dtprfb(int matrix_layout, char side, char trans, char direct, char storev, int m, int n, int k, int l, const double *v, int ldv, const double *t, int ldt, double *a, int lda, double *b, int ldb)
     * }
     */
    public static int LAPACKE_dtprfb(int matrix_layout, byte side, byte trans, byte direct, byte storev, int m, int n, int k, int l, MemorySegment v, int ldv, MemorySegment t, int ldt, MemorySegment a, int lda, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_dtprfb.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dtprfb", matrix_layout, side, trans, direct, storev, m, n, k, l, v, ldv, t, ldt, a, lda, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, side, trans, direct, storev, m, n, k, l, v, ldv, t, ldt, a, lda, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ctprfb {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_ctprfb");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ctprfb(int matrix_layout, char side, char trans, char direct, char storev, int m, int n, int k, int l, const _Complex float *v, int ldv, const _Complex float *t, int ldt, _Complex float *a, int lda, _Complex float *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_ctprfb$descriptor() {
        return LAPACKE_ctprfb.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ctprfb(int matrix_layout, char side, char trans, char direct, char storev, int m, int n, int k, int l, const _Complex float *v, int ldv, const _Complex float *t, int ldt, _Complex float *a, int lda, _Complex float *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_ctprfb$handle() {
        return LAPACKE_ctprfb.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ctprfb(int matrix_layout, char side, char trans, char direct, char storev, int m, int n, int k, int l, const _Complex float *v, int ldv, const _Complex float *t, int ldt, _Complex float *a, int lda, _Complex float *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_ctprfb$address() {
        return LAPACKE_ctprfb.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ctprfb(int matrix_layout, char side, char trans, char direct, char storev, int m, int n, int k, int l, const _Complex float *v, int ldv, const _Complex float *t, int ldt, _Complex float *a, int lda, _Complex float *b, int ldb)
     * }
     */
    public static int LAPACKE_ctprfb(int matrix_layout, byte side, byte trans, byte direct, byte storev, int m, int n, int k, int l, MemorySegment v, int ldv, MemorySegment t, int ldt, MemorySegment a, int lda, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_ctprfb.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ctprfb", matrix_layout, side, trans, direct, storev, m, n, k, l, v, ldv, t, ldt, a, lda, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, side, trans, direct, storev, m, n, k, l, v, ldv, t, ldt, a, lda, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ztprfb {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_ztprfb");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ztprfb(int matrix_layout, char side, char trans, char direct, char storev, int m, int n, int k, int l, const _Complex double *v, int ldv, const _Complex double *t, int ldt, _Complex double *a, int lda, _Complex double *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_ztprfb$descriptor() {
        return LAPACKE_ztprfb.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ztprfb(int matrix_layout, char side, char trans, char direct, char storev, int m, int n, int k, int l, const _Complex double *v, int ldv, const _Complex double *t, int ldt, _Complex double *a, int lda, _Complex double *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_ztprfb$handle() {
        return LAPACKE_ztprfb.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ztprfb(int matrix_layout, char side, char trans, char direct, char storev, int m, int n, int k, int l, const _Complex double *v, int ldv, const _Complex double *t, int ldt, _Complex double *a, int lda, _Complex double *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_ztprfb$address() {
        return LAPACKE_ztprfb.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ztprfb(int matrix_layout, char side, char trans, char direct, char storev, int m, int n, int k, int l, const _Complex double *v, int ldv, const _Complex double *t, int ldt, _Complex double *a, int lda, _Complex double *b, int ldb)
     * }
     */
    public static int LAPACKE_ztprfb(int matrix_layout, byte side, byte trans, byte direct, byte storev, int m, int n, int k, int l, MemorySegment v, int ldv, MemorySegment t, int ldt, MemorySegment a, int lda, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_ztprfb.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ztprfb", matrix_layout, side, trans, direct, storev, m, n, k, l, v, ldv, t, ldt, a, lda, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, side, trans, direct, storev, m, n, k, l, v, ldv, t, ldt, a, lda, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sgemqrt_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_sgemqrt_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sgemqrt_work(int matrix_layout, char side, char trans, int m, int n, int k, int nb, const float *v, int ldv, const float *t, int ldt, float *c, int ldc, float *work)
     * }
     */
    public static FunctionDescriptor LAPACKE_sgemqrt_work$descriptor() {
        return LAPACKE_sgemqrt_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sgemqrt_work(int matrix_layout, char side, char trans, int m, int n, int k, int nb, const float *v, int ldv, const float *t, int ldt, float *c, int ldc, float *work)
     * }
     */
    public static MethodHandle LAPACKE_sgemqrt_work$handle() {
        return LAPACKE_sgemqrt_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sgemqrt_work(int matrix_layout, char side, char trans, int m, int n, int k, int nb, const float *v, int ldv, const float *t, int ldt, float *c, int ldc, float *work)
     * }
     */
    public static MemorySegment LAPACKE_sgemqrt_work$address() {
        return LAPACKE_sgemqrt_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sgemqrt_work(int matrix_layout, char side, char trans, int m, int n, int k, int nb, const float *v, int ldv, const float *t, int ldt, float *c, int ldc, float *work)
     * }
     */
    public static int LAPACKE_sgemqrt_work(int matrix_layout, byte side, byte trans, int m, int n, int k, int nb, MemorySegment v, int ldv, MemorySegment t, int ldt, MemorySegment c, int ldc, MemorySegment work) {
        var mh$ = LAPACKE_sgemqrt_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sgemqrt_work", matrix_layout, side, trans, m, n, k, nb, v, ldv, t, ldt, c, ldc, work);
            }
            return (int)mh$.invokeExact(matrix_layout, side, trans, m, n, k, nb, v, ldv, t, ldt, c, ldc, work);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dgemqrt_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dgemqrt_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dgemqrt_work(int matrix_layout, char side, char trans, int m, int n, int k, int nb, const double *v, int ldv, const double *t, int ldt, double *c, int ldc, double *work)
     * }
     */
    public static FunctionDescriptor LAPACKE_dgemqrt_work$descriptor() {
        return LAPACKE_dgemqrt_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dgemqrt_work(int matrix_layout, char side, char trans, int m, int n, int k, int nb, const double *v, int ldv, const double *t, int ldt, double *c, int ldc, double *work)
     * }
     */
    public static MethodHandle LAPACKE_dgemqrt_work$handle() {
        return LAPACKE_dgemqrt_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dgemqrt_work(int matrix_layout, char side, char trans, int m, int n, int k, int nb, const double *v, int ldv, const double *t, int ldt, double *c, int ldc, double *work)
     * }
     */
    public static MemorySegment LAPACKE_dgemqrt_work$address() {
        return LAPACKE_dgemqrt_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dgemqrt_work(int matrix_layout, char side, char trans, int m, int n, int k, int nb, const double *v, int ldv, const double *t, int ldt, double *c, int ldc, double *work)
     * }
     */
    public static int LAPACKE_dgemqrt_work(int matrix_layout, byte side, byte trans, int m, int n, int k, int nb, MemorySegment v, int ldv, MemorySegment t, int ldt, MemorySegment c, int ldc, MemorySegment work) {
        var mh$ = LAPACKE_dgemqrt_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dgemqrt_work", matrix_layout, side, trans, m, n, k, nb, v, ldv, t, ldt, c, ldc, work);
            }
            return (int)mh$.invokeExact(matrix_layout, side, trans, m, n, k, nb, v, ldv, t, ldt, c, ldc, work);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cgemqrt_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_cgemqrt_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cgemqrt_work(int matrix_layout, char side, char trans, int m, int n, int k, int nb, const _Complex float *v, int ldv, const _Complex float *t, int ldt, _Complex float *c, int ldc, _Complex float *work)
     * }
     */
    public static FunctionDescriptor LAPACKE_cgemqrt_work$descriptor() {
        return LAPACKE_cgemqrt_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cgemqrt_work(int matrix_layout, char side, char trans, int m, int n, int k, int nb, const _Complex float *v, int ldv, const _Complex float *t, int ldt, _Complex float *c, int ldc, _Complex float *work)
     * }
     */
    public static MethodHandle LAPACKE_cgemqrt_work$handle() {
        return LAPACKE_cgemqrt_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cgemqrt_work(int matrix_layout, char side, char trans, int m, int n, int k, int nb, const _Complex float *v, int ldv, const _Complex float *t, int ldt, _Complex float *c, int ldc, _Complex float *work)
     * }
     */
    public static MemorySegment LAPACKE_cgemqrt_work$address() {
        return LAPACKE_cgemqrt_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cgemqrt_work(int matrix_layout, char side, char trans, int m, int n, int k, int nb, const _Complex float *v, int ldv, const _Complex float *t, int ldt, _Complex float *c, int ldc, _Complex float *work)
     * }
     */
    public static int LAPACKE_cgemqrt_work(int matrix_layout, byte side, byte trans, int m, int n, int k, int nb, MemorySegment v, int ldv, MemorySegment t, int ldt, MemorySegment c, int ldc, MemorySegment work) {
        var mh$ = LAPACKE_cgemqrt_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cgemqrt_work", matrix_layout, side, trans, m, n, k, nb, v, ldv, t, ldt, c, ldc, work);
            }
            return (int)mh$.invokeExact(matrix_layout, side, trans, m, n, k, nb, v, ldv, t, ldt, c, ldc, work);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zgemqrt_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zgemqrt_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zgemqrt_work(int matrix_layout, char side, char trans, int m, int n, int k, int nb, const _Complex double *v, int ldv, const _Complex double *t, int ldt, _Complex double *c, int ldc, _Complex double *work)
     * }
     */
    public static FunctionDescriptor LAPACKE_zgemqrt_work$descriptor() {
        return LAPACKE_zgemqrt_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zgemqrt_work(int matrix_layout, char side, char trans, int m, int n, int k, int nb, const _Complex double *v, int ldv, const _Complex double *t, int ldt, _Complex double *c, int ldc, _Complex double *work)
     * }
     */
    public static MethodHandle LAPACKE_zgemqrt_work$handle() {
        return LAPACKE_zgemqrt_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zgemqrt_work(int matrix_layout, char side, char trans, int m, int n, int k, int nb, const _Complex double *v, int ldv, const _Complex double *t, int ldt, _Complex double *c, int ldc, _Complex double *work)
     * }
     */
    public static MemorySegment LAPACKE_zgemqrt_work$address() {
        return LAPACKE_zgemqrt_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zgemqrt_work(int matrix_layout, char side, char trans, int m, int n, int k, int nb, const _Complex double *v, int ldv, const _Complex double *t, int ldt, _Complex double *c, int ldc, _Complex double *work)
     * }
     */
    public static int LAPACKE_zgemqrt_work(int matrix_layout, byte side, byte trans, int m, int n, int k, int nb, MemorySegment v, int ldv, MemorySegment t, int ldt, MemorySegment c, int ldc, MemorySegment work) {
        var mh$ = LAPACKE_zgemqrt_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zgemqrt_work", matrix_layout, side, trans, m, n, k, nb, v, ldv, t, ldt, c, ldc, work);
            }
            return (int)mh$.invokeExact(matrix_layout, side, trans, m, n, k, nb, v, ldv, t, ldt, c, ldc, work);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sgeqrt_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_sgeqrt_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sgeqrt_work(int matrix_layout, int m, int n, int nb, float *a, int lda, float *t, int ldt, float *work)
     * }
     */
    public static FunctionDescriptor LAPACKE_sgeqrt_work$descriptor() {
        return LAPACKE_sgeqrt_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sgeqrt_work(int matrix_layout, int m, int n, int nb, float *a, int lda, float *t, int ldt, float *work)
     * }
     */
    public static MethodHandle LAPACKE_sgeqrt_work$handle() {
        return LAPACKE_sgeqrt_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sgeqrt_work(int matrix_layout, int m, int n, int nb, float *a, int lda, float *t, int ldt, float *work)
     * }
     */
    public static MemorySegment LAPACKE_sgeqrt_work$address() {
        return LAPACKE_sgeqrt_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sgeqrt_work(int matrix_layout, int m, int n, int nb, float *a, int lda, float *t, int ldt, float *work)
     * }
     */
    public static int LAPACKE_sgeqrt_work(int matrix_layout, int m, int n, int nb, MemorySegment a, int lda, MemorySegment t, int ldt, MemorySegment work) {
        var mh$ = LAPACKE_sgeqrt_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sgeqrt_work", matrix_layout, m, n, nb, a, lda, t, ldt, work);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, nb, a, lda, t, ldt, work);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dgeqrt_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dgeqrt_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dgeqrt_work(int matrix_layout, int m, int n, int nb, double *a, int lda, double *t, int ldt, double *work)
     * }
     */
    public static FunctionDescriptor LAPACKE_dgeqrt_work$descriptor() {
        return LAPACKE_dgeqrt_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dgeqrt_work(int matrix_layout, int m, int n, int nb, double *a, int lda, double *t, int ldt, double *work)
     * }
     */
    public static MethodHandle LAPACKE_dgeqrt_work$handle() {
        return LAPACKE_dgeqrt_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dgeqrt_work(int matrix_layout, int m, int n, int nb, double *a, int lda, double *t, int ldt, double *work)
     * }
     */
    public static MemorySegment LAPACKE_dgeqrt_work$address() {
        return LAPACKE_dgeqrt_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dgeqrt_work(int matrix_layout, int m, int n, int nb, double *a, int lda, double *t, int ldt, double *work)
     * }
     */
    public static int LAPACKE_dgeqrt_work(int matrix_layout, int m, int n, int nb, MemorySegment a, int lda, MemorySegment t, int ldt, MemorySegment work) {
        var mh$ = LAPACKE_dgeqrt_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dgeqrt_work", matrix_layout, m, n, nb, a, lda, t, ldt, work);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, nb, a, lda, t, ldt, work);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cgeqrt_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_cgeqrt_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cgeqrt_work(int matrix_layout, int m, int n, int nb, _Complex float *a, int lda, _Complex float *t, int ldt, _Complex float *work)
     * }
     */
    public static FunctionDescriptor LAPACKE_cgeqrt_work$descriptor() {
        return LAPACKE_cgeqrt_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cgeqrt_work(int matrix_layout, int m, int n, int nb, _Complex float *a, int lda, _Complex float *t, int ldt, _Complex float *work)
     * }
     */
    public static MethodHandle LAPACKE_cgeqrt_work$handle() {
        return LAPACKE_cgeqrt_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cgeqrt_work(int matrix_layout, int m, int n, int nb, _Complex float *a, int lda, _Complex float *t, int ldt, _Complex float *work)
     * }
     */
    public static MemorySegment LAPACKE_cgeqrt_work$address() {
        return LAPACKE_cgeqrt_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cgeqrt_work(int matrix_layout, int m, int n, int nb, _Complex float *a, int lda, _Complex float *t, int ldt, _Complex float *work)
     * }
     */
    public static int LAPACKE_cgeqrt_work(int matrix_layout, int m, int n, int nb, MemorySegment a, int lda, MemorySegment t, int ldt, MemorySegment work) {
        var mh$ = LAPACKE_cgeqrt_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cgeqrt_work", matrix_layout, m, n, nb, a, lda, t, ldt, work);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, nb, a, lda, t, ldt, work);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zgeqrt_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zgeqrt_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zgeqrt_work(int matrix_layout, int m, int n, int nb, _Complex double *a, int lda, _Complex double *t, int ldt, _Complex double *work)
     * }
     */
    public static FunctionDescriptor LAPACKE_zgeqrt_work$descriptor() {
        return LAPACKE_zgeqrt_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zgeqrt_work(int matrix_layout, int m, int n, int nb, _Complex double *a, int lda, _Complex double *t, int ldt, _Complex double *work)
     * }
     */
    public static MethodHandle LAPACKE_zgeqrt_work$handle() {
        return LAPACKE_zgeqrt_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zgeqrt_work(int matrix_layout, int m, int n, int nb, _Complex double *a, int lda, _Complex double *t, int ldt, _Complex double *work)
     * }
     */
    public static MemorySegment LAPACKE_zgeqrt_work$address() {
        return LAPACKE_zgeqrt_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zgeqrt_work(int matrix_layout, int m, int n, int nb, _Complex double *a, int lda, _Complex double *t, int ldt, _Complex double *work)
     * }
     */
    public static int LAPACKE_zgeqrt_work(int matrix_layout, int m, int n, int nb, MemorySegment a, int lda, MemorySegment t, int ldt, MemorySegment work) {
        var mh$ = LAPACKE_zgeqrt_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zgeqrt_work", matrix_layout, m, n, nb, a, lda, t, ldt, work);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, nb, a, lda, t, ldt, work);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sgeqrt2_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_sgeqrt2_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sgeqrt2_work(int matrix_layout, int m, int n, float *a, int lda, float *t, int ldt)
     * }
     */
    public static FunctionDescriptor LAPACKE_sgeqrt2_work$descriptor() {
        return LAPACKE_sgeqrt2_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sgeqrt2_work(int matrix_layout, int m, int n, float *a, int lda, float *t, int ldt)
     * }
     */
    public static MethodHandle LAPACKE_sgeqrt2_work$handle() {
        return LAPACKE_sgeqrt2_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sgeqrt2_work(int matrix_layout, int m, int n, float *a, int lda, float *t, int ldt)
     * }
     */
    public static MemorySegment LAPACKE_sgeqrt2_work$address() {
        return LAPACKE_sgeqrt2_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sgeqrt2_work(int matrix_layout, int m, int n, float *a, int lda, float *t, int ldt)
     * }
     */
    public static int LAPACKE_sgeqrt2_work(int matrix_layout, int m, int n, MemorySegment a, int lda, MemorySegment t, int ldt) {
        var mh$ = LAPACKE_sgeqrt2_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sgeqrt2_work", matrix_layout, m, n, a, lda, t, ldt);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, a, lda, t, ldt);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dgeqrt2_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dgeqrt2_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dgeqrt2_work(int matrix_layout, int m, int n, double *a, int lda, double *t, int ldt)
     * }
     */
    public static FunctionDescriptor LAPACKE_dgeqrt2_work$descriptor() {
        return LAPACKE_dgeqrt2_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dgeqrt2_work(int matrix_layout, int m, int n, double *a, int lda, double *t, int ldt)
     * }
     */
    public static MethodHandle LAPACKE_dgeqrt2_work$handle() {
        return LAPACKE_dgeqrt2_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dgeqrt2_work(int matrix_layout, int m, int n, double *a, int lda, double *t, int ldt)
     * }
     */
    public static MemorySegment LAPACKE_dgeqrt2_work$address() {
        return LAPACKE_dgeqrt2_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dgeqrt2_work(int matrix_layout, int m, int n, double *a, int lda, double *t, int ldt)
     * }
     */
    public static int LAPACKE_dgeqrt2_work(int matrix_layout, int m, int n, MemorySegment a, int lda, MemorySegment t, int ldt) {
        var mh$ = LAPACKE_dgeqrt2_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dgeqrt2_work", matrix_layout, m, n, a, lda, t, ldt);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, a, lda, t, ldt);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cgeqrt2_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_cgeqrt2_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cgeqrt2_work(int matrix_layout, int m, int n, _Complex float *a, int lda, _Complex float *t, int ldt)
     * }
     */
    public static FunctionDescriptor LAPACKE_cgeqrt2_work$descriptor() {
        return LAPACKE_cgeqrt2_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cgeqrt2_work(int matrix_layout, int m, int n, _Complex float *a, int lda, _Complex float *t, int ldt)
     * }
     */
    public static MethodHandle LAPACKE_cgeqrt2_work$handle() {
        return LAPACKE_cgeqrt2_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cgeqrt2_work(int matrix_layout, int m, int n, _Complex float *a, int lda, _Complex float *t, int ldt)
     * }
     */
    public static MemorySegment LAPACKE_cgeqrt2_work$address() {
        return LAPACKE_cgeqrt2_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cgeqrt2_work(int matrix_layout, int m, int n, _Complex float *a, int lda, _Complex float *t, int ldt)
     * }
     */
    public static int LAPACKE_cgeqrt2_work(int matrix_layout, int m, int n, MemorySegment a, int lda, MemorySegment t, int ldt) {
        var mh$ = LAPACKE_cgeqrt2_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cgeqrt2_work", matrix_layout, m, n, a, lda, t, ldt);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, a, lda, t, ldt);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zgeqrt2_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zgeqrt2_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zgeqrt2_work(int matrix_layout, int m, int n, _Complex double *a, int lda, _Complex double *t, int ldt)
     * }
     */
    public static FunctionDescriptor LAPACKE_zgeqrt2_work$descriptor() {
        return LAPACKE_zgeqrt2_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zgeqrt2_work(int matrix_layout, int m, int n, _Complex double *a, int lda, _Complex double *t, int ldt)
     * }
     */
    public static MethodHandle LAPACKE_zgeqrt2_work$handle() {
        return LAPACKE_zgeqrt2_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zgeqrt2_work(int matrix_layout, int m, int n, _Complex double *a, int lda, _Complex double *t, int ldt)
     * }
     */
    public static MemorySegment LAPACKE_zgeqrt2_work$address() {
        return LAPACKE_zgeqrt2_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zgeqrt2_work(int matrix_layout, int m, int n, _Complex double *a, int lda, _Complex double *t, int ldt)
     * }
     */
    public static int LAPACKE_zgeqrt2_work(int matrix_layout, int m, int n, MemorySegment a, int lda, MemorySegment t, int ldt) {
        var mh$ = LAPACKE_zgeqrt2_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zgeqrt2_work", matrix_layout, m, n, a, lda, t, ldt);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, a, lda, t, ldt);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sgeqrt3_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_sgeqrt3_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sgeqrt3_work(int matrix_layout, int m, int n, float *a, int lda, float *t, int ldt)
     * }
     */
    public static FunctionDescriptor LAPACKE_sgeqrt3_work$descriptor() {
        return LAPACKE_sgeqrt3_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sgeqrt3_work(int matrix_layout, int m, int n, float *a, int lda, float *t, int ldt)
     * }
     */
    public static MethodHandle LAPACKE_sgeqrt3_work$handle() {
        return LAPACKE_sgeqrt3_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sgeqrt3_work(int matrix_layout, int m, int n, float *a, int lda, float *t, int ldt)
     * }
     */
    public static MemorySegment LAPACKE_sgeqrt3_work$address() {
        return LAPACKE_sgeqrt3_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sgeqrt3_work(int matrix_layout, int m, int n, float *a, int lda, float *t, int ldt)
     * }
     */
    public static int LAPACKE_sgeqrt3_work(int matrix_layout, int m, int n, MemorySegment a, int lda, MemorySegment t, int ldt) {
        var mh$ = LAPACKE_sgeqrt3_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sgeqrt3_work", matrix_layout, m, n, a, lda, t, ldt);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, a, lda, t, ldt);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dgeqrt3_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dgeqrt3_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dgeqrt3_work(int matrix_layout, int m, int n, double *a, int lda, double *t, int ldt)
     * }
     */
    public static FunctionDescriptor LAPACKE_dgeqrt3_work$descriptor() {
        return LAPACKE_dgeqrt3_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dgeqrt3_work(int matrix_layout, int m, int n, double *a, int lda, double *t, int ldt)
     * }
     */
    public static MethodHandle LAPACKE_dgeqrt3_work$handle() {
        return LAPACKE_dgeqrt3_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dgeqrt3_work(int matrix_layout, int m, int n, double *a, int lda, double *t, int ldt)
     * }
     */
    public static MemorySegment LAPACKE_dgeqrt3_work$address() {
        return LAPACKE_dgeqrt3_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dgeqrt3_work(int matrix_layout, int m, int n, double *a, int lda, double *t, int ldt)
     * }
     */
    public static int LAPACKE_dgeqrt3_work(int matrix_layout, int m, int n, MemorySegment a, int lda, MemorySegment t, int ldt) {
        var mh$ = LAPACKE_dgeqrt3_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dgeqrt3_work", matrix_layout, m, n, a, lda, t, ldt);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, a, lda, t, ldt);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cgeqrt3_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_cgeqrt3_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cgeqrt3_work(int matrix_layout, int m, int n, _Complex float *a, int lda, _Complex float *t, int ldt)
     * }
     */
    public static FunctionDescriptor LAPACKE_cgeqrt3_work$descriptor() {
        return LAPACKE_cgeqrt3_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cgeqrt3_work(int matrix_layout, int m, int n, _Complex float *a, int lda, _Complex float *t, int ldt)
     * }
     */
    public static MethodHandle LAPACKE_cgeqrt3_work$handle() {
        return LAPACKE_cgeqrt3_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cgeqrt3_work(int matrix_layout, int m, int n, _Complex float *a, int lda, _Complex float *t, int ldt)
     * }
     */
    public static MemorySegment LAPACKE_cgeqrt3_work$address() {
        return LAPACKE_cgeqrt3_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cgeqrt3_work(int matrix_layout, int m, int n, _Complex float *a, int lda, _Complex float *t, int ldt)
     * }
     */
    public static int LAPACKE_cgeqrt3_work(int matrix_layout, int m, int n, MemorySegment a, int lda, MemorySegment t, int ldt) {
        var mh$ = LAPACKE_cgeqrt3_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cgeqrt3_work", matrix_layout, m, n, a, lda, t, ldt);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, a, lda, t, ldt);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zgeqrt3_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zgeqrt3_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zgeqrt3_work(int matrix_layout, int m, int n, _Complex double *a, int lda, _Complex double *t, int ldt)
     * }
     */
    public static FunctionDescriptor LAPACKE_zgeqrt3_work$descriptor() {
        return LAPACKE_zgeqrt3_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zgeqrt3_work(int matrix_layout, int m, int n, _Complex double *a, int lda, _Complex double *t, int ldt)
     * }
     */
    public static MethodHandle LAPACKE_zgeqrt3_work$handle() {
        return LAPACKE_zgeqrt3_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zgeqrt3_work(int matrix_layout, int m, int n, _Complex double *a, int lda, _Complex double *t, int ldt)
     * }
     */
    public static MemorySegment LAPACKE_zgeqrt3_work$address() {
        return LAPACKE_zgeqrt3_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zgeqrt3_work(int matrix_layout, int m, int n, _Complex double *a, int lda, _Complex double *t, int ldt)
     * }
     */
    public static int LAPACKE_zgeqrt3_work(int matrix_layout, int m, int n, MemorySegment a, int lda, MemorySegment t, int ldt) {
        var mh$ = LAPACKE_zgeqrt3_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zgeqrt3_work", matrix_layout, m, n, a, lda, t, ldt);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, a, lda, t, ldt);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_stpmqrt_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_stpmqrt_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_stpmqrt_work(int matrix_layout, char side, char trans, int m, int n, int k, int l, int nb, const float *v, int ldv, const float *t, int ldt, float *a, int lda, float *b, int ldb, float *work)
     * }
     */
    public static FunctionDescriptor LAPACKE_stpmqrt_work$descriptor() {
        return LAPACKE_stpmqrt_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_stpmqrt_work(int matrix_layout, char side, char trans, int m, int n, int k, int l, int nb, const float *v, int ldv, const float *t, int ldt, float *a, int lda, float *b, int ldb, float *work)
     * }
     */
    public static MethodHandle LAPACKE_stpmqrt_work$handle() {
        return LAPACKE_stpmqrt_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_stpmqrt_work(int matrix_layout, char side, char trans, int m, int n, int k, int l, int nb, const float *v, int ldv, const float *t, int ldt, float *a, int lda, float *b, int ldb, float *work)
     * }
     */
    public static MemorySegment LAPACKE_stpmqrt_work$address() {
        return LAPACKE_stpmqrt_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_stpmqrt_work(int matrix_layout, char side, char trans, int m, int n, int k, int l, int nb, const float *v, int ldv, const float *t, int ldt, float *a, int lda, float *b, int ldb, float *work)
     * }
     */
    public static int LAPACKE_stpmqrt_work(int matrix_layout, byte side, byte trans, int m, int n, int k, int l, int nb, MemorySegment v, int ldv, MemorySegment t, int ldt, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment work) {
        var mh$ = LAPACKE_stpmqrt_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_stpmqrt_work", matrix_layout, side, trans, m, n, k, l, nb, v, ldv, t, ldt, a, lda, b, ldb, work);
            }
            return (int)mh$.invokeExact(matrix_layout, side, trans, m, n, k, l, nb, v, ldv, t, ldt, a, lda, b, ldb, work);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dtpmqrt_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dtpmqrt_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dtpmqrt_work(int matrix_layout, char side, char trans, int m, int n, int k, int l, int nb, const double *v, int ldv, const double *t, int ldt, double *a, int lda, double *b, int ldb, double *work)
     * }
     */
    public static FunctionDescriptor LAPACKE_dtpmqrt_work$descriptor() {
        return LAPACKE_dtpmqrt_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dtpmqrt_work(int matrix_layout, char side, char trans, int m, int n, int k, int l, int nb, const double *v, int ldv, const double *t, int ldt, double *a, int lda, double *b, int ldb, double *work)
     * }
     */
    public static MethodHandle LAPACKE_dtpmqrt_work$handle() {
        return LAPACKE_dtpmqrt_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dtpmqrt_work(int matrix_layout, char side, char trans, int m, int n, int k, int l, int nb, const double *v, int ldv, const double *t, int ldt, double *a, int lda, double *b, int ldb, double *work)
     * }
     */
    public static MemorySegment LAPACKE_dtpmqrt_work$address() {
        return LAPACKE_dtpmqrt_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dtpmqrt_work(int matrix_layout, char side, char trans, int m, int n, int k, int l, int nb, const double *v, int ldv, const double *t, int ldt, double *a, int lda, double *b, int ldb, double *work)
     * }
     */
    public static int LAPACKE_dtpmqrt_work(int matrix_layout, byte side, byte trans, int m, int n, int k, int l, int nb, MemorySegment v, int ldv, MemorySegment t, int ldt, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment work) {
        var mh$ = LAPACKE_dtpmqrt_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dtpmqrt_work", matrix_layout, side, trans, m, n, k, l, nb, v, ldv, t, ldt, a, lda, b, ldb, work);
            }
            return (int)mh$.invokeExact(matrix_layout, side, trans, m, n, k, l, nb, v, ldv, t, ldt, a, lda, b, ldb, work);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ctpmqrt_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_ctpmqrt_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ctpmqrt_work(int matrix_layout, char side, char trans, int m, int n, int k, int l, int nb, const _Complex float *v, int ldv, const _Complex float *t, int ldt, _Complex float *a, int lda, _Complex float *b, int ldb, _Complex float *work)
     * }
     */
    public static FunctionDescriptor LAPACKE_ctpmqrt_work$descriptor() {
        return LAPACKE_ctpmqrt_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ctpmqrt_work(int matrix_layout, char side, char trans, int m, int n, int k, int l, int nb, const _Complex float *v, int ldv, const _Complex float *t, int ldt, _Complex float *a, int lda, _Complex float *b, int ldb, _Complex float *work)
     * }
     */
    public static MethodHandle LAPACKE_ctpmqrt_work$handle() {
        return LAPACKE_ctpmqrt_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ctpmqrt_work(int matrix_layout, char side, char trans, int m, int n, int k, int l, int nb, const _Complex float *v, int ldv, const _Complex float *t, int ldt, _Complex float *a, int lda, _Complex float *b, int ldb, _Complex float *work)
     * }
     */
    public static MemorySegment LAPACKE_ctpmqrt_work$address() {
        return LAPACKE_ctpmqrt_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ctpmqrt_work(int matrix_layout, char side, char trans, int m, int n, int k, int l, int nb, const _Complex float *v, int ldv, const _Complex float *t, int ldt, _Complex float *a, int lda, _Complex float *b, int ldb, _Complex float *work)
     * }
     */
    public static int LAPACKE_ctpmqrt_work(int matrix_layout, byte side, byte trans, int m, int n, int k, int l, int nb, MemorySegment v, int ldv, MemorySegment t, int ldt, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment work) {
        var mh$ = LAPACKE_ctpmqrt_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ctpmqrt_work", matrix_layout, side, trans, m, n, k, l, nb, v, ldv, t, ldt, a, lda, b, ldb, work);
            }
            return (int)mh$.invokeExact(matrix_layout, side, trans, m, n, k, l, nb, v, ldv, t, ldt, a, lda, b, ldb, work);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ztpmqrt_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_ztpmqrt_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ztpmqrt_work(int matrix_layout, char side, char trans, int m, int n, int k, int l, int nb, const _Complex double *v, int ldv, const _Complex double *t, int ldt, _Complex double *a, int lda, _Complex double *b, int ldb, _Complex double *work)
     * }
     */
    public static FunctionDescriptor LAPACKE_ztpmqrt_work$descriptor() {
        return LAPACKE_ztpmqrt_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ztpmqrt_work(int matrix_layout, char side, char trans, int m, int n, int k, int l, int nb, const _Complex double *v, int ldv, const _Complex double *t, int ldt, _Complex double *a, int lda, _Complex double *b, int ldb, _Complex double *work)
     * }
     */
    public static MethodHandle LAPACKE_ztpmqrt_work$handle() {
        return LAPACKE_ztpmqrt_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ztpmqrt_work(int matrix_layout, char side, char trans, int m, int n, int k, int l, int nb, const _Complex double *v, int ldv, const _Complex double *t, int ldt, _Complex double *a, int lda, _Complex double *b, int ldb, _Complex double *work)
     * }
     */
    public static MemorySegment LAPACKE_ztpmqrt_work$address() {
        return LAPACKE_ztpmqrt_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ztpmqrt_work(int matrix_layout, char side, char trans, int m, int n, int k, int l, int nb, const _Complex double *v, int ldv, const _Complex double *t, int ldt, _Complex double *a, int lda, _Complex double *b, int ldb, _Complex double *work)
     * }
     */
    public static int LAPACKE_ztpmqrt_work(int matrix_layout, byte side, byte trans, int m, int n, int k, int l, int nb, MemorySegment v, int ldv, MemorySegment t, int ldt, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment work) {
        var mh$ = LAPACKE_ztpmqrt_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ztpmqrt_work", matrix_layout, side, trans, m, n, k, l, nb, v, ldv, t, ldt, a, lda, b, ldb, work);
            }
            return (int)mh$.invokeExact(matrix_layout, side, trans, m, n, k, l, nb, v, ldv, t, ldt, a, lda, b, ldb, work);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_stpqrt_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_stpqrt_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_stpqrt_work(int matrix_layout, int m, int n, int l, int nb, float *a, int lda, float *b, int ldb, float *t, int ldt, float *work)
     * }
     */
    public static FunctionDescriptor LAPACKE_stpqrt_work$descriptor() {
        return LAPACKE_stpqrt_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_stpqrt_work(int matrix_layout, int m, int n, int l, int nb, float *a, int lda, float *b, int ldb, float *t, int ldt, float *work)
     * }
     */
    public static MethodHandle LAPACKE_stpqrt_work$handle() {
        return LAPACKE_stpqrt_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_stpqrt_work(int matrix_layout, int m, int n, int l, int nb, float *a, int lda, float *b, int ldb, float *t, int ldt, float *work)
     * }
     */
    public static MemorySegment LAPACKE_stpqrt_work$address() {
        return LAPACKE_stpqrt_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_stpqrt_work(int matrix_layout, int m, int n, int l, int nb, float *a, int lda, float *b, int ldb, float *t, int ldt, float *work)
     * }
     */
    public static int LAPACKE_stpqrt_work(int matrix_layout, int m, int n, int l, int nb, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment t, int ldt, MemorySegment work) {
        var mh$ = LAPACKE_stpqrt_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_stpqrt_work", matrix_layout, m, n, l, nb, a, lda, b, ldb, t, ldt, work);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, l, nb, a, lda, b, ldb, t, ldt, work);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dtpqrt_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dtpqrt_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dtpqrt_work(int matrix_layout, int m, int n, int l, int nb, double *a, int lda, double *b, int ldb, double *t, int ldt, double *work)
     * }
     */
    public static FunctionDescriptor LAPACKE_dtpqrt_work$descriptor() {
        return LAPACKE_dtpqrt_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dtpqrt_work(int matrix_layout, int m, int n, int l, int nb, double *a, int lda, double *b, int ldb, double *t, int ldt, double *work)
     * }
     */
    public static MethodHandle LAPACKE_dtpqrt_work$handle() {
        return LAPACKE_dtpqrt_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dtpqrt_work(int matrix_layout, int m, int n, int l, int nb, double *a, int lda, double *b, int ldb, double *t, int ldt, double *work)
     * }
     */
    public static MemorySegment LAPACKE_dtpqrt_work$address() {
        return LAPACKE_dtpqrt_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dtpqrt_work(int matrix_layout, int m, int n, int l, int nb, double *a, int lda, double *b, int ldb, double *t, int ldt, double *work)
     * }
     */
    public static int LAPACKE_dtpqrt_work(int matrix_layout, int m, int n, int l, int nb, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment t, int ldt, MemorySegment work) {
        var mh$ = LAPACKE_dtpqrt_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dtpqrt_work", matrix_layout, m, n, l, nb, a, lda, b, ldb, t, ldt, work);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, l, nb, a, lda, b, ldb, t, ldt, work);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ctpqrt_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_ctpqrt_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ctpqrt_work(int matrix_layout, int m, int n, int l, int nb, _Complex float *a, int lda, _Complex float *b, int ldb, _Complex float *t, int ldt, _Complex float *work)
     * }
     */
    public static FunctionDescriptor LAPACKE_ctpqrt_work$descriptor() {
        return LAPACKE_ctpqrt_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ctpqrt_work(int matrix_layout, int m, int n, int l, int nb, _Complex float *a, int lda, _Complex float *b, int ldb, _Complex float *t, int ldt, _Complex float *work)
     * }
     */
    public static MethodHandle LAPACKE_ctpqrt_work$handle() {
        return LAPACKE_ctpqrt_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ctpqrt_work(int matrix_layout, int m, int n, int l, int nb, _Complex float *a, int lda, _Complex float *b, int ldb, _Complex float *t, int ldt, _Complex float *work)
     * }
     */
    public static MemorySegment LAPACKE_ctpqrt_work$address() {
        return LAPACKE_ctpqrt_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ctpqrt_work(int matrix_layout, int m, int n, int l, int nb, _Complex float *a, int lda, _Complex float *b, int ldb, _Complex float *t, int ldt, _Complex float *work)
     * }
     */
    public static int LAPACKE_ctpqrt_work(int matrix_layout, int m, int n, int l, int nb, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment t, int ldt, MemorySegment work) {
        var mh$ = LAPACKE_ctpqrt_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ctpqrt_work", matrix_layout, m, n, l, nb, a, lda, b, ldb, t, ldt, work);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, l, nb, a, lda, b, ldb, t, ldt, work);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ztpqrt_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_ztpqrt_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ztpqrt_work(int matrix_layout, int m, int n, int l, int nb, _Complex double *a, int lda, _Complex double *b, int ldb, _Complex double *t, int ldt, _Complex double *work)
     * }
     */
    public static FunctionDescriptor LAPACKE_ztpqrt_work$descriptor() {
        return LAPACKE_ztpqrt_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ztpqrt_work(int matrix_layout, int m, int n, int l, int nb, _Complex double *a, int lda, _Complex double *b, int ldb, _Complex double *t, int ldt, _Complex double *work)
     * }
     */
    public static MethodHandle LAPACKE_ztpqrt_work$handle() {
        return LAPACKE_ztpqrt_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ztpqrt_work(int matrix_layout, int m, int n, int l, int nb, _Complex double *a, int lda, _Complex double *b, int ldb, _Complex double *t, int ldt, _Complex double *work)
     * }
     */
    public static MemorySegment LAPACKE_ztpqrt_work$address() {
        return LAPACKE_ztpqrt_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ztpqrt_work(int matrix_layout, int m, int n, int l, int nb, _Complex double *a, int lda, _Complex double *b, int ldb, _Complex double *t, int ldt, _Complex double *work)
     * }
     */
    public static int LAPACKE_ztpqrt_work(int matrix_layout, int m, int n, int l, int nb, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment t, int ldt, MemorySegment work) {
        var mh$ = LAPACKE_ztpqrt_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ztpqrt_work", matrix_layout, m, n, l, nb, a, lda, b, ldb, t, ldt, work);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, l, nb, a, lda, b, ldb, t, ldt, work);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_stpqrt2_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_stpqrt2_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_stpqrt2_work(int matrix_layout, int m, int n, int l, float *a, int lda, float *b, int ldb, float *t, int ldt)
     * }
     */
    public static FunctionDescriptor LAPACKE_stpqrt2_work$descriptor() {
        return LAPACKE_stpqrt2_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_stpqrt2_work(int matrix_layout, int m, int n, int l, float *a, int lda, float *b, int ldb, float *t, int ldt)
     * }
     */
    public static MethodHandle LAPACKE_stpqrt2_work$handle() {
        return LAPACKE_stpqrt2_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_stpqrt2_work(int matrix_layout, int m, int n, int l, float *a, int lda, float *b, int ldb, float *t, int ldt)
     * }
     */
    public static MemorySegment LAPACKE_stpqrt2_work$address() {
        return LAPACKE_stpqrt2_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_stpqrt2_work(int matrix_layout, int m, int n, int l, float *a, int lda, float *b, int ldb, float *t, int ldt)
     * }
     */
    public static int LAPACKE_stpqrt2_work(int matrix_layout, int m, int n, int l, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment t, int ldt) {
        var mh$ = LAPACKE_stpqrt2_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_stpqrt2_work", matrix_layout, m, n, l, a, lda, b, ldb, t, ldt);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, l, a, lda, b, ldb, t, ldt);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dtpqrt2_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dtpqrt2_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dtpqrt2_work(int matrix_layout, int m, int n, int l, double *a, int lda, double *b, int ldb, double *t, int ldt)
     * }
     */
    public static FunctionDescriptor LAPACKE_dtpqrt2_work$descriptor() {
        return LAPACKE_dtpqrt2_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dtpqrt2_work(int matrix_layout, int m, int n, int l, double *a, int lda, double *b, int ldb, double *t, int ldt)
     * }
     */
    public static MethodHandle LAPACKE_dtpqrt2_work$handle() {
        return LAPACKE_dtpqrt2_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dtpqrt2_work(int matrix_layout, int m, int n, int l, double *a, int lda, double *b, int ldb, double *t, int ldt)
     * }
     */
    public static MemorySegment LAPACKE_dtpqrt2_work$address() {
        return LAPACKE_dtpqrt2_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dtpqrt2_work(int matrix_layout, int m, int n, int l, double *a, int lda, double *b, int ldb, double *t, int ldt)
     * }
     */
    public static int LAPACKE_dtpqrt2_work(int matrix_layout, int m, int n, int l, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment t, int ldt) {
        var mh$ = LAPACKE_dtpqrt2_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dtpqrt2_work", matrix_layout, m, n, l, a, lda, b, ldb, t, ldt);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, l, a, lda, b, ldb, t, ldt);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ctpqrt2_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_ctpqrt2_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ctpqrt2_work(int matrix_layout, int m, int n, int l, _Complex float *a, int lda, _Complex float *b, int ldb, _Complex float *t, int ldt)
     * }
     */
    public static FunctionDescriptor LAPACKE_ctpqrt2_work$descriptor() {
        return LAPACKE_ctpqrt2_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ctpqrt2_work(int matrix_layout, int m, int n, int l, _Complex float *a, int lda, _Complex float *b, int ldb, _Complex float *t, int ldt)
     * }
     */
    public static MethodHandle LAPACKE_ctpqrt2_work$handle() {
        return LAPACKE_ctpqrt2_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ctpqrt2_work(int matrix_layout, int m, int n, int l, _Complex float *a, int lda, _Complex float *b, int ldb, _Complex float *t, int ldt)
     * }
     */
    public static MemorySegment LAPACKE_ctpqrt2_work$address() {
        return LAPACKE_ctpqrt2_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ctpqrt2_work(int matrix_layout, int m, int n, int l, _Complex float *a, int lda, _Complex float *b, int ldb, _Complex float *t, int ldt)
     * }
     */
    public static int LAPACKE_ctpqrt2_work(int matrix_layout, int m, int n, int l, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment t, int ldt) {
        var mh$ = LAPACKE_ctpqrt2_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ctpqrt2_work", matrix_layout, m, n, l, a, lda, b, ldb, t, ldt);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, l, a, lda, b, ldb, t, ldt);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ztpqrt2_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_ztpqrt2_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ztpqrt2_work(int matrix_layout, int m, int n, int l, _Complex double *a, int lda, _Complex double *b, int ldb, _Complex double *t, int ldt)
     * }
     */
    public static FunctionDescriptor LAPACKE_ztpqrt2_work$descriptor() {
        return LAPACKE_ztpqrt2_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ztpqrt2_work(int matrix_layout, int m, int n, int l, _Complex double *a, int lda, _Complex double *b, int ldb, _Complex double *t, int ldt)
     * }
     */
    public static MethodHandle LAPACKE_ztpqrt2_work$handle() {
        return LAPACKE_ztpqrt2_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ztpqrt2_work(int matrix_layout, int m, int n, int l, _Complex double *a, int lda, _Complex double *b, int ldb, _Complex double *t, int ldt)
     * }
     */
    public static MemorySegment LAPACKE_ztpqrt2_work$address() {
        return LAPACKE_ztpqrt2_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ztpqrt2_work(int matrix_layout, int m, int n, int l, _Complex double *a, int lda, _Complex double *b, int ldb, _Complex double *t, int ldt)
     * }
     */
    public static int LAPACKE_ztpqrt2_work(int matrix_layout, int m, int n, int l, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment t, int ldt) {
        var mh$ = LAPACKE_ztpqrt2_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ztpqrt2_work", matrix_layout, m, n, l, a, lda, b, ldb, t, ldt);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, l, a, lda, b, ldb, t, ldt);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_stprfb_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_stprfb_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_stprfb_work(int matrix_layout, char side, char trans, char direct, char storev, int m, int n, int k, int l, const float *v, int ldv, const float *t, int ldt, float *a, int lda, float *b, int ldb, float *work, int ldwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_stprfb_work$descriptor() {
        return LAPACKE_stprfb_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_stprfb_work(int matrix_layout, char side, char trans, char direct, char storev, int m, int n, int k, int l, const float *v, int ldv, const float *t, int ldt, float *a, int lda, float *b, int ldb, float *work, int ldwork)
     * }
     */
    public static MethodHandle LAPACKE_stprfb_work$handle() {
        return LAPACKE_stprfb_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_stprfb_work(int matrix_layout, char side, char trans, char direct, char storev, int m, int n, int k, int l, const float *v, int ldv, const float *t, int ldt, float *a, int lda, float *b, int ldb, float *work, int ldwork)
     * }
     */
    public static MemorySegment LAPACKE_stprfb_work$address() {
        return LAPACKE_stprfb_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_stprfb_work(int matrix_layout, char side, char trans, char direct, char storev, int m, int n, int k, int l, const float *v, int ldv, const float *t, int ldt, float *a, int lda, float *b, int ldb, float *work, int ldwork)
     * }
     */
    public static int LAPACKE_stprfb_work(int matrix_layout, byte side, byte trans, byte direct, byte storev, int m, int n, int k, int l, MemorySegment v, int ldv, MemorySegment t, int ldt, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment work, int ldwork) {
        var mh$ = LAPACKE_stprfb_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_stprfb_work", matrix_layout, side, trans, direct, storev, m, n, k, l, v, ldv, t, ldt, a, lda, b, ldb, work, ldwork);
            }
            return (int)mh$.invokeExact(matrix_layout, side, trans, direct, storev, m, n, k, l, v, ldv, t, ldt, a, lda, b, ldb, work, ldwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dtprfb_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dtprfb_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dtprfb_work(int matrix_layout, char side, char trans, char direct, char storev, int m, int n, int k, int l, const double *v, int ldv, const double *t, int ldt, double *a, int lda, double *b, int ldb, double *work, int ldwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_dtprfb_work$descriptor() {
        return LAPACKE_dtprfb_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dtprfb_work(int matrix_layout, char side, char trans, char direct, char storev, int m, int n, int k, int l, const double *v, int ldv, const double *t, int ldt, double *a, int lda, double *b, int ldb, double *work, int ldwork)
     * }
     */
    public static MethodHandle LAPACKE_dtprfb_work$handle() {
        return LAPACKE_dtprfb_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dtprfb_work(int matrix_layout, char side, char trans, char direct, char storev, int m, int n, int k, int l, const double *v, int ldv, const double *t, int ldt, double *a, int lda, double *b, int ldb, double *work, int ldwork)
     * }
     */
    public static MemorySegment LAPACKE_dtprfb_work$address() {
        return LAPACKE_dtprfb_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dtprfb_work(int matrix_layout, char side, char trans, char direct, char storev, int m, int n, int k, int l, const double *v, int ldv, const double *t, int ldt, double *a, int lda, double *b, int ldb, double *work, int ldwork)
     * }
     */
    public static int LAPACKE_dtprfb_work(int matrix_layout, byte side, byte trans, byte direct, byte storev, int m, int n, int k, int l, MemorySegment v, int ldv, MemorySegment t, int ldt, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment work, int ldwork) {
        var mh$ = LAPACKE_dtprfb_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dtprfb_work", matrix_layout, side, trans, direct, storev, m, n, k, l, v, ldv, t, ldt, a, lda, b, ldb, work, ldwork);
            }
            return (int)mh$.invokeExact(matrix_layout, side, trans, direct, storev, m, n, k, l, v, ldv, t, ldt, a, lda, b, ldb, work, ldwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ctprfb_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_ctprfb_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ctprfb_work(int matrix_layout, char side, char trans, char direct, char storev, int m, int n, int k, int l, const _Complex float *v, int ldv, const _Complex float *t, int ldt, _Complex float *a, int lda, _Complex float *b, int ldb, _Complex float *work, int ldwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_ctprfb_work$descriptor() {
        return LAPACKE_ctprfb_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ctprfb_work(int matrix_layout, char side, char trans, char direct, char storev, int m, int n, int k, int l, const _Complex float *v, int ldv, const _Complex float *t, int ldt, _Complex float *a, int lda, _Complex float *b, int ldb, _Complex float *work, int ldwork)
     * }
     */
    public static MethodHandle LAPACKE_ctprfb_work$handle() {
        return LAPACKE_ctprfb_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ctprfb_work(int matrix_layout, char side, char trans, char direct, char storev, int m, int n, int k, int l, const _Complex float *v, int ldv, const _Complex float *t, int ldt, _Complex float *a, int lda, _Complex float *b, int ldb, _Complex float *work, int ldwork)
     * }
     */
    public static MemorySegment LAPACKE_ctprfb_work$address() {
        return LAPACKE_ctprfb_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ctprfb_work(int matrix_layout, char side, char trans, char direct, char storev, int m, int n, int k, int l, const _Complex float *v, int ldv, const _Complex float *t, int ldt, _Complex float *a, int lda, _Complex float *b, int ldb, _Complex float *work, int ldwork)
     * }
     */
    public static int LAPACKE_ctprfb_work(int matrix_layout, byte side, byte trans, byte direct, byte storev, int m, int n, int k, int l, MemorySegment v, int ldv, MemorySegment t, int ldt, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment work, int ldwork) {
        var mh$ = LAPACKE_ctprfb_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ctprfb_work", matrix_layout, side, trans, direct, storev, m, n, k, l, v, ldv, t, ldt, a, lda, b, ldb, work, ldwork);
            }
            return (int)mh$.invokeExact(matrix_layout, side, trans, direct, storev, m, n, k, l, v, ldv, t, ldt, a, lda, b, ldb, work, ldwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ztprfb_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_ztprfb_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ztprfb_work(int matrix_layout, char side, char trans, char direct, char storev, int m, int n, int k, int l, const _Complex double *v, int ldv, const _Complex double *t, int ldt, _Complex double *a, int lda, _Complex double *b, int ldb, _Complex double *work, int ldwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_ztprfb_work$descriptor() {
        return LAPACKE_ztprfb_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ztprfb_work(int matrix_layout, char side, char trans, char direct, char storev, int m, int n, int k, int l, const _Complex double *v, int ldv, const _Complex double *t, int ldt, _Complex double *a, int lda, _Complex double *b, int ldb, _Complex double *work, int ldwork)
     * }
     */
    public static MethodHandle LAPACKE_ztprfb_work$handle() {
        return LAPACKE_ztprfb_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ztprfb_work(int matrix_layout, char side, char trans, char direct, char storev, int m, int n, int k, int l, const _Complex double *v, int ldv, const _Complex double *t, int ldt, _Complex double *a, int lda, _Complex double *b, int ldb, _Complex double *work, int ldwork)
     * }
     */
    public static MemorySegment LAPACKE_ztprfb_work$address() {
        return LAPACKE_ztprfb_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ztprfb_work(int matrix_layout, char side, char trans, char direct, char storev, int m, int n, int k, int l, const _Complex double *v, int ldv, const _Complex double *t, int ldt, _Complex double *a, int lda, _Complex double *b, int ldb, _Complex double *work, int ldwork)
     * }
     */
    public static int LAPACKE_ztprfb_work(int matrix_layout, byte side, byte trans, byte direct, byte storev, int m, int n, int k, int l, MemorySegment v, int ldv, MemorySegment t, int ldt, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment work, int ldwork) {
        var mh$ = LAPACKE_ztprfb_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ztprfb_work", matrix_layout, side, trans, direct, storev, m, n, k, l, v, ldv, t, ldt, a, lda, b, ldb, work, ldwork);
            }
            return (int)mh$.invokeExact(matrix_layout, side, trans, direct, storev, m, n, k, l, v, ldv, t, ldt, a, lda, b, ldb, work, ldwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ssysv_rook {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_ssysv_rook");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ssysv_rook(int matrix_layout, char uplo, int n, int nrhs, float *a, int lda, int *ipiv, float *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_ssysv_rook$descriptor() {
        return LAPACKE_ssysv_rook.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ssysv_rook(int matrix_layout, char uplo, int n, int nrhs, float *a, int lda, int *ipiv, float *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_ssysv_rook$handle() {
        return LAPACKE_ssysv_rook.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ssysv_rook(int matrix_layout, char uplo, int n, int nrhs, float *a, int lda, int *ipiv, float *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_ssysv_rook$address() {
        return LAPACKE_ssysv_rook.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ssysv_rook(int matrix_layout, char uplo, int n, int nrhs, float *a, int lda, int *ipiv, float *b, int ldb)
     * }
     */
    public static int LAPACKE_ssysv_rook(int matrix_layout, byte uplo, int n, int nrhs, MemorySegment a, int lda, MemorySegment ipiv, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_ssysv_rook.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ssysv_rook", matrix_layout, uplo, n, nrhs, a, lda, ipiv, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, nrhs, a, lda, ipiv, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dsysv_rook {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dsysv_rook");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dsysv_rook(int matrix_layout, char uplo, int n, int nrhs, double *a, int lda, int *ipiv, double *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_dsysv_rook$descriptor() {
        return LAPACKE_dsysv_rook.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dsysv_rook(int matrix_layout, char uplo, int n, int nrhs, double *a, int lda, int *ipiv, double *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_dsysv_rook$handle() {
        return LAPACKE_dsysv_rook.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dsysv_rook(int matrix_layout, char uplo, int n, int nrhs, double *a, int lda, int *ipiv, double *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_dsysv_rook$address() {
        return LAPACKE_dsysv_rook.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dsysv_rook(int matrix_layout, char uplo, int n, int nrhs, double *a, int lda, int *ipiv, double *b, int ldb)
     * }
     */
    public static int LAPACKE_dsysv_rook(int matrix_layout, byte uplo, int n, int nrhs, MemorySegment a, int lda, MemorySegment ipiv, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_dsysv_rook.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dsysv_rook", matrix_layout, uplo, n, nrhs, a, lda, ipiv, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, nrhs, a, lda, ipiv, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_csysv_rook {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_csysv_rook");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_csysv_rook(int matrix_layout, char uplo, int n, int nrhs, _Complex float *a, int lda, int *ipiv, _Complex float *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_csysv_rook$descriptor() {
        return LAPACKE_csysv_rook.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_csysv_rook(int matrix_layout, char uplo, int n, int nrhs, _Complex float *a, int lda, int *ipiv, _Complex float *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_csysv_rook$handle() {
        return LAPACKE_csysv_rook.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_csysv_rook(int matrix_layout, char uplo, int n, int nrhs, _Complex float *a, int lda, int *ipiv, _Complex float *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_csysv_rook$address() {
        return LAPACKE_csysv_rook.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_csysv_rook(int matrix_layout, char uplo, int n, int nrhs, _Complex float *a, int lda, int *ipiv, _Complex float *b, int ldb)
     * }
     */
    public static int LAPACKE_csysv_rook(int matrix_layout, byte uplo, int n, int nrhs, MemorySegment a, int lda, MemorySegment ipiv, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_csysv_rook.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_csysv_rook", matrix_layout, uplo, n, nrhs, a, lda, ipiv, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, nrhs, a, lda, ipiv, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zsysv_rook {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zsysv_rook");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zsysv_rook(int matrix_layout, char uplo, int n, int nrhs, _Complex double *a, int lda, int *ipiv, _Complex double *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_zsysv_rook$descriptor() {
        return LAPACKE_zsysv_rook.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zsysv_rook(int matrix_layout, char uplo, int n, int nrhs, _Complex double *a, int lda, int *ipiv, _Complex double *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_zsysv_rook$handle() {
        return LAPACKE_zsysv_rook.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zsysv_rook(int matrix_layout, char uplo, int n, int nrhs, _Complex double *a, int lda, int *ipiv, _Complex double *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_zsysv_rook$address() {
        return LAPACKE_zsysv_rook.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zsysv_rook(int matrix_layout, char uplo, int n, int nrhs, _Complex double *a, int lda, int *ipiv, _Complex double *b, int ldb)
     * }
     */
    public static int LAPACKE_zsysv_rook(int matrix_layout, byte uplo, int n, int nrhs, MemorySegment a, int lda, MemorySegment ipiv, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_zsysv_rook.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zsysv_rook", matrix_layout, uplo, n, nrhs, a, lda, ipiv, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, nrhs, a, lda, ipiv, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ssytrf_rook {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_ssytrf_rook");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ssytrf_rook(int matrix_layout, char uplo, int n, float *a, int lda, int *ipiv)
     * }
     */
    public static FunctionDescriptor LAPACKE_ssytrf_rook$descriptor() {
        return LAPACKE_ssytrf_rook.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ssytrf_rook(int matrix_layout, char uplo, int n, float *a, int lda, int *ipiv)
     * }
     */
    public static MethodHandle LAPACKE_ssytrf_rook$handle() {
        return LAPACKE_ssytrf_rook.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ssytrf_rook(int matrix_layout, char uplo, int n, float *a, int lda, int *ipiv)
     * }
     */
    public static MemorySegment LAPACKE_ssytrf_rook$address() {
        return LAPACKE_ssytrf_rook.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ssytrf_rook(int matrix_layout, char uplo, int n, float *a, int lda, int *ipiv)
     * }
     */
    public static int LAPACKE_ssytrf_rook(int matrix_layout, byte uplo, int n, MemorySegment a, int lda, MemorySegment ipiv) {
        var mh$ = LAPACKE_ssytrf_rook.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ssytrf_rook", matrix_layout, uplo, n, a, lda, ipiv);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, a, lda, ipiv);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dsytrf_rook {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dsytrf_rook");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dsytrf_rook(int matrix_layout, char uplo, int n, double *a, int lda, int *ipiv)
     * }
     */
    public static FunctionDescriptor LAPACKE_dsytrf_rook$descriptor() {
        return LAPACKE_dsytrf_rook.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dsytrf_rook(int matrix_layout, char uplo, int n, double *a, int lda, int *ipiv)
     * }
     */
    public static MethodHandle LAPACKE_dsytrf_rook$handle() {
        return LAPACKE_dsytrf_rook.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dsytrf_rook(int matrix_layout, char uplo, int n, double *a, int lda, int *ipiv)
     * }
     */
    public static MemorySegment LAPACKE_dsytrf_rook$address() {
        return LAPACKE_dsytrf_rook.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dsytrf_rook(int matrix_layout, char uplo, int n, double *a, int lda, int *ipiv)
     * }
     */
    public static int LAPACKE_dsytrf_rook(int matrix_layout, byte uplo, int n, MemorySegment a, int lda, MemorySegment ipiv) {
        var mh$ = LAPACKE_dsytrf_rook.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dsytrf_rook", matrix_layout, uplo, n, a, lda, ipiv);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, a, lda, ipiv);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_csytrf_rook {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_csytrf_rook");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_csytrf_rook(int matrix_layout, char uplo, int n, _Complex float *a, int lda, int *ipiv)
     * }
     */
    public static FunctionDescriptor LAPACKE_csytrf_rook$descriptor() {
        return LAPACKE_csytrf_rook.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_csytrf_rook(int matrix_layout, char uplo, int n, _Complex float *a, int lda, int *ipiv)
     * }
     */
    public static MethodHandle LAPACKE_csytrf_rook$handle() {
        return LAPACKE_csytrf_rook.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_csytrf_rook(int matrix_layout, char uplo, int n, _Complex float *a, int lda, int *ipiv)
     * }
     */
    public static MemorySegment LAPACKE_csytrf_rook$address() {
        return LAPACKE_csytrf_rook.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_csytrf_rook(int matrix_layout, char uplo, int n, _Complex float *a, int lda, int *ipiv)
     * }
     */
    public static int LAPACKE_csytrf_rook(int matrix_layout, byte uplo, int n, MemorySegment a, int lda, MemorySegment ipiv) {
        var mh$ = LAPACKE_csytrf_rook.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_csytrf_rook", matrix_layout, uplo, n, a, lda, ipiv);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, a, lda, ipiv);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zsytrf_rook {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zsytrf_rook");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zsytrf_rook(int matrix_layout, char uplo, int n, _Complex double *a, int lda, int *ipiv)
     * }
     */
    public static FunctionDescriptor LAPACKE_zsytrf_rook$descriptor() {
        return LAPACKE_zsytrf_rook.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zsytrf_rook(int matrix_layout, char uplo, int n, _Complex double *a, int lda, int *ipiv)
     * }
     */
    public static MethodHandle LAPACKE_zsytrf_rook$handle() {
        return LAPACKE_zsytrf_rook.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zsytrf_rook(int matrix_layout, char uplo, int n, _Complex double *a, int lda, int *ipiv)
     * }
     */
    public static MemorySegment LAPACKE_zsytrf_rook$address() {
        return LAPACKE_zsytrf_rook.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zsytrf_rook(int matrix_layout, char uplo, int n, _Complex double *a, int lda, int *ipiv)
     * }
     */
    public static int LAPACKE_zsytrf_rook(int matrix_layout, byte uplo, int n, MemorySegment a, int lda, MemorySegment ipiv) {
        var mh$ = LAPACKE_zsytrf_rook.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zsytrf_rook", matrix_layout, uplo, n, a, lda, ipiv);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, a, lda, ipiv);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ssytrs_rook {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_ssytrs_rook");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ssytrs_rook(int matrix_layout, char uplo, int n, int nrhs, const float *a, int lda, const int *ipiv, float *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_ssytrs_rook$descriptor() {
        return LAPACKE_ssytrs_rook.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ssytrs_rook(int matrix_layout, char uplo, int n, int nrhs, const float *a, int lda, const int *ipiv, float *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_ssytrs_rook$handle() {
        return LAPACKE_ssytrs_rook.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ssytrs_rook(int matrix_layout, char uplo, int n, int nrhs, const float *a, int lda, const int *ipiv, float *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_ssytrs_rook$address() {
        return LAPACKE_ssytrs_rook.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ssytrs_rook(int matrix_layout, char uplo, int n, int nrhs, const float *a, int lda, const int *ipiv, float *b, int ldb)
     * }
     */
    public static int LAPACKE_ssytrs_rook(int matrix_layout, byte uplo, int n, int nrhs, MemorySegment a, int lda, MemorySegment ipiv, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_ssytrs_rook.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ssytrs_rook", matrix_layout, uplo, n, nrhs, a, lda, ipiv, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, nrhs, a, lda, ipiv, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dsytrs_rook {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dsytrs_rook");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dsytrs_rook(int matrix_layout, char uplo, int n, int nrhs, const double *a, int lda, const int *ipiv, double *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_dsytrs_rook$descriptor() {
        return LAPACKE_dsytrs_rook.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dsytrs_rook(int matrix_layout, char uplo, int n, int nrhs, const double *a, int lda, const int *ipiv, double *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_dsytrs_rook$handle() {
        return LAPACKE_dsytrs_rook.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dsytrs_rook(int matrix_layout, char uplo, int n, int nrhs, const double *a, int lda, const int *ipiv, double *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_dsytrs_rook$address() {
        return LAPACKE_dsytrs_rook.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dsytrs_rook(int matrix_layout, char uplo, int n, int nrhs, const double *a, int lda, const int *ipiv, double *b, int ldb)
     * }
     */
    public static int LAPACKE_dsytrs_rook(int matrix_layout, byte uplo, int n, int nrhs, MemorySegment a, int lda, MemorySegment ipiv, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_dsytrs_rook.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dsytrs_rook", matrix_layout, uplo, n, nrhs, a, lda, ipiv, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, nrhs, a, lda, ipiv, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_csytrs_rook {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_csytrs_rook");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_csytrs_rook(int matrix_layout, char uplo, int n, int nrhs, const _Complex float *a, int lda, const int *ipiv, _Complex float *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_csytrs_rook$descriptor() {
        return LAPACKE_csytrs_rook.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_csytrs_rook(int matrix_layout, char uplo, int n, int nrhs, const _Complex float *a, int lda, const int *ipiv, _Complex float *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_csytrs_rook$handle() {
        return LAPACKE_csytrs_rook.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_csytrs_rook(int matrix_layout, char uplo, int n, int nrhs, const _Complex float *a, int lda, const int *ipiv, _Complex float *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_csytrs_rook$address() {
        return LAPACKE_csytrs_rook.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_csytrs_rook(int matrix_layout, char uplo, int n, int nrhs, const _Complex float *a, int lda, const int *ipiv, _Complex float *b, int ldb)
     * }
     */
    public static int LAPACKE_csytrs_rook(int matrix_layout, byte uplo, int n, int nrhs, MemorySegment a, int lda, MemorySegment ipiv, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_csytrs_rook.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_csytrs_rook", matrix_layout, uplo, n, nrhs, a, lda, ipiv, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, nrhs, a, lda, ipiv, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zsytrs_rook {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zsytrs_rook");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zsytrs_rook(int matrix_layout, char uplo, int n, int nrhs, const _Complex double *a, int lda, const int *ipiv, _Complex double *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_zsytrs_rook$descriptor() {
        return LAPACKE_zsytrs_rook.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zsytrs_rook(int matrix_layout, char uplo, int n, int nrhs, const _Complex double *a, int lda, const int *ipiv, _Complex double *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_zsytrs_rook$handle() {
        return LAPACKE_zsytrs_rook.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zsytrs_rook(int matrix_layout, char uplo, int n, int nrhs, const _Complex double *a, int lda, const int *ipiv, _Complex double *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_zsytrs_rook$address() {
        return LAPACKE_zsytrs_rook.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zsytrs_rook(int matrix_layout, char uplo, int n, int nrhs, const _Complex double *a, int lda, const int *ipiv, _Complex double *b, int ldb)
     * }
     */
    public static int LAPACKE_zsytrs_rook(int matrix_layout, byte uplo, int n, int nrhs, MemorySegment a, int lda, MemorySegment ipiv, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_zsytrs_rook.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zsytrs_rook", matrix_layout, uplo, n, nrhs, a, lda, ipiv, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, nrhs, a, lda, ipiv, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_chetrf_rook {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_chetrf_rook");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_chetrf_rook(int matrix_layout, char uplo, int n, _Complex float *a, int lda, int *ipiv)
     * }
     */
    public static FunctionDescriptor LAPACKE_chetrf_rook$descriptor() {
        return LAPACKE_chetrf_rook.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_chetrf_rook(int matrix_layout, char uplo, int n, _Complex float *a, int lda, int *ipiv)
     * }
     */
    public static MethodHandle LAPACKE_chetrf_rook$handle() {
        return LAPACKE_chetrf_rook.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_chetrf_rook(int matrix_layout, char uplo, int n, _Complex float *a, int lda, int *ipiv)
     * }
     */
    public static MemorySegment LAPACKE_chetrf_rook$address() {
        return LAPACKE_chetrf_rook.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_chetrf_rook(int matrix_layout, char uplo, int n, _Complex float *a, int lda, int *ipiv)
     * }
     */
    public static int LAPACKE_chetrf_rook(int matrix_layout, byte uplo, int n, MemorySegment a, int lda, MemorySegment ipiv) {
        var mh$ = LAPACKE_chetrf_rook.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_chetrf_rook", matrix_layout, uplo, n, a, lda, ipiv);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, a, lda, ipiv);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zhetrf_rook {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zhetrf_rook");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zhetrf_rook(int matrix_layout, char uplo, int n, _Complex double *a, int lda, int *ipiv)
     * }
     */
    public static FunctionDescriptor LAPACKE_zhetrf_rook$descriptor() {
        return LAPACKE_zhetrf_rook.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zhetrf_rook(int matrix_layout, char uplo, int n, _Complex double *a, int lda, int *ipiv)
     * }
     */
    public static MethodHandle LAPACKE_zhetrf_rook$handle() {
        return LAPACKE_zhetrf_rook.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zhetrf_rook(int matrix_layout, char uplo, int n, _Complex double *a, int lda, int *ipiv)
     * }
     */
    public static MemorySegment LAPACKE_zhetrf_rook$address() {
        return LAPACKE_zhetrf_rook.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zhetrf_rook(int matrix_layout, char uplo, int n, _Complex double *a, int lda, int *ipiv)
     * }
     */
    public static int LAPACKE_zhetrf_rook(int matrix_layout, byte uplo, int n, MemorySegment a, int lda, MemorySegment ipiv) {
        var mh$ = LAPACKE_zhetrf_rook.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zhetrf_rook", matrix_layout, uplo, n, a, lda, ipiv);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, a, lda, ipiv);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_chetrs_rook {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_chetrs_rook");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_chetrs_rook(int matrix_layout, char uplo, int n, int nrhs, const _Complex float *a, int lda, const int *ipiv, _Complex float *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_chetrs_rook$descriptor() {
        return LAPACKE_chetrs_rook.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_chetrs_rook(int matrix_layout, char uplo, int n, int nrhs, const _Complex float *a, int lda, const int *ipiv, _Complex float *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_chetrs_rook$handle() {
        return LAPACKE_chetrs_rook.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_chetrs_rook(int matrix_layout, char uplo, int n, int nrhs, const _Complex float *a, int lda, const int *ipiv, _Complex float *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_chetrs_rook$address() {
        return LAPACKE_chetrs_rook.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_chetrs_rook(int matrix_layout, char uplo, int n, int nrhs, const _Complex float *a, int lda, const int *ipiv, _Complex float *b, int ldb)
     * }
     */
    public static int LAPACKE_chetrs_rook(int matrix_layout, byte uplo, int n, int nrhs, MemorySegment a, int lda, MemorySegment ipiv, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_chetrs_rook.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_chetrs_rook", matrix_layout, uplo, n, nrhs, a, lda, ipiv, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, nrhs, a, lda, ipiv, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zhetrs_rook {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zhetrs_rook");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zhetrs_rook(int matrix_layout, char uplo, int n, int nrhs, const _Complex double *a, int lda, const int *ipiv, _Complex double *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_zhetrs_rook$descriptor() {
        return LAPACKE_zhetrs_rook.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zhetrs_rook(int matrix_layout, char uplo, int n, int nrhs, const _Complex double *a, int lda, const int *ipiv, _Complex double *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_zhetrs_rook$handle() {
        return LAPACKE_zhetrs_rook.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zhetrs_rook(int matrix_layout, char uplo, int n, int nrhs, const _Complex double *a, int lda, const int *ipiv, _Complex double *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_zhetrs_rook$address() {
        return LAPACKE_zhetrs_rook.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zhetrs_rook(int matrix_layout, char uplo, int n, int nrhs, const _Complex double *a, int lda, const int *ipiv, _Complex double *b, int ldb)
     * }
     */
    public static int LAPACKE_zhetrs_rook(int matrix_layout, byte uplo, int n, int nrhs, MemorySegment a, int lda, MemorySegment ipiv, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_zhetrs_rook.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zhetrs_rook", matrix_layout, uplo, n, nrhs, a, lda, ipiv, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, nrhs, a, lda, ipiv, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_csyr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_csyr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_csyr(int matrix_layout, char uplo, int n, _Complex float alpha, const _Complex float *x, int incx, _Complex float *a, int lda)
     * }
     */
    public static FunctionDescriptor LAPACKE_csyr$descriptor() {
        return LAPACKE_csyr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_csyr(int matrix_layout, char uplo, int n, _Complex float alpha, const _Complex float *x, int incx, _Complex float *a, int lda)
     * }
     */
    public static MethodHandle LAPACKE_csyr$handle() {
        return LAPACKE_csyr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_csyr(int matrix_layout, char uplo, int n, _Complex float alpha, const _Complex float *x, int incx, _Complex float *a, int lda)
     * }
     */
    public static MemorySegment LAPACKE_csyr$address() {
        return LAPACKE_csyr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_csyr(int matrix_layout, char uplo, int n, _Complex float alpha, const _Complex float *x, int incx, _Complex float *a, int lda)
     * }
     */
    public static int LAPACKE_csyr(int matrix_layout, byte uplo, int n, float alpha, MemorySegment x, int incx, MemorySegment a, int lda) {
        var mh$ = LAPACKE_csyr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_csyr", matrix_layout, uplo, n, alpha, x, incx, a, lda);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, alpha, x, incx, a, lda);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zsyr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zsyr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zsyr(int matrix_layout, char uplo, int n, _Complex double alpha, const _Complex double *x, int incx, _Complex double *a, int lda)
     * }
     */
    public static FunctionDescriptor LAPACKE_zsyr$descriptor() {
        return LAPACKE_zsyr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zsyr(int matrix_layout, char uplo, int n, _Complex double alpha, const _Complex double *x, int incx, _Complex double *a, int lda)
     * }
     */
    public static MethodHandle LAPACKE_zsyr$handle() {
        return LAPACKE_zsyr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zsyr(int matrix_layout, char uplo, int n, _Complex double alpha, const _Complex double *x, int incx, _Complex double *a, int lda)
     * }
     */
    public static MemorySegment LAPACKE_zsyr$address() {
        return LAPACKE_zsyr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zsyr(int matrix_layout, char uplo, int n, _Complex double alpha, const _Complex double *x, int incx, _Complex double *a, int lda)
     * }
     */
    public static int LAPACKE_zsyr(int matrix_layout, byte uplo, int n, double alpha, MemorySegment x, int incx, MemorySegment a, int lda) {
        var mh$ = LAPACKE_zsyr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zsyr", matrix_layout, uplo, n, alpha, x, incx, a, lda);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, alpha, x, incx, a, lda);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ssysv_rook_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_ssysv_rook_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ssysv_rook_work(int matrix_layout, char uplo, int n, int nrhs, float *a, int lda, int *ipiv, float *b, int ldb, float *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_ssysv_rook_work$descriptor() {
        return LAPACKE_ssysv_rook_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ssysv_rook_work(int matrix_layout, char uplo, int n, int nrhs, float *a, int lda, int *ipiv, float *b, int ldb, float *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_ssysv_rook_work$handle() {
        return LAPACKE_ssysv_rook_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ssysv_rook_work(int matrix_layout, char uplo, int n, int nrhs, float *a, int lda, int *ipiv, float *b, int ldb, float *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_ssysv_rook_work$address() {
        return LAPACKE_ssysv_rook_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ssysv_rook_work(int matrix_layout, char uplo, int n, int nrhs, float *a, int lda, int *ipiv, float *b, int ldb, float *work, int lwork)
     * }
     */
    public static int LAPACKE_ssysv_rook_work(int matrix_layout, byte uplo, int n, int nrhs, MemorySegment a, int lda, MemorySegment ipiv, MemorySegment b, int ldb, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_ssysv_rook_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ssysv_rook_work", matrix_layout, uplo, n, nrhs, a, lda, ipiv, b, ldb, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, nrhs, a, lda, ipiv, b, ldb, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dsysv_rook_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dsysv_rook_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dsysv_rook_work(int matrix_layout, char uplo, int n, int nrhs, double *a, int lda, int *ipiv, double *b, int ldb, double *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_dsysv_rook_work$descriptor() {
        return LAPACKE_dsysv_rook_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dsysv_rook_work(int matrix_layout, char uplo, int n, int nrhs, double *a, int lda, int *ipiv, double *b, int ldb, double *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_dsysv_rook_work$handle() {
        return LAPACKE_dsysv_rook_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dsysv_rook_work(int matrix_layout, char uplo, int n, int nrhs, double *a, int lda, int *ipiv, double *b, int ldb, double *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_dsysv_rook_work$address() {
        return LAPACKE_dsysv_rook_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dsysv_rook_work(int matrix_layout, char uplo, int n, int nrhs, double *a, int lda, int *ipiv, double *b, int ldb, double *work, int lwork)
     * }
     */
    public static int LAPACKE_dsysv_rook_work(int matrix_layout, byte uplo, int n, int nrhs, MemorySegment a, int lda, MemorySegment ipiv, MemorySegment b, int ldb, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_dsysv_rook_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dsysv_rook_work", matrix_layout, uplo, n, nrhs, a, lda, ipiv, b, ldb, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, nrhs, a, lda, ipiv, b, ldb, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_csysv_rook_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_csysv_rook_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_csysv_rook_work(int matrix_layout, char uplo, int n, int nrhs, _Complex float *a, int lda, int *ipiv, _Complex float *b, int ldb, _Complex float *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_csysv_rook_work$descriptor() {
        return LAPACKE_csysv_rook_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_csysv_rook_work(int matrix_layout, char uplo, int n, int nrhs, _Complex float *a, int lda, int *ipiv, _Complex float *b, int ldb, _Complex float *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_csysv_rook_work$handle() {
        return LAPACKE_csysv_rook_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_csysv_rook_work(int matrix_layout, char uplo, int n, int nrhs, _Complex float *a, int lda, int *ipiv, _Complex float *b, int ldb, _Complex float *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_csysv_rook_work$address() {
        return LAPACKE_csysv_rook_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_csysv_rook_work(int matrix_layout, char uplo, int n, int nrhs, _Complex float *a, int lda, int *ipiv, _Complex float *b, int ldb, _Complex float *work, int lwork)
     * }
     */
    public static int LAPACKE_csysv_rook_work(int matrix_layout, byte uplo, int n, int nrhs, MemorySegment a, int lda, MemorySegment ipiv, MemorySegment b, int ldb, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_csysv_rook_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_csysv_rook_work", matrix_layout, uplo, n, nrhs, a, lda, ipiv, b, ldb, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, nrhs, a, lda, ipiv, b, ldb, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zsysv_rook_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zsysv_rook_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zsysv_rook_work(int matrix_layout, char uplo, int n, int nrhs, _Complex double *a, int lda, int *ipiv, _Complex double *b, int ldb, _Complex double *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_zsysv_rook_work$descriptor() {
        return LAPACKE_zsysv_rook_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zsysv_rook_work(int matrix_layout, char uplo, int n, int nrhs, _Complex double *a, int lda, int *ipiv, _Complex double *b, int ldb, _Complex double *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_zsysv_rook_work$handle() {
        return LAPACKE_zsysv_rook_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zsysv_rook_work(int matrix_layout, char uplo, int n, int nrhs, _Complex double *a, int lda, int *ipiv, _Complex double *b, int ldb, _Complex double *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_zsysv_rook_work$address() {
        return LAPACKE_zsysv_rook_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zsysv_rook_work(int matrix_layout, char uplo, int n, int nrhs, _Complex double *a, int lda, int *ipiv, _Complex double *b, int ldb, _Complex double *work, int lwork)
     * }
     */
    public static int LAPACKE_zsysv_rook_work(int matrix_layout, byte uplo, int n, int nrhs, MemorySegment a, int lda, MemorySegment ipiv, MemorySegment b, int ldb, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_zsysv_rook_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zsysv_rook_work", matrix_layout, uplo, n, nrhs, a, lda, ipiv, b, ldb, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, nrhs, a, lda, ipiv, b, ldb, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ssytrf_rook_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_ssytrf_rook_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ssytrf_rook_work(int matrix_layout, char uplo, int n, float *a, int lda, int *ipiv, float *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_ssytrf_rook_work$descriptor() {
        return LAPACKE_ssytrf_rook_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ssytrf_rook_work(int matrix_layout, char uplo, int n, float *a, int lda, int *ipiv, float *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_ssytrf_rook_work$handle() {
        return LAPACKE_ssytrf_rook_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ssytrf_rook_work(int matrix_layout, char uplo, int n, float *a, int lda, int *ipiv, float *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_ssytrf_rook_work$address() {
        return LAPACKE_ssytrf_rook_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ssytrf_rook_work(int matrix_layout, char uplo, int n, float *a, int lda, int *ipiv, float *work, int lwork)
     * }
     */
    public static int LAPACKE_ssytrf_rook_work(int matrix_layout, byte uplo, int n, MemorySegment a, int lda, MemorySegment ipiv, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_ssytrf_rook_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ssytrf_rook_work", matrix_layout, uplo, n, a, lda, ipiv, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, a, lda, ipiv, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dsytrf_rook_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dsytrf_rook_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dsytrf_rook_work(int matrix_layout, char uplo, int n, double *a, int lda, int *ipiv, double *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_dsytrf_rook_work$descriptor() {
        return LAPACKE_dsytrf_rook_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dsytrf_rook_work(int matrix_layout, char uplo, int n, double *a, int lda, int *ipiv, double *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_dsytrf_rook_work$handle() {
        return LAPACKE_dsytrf_rook_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dsytrf_rook_work(int matrix_layout, char uplo, int n, double *a, int lda, int *ipiv, double *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_dsytrf_rook_work$address() {
        return LAPACKE_dsytrf_rook_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dsytrf_rook_work(int matrix_layout, char uplo, int n, double *a, int lda, int *ipiv, double *work, int lwork)
     * }
     */
    public static int LAPACKE_dsytrf_rook_work(int matrix_layout, byte uplo, int n, MemorySegment a, int lda, MemorySegment ipiv, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_dsytrf_rook_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dsytrf_rook_work", matrix_layout, uplo, n, a, lda, ipiv, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, a, lda, ipiv, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_csytrf_rook_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_csytrf_rook_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_csytrf_rook_work(int matrix_layout, char uplo, int n, _Complex float *a, int lda, int *ipiv, _Complex float *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_csytrf_rook_work$descriptor() {
        return LAPACKE_csytrf_rook_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_csytrf_rook_work(int matrix_layout, char uplo, int n, _Complex float *a, int lda, int *ipiv, _Complex float *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_csytrf_rook_work$handle() {
        return LAPACKE_csytrf_rook_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_csytrf_rook_work(int matrix_layout, char uplo, int n, _Complex float *a, int lda, int *ipiv, _Complex float *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_csytrf_rook_work$address() {
        return LAPACKE_csytrf_rook_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_csytrf_rook_work(int matrix_layout, char uplo, int n, _Complex float *a, int lda, int *ipiv, _Complex float *work, int lwork)
     * }
     */
    public static int LAPACKE_csytrf_rook_work(int matrix_layout, byte uplo, int n, MemorySegment a, int lda, MemorySegment ipiv, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_csytrf_rook_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_csytrf_rook_work", matrix_layout, uplo, n, a, lda, ipiv, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, a, lda, ipiv, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zsytrf_rook_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zsytrf_rook_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zsytrf_rook_work(int matrix_layout, char uplo, int n, _Complex double *a, int lda, int *ipiv, _Complex double *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_zsytrf_rook_work$descriptor() {
        return LAPACKE_zsytrf_rook_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zsytrf_rook_work(int matrix_layout, char uplo, int n, _Complex double *a, int lda, int *ipiv, _Complex double *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_zsytrf_rook_work$handle() {
        return LAPACKE_zsytrf_rook_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zsytrf_rook_work(int matrix_layout, char uplo, int n, _Complex double *a, int lda, int *ipiv, _Complex double *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_zsytrf_rook_work$address() {
        return LAPACKE_zsytrf_rook_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zsytrf_rook_work(int matrix_layout, char uplo, int n, _Complex double *a, int lda, int *ipiv, _Complex double *work, int lwork)
     * }
     */
    public static int LAPACKE_zsytrf_rook_work(int matrix_layout, byte uplo, int n, MemorySegment a, int lda, MemorySegment ipiv, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_zsytrf_rook_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zsytrf_rook_work", matrix_layout, uplo, n, a, lda, ipiv, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, a, lda, ipiv, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ssytrs_rook_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_ssytrs_rook_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ssytrs_rook_work(int matrix_layout, char uplo, int n, int nrhs, const float *a, int lda, const int *ipiv, float *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_ssytrs_rook_work$descriptor() {
        return LAPACKE_ssytrs_rook_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ssytrs_rook_work(int matrix_layout, char uplo, int n, int nrhs, const float *a, int lda, const int *ipiv, float *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_ssytrs_rook_work$handle() {
        return LAPACKE_ssytrs_rook_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ssytrs_rook_work(int matrix_layout, char uplo, int n, int nrhs, const float *a, int lda, const int *ipiv, float *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_ssytrs_rook_work$address() {
        return LAPACKE_ssytrs_rook_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ssytrs_rook_work(int matrix_layout, char uplo, int n, int nrhs, const float *a, int lda, const int *ipiv, float *b, int ldb)
     * }
     */
    public static int LAPACKE_ssytrs_rook_work(int matrix_layout, byte uplo, int n, int nrhs, MemorySegment a, int lda, MemorySegment ipiv, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_ssytrs_rook_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ssytrs_rook_work", matrix_layout, uplo, n, nrhs, a, lda, ipiv, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, nrhs, a, lda, ipiv, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dsytrs_rook_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dsytrs_rook_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dsytrs_rook_work(int matrix_layout, char uplo, int n, int nrhs, const double *a, int lda, const int *ipiv, double *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_dsytrs_rook_work$descriptor() {
        return LAPACKE_dsytrs_rook_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dsytrs_rook_work(int matrix_layout, char uplo, int n, int nrhs, const double *a, int lda, const int *ipiv, double *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_dsytrs_rook_work$handle() {
        return LAPACKE_dsytrs_rook_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dsytrs_rook_work(int matrix_layout, char uplo, int n, int nrhs, const double *a, int lda, const int *ipiv, double *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_dsytrs_rook_work$address() {
        return LAPACKE_dsytrs_rook_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dsytrs_rook_work(int matrix_layout, char uplo, int n, int nrhs, const double *a, int lda, const int *ipiv, double *b, int ldb)
     * }
     */
    public static int LAPACKE_dsytrs_rook_work(int matrix_layout, byte uplo, int n, int nrhs, MemorySegment a, int lda, MemorySegment ipiv, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_dsytrs_rook_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dsytrs_rook_work", matrix_layout, uplo, n, nrhs, a, lda, ipiv, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, nrhs, a, lda, ipiv, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_csytrs_rook_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_csytrs_rook_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_csytrs_rook_work(int matrix_layout, char uplo, int n, int nrhs, const _Complex float *a, int lda, const int *ipiv, _Complex float *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_csytrs_rook_work$descriptor() {
        return LAPACKE_csytrs_rook_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_csytrs_rook_work(int matrix_layout, char uplo, int n, int nrhs, const _Complex float *a, int lda, const int *ipiv, _Complex float *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_csytrs_rook_work$handle() {
        return LAPACKE_csytrs_rook_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_csytrs_rook_work(int matrix_layout, char uplo, int n, int nrhs, const _Complex float *a, int lda, const int *ipiv, _Complex float *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_csytrs_rook_work$address() {
        return LAPACKE_csytrs_rook_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_csytrs_rook_work(int matrix_layout, char uplo, int n, int nrhs, const _Complex float *a, int lda, const int *ipiv, _Complex float *b, int ldb)
     * }
     */
    public static int LAPACKE_csytrs_rook_work(int matrix_layout, byte uplo, int n, int nrhs, MemorySegment a, int lda, MemorySegment ipiv, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_csytrs_rook_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_csytrs_rook_work", matrix_layout, uplo, n, nrhs, a, lda, ipiv, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, nrhs, a, lda, ipiv, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zsytrs_rook_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zsytrs_rook_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zsytrs_rook_work(int matrix_layout, char uplo, int n, int nrhs, const _Complex double *a, int lda, const int *ipiv, _Complex double *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_zsytrs_rook_work$descriptor() {
        return LAPACKE_zsytrs_rook_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zsytrs_rook_work(int matrix_layout, char uplo, int n, int nrhs, const _Complex double *a, int lda, const int *ipiv, _Complex double *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_zsytrs_rook_work$handle() {
        return LAPACKE_zsytrs_rook_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zsytrs_rook_work(int matrix_layout, char uplo, int n, int nrhs, const _Complex double *a, int lda, const int *ipiv, _Complex double *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_zsytrs_rook_work$address() {
        return LAPACKE_zsytrs_rook_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zsytrs_rook_work(int matrix_layout, char uplo, int n, int nrhs, const _Complex double *a, int lda, const int *ipiv, _Complex double *b, int ldb)
     * }
     */
    public static int LAPACKE_zsytrs_rook_work(int matrix_layout, byte uplo, int n, int nrhs, MemorySegment a, int lda, MemorySegment ipiv, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_zsytrs_rook_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zsytrs_rook_work", matrix_layout, uplo, n, nrhs, a, lda, ipiv, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, nrhs, a, lda, ipiv, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_chetrf_rook_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_chetrf_rook_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_chetrf_rook_work(int matrix_layout, char uplo, int n, _Complex float *a, int lda, int *ipiv, _Complex float *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_chetrf_rook_work$descriptor() {
        return LAPACKE_chetrf_rook_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_chetrf_rook_work(int matrix_layout, char uplo, int n, _Complex float *a, int lda, int *ipiv, _Complex float *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_chetrf_rook_work$handle() {
        return LAPACKE_chetrf_rook_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_chetrf_rook_work(int matrix_layout, char uplo, int n, _Complex float *a, int lda, int *ipiv, _Complex float *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_chetrf_rook_work$address() {
        return LAPACKE_chetrf_rook_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_chetrf_rook_work(int matrix_layout, char uplo, int n, _Complex float *a, int lda, int *ipiv, _Complex float *work, int lwork)
     * }
     */
    public static int LAPACKE_chetrf_rook_work(int matrix_layout, byte uplo, int n, MemorySegment a, int lda, MemorySegment ipiv, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_chetrf_rook_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_chetrf_rook_work", matrix_layout, uplo, n, a, lda, ipiv, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, a, lda, ipiv, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zhetrf_rook_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zhetrf_rook_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zhetrf_rook_work(int matrix_layout, char uplo, int n, _Complex double *a, int lda, int *ipiv, _Complex double *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_zhetrf_rook_work$descriptor() {
        return LAPACKE_zhetrf_rook_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zhetrf_rook_work(int matrix_layout, char uplo, int n, _Complex double *a, int lda, int *ipiv, _Complex double *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_zhetrf_rook_work$handle() {
        return LAPACKE_zhetrf_rook_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zhetrf_rook_work(int matrix_layout, char uplo, int n, _Complex double *a, int lda, int *ipiv, _Complex double *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_zhetrf_rook_work$address() {
        return LAPACKE_zhetrf_rook_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zhetrf_rook_work(int matrix_layout, char uplo, int n, _Complex double *a, int lda, int *ipiv, _Complex double *work, int lwork)
     * }
     */
    public static int LAPACKE_zhetrf_rook_work(int matrix_layout, byte uplo, int n, MemorySegment a, int lda, MemorySegment ipiv, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_zhetrf_rook_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zhetrf_rook_work", matrix_layout, uplo, n, a, lda, ipiv, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, a, lda, ipiv, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_chetrs_rook_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_chetrs_rook_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_chetrs_rook_work(int matrix_layout, char uplo, int n, int nrhs, const _Complex float *a, int lda, const int *ipiv, _Complex float *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_chetrs_rook_work$descriptor() {
        return LAPACKE_chetrs_rook_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_chetrs_rook_work(int matrix_layout, char uplo, int n, int nrhs, const _Complex float *a, int lda, const int *ipiv, _Complex float *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_chetrs_rook_work$handle() {
        return LAPACKE_chetrs_rook_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_chetrs_rook_work(int matrix_layout, char uplo, int n, int nrhs, const _Complex float *a, int lda, const int *ipiv, _Complex float *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_chetrs_rook_work$address() {
        return LAPACKE_chetrs_rook_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_chetrs_rook_work(int matrix_layout, char uplo, int n, int nrhs, const _Complex float *a, int lda, const int *ipiv, _Complex float *b, int ldb)
     * }
     */
    public static int LAPACKE_chetrs_rook_work(int matrix_layout, byte uplo, int n, int nrhs, MemorySegment a, int lda, MemorySegment ipiv, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_chetrs_rook_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_chetrs_rook_work", matrix_layout, uplo, n, nrhs, a, lda, ipiv, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, nrhs, a, lda, ipiv, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zhetrs_rook_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zhetrs_rook_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zhetrs_rook_work(int matrix_layout, char uplo, int n, int nrhs, const _Complex double *a, int lda, const int *ipiv, _Complex double *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_zhetrs_rook_work$descriptor() {
        return LAPACKE_zhetrs_rook_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zhetrs_rook_work(int matrix_layout, char uplo, int n, int nrhs, const _Complex double *a, int lda, const int *ipiv, _Complex double *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_zhetrs_rook_work$handle() {
        return LAPACKE_zhetrs_rook_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zhetrs_rook_work(int matrix_layout, char uplo, int n, int nrhs, const _Complex double *a, int lda, const int *ipiv, _Complex double *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_zhetrs_rook_work$address() {
        return LAPACKE_zhetrs_rook_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zhetrs_rook_work(int matrix_layout, char uplo, int n, int nrhs, const _Complex double *a, int lda, const int *ipiv, _Complex double *b, int ldb)
     * }
     */
    public static int LAPACKE_zhetrs_rook_work(int matrix_layout, byte uplo, int n, int nrhs, MemorySegment a, int lda, MemorySegment ipiv, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_zhetrs_rook_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zhetrs_rook_work", matrix_layout, uplo, n, nrhs, a, lda, ipiv, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, nrhs, a, lda, ipiv, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_csyr_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_csyr_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_csyr_work(int matrix_layout, char uplo, int n, _Complex float alpha, const _Complex float *x, int incx, _Complex float *a, int lda)
     * }
     */
    public static FunctionDescriptor LAPACKE_csyr_work$descriptor() {
        return LAPACKE_csyr_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_csyr_work(int matrix_layout, char uplo, int n, _Complex float alpha, const _Complex float *x, int incx, _Complex float *a, int lda)
     * }
     */
    public static MethodHandle LAPACKE_csyr_work$handle() {
        return LAPACKE_csyr_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_csyr_work(int matrix_layout, char uplo, int n, _Complex float alpha, const _Complex float *x, int incx, _Complex float *a, int lda)
     * }
     */
    public static MemorySegment LAPACKE_csyr_work$address() {
        return LAPACKE_csyr_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_csyr_work(int matrix_layout, char uplo, int n, _Complex float alpha, const _Complex float *x, int incx, _Complex float *a, int lda)
     * }
     */
    public static int LAPACKE_csyr_work(int matrix_layout, byte uplo, int n, float alpha, MemorySegment x, int incx, MemorySegment a, int lda) {
        var mh$ = LAPACKE_csyr_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_csyr_work", matrix_layout, uplo, n, alpha, x, incx, a, lda);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, alpha, x, incx, a, lda);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zsyr_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zsyr_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zsyr_work(int matrix_layout, char uplo, int n, _Complex double alpha, const _Complex double *x, int incx, _Complex double *a, int lda)
     * }
     */
    public static FunctionDescriptor LAPACKE_zsyr_work$descriptor() {
        return LAPACKE_zsyr_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zsyr_work(int matrix_layout, char uplo, int n, _Complex double alpha, const _Complex double *x, int incx, _Complex double *a, int lda)
     * }
     */
    public static MethodHandle LAPACKE_zsyr_work$handle() {
        return LAPACKE_zsyr_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zsyr_work(int matrix_layout, char uplo, int n, _Complex double alpha, const _Complex double *x, int incx, _Complex double *a, int lda)
     * }
     */
    public static MemorySegment LAPACKE_zsyr_work$address() {
        return LAPACKE_zsyr_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zsyr_work(int matrix_layout, char uplo, int n, _Complex double alpha, const _Complex double *x, int incx, _Complex double *a, int lda)
     * }
     */
    public static int LAPACKE_zsyr_work(int matrix_layout, byte uplo, int n, double alpha, MemorySegment x, int incx, MemorySegment a, int lda) {
        var mh$ = LAPACKE_zsyr_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zsyr_work", matrix_layout, uplo, n, alpha, x, incx, a, lda);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, alpha, x, incx, a, lda);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ilaver {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_ilaver");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void LAPACKE_ilaver(int *vers_major, int *vers_minor, int *vers_patch)
     * }
     */
    public static FunctionDescriptor LAPACKE_ilaver$descriptor() {
        return LAPACKE_ilaver.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void LAPACKE_ilaver(int *vers_major, int *vers_minor, int *vers_patch)
     * }
     */
    public static MethodHandle LAPACKE_ilaver$handle() {
        return LAPACKE_ilaver.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void LAPACKE_ilaver(int *vers_major, int *vers_minor, int *vers_patch)
     * }
     */
    public static MemorySegment LAPACKE_ilaver$address() {
        return LAPACKE_ilaver.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void LAPACKE_ilaver(int *vers_major, int *vers_minor, int *vers_patch)
     * }
     */
    public static void LAPACKE_ilaver(MemorySegment vers_major, MemorySegment vers_minor, MemorySegment vers_patch) {
        var mh$ = LAPACKE_ilaver.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ilaver", vers_major, vers_minor, vers_patch);
            }
            mh$.invokeExact(vers_major, vers_minor, vers_patch);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ssysv_aa {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_ssysv_aa");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ssysv_aa(int matrix_layout, char uplo, int n, int nrhs, float *a, int lda, int *ipiv, float *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_ssysv_aa$descriptor() {
        return LAPACKE_ssysv_aa.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ssysv_aa(int matrix_layout, char uplo, int n, int nrhs, float *a, int lda, int *ipiv, float *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_ssysv_aa$handle() {
        return LAPACKE_ssysv_aa.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ssysv_aa(int matrix_layout, char uplo, int n, int nrhs, float *a, int lda, int *ipiv, float *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_ssysv_aa$address() {
        return LAPACKE_ssysv_aa.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ssysv_aa(int matrix_layout, char uplo, int n, int nrhs, float *a, int lda, int *ipiv, float *b, int ldb)
     * }
     */
    public static int LAPACKE_ssysv_aa(int matrix_layout, byte uplo, int n, int nrhs, MemorySegment a, int lda, MemorySegment ipiv, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_ssysv_aa.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ssysv_aa", matrix_layout, uplo, n, nrhs, a, lda, ipiv, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, nrhs, a, lda, ipiv, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ssysv_aa_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_ssysv_aa_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ssysv_aa_work(int matrix_layout, char uplo, int n, int nrhs, float *a, int lda, int *ipiv, float *b, int ldb, float *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_ssysv_aa_work$descriptor() {
        return LAPACKE_ssysv_aa_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ssysv_aa_work(int matrix_layout, char uplo, int n, int nrhs, float *a, int lda, int *ipiv, float *b, int ldb, float *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_ssysv_aa_work$handle() {
        return LAPACKE_ssysv_aa_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ssysv_aa_work(int matrix_layout, char uplo, int n, int nrhs, float *a, int lda, int *ipiv, float *b, int ldb, float *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_ssysv_aa_work$address() {
        return LAPACKE_ssysv_aa_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ssysv_aa_work(int matrix_layout, char uplo, int n, int nrhs, float *a, int lda, int *ipiv, float *b, int ldb, float *work, int lwork)
     * }
     */
    public static int LAPACKE_ssysv_aa_work(int matrix_layout, byte uplo, int n, int nrhs, MemorySegment a, int lda, MemorySegment ipiv, MemorySegment b, int ldb, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_ssysv_aa_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ssysv_aa_work", matrix_layout, uplo, n, nrhs, a, lda, ipiv, b, ldb, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, nrhs, a, lda, ipiv, b, ldb, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dsysv_aa {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dsysv_aa");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dsysv_aa(int matrix_layout, char uplo, int n, int nrhs, double *a, int lda, int *ipiv, double *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_dsysv_aa$descriptor() {
        return LAPACKE_dsysv_aa.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dsysv_aa(int matrix_layout, char uplo, int n, int nrhs, double *a, int lda, int *ipiv, double *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_dsysv_aa$handle() {
        return LAPACKE_dsysv_aa.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dsysv_aa(int matrix_layout, char uplo, int n, int nrhs, double *a, int lda, int *ipiv, double *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_dsysv_aa$address() {
        return LAPACKE_dsysv_aa.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dsysv_aa(int matrix_layout, char uplo, int n, int nrhs, double *a, int lda, int *ipiv, double *b, int ldb)
     * }
     */
    public static int LAPACKE_dsysv_aa(int matrix_layout, byte uplo, int n, int nrhs, MemorySegment a, int lda, MemorySegment ipiv, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_dsysv_aa.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dsysv_aa", matrix_layout, uplo, n, nrhs, a, lda, ipiv, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, nrhs, a, lda, ipiv, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dsysv_aa_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dsysv_aa_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dsysv_aa_work(int matrix_layout, char uplo, int n, int nrhs, double *a, int lda, int *ipiv, double *b, int ldb, double *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_dsysv_aa_work$descriptor() {
        return LAPACKE_dsysv_aa_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dsysv_aa_work(int matrix_layout, char uplo, int n, int nrhs, double *a, int lda, int *ipiv, double *b, int ldb, double *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_dsysv_aa_work$handle() {
        return LAPACKE_dsysv_aa_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dsysv_aa_work(int matrix_layout, char uplo, int n, int nrhs, double *a, int lda, int *ipiv, double *b, int ldb, double *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_dsysv_aa_work$address() {
        return LAPACKE_dsysv_aa_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dsysv_aa_work(int matrix_layout, char uplo, int n, int nrhs, double *a, int lda, int *ipiv, double *b, int ldb, double *work, int lwork)
     * }
     */
    public static int LAPACKE_dsysv_aa_work(int matrix_layout, byte uplo, int n, int nrhs, MemorySegment a, int lda, MemorySegment ipiv, MemorySegment b, int ldb, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_dsysv_aa_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dsysv_aa_work", matrix_layout, uplo, n, nrhs, a, lda, ipiv, b, ldb, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, nrhs, a, lda, ipiv, b, ldb, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_csysv_aa {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_csysv_aa");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_csysv_aa(int matrix_layout, char uplo, int n, int nrhs, _Complex float *a, int lda, int *ipiv, _Complex float *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_csysv_aa$descriptor() {
        return LAPACKE_csysv_aa.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_csysv_aa(int matrix_layout, char uplo, int n, int nrhs, _Complex float *a, int lda, int *ipiv, _Complex float *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_csysv_aa$handle() {
        return LAPACKE_csysv_aa.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_csysv_aa(int matrix_layout, char uplo, int n, int nrhs, _Complex float *a, int lda, int *ipiv, _Complex float *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_csysv_aa$address() {
        return LAPACKE_csysv_aa.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_csysv_aa(int matrix_layout, char uplo, int n, int nrhs, _Complex float *a, int lda, int *ipiv, _Complex float *b, int ldb)
     * }
     */
    public static int LAPACKE_csysv_aa(int matrix_layout, byte uplo, int n, int nrhs, MemorySegment a, int lda, MemorySegment ipiv, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_csysv_aa.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_csysv_aa", matrix_layout, uplo, n, nrhs, a, lda, ipiv, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, nrhs, a, lda, ipiv, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_csysv_aa_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_csysv_aa_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_csysv_aa_work(int matrix_layout, char uplo, int n, int nrhs, _Complex float *a, int lda, int *ipiv, _Complex float *b, int ldb, _Complex float *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_csysv_aa_work$descriptor() {
        return LAPACKE_csysv_aa_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_csysv_aa_work(int matrix_layout, char uplo, int n, int nrhs, _Complex float *a, int lda, int *ipiv, _Complex float *b, int ldb, _Complex float *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_csysv_aa_work$handle() {
        return LAPACKE_csysv_aa_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_csysv_aa_work(int matrix_layout, char uplo, int n, int nrhs, _Complex float *a, int lda, int *ipiv, _Complex float *b, int ldb, _Complex float *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_csysv_aa_work$address() {
        return LAPACKE_csysv_aa_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_csysv_aa_work(int matrix_layout, char uplo, int n, int nrhs, _Complex float *a, int lda, int *ipiv, _Complex float *b, int ldb, _Complex float *work, int lwork)
     * }
     */
    public static int LAPACKE_csysv_aa_work(int matrix_layout, byte uplo, int n, int nrhs, MemorySegment a, int lda, MemorySegment ipiv, MemorySegment b, int ldb, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_csysv_aa_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_csysv_aa_work", matrix_layout, uplo, n, nrhs, a, lda, ipiv, b, ldb, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, nrhs, a, lda, ipiv, b, ldb, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zsysv_aa {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zsysv_aa");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zsysv_aa(int matrix_layout, char uplo, int n, int nrhs, _Complex double *a, int lda, int *ipiv, _Complex double *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_zsysv_aa$descriptor() {
        return LAPACKE_zsysv_aa.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zsysv_aa(int matrix_layout, char uplo, int n, int nrhs, _Complex double *a, int lda, int *ipiv, _Complex double *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_zsysv_aa$handle() {
        return LAPACKE_zsysv_aa.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zsysv_aa(int matrix_layout, char uplo, int n, int nrhs, _Complex double *a, int lda, int *ipiv, _Complex double *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_zsysv_aa$address() {
        return LAPACKE_zsysv_aa.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zsysv_aa(int matrix_layout, char uplo, int n, int nrhs, _Complex double *a, int lda, int *ipiv, _Complex double *b, int ldb)
     * }
     */
    public static int LAPACKE_zsysv_aa(int matrix_layout, byte uplo, int n, int nrhs, MemorySegment a, int lda, MemorySegment ipiv, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_zsysv_aa.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zsysv_aa", matrix_layout, uplo, n, nrhs, a, lda, ipiv, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, nrhs, a, lda, ipiv, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zsysv_aa_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zsysv_aa_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zsysv_aa_work(int matrix_layout, char uplo, int n, int nrhs, _Complex double *a, int lda, int *ipiv, _Complex double *b, int ldb, _Complex double *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_zsysv_aa_work$descriptor() {
        return LAPACKE_zsysv_aa_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zsysv_aa_work(int matrix_layout, char uplo, int n, int nrhs, _Complex double *a, int lda, int *ipiv, _Complex double *b, int ldb, _Complex double *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_zsysv_aa_work$handle() {
        return LAPACKE_zsysv_aa_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zsysv_aa_work(int matrix_layout, char uplo, int n, int nrhs, _Complex double *a, int lda, int *ipiv, _Complex double *b, int ldb, _Complex double *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_zsysv_aa_work$address() {
        return LAPACKE_zsysv_aa_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zsysv_aa_work(int matrix_layout, char uplo, int n, int nrhs, _Complex double *a, int lda, int *ipiv, _Complex double *b, int ldb, _Complex double *work, int lwork)
     * }
     */
    public static int LAPACKE_zsysv_aa_work(int matrix_layout, byte uplo, int n, int nrhs, MemorySegment a, int lda, MemorySegment ipiv, MemorySegment b, int ldb, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_zsysv_aa_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zsysv_aa_work", matrix_layout, uplo, n, nrhs, a, lda, ipiv, b, ldb, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, nrhs, a, lda, ipiv, b, ldb, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_chesv_aa {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_chesv_aa");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_chesv_aa(int matrix_layout, char uplo, int n, int nrhs, _Complex float *a, int lda, int *ipiv, _Complex float *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_chesv_aa$descriptor() {
        return LAPACKE_chesv_aa.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_chesv_aa(int matrix_layout, char uplo, int n, int nrhs, _Complex float *a, int lda, int *ipiv, _Complex float *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_chesv_aa$handle() {
        return LAPACKE_chesv_aa.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_chesv_aa(int matrix_layout, char uplo, int n, int nrhs, _Complex float *a, int lda, int *ipiv, _Complex float *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_chesv_aa$address() {
        return LAPACKE_chesv_aa.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_chesv_aa(int matrix_layout, char uplo, int n, int nrhs, _Complex float *a, int lda, int *ipiv, _Complex float *b, int ldb)
     * }
     */
    public static int LAPACKE_chesv_aa(int matrix_layout, byte uplo, int n, int nrhs, MemorySegment a, int lda, MemorySegment ipiv, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_chesv_aa.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_chesv_aa", matrix_layout, uplo, n, nrhs, a, lda, ipiv, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, nrhs, a, lda, ipiv, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_chesv_aa_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_chesv_aa_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_chesv_aa_work(int matrix_layout, char uplo, int n, int nrhs, _Complex float *a, int lda, int *ipiv, _Complex float *b, int ldb, _Complex float *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_chesv_aa_work$descriptor() {
        return LAPACKE_chesv_aa_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_chesv_aa_work(int matrix_layout, char uplo, int n, int nrhs, _Complex float *a, int lda, int *ipiv, _Complex float *b, int ldb, _Complex float *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_chesv_aa_work$handle() {
        return LAPACKE_chesv_aa_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_chesv_aa_work(int matrix_layout, char uplo, int n, int nrhs, _Complex float *a, int lda, int *ipiv, _Complex float *b, int ldb, _Complex float *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_chesv_aa_work$address() {
        return LAPACKE_chesv_aa_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_chesv_aa_work(int matrix_layout, char uplo, int n, int nrhs, _Complex float *a, int lda, int *ipiv, _Complex float *b, int ldb, _Complex float *work, int lwork)
     * }
     */
    public static int LAPACKE_chesv_aa_work(int matrix_layout, byte uplo, int n, int nrhs, MemorySegment a, int lda, MemorySegment ipiv, MemorySegment b, int ldb, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_chesv_aa_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_chesv_aa_work", matrix_layout, uplo, n, nrhs, a, lda, ipiv, b, ldb, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, nrhs, a, lda, ipiv, b, ldb, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zhesv_aa {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zhesv_aa");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zhesv_aa(int matrix_layout, char uplo, int n, int nrhs, _Complex double *a, int lda, int *ipiv, _Complex double *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_zhesv_aa$descriptor() {
        return LAPACKE_zhesv_aa.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zhesv_aa(int matrix_layout, char uplo, int n, int nrhs, _Complex double *a, int lda, int *ipiv, _Complex double *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_zhesv_aa$handle() {
        return LAPACKE_zhesv_aa.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zhesv_aa(int matrix_layout, char uplo, int n, int nrhs, _Complex double *a, int lda, int *ipiv, _Complex double *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_zhesv_aa$address() {
        return LAPACKE_zhesv_aa.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zhesv_aa(int matrix_layout, char uplo, int n, int nrhs, _Complex double *a, int lda, int *ipiv, _Complex double *b, int ldb)
     * }
     */
    public static int LAPACKE_zhesv_aa(int matrix_layout, byte uplo, int n, int nrhs, MemorySegment a, int lda, MemorySegment ipiv, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_zhesv_aa.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zhesv_aa", matrix_layout, uplo, n, nrhs, a, lda, ipiv, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, nrhs, a, lda, ipiv, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zhesv_aa_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zhesv_aa_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zhesv_aa_work(int matrix_layout, char uplo, int n, int nrhs, _Complex double *a, int lda, int *ipiv, _Complex double *b, int ldb, _Complex double *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_zhesv_aa_work$descriptor() {
        return LAPACKE_zhesv_aa_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zhesv_aa_work(int matrix_layout, char uplo, int n, int nrhs, _Complex double *a, int lda, int *ipiv, _Complex double *b, int ldb, _Complex double *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_zhesv_aa_work$handle() {
        return LAPACKE_zhesv_aa_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zhesv_aa_work(int matrix_layout, char uplo, int n, int nrhs, _Complex double *a, int lda, int *ipiv, _Complex double *b, int ldb, _Complex double *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_zhesv_aa_work$address() {
        return LAPACKE_zhesv_aa_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zhesv_aa_work(int matrix_layout, char uplo, int n, int nrhs, _Complex double *a, int lda, int *ipiv, _Complex double *b, int ldb, _Complex double *work, int lwork)
     * }
     */
    public static int LAPACKE_zhesv_aa_work(int matrix_layout, byte uplo, int n, int nrhs, MemorySegment a, int lda, MemorySegment ipiv, MemorySegment b, int ldb, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_zhesv_aa_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zhesv_aa_work", matrix_layout, uplo, n, nrhs, a, lda, ipiv, b, ldb, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, nrhs, a, lda, ipiv, b, ldb, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ssytrf_aa {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_ssytrf_aa");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ssytrf_aa(int matrix_layout, char uplo, int n, float *a, int lda, int *ipiv)
     * }
     */
    public static FunctionDescriptor LAPACKE_ssytrf_aa$descriptor() {
        return LAPACKE_ssytrf_aa.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ssytrf_aa(int matrix_layout, char uplo, int n, float *a, int lda, int *ipiv)
     * }
     */
    public static MethodHandle LAPACKE_ssytrf_aa$handle() {
        return LAPACKE_ssytrf_aa.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ssytrf_aa(int matrix_layout, char uplo, int n, float *a, int lda, int *ipiv)
     * }
     */
    public static MemorySegment LAPACKE_ssytrf_aa$address() {
        return LAPACKE_ssytrf_aa.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ssytrf_aa(int matrix_layout, char uplo, int n, float *a, int lda, int *ipiv)
     * }
     */
    public static int LAPACKE_ssytrf_aa(int matrix_layout, byte uplo, int n, MemorySegment a, int lda, MemorySegment ipiv) {
        var mh$ = LAPACKE_ssytrf_aa.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ssytrf_aa", matrix_layout, uplo, n, a, lda, ipiv);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, a, lda, ipiv);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dsytrf_aa {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dsytrf_aa");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dsytrf_aa(int matrix_layout, char uplo, int n, double *a, int lda, int *ipiv)
     * }
     */
    public static FunctionDescriptor LAPACKE_dsytrf_aa$descriptor() {
        return LAPACKE_dsytrf_aa.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dsytrf_aa(int matrix_layout, char uplo, int n, double *a, int lda, int *ipiv)
     * }
     */
    public static MethodHandle LAPACKE_dsytrf_aa$handle() {
        return LAPACKE_dsytrf_aa.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dsytrf_aa(int matrix_layout, char uplo, int n, double *a, int lda, int *ipiv)
     * }
     */
    public static MemorySegment LAPACKE_dsytrf_aa$address() {
        return LAPACKE_dsytrf_aa.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dsytrf_aa(int matrix_layout, char uplo, int n, double *a, int lda, int *ipiv)
     * }
     */
    public static int LAPACKE_dsytrf_aa(int matrix_layout, byte uplo, int n, MemorySegment a, int lda, MemorySegment ipiv) {
        var mh$ = LAPACKE_dsytrf_aa.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dsytrf_aa", matrix_layout, uplo, n, a, lda, ipiv);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, a, lda, ipiv);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_csytrf_aa {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_csytrf_aa");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_csytrf_aa(int matrix_layout, char uplo, int n, _Complex float *a, int lda, int *ipiv)
     * }
     */
    public static FunctionDescriptor LAPACKE_csytrf_aa$descriptor() {
        return LAPACKE_csytrf_aa.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_csytrf_aa(int matrix_layout, char uplo, int n, _Complex float *a, int lda, int *ipiv)
     * }
     */
    public static MethodHandle LAPACKE_csytrf_aa$handle() {
        return LAPACKE_csytrf_aa.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_csytrf_aa(int matrix_layout, char uplo, int n, _Complex float *a, int lda, int *ipiv)
     * }
     */
    public static MemorySegment LAPACKE_csytrf_aa$address() {
        return LAPACKE_csytrf_aa.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_csytrf_aa(int matrix_layout, char uplo, int n, _Complex float *a, int lda, int *ipiv)
     * }
     */
    public static int LAPACKE_csytrf_aa(int matrix_layout, byte uplo, int n, MemorySegment a, int lda, MemorySegment ipiv) {
        var mh$ = LAPACKE_csytrf_aa.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_csytrf_aa", matrix_layout, uplo, n, a, lda, ipiv);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, a, lda, ipiv);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zsytrf_aa {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zsytrf_aa");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zsytrf_aa(int matrix_layout, char uplo, int n, _Complex double *a, int lda, int *ipiv)
     * }
     */
    public static FunctionDescriptor LAPACKE_zsytrf_aa$descriptor() {
        return LAPACKE_zsytrf_aa.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zsytrf_aa(int matrix_layout, char uplo, int n, _Complex double *a, int lda, int *ipiv)
     * }
     */
    public static MethodHandle LAPACKE_zsytrf_aa$handle() {
        return LAPACKE_zsytrf_aa.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zsytrf_aa(int matrix_layout, char uplo, int n, _Complex double *a, int lda, int *ipiv)
     * }
     */
    public static MemorySegment LAPACKE_zsytrf_aa$address() {
        return LAPACKE_zsytrf_aa.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zsytrf_aa(int matrix_layout, char uplo, int n, _Complex double *a, int lda, int *ipiv)
     * }
     */
    public static int LAPACKE_zsytrf_aa(int matrix_layout, byte uplo, int n, MemorySegment a, int lda, MemorySegment ipiv) {
        var mh$ = LAPACKE_zsytrf_aa.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zsytrf_aa", matrix_layout, uplo, n, a, lda, ipiv);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, a, lda, ipiv);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_chetrf_aa {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_chetrf_aa");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_chetrf_aa(int matrix_layout, char uplo, int n, _Complex float *a, int lda, int *ipiv)
     * }
     */
    public static FunctionDescriptor LAPACKE_chetrf_aa$descriptor() {
        return LAPACKE_chetrf_aa.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_chetrf_aa(int matrix_layout, char uplo, int n, _Complex float *a, int lda, int *ipiv)
     * }
     */
    public static MethodHandle LAPACKE_chetrf_aa$handle() {
        return LAPACKE_chetrf_aa.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_chetrf_aa(int matrix_layout, char uplo, int n, _Complex float *a, int lda, int *ipiv)
     * }
     */
    public static MemorySegment LAPACKE_chetrf_aa$address() {
        return LAPACKE_chetrf_aa.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_chetrf_aa(int matrix_layout, char uplo, int n, _Complex float *a, int lda, int *ipiv)
     * }
     */
    public static int LAPACKE_chetrf_aa(int matrix_layout, byte uplo, int n, MemorySegment a, int lda, MemorySegment ipiv) {
        var mh$ = LAPACKE_chetrf_aa.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_chetrf_aa", matrix_layout, uplo, n, a, lda, ipiv);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, a, lda, ipiv);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zhetrf_aa {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zhetrf_aa");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zhetrf_aa(int matrix_layout, char uplo, int n, _Complex double *a, int lda, int *ipiv)
     * }
     */
    public static FunctionDescriptor LAPACKE_zhetrf_aa$descriptor() {
        return LAPACKE_zhetrf_aa.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zhetrf_aa(int matrix_layout, char uplo, int n, _Complex double *a, int lda, int *ipiv)
     * }
     */
    public static MethodHandle LAPACKE_zhetrf_aa$handle() {
        return LAPACKE_zhetrf_aa.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zhetrf_aa(int matrix_layout, char uplo, int n, _Complex double *a, int lda, int *ipiv)
     * }
     */
    public static MemorySegment LAPACKE_zhetrf_aa$address() {
        return LAPACKE_zhetrf_aa.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zhetrf_aa(int matrix_layout, char uplo, int n, _Complex double *a, int lda, int *ipiv)
     * }
     */
    public static int LAPACKE_zhetrf_aa(int matrix_layout, byte uplo, int n, MemorySegment a, int lda, MemorySegment ipiv) {
        var mh$ = LAPACKE_zhetrf_aa.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zhetrf_aa", matrix_layout, uplo, n, a, lda, ipiv);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, a, lda, ipiv);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ssytrf_aa_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_ssytrf_aa_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ssytrf_aa_work(int matrix_layout, char uplo, int n, float *a, int lda, int *ipiv, float *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_ssytrf_aa_work$descriptor() {
        return LAPACKE_ssytrf_aa_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ssytrf_aa_work(int matrix_layout, char uplo, int n, float *a, int lda, int *ipiv, float *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_ssytrf_aa_work$handle() {
        return LAPACKE_ssytrf_aa_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ssytrf_aa_work(int matrix_layout, char uplo, int n, float *a, int lda, int *ipiv, float *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_ssytrf_aa_work$address() {
        return LAPACKE_ssytrf_aa_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ssytrf_aa_work(int matrix_layout, char uplo, int n, float *a, int lda, int *ipiv, float *work, int lwork)
     * }
     */
    public static int LAPACKE_ssytrf_aa_work(int matrix_layout, byte uplo, int n, MemorySegment a, int lda, MemorySegment ipiv, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_ssytrf_aa_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ssytrf_aa_work", matrix_layout, uplo, n, a, lda, ipiv, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, a, lda, ipiv, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dsytrf_aa_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dsytrf_aa_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dsytrf_aa_work(int matrix_layout, char uplo, int n, double *a, int lda, int *ipiv, double *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_dsytrf_aa_work$descriptor() {
        return LAPACKE_dsytrf_aa_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dsytrf_aa_work(int matrix_layout, char uplo, int n, double *a, int lda, int *ipiv, double *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_dsytrf_aa_work$handle() {
        return LAPACKE_dsytrf_aa_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dsytrf_aa_work(int matrix_layout, char uplo, int n, double *a, int lda, int *ipiv, double *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_dsytrf_aa_work$address() {
        return LAPACKE_dsytrf_aa_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dsytrf_aa_work(int matrix_layout, char uplo, int n, double *a, int lda, int *ipiv, double *work, int lwork)
     * }
     */
    public static int LAPACKE_dsytrf_aa_work(int matrix_layout, byte uplo, int n, MemorySegment a, int lda, MemorySegment ipiv, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_dsytrf_aa_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dsytrf_aa_work", matrix_layout, uplo, n, a, lda, ipiv, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, a, lda, ipiv, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_csytrf_aa_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_csytrf_aa_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_csytrf_aa_work(int matrix_layout, char uplo, int n, _Complex float *a, int lda, int *ipiv, _Complex float *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_csytrf_aa_work$descriptor() {
        return LAPACKE_csytrf_aa_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_csytrf_aa_work(int matrix_layout, char uplo, int n, _Complex float *a, int lda, int *ipiv, _Complex float *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_csytrf_aa_work$handle() {
        return LAPACKE_csytrf_aa_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_csytrf_aa_work(int matrix_layout, char uplo, int n, _Complex float *a, int lda, int *ipiv, _Complex float *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_csytrf_aa_work$address() {
        return LAPACKE_csytrf_aa_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_csytrf_aa_work(int matrix_layout, char uplo, int n, _Complex float *a, int lda, int *ipiv, _Complex float *work, int lwork)
     * }
     */
    public static int LAPACKE_csytrf_aa_work(int matrix_layout, byte uplo, int n, MemorySegment a, int lda, MemorySegment ipiv, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_csytrf_aa_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_csytrf_aa_work", matrix_layout, uplo, n, a, lda, ipiv, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, a, lda, ipiv, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zsytrf_aa_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zsytrf_aa_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zsytrf_aa_work(int matrix_layout, char uplo, int n, _Complex double *a, int lda, int *ipiv, _Complex double *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_zsytrf_aa_work$descriptor() {
        return LAPACKE_zsytrf_aa_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zsytrf_aa_work(int matrix_layout, char uplo, int n, _Complex double *a, int lda, int *ipiv, _Complex double *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_zsytrf_aa_work$handle() {
        return LAPACKE_zsytrf_aa_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zsytrf_aa_work(int matrix_layout, char uplo, int n, _Complex double *a, int lda, int *ipiv, _Complex double *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_zsytrf_aa_work$address() {
        return LAPACKE_zsytrf_aa_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zsytrf_aa_work(int matrix_layout, char uplo, int n, _Complex double *a, int lda, int *ipiv, _Complex double *work, int lwork)
     * }
     */
    public static int LAPACKE_zsytrf_aa_work(int matrix_layout, byte uplo, int n, MemorySegment a, int lda, MemorySegment ipiv, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_zsytrf_aa_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zsytrf_aa_work", matrix_layout, uplo, n, a, lda, ipiv, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, a, lda, ipiv, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_chetrf_aa_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_chetrf_aa_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_chetrf_aa_work(int matrix_layout, char uplo, int n, _Complex float *a, int lda, int *ipiv, _Complex float *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_chetrf_aa_work$descriptor() {
        return LAPACKE_chetrf_aa_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_chetrf_aa_work(int matrix_layout, char uplo, int n, _Complex float *a, int lda, int *ipiv, _Complex float *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_chetrf_aa_work$handle() {
        return LAPACKE_chetrf_aa_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_chetrf_aa_work(int matrix_layout, char uplo, int n, _Complex float *a, int lda, int *ipiv, _Complex float *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_chetrf_aa_work$address() {
        return LAPACKE_chetrf_aa_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_chetrf_aa_work(int matrix_layout, char uplo, int n, _Complex float *a, int lda, int *ipiv, _Complex float *work, int lwork)
     * }
     */
    public static int LAPACKE_chetrf_aa_work(int matrix_layout, byte uplo, int n, MemorySegment a, int lda, MemorySegment ipiv, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_chetrf_aa_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_chetrf_aa_work", matrix_layout, uplo, n, a, lda, ipiv, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, a, lda, ipiv, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zhetrf_aa_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zhetrf_aa_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zhetrf_aa_work(int matrix_layout, char uplo, int n, _Complex double *a, int lda, int *ipiv, _Complex double *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_zhetrf_aa_work$descriptor() {
        return LAPACKE_zhetrf_aa_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zhetrf_aa_work(int matrix_layout, char uplo, int n, _Complex double *a, int lda, int *ipiv, _Complex double *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_zhetrf_aa_work$handle() {
        return LAPACKE_zhetrf_aa_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zhetrf_aa_work(int matrix_layout, char uplo, int n, _Complex double *a, int lda, int *ipiv, _Complex double *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_zhetrf_aa_work$address() {
        return LAPACKE_zhetrf_aa_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zhetrf_aa_work(int matrix_layout, char uplo, int n, _Complex double *a, int lda, int *ipiv, _Complex double *work, int lwork)
     * }
     */
    public static int LAPACKE_zhetrf_aa_work(int matrix_layout, byte uplo, int n, MemorySegment a, int lda, MemorySegment ipiv, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_zhetrf_aa_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zhetrf_aa_work", matrix_layout, uplo, n, a, lda, ipiv, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, a, lda, ipiv, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_csytrs_aa {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_csytrs_aa");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_csytrs_aa(int matrix_layout, char uplo, int n, int nrhs, const _Complex float *a, int lda, const int *ipiv, _Complex float *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_csytrs_aa$descriptor() {
        return LAPACKE_csytrs_aa.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_csytrs_aa(int matrix_layout, char uplo, int n, int nrhs, const _Complex float *a, int lda, const int *ipiv, _Complex float *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_csytrs_aa$handle() {
        return LAPACKE_csytrs_aa.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_csytrs_aa(int matrix_layout, char uplo, int n, int nrhs, const _Complex float *a, int lda, const int *ipiv, _Complex float *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_csytrs_aa$address() {
        return LAPACKE_csytrs_aa.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_csytrs_aa(int matrix_layout, char uplo, int n, int nrhs, const _Complex float *a, int lda, const int *ipiv, _Complex float *b, int ldb)
     * }
     */
    public static int LAPACKE_csytrs_aa(int matrix_layout, byte uplo, int n, int nrhs, MemorySegment a, int lda, MemorySegment ipiv, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_csytrs_aa.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_csytrs_aa", matrix_layout, uplo, n, nrhs, a, lda, ipiv, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, nrhs, a, lda, ipiv, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_csytrs_aa_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_csytrs_aa_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_csytrs_aa_work(int matrix_layout, char uplo, int n, int nrhs, const _Complex float *a, int lda, const int *ipiv, _Complex float *b, int ldb, _Complex float *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_csytrs_aa_work$descriptor() {
        return LAPACKE_csytrs_aa_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_csytrs_aa_work(int matrix_layout, char uplo, int n, int nrhs, const _Complex float *a, int lda, const int *ipiv, _Complex float *b, int ldb, _Complex float *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_csytrs_aa_work$handle() {
        return LAPACKE_csytrs_aa_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_csytrs_aa_work(int matrix_layout, char uplo, int n, int nrhs, const _Complex float *a, int lda, const int *ipiv, _Complex float *b, int ldb, _Complex float *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_csytrs_aa_work$address() {
        return LAPACKE_csytrs_aa_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_csytrs_aa_work(int matrix_layout, char uplo, int n, int nrhs, const _Complex float *a, int lda, const int *ipiv, _Complex float *b, int ldb, _Complex float *work, int lwork)
     * }
     */
    public static int LAPACKE_csytrs_aa_work(int matrix_layout, byte uplo, int n, int nrhs, MemorySegment a, int lda, MemorySegment ipiv, MemorySegment b, int ldb, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_csytrs_aa_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_csytrs_aa_work", matrix_layout, uplo, n, nrhs, a, lda, ipiv, b, ldb, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, nrhs, a, lda, ipiv, b, ldb, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_chetrs_aa {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_chetrs_aa");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_chetrs_aa(int matrix_layout, char uplo, int n, int nrhs, const _Complex float *a, int lda, const int *ipiv, _Complex float *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_chetrs_aa$descriptor() {
        return LAPACKE_chetrs_aa.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_chetrs_aa(int matrix_layout, char uplo, int n, int nrhs, const _Complex float *a, int lda, const int *ipiv, _Complex float *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_chetrs_aa$handle() {
        return LAPACKE_chetrs_aa.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_chetrs_aa(int matrix_layout, char uplo, int n, int nrhs, const _Complex float *a, int lda, const int *ipiv, _Complex float *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_chetrs_aa$address() {
        return LAPACKE_chetrs_aa.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_chetrs_aa(int matrix_layout, char uplo, int n, int nrhs, const _Complex float *a, int lda, const int *ipiv, _Complex float *b, int ldb)
     * }
     */
    public static int LAPACKE_chetrs_aa(int matrix_layout, byte uplo, int n, int nrhs, MemorySegment a, int lda, MemorySegment ipiv, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_chetrs_aa.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_chetrs_aa", matrix_layout, uplo, n, nrhs, a, lda, ipiv, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, nrhs, a, lda, ipiv, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_chetrs_aa_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_chetrs_aa_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_chetrs_aa_work(int matrix_layout, char uplo, int n, int nrhs, const _Complex float *a, int lda, const int *ipiv, _Complex float *b, int ldb, _Complex float *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_chetrs_aa_work$descriptor() {
        return LAPACKE_chetrs_aa_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_chetrs_aa_work(int matrix_layout, char uplo, int n, int nrhs, const _Complex float *a, int lda, const int *ipiv, _Complex float *b, int ldb, _Complex float *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_chetrs_aa_work$handle() {
        return LAPACKE_chetrs_aa_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_chetrs_aa_work(int matrix_layout, char uplo, int n, int nrhs, const _Complex float *a, int lda, const int *ipiv, _Complex float *b, int ldb, _Complex float *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_chetrs_aa_work$address() {
        return LAPACKE_chetrs_aa_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_chetrs_aa_work(int matrix_layout, char uplo, int n, int nrhs, const _Complex float *a, int lda, const int *ipiv, _Complex float *b, int ldb, _Complex float *work, int lwork)
     * }
     */
    public static int LAPACKE_chetrs_aa_work(int matrix_layout, byte uplo, int n, int nrhs, MemorySegment a, int lda, MemorySegment ipiv, MemorySegment b, int ldb, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_chetrs_aa_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_chetrs_aa_work", matrix_layout, uplo, n, nrhs, a, lda, ipiv, b, ldb, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, nrhs, a, lda, ipiv, b, ldb, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dsytrs_aa {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dsytrs_aa");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dsytrs_aa(int matrix_layout, char uplo, int n, int nrhs, const double *a, int lda, const int *ipiv, double *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_dsytrs_aa$descriptor() {
        return LAPACKE_dsytrs_aa.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dsytrs_aa(int matrix_layout, char uplo, int n, int nrhs, const double *a, int lda, const int *ipiv, double *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_dsytrs_aa$handle() {
        return LAPACKE_dsytrs_aa.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dsytrs_aa(int matrix_layout, char uplo, int n, int nrhs, const double *a, int lda, const int *ipiv, double *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_dsytrs_aa$address() {
        return LAPACKE_dsytrs_aa.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dsytrs_aa(int matrix_layout, char uplo, int n, int nrhs, const double *a, int lda, const int *ipiv, double *b, int ldb)
     * }
     */
    public static int LAPACKE_dsytrs_aa(int matrix_layout, byte uplo, int n, int nrhs, MemorySegment a, int lda, MemorySegment ipiv, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_dsytrs_aa.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dsytrs_aa", matrix_layout, uplo, n, nrhs, a, lda, ipiv, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, nrhs, a, lda, ipiv, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dsytrs_aa_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dsytrs_aa_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dsytrs_aa_work(int matrix_layout, char uplo, int n, int nrhs, const double *a, int lda, const int *ipiv, double *b, int ldb, double *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_dsytrs_aa_work$descriptor() {
        return LAPACKE_dsytrs_aa_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dsytrs_aa_work(int matrix_layout, char uplo, int n, int nrhs, const double *a, int lda, const int *ipiv, double *b, int ldb, double *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_dsytrs_aa_work$handle() {
        return LAPACKE_dsytrs_aa_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dsytrs_aa_work(int matrix_layout, char uplo, int n, int nrhs, const double *a, int lda, const int *ipiv, double *b, int ldb, double *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_dsytrs_aa_work$address() {
        return LAPACKE_dsytrs_aa_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dsytrs_aa_work(int matrix_layout, char uplo, int n, int nrhs, const double *a, int lda, const int *ipiv, double *b, int ldb, double *work, int lwork)
     * }
     */
    public static int LAPACKE_dsytrs_aa_work(int matrix_layout, byte uplo, int n, int nrhs, MemorySegment a, int lda, MemorySegment ipiv, MemorySegment b, int ldb, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_dsytrs_aa_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dsytrs_aa_work", matrix_layout, uplo, n, nrhs, a, lda, ipiv, b, ldb, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, nrhs, a, lda, ipiv, b, ldb, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ssytrs_aa {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_ssytrs_aa");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ssytrs_aa(int matrix_layout, char uplo, int n, int nrhs, const float *a, int lda, const int *ipiv, float *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_ssytrs_aa$descriptor() {
        return LAPACKE_ssytrs_aa.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ssytrs_aa(int matrix_layout, char uplo, int n, int nrhs, const float *a, int lda, const int *ipiv, float *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_ssytrs_aa$handle() {
        return LAPACKE_ssytrs_aa.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ssytrs_aa(int matrix_layout, char uplo, int n, int nrhs, const float *a, int lda, const int *ipiv, float *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_ssytrs_aa$address() {
        return LAPACKE_ssytrs_aa.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ssytrs_aa(int matrix_layout, char uplo, int n, int nrhs, const float *a, int lda, const int *ipiv, float *b, int ldb)
     * }
     */
    public static int LAPACKE_ssytrs_aa(int matrix_layout, byte uplo, int n, int nrhs, MemorySegment a, int lda, MemorySegment ipiv, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_ssytrs_aa.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ssytrs_aa", matrix_layout, uplo, n, nrhs, a, lda, ipiv, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, nrhs, a, lda, ipiv, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ssytrs_aa_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_ssytrs_aa_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ssytrs_aa_work(int matrix_layout, char uplo, int n, int nrhs, const float *a, int lda, const int *ipiv, float *b, int ldb, float *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_ssytrs_aa_work$descriptor() {
        return LAPACKE_ssytrs_aa_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ssytrs_aa_work(int matrix_layout, char uplo, int n, int nrhs, const float *a, int lda, const int *ipiv, float *b, int ldb, float *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_ssytrs_aa_work$handle() {
        return LAPACKE_ssytrs_aa_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ssytrs_aa_work(int matrix_layout, char uplo, int n, int nrhs, const float *a, int lda, const int *ipiv, float *b, int ldb, float *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_ssytrs_aa_work$address() {
        return LAPACKE_ssytrs_aa_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ssytrs_aa_work(int matrix_layout, char uplo, int n, int nrhs, const float *a, int lda, const int *ipiv, float *b, int ldb, float *work, int lwork)
     * }
     */
    public static int LAPACKE_ssytrs_aa_work(int matrix_layout, byte uplo, int n, int nrhs, MemorySegment a, int lda, MemorySegment ipiv, MemorySegment b, int ldb, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_ssytrs_aa_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ssytrs_aa_work", matrix_layout, uplo, n, nrhs, a, lda, ipiv, b, ldb, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, nrhs, a, lda, ipiv, b, ldb, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zsytrs_aa {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zsytrs_aa");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zsytrs_aa(int matrix_layout, char uplo, int n, int nrhs, const _Complex double *a, int lda, const int *ipiv, _Complex double *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_zsytrs_aa$descriptor() {
        return LAPACKE_zsytrs_aa.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zsytrs_aa(int matrix_layout, char uplo, int n, int nrhs, const _Complex double *a, int lda, const int *ipiv, _Complex double *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_zsytrs_aa$handle() {
        return LAPACKE_zsytrs_aa.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zsytrs_aa(int matrix_layout, char uplo, int n, int nrhs, const _Complex double *a, int lda, const int *ipiv, _Complex double *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_zsytrs_aa$address() {
        return LAPACKE_zsytrs_aa.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zsytrs_aa(int matrix_layout, char uplo, int n, int nrhs, const _Complex double *a, int lda, const int *ipiv, _Complex double *b, int ldb)
     * }
     */
    public static int LAPACKE_zsytrs_aa(int matrix_layout, byte uplo, int n, int nrhs, MemorySegment a, int lda, MemorySegment ipiv, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_zsytrs_aa.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zsytrs_aa", matrix_layout, uplo, n, nrhs, a, lda, ipiv, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, nrhs, a, lda, ipiv, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zsytrs_aa_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zsytrs_aa_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zsytrs_aa_work(int matrix_layout, char uplo, int n, int nrhs, const _Complex double *a, int lda, const int *ipiv, _Complex double *b, int ldb, _Complex double *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_zsytrs_aa_work$descriptor() {
        return LAPACKE_zsytrs_aa_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zsytrs_aa_work(int matrix_layout, char uplo, int n, int nrhs, const _Complex double *a, int lda, const int *ipiv, _Complex double *b, int ldb, _Complex double *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_zsytrs_aa_work$handle() {
        return LAPACKE_zsytrs_aa_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zsytrs_aa_work(int matrix_layout, char uplo, int n, int nrhs, const _Complex double *a, int lda, const int *ipiv, _Complex double *b, int ldb, _Complex double *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_zsytrs_aa_work$address() {
        return LAPACKE_zsytrs_aa_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zsytrs_aa_work(int matrix_layout, char uplo, int n, int nrhs, const _Complex double *a, int lda, const int *ipiv, _Complex double *b, int ldb, _Complex double *work, int lwork)
     * }
     */
    public static int LAPACKE_zsytrs_aa_work(int matrix_layout, byte uplo, int n, int nrhs, MemorySegment a, int lda, MemorySegment ipiv, MemorySegment b, int ldb, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_zsytrs_aa_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zsytrs_aa_work", matrix_layout, uplo, n, nrhs, a, lda, ipiv, b, ldb, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, nrhs, a, lda, ipiv, b, ldb, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zhetrs_aa {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zhetrs_aa");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zhetrs_aa(int matrix_layout, char uplo, int n, int nrhs, const _Complex double *a, int lda, const int *ipiv, _Complex double *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_zhetrs_aa$descriptor() {
        return LAPACKE_zhetrs_aa.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zhetrs_aa(int matrix_layout, char uplo, int n, int nrhs, const _Complex double *a, int lda, const int *ipiv, _Complex double *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_zhetrs_aa$handle() {
        return LAPACKE_zhetrs_aa.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zhetrs_aa(int matrix_layout, char uplo, int n, int nrhs, const _Complex double *a, int lda, const int *ipiv, _Complex double *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_zhetrs_aa$address() {
        return LAPACKE_zhetrs_aa.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zhetrs_aa(int matrix_layout, char uplo, int n, int nrhs, const _Complex double *a, int lda, const int *ipiv, _Complex double *b, int ldb)
     * }
     */
    public static int LAPACKE_zhetrs_aa(int matrix_layout, byte uplo, int n, int nrhs, MemorySegment a, int lda, MemorySegment ipiv, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_zhetrs_aa.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zhetrs_aa", matrix_layout, uplo, n, nrhs, a, lda, ipiv, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, nrhs, a, lda, ipiv, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zhetrs_aa_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zhetrs_aa_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zhetrs_aa_work(int matrix_layout, char uplo, int n, int nrhs, const _Complex double *a, int lda, const int *ipiv, _Complex double *b, int ldb, _Complex double *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_zhetrs_aa_work$descriptor() {
        return LAPACKE_zhetrs_aa_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zhetrs_aa_work(int matrix_layout, char uplo, int n, int nrhs, const _Complex double *a, int lda, const int *ipiv, _Complex double *b, int ldb, _Complex double *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_zhetrs_aa_work$handle() {
        return LAPACKE_zhetrs_aa_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zhetrs_aa_work(int matrix_layout, char uplo, int n, int nrhs, const _Complex double *a, int lda, const int *ipiv, _Complex double *b, int ldb, _Complex double *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_zhetrs_aa_work$address() {
        return LAPACKE_zhetrs_aa_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zhetrs_aa_work(int matrix_layout, char uplo, int n, int nrhs, const _Complex double *a, int lda, const int *ipiv, _Complex double *b, int ldb, _Complex double *work, int lwork)
     * }
     */
    public static int LAPACKE_zhetrs_aa_work(int matrix_layout, byte uplo, int n, int nrhs, MemorySegment a, int lda, MemorySegment ipiv, MemorySegment b, int ldb, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_zhetrs_aa_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zhetrs_aa_work", matrix_layout, uplo, n, nrhs, a, lda, ipiv, b, ldb, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, nrhs, a, lda, ipiv, b, ldb, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ssysv_rk {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_ssysv_rk");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ssysv_rk(int matrix_layout, char uplo, int n, int nrhs, float *a, int lda, float *e, int *ipiv, float *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_ssysv_rk$descriptor() {
        return LAPACKE_ssysv_rk.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ssysv_rk(int matrix_layout, char uplo, int n, int nrhs, float *a, int lda, float *e, int *ipiv, float *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_ssysv_rk$handle() {
        return LAPACKE_ssysv_rk.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ssysv_rk(int matrix_layout, char uplo, int n, int nrhs, float *a, int lda, float *e, int *ipiv, float *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_ssysv_rk$address() {
        return LAPACKE_ssysv_rk.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ssysv_rk(int matrix_layout, char uplo, int n, int nrhs, float *a, int lda, float *e, int *ipiv, float *b, int ldb)
     * }
     */
    public static int LAPACKE_ssysv_rk(int matrix_layout, byte uplo, int n, int nrhs, MemorySegment a, int lda, MemorySegment e, MemorySegment ipiv, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_ssysv_rk.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ssysv_rk", matrix_layout, uplo, n, nrhs, a, lda, e, ipiv, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, nrhs, a, lda, e, ipiv, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ssysv_rk_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_ssysv_rk_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ssysv_rk_work(int matrix_layout, char uplo, int n, int nrhs, float *a, int lda, float *e, int *ipiv, float *b, int ldb, float *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_ssysv_rk_work$descriptor() {
        return LAPACKE_ssysv_rk_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ssysv_rk_work(int matrix_layout, char uplo, int n, int nrhs, float *a, int lda, float *e, int *ipiv, float *b, int ldb, float *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_ssysv_rk_work$handle() {
        return LAPACKE_ssysv_rk_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ssysv_rk_work(int matrix_layout, char uplo, int n, int nrhs, float *a, int lda, float *e, int *ipiv, float *b, int ldb, float *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_ssysv_rk_work$address() {
        return LAPACKE_ssysv_rk_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ssysv_rk_work(int matrix_layout, char uplo, int n, int nrhs, float *a, int lda, float *e, int *ipiv, float *b, int ldb, float *work, int lwork)
     * }
     */
    public static int LAPACKE_ssysv_rk_work(int matrix_layout, byte uplo, int n, int nrhs, MemorySegment a, int lda, MemorySegment e, MemorySegment ipiv, MemorySegment b, int ldb, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_ssysv_rk_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ssysv_rk_work", matrix_layout, uplo, n, nrhs, a, lda, e, ipiv, b, ldb, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, nrhs, a, lda, e, ipiv, b, ldb, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dsysv_rk {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dsysv_rk");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dsysv_rk(int matrix_layout, char uplo, int n, int nrhs, double *a, int lda, double *e, int *ipiv, double *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_dsysv_rk$descriptor() {
        return LAPACKE_dsysv_rk.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dsysv_rk(int matrix_layout, char uplo, int n, int nrhs, double *a, int lda, double *e, int *ipiv, double *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_dsysv_rk$handle() {
        return LAPACKE_dsysv_rk.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dsysv_rk(int matrix_layout, char uplo, int n, int nrhs, double *a, int lda, double *e, int *ipiv, double *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_dsysv_rk$address() {
        return LAPACKE_dsysv_rk.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dsysv_rk(int matrix_layout, char uplo, int n, int nrhs, double *a, int lda, double *e, int *ipiv, double *b, int ldb)
     * }
     */
    public static int LAPACKE_dsysv_rk(int matrix_layout, byte uplo, int n, int nrhs, MemorySegment a, int lda, MemorySegment e, MemorySegment ipiv, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_dsysv_rk.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dsysv_rk", matrix_layout, uplo, n, nrhs, a, lda, e, ipiv, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, nrhs, a, lda, e, ipiv, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dsysv_rk_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dsysv_rk_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dsysv_rk_work(int matrix_layout, char uplo, int n, int nrhs, double *a, int lda, double *e, int *ipiv, double *b, int ldb, double *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_dsysv_rk_work$descriptor() {
        return LAPACKE_dsysv_rk_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dsysv_rk_work(int matrix_layout, char uplo, int n, int nrhs, double *a, int lda, double *e, int *ipiv, double *b, int ldb, double *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_dsysv_rk_work$handle() {
        return LAPACKE_dsysv_rk_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dsysv_rk_work(int matrix_layout, char uplo, int n, int nrhs, double *a, int lda, double *e, int *ipiv, double *b, int ldb, double *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_dsysv_rk_work$address() {
        return LAPACKE_dsysv_rk_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dsysv_rk_work(int matrix_layout, char uplo, int n, int nrhs, double *a, int lda, double *e, int *ipiv, double *b, int ldb, double *work, int lwork)
     * }
     */
    public static int LAPACKE_dsysv_rk_work(int matrix_layout, byte uplo, int n, int nrhs, MemorySegment a, int lda, MemorySegment e, MemorySegment ipiv, MemorySegment b, int ldb, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_dsysv_rk_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dsysv_rk_work", matrix_layout, uplo, n, nrhs, a, lda, e, ipiv, b, ldb, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, nrhs, a, lda, e, ipiv, b, ldb, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_csysv_rk {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_csysv_rk");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_csysv_rk(int matrix_layout, char uplo, int n, int nrhs, _Complex float *a, int lda, _Complex float *e, int *ipiv, _Complex float *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_csysv_rk$descriptor() {
        return LAPACKE_csysv_rk.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_csysv_rk(int matrix_layout, char uplo, int n, int nrhs, _Complex float *a, int lda, _Complex float *e, int *ipiv, _Complex float *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_csysv_rk$handle() {
        return LAPACKE_csysv_rk.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_csysv_rk(int matrix_layout, char uplo, int n, int nrhs, _Complex float *a, int lda, _Complex float *e, int *ipiv, _Complex float *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_csysv_rk$address() {
        return LAPACKE_csysv_rk.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_csysv_rk(int matrix_layout, char uplo, int n, int nrhs, _Complex float *a, int lda, _Complex float *e, int *ipiv, _Complex float *b, int ldb)
     * }
     */
    public static int LAPACKE_csysv_rk(int matrix_layout, byte uplo, int n, int nrhs, MemorySegment a, int lda, MemorySegment e, MemorySegment ipiv, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_csysv_rk.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_csysv_rk", matrix_layout, uplo, n, nrhs, a, lda, e, ipiv, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, nrhs, a, lda, e, ipiv, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_csysv_rk_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_csysv_rk_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_csysv_rk_work(int matrix_layout, char uplo, int n, int nrhs, _Complex float *a, int lda, _Complex float *e, int *ipiv, _Complex float *b, int ldb, _Complex float *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_csysv_rk_work$descriptor() {
        return LAPACKE_csysv_rk_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_csysv_rk_work(int matrix_layout, char uplo, int n, int nrhs, _Complex float *a, int lda, _Complex float *e, int *ipiv, _Complex float *b, int ldb, _Complex float *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_csysv_rk_work$handle() {
        return LAPACKE_csysv_rk_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_csysv_rk_work(int matrix_layout, char uplo, int n, int nrhs, _Complex float *a, int lda, _Complex float *e, int *ipiv, _Complex float *b, int ldb, _Complex float *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_csysv_rk_work$address() {
        return LAPACKE_csysv_rk_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_csysv_rk_work(int matrix_layout, char uplo, int n, int nrhs, _Complex float *a, int lda, _Complex float *e, int *ipiv, _Complex float *b, int ldb, _Complex float *work, int lwork)
     * }
     */
    public static int LAPACKE_csysv_rk_work(int matrix_layout, byte uplo, int n, int nrhs, MemorySegment a, int lda, MemorySegment e, MemorySegment ipiv, MemorySegment b, int ldb, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_csysv_rk_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_csysv_rk_work", matrix_layout, uplo, n, nrhs, a, lda, e, ipiv, b, ldb, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, nrhs, a, lda, e, ipiv, b, ldb, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zsysv_rk {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zsysv_rk");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zsysv_rk(int matrix_layout, char uplo, int n, int nrhs, _Complex double *a, int lda, _Complex double *e, int *ipiv, _Complex double *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_zsysv_rk$descriptor() {
        return LAPACKE_zsysv_rk.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zsysv_rk(int matrix_layout, char uplo, int n, int nrhs, _Complex double *a, int lda, _Complex double *e, int *ipiv, _Complex double *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_zsysv_rk$handle() {
        return LAPACKE_zsysv_rk.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zsysv_rk(int matrix_layout, char uplo, int n, int nrhs, _Complex double *a, int lda, _Complex double *e, int *ipiv, _Complex double *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_zsysv_rk$address() {
        return LAPACKE_zsysv_rk.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zsysv_rk(int matrix_layout, char uplo, int n, int nrhs, _Complex double *a, int lda, _Complex double *e, int *ipiv, _Complex double *b, int ldb)
     * }
     */
    public static int LAPACKE_zsysv_rk(int matrix_layout, byte uplo, int n, int nrhs, MemorySegment a, int lda, MemorySegment e, MemorySegment ipiv, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_zsysv_rk.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zsysv_rk", matrix_layout, uplo, n, nrhs, a, lda, e, ipiv, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, nrhs, a, lda, e, ipiv, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zsysv_rk_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zsysv_rk_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zsysv_rk_work(int matrix_layout, char uplo, int n, int nrhs, _Complex double *a, int lda, _Complex double *e, int *ipiv, _Complex double *b, int ldb, _Complex double *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_zsysv_rk_work$descriptor() {
        return LAPACKE_zsysv_rk_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zsysv_rk_work(int matrix_layout, char uplo, int n, int nrhs, _Complex double *a, int lda, _Complex double *e, int *ipiv, _Complex double *b, int ldb, _Complex double *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_zsysv_rk_work$handle() {
        return LAPACKE_zsysv_rk_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zsysv_rk_work(int matrix_layout, char uplo, int n, int nrhs, _Complex double *a, int lda, _Complex double *e, int *ipiv, _Complex double *b, int ldb, _Complex double *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_zsysv_rk_work$address() {
        return LAPACKE_zsysv_rk_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zsysv_rk_work(int matrix_layout, char uplo, int n, int nrhs, _Complex double *a, int lda, _Complex double *e, int *ipiv, _Complex double *b, int ldb, _Complex double *work, int lwork)
     * }
     */
    public static int LAPACKE_zsysv_rk_work(int matrix_layout, byte uplo, int n, int nrhs, MemorySegment a, int lda, MemorySegment e, MemorySegment ipiv, MemorySegment b, int ldb, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_zsysv_rk_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zsysv_rk_work", matrix_layout, uplo, n, nrhs, a, lda, e, ipiv, b, ldb, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, nrhs, a, lda, e, ipiv, b, ldb, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_chesv_rk {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_chesv_rk");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_chesv_rk(int matrix_layout, char uplo, int n, int nrhs, _Complex float *a, int lda, _Complex float *e, int *ipiv, _Complex float *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_chesv_rk$descriptor() {
        return LAPACKE_chesv_rk.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_chesv_rk(int matrix_layout, char uplo, int n, int nrhs, _Complex float *a, int lda, _Complex float *e, int *ipiv, _Complex float *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_chesv_rk$handle() {
        return LAPACKE_chesv_rk.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_chesv_rk(int matrix_layout, char uplo, int n, int nrhs, _Complex float *a, int lda, _Complex float *e, int *ipiv, _Complex float *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_chesv_rk$address() {
        return LAPACKE_chesv_rk.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_chesv_rk(int matrix_layout, char uplo, int n, int nrhs, _Complex float *a, int lda, _Complex float *e, int *ipiv, _Complex float *b, int ldb)
     * }
     */
    public static int LAPACKE_chesv_rk(int matrix_layout, byte uplo, int n, int nrhs, MemorySegment a, int lda, MemorySegment e, MemorySegment ipiv, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_chesv_rk.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_chesv_rk", matrix_layout, uplo, n, nrhs, a, lda, e, ipiv, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, nrhs, a, lda, e, ipiv, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_chesv_rk_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_chesv_rk_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_chesv_rk_work(int matrix_layout, char uplo, int n, int nrhs, _Complex float *a, int lda, _Complex float *e, int *ipiv, _Complex float *b, int ldb, _Complex float *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_chesv_rk_work$descriptor() {
        return LAPACKE_chesv_rk_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_chesv_rk_work(int matrix_layout, char uplo, int n, int nrhs, _Complex float *a, int lda, _Complex float *e, int *ipiv, _Complex float *b, int ldb, _Complex float *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_chesv_rk_work$handle() {
        return LAPACKE_chesv_rk_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_chesv_rk_work(int matrix_layout, char uplo, int n, int nrhs, _Complex float *a, int lda, _Complex float *e, int *ipiv, _Complex float *b, int ldb, _Complex float *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_chesv_rk_work$address() {
        return LAPACKE_chesv_rk_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_chesv_rk_work(int matrix_layout, char uplo, int n, int nrhs, _Complex float *a, int lda, _Complex float *e, int *ipiv, _Complex float *b, int ldb, _Complex float *work, int lwork)
     * }
     */
    public static int LAPACKE_chesv_rk_work(int matrix_layout, byte uplo, int n, int nrhs, MemorySegment a, int lda, MemorySegment e, MemorySegment ipiv, MemorySegment b, int ldb, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_chesv_rk_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_chesv_rk_work", matrix_layout, uplo, n, nrhs, a, lda, e, ipiv, b, ldb, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, nrhs, a, lda, e, ipiv, b, ldb, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zhesv_rk {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zhesv_rk");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zhesv_rk(int matrix_layout, char uplo, int n, int nrhs, _Complex double *a, int lda, _Complex double *e, int *ipiv, _Complex double *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_zhesv_rk$descriptor() {
        return LAPACKE_zhesv_rk.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zhesv_rk(int matrix_layout, char uplo, int n, int nrhs, _Complex double *a, int lda, _Complex double *e, int *ipiv, _Complex double *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_zhesv_rk$handle() {
        return LAPACKE_zhesv_rk.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zhesv_rk(int matrix_layout, char uplo, int n, int nrhs, _Complex double *a, int lda, _Complex double *e, int *ipiv, _Complex double *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_zhesv_rk$address() {
        return LAPACKE_zhesv_rk.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zhesv_rk(int matrix_layout, char uplo, int n, int nrhs, _Complex double *a, int lda, _Complex double *e, int *ipiv, _Complex double *b, int ldb)
     * }
     */
    public static int LAPACKE_zhesv_rk(int matrix_layout, byte uplo, int n, int nrhs, MemorySegment a, int lda, MemorySegment e, MemorySegment ipiv, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_zhesv_rk.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zhesv_rk", matrix_layout, uplo, n, nrhs, a, lda, e, ipiv, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, nrhs, a, lda, e, ipiv, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zhesv_rk_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zhesv_rk_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zhesv_rk_work(int matrix_layout, char uplo, int n, int nrhs, _Complex double *a, int lda, _Complex double *e, int *ipiv, _Complex double *b, int ldb, _Complex double *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_zhesv_rk_work$descriptor() {
        return LAPACKE_zhesv_rk_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zhesv_rk_work(int matrix_layout, char uplo, int n, int nrhs, _Complex double *a, int lda, _Complex double *e, int *ipiv, _Complex double *b, int ldb, _Complex double *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_zhesv_rk_work$handle() {
        return LAPACKE_zhesv_rk_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zhesv_rk_work(int matrix_layout, char uplo, int n, int nrhs, _Complex double *a, int lda, _Complex double *e, int *ipiv, _Complex double *b, int ldb, _Complex double *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_zhesv_rk_work$address() {
        return LAPACKE_zhesv_rk_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zhesv_rk_work(int matrix_layout, char uplo, int n, int nrhs, _Complex double *a, int lda, _Complex double *e, int *ipiv, _Complex double *b, int ldb, _Complex double *work, int lwork)
     * }
     */
    public static int LAPACKE_zhesv_rk_work(int matrix_layout, byte uplo, int n, int nrhs, MemorySegment a, int lda, MemorySegment e, MemorySegment ipiv, MemorySegment b, int ldb, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_zhesv_rk_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zhesv_rk_work", matrix_layout, uplo, n, nrhs, a, lda, e, ipiv, b, ldb, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, nrhs, a, lda, e, ipiv, b, ldb, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ssytrf_rk {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_ssytrf_rk");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ssytrf_rk(int matrix_layout, char uplo, int n, float *a, int lda, float *e, int *ipiv)
     * }
     */
    public static FunctionDescriptor LAPACKE_ssytrf_rk$descriptor() {
        return LAPACKE_ssytrf_rk.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ssytrf_rk(int matrix_layout, char uplo, int n, float *a, int lda, float *e, int *ipiv)
     * }
     */
    public static MethodHandle LAPACKE_ssytrf_rk$handle() {
        return LAPACKE_ssytrf_rk.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ssytrf_rk(int matrix_layout, char uplo, int n, float *a, int lda, float *e, int *ipiv)
     * }
     */
    public static MemorySegment LAPACKE_ssytrf_rk$address() {
        return LAPACKE_ssytrf_rk.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ssytrf_rk(int matrix_layout, char uplo, int n, float *a, int lda, float *e, int *ipiv)
     * }
     */
    public static int LAPACKE_ssytrf_rk(int matrix_layout, byte uplo, int n, MemorySegment a, int lda, MemorySegment e, MemorySegment ipiv) {
        var mh$ = LAPACKE_ssytrf_rk.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ssytrf_rk", matrix_layout, uplo, n, a, lda, e, ipiv);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, a, lda, e, ipiv);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dsytrf_rk {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dsytrf_rk");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dsytrf_rk(int matrix_layout, char uplo, int n, double *a, int lda, double *e, int *ipiv)
     * }
     */
    public static FunctionDescriptor LAPACKE_dsytrf_rk$descriptor() {
        return LAPACKE_dsytrf_rk.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dsytrf_rk(int matrix_layout, char uplo, int n, double *a, int lda, double *e, int *ipiv)
     * }
     */
    public static MethodHandle LAPACKE_dsytrf_rk$handle() {
        return LAPACKE_dsytrf_rk.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dsytrf_rk(int matrix_layout, char uplo, int n, double *a, int lda, double *e, int *ipiv)
     * }
     */
    public static MemorySegment LAPACKE_dsytrf_rk$address() {
        return LAPACKE_dsytrf_rk.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dsytrf_rk(int matrix_layout, char uplo, int n, double *a, int lda, double *e, int *ipiv)
     * }
     */
    public static int LAPACKE_dsytrf_rk(int matrix_layout, byte uplo, int n, MemorySegment a, int lda, MemorySegment e, MemorySegment ipiv) {
        var mh$ = LAPACKE_dsytrf_rk.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dsytrf_rk", matrix_layout, uplo, n, a, lda, e, ipiv);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, a, lda, e, ipiv);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_csytrf_rk {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_csytrf_rk");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_csytrf_rk(int matrix_layout, char uplo, int n, _Complex float *a, int lda, _Complex float *e, int *ipiv)
     * }
     */
    public static FunctionDescriptor LAPACKE_csytrf_rk$descriptor() {
        return LAPACKE_csytrf_rk.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_csytrf_rk(int matrix_layout, char uplo, int n, _Complex float *a, int lda, _Complex float *e, int *ipiv)
     * }
     */
    public static MethodHandle LAPACKE_csytrf_rk$handle() {
        return LAPACKE_csytrf_rk.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_csytrf_rk(int matrix_layout, char uplo, int n, _Complex float *a, int lda, _Complex float *e, int *ipiv)
     * }
     */
    public static MemorySegment LAPACKE_csytrf_rk$address() {
        return LAPACKE_csytrf_rk.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_csytrf_rk(int matrix_layout, char uplo, int n, _Complex float *a, int lda, _Complex float *e, int *ipiv)
     * }
     */
    public static int LAPACKE_csytrf_rk(int matrix_layout, byte uplo, int n, MemorySegment a, int lda, MemorySegment e, MemorySegment ipiv) {
        var mh$ = LAPACKE_csytrf_rk.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_csytrf_rk", matrix_layout, uplo, n, a, lda, e, ipiv);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, a, lda, e, ipiv);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zsytrf_rk {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zsytrf_rk");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zsytrf_rk(int matrix_layout, char uplo, int n, _Complex double *a, int lda, _Complex double *e, int *ipiv)
     * }
     */
    public static FunctionDescriptor LAPACKE_zsytrf_rk$descriptor() {
        return LAPACKE_zsytrf_rk.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zsytrf_rk(int matrix_layout, char uplo, int n, _Complex double *a, int lda, _Complex double *e, int *ipiv)
     * }
     */
    public static MethodHandle LAPACKE_zsytrf_rk$handle() {
        return LAPACKE_zsytrf_rk.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zsytrf_rk(int matrix_layout, char uplo, int n, _Complex double *a, int lda, _Complex double *e, int *ipiv)
     * }
     */
    public static MemorySegment LAPACKE_zsytrf_rk$address() {
        return LAPACKE_zsytrf_rk.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zsytrf_rk(int matrix_layout, char uplo, int n, _Complex double *a, int lda, _Complex double *e, int *ipiv)
     * }
     */
    public static int LAPACKE_zsytrf_rk(int matrix_layout, byte uplo, int n, MemorySegment a, int lda, MemorySegment e, MemorySegment ipiv) {
        var mh$ = LAPACKE_zsytrf_rk.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zsytrf_rk", matrix_layout, uplo, n, a, lda, e, ipiv);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, a, lda, e, ipiv);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_chetrf_rk {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_chetrf_rk");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_chetrf_rk(int matrix_layout, char uplo, int n, _Complex float *a, int lda, _Complex float *e, int *ipiv)
     * }
     */
    public static FunctionDescriptor LAPACKE_chetrf_rk$descriptor() {
        return LAPACKE_chetrf_rk.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_chetrf_rk(int matrix_layout, char uplo, int n, _Complex float *a, int lda, _Complex float *e, int *ipiv)
     * }
     */
    public static MethodHandle LAPACKE_chetrf_rk$handle() {
        return LAPACKE_chetrf_rk.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_chetrf_rk(int matrix_layout, char uplo, int n, _Complex float *a, int lda, _Complex float *e, int *ipiv)
     * }
     */
    public static MemorySegment LAPACKE_chetrf_rk$address() {
        return LAPACKE_chetrf_rk.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_chetrf_rk(int matrix_layout, char uplo, int n, _Complex float *a, int lda, _Complex float *e, int *ipiv)
     * }
     */
    public static int LAPACKE_chetrf_rk(int matrix_layout, byte uplo, int n, MemorySegment a, int lda, MemorySegment e, MemorySegment ipiv) {
        var mh$ = LAPACKE_chetrf_rk.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_chetrf_rk", matrix_layout, uplo, n, a, lda, e, ipiv);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, a, lda, e, ipiv);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zhetrf_rk {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zhetrf_rk");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zhetrf_rk(int matrix_layout, char uplo, int n, _Complex double *a, int lda, _Complex double *e, int *ipiv)
     * }
     */
    public static FunctionDescriptor LAPACKE_zhetrf_rk$descriptor() {
        return LAPACKE_zhetrf_rk.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zhetrf_rk(int matrix_layout, char uplo, int n, _Complex double *a, int lda, _Complex double *e, int *ipiv)
     * }
     */
    public static MethodHandle LAPACKE_zhetrf_rk$handle() {
        return LAPACKE_zhetrf_rk.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zhetrf_rk(int matrix_layout, char uplo, int n, _Complex double *a, int lda, _Complex double *e, int *ipiv)
     * }
     */
    public static MemorySegment LAPACKE_zhetrf_rk$address() {
        return LAPACKE_zhetrf_rk.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zhetrf_rk(int matrix_layout, char uplo, int n, _Complex double *a, int lda, _Complex double *e, int *ipiv)
     * }
     */
    public static int LAPACKE_zhetrf_rk(int matrix_layout, byte uplo, int n, MemorySegment a, int lda, MemorySegment e, MemorySegment ipiv) {
        var mh$ = LAPACKE_zhetrf_rk.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zhetrf_rk", matrix_layout, uplo, n, a, lda, e, ipiv);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, a, lda, e, ipiv);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ssytrf_rk_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_ssytrf_rk_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ssytrf_rk_work(int matrix_layout, char uplo, int n, float *a, int lda, float *e, int *ipiv, float *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_ssytrf_rk_work$descriptor() {
        return LAPACKE_ssytrf_rk_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ssytrf_rk_work(int matrix_layout, char uplo, int n, float *a, int lda, float *e, int *ipiv, float *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_ssytrf_rk_work$handle() {
        return LAPACKE_ssytrf_rk_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ssytrf_rk_work(int matrix_layout, char uplo, int n, float *a, int lda, float *e, int *ipiv, float *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_ssytrf_rk_work$address() {
        return LAPACKE_ssytrf_rk_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ssytrf_rk_work(int matrix_layout, char uplo, int n, float *a, int lda, float *e, int *ipiv, float *work, int lwork)
     * }
     */
    public static int LAPACKE_ssytrf_rk_work(int matrix_layout, byte uplo, int n, MemorySegment a, int lda, MemorySegment e, MemorySegment ipiv, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_ssytrf_rk_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ssytrf_rk_work", matrix_layout, uplo, n, a, lda, e, ipiv, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, a, lda, e, ipiv, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dsytrf_rk_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dsytrf_rk_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dsytrf_rk_work(int matrix_layout, char uplo, int n, double *a, int lda, double *e, int *ipiv, double *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_dsytrf_rk_work$descriptor() {
        return LAPACKE_dsytrf_rk_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dsytrf_rk_work(int matrix_layout, char uplo, int n, double *a, int lda, double *e, int *ipiv, double *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_dsytrf_rk_work$handle() {
        return LAPACKE_dsytrf_rk_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dsytrf_rk_work(int matrix_layout, char uplo, int n, double *a, int lda, double *e, int *ipiv, double *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_dsytrf_rk_work$address() {
        return LAPACKE_dsytrf_rk_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dsytrf_rk_work(int matrix_layout, char uplo, int n, double *a, int lda, double *e, int *ipiv, double *work, int lwork)
     * }
     */
    public static int LAPACKE_dsytrf_rk_work(int matrix_layout, byte uplo, int n, MemorySegment a, int lda, MemorySegment e, MemorySegment ipiv, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_dsytrf_rk_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dsytrf_rk_work", matrix_layout, uplo, n, a, lda, e, ipiv, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, a, lda, e, ipiv, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_csytrf_rk_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_csytrf_rk_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_csytrf_rk_work(int matrix_layout, char uplo, int n, _Complex float *a, int lda, _Complex float *e, int *ipiv, _Complex float *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_csytrf_rk_work$descriptor() {
        return LAPACKE_csytrf_rk_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_csytrf_rk_work(int matrix_layout, char uplo, int n, _Complex float *a, int lda, _Complex float *e, int *ipiv, _Complex float *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_csytrf_rk_work$handle() {
        return LAPACKE_csytrf_rk_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_csytrf_rk_work(int matrix_layout, char uplo, int n, _Complex float *a, int lda, _Complex float *e, int *ipiv, _Complex float *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_csytrf_rk_work$address() {
        return LAPACKE_csytrf_rk_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_csytrf_rk_work(int matrix_layout, char uplo, int n, _Complex float *a, int lda, _Complex float *e, int *ipiv, _Complex float *work, int lwork)
     * }
     */
    public static int LAPACKE_csytrf_rk_work(int matrix_layout, byte uplo, int n, MemorySegment a, int lda, MemorySegment e, MemorySegment ipiv, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_csytrf_rk_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_csytrf_rk_work", matrix_layout, uplo, n, a, lda, e, ipiv, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, a, lda, e, ipiv, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zsytrf_rk_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zsytrf_rk_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zsytrf_rk_work(int matrix_layout, char uplo, int n, _Complex double *a, int lda, _Complex double *e, int *ipiv, _Complex double *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_zsytrf_rk_work$descriptor() {
        return LAPACKE_zsytrf_rk_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zsytrf_rk_work(int matrix_layout, char uplo, int n, _Complex double *a, int lda, _Complex double *e, int *ipiv, _Complex double *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_zsytrf_rk_work$handle() {
        return LAPACKE_zsytrf_rk_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zsytrf_rk_work(int matrix_layout, char uplo, int n, _Complex double *a, int lda, _Complex double *e, int *ipiv, _Complex double *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_zsytrf_rk_work$address() {
        return LAPACKE_zsytrf_rk_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zsytrf_rk_work(int matrix_layout, char uplo, int n, _Complex double *a, int lda, _Complex double *e, int *ipiv, _Complex double *work, int lwork)
     * }
     */
    public static int LAPACKE_zsytrf_rk_work(int matrix_layout, byte uplo, int n, MemorySegment a, int lda, MemorySegment e, MemorySegment ipiv, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_zsytrf_rk_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zsytrf_rk_work", matrix_layout, uplo, n, a, lda, e, ipiv, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, a, lda, e, ipiv, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_chetrf_rk_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_chetrf_rk_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_chetrf_rk_work(int matrix_layout, char uplo, int n, _Complex float *a, int lda, _Complex float *e, int *ipiv, _Complex float *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_chetrf_rk_work$descriptor() {
        return LAPACKE_chetrf_rk_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_chetrf_rk_work(int matrix_layout, char uplo, int n, _Complex float *a, int lda, _Complex float *e, int *ipiv, _Complex float *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_chetrf_rk_work$handle() {
        return LAPACKE_chetrf_rk_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_chetrf_rk_work(int matrix_layout, char uplo, int n, _Complex float *a, int lda, _Complex float *e, int *ipiv, _Complex float *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_chetrf_rk_work$address() {
        return LAPACKE_chetrf_rk_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_chetrf_rk_work(int matrix_layout, char uplo, int n, _Complex float *a, int lda, _Complex float *e, int *ipiv, _Complex float *work, int lwork)
     * }
     */
    public static int LAPACKE_chetrf_rk_work(int matrix_layout, byte uplo, int n, MemorySegment a, int lda, MemorySegment e, MemorySegment ipiv, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_chetrf_rk_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_chetrf_rk_work", matrix_layout, uplo, n, a, lda, e, ipiv, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, a, lda, e, ipiv, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zhetrf_rk_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zhetrf_rk_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zhetrf_rk_work(int matrix_layout, char uplo, int n, _Complex double *a, int lda, _Complex double *e, int *ipiv, _Complex double *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_zhetrf_rk_work$descriptor() {
        return LAPACKE_zhetrf_rk_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zhetrf_rk_work(int matrix_layout, char uplo, int n, _Complex double *a, int lda, _Complex double *e, int *ipiv, _Complex double *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_zhetrf_rk_work$handle() {
        return LAPACKE_zhetrf_rk_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zhetrf_rk_work(int matrix_layout, char uplo, int n, _Complex double *a, int lda, _Complex double *e, int *ipiv, _Complex double *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_zhetrf_rk_work$address() {
        return LAPACKE_zhetrf_rk_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zhetrf_rk_work(int matrix_layout, char uplo, int n, _Complex double *a, int lda, _Complex double *e, int *ipiv, _Complex double *work, int lwork)
     * }
     */
    public static int LAPACKE_zhetrf_rk_work(int matrix_layout, byte uplo, int n, MemorySegment a, int lda, MemorySegment e, MemorySegment ipiv, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_zhetrf_rk_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zhetrf_rk_work", matrix_layout, uplo, n, a, lda, e, ipiv, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, a, lda, e, ipiv, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_csytrs_3 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_csytrs_3");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_csytrs_3(int matrix_layout, char uplo, int n, int nrhs, const _Complex float *a, int lda, const _Complex float *e, const int *ipiv, _Complex float *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_csytrs_3$descriptor() {
        return LAPACKE_csytrs_3.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_csytrs_3(int matrix_layout, char uplo, int n, int nrhs, const _Complex float *a, int lda, const _Complex float *e, const int *ipiv, _Complex float *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_csytrs_3$handle() {
        return LAPACKE_csytrs_3.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_csytrs_3(int matrix_layout, char uplo, int n, int nrhs, const _Complex float *a, int lda, const _Complex float *e, const int *ipiv, _Complex float *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_csytrs_3$address() {
        return LAPACKE_csytrs_3.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_csytrs_3(int matrix_layout, char uplo, int n, int nrhs, const _Complex float *a, int lda, const _Complex float *e, const int *ipiv, _Complex float *b, int ldb)
     * }
     */
    public static int LAPACKE_csytrs_3(int matrix_layout, byte uplo, int n, int nrhs, MemorySegment a, int lda, MemorySegment e, MemorySegment ipiv, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_csytrs_3.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_csytrs_3", matrix_layout, uplo, n, nrhs, a, lda, e, ipiv, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, nrhs, a, lda, e, ipiv, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_csytrs_3_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_csytrs_3_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_csytrs_3_work(int matrix_layout, char uplo, int n, int nrhs, const _Complex float *a, int lda, const _Complex float *e, const int *ipiv, _Complex float *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_csytrs_3_work$descriptor() {
        return LAPACKE_csytrs_3_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_csytrs_3_work(int matrix_layout, char uplo, int n, int nrhs, const _Complex float *a, int lda, const _Complex float *e, const int *ipiv, _Complex float *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_csytrs_3_work$handle() {
        return LAPACKE_csytrs_3_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_csytrs_3_work(int matrix_layout, char uplo, int n, int nrhs, const _Complex float *a, int lda, const _Complex float *e, const int *ipiv, _Complex float *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_csytrs_3_work$address() {
        return LAPACKE_csytrs_3_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_csytrs_3_work(int matrix_layout, char uplo, int n, int nrhs, const _Complex float *a, int lda, const _Complex float *e, const int *ipiv, _Complex float *b, int ldb)
     * }
     */
    public static int LAPACKE_csytrs_3_work(int matrix_layout, byte uplo, int n, int nrhs, MemorySegment a, int lda, MemorySegment e, MemorySegment ipiv, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_csytrs_3_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_csytrs_3_work", matrix_layout, uplo, n, nrhs, a, lda, e, ipiv, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, nrhs, a, lda, e, ipiv, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_chetrs_3 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_chetrs_3");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_chetrs_3(int matrix_layout, char uplo, int n, int nrhs, const _Complex float *a, int lda, const _Complex float *e, const int *ipiv, _Complex float *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_chetrs_3$descriptor() {
        return LAPACKE_chetrs_3.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_chetrs_3(int matrix_layout, char uplo, int n, int nrhs, const _Complex float *a, int lda, const _Complex float *e, const int *ipiv, _Complex float *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_chetrs_3$handle() {
        return LAPACKE_chetrs_3.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_chetrs_3(int matrix_layout, char uplo, int n, int nrhs, const _Complex float *a, int lda, const _Complex float *e, const int *ipiv, _Complex float *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_chetrs_3$address() {
        return LAPACKE_chetrs_3.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_chetrs_3(int matrix_layout, char uplo, int n, int nrhs, const _Complex float *a, int lda, const _Complex float *e, const int *ipiv, _Complex float *b, int ldb)
     * }
     */
    public static int LAPACKE_chetrs_3(int matrix_layout, byte uplo, int n, int nrhs, MemorySegment a, int lda, MemorySegment e, MemorySegment ipiv, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_chetrs_3.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_chetrs_3", matrix_layout, uplo, n, nrhs, a, lda, e, ipiv, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, nrhs, a, lda, e, ipiv, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_chetrs_3_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_chetrs_3_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_chetrs_3_work(int matrix_layout, char uplo, int n, int nrhs, const _Complex float *a, int lda, const _Complex float *e, const int *ipiv, _Complex float *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_chetrs_3_work$descriptor() {
        return LAPACKE_chetrs_3_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_chetrs_3_work(int matrix_layout, char uplo, int n, int nrhs, const _Complex float *a, int lda, const _Complex float *e, const int *ipiv, _Complex float *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_chetrs_3_work$handle() {
        return LAPACKE_chetrs_3_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_chetrs_3_work(int matrix_layout, char uplo, int n, int nrhs, const _Complex float *a, int lda, const _Complex float *e, const int *ipiv, _Complex float *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_chetrs_3_work$address() {
        return LAPACKE_chetrs_3_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_chetrs_3_work(int matrix_layout, char uplo, int n, int nrhs, const _Complex float *a, int lda, const _Complex float *e, const int *ipiv, _Complex float *b, int ldb)
     * }
     */
    public static int LAPACKE_chetrs_3_work(int matrix_layout, byte uplo, int n, int nrhs, MemorySegment a, int lda, MemorySegment e, MemorySegment ipiv, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_chetrs_3_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_chetrs_3_work", matrix_layout, uplo, n, nrhs, a, lda, e, ipiv, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, nrhs, a, lda, e, ipiv, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dsytrs_3 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dsytrs_3");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dsytrs_3(int matrix_layout, char uplo, int n, int nrhs, const double *a, int lda, const double *e, const int *ipiv, double *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_dsytrs_3$descriptor() {
        return LAPACKE_dsytrs_3.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dsytrs_3(int matrix_layout, char uplo, int n, int nrhs, const double *a, int lda, const double *e, const int *ipiv, double *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_dsytrs_3$handle() {
        return LAPACKE_dsytrs_3.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dsytrs_3(int matrix_layout, char uplo, int n, int nrhs, const double *a, int lda, const double *e, const int *ipiv, double *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_dsytrs_3$address() {
        return LAPACKE_dsytrs_3.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dsytrs_3(int matrix_layout, char uplo, int n, int nrhs, const double *a, int lda, const double *e, const int *ipiv, double *b, int ldb)
     * }
     */
    public static int LAPACKE_dsytrs_3(int matrix_layout, byte uplo, int n, int nrhs, MemorySegment a, int lda, MemorySegment e, MemorySegment ipiv, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_dsytrs_3.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dsytrs_3", matrix_layout, uplo, n, nrhs, a, lda, e, ipiv, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, nrhs, a, lda, e, ipiv, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dsytrs_3_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dsytrs_3_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dsytrs_3_work(int matrix_layout, char uplo, int n, int nrhs, const double *a, int lda, const double *e, const int *ipiv, double *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_dsytrs_3_work$descriptor() {
        return LAPACKE_dsytrs_3_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dsytrs_3_work(int matrix_layout, char uplo, int n, int nrhs, const double *a, int lda, const double *e, const int *ipiv, double *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_dsytrs_3_work$handle() {
        return LAPACKE_dsytrs_3_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dsytrs_3_work(int matrix_layout, char uplo, int n, int nrhs, const double *a, int lda, const double *e, const int *ipiv, double *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_dsytrs_3_work$address() {
        return LAPACKE_dsytrs_3_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dsytrs_3_work(int matrix_layout, char uplo, int n, int nrhs, const double *a, int lda, const double *e, const int *ipiv, double *b, int ldb)
     * }
     */
    public static int LAPACKE_dsytrs_3_work(int matrix_layout, byte uplo, int n, int nrhs, MemorySegment a, int lda, MemorySegment e, MemorySegment ipiv, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_dsytrs_3_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dsytrs_3_work", matrix_layout, uplo, n, nrhs, a, lda, e, ipiv, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, nrhs, a, lda, e, ipiv, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ssytrs_3 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_ssytrs_3");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ssytrs_3(int matrix_layout, char uplo, int n, int nrhs, const float *a, int lda, const float *e, const int *ipiv, float *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_ssytrs_3$descriptor() {
        return LAPACKE_ssytrs_3.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ssytrs_3(int matrix_layout, char uplo, int n, int nrhs, const float *a, int lda, const float *e, const int *ipiv, float *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_ssytrs_3$handle() {
        return LAPACKE_ssytrs_3.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ssytrs_3(int matrix_layout, char uplo, int n, int nrhs, const float *a, int lda, const float *e, const int *ipiv, float *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_ssytrs_3$address() {
        return LAPACKE_ssytrs_3.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ssytrs_3(int matrix_layout, char uplo, int n, int nrhs, const float *a, int lda, const float *e, const int *ipiv, float *b, int ldb)
     * }
     */
    public static int LAPACKE_ssytrs_3(int matrix_layout, byte uplo, int n, int nrhs, MemorySegment a, int lda, MemorySegment e, MemorySegment ipiv, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_ssytrs_3.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ssytrs_3", matrix_layout, uplo, n, nrhs, a, lda, e, ipiv, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, nrhs, a, lda, e, ipiv, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ssytrs_3_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_ssytrs_3_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ssytrs_3_work(int matrix_layout, char uplo, int n, int nrhs, const float *a, int lda, const float *e, const int *ipiv, float *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_ssytrs_3_work$descriptor() {
        return LAPACKE_ssytrs_3_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ssytrs_3_work(int matrix_layout, char uplo, int n, int nrhs, const float *a, int lda, const float *e, const int *ipiv, float *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_ssytrs_3_work$handle() {
        return LAPACKE_ssytrs_3_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ssytrs_3_work(int matrix_layout, char uplo, int n, int nrhs, const float *a, int lda, const float *e, const int *ipiv, float *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_ssytrs_3_work$address() {
        return LAPACKE_ssytrs_3_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ssytrs_3_work(int matrix_layout, char uplo, int n, int nrhs, const float *a, int lda, const float *e, const int *ipiv, float *b, int ldb)
     * }
     */
    public static int LAPACKE_ssytrs_3_work(int matrix_layout, byte uplo, int n, int nrhs, MemorySegment a, int lda, MemorySegment e, MemorySegment ipiv, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_ssytrs_3_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ssytrs_3_work", matrix_layout, uplo, n, nrhs, a, lda, e, ipiv, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, nrhs, a, lda, e, ipiv, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zsytrs_3 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zsytrs_3");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zsytrs_3(int matrix_layout, char uplo, int n, int nrhs, const _Complex double *a, int lda, const _Complex double *e, const int *ipiv, _Complex double *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_zsytrs_3$descriptor() {
        return LAPACKE_zsytrs_3.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zsytrs_3(int matrix_layout, char uplo, int n, int nrhs, const _Complex double *a, int lda, const _Complex double *e, const int *ipiv, _Complex double *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_zsytrs_3$handle() {
        return LAPACKE_zsytrs_3.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zsytrs_3(int matrix_layout, char uplo, int n, int nrhs, const _Complex double *a, int lda, const _Complex double *e, const int *ipiv, _Complex double *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_zsytrs_3$address() {
        return LAPACKE_zsytrs_3.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zsytrs_3(int matrix_layout, char uplo, int n, int nrhs, const _Complex double *a, int lda, const _Complex double *e, const int *ipiv, _Complex double *b, int ldb)
     * }
     */
    public static int LAPACKE_zsytrs_3(int matrix_layout, byte uplo, int n, int nrhs, MemorySegment a, int lda, MemorySegment e, MemorySegment ipiv, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_zsytrs_3.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zsytrs_3", matrix_layout, uplo, n, nrhs, a, lda, e, ipiv, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, nrhs, a, lda, e, ipiv, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zsytrs_3_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zsytrs_3_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zsytrs_3_work(int matrix_layout, char uplo, int n, int nrhs, const _Complex double *a, int lda, const _Complex double *e, const int *ipiv, _Complex double *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_zsytrs_3_work$descriptor() {
        return LAPACKE_zsytrs_3_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zsytrs_3_work(int matrix_layout, char uplo, int n, int nrhs, const _Complex double *a, int lda, const _Complex double *e, const int *ipiv, _Complex double *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_zsytrs_3_work$handle() {
        return LAPACKE_zsytrs_3_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zsytrs_3_work(int matrix_layout, char uplo, int n, int nrhs, const _Complex double *a, int lda, const _Complex double *e, const int *ipiv, _Complex double *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_zsytrs_3_work$address() {
        return LAPACKE_zsytrs_3_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zsytrs_3_work(int matrix_layout, char uplo, int n, int nrhs, const _Complex double *a, int lda, const _Complex double *e, const int *ipiv, _Complex double *b, int ldb)
     * }
     */
    public static int LAPACKE_zsytrs_3_work(int matrix_layout, byte uplo, int n, int nrhs, MemorySegment a, int lda, MemorySegment e, MemorySegment ipiv, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_zsytrs_3_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zsytrs_3_work", matrix_layout, uplo, n, nrhs, a, lda, e, ipiv, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, nrhs, a, lda, e, ipiv, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zhetrs_3 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zhetrs_3");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zhetrs_3(int matrix_layout, char uplo, int n, int nrhs, const _Complex double *a, int lda, const _Complex double *e, const int *ipiv, _Complex double *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_zhetrs_3$descriptor() {
        return LAPACKE_zhetrs_3.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zhetrs_3(int matrix_layout, char uplo, int n, int nrhs, const _Complex double *a, int lda, const _Complex double *e, const int *ipiv, _Complex double *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_zhetrs_3$handle() {
        return LAPACKE_zhetrs_3.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zhetrs_3(int matrix_layout, char uplo, int n, int nrhs, const _Complex double *a, int lda, const _Complex double *e, const int *ipiv, _Complex double *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_zhetrs_3$address() {
        return LAPACKE_zhetrs_3.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zhetrs_3(int matrix_layout, char uplo, int n, int nrhs, const _Complex double *a, int lda, const _Complex double *e, const int *ipiv, _Complex double *b, int ldb)
     * }
     */
    public static int LAPACKE_zhetrs_3(int matrix_layout, byte uplo, int n, int nrhs, MemorySegment a, int lda, MemorySegment e, MemorySegment ipiv, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_zhetrs_3.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zhetrs_3", matrix_layout, uplo, n, nrhs, a, lda, e, ipiv, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, nrhs, a, lda, e, ipiv, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zhetrs_3_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zhetrs_3_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zhetrs_3_work(int matrix_layout, char uplo, int n, int nrhs, const _Complex double *a, int lda, const _Complex double *e, const int *ipiv, _Complex double *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_zhetrs_3_work$descriptor() {
        return LAPACKE_zhetrs_3_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zhetrs_3_work(int matrix_layout, char uplo, int n, int nrhs, const _Complex double *a, int lda, const _Complex double *e, const int *ipiv, _Complex double *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_zhetrs_3_work$handle() {
        return LAPACKE_zhetrs_3_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zhetrs_3_work(int matrix_layout, char uplo, int n, int nrhs, const _Complex double *a, int lda, const _Complex double *e, const int *ipiv, _Complex double *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_zhetrs_3_work$address() {
        return LAPACKE_zhetrs_3_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zhetrs_3_work(int matrix_layout, char uplo, int n, int nrhs, const _Complex double *a, int lda, const _Complex double *e, const int *ipiv, _Complex double *b, int ldb)
     * }
     */
    public static int LAPACKE_zhetrs_3_work(int matrix_layout, byte uplo, int n, int nrhs, MemorySegment a, int lda, MemorySegment e, MemorySegment ipiv, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_zhetrs_3_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zhetrs_3_work", matrix_layout, uplo, n, nrhs, a, lda, e, ipiv, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, nrhs, a, lda, e, ipiv, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ssytri_3 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_ssytri_3");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ssytri_3(int matrix_layout, char uplo, int n, float *a, int lda, const float *e, const int *ipiv)
     * }
     */
    public static FunctionDescriptor LAPACKE_ssytri_3$descriptor() {
        return LAPACKE_ssytri_3.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ssytri_3(int matrix_layout, char uplo, int n, float *a, int lda, const float *e, const int *ipiv)
     * }
     */
    public static MethodHandle LAPACKE_ssytri_3$handle() {
        return LAPACKE_ssytri_3.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ssytri_3(int matrix_layout, char uplo, int n, float *a, int lda, const float *e, const int *ipiv)
     * }
     */
    public static MemorySegment LAPACKE_ssytri_3$address() {
        return LAPACKE_ssytri_3.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ssytri_3(int matrix_layout, char uplo, int n, float *a, int lda, const float *e, const int *ipiv)
     * }
     */
    public static int LAPACKE_ssytri_3(int matrix_layout, byte uplo, int n, MemorySegment a, int lda, MemorySegment e, MemorySegment ipiv) {
        var mh$ = LAPACKE_ssytri_3.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ssytri_3", matrix_layout, uplo, n, a, lda, e, ipiv);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, a, lda, e, ipiv);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dsytri_3 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dsytri_3");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dsytri_3(int matrix_layout, char uplo, int n, double *a, int lda, const double *e, const int *ipiv)
     * }
     */
    public static FunctionDescriptor LAPACKE_dsytri_3$descriptor() {
        return LAPACKE_dsytri_3.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dsytri_3(int matrix_layout, char uplo, int n, double *a, int lda, const double *e, const int *ipiv)
     * }
     */
    public static MethodHandle LAPACKE_dsytri_3$handle() {
        return LAPACKE_dsytri_3.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dsytri_3(int matrix_layout, char uplo, int n, double *a, int lda, const double *e, const int *ipiv)
     * }
     */
    public static MemorySegment LAPACKE_dsytri_3$address() {
        return LAPACKE_dsytri_3.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dsytri_3(int matrix_layout, char uplo, int n, double *a, int lda, const double *e, const int *ipiv)
     * }
     */
    public static int LAPACKE_dsytri_3(int matrix_layout, byte uplo, int n, MemorySegment a, int lda, MemorySegment e, MemorySegment ipiv) {
        var mh$ = LAPACKE_dsytri_3.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dsytri_3", matrix_layout, uplo, n, a, lda, e, ipiv);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, a, lda, e, ipiv);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_csytri_3 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_csytri_3");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_csytri_3(int matrix_layout, char uplo, int n, _Complex float *a, int lda, const _Complex float *e, const int *ipiv)
     * }
     */
    public static FunctionDescriptor LAPACKE_csytri_3$descriptor() {
        return LAPACKE_csytri_3.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_csytri_3(int matrix_layout, char uplo, int n, _Complex float *a, int lda, const _Complex float *e, const int *ipiv)
     * }
     */
    public static MethodHandle LAPACKE_csytri_3$handle() {
        return LAPACKE_csytri_3.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_csytri_3(int matrix_layout, char uplo, int n, _Complex float *a, int lda, const _Complex float *e, const int *ipiv)
     * }
     */
    public static MemorySegment LAPACKE_csytri_3$address() {
        return LAPACKE_csytri_3.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_csytri_3(int matrix_layout, char uplo, int n, _Complex float *a, int lda, const _Complex float *e, const int *ipiv)
     * }
     */
    public static int LAPACKE_csytri_3(int matrix_layout, byte uplo, int n, MemorySegment a, int lda, MemorySegment e, MemorySegment ipiv) {
        var mh$ = LAPACKE_csytri_3.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_csytri_3", matrix_layout, uplo, n, a, lda, e, ipiv);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, a, lda, e, ipiv);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zsytri_3 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zsytri_3");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zsytri_3(int matrix_layout, char uplo, int n, _Complex double *a, int lda, const _Complex double *e, const int *ipiv)
     * }
     */
    public static FunctionDescriptor LAPACKE_zsytri_3$descriptor() {
        return LAPACKE_zsytri_3.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zsytri_3(int matrix_layout, char uplo, int n, _Complex double *a, int lda, const _Complex double *e, const int *ipiv)
     * }
     */
    public static MethodHandle LAPACKE_zsytri_3$handle() {
        return LAPACKE_zsytri_3.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zsytri_3(int matrix_layout, char uplo, int n, _Complex double *a, int lda, const _Complex double *e, const int *ipiv)
     * }
     */
    public static MemorySegment LAPACKE_zsytri_3$address() {
        return LAPACKE_zsytri_3.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zsytri_3(int matrix_layout, char uplo, int n, _Complex double *a, int lda, const _Complex double *e, const int *ipiv)
     * }
     */
    public static int LAPACKE_zsytri_3(int matrix_layout, byte uplo, int n, MemorySegment a, int lda, MemorySegment e, MemorySegment ipiv) {
        var mh$ = LAPACKE_zsytri_3.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zsytri_3", matrix_layout, uplo, n, a, lda, e, ipiv);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, a, lda, e, ipiv);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_chetri_3 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_chetri_3");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_chetri_3(int matrix_layout, char uplo, int n, _Complex float *a, int lda, const _Complex float *e, const int *ipiv)
     * }
     */
    public static FunctionDescriptor LAPACKE_chetri_3$descriptor() {
        return LAPACKE_chetri_3.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_chetri_3(int matrix_layout, char uplo, int n, _Complex float *a, int lda, const _Complex float *e, const int *ipiv)
     * }
     */
    public static MethodHandle LAPACKE_chetri_3$handle() {
        return LAPACKE_chetri_3.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_chetri_3(int matrix_layout, char uplo, int n, _Complex float *a, int lda, const _Complex float *e, const int *ipiv)
     * }
     */
    public static MemorySegment LAPACKE_chetri_3$address() {
        return LAPACKE_chetri_3.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_chetri_3(int matrix_layout, char uplo, int n, _Complex float *a, int lda, const _Complex float *e, const int *ipiv)
     * }
     */
    public static int LAPACKE_chetri_3(int matrix_layout, byte uplo, int n, MemorySegment a, int lda, MemorySegment e, MemorySegment ipiv) {
        var mh$ = LAPACKE_chetri_3.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_chetri_3", matrix_layout, uplo, n, a, lda, e, ipiv);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, a, lda, e, ipiv);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zhetri_3 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zhetri_3");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zhetri_3(int matrix_layout, char uplo, int n, _Complex double *a, int lda, const _Complex double *e, const int *ipiv)
     * }
     */
    public static FunctionDescriptor LAPACKE_zhetri_3$descriptor() {
        return LAPACKE_zhetri_3.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zhetri_3(int matrix_layout, char uplo, int n, _Complex double *a, int lda, const _Complex double *e, const int *ipiv)
     * }
     */
    public static MethodHandle LAPACKE_zhetri_3$handle() {
        return LAPACKE_zhetri_3.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zhetri_3(int matrix_layout, char uplo, int n, _Complex double *a, int lda, const _Complex double *e, const int *ipiv)
     * }
     */
    public static MemorySegment LAPACKE_zhetri_3$address() {
        return LAPACKE_zhetri_3.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zhetri_3(int matrix_layout, char uplo, int n, _Complex double *a, int lda, const _Complex double *e, const int *ipiv)
     * }
     */
    public static int LAPACKE_zhetri_3(int matrix_layout, byte uplo, int n, MemorySegment a, int lda, MemorySegment e, MemorySegment ipiv) {
        var mh$ = LAPACKE_zhetri_3.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zhetri_3", matrix_layout, uplo, n, a, lda, e, ipiv);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, a, lda, e, ipiv);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ssytri_3_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_ssytri_3_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ssytri_3_work(int matrix_layout, char uplo, int n, float *a, int lda, const float *e, const int *ipiv, float *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_ssytri_3_work$descriptor() {
        return LAPACKE_ssytri_3_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ssytri_3_work(int matrix_layout, char uplo, int n, float *a, int lda, const float *e, const int *ipiv, float *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_ssytri_3_work$handle() {
        return LAPACKE_ssytri_3_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ssytri_3_work(int matrix_layout, char uplo, int n, float *a, int lda, const float *e, const int *ipiv, float *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_ssytri_3_work$address() {
        return LAPACKE_ssytri_3_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ssytri_3_work(int matrix_layout, char uplo, int n, float *a, int lda, const float *e, const int *ipiv, float *work, int lwork)
     * }
     */
    public static int LAPACKE_ssytri_3_work(int matrix_layout, byte uplo, int n, MemorySegment a, int lda, MemorySegment e, MemorySegment ipiv, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_ssytri_3_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ssytri_3_work", matrix_layout, uplo, n, a, lda, e, ipiv, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, a, lda, e, ipiv, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dsytri_3_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dsytri_3_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dsytri_3_work(int matrix_layout, char uplo, int n, double *a, int lda, const double *e, const int *ipiv, double *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_dsytri_3_work$descriptor() {
        return LAPACKE_dsytri_3_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dsytri_3_work(int matrix_layout, char uplo, int n, double *a, int lda, const double *e, const int *ipiv, double *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_dsytri_3_work$handle() {
        return LAPACKE_dsytri_3_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dsytri_3_work(int matrix_layout, char uplo, int n, double *a, int lda, const double *e, const int *ipiv, double *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_dsytri_3_work$address() {
        return LAPACKE_dsytri_3_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dsytri_3_work(int matrix_layout, char uplo, int n, double *a, int lda, const double *e, const int *ipiv, double *work, int lwork)
     * }
     */
    public static int LAPACKE_dsytri_3_work(int matrix_layout, byte uplo, int n, MemorySegment a, int lda, MemorySegment e, MemorySegment ipiv, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_dsytri_3_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dsytri_3_work", matrix_layout, uplo, n, a, lda, e, ipiv, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, a, lda, e, ipiv, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_csytri_3_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_csytri_3_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_csytri_3_work(int matrix_layout, char uplo, int n, _Complex float *a, int lda, const _Complex float *e, const int *ipiv, _Complex float *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_csytri_3_work$descriptor() {
        return LAPACKE_csytri_3_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_csytri_3_work(int matrix_layout, char uplo, int n, _Complex float *a, int lda, const _Complex float *e, const int *ipiv, _Complex float *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_csytri_3_work$handle() {
        return LAPACKE_csytri_3_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_csytri_3_work(int matrix_layout, char uplo, int n, _Complex float *a, int lda, const _Complex float *e, const int *ipiv, _Complex float *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_csytri_3_work$address() {
        return LAPACKE_csytri_3_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_csytri_3_work(int matrix_layout, char uplo, int n, _Complex float *a, int lda, const _Complex float *e, const int *ipiv, _Complex float *work, int lwork)
     * }
     */
    public static int LAPACKE_csytri_3_work(int matrix_layout, byte uplo, int n, MemorySegment a, int lda, MemorySegment e, MemorySegment ipiv, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_csytri_3_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_csytri_3_work", matrix_layout, uplo, n, a, lda, e, ipiv, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, a, lda, e, ipiv, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zsytri_3_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zsytri_3_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zsytri_3_work(int matrix_layout, char uplo, int n, _Complex double *a, int lda, const _Complex double *e, const int *ipiv, _Complex double *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_zsytri_3_work$descriptor() {
        return LAPACKE_zsytri_3_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zsytri_3_work(int matrix_layout, char uplo, int n, _Complex double *a, int lda, const _Complex double *e, const int *ipiv, _Complex double *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_zsytri_3_work$handle() {
        return LAPACKE_zsytri_3_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zsytri_3_work(int matrix_layout, char uplo, int n, _Complex double *a, int lda, const _Complex double *e, const int *ipiv, _Complex double *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_zsytri_3_work$address() {
        return LAPACKE_zsytri_3_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zsytri_3_work(int matrix_layout, char uplo, int n, _Complex double *a, int lda, const _Complex double *e, const int *ipiv, _Complex double *work, int lwork)
     * }
     */
    public static int LAPACKE_zsytri_3_work(int matrix_layout, byte uplo, int n, MemorySegment a, int lda, MemorySegment e, MemorySegment ipiv, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_zsytri_3_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zsytri_3_work", matrix_layout, uplo, n, a, lda, e, ipiv, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, a, lda, e, ipiv, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_chetri_3_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_chetri_3_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_chetri_3_work(int matrix_layout, char uplo, int n, _Complex float *a, int lda, const _Complex float *e, const int *ipiv, _Complex float *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_chetri_3_work$descriptor() {
        return LAPACKE_chetri_3_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_chetri_3_work(int matrix_layout, char uplo, int n, _Complex float *a, int lda, const _Complex float *e, const int *ipiv, _Complex float *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_chetri_3_work$handle() {
        return LAPACKE_chetri_3_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_chetri_3_work(int matrix_layout, char uplo, int n, _Complex float *a, int lda, const _Complex float *e, const int *ipiv, _Complex float *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_chetri_3_work$address() {
        return LAPACKE_chetri_3_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_chetri_3_work(int matrix_layout, char uplo, int n, _Complex float *a, int lda, const _Complex float *e, const int *ipiv, _Complex float *work, int lwork)
     * }
     */
    public static int LAPACKE_chetri_3_work(int matrix_layout, byte uplo, int n, MemorySegment a, int lda, MemorySegment e, MemorySegment ipiv, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_chetri_3_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_chetri_3_work", matrix_layout, uplo, n, a, lda, e, ipiv, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, a, lda, e, ipiv, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zhetri_3_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zhetri_3_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zhetri_3_work(int matrix_layout, char uplo, int n, _Complex double *a, int lda, const _Complex double *e, const int *ipiv, _Complex double *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_zhetri_3_work$descriptor() {
        return LAPACKE_zhetri_3_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zhetri_3_work(int matrix_layout, char uplo, int n, _Complex double *a, int lda, const _Complex double *e, const int *ipiv, _Complex double *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_zhetri_3_work$handle() {
        return LAPACKE_zhetri_3_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zhetri_3_work(int matrix_layout, char uplo, int n, _Complex double *a, int lda, const _Complex double *e, const int *ipiv, _Complex double *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_zhetri_3_work$address() {
        return LAPACKE_zhetri_3_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zhetri_3_work(int matrix_layout, char uplo, int n, _Complex double *a, int lda, const _Complex double *e, const int *ipiv, _Complex double *work, int lwork)
     * }
     */
    public static int LAPACKE_zhetri_3_work(int matrix_layout, byte uplo, int n, MemorySegment a, int lda, MemorySegment e, MemorySegment ipiv, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_zhetri_3_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zhetri_3_work", matrix_layout, uplo, n, a, lda, e, ipiv, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, a, lda, e, ipiv, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ssycon_3 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_ssycon_3");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ssycon_3(int matrix_layout, char uplo, int n, const float *a, int lda, const float *e, const int *ipiv, float anorm, float *rcond)
     * }
     */
    public static FunctionDescriptor LAPACKE_ssycon_3$descriptor() {
        return LAPACKE_ssycon_3.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ssycon_3(int matrix_layout, char uplo, int n, const float *a, int lda, const float *e, const int *ipiv, float anorm, float *rcond)
     * }
     */
    public static MethodHandle LAPACKE_ssycon_3$handle() {
        return LAPACKE_ssycon_3.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ssycon_3(int matrix_layout, char uplo, int n, const float *a, int lda, const float *e, const int *ipiv, float anorm, float *rcond)
     * }
     */
    public static MemorySegment LAPACKE_ssycon_3$address() {
        return LAPACKE_ssycon_3.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ssycon_3(int matrix_layout, char uplo, int n, const float *a, int lda, const float *e, const int *ipiv, float anorm, float *rcond)
     * }
     */
    public static int LAPACKE_ssycon_3(int matrix_layout, byte uplo, int n, MemorySegment a, int lda, MemorySegment e, MemorySegment ipiv, float anorm, MemorySegment rcond) {
        var mh$ = LAPACKE_ssycon_3.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ssycon_3", matrix_layout, uplo, n, a, lda, e, ipiv, anorm, rcond);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, a, lda, e, ipiv, anorm, rcond);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dsycon_3 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dsycon_3");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dsycon_3(int matrix_layout, char uplo, int n, const double *a, int lda, const double *e, const int *ipiv, double anorm, double *rcond)
     * }
     */
    public static FunctionDescriptor LAPACKE_dsycon_3$descriptor() {
        return LAPACKE_dsycon_3.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dsycon_3(int matrix_layout, char uplo, int n, const double *a, int lda, const double *e, const int *ipiv, double anorm, double *rcond)
     * }
     */
    public static MethodHandle LAPACKE_dsycon_3$handle() {
        return LAPACKE_dsycon_3.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dsycon_3(int matrix_layout, char uplo, int n, const double *a, int lda, const double *e, const int *ipiv, double anorm, double *rcond)
     * }
     */
    public static MemorySegment LAPACKE_dsycon_3$address() {
        return LAPACKE_dsycon_3.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dsycon_3(int matrix_layout, char uplo, int n, const double *a, int lda, const double *e, const int *ipiv, double anorm, double *rcond)
     * }
     */
    public static int LAPACKE_dsycon_3(int matrix_layout, byte uplo, int n, MemorySegment a, int lda, MemorySegment e, MemorySegment ipiv, double anorm, MemorySegment rcond) {
        var mh$ = LAPACKE_dsycon_3.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dsycon_3", matrix_layout, uplo, n, a, lda, e, ipiv, anorm, rcond);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, a, lda, e, ipiv, anorm, rcond);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_csycon_3 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_csycon_3");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_csycon_3(int matrix_layout, char uplo, int n, const _Complex float *a, int lda, const _Complex float *e, const int *ipiv, float anorm, float *rcond)
     * }
     */
    public static FunctionDescriptor LAPACKE_csycon_3$descriptor() {
        return LAPACKE_csycon_3.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_csycon_3(int matrix_layout, char uplo, int n, const _Complex float *a, int lda, const _Complex float *e, const int *ipiv, float anorm, float *rcond)
     * }
     */
    public static MethodHandle LAPACKE_csycon_3$handle() {
        return LAPACKE_csycon_3.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_csycon_3(int matrix_layout, char uplo, int n, const _Complex float *a, int lda, const _Complex float *e, const int *ipiv, float anorm, float *rcond)
     * }
     */
    public static MemorySegment LAPACKE_csycon_3$address() {
        return LAPACKE_csycon_3.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_csycon_3(int matrix_layout, char uplo, int n, const _Complex float *a, int lda, const _Complex float *e, const int *ipiv, float anorm, float *rcond)
     * }
     */
    public static int LAPACKE_csycon_3(int matrix_layout, byte uplo, int n, MemorySegment a, int lda, MemorySegment e, MemorySegment ipiv, float anorm, MemorySegment rcond) {
        var mh$ = LAPACKE_csycon_3.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_csycon_3", matrix_layout, uplo, n, a, lda, e, ipiv, anorm, rcond);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, a, lda, e, ipiv, anorm, rcond);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zsycon_3 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zsycon_3");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zsycon_3(int matrix_layout, char uplo, int n, const _Complex double *a, int lda, const _Complex double *e, const int *ipiv, double anorm, double *rcond)
     * }
     */
    public static FunctionDescriptor LAPACKE_zsycon_3$descriptor() {
        return LAPACKE_zsycon_3.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zsycon_3(int matrix_layout, char uplo, int n, const _Complex double *a, int lda, const _Complex double *e, const int *ipiv, double anorm, double *rcond)
     * }
     */
    public static MethodHandle LAPACKE_zsycon_3$handle() {
        return LAPACKE_zsycon_3.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zsycon_3(int matrix_layout, char uplo, int n, const _Complex double *a, int lda, const _Complex double *e, const int *ipiv, double anorm, double *rcond)
     * }
     */
    public static MemorySegment LAPACKE_zsycon_3$address() {
        return LAPACKE_zsycon_3.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zsycon_3(int matrix_layout, char uplo, int n, const _Complex double *a, int lda, const _Complex double *e, const int *ipiv, double anorm, double *rcond)
     * }
     */
    public static int LAPACKE_zsycon_3(int matrix_layout, byte uplo, int n, MemorySegment a, int lda, MemorySegment e, MemorySegment ipiv, double anorm, MemorySegment rcond) {
        var mh$ = LAPACKE_zsycon_3.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zsycon_3", matrix_layout, uplo, n, a, lda, e, ipiv, anorm, rcond);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, a, lda, e, ipiv, anorm, rcond);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_checon_3 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_checon_3");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_checon_3(int matrix_layout, char uplo, int n, const _Complex float *a, int lda, const _Complex float *e, const int *ipiv, float anorm, float *rcond)
     * }
     */
    public static FunctionDescriptor LAPACKE_checon_3$descriptor() {
        return LAPACKE_checon_3.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_checon_3(int matrix_layout, char uplo, int n, const _Complex float *a, int lda, const _Complex float *e, const int *ipiv, float anorm, float *rcond)
     * }
     */
    public static MethodHandle LAPACKE_checon_3$handle() {
        return LAPACKE_checon_3.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_checon_3(int matrix_layout, char uplo, int n, const _Complex float *a, int lda, const _Complex float *e, const int *ipiv, float anorm, float *rcond)
     * }
     */
    public static MemorySegment LAPACKE_checon_3$address() {
        return LAPACKE_checon_3.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_checon_3(int matrix_layout, char uplo, int n, const _Complex float *a, int lda, const _Complex float *e, const int *ipiv, float anorm, float *rcond)
     * }
     */
    public static int LAPACKE_checon_3(int matrix_layout, byte uplo, int n, MemorySegment a, int lda, MemorySegment e, MemorySegment ipiv, float anorm, MemorySegment rcond) {
        var mh$ = LAPACKE_checon_3.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_checon_3", matrix_layout, uplo, n, a, lda, e, ipiv, anorm, rcond);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, a, lda, e, ipiv, anorm, rcond);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zhecon_3 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zhecon_3");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zhecon_3(int matrix_layout, char uplo, int n, const _Complex double *a, int lda, const _Complex double *e, const int *ipiv, double anorm, double *rcond)
     * }
     */
    public static FunctionDescriptor LAPACKE_zhecon_3$descriptor() {
        return LAPACKE_zhecon_3.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zhecon_3(int matrix_layout, char uplo, int n, const _Complex double *a, int lda, const _Complex double *e, const int *ipiv, double anorm, double *rcond)
     * }
     */
    public static MethodHandle LAPACKE_zhecon_3$handle() {
        return LAPACKE_zhecon_3.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zhecon_3(int matrix_layout, char uplo, int n, const _Complex double *a, int lda, const _Complex double *e, const int *ipiv, double anorm, double *rcond)
     * }
     */
    public static MemorySegment LAPACKE_zhecon_3$address() {
        return LAPACKE_zhecon_3.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zhecon_3(int matrix_layout, char uplo, int n, const _Complex double *a, int lda, const _Complex double *e, const int *ipiv, double anorm, double *rcond)
     * }
     */
    public static int LAPACKE_zhecon_3(int matrix_layout, byte uplo, int n, MemorySegment a, int lda, MemorySegment e, MemorySegment ipiv, double anorm, MemorySegment rcond) {
        var mh$ = LAPACKE_zhecon_3.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zhecon_3", matrix_layout, uplo, n, a, lda, e, ipiv, anorm, rcond);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, a, lda, e, ipiv, anorm, rcond);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ssycon_3_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_ssycon_3_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ssycon_3_work(int matrix_layout, char uplo, int n, const float *a, int lda, const float *e, const int *ipiv, float anorm, float *rcond, float *work, int *iwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_ssycon_3_work$descriptor() {
        return LAPACKE_ssycon_3_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ssycon_3_work(int matrix_layout, char uplo, int n, const float *a, int lda, const float *e, const int *ipiv, float anorm, float *rcond, float *work, int *iwork)
     * }
     */
    public static MethodHandle LAPACKE_ssycon_3_work$handle() {
        return LAPACKE_ssycon_3_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ssycon_3_work(int matrix_layout, char uplo, int n, const float *a, int lda, const float *e, const int *ipiv, float anorm, float *rcond, float *work, int *iwork)
     * }
     */
    public static MemorySegment LAPACKE_ssycon_3_work$address() {
        return LAPACKE_ssycon_3_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ssycon_3_work(int matrix_layout, char uplo, int n, const float *a, int lda, const float *e, const int *ipiv, float anorm, float *rcond, float *work, int *iwork)
     * }
     */
    public static int LAPACKE_ssycon_3_work(int matrix_layout, byte uplo, int n, MemorySegment a, int lda, MemorySegment e, MemorySegment ipiv, float anorm, MemorySegment rcond, MemorySegment work, MemorySegment iwork) {
        var mh$ = LAPACKE_ssycon_3_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ssycon_3_work", matrix_layout, uplo, n, a, lda, e, ipiv, anorm, rcond, work, iwork);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, a, lda, e, ipiv, anorm, rcond, work, iwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dsycon_3_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dsycon_3_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dsycon_3_work(int matrix_layout, char uplo, int n, const double *a, int lda, const double *e, const int *ipiv, double anorm, double *rcond, double *work, int *iwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_dsycon_3_work$descriptor() {
        return LAPACKE_dsycon_3_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dsycon_3_work(int matrix_layout, char uplo, int n, const double *a, int lda, const double *e, const int *ipiv, double anorm, double *rcond, double *work, int *iwork)
     * }
     */
    public static MethodHandle LAPACKE_dsycon_3_work$handle() {
        return LAPACKE_dsycon_3_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dsycon_3_work(int matrix_layout, char uplo, int n, const double *a, int lda, const double *e, const int *ipiv, double anorm, double *rcond, double *work, int *iwork)
     * }
     */
    public static MemorySegment LAPACKE_dsycon_3_work$address() {
        return LAPACKE_dsycon_3_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dsycon_3_work(int matrix_layout, char uplo, int n, const double *a, int lda, const double *e, const int *ipiv, double anorm, double *rcond, double *work, int *iwork)
     * }
     */
    public static int LAPACKE_dsycon_3_work(int matrix_layout, byte uplo, int n, MemorySegment a, int lda, MemorySegment e, MemorySegment ipiv, double anorm, MemorySegment rcond, MemorySegment work, MemorySegment iwork) {
        var mh$ = LAPACKE_dsycon_3_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dsycon_3_work", matrix_layout, uplo, n, a, lda, e, ipiv, anorm, rcond, work, iwork);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, a, lda, e, ipiv, anorm, rcond, work, iwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_csycon_3_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_csycon_3_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_csycon_3_work(int matrix_layout, char uplo, int n, const _Complex float *a, int lda, const _Complex float *e, const int *ipiv, float anorm, float *rcond, _Complex float *work)
     * }
     */
    public static FunctionDescriptor LAPACKE_csycon_3_work$descriptor() {
        return LAPACKE_csycon_3_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_csycon_3_work(int matrix_layout, char uplo, int n, const _Complex float *a, int lda, const _Complex float *e, const int *ipiv, float anorm, float *rcond, _Complex float *work)
     * }
     */
    public static MethodHandle LAPACKE_csycon_3_work$handle() {
        return LAPACKE_csycon_3_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_csycon_3_work(int matrix_layout, char uplo, int n, const _Complex float *a, int lda, const _Complex float *e, const int *ipiv, float anorm, float *rcond, _Complex float *work)
     * }
     */
    public static MemorySegment LAPACKE_csycon_3_work$address() {
        return LAPACKE_csycon_3_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_csycon_3_work(int matrix_layout, char uplo, int n, const _Complex float *a, int lda, const _Complex float *e, const int *ipiv, float anorm, float *rcond, _Complex float *work)
     * }
     */
    public static int LAPACKE_csycon_3_work(int matrix_layout, byte uplo, int n, MemorySegment a, int lda, MemorySegment e, MemorySegment ipiv, float anorm, MemorySegment rcond, MemorySegment work) {
        var mh$ = LAPACKE_csycon_3_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_csycon_3_work", matrix_layout, uplo, n, a, lda, e, ipiv, anorm, rcond, work);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, a, lda, e, ipiv, anorm, rcond, work);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zsycon_3_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zsycon_3_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zsycon_3_work(int matrix_layout, char uplo, int n, const _Complex double *a, int lda, const _Complex double *e, const int *ipiv, double anorm, double *rcond, _Complex double *work)
     * }
     */
    public static FunctionDescriptor LAPACKE_zsycon_3_work$descriptor() {
        return LAPACKE_zsycon_3_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zsycon_3_work(int matrix_layout, char uplo, int n, const _Complex double *a, int lda, const _Complex double *e, const int *ipiv, double anorm, double *rcond, _Complex double *work)
     * }
     */
    public static MethodHandle LAPACKE_zsycon_3_work$handle() {
        return LAPACKE_zsycon_3_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zsycon_3_work(int matrix_layout, char uplo, int n, const _Complex double *a, int lda, const _Complex double *e, const int *ipiv, double anorm, double *rcond, _Complex double *work)
     * }
     */
    public static MemorySegment LAPACKE_zsycon_3_work$address() {
        return LAPACKE_zsycon_3_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zsycon_3_work(int matrix_layout, char uplo, int n, const _Complex double *a, int lda, const _Complex double *e, const int *ipiv, double anorm, double *rcond, _Complex double *work)
     * }
     */
    public static int LAPACKE_zsycon_3_work(int matrix_layout, byte uplo, int n, MemorySegment a, int lda, MemorySegment e, MemorySegment ipiv, double anorm, MemorySegment rcond, MemorySegment work) {
        var mh$ = LAPACKE_zsycon_3_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zsycon_3_work", matrix_layout, uplo, n, a, lda, e, ipiv, anorm, rcond, work);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, a, lda, e, ipiv, anorm, rcond, work);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_checon_3_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_checon_3_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_checon_3_work(int matrix_layout, char uplo, int n, const _Complex float *a, int lda, const _Complex float *e, const int *ipiv, float anorm, float *rcond, _Complex float *work)
     * }
     */
    public static FunctionDescriptor LAPACKE_checon_3_work$descriptor() {
        return LAPACKE_checon_3_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_checon_3_work(int matrix_layout, char uplo, int n, const _Complex float *a, int lda, const _Complex float *e, const int *ipiv, float anorm, float *rcond, _Complex float *work)
     * }
     */
    public static MethodHandle LAPACKE_checon_3_work$handle() {
        return LAPACKE_checon_3_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_checon_3_work(int matrix_layout, char uplo, int n, const _Complex float *a, int lda, const _Complex float *e, const int *ipiv, float anorm, float *rcond, _Complex float *work)
     * }
     */
    public static MemorySegment LAPACKE_checon_3_work$address() {
        return LAPACKE_checon_3_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_checon_3_work(int matrix_layout, char uplo, int n, const _Complex float *a, int lda, const _Complex float *e, const int *ipiv, float anorm, float *rcond, _Complex float *work)
     * }
     */
    public static int LAPACKE_checon_3_work(int matrix_layout, byte uplo, int n, MemorySegment a, int lda, MemorySegment e, MemorySegment ipiv, float anorm, MemorySegment rcond, MemorySegment work) {
        var mh$ = LAPACKE_checon_3_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_checon_3_work", matrix_layout, uplo, n, a, lda, e, ipiv, anorm, rcond, work);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, a, lda, e, ipiv, anorm, rcond, work);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zhecon_3_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zhecon_3_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zhecon_3_work(int matrix_layout, char uplo, int n, const _Complex double *a, int lda, const _Complex double *e, const int *ipiv, double anorm, double *rcond, _Complex double *work)
     * }
     */
    public static FunctionDescriptor LAPACKE_zhecon_3_work$descriptor() {
        return LAPACKE_zhecon_3_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zhecon_3_work(int matrix_layout, char uplo, int n, const _Complex double *a, int lda, const _Complex double *e, const int *ipiv, double anorm, double *rcond, _Complex double *work)
     * }
     */
    public static MethodHandle LAPACKE_zhecon_3_work$handle() {
        return LAPACKE_zhecon_3_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zhecon_3_work(int matrix_layout, char uplo, int n, const _Complex double *a, int lda, const _Complex double *e, const int *ipiv, double anorm, double *rcond, _Complex double *work)
     * }
     */
    public static MemorySegment LAPACKE_zhecon_3_work$address() {
        return LAPACKE_zhecon_3_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zhecon_3_work(int matrix_layout, char uplo, int n, const _Complex double *a, int lda, const _Complex double *e, const int *ipiv, double anorm, double *rcond, _Complex double *work)
     * }
     */
    public static int LAPACKE_zhecon_3_work(int matrix_layout, byte uplo, int n, MemorySegment a, int lda, MemorySegment e, MemorySegment ipiv, double anorm, MemorySegment rcond, MemorySegment work) {
        var mh$ = LAPACKE_zhecon_3_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zhecon_3_work", matrix_layout, uplo, n, a, lda, e, ipiv, anorm, rcond, work);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, a, lda, e, ipiv, anorm, rcond, work);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sgelq {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_sgelq");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sgelq(int matrix_layout, int m, int n, float *a, int lda, float *t, int tsize)
     * }
     */
    public static FunctionDescriptor LAPACKE_sgelq$descriptor() {
        return LAPACKE_sgelq.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sgelq(int matrix_layout, int m, int n, float *a, int lda, float *t, int tsize)
     * }
     */
    public static MethodHandle LAPACKE_sgelq$handle() {
        return LAPACKE_sgelq.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sgelq(int matrix_layout, int m, int n, float *a, int lda, float *t, int tsize)
     * }
     */
    public static MemorySegment LAPACKE_sgelq$address() {
        return LAPACKE_sgelq.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sgelq(int matrix_layout, int m, int n, float *a, int lda, float *t, int tsize)
     * }
     */
    public static int LAPACKE_sgelq(int matrix_layout, int m, int n, MemorySegment a, int lda, MemorySegment t, int tsize) {
        var mh$ = LAPACKE_sgelq.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sgelq", matrix_layout, m, n, a, lda, t, tsize);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, a, lda, t, tsize);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dgelq {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dgelq");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dgelq(int matrix_layout, int m, int n, double *a, int lda, double *t, int tsize)
     * }
     */
    public static FunctionDescriptor LAPACKE_dgelq$descriptor() {
        return LAPACKE_dgelq.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dgelq(int matrix_layout, int m, int n, double *a, int lda, double *t, int tsize)
     * }
     */
    public static MethodHandle LAPACKE_dgelq$handle() {
        return LAPACKE_dgelq.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dgelq(int matrix_layout, int m, int n, double *a, int lda, double *t, int tsize)
     * }
     */
    public static MemorySegment LAPACKE_dgelq$address() {
        return LAPACKE_dgelq.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dgelq(int matrix_layout, int m, int n, double *a, int lda, double *t, int tsize)
     * }
     */
    public static int LAPACKE_dgelq(int matrix_layout, int m, int n, MemorySegment a, int lda, MemorySegment t, int tsize) {
        var mh$ = LAPACKE_dgelq.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dgelq", matrix_layout, m, n, a, lda, t, tsize);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, a, lda, t, tsize);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cgelq {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_cgelq");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cgelq(int matrix_layout, int m, int n, _Complex float *a, int lda, _Complex float *t, int tsize)
     * }
     */
    public static FunctionDescriptor LAPACKE_cgelq$descriptor() {
        return LAPACKE_cgelq.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cgelq(int matrix_layout, int m, int n, _Complex float *a, int lda, _Complex float *t, int tsize)
     * }
     */
    public static MethodHandle LAPACKE_cgelq$handle() {
        return LAPACKE_cgelq.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cgelq(int matrix_layout, int m, int n, _Complex float *a, int lda, _Complex float *t, int tsize)
     * }
     */
    public static MemorySegment LAPACKE_cgelq$address() {
        return LAPACKE_cgelq.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cgelq(int matrix_layout, int m, int n, _Complex float *a, int lda, _Complex float *t, int tsize)
     * }
     */
    public static int LAPACKE_cgelq(int matrix_layout, int m, int n, MemorySegment a, int lda, MemorySegment t, int tsize) {
        var mh$ = LAPACKE_cgelq.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cgelq", matrix_layout, m, n, a, lda, t, tsize);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, a, lda, t, tsize);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zgelq {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zgelq");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zgelq(int matrix_layout, int m, int n, _Complex double *a, int lda, _Complex double *t, int tsize)
     * }
     */
    public static FunctionDescriptor LAPACKE_zgelq$descriptor() {
        return LAPACKE_zgelq.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zgelq(int matrix_layout, int m, int n, _Complex double *a, int lda, _Complex double *t, int tsize)
     * }
     */
    public static MethodHandle LAPACKE_zgelq$handle() {
        return LAPACKE_zgelq.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zgelq(int matrix_layout, int m, int n, _Complex double *a, int lda, _Complex double *t, int tsize)
     * }
     */
    public static MemorySegment LAPACKE_zgelq$address() {
        return LAPACKE_zgelq.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zgelq(int matrix_layout, int m, int n, _Complex double *a, int lda, _Complex double *t, int tsize)
     * }
     */
    public static int LAPACKE_zgelq(int matrix_layout, int m, int n, MemorySegment a, int lda, MemorySegment t, int tsize) {
        var mh$ = LAPACKE_zgelq.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zgelq", matrix_layout, m, n, a, lda, t, tsize);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, a, lda, t, tsize);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sgelq_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_sgelq_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sgelq_work(int matrix_layout, int m, int n, float *a, int lda, float *t, int tsize, float *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_sgelq_work$descriptor() {
        return LAPACKE_sgelq_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sgelq_work(int matrix_layout, int m, int n, float *a, int lda, float *t, int tsize, float *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_sgelq_work$handle() {
        return LAPACKE_sgelq_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sgelq_work(int matrix_layout, int m, int n, float *a, int lda, float *t, int tsize, float *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_sgelq_work$address() {
        return LAPACKE_sgelq_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sgelq_work(int matrix_layout, int m, int n, float *a, int lda, float *t, int tsize, float *work, int lwork)
     * }
     */
    public static int LAPACKE_sgelq_work(int matrix_layout, int m, int n, MemorySegment a, int lda, MemorySegment t, int tsize, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_sgelq_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sgelq_work", matrix_layout, m, n, a, lda, t, tsize, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, a, lda, t, tsize, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dgelq_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dgelq_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dgelq_work(int matrix_layout, int m, int n, double *a, int lda, double *t, int tsize, double *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_dgelq_work$descriptor() {
        return LAPACKE_dgelq_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dgelq_work(int matrix_layout, int m, int n, double *a, int lda, double *t, int tsize, double *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_dgelq_work$handle() {
        return LAPACKE_dgelq_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dgelq_work(int matrix_layout, int m, int n, double *a, int lda, double *t, int tsize, double *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_dgelq_work$address() {
        return LAPACKE_dgelq_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dgelq_work(int matrix_layout, int m, int n, double *a, int lda, double *t, int tsize, double *work, int lwork)
     * }
     */
    public static int LAPACKE_dgelq_work(int matrix_layout, int m, int n, MemorySegment a, int lda, MemorySegment t, int tsize, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_dgelq_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dgelq_work", matrix_layout, m, n, a, lda, t, tsize, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, a, lda, t, tsize, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cgelq_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_cgelq_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cgelq_work(int matrix_layout, int m, int n, _Complex float *a, int lda, _Complex float *t, int tsize, _Complex float *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_cgelq_work$descriptor() {
        return LAPACKE_cgelq_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cgelq_work(int matrix_layout, int m, int n, _Complex float *a, int lda, _Complex float *t, int tsize, _Complex float *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_cgelq_work$handle() {
        return LAPACKE_cgelq_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cgelq_work(int matrix_layout, int m, int n, _Complex float *a, int lda, _Complex float *t, int tsize, _Complex float *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_cgelq_work$address() {
        return LAPACKE_cgelq_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cgelq_work(int matrix_layout, int m, int n, _Complex float *a, int lda, _Complex float *t, int tsize, _Complex float *work, int lwork)
     * }
     */
    public static int LAPACKE_cgelq_work(int matrix_layout, int m, int n, MemorySegment a, int lda, MemorySegment t, int tsize, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_cgelq_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cgelq_work", matrix_layout, m, n, a, lda, t, tsize, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, a, lda, t, tsize, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zgelq_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zgelq_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zgelq_work(int matrix_layout, int m, int n, _Complex double *a, int lda, _Complex double *t, int tsize, _Complex double *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_zgelq_work$descriptor() {
        return LAPACKE_zgelq_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zgelq_work(int matrix_layout, int m, int n, _Complex double *a, int lda, _Complex double *t, int tsize, _Complex double *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_zgelq_work$handle() {
        return LAPACKE_zgelq_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zgelq_work(int matrix_layout, int m, int n, _Complex double *a, int lda, _Complex double *t, int tsize, _Complex double *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_zgelq_work$address() {
        return LAPACKE_zgelq_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zgelq_work(int matrix_layout, int m, int n, _Complex double *a, int lda, _Complex double *t, int tsize, _Complex double *work, int lwork)
     * }
     */
    public static int LAPACKE_zgelq_work(int matrix_layout, int m, int n, MemorySegment a, int lda, MemorySegment t, int tsize, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_zgelq_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zgelq_work", matrix_layout, m, n, a, lda, t, tsize, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, a, lda, t, tsize, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sgemlq {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_sgemlq");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sgemlq(int matrix_layout, char side, char trans, int m, int n, int k, const float *a, int lda, const float *t, int tsize, float *c, int ldc)
     * }
     */
    public static FunctionDescriptor LAPACKE_sgemlq$descriptor() {
        return LAPACKE_sgemlq.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sgemlq(int matrix_layout, char side, char trans, int m, int n, int k, const float *a, int lda, const float *t, int tsize, float *c, int ldc)
     * }
     */
    public static MethodHandle LAPACKE_sgemlq$handle() {
        return LAPACKE_sgemlq.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sgemlq(int matrix_layout, char side, char trans, int m, int n, int k, const float *a, int lda, const float *t, int tsize, float *c, int ldc)
     * }
     */
    public static MemorySegment LAPACKE_sgemlq$address() {
        return LAPACKE_sgemlq.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sgemlq(int matrix_layout, char side, char trans, int m, int n, int k, const float *a, int lda, const float *t, int tsize, float *c, int ldc)
     * }
     */
    public static int LAPACKE_sgemlq(int matrix_layout, byte side, byte trans, int m, int n, int k, MemorySegment a, int lda, MemorySegment t, int tsize, MemorySegment c, int ldc) {
        var mh$ = LAPACKE_sgemlq.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sgemlq", matrix_layout, side, trans, m, n, k, a, lda, t, tsize, c, ldc);
            }
            return (int)mh$.invokeExact(matrix_layout, side, trans, m, n, k, a, lda, t, tsize, c, ldc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dgemlq {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dgemlq");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dgemlq(int matrix_layout, char side, char trans, int m, int n, int k, const double *a, int lda, const double *t, int tsize, double *c, int ldc)
     * }
     */
    public static FunctionDescriptor LAPACKE_dgemlq$descriptor() {
        return LAPACKE_dgemlq.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dgemlq(int matrix_layout, char side, char trans, int m, int n, int k, const double *a, int lda, const double *t, int tsize, double *c, int ldc)
     * }
     */
    public static MethodHandle LAPACKE_dgemlq$handle() {
        return LAPACKE_dgemlq.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dgemlq(int matrix_layout, char side, char trans, int m, int n, int k, const double *a, int lda, const double *t, int tsize, double *c, int ldc)
     * }
     */
    public static MemorySegment LAPACKE_dgemlq$address() {
        return LAPACKE_dgemlq.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dgemlq(int matrix_layout, char side, char trans, int m, int n, int k, const double *a, int lda, const double *t, int tsize, double *c, int ldc)
     * }
     */
    public static int LAPACKE_dgemlq(int matrix_layout, byte side, byte trans, int m, int n, int k, MemorySegment a, int lda, MemorySegment t, int tsize, MemorySegment c, int ldc) {
        var mh$ = LAPACKE_dgemlq.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dgemlq", matrix_layout, side, trans, m, n, k, a, lda, t, tsize, c, ldc);
            }
            return (int)mh$.invokeExact(matrix_layout, side, trans, m, n, k, a, lda, t, tsize, c, ldc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cgemlq {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_cgemlq");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cgemlq(int matrix_layout, char side, char trans, int m, int n, int k, const _Complex float *a, int lda, const _Complex float *t, int tsize, _Complex float *c, int ldc)
     * }
     */
    public static FunctionDescriptor LAPACKE_cgemlq$descriptor() {
        return LAPACKE_cgemlq.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cgemlq(int matrix_layout, char side, char trans, int m, int n, int k, const _Complex float *a, int lda, const _Complex float *t, int tsize, _Complex float *c, int ldc)
     * }
     */
    public static MethodHandle LAPACKE_cgemlq$handle() {
        return LAPACKE_cgemlq.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cgemlq(int matrix_layout, char side, char trans, int m, int n, int k, const _Complex float *a, int lda, const _Complex float *t, int tsize, _Complex float *c, int ldc)
     * }
     */
    public static MemorySegment LAPACKE_cgemlq$address() {
        return LAPACKE_cgemlq.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cgemlq(int matrix_layout, char side, char trans, int m, int n, int k, const _Complex float *a, int lda, const _Complex float *t, int tsize, _Complex float *c, int ldc)
     * }
     */
    public static int LAPACKE_cgemlq(int matrix_layout, byte side, byte trans, int m, int n, int k, MemorySegment a, int lda, MemorySegment t, int tsize, MemorySegment c, int ldc) {
        var mh$ = LAPACKE_cgemlq.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cgemlq", matrix_layout, side, trans, m, n, k, a, lda, t, tsize, c, ldc);
            }
            return (int)mh$.invokeExact(matrix_layout, side, trans, m, n, k, a, lda, t, tsize, c, ldc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zgemlq {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zgemlq");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zgemlq(int matrix_layout, char side, char trans, int m, int n, int k, const _Complex double *a, int lda, const _Complex double *t, int tsize, _Complex double *c, int ldc)
     * }
     */
    public static FunctionDescriptor LAPACKE_zgemlq$descriptor() {
        return LAPACKE_zgemlq.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zgemlq(int matrix_layout, char side, char trans, int m, int n, int k, const _Complex double *a, int lda, const _Complex double *t, int tsize, _Complex double *c, int ldc)
     * }
     */
    public static MethodHandle LAPACKE_zgemlq$handle() {
        return LAPACKE_zgemlq.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zgemlq(int matrix_layout, char side, char trans, int m, int n, int k, const _Complex double *a, int lda, const _Complex double *t, int tsize, _Complex double *c, int ldc)
     * }
     */
    public static MemorySegment LAPACKE_zgemlq$address() {
        return LAPACKE_zgemlq.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zgemlq(int matrix_layout, char side, char trans, int m, int n, int k, const _Complex double *a, int lda, const _Complex double *t, int tsize, _Complex double *c, int ldc)
     * }
     */
    public static int LAPACKE_zgemlq(int matrix_layout, byte side, byte trans, int m, int n, int k, MemorySegment a, int lda, MemorySegment t, int tsize, MemorySegment c, int ldc) {
        var mh$ = LAPACKE_zgemlq.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zgemlq", matrix_layout, side, trans, m, n, k, a, lda, t, tsize, c, ldc);
            }
            return (int)mh$.invokeExact(matrix_layout, side, trans, m, n, k, a, lda, t, tsize, c, ldc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sgemlq_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_sgemlq_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sgemlq_work(int matrix_layout, char side, char trans, int m, int n, int k, const float *a, int lda, const float *t, int tsize, float *c, int ldc, float *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_sgemlq_work$descriptor() {
        return LAPACKE_sgemlq_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sgemlq_work(int matrix_layout, char side, char trans, int m, int n, int k, const float *a, int lda, const float *t, int tsize, float *c, int ldc, float *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_sgemlq_work$handle() {
        return LAPACKE_sgemlq_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sgemlq_work(int matrix_layout, char side, char trans, int m, int n, int k, const float *a, int lda, const float *t, int tsize, float *c, int ldc, float *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_sgemlq_work$address() {
        return LAPACKE_sgemlq_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sgemlq_work(int matrix_layout, char side, char trans, int m, int n, int k, const float *a, int lda, const float *t, int tsize, float *c, int ldc, float *work, int lwork)
     * }
     */
    public static int LAPACKE_sgemlq_work(int matrix_layout, byte side, byte trans, int m, int n, int k, MemorySegment a, int lda, MemorySegment t, int tsize, MemorySegment c, int ldc, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_sgemlq_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sgemlq_work", matrix_layout, side, trans, m, n, k, a, lda, t, tsize, c, ldc, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, side, trans, m, n, k, a, lda, t, tsize, c, ldc, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dgemlq_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dgemlq_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dgemlq_work(int matrix_layout, char side, char trans, int m, int n, int k, const double *a, int lda, const double *t, int tsize, double *c, int ldc, double *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_dgemlq_work$descriptor() {
        return LAPACKE_dgemlq_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dgemlq_work(int matrix_layout, char side, char trans, int m, int n, int k, const double *a, int lda, const double *t, int tsize, double *c, int ldc, double *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_dgemlq_work$handle() {
        return LAPACKE_dgemlq_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dgemlq_work(int matrix_layout, char side, char trans, int m, int n, int k, const double *a, int lda, const double *t, int tsize, double *c, int ldc, double *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_dgemlq_work$address() {
        return LAPACKE_dgemlq_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dgemlq_work(int matrix_layout, char side, char trans, int m, int n, int k, const double *a, int lda, const double *t, int tsize, double *c, int ldc, double *work, int lwork)
     * }
     */
    public static int LAPACKE_dgemlq_work(int matrix_layout, byte side, byte trans, int m, int n, int k, MemorySegment a, int lda, MemorySegment t, int tsize, MemorySegment c, int ldc, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_dgemlq_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dgemlq_work", matrix_layout, side, trans, m, n, k, a, lda, t, tsize, c, ldc, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, side, trans, m, n, k, a, lda, t, tsize, c, ldc, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cgemlq_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_cgemlq_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cgemlq_work(int matrix_layout, char side, char trans, int m, int n, int k, const _Complex float *a, int lda, const _Complex float *t, int tsize, _Complex float *c, int ldc, _Complex float *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_cgemlq_work$descriptor() {
        return LAPACKE_cgemlq_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cgemlq_work(int matrix_layout, char side, char trans, int m, int n, int k, const _Complex float *a, int lda, const _Complex float *t, int tsize, _Complex float *c, int ldc, _Complex float *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_cgemlq_work$handle() {
        return LAPACKE_cgemlq_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cgemlq_work(int matrix_layout, char side, char trans, int m, int n, int k, const _Complex float *a, int lda, const _Complex float *t, int tsize, _Complex float *c, int ldc, _Complex float *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_cgemlq_work$address() {
        return LAPACKE_cgemlq_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cgemlq_work(int matrix_layout, char side, char trans, int m, int n, int k, const _Complex float *a, int lda, const _Complex float *t, int tsize, _Complex float *c, int ldc, _Complex float *work, int lwork)
     * }
     */
    public static int LAPACKE_cgemlq_work(int matrix_layout, byte side, byte trans, int m, int n, int k, MemorySegment a, int lda, MemorySegment t, int tsize, MemorySegment c, int ldc, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_cgemlq_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cgemlq_work", matrix_layout, side, trans, m, n, k, a, lda, t, tsize, c, ldc, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, side, trans, m, n, k, a, lda, t, tsize, c, ldc, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zgemlq_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zgemlq_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zgemlq_work(int matrix_layout, char side, char trans, int m, int n, int k, const _Complex double *a, int lda, const _Complex double *t, int tsize, _Complex double *c, int ldc, _Complex double *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_zgemlq_work$descriptor() {
        return LAPACKE_zgemlq_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zgemlq_work(int matrix_layout, char side, char trans, int m, int n, int k, const _Complex double *a, int lda, const _Complex double *t, int tsize, _Complex double *c, int ldc, _Complex double *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_zgemlq_work$handle() {
        return LAPACKE_zgemlq_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zgemlq_work(int matrix_layout, char side, char trans, int m, int n, int k, const _Complex double *a, int lda, const _Complex double *t, int tsize, _Complex double *c, int ldc, _Complex double *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_zgemlq_work$address() {
        return LAPACKE_zgemlq_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zgemlq_work(int matrix_layout, char side, char trans, int m, int n, int k, const _Complex double *a, int lda, const _Complex double *t, int tsize, _Complex double *c, int ldc, _Complex double *work, int lwork)
     * }
     */
    public static int LAPACKE_zgemlq_work(int matrix_layout, byte side, byte trans, int m, int n, int k, MemorySegment a, int lda, MemorySegment t, int tsize, MemorySegment c, int ldc, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_zgemlq_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zgemlq_work", matrix_layout, side, trans, m, n, k, a, lda, t, tsize, c, ldc, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, side, trans, m, n, k, a, lda, t, tsize, c, ldc, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sgeqr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_sgeqr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sgeqr(int matrix_layout, int m, int n, float *a, int lda, float *t, int tsize)
     * }
     */
    public static FunctionDescriptor LAPACKE_sgeqr$descriptor() {
        return LAPACKE_sgeqr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sgeqr(int matrix_layout, int m, int n, float *a, int lda, float *t, int tsize)
     * }
     */
    public static MethodHandle LAPACKE_sgeqr$handle() {
        return LAPACKE_sgeqr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sgeqr(int matrix_layout, int m, int n, float *a, int lda, float *t, int tsize)
     * }
     */
    public static MemorySegment LAPACKE_sgeqr$address() {
        return LAPACKE_sgeqr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sgeqr(int matrix_layout, int m, int n, float *a, int lda, float *t, int tsize)
     * }
     */
    public static int LAPACKE_sgeqr(int matrix_layout, int m, int n, MemorySegment a, int lda, MemorySegment t, int tsize) {
        var mh$ = LAPACKE_sgeqr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sgeqr", matrix_layout, m, n, a, lda, t, tsize);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, a, lda, t, tsize);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dgeqr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dgeqr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dgeqr(int matrix_layout, int m, int n, double *a, int lda, double *t, int tsize)
     * }
     */
    public static FunctionDescriptor LAPACKE_dgeqr$descriptor() {
        return LAPACKE_dgeqr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dgeqr(int matrix_layout, int m, int n, double *a, int lda, double *t, int tsize)
     * }
     */
    public static MethodHandle LAPACKE_dgeqr$handle() {
        return LAPACKE_dgeqr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dgeqr(int matrix_layout, int m, int n, double *a, int lda, double *t, int tsize)
     * }
     */
    public static MemorySegment LAPACKE_dgeqr$address() {
        return LAPACKE_dgeqr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dgeqr(int matrix_layout, int m, int n, double *a, int lda, double *t, int tsize)
     * }
     */
    public static int LAPACKE_dgeqr(int matrix_layout, int m, int n, MemorySegment a, int lda, MemorySegment t, int tsize) {
        var mh$ = LAPACKE_dgeqr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dgeqr", matrix_layout, m, n, a, lda, t, tsize);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, a, lda, t, tsize);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cgeqr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_cgeqr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cgeqr(int matrix_layout, int m, int n, _Complex float *a, int lda, _Complex float *t, int tsize)
     * }
     */
    public static FunctionDescriptor LAPACKE_cgeqr$descriptor() {
        return LAPACKE_cgeqr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cgeqr(int matrix_layout, int m, int n, _Complex float *a, int lda, _Complex float *t, int tsize)
     * }
     */
    public static MethodHandle LAPACKE_cgeqr$handle() {
        return LAPACKE_cgeqr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cgeqr(int matrix_layout, int m, int n, _Complex float *a, int lda, _Complex float *t, int tsize)
     * }
     */
    public static MemorySegment LAPACKE_cgeqr$address() {
        return LAPACKE_cgeqr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cgeqr(int matrix_layout, int m, int n, _Complex float *a, int lda, _Complex float *t, int tsize)
     * }
     */
    public static int LAPACKE_cgeqr(int matrix_layout, int m, int n, MemorySegment a, int lda, MemorySegment t, int tsize) {
        var mh$ = LAPACKE_cgeqr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cgeqr", matrix_layout, m, n, a, lda, t, tsize);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, a, lda, t, tsize);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zgeqr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zgeqr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zgeqr(int matrix_layout, int m, int n, _Complex double *a, int lda, _Complex double *t, int tsize)
     * }
     */
    public static FunctionDescriptor LAPACKE_zgeqr$descriptor() {
        return LAPACKE_zgeqr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zgeqr(int matrix_layout, int m, int n, _Complex double *a, int lda, _Complex double *t, int tsize)
     * }
     */
    public static MethodHandle LAPACKE_zgeqr$handle() {
        return LAPACKE_zgeqr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zgeqr(int matrix_layout, int m, int n, _Complex double *a, int lda, _Complex double *t, int tsize)
     * }
     */
    public static MemorySegment LAPACKE_zgeqr$address() {
        return LAPACKE_zgeqr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zgeqr(int matrix_layout, int m, int n, _Complex double *a, int lda, _Complex double *t, int tsize)
     * }
     */
    public static int LAPACKE_zgeqr(int matrix_layout, int m, int n, MemorySegment a, int lda, MemorySegment t, int tsize) {
        var mh$ = LAPACKE_zgeqr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zgeqr", matrix_layout, m, n, a, lda, t, tsize);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, a, lda, t, tsize);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sgeqr_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_sgeqr_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sgeqr_work(int matrix_layout, int m, int n, float *a, int lda, float *t, int tsize, float *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_sgeqr_work$descriptor() {
        return LAPACKE_sgeqr_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sgeqr_work(int matrix_layout, int m, int n, float *a, int lda, float *t, int tsize, float *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_sgeqr_work$handle() {
        return LAPACKE_sgeqr_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sgeqr_work(int matrix_layout, int m, int n, float *a, int lda, float *t, int tsize, float *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_sgeqr_work$address() {
        return LAPACKE_sgeqr_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sgeqr_work(int matrix_layout, int m, int n, float *a, int lda, float *t, int tsize, float *work, int lwork)
     * }
     */
    public static int LAPACKE_sgeqr_work(int matrix_layout, int m, int n, MemorySegment a, int lda, MemorySegment t, int tsize, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_sgeqr_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sgeqr_work", matrix_layout, m, n, a, lda, t, tsize, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, a, lda, t, tsize, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dgeqr_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dgeqr_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dgeqr_work(int matrix_layout, int m, int n, double *a, int lda, double *t, int tsize, double *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_dgeqr_work$descriptor() {
        return LAPACKE_dgeqr_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dgeqr_work(int matrix_layout, int m, int n, double *a, int lda, double *t, int tsize, double *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_dgeqr_work$handle() {
        return LAPACKE_dgeqr_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dgeqr_work(int matrix_layout, int m, int n, double *a, int lda, double *t, int tsize, double *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_dgeqr_work$address() {
        return LAPACKE_dgeqr_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dgeqr_work(int matrix_layout, int m, int n, double *a, int lda, double *t, int tsize, double *work, int lwork)
     * }
     */
    public static int LAPACKE_dgeqr_work(int matrix_layout, int m, int n, MemorySegment a, int lda, MemorySegment t, int tsize, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_dgeqr_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dgeqr_work", matrix_layout, m, n, a, lda, t, tsize, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, a, lda, t, tsize, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cgeqr_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_cgeqr_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cgeqr_work(int matrix_layout, int m, int n, _Complex float *a, int lda, _Complex float *t, int tsize, _Complex float *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_cgeqr_work$descriptor() {
        return LAPACKE_cgeqr_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cgeqr_work(int matrix_layout, int m, int n, _Complex float *a, int lda, _Complex float *t, int tsize, _Complex float *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_cgeqr_work$handle() {
        return LAPACKE_cgeqr_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cgeqr_work(int matrix_layout, int m, int n, _Complex float *a, int lda, _Complex float *t, int tsize, _Complex float *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_cgeqr_work$address() {
        return LAPACKE_cgeqr_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cgeqr_work(int matrix_layout, int m, int n, _Complex float *a, int lda, _Complex float *t, int tsize, _Complex float *work, int lwork)
     * }
     */
    public static int LAPACKE_cgeqr_work(int matrix_layout, int m, int n, MemorySegment a, int lda, MemorySegment t, int tsize, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_cgeqr_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cgeqr_work", matrix_layout, m, n, a, lda, t, tsize, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, a, lda, t, tsize, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zgeqr_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zgeqr_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zgeqr_work(int matrix_layout, int m, int n, _Complex double *a, int lda, _Complex double *t, int tsize, _Complex double *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_zgeqr_work$descriptor() {
        return LAPACKE_zgeqr_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zgeqr_work(int matrix_layout, int m, int n, _Complex double *a, int lda, _Complex double *t, int tsize, _Complex double *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_zgeqr_work$handle() {
        return LAPACKE_zgeqr_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zgeqr_work(int matrix_layout, int m, int n, _Complex double *a, int lda, _Complex double *t, int tsize, _Complex double *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_zgeqr_work$address() {
        return LAPACKE_zgeqr_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zgeqr_work(int matrix_layout, int m, int n, _Complex double *a, int lda, _Complex double *t, int tsize, _Complex double *work, int lwork)
     * }
     */
    public static int LAPACKE_zgeqr_work(int matrix_layout, int m, int n, MemorySegment a, int lda, MemorySegment t, int tsize, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_zgeqr_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zgeqr_work", matrix_layout, m, n, a, lda, t, tsize, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, a, lda, t, tsize, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sgemqr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_sgemqr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sgemqr(int matrix_layout, char side, char trans, int m, int n, int k, const float *a, int lda, const float *t, int tsize, float *c, int ldc)
     * }
     */
    public static FunctionDescriptor LAPACKE_sgemqr$descriptor() {
        return LAPACKE_sgemqr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sgemqr(int matrix_layout, char side, char trans, int m, int n, int k, const float *a, int lda, const float *t, int tsize, float *c, int ldc)
     * }
     */
    public static MethodHandle LAPACKE_sgemqr$handle() {
        return LAPACKE_sgemqr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sgemqr(int matrix_layout, char side, char trans, int m, int n, int k, const float *a, int lda, const float *t, int tsize, float *c, int ldc)
     * }
     */
    public static MemorySegment LAPACKE_sgemqr$address() {
        return LAPACKE_sgemqr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sgemqr(int matrix_layout, char side, char trans, int m, int n, int k, const float *a, int lda, const float *t, int tsize, float *c, int ldc)
     * }
     */
    public static int LAPACKE_sgemqr(int matrix_layout, byte side, byte trans, int m, int n, int k, MemorySegment a, int lda, MemorySegment t, int tsize, MemorySegment c, int ldc) {
        var mh$ = LAPACKE_sgemqr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sgemqr", matrix_layout, side, trans, m, n, k, a, lda, t, tsize, c, ldc);
            }
            return (int)mh$.invokeExact(matrix_layout, side, trans, m, n, k, a, lda, t, tsize, c, ldc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dgemqr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dgemqr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dgemqr(int matrix_layout, char side, char trans, int m, int n, int k, const double *a, int lda, const double *t, int tsize, double *c, int ldc)
     * }
     */
    public static FunctionDescriptor LAPACKE_dgemqr$descriptor() {
        return LAPACKE_dgemqr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dgemqr(int matrix_layout, char side, char trans, int m, int n, int k, const double *a, int lda, const double *t, int tsize, double *c, int ldc)
     * }
     */
    public static MethodHandle LAPACKE_dgemqr$handle() {
        return LAPACKE_dgemqr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dgemqr(int matrix_layout, char side, char trans, int m, int n, int k, const double *a, int lda, const double *t, int tsize, double *c, int ldc)
     * }
     */
    public static MemorySegment LAPACKE_dgemqr$address() {
        return LAPACKE_dgemqr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dgemqr(int matrix_layout, char side, char trans, int m, int n, int k, const double *a, int lda, const double *t, int tsize, double *c, int ldc)
     * }
     */
    public static int LAPACKE_dgemqr(int matrix_layout, byte side, byte trans, int m, int n, int k, MemorySegment a, int lda, MemorySegment t, int tsize, MemorySegment c, int ldc) {
        var mh$ = LAPACKE_dgemqr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dgemqr", matrix_layout, side, trans, m, n, k, a, lda, t, tsize, c, ldc);
            }
            return (int)mh$.invokeExact(matrix_layout, side, trans, m, n, k, a, lda, t, tsize, c, ldc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cgemqr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_cgemqr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cgemqr(int matrix_layout, char side, char trans, int m, int n, int k, const _Complex float *a, int lda, const _Complex float *t, int tsize, _Complex float *c, int ldc)
     * }
     */
    public static FunctionDescriptor LAPACKE_cgemqr$descriptor() {
        return LAPACKE_cgemqr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cgemqr(int matrix_layout, char side, char trans, int m, int n, int k, const _Complex float *a, int lda, const _Complex float *t, int tsize, _Complex float *c, int ldc)
     * }
     */
    public static MethodHandle LAPACKE_cgemqr$handle() {
        return LAPACKE_cgemqr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cgemqr(int matrix_layout, char side, char trans, int m, int n, int k, const _Complex float *a, int lda, const _Complex float *t, int tsize, _Complex float *c, int ldc)
     * }
     */
    public static MemorySegment LAPACKE_cgemqr$address() {
        return LAPACKE_cgemqr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cgemqr(int matrix_layout, char side, char trans, int m, int n, int k, const _Complex float *a, int lda, const _Complex float *t, int tsize, _Complex float *c, int ldc)
     * }
     */
    public static int LAPACKE_cgemqr(int matrix_layout, byte side, byte trans, int m, int n, int k, MemorySegment a, int lda, MemorySegment t, int tsize, MemorySegment c, int ldc) {
        var mh$ = LAPACKE_cgemqr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cgemqr", matrix_layout, side, trans, m, n, k, a, lda, t, tsize, c, ldc);
            }
            return (int)mh$.invokeExact(matrix_layout, side, trans, m, n, k, a, lda, t, tsize, c, ldc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zgemqr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zgemqr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zgemqr(int matrix_layout, char side, char trans, int m, int n, int k, const _Complex double *a, int lda, const _Complex double *t, int tsize, _Complex double *c, int ldc)
     * }
     */
    public static FunctionDescriptor LAPACKE_zgemqr$descriptor() {
        return LAPACKE_zgemqr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zgemqr(int matrix_layout, char side, char trans, int m, int n, int k, const _Complex double *a, int lda, const _Complex double *t, int tsize, _Complex double *c, int ldc)
     * }
     */
    public static MethodHandle LAPACKE_zgemqr$handle() {
        return LAPACKE_zgemqr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zgemqr(int matrix_layout, char side, char trans, int m, int n, int k, const _Complex double *a, int lda, const _Complex double *t, int tsize, _Complex double *c, int ldc)
     * }
     */
    public static MemorySegment LAPACKE_zgemqr$address() {
        return LAPACKE_zgemqr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zgemqr(int matrix_layout, char side, char trans, int m, int n, int k, const _Complex double *a, int lda, const _Complex double *t, int tsize, _Complex double *c, int ldc)
     * }
     */
    public static int LAPACKE_zgemqr(int matrix_layout, byte side, byte trans, int m, int n, int k, MemorySegment a, int lda, MemorySegment t, int tsize, MemorySegment c, int ldc) {
        var mh$ = LAPACKE_zgemqr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zgemqr", matrix_layout, side, trans, m, n, k, a, lda, t, tsize, c, ldc);
            }
            return (int)mh$.invokeExact(matrix_layout, side, trans, m, n, k, a, lda, t, tsize, c, ldc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sgemqr_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_sgemqr_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sgemqr_work(int matrix_layout, char side, char trans, int m, int n, int k, const float *a, int lda, const float *t, int tsize, float *c, int ldc, float *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_sgemqr_work$descriptor() {
        return LAPACKE_sgemqr_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sgemqr_work(int matrix_layout, char side, char trans, int m, int n, int k, const float *a, int lda, const float *t, int tsize, float *c, int ldc, float *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_sgemqr_work$handle() {
        return LAPACKE_sgemqr_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sgemqr_work(int matrix_layout, char side, char trans, int m, int n, int k, const float *a, int lda, const float *t, int tsize, float *c, int ldc, float *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_sgemqr_work$address() {
        return LAPACKE_sgemqr_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sgemqr_work(int matrix_layout, char side, char trans, int m, int n, int k, const float *a, int lda, const float *t, int tsize, float *c, int ldc, float *work, int lwork)
     * }
     */
    public static int LAPACKE_sgemqr_work(int matrix_layout, byte side, byte trans, int m, int n, int k, MemorySegment a, int lda, MemorySegment t, int tsize, MemorySegment c, int ldc, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_sgemqr_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sgemqr_work", matrix_layout, side, trans, m, n, k, a, lda, t, tsize, c, ldc, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, side, trans, m, n, k, a, lda, t, tsize, c, ldc, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dgemqr_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dgemqr_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dgemqr_work(int matrix_layout, char side, char trans, int m, int n, int k, const double *a, int lda, const double *t, int tsize, double *c, int ldc, double *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_dgemqr_work$descriptor() {
        return LAPACKE_dgemqr_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dgemqr_work(int matrix_layout, char side, char trans, int m, int n, int k, const double *a, int lda, const double *t, int tsize, double *c, int ldc, double *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_dgemqr_work$handle() {
        return LAPACKE_dgemqr_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dgemqr_work(int matrix_layout, char side, char trans, int m, int n, int k, const double *a, int lda, const double *t, int tsize, double *c, int ldc, double *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_dgemqr_work$address() {
        return LAPACKE_dgemqr_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dgemqr_work(int matrix_layout, char side, char trans, int m, int n, int k, const double *a, int lda, const double *t, int tsize, double *c, int ldc, double *work, int lwork)
     * }
     */
    public static int LAPACKE_dgemqr_work(int matrix_layout, byte side, byte trans, int m, int n, int k, MemorySegment a, int lda, MemorySegment t, int tsize, MemorySegment c, int ldc, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_dgemqr_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dgemqr_work", matrix_layout, side, trans, m, n, k, a, lda, t, tsize, c, ldc, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, side, trans, m, n, k, a, lda, t, tsize, c, ldc, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cgemqr_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_cgemqr_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cgemqr_work(int matrix_layout, char side, char trans, int m, int n, int k, const _Complex float *a, int lda, const _Complex float *t, int tsize, _Complex float *c, int ldc, _Complex float *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_cgemqr_work$descriptor() {
        return LAPACKE_cgemqr_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cgemqr_work(int matrix_layout, char side, char trans, int m, int n, int k, const _Complex float *a, int lda, const _Complex float *t, int tsize, _Complex float *c, int ldc, _Complex float *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_cgemqr_work$handle() {
        return LAPACKE_cgemqr_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cgemqr_work(int matrix_layout, char side, char trans, int m, int n, int k, const _Complex float *a, int lda, const _Complex float *t, int tsize, _Complex float *c, int ldc, _Complex float *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_cgemqr_work$address() {
        return LAPACKE_cgemqr_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cgemqr_work(int matrix_layout, char side, char trans, int m, int n, int k, const _Complex float *a, int lda, const _Complex float *t, int tsize, _Complex float *c, int ldc, _Complex float *work, int lwork)
     * }
     */
    public static int LAPACKE_cgemqr_work(int matrix_layout, byte side, byte trans, int m, int n, int k, MemorySegment a, int lda, MemorySegment t, int tsize, MemorySegment c, int ldc, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_cgemqr_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cgemqr_work", matrix_layout, side, trans, m, n, k, a, lda, t, tsize, c, ldc, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, side, trans, m, n, k, a, lda, t, tsize, c, ldc, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zgemqr_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zgemqr_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zgemqr_work(int matrix_layout, char side, char trans, int m, int n, int k, const _Complex double *a, int lda, const _Complex double *t, int tsize, _Complex double *c, int ldc, _Complex double *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_zgemqr_work$descriptor() {
        return LAPACKE_zgemqr_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zgemqr_work(int matrix_layout, char side, char trans, int m, int n, int k, const _Complex double *a, int lda, const _Complex double *t, int tsize, _Complex double *c, int ldc, _Complex double *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_zgemqr_work$handle() {
        return LAPACKE_zgemqr_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zgemqr_work(int matrix_layout, char side, char trans, int m, int n, int k, const _Complex double *a, int lda, const _Complex double *t, int tsize, _Complex double *c, int ldc, _Complex double *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_zgemqr_work$address() {
        return LAPACKE_zgemqr_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zgemqr_work(int matrix_layout, char side, char trans, int m, int n, int k, const _Complex double *a, int lda, const _Complex double *t, int tsize, _Complex double *c, int ldc, _Complex double *work, int lwork)
     * }
     */
    public static int LAPACKE_zgemqr_work(int matrix_layout, byte side, byte trans, int m, int n, int k, MemorySegment a, int lda, MemorySegment t, int tsize, MemorySegment c, int ldc, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_zgemqr_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zgemqr_work", matrix_layout, side, trans, m, n, k, a, lda, t, tsize, c, ldc, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, side, trans, m, n, k, a, lda, t, tsize, c, ldc, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sgetsls {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_sgetsls");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sgetsls(int matrix_layout, char trans, int m, int n, int nrhs, float *a, int lda, float *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_sgetsls$descriptor() {
        return LAPACKE_sgetsls.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sgetsls(int matrix_layout, char trans, int m, int n, int nrhs, float *a, int lda, float *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_sgetsls$handle() {
        return LAPACKE_sgetsls.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sgetsls(int matrix_layout, char trans, int m, int n, int nrhs, float *a, int lda, float *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_sgetsls$address() {
        return LAPACKE_sgetsls.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sgetsls(int matrix_layout, char trans, int m, int n, int nrhs, float *a, int lda, float *b, int ldb)
     * }
     */
    public static int LAPACKE_sgetsls(int matrix_layout, byte trans, int m, int n, int nrhs, MemorySegment a, int lda, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_sgetsls.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sgetsls", matrix_layout, trans, m, n, nrhs, a, lda, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, trans, m, n, nrhs, a, lda, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dgetsls {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dgetsls");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dgetsls(int matrix_layout, char trans, int m, int n, int nrhs, double *a, int lda, double *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_dgetsls$descriptor() {
        return LAPACKE_dgetsls.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dgetsls(int matrix_layout, char trans, int m, int n, int nrhs, double *a, int lda, double *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_dgetsls$handle() {
        return LAPACKE_dgetsls.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dgetsls(int matrix_layout, char trans, int m, int n, int nrhs, double *a, int lda, double *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_dgetsls$address() {
        return LAPACKE_dgetsls.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dgetsls(int matrix_layout, char trans, int m, int n, int nrhs, double *a, int lda, double *b, int ldb)
     * }
     */
    public static int LAPACKE_dgetsls(int matrix_layout, byte trans, int m, int n, int nrhs, MemorySegment a, int lda, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_dgetsls.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dgetsls", matrix_layout, trans, m, n, nrhs, a, lda, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, trans, m, n, nrhs, a, lda, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cgetsls {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_cgetsls");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cgetsls(int matrix_layout, char trans, int m, int n, int nrhs, _Complex float *a, int lda, _Complex float *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_cgetsls$descriptor() {
        return LAPACKE_cgetsls.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cgetsls(int matrix_layout, char trans, int m, int n, int nrhs, _Complex float *a, int lda, _Complex float *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_cgetsls$handle() {
        return LAPACKE_cgetsls.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cgetsls(int matrix_layout, char trans, int m, int n, int nrhs, _Complex float *a, int lda, _Complex float *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_cgetsls$address() {
        return LAPACKE_cgetsls.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cgetsls(int matrix_layout, char trans, int m, int n, int nrhs, _Complex float *a, int lda, _Complex float *b, int ldb)
     * }
     */
    public static int LAPACKE_cgetsls(int matrix_layout, byte trans, int m, int n, int nrhs, MemorySegment a, int lda, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_cgetsls.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cgetsls", matrix_layout, trans, m, n, nrhs, a, lda, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, trans, m, n, nrhs, a, lda, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zgetsls {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zgetsls");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zgetsls(int matrix_layout, char trans, int m, int n, int nrhs, _Complex double *a, int lda, _Complex double *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_zgetsls$descriptor() {
        return LAPACKE_zgetsls.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zgetsls(int matrix_layout, char trans, int m, int n, int nrhs, _Complex double *a, int lda, _Complex double *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_zgetsls$handle() {
        return LAPACKE_zgetsls.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zgetsls(int matrix_layout, char trans, int m, int n, int nrhs, _Complex double *a, int lda, _Complex double *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_zgetsls$address() {
        return LAPACKE_zgetsls.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zgetsls(int matrix_layout, char trans, int m, int n, int nrhs, _Complex double *a, int lda, _Complex double *b, int ldb)
     * }
     */
    public static int LAPACKE_zgetsls(int matrix_layout, byte trans, int m, int n, int nrhs, MemorySegment a, int lda, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_zgetsls.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zgetsls", matrix_layout, trans, m, n, nrhs, a, lda, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, trans, m, n, nrhs, a, lda, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sgetsls_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_sgetsls_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sgetsls_work(int matrix_layout, char trans, int m, int n, int nrhs, float *a, int lda, float *b, int ldb, float *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_sgetsls_work$descriptor() {
        return LAPACKE_sgetsls_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sgetsls_work(int matrix_layout, char trans, int m, int n, int nrhs, float *a, int lda, float *b, int ldb, float *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_sgetsls_work$handle() {
        return LAPACKE_sgetsls_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sgetsls_work(int matrix_layout, char trans, int m, int n, int nrhs, float *a, int lda, float *b, int ldb, float *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_sgetsls_work$address() {
        return LAPACKE_sgetsls_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sgetsls_work(int matrix_layout, char trans, int m, int n, int nrhs, float *a, int lda, float *b, int ldb, float *work, int lwork)
     * }
     */
    public static int LAPACKE_sgetsls_work(int matrix_layout, byte trans, int m, int n, int nrhs, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_sgetsls_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sgetsls_work", matrix_layout, trans, m, n, nrhs, a, lda, b, ldb, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, trans, m, n, nrhs, a, lda, b, ldb, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dgetsls_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dgetsls_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dgetsls_work(int matrix_layout, char trans, int m, int n, int nrhs, double *a, int lda, double *b, int ldb, double *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_dgetsls_work$descriptor() {
        return LAPACKE_dgetsls_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dgetsls_work(int matrix_layout, char trans, int m, int n, int nrhs, double *a, int lda, double *b, int ldb, double *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_dgetsls_work$handle() {
        return LAPACKE_dgetsls_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dgetsls_work(int matrix_layout, char trans, int m, int n, int nrhs, double *a, int lda, double *b, int ldb, double *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_dgetsls_work$address() {
        return LAPACKE_dgetsls_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dgetsls_work(int matrix_layout, char trans, int m, int n, int nrhs, double *a, int lda, double *b, int ldb, double *work, int lwork)
     * }
     */
    public static int LAPACKE_dgetsls_work(int matrix_layout, byte trans, int m, int n, int nrhs, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_dgetsls_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dgetsls_work", matrix_layout, trans, m, n, nrhs, a, lda, b, ldb, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, trans, m, n, nrhs, a, lda, b, ldb, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cgetsls_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_cgetsls_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cgetsls_work(int matrix_layout, char trans, int m, int n, int nrhs, _Complex float *a, int lda, _Complex float *b, int ldb, _Complex float *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_cgetsls_work$descriptor() {
        return LAPACKE_cgetsls_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cgetsls_work(int matrix_layout, char trans, int m, int n, int nrhs, _Complex float *a, int lda, _Complex float *b, int ldb, _Complex float *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_cgetsls_work$handle() {
        return LAPACKE_cgetsls_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cgetsls_work(int matrix_layout, char trans, int m, int n, int nrhs, _Complex float *a, int lda, _Complex float *b, int ldb, _Complex float *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_cgetsls_work$address() {
        return LAPACKE_cgetsls_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cgetsls_work(int matrix_layout, char trans, int m, int n, int nrhs, _Complex float *a, int lda, _Complex float *b, int ldb, _Complex float *work, int lwork)
     * }
     */
    public static int LAPACKE_cgetsls_work(int matrix_layout, byte trans, int m, int n, int nrhs, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_cgetsls_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cgetsls_work", matrix_layout, trans, m, n, nrhs, a, lda, b, ldb, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, trans, m, n, nrhs, a, lda, b, ldb, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zgetsls_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zgetsls_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zgetsls_work(int matrix_layout, char trans, int m, int n, int nrhs, _Complex double *a, int lda, _Complex double *b, int ldb, _Complex double *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_zgetsls_work$descriptor() {
        return LAPACKE_zgetsls_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zgetsls_work(int matrix_layout, char trans, int m, int n, int nrhs, _Complex double *a, int lda, _Complex double *b, int ldb, _Complex double *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_zgetsls_work$handle() {
        return LAPACKE_zgetsls_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zgetsls_work(int matrix_layout, char trans, int m, int n, int nrhs, _Complex double *a, int lda, _Complex double *b, int ldb, _Complex double *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_zgetsls_work$address() {
        return LAPACKE_zgetsls_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zgetsls_work(int matrix_layout, char trans, int m, int n, int nrhs, _Complex double *a, int lda, _Complex double *b, int ldb, _Complex double *work, int lwork)
     * }
     */
    public static int LAPACKE_zgetsls_work(int matrix_layout, byte trans, int m, int n, int nrhs, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_zgetsls_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zgetsls_work", matrix_layout, trans, m, n, nrhs, a, lda, b, ldb, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, trans, m, n, nrhs, a, lda, b, ldb, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sgetsqrhrt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_sgetsqrhrt");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sgetsqrhrt(int matrix_layout, int m, int n, int mb1, int nb1, int nb2, float *a, int lda, float *t, int ldt)
     * }
     */
    public static FunctionDescriptor LAPACKE_sgetsqrhrt$descriptor() {
        return LAPACKE_sgetsqrhrt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sgetsqrhrt(int matrix_layout, int m, int n, int mb1, int nb1, int nb2, float *a, int lda, float *t, int ldt)
     * }
     */
    public static MethodHandle LAPACKE_sgetsqrhrt$handle() {
        return LAPACKE_sgetsqrhrt.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sgetsqrhrt(int matrix_layout, int m, int n, int mb1, int nb1, int nb2, float *a, int lda, float *t, int ldt)
     * }
     */
    public static MemorySegment LAPACKE_sgetsqrhrt$address() {
        return LAPACKE_sgetsqrhrt.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sgetsqrhrt(int matrix_layout, int m, int n, int mb1, int nb1, int nb2, float *a, int lda, float *t, int ldt)
     * }
     */
    public static int LAPACKE_sgetsqrhrt(int matrix_layout, int m, int n, int mb1, int nb1, int nb2, MemorySegment a, int lda, MemorySegment t, int ldt) {
        var mh$ = LAPACKE_sgetsqrhrt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sgetsqrhrt", matrix_layout, m, n, mb1, nb1, nb2, a, lda, t, ldt);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, mb1, nb1, nb2, a, lda, t, ldt);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dgetsqrhrt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dgetsqrhrt");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dgetsqrhrt(int matrix_layout, int m, int n, int mb1, int nb1, int nb2, double *a, int lda, double *t, int ldt)
     * }
     */
    public static FunctionDescriptor LAPACKE_dgetsqrhrt$descriptor() {
        return LAPACKE_dgetsqrhrt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dgetsqrhrt(int matrix_layout, int m, int n, int mb1, int nb1, int nb2, double *a, int lda, double *t, int ldt)
     * }
     */
    public static MethodHandle LAPACKE_dgetsqrhrt$handle() {
        return LAPACKE_dgetsqrhrt.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dgetsqrhrt(int matrix_layout, int m, int n, int mb1, int nb1, int nb2, double *a, int lda, double *t, int ldt)
     * }
     */
    public static MemorySegment LAPACKE_dgetsqrhrt$address() {
        return LAPACKE_dgetsqrhrt.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dgetsqrhrt(int matrix_layout, int m, int n, int mb1, int nb1, int nb2, double *a, int lda, double *t, int ldt)
     * }
     */
    public static int LAPACKE_dgetsqrhrt(int matrix_layout, int m, int n, int mb1, int nb1, int nb2, MemorySegment a, int lda, MemorySegment t, int ldt) {
        var mh$ = LAPACKE_dgetsqrhrt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dgetsqrhrt", matrix_layout, m, n, mb1, nb1, nb2, a, lda, t, ldt);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, mb1, nb1, nb2, a, lda, t, ldt);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cgetsqrhrt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_cgetsqrhrt");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cgetsqrhrt(int matrix_layout, int m, int n, int mb1, int nb1, int nb2, _Complex float *a, int lda, _Complex float *t, int ldt)
     * }
     */
    public static FunctionDescriptor LAPACKE_cgetsqrhrt$descriptor() {
        return LAPACKE_cgetsqrhrt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cgetsqrhrt(int matrix_layout, int m, int n, int mb1, int nb1, int nb2, _Complex float *a, int lda, _Complex float *t, int ldt)
     * }
     */
    public static MethodHandle LAPACKE_cgetsqrhrt$handle() {
        return LAPACKE_cgetsqrhrt.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cgetsqrhrt(int matrix_layout, int m, int n, int mb1, int nb1, int nb2, _Complex float *a, int lda, _Complex float *t, int ldt)
     * }
     */
    public static MemorySegment LAPACKE_cgetsqrhrt$address() {
        return LAPACKE_cgetsqrhrt.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cgetsqrhrt(int matrix_layout, int m, int n, int mb1, int nb1, int nb2, _Complex float *a, int lda, _Complex float *t, int ldt)
     * }
     */
    public static int LAPACKE_cgetsqrhrt(int matrix_layout, int m, int n, int mb1, int nb1, int nb2, MemorySegment a, int lda, MemorySegment t, int ldt) {
        var mh$ = LAPACKE_cgetsqrhrt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cgetsqrhrt", matrix_layout, m, n, mb1, nb1, nb2, a, lda, t, ldt);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, mb1, nb1, nb2, a, lda, t, ldt);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zgetsqrhrt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zgetsqrhrt");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zgetsqrhrt(int matrix_layout, int m, int n, int mb1, int nb1, int nb2, _Complex double *a, int lda, _Complex double *t, int ldt)
     * }
     */
    public static FunctionDescriptor LAPACKE_zgetsqrhrt$descriptor() {
        return LAPACKE_zgetsqrhrt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zgetsqrhrt(int matrix_layout, int m, int n, int mb1, int nb1, int nb2, _Complex double *a, int lda, _Complex double *t, int ldt)
     * }
     */
    public static MethodHandle LAPACKE_zgetsqrhrt$handle() {
        return LAPACKE_zgetsqrhrt.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zgetsqrhrt(int matrix_layout, int m, int n, int mb1, int nb1, int nb2, _Complex double *a, int lda, _Complex double *t, int ldt)
     * }
     */
    public static MemorySegment LAPACKE_zgetsqrhrt$address() {
        return LAPACKE_zgetsqrhrt.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zgetsqrhrt(int matrix_layout, int m, int n, int mb1, int nb1, int nb2, _Complex double *a, int lda, _Complex double *t, int ldt)
     * }
     */
    public static int LAPACKE_zgetsqrhrt(int matrix_layout, int m, int n, int mb1, int nb1, int nb2, MemorySegment a, int lda, MemorySegment t, int ldt) {
        var mh$ = LAPACKE_zgetsqrhrt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zgetsqrhrt", matrix_layout, m, n, mb1, nb1, nb2, a, lda, t, ldt);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, mb1, nb1, nb2, a, lda, t, ldt);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sgetsqrhrt_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_sgetsqrhrt_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sgetsqrhrt_work(int matrix_layout, int m, int n, int mb1, int nb1, int nb2, float *a, int lda, float *t, int ldt, float *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_sgetsqrhrt_work$descriptor() {
        return LAPACKE_sgetsqrhrt_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sgetsqrhrt_work(int matrix_layout, int m, int n, int mb1, int nb1, int nb2, float *a, int lda, float *t, int ldt, float *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_sgetsqrhrt_work$handle() {
        return LAPACKE_sgetsqrhrt_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sgetsqrhrt_work(int matrix_layout, int m, int n, int mb1, int nb1, int nb2, float *a, int lda, float *t, int ldt, float *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_sgetsqrhrt_work$address() {
        return LAPACKE_sgetsqrhrt_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sgetsqrhrt_work(int matrix_layout, int m, int n, int mb1, int nb1, int nb2, float *a, int lda, float *t, int ldt, float *work, int lwork)
     * }
     */
    public static int LAPACKE_sgetsqrhrt_work(int matrix_layout, int m, int n, int mb1, int nb1, int nb2, MemorySegment a, int lda, MemorySegment t, int ldt, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_sgetsqrhrt_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sgetsqrhrt_work", matrix_layout, m, n, mb1, nb1, nb2, a, lda, t, ldt, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, mb1, nb1, nb2, a, lda, t, ldt, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dgetsqrhrt_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dgetsqrhrt_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dgetsqrhrt_work(int matrix_layout, int m, int n, int mb1, int nb1, int nb2, double *a, int lda, double *t, int ldt, double *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_dgetsqrhrt_work$descriptor() {
        return LAPACKE_dgetsqrhrt_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dgetsqrhrt_work(int matrix_layout, int m, int n, int mb1, int nb1, int nb2, double *a, int lda, double *t, int ldt, double *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_dgetsqrhrt_work$handle() {
        return LAPACKE_dgetsqrhrt_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dgetsqrhrt_work(int matrix_layout, int m, int n, int mb1, int nb1, int nb2, double *a, int lda, double *t, int ldt, double *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_dgetsqrhrt_work$address() {
        return LAPACKE_dgetsqrhrt_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dgetsqrhrt_work(int matrix_layout, int m, int n, int mb1, int nb1, int nb2, double *a, int lda, double *t, int ldt, double *work, int lwork)
     * }
     */
    public static int LAPACKE_dgetsqrhrt_work(int matrix_layout, int m, int n, int mb1, int nb1, int nb2, MemorySegment a, int lda, MemorySegment t, int ldt, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_dgetsqrhrt_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dgetsqrhrt_work", matrix_layout, m, n, mb1, nb1, nb2, a, lda, t, ldt, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, mb1, nb1, nb2, a, lda, t, ldt, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cgetsqrhrt_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_cgetsqrhrt_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cgetsqrhrt_work(int matrix_layout, int m, int n, int mb1, int nb1, int nb2, _Complex float *a, int lda, _Complex float *t, int ldt, _Complex float *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_cgetsqrhrt_work$descriptor() {
        return LAPACKE_cgetsqrhrt_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cgetsqrhrt_work(int matrix_layout, int m, int n, int mb1, int nb1, int nb2, _Complex float *a, int lda, _Complex float *t, int ldt, _Complex float *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_cgetsqrhrt_work$handle() {
        return LAPACKE_cgetsqrhrt_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cgetsqrhrt_work(int matrix_layout, int m, int n, int mb1, int nb1, int nb2, _Complex float *a, int lda, _Complex float *t, int ldt, _Complex float *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_cgetsqrhrt_work$address() {
        return LAPACKE_cgetsqrhrt_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cgetsqrhrt_work(int matrix_layout, int m, int n, int mb1, int nb1, int nb2, _Complex float *a, int lda, _Complex float *t, int ldt, _Complex float *work, int lwork)
     * }
     */
    public static int LAPACKE_cgetsqrhrt_work(int matrix_layout, int m, int n, int mb1, int nb1, int nb2, MemorySegment a, int lda, MemorySegment t, int ldt, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_cgetsqrhrt_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cgetsqrhrt_work", matrix_layout, m, n, mb1, nb1, nb2, a, lda, t, ldt, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, mb1, nb1, nb2, a, lda, t, ldt, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zgetsqrhrt_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zgetsqrhrt_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zgetsqrhrt_work(int matrix_layout, int m, int n, int mb1, int nb1, int nb2, _Complex double *a, int lda, _Complex double *t, int ldt, _Complex double *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_zgetsqrhrt_work$descriptor() {
        return LAPACKE_zgetsqrhrt_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zgetsqrhrt_work(int matrix_layout, int m, int n, int mb1, int nb1, int nb2, _Complex double *a, int lda, _Complex double *t, int ldt, _Complex double *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_zgetsqrhrt_work$handle() {
        return LAPACKE_zgetsqrhrt_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zgetsqrhrt_work(int matrix_layout, int m, int n, int mb1, int nb1, int nb2, _Complex double *a, int lda, _Complex double *t, int ldt, _Complex double *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_zgetsqrhrt_work$address() {
        return LAPACKE_zgetsqrhrt_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zgetsqrhrt_work(int matrix_layout, int m, int n, int mb1, int nb1, int nb2, _Complex double *a, int lda, _Complex double *t, int ldt, _Complex double *work, int lwork)
     * }
     */
    public static int LAPACKE_zgetsqrhrt_work(int matrix_layout, int m, int n, int mb1, int nb1, int nb2, MemorySegment a, int lda, MemorySegment t, int ldt, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_zgetsqrhrt_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zgetsqrhrt_work", matrix_layout, m, n, mb1, nb1, nb2, a, lda, t, ldt, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, mb1, nb1, nb2, a, lda, t, ldt, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ssyev_2stage {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_ssyev_2stage");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ssyev_2stage(int matrix_layout, char jobz, char uplo, int n, float *a, int lda, float *w)
     * }
     */
    public static FunctionDescriptor LAPACKE_ssyev_2stage$descriptor() {
        return LAPACKE_ssyev_2stage.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ssyev_2stage(int matrix_layout, char jobz, char uplo, int n, float *a, int lda, float *w)
     * }
     */
    public static MethodHandle LAPACKE_ssyev_2stage$handle() {
        return LAPACKE_ssyev_2stage.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ssyev_2stage(int matrix_layout, char jobz, char uplo, int n, float *a, int lda, float *w)
     * }
     */
    public static MemorySegment LAPACKE_ssyev_2stage$address() {
        return LAPACKE_ssyev_2stage.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ssyev_2stage(int matrix_layout, char jobz, char uplo, int n, float *a, int lda, float *w)
     * }
     */
    public static int LAPACKE_ssyev_2stage(int matrix_layout, byte jobz, byte uplo, int n, MemorySegment a, int lda, MemorySegment w) {
        var mh$ = LAPACKE_ssyev_2stage.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ssyev_2stage", matrix_layout, jobz, uplo, n, a, lda, w);
            }
            return (int)mh$.invokeExact(matrix_layout, jobz, uplo, n, a, lda, w);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dsyev_2stage {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dsyev_2stage");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dsyev_2stage(int matrix_layout, char jobz, char uplo, int n, double *a, int lda, double *w)
     * }
     */
    public static FunctionDescriptor LAPACKE_dsyev_2stage$descriptor() {
        return LAPACKE_dsyev_2stage.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dsyev_2stage(int matrix_layout, char jobz, char uplo, int n, double *a, int lda, double *w)
     * }
     */
    public static MethodHandle LAPACKE_dsyev_2stage$handle() {
        return LAPACKE_dsyev_2stage.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dsyev_2stage(int matrix_layout, char jobz, char uplo, int n, double *a, int lda, double *w)
     * }
     */
    public static MemorySegment LAPACKE_dsyev_2stage$address() {
        return LAPACKE_dsyev_2stage.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dsyev_2stage(int matrix_layout, char jobz, char uplo, int n, double *a, int lda, double *w)
     * }
     */
    public static int LAPACKE_dsyev_2stage(int matrix_layout, byte jobz, byte uplo, int n, MemorySegment a, int lda, MemorySegment w) {
        var mh$ = LAPACKE_dsyev_2stage.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dsyev_2stage", matrix_layout, jobz, uplo, n, a, lda, w);
            }
            return (int)mh$.invokeExact(matrix_layout, jobz, uplo, n, a, lda, w);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ssyevd_2stage {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_ssyevd_2stage");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ssyevd_2stage(int matrix_layout, char jobz, char uplo, int n, float *a, int lda, float *w)
     * }
     */
    public static FunctionDescriptor LAPACKE_ssyevd_2stage$descriptor() {
        return LAPACKE_ssyevd_2stage.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ssyevd_2stage(int matrix_layout, char jobz, char uplo, int n, float *a, int lda, float *w)
     * }
     */
    public static MethodHandle LAPACKE_ssyevd_2stage$handle() {
        return LAPACKE_ssyevd_2stage.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ssyevd_2stage(int matrix_layout, char jobz, char uplo, int n, float *a, int lda, float *w)
     * }
     */
    public static MemorySegment LAPACKE_ssyevd_2stage$address() {
        return LAPACKE_ssyevd_2stage.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ssyevd_2stage(int matrix_layout, char jobz, char uplo, int n, float *a, int lda, float *w)
     * }
     */
    public static int LAPACKE_ssyevd_2stage(int matrix_layout, byte jobz, byte uplo, int n, MemorySegment a, int lda, MemorySegment w) {
        var mh$ = LAPACKE_ssyevd_2stage.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ssyevd_2stage", matrix_layout, jobz, uplo, n, a, lda, w);
            }
            return (int)mh$.invokeExact(matrix_layout, jobz, uplo, n, a, lda, w);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dsyevd_2stage {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dsyevd_2stage");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dsyevd_2stage(int matrix_layout, char jobz, char uplo, int n, double *a, int lda, double *w)
     * }
     */
    public static FunctionDescriptor LAPACKE_dsyevd_2stage$descriptor() {
        return LAPACKE_dsyevd_2stage.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dsyevd_2stage(int matrix_layout, char jobz, char uplo, int n, double *a, int lda, double *w)
     * }
     */
    public static MethodHandle LAPACKE_dsyevd_2stage$handle() {
        return LAPACKE_dsyevd_2stage.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dsyevd_2stage(int matrix_layout, char jobz, char uplo, int n, double *a, int lda, double *w)
     * }
     */
    public static MemorySegment LAPACKE_dsyevd_2stage$address() {
        return LAPACKE_dsyevd_2stage.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dsyevd_2stage(int matrix_layout, char jobz, char uplo, int n, double *a, int lda, double *w)
     * }
     */
    public static int LAPACKE_dsyevd_2stage(int matrix_layout, byte jobz, byte uplo, int n, MemorySegment a, int lda, MemorySegment w) {
        var mh$ = LAPACKE_dsyevd_2stage.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dsyevd_2stage", matrix_layout, jobz, uplo, n, a, lda, w);
            }
            return (int)mh$.invokeExact(matrix_layout, jobz, uplo, n, a, lda, w);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ssyevr_2stage {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_ssyevr_2stage");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ssyevr_2stage(int matrix_layout, char jobz, char range, char uplo, int n, float *a, int lda, float vl, float vu, int il, int iu, float abstol, int *m, float *w, float *z, int ldz, int *isuppz)
     * }
     */
    public static FunctionDescriptor LAPACKE_ssyevr_2stage$descriptor() {
        return LAPACKE_ssyevr_2stage.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ssyevr_2stage(int matrix_layout, char jobz, char range, char uplo, int n, float *a, int lda, float vl, float vu, int il, int iu, float abstol, int *m, float *w, float *z, int ldz, int *isuppz)
     * }
     */
    public static MethodHandle LAPACKE_ssyevr_2stage$handle() {
        return LAPACKE_ssyevr_2stage.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ssyevr_2stage(int matrix_layout, char jobz, char range, char uplo, int n, float *a, int lda, float vl, float vu, int il, int iu, float abstol, int *m, float *w, float *z, int ldz, int *isuppz)
     * }
     */
    public static MemorySegment LAPACKE_ssyevr_2stage$address() {
        return LAPACKE_ssyevr_2stage.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ssyevr_2stage(int matrix_layout, char jobz, char range, char uplo, int n, float *a, int lda, float vl, float vu, int il, int iu, float abstol, int *m, float *w, float *z, int ldz, int *isuppz)
     * }
     */
    public static int LAPACKE_ssyevr_2stage(int matrix_layout, byte jobz, byte range, byte uplo, int n, MemorySegment a, int lda, float vl, float vu, int il, int iu, float abstol, MemorySegment m, MemorySegment w, MemorySegment z, int ldz, MemorySegment isuppz) {
        var mh$ = LAPACKE_ssyevr_2stage.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ssyevr_2stage", matrix_layout, jobz, range, uplo, n, a, lda, vl, vu, il, iu, abstol, m, w, z, ldz, isuppz);
            }
            return (int)mh$.invokeExact(matrix_layout, jobz, range, uplo, n, a, lda, vl, vu, il, iu, abstol, m, w, z, ldz, isuppz);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dsyevr_2stage {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dsyevr_2stage");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dsyevr_2stage(int matrix_layout, char jobz, char range, char uplo, int n, double *a, int lda, double vl, double vu, int il, int iu, double abstol, int *m, double *w, double *z, int ldz, int *isuppz)
     * }
     */
    public static FunctionDescriptor LAPACKE_dsyevr_2stage$descriptor() {
        return LAPACKE_dsyevr_2stage.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dsyevr_2stage(int matrix_layout, char jobz, char range, char uplo, int n, double *a, int lda, double vl, double vu, int il, int iu, double abstol, int *m, double *w, double *z, int ldz, int *isuppz)
     * }
     */
    public static MethodHandle LAPACKE_dsyevr_2stage$handle() {
        return LAPACKE_dsyevr_2stage.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dsyevr_2stage(int matrix_layout, char jobz, char range, char uplo, int n, double *a, int lda, double vl, double vu, int il, int iu, double abstol, int *m, double *w, double *z, int ldz, int *isuppz)
     * }
     */
    public static MemorySegment LAPACKE_dsyevr_2stage$address() {
        return LAPACKE_dsyevr_2stage.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dsyevr_2stage(int matrix_layout, char jobz, char range, char uplo, int n, double *a, int lda, double vl, double vu, int il, int iu, double abstol, int *m, double *w, double *z, int ldz, int *isuppz)
     * }
     */
    public static int LAPACKE_dsyevr_2stage(int matrix_layout, byte jobz, byte range, byte uplo, int n, MemorySegment a, int lda, double vl, double vu, int il, int iu, double abstol, MemorySegment m, MemorySegment w, MemorySegment z, int ldz, MemorySegment isuppz) {
        var mh$ = LAPACKE_dsyevr_2stage.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dsyevr_2stage", matrix_layout, jobz, range, uplo, n, a, lda, vl, vu, il, iu, abstol, m, w, z, ldz, isuppz);
            }
            return (int)mh$.invokeExact(matrix_layout, jobz, range, uplo, n, a, lda, vl, vu, il, iu, abstol, m, w, z, ldz, isuppz);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ssyevx_2stage {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_ssyevx_2stage");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ssyevx_2stage(int matrix_layout, char jobz, char range, char uplo, int n, float *a, int lda, float vl, float vu, int il, int iu, float abstol, int *m, float *w, float *z, int ldz, int *ifail)
     * }
     */
    public static FunctionDescriptor LAPACKE_ssyevx_2stage$descriptor() {
        return LAPACKE_ssyevx_2stage.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ssyevx_2stage(int matrix_layout, char jobz, char range, char uplo, int n, float *a, int lda, float vl, float vu, int il, int iu, float abstol, int *m, float *w, float *z, int ldz, int *ifail)
     * }
     */
    public static MethodHandle LAPACKE_ssyevx_2stage$handle() {
        return LAPACKE_ssyevx_2stage.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ssyevx_2stage(int matrix_layout, char jobz, char range, char uplo, int n, float *a, int lda, float vl, float vu, int il, int iu, float abstol, int *m, float *w, float *z, int ldz, int *ifail)
     * }
     */
    public static MemorySegment LAPACKE_ssyevx_2stage$address() {
        return LAPACKE_ssyevx_2stage.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ssyevx_2stage(int matrix_layout, char jobz, char range, char uplo, int n, float *a, int lda, float vl, float vu, int il, int iu, float abstol, int *m, float *w, float *z, int ldz, int *ifail)
     * }
     */
    public static int LAPACKE_ssyevx_2stage(int matrix_layout, byte jobz, byte range, byte uplo, int n, MemorySegment a, int lda, float vl, float vu, int il, int iu, float abstol, MemorySegment m, MemorySegment w, MemorySegment z, int ldz, MemorySegment ifail) {
        var mh$ = LAPACKE_ssyevx_2stage.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ssyevx_2stage", matrix_layout, jobz, range, uplo, n, a, lda, vl, vu, il, iu, abstol, m, w, z, ldz, ifail);
            }
            return (int)mh$.invokeExact(matrix_layout, jobz, range, uplo, n, a, lda, vl, vu, il, iu, abstol, m, w, z, ldz, ifail);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dsyevx_2stage {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dsyevx_2stage");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dsyevx_2stage(int matrix_layout, char jobz, char range, char uplo, int n, double *a, int lda, double vl, double vu, int il, int iu, double abstol, int *m, double *w, double *z, int ldz, int *ifail)
     * }
     */
    public static FunctionDescriptor LAPACKE_dsyevx_2stage$descriptor() {
        return LAPACKE_dsyevx_2stage.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dsyevx_2stage(int matrix_layout, char jobz, char range, char uplo, int n, double *a, int lda, double vl, double vu, int il, int iu, double abstol, int *m, double *w, double *z, int ldz, int *ifail)
     * }
     */
    public static MethodHandle LAPACKE_dsyevx_2stage$handle() {
        return LAPACKE_dsyevx_2stage.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dsyevx_2stage(int matrix_layout, char jobz, char range, char uplo, int n, double *a, int lda, double vl, double vu, int il, int iu, double abstol, int *m, double *w, double *z, int ldz, int *ifail)
     * }
     */
    public static MemorySegment LAPACKE_dsyevx_2stage$address() {
        return LAPACKE_dsyevx_2stage.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dsyevx_2stage(int matrix_layout, char jobz, char range, char uplo, int n, double *a, int lda, double vl, double vu, int il, int iu, double abstol, int *m, double *w, double *z, int ldz, int *ifail)
     * }
     */
    public static int LAPACKE_dsyevx_2stage(int matrix_layout, byte jobz, byte range, byte uplo, int n, MemorySegment a, int lda, double vl, double vu, int il, int iu, double abstol, MemorySegment m, MemorySegment w, MemorySegment z, int ldz, MemorySegment ifail) {
        var mh$ = LAPACKE_dsyevx_2stage.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dsyevx_2stage", matrix_layout, jobz, range, uplo, n, a, lda, vl, vu, il, iu, abstol, m, w, z, ldz, ifail);
            }
            return (int)mh$.invokeExact(matrix_layout, jobz, range, uplo, n, a, lda, vl, vu, il, iu, abstol, m, w, z, ldz, ifail);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ssyev_2stage_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_ssyev_2stage_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ssyev_2stage_work(int matrix_layout, char jobz, char uplo, int n, float *a, int lda, float *w, float *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_ssyev_2stage_work$descriptor() {
        return LAPACKE_ssyev_2stage_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ssyev_2stage_work(int matrix_layout, char jobz, char uplo, int n, float *a, int lda, float *w, float *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_ssyev_2stage_work$handle() {
        return LAPACKE_ssyev_2stage_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ssyev_2stage_work(int matrix_layout, char jobz, char uplo, int n, float *a, int lda, float *w, float *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_ssyev_2stage_work$address() {
        return LAPACKE_ssyev_2stage_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ssyev_2stage_work(int matrix_layout, char jobz, char uplo, int n, float *a, int lda, float *w, float *work, int lwork)
     * }
     */
    public static int LAPACKE_ssyev_2stage_work(int matrix_layout, byte jobz, byte uplo, int n, MemorySegment a, int lda, MemorySegment w, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_ssyev_2stage_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ssyev_2stage_work", matrix_layout, jobz, uplo, n, a, lda, w, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, jobz, uplo, n, a, lda, w, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dsyev_2stage_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dsyev_2stage_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dsyev_2stage_work(int matrix_layout, char jobz, char uplo, int n, double *a, int lda, double *w, double *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_dsyev_2stage_work$descriptor() {
        return LAPACKE_dsyev_2stage_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dsyev_2stage_work(int matrix_layout, char jobz, char uplo, int n, double *a, int lda, double *w, double *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_dsyev_2stage_work$handle() {
        return LAPACKE_dsyev_2stage_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dsyev_2stage_work(int matrix_layout, char jobz, char uplo, int n, double *a, int lda, double *w, double *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_dsyev_2stage_work$address() {
        return LAPACKE_dsyev_2stage_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dsyev_2stage_work(int matrix_layout, char jobz, char uplo, int n, double *a, int lda, double *w, double *work, int lwork)
     * }
     */
    public static int LAPACKE_dsyev_2stage_work(int matrix_layout, byte jobz, byte uplo, int n, MemorySegment a, int lda, MemorySegment w, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_dsyev_2stage_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dsyev_2stage_work", matrix_layout, jobz, uplo, n, a, lda, w, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, jobz, uplo, n, a, lda, w, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ssyevd_2stage_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_ssyevd_2stage_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ssyevd_2stage_work(int matrix_layout, char jobz, char uplo, int n, float *a, int lda, float *w, float *work, int lwork, int *iwork, int liwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_ssyevd_2stage_work$descriptor() {
        return LAPACKE_ssyevd_2stage_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ssyevd_2stage_work(int matrix_layout, char jobz, char uplo, int n, float *a, int lda, float *w, float *work, int lwork, int *iwork, int liwork)
     * }
     */
    public static MethodHandle LAPACKE_ssyevd_2stage_work$handle() {
        return LAPACKE_ssyevd_2stage_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ssyevd_2stage_work(int matrix_layout, char jobz, char uplo, int n, float *a, int lda, float *w, float *work, int lwork, int *iwork, int liwork)
     * }
     */
    public static MemorySegment LAPACKE_ssyevd_2stage_work$address() {
        return LAPACKE_ssyevd_2stage_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ssyevd_2stage_work(int matrix_layout, char jobz, char uplo, int n, float *a, int lda, float *w, float *work, int lwork, int *iwork, int liwork)
     * }
     */
    public static int LAPACKE_ssyevd_2stage_work(int matrix_layout, byte jobz, byte uplo, int n, MemorySegment a, int lda, MemorySegment w, MemorySegment work, int lwork, MemorySegment iwork, int liwork) {
        var mh$ = LAPACKE_ssyevd_2stage_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ssyevd_2stage_work", matrix_layout, jobz, uplo, n, a, lda, w, work, lwork, iwork, liwork);
            }
            return (int)mh$.invokeExact(matrix_layout, jobz, uplo, n, a, lda, w, work, lwork, iwork, liwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dsyevd_2stage_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dsyevd_2stage_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dsyevd_2stage_work(int matrix_layout, char jobz, char uplo, int n, double *a, int lda, double *w, double *work, int lwork, int *iwork, int liwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_dsyevd_2stage_work$descriptor() {
        return LAPACKE_dsyevd_2stage_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dsyevd_2stage_work(int matrix_layout, char jobz, char uplo, int n, double *a, int lda, double *w, double *work, int lwork, int *iwork, int liwork)
     * }
     */
    public static MethodHandle LAPACKE_dsyevd_2stage_work$handle() {
        return LAPACKE_dsyevd_2stage_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dsyevd_2stage_work(int matrix_layout, char jobz, char uplo, int n, double *a, int lda, double *w, double *work, int lwork, int *iwork, int liwork)
     * }
     */
    public static MemorySegment LAPACKE_dsyevd_2stage_work$address() {
        return LAPACKE_dsyevd_2stage_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dsyevd_2stage_work(int matrix_layout, char jobz, char uplo, int n, double *a, int lda, double *w, double *work, int lwork, int *iwork, int liwork)
     * }
     */
    public static int LAPACKE_dsyevd_2stage_work(int matrix_layout, byte jobz, byte uplo, int n, MemorySegment a, int lda, MemorySegment w, MemorySegment work, int lwork, MemorySegment iwork, int liwork) {
        var mh$ = LAPACKE_dsyevd_2stage_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dsyevd_2stage_work", matrix_layout, jobz, uplo, n, a, lda, w, work, lwork, iwork, liwork);
            }
            return (int)mh$.invokeExact(matrix_layout, jobz, uplo, n, a, lda, w, work, lwork, iwork, liwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ssyevr_2stage_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_ssyevr_2stage_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ssyevr_2stage_work(int matrix_layout, char jobz, char range, char uplo, int n, float *a, int lda, float vl, float vu, int il, int iu, float abstol, int *m, float *w, float *z, int ldz, int *isuppz, float *work, int lwork, int *iwork, int liwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_ssyevr_2stage_work$descriptor() {
        return LAPACKE_ssyevr_2stage_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ssyevr_2stage_work(int matrix_layout, char jobz, char range, char uplo, int n, float *a, int lda, float vl, float vu, int il, int iu, float abstol, int *m, float *w, float *z, int ldz, int *isuppz, float *work, int lwork, int *iwork, int liwork)
     * }
     */
    public static MethodHandle LAPACKE_ssyevr_2stage_work$handle() {
        return LAPACKE_ssyevr_2stage_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ssyevr_2stage_work(int matrix_layout, char jobz, char range, char uplo, int n, float *a, int lda, float vl, float vu, int il, int iu, float abstol, int *m, float *w, float *z, int ldz, int *isuppz, float *work, int lwork, int *iwork, int liwork)
     * }
     */
    public static MemorySegment LAPACKE_ssyevr_2stage_work$address() {
        return LAPACKE_ssyevr_2stage_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ssyevr_2stage_work(int matrix_layout, char jobz, char range, char uplo, int n, float *a, int lda, float vl, float vu, int il, int iu, float abstol, int *m, float *w, float *z, int ldz, int *isuppz, float *work, int lwork, int *iwork, int liwork)
     * }
     */
    public static int LAPACKE_ssyevr_2stage_work(int matrix_layout, byte jobz, byte range, byte uplo, int n, MemorySegment a, int lda, float vl, float vu, int il, int iu, float abstol, MemorySegment m, MemorySegment w, MemorySegment z, int ldz, MemorySegment isuppz, MemorySegment work, int lwork, MemorySegment iwork, int liwork) {
        var mh$ = LAPACKE_ssyevr_2stage_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ssyevr_2stage_work", matrix_layout, jobz, range, uplo, n, a, lda, vl, vu, il, iu, abstol, m, w, z, ldz, isuppz, work, lwork, iwork, liwork);
            }
            return (int)mh$.invokeExact(matrix_layout, jobz, range, uplo, n, a, lda, vl, vu, il, iu, abstol, m, w, z, ldz, isuppz, work, lwork, iwork, liwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dsyevr_2stage_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dsyevr_2stage_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dsyevr_2stage_work(int matrix_layout, char jobz, char range, char uplo, int n, double *a, int lda, double vl, double vu, int il, int iu, double abstol, int *m, double *w, double *z, int ldz, int *isuppz, double *work, int lwork, int *iwork, int liwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_dsyevr_2stage_work$descriptor() {
        return LAPACKE_dsyevr_2stage_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dsyevr_2stage_work(int matrix_layout, char jobz, char range, char uplo, int n, double *a, int lda, double vl, double vu, int il, int iu, double abstol, int *m, double *w, double *z, int ldz, int *isuppz, double *work, int lwork, int *iwork, int liwork)
     * }
     */
    public static MethodHandle LAPACKE_dsyevr_2stage_work$handle() {
        return LAPACKE_dsyevr_2stage_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dsyevr_2stage_work(int matrix_layout, char jobz, char range, char uplo, int n, double *a, int lda, double vl, double vu, int il, int iu, double abstol, int *m, double *w, double *z, int ldz, int *isuppz, double *work, int lwork, int *iwork, int liwork)
     * }
     */
    public static MemorySegment LAPACKE_dsyevr_2stage_work$address() {
        return LAPACKE_dsyevr_2stage_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dsyevr_2stage_work(int matrix_layout, char jobz, char range, char uplo, int n, double *a, int lda, double vl, double vu, int il, int iu, double abstol, int *m, double *w, double *z, int ldz, int *isuppz, double *work, int lwork, int *iwork, int liwork)
     * }
     */
    public static int LAPACKE_dsyevr_2stage_work(int matrix_layout, byte jobz, byte range, byte uplo, int n, MemorySegment a, int lda, double vl, double vu, int il, int iu, double abstol, MemorySegment m, MemorySegment w, MemorySegment z, int ldz, MemorySegment isuppz, MemorySegment work, int lwork, MemorySegment iwork, int liwork) {
        var mh$ = LAPACKE_dsyevr_2stage_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dsyevr_2stage_work", matrix_layout, jobz, range, uplo, n, a, lda, vl, vu, il, iu, abstol, m, w, z, ldz, isuppz, work, lwork, iwork, liwork);
            }
            return (int)mh$.invokeExact(matrix_layout, jobz, range, uplo, n, a, lda, vl, vu, il, iu, abstol, m, w, z, ldz, isuppz, work, lwork, iwork, liwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ssyevx_2stage_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_ssyevx_2stage_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ssyevx_2stage_work(int matrix_layout, char jobz, char range, char uplo, int n, float *a, int lda, float vl, float vu, int il, int iu, float abstol, int *m, float *w, float *z, int ldz, float *work, int lwork, int *iwork, int *ifail)
     * }
     */
    public static FunctionDescriptor LAPACKE_ssyevx_2stage_work$descriptor() {
        return LAPACKE_ssyevx_2stage_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ssyevx_2stage_work(int matrix_layout, char jobz, char range, char uplo, int n, float *a, int lda, float vl, float vu, int il, int iu, float abstol, int *m, float *w, float *z, int ldz, float *work, int lwork, int *iwork, int *ifail)
     * }
     */
    public static MethodHandle LAPACKE_ssyevx_2stage_work$handle() {
        return LAPACKE_ssyevx_2stage_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ssyevx_2stage_work(int matrix_layout, char jobz, char range, char uplo, int n, float *a, int lda, float vl, float vu, int il, int iu, float abstol, int *m, float *w, float *z, int ldz, float *work, int lwork, int *iwork, int *ifail)
     * }
     */
    public static MemorySegment LAPACKE_ssyevx_2stage_work$address() {
        return LAPACKE_ssyevx_2stage_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ssyevx_2stage_work(int matrix_layout, char jobz, char range, char uplo, int n, float *a, int lda, float vl, float vu, int il, int iu, float abstol, int *m, float *w, float *z, int ldz, float *work, int lwork, int *iwork, int *ifail)
     * }
     */
    public static int LAPACKE_ssyevx_2stage_work(int matrix_layout, byte jobz, byte range, byte uplo, int n, MemorySegment a, int lda, float vl, float vu, int il, int iu, float abstol, MemorySegment m, MemorySegment w, MemorySegment z, int ldz, MemorySegment work, int lwork, MemorySegment iwork, MemorySegment ifail) {
        var mh$ = LAPACKE_ssyevx_2stage_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ssyevx_2stage_work", matrix_layout, jobz, range, uplo, n, a, lda, vl, vu, il, iu, abstol, m, w, z, ldz, work, lwork, iwork, ifail);
            }
            return (int)mh$.invokeExact(matrix_layout, jobz, range, uplo, n, a, lda, vl, vu, il, iu, abstol, m, w, z, ldz, work, lwork, iwork, ifail);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dsyevx_2stage_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dsyevx_2stage_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dsyevx_2stage_work(int matrix_layout, char jobz, char range, char uplo, int n, double *a, int lda, double vl, double vu, int il, int iu, double abstol, int *m, double *w, double *z, int ldz, double *work, int lwork, int *iwork, int *ifail)
     * }
     */
    public static FunctionDescriptor LAPACKE_dsyevx_2stage_work$descriptor() {
        return LAPACKE_dsyevx_2stage_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dsyevx_2stage_work(int matrix_layout, char jobz, char range, char uplo, int n, double *a, int lda, double vl, double vu, int il, int iu, double abstol, int *m, double *w, double *z, int ldz, double *work, int lwork, int *iwork, int *ifail)
     * }
     */
    public static MethodHandle LAPACKE_dsyevx_2stage_work$handle() {
        return LAPACKE_dsyevx_2stage_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dsyevx_2stage_work(int matrix_layout, char jobz, char range, char uplo, int n, double *a, int lda, double vl, double vu, int il, int iu, double abstol, int *m, double *w, double *z, int ldz, double *work, int lwork, int *iwork, int *ifail)
     * }
     */
    public static MemorySegment LAPACKE_dsyevx_2stage_work$address() {
        return LAPACKE_dsyevx_2stage_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dsyevx_2stage_work(int matrix_layout, char jobz, char range, char uplo, int n, double *a, int lda, double vl, double vu, int il, int iu, double abstol, int *m, double *w, double *z, int ldz, double *work, int lwork, int *iwork, int *ifail)
     * }
     */
    public static int LAPACKE_dsyevx_2stage_work(int matrix_layout, byte jobz, byte range, byte uplo, int n, MemorySegment a, int lda, double vl, double vu, int il, int iu, double abstol, MemorySegment m, MemorySegment w, MemorySegment z, int ldz, MemorySegment work, int lwork, MemorySegment iwork, MemorySegment ifail) {
        var mh$ = LAPACKE_dsyevx_2stage_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dsyevx_2stage_work", matrix_layout, jobz, range, uplo, n, a, lda, vl, vu, il, iu, abstol, m, w, z, ldz, work, lwork, iwork, ifail);
            }
            return (int)mh$.invokeExact(matrix_layout, jobz, range, uplo, n, a, lda, vl, vu, il, iu, abstol, m, w, z, ldz, work, lwork, iwork, ifail);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cheev_2stage {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_cheev_2stage");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cheev_2stage(int matrix_layout, char jobz, char uplo, int n, _Complex float *a, int lda, float *w)
     * }
     */
    public static FunctionDescriptor LAPACKE_cheev_2stage$descriptor() {
        return LAPACKE_cheev_2stage.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cheev_2stage(int matrix_layout, char jobz, char uplo, int n, _Complex float *a, int lda, float *w)
     * }
     */
    public static MethodHandle LAPACKE_cheev_2stage$handle() {
        return LAPACKE_cheev_2stage.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cheev_2stage(int matrix_layout, char jobz, char uplo, int n, _Complex float *a, int lda, float *w)
     * }
     */
    public static MemorySegment LAPACKE_cheev_2stage$address() {
        return LAPACKE_cheev_2stage.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cheev_2stage(int matrix_layout, char jobz, char uplo, int n, _Complex float *a, int lda, float *w)
     * }
     */
    public static int LAPACKE_cheev_2stage(int matrix_layout, byte jobz, byte uplo, int n, MemorySegment a, int lda, MemorySegment w) {
        var mh$ = LAPACKE_cheev_2stage.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cheev_2stage", matrix_layout, jobz, uplo, n, a, lda, w);
            }
            return (int)mh$.invokeExact(matrix_layout, jobz, uplo, n, a, lda, w);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zheev_2stage {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zheev_2stage");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zheev_2stage(int matrix_layout, char jobz, char uplo, int n, _Complex double *a, int lda, double *w)
     * }
     */
    public static FunctionDescriptor LAPACKE_zheev_2stage$descriptor() {
        return LAPACKE_zheev_2stage.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zheev_2stage(int matrix_layout, char jobz, char uplo, int n, _Complex double *a, int lda, double *w)
     * }
     */
    public static MethodHandle LAPACKE_zheev_2stage$handle() {
        return LAPACKE_zheev_2stage.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zheev_2stage(int matrix_layout, char jobz, char uplo, int n, _Complex double *a, int lda, double *w)
     * }
     */
    public static MemorySegment LAPACKE_zheev_2stage$address() {
        return LAPACKE_zheev_2stage.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zheev_2stage(int matrix_layout, char jobz, char uplo, int n, _Complex double *a, int lda, double *w)
     * }
     */
    public static int LAPACKE_zheev_2stage(int matrix_layout, byte jobz, byte uplo, int n, MemorySegment a, int lda, MemorySegment w) {
        var mh$ = LAPACKE_zheev_2stage.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zheev_2stage", matrix_layout, jobz, uplo, n, a, lda, w);
            }
            return (int)mh$.invokeExact(matrix_layout, jobz, uplo, n, a, lda, w);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cheevd_2stage {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_cheevd_2stage");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cheevd_2stage(int matrix_layout, char jobz, char uplo, int n, _Complex float *a, int lda, float *w)
     * }
     */
    public static FunctionDescriptor LAPACKE_cheevd_2stage$descriptor() {
        return LAPACKE_cheevd_2stage.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cheevd_2stage(int matrix_layout, char jobz, char uplo, int n, _Complex float *a, int lda, float *w)
     * }
     */
    public static MethodHandle LAPACKE_cheevd_2stage$handle() {
        return LAPACKE_cheevd_2stage.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cheevd_2stage(int matrix_layout, char jobz, char uplo, int n, _Complex float *a, int lda, float *w)
     * }
     */
    public static MemorySegment LAPACKE_cheevd_2stage$address() {
        return LAPACKE_cheevd_2stage.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cheevd_2stage(int matrix_layout, char jobz, char uplo, int n, _Complex float *a, int lda, float *w)
     * }
     */
    public static int LAPACKE_cheevd_2stage(int matrix_layout, byte jobz, byte uplo, int n, MemorySegment a, int lda, MemorySegment w) {
        var mh$ = LAPACKE_cheevd_2stage.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cheevd_2stage", matrix_layout, jobz, uplo, n, a, lda, w);
            }
            return (int)mh$.invokeExact(matrix_layout, jobz, uplo, n, a, lda, w);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zheevd_2stage {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zheevd_2stage");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zheevd_2stage(int matrix_layout, char jobz, char uplo, int n, _Complex double *a, int lda, double *w)
     * }
     */
    public static FunctionDescriptor LAPACKE_zheevd_2stage$descriptor() {
        return LAPACKE_zheevd_2stage.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zheevd_2stage(int matrix_layout, char jobz, char uplo, int n, _Complex double *a, int lda, double *w)
     * }
     */
    public static MethodHandle LAPACKE_zheevd_2stage$handle() {
        return LAPACKE_zheevd_2stage.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zheevd_2stage(int matrix_layout, char jobz, char uplo, int n, _Complex double *a, int lda, double *w)
     * }
     */
    public static MemorySegment LAPACKE_zheevd_2stage$address() {
        return LAPACKE_zheevd_2stage.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zheevd_2stage(int matrix_layout, char jobz, char uplo, int n, _Complex double *a, int lda, double *w)
     * }
     */
    public static int LAPACKE_zheevd_2stage(int matrix_layout, byte jobz, byte uplo, int n, MemorySegment a, int lda, MemorySegment w) {
        var mh$ = LAPACKE_zheevd_2stage.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zheevd_2stage", matrix_layout, jobz, uplo, n, a, lda, w);
            }
            return (int)mh$.invokeExact(matrix_layout, jobz, uplo, n, a, lda, w);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cheevr_2stage {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_cheevr_2stage");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cheevr_2stage(int matrix_layout, char jobz, char range, char uplo, int n, _Complex float *a, int lda, float vl, float vu, int il, int iu, float abstol, int *m, float *w, _Complex float *z, int ldz, int *isuppz)
     * }
     */
    public static FunctionDescriptor LAPACKE_cheevr_2stage$descriptor() {
        return LAPACKE_cheevr_2stage.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cheevr_2stage(int matrix_layout, char jobz, char range, char uplo, int n, _Complex float *a, int lda, float vl, float vu, int il, int iu, float abstol, int *m, float *w, _Complex float *z, int ldz, int *isuppz)
     * }
     */
    public static MethodHandle LAPACKE_cheevr_2stage$handle() {
        return LAPACKE_cheevr_2stage.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cheevr_2stage(int matrix_layout, char jobz, char range, char uplo, int n, _Complex float *a, int lda, float vl, float vu, int il, int iu, float abstol, int *m, float *w, _Complex float *z, int ldz, int *isuppz)
     * }
     */
    public static MemorySegment LAPACKE_cheevr_2stage$address() {
        return LAPACKE_cheevr_2stage.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cheevr_2stage(int matrix_layout, char jobz, char range, char uplo, int n, _Complex float *a, int lda, float vl, float vu, int il, int iu, float abstol, int *m, float *w, _Complex float *z, int ldz, int *isuppz)
     * }
     */
    public static int LAPACKE_cheevr_2stage(int matrix_layout, byte jobz, byte range, byte uplo, int n, MemorySegment a, int lda, float vl, float vu, int il, int iu, float abstol, MemorySegment m, MemorySegment w, MemorySegment z, int ldz, MemorySegment isuppz) {
        var mh$ = LAPACKE_cheevr_2stage.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cheevr_2stage", matrix_layout, jobz, range, uplo, n, a, lda, vl, vu, il, iu, abstol, m, w, z, ldz, isuppz);
            }
            return (int)mh$.invokeExact(matrix_layout, jobz, range, uplo, n, a, lda, vl, vu, il, iu, abstol, m, w, z, ldz, isuppz);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zheevr_2stage {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zheevr_2stage");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zheevr_2stage(int matrix_layout, char jobz, char range, char uplo, int n, _Complex double *a, int lda, double vl, double vu, int il, int iu, double abstol, int *m, double *w, _Complex double *z, int ldz, int *isuppz)
     * }
     */
    public static FunctionDescriptor LAPACKE_zheevr_2stage$descriptor() {
        return LAPACKE_zheevr_2stage.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zheevr_2stage(int matrix_layout, char jobz, char range, char uplo, int n, _Complex double *a, int lda, double vl, double vu, int il, int iu, double abstol, int *m, double *w, _Complex double *z, int ldz, int *isuppz)
     * }
     */
    public static MethodHandle LAPACKE_zheevr_2stage$handle() {
        return LAPACKE_zheevr_2stage.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zheevr_2stage(int matrix_layout, char jobz, char range, char uplo, int n, _Complex double *a, int lda, double vl, double vu, int il, int iu, double abstol, int *m, double *w, _Complex double *z, int ldz, int *isuppz)
     * }
     */
    public static MemorySegment LAPACKE_zheevr_2stage$address() {
        return LAPACKE_zheevr_2stage.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zheevr_2stage(int matrix_layout, char jobz, char range, char uplo, int n, _Complex double *a, int lda, double vl, double vu, int il, int iu, double abstol, int *m, double *w, _Complex double *z, int ldz, int *isuppz)
     * }
     */
    public static int LAPACKE_zheevr_2stage(int matrix_layout, byte jobz, byte range, byte uplo, int n, MemorySegment a, int lda, double vl, double vu, int il, int iu, double abstol, MemorySegment m, MemorySegment w, MemorySegment z, int ldz, MemorySegment isuppz) {
        var mh$ = LAPACKE_zheevr_2stage.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zheevr_2stage", matrix_layout, jobz, range, uplo, n, a, lda, vl, vu, il, iu, abstol, m, w, z, ldz, isuppz);
            }
            return (int)mh$.invokeExact(matrix_layout, jobz, range, uplo, n, a, lda, vl, vu, il, iu, abstol, m, w, z, ldz, isuppz);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cheevx_2stage {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_cheevx_2stage");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cheevx_2stage(int matrix_layout, char jobz, char range, char uplo, int n, _Complex float *a, int lda, float vl, float vu, int il, int iu, float abstol, int *m, float *w, _Complex float *z, int ldz, int *ifail)
     * }
     */
    public static FunctionDescriptor LAPACKE_cheevx_2stage$descriptor() {
        return LAPACKE_cheevx_2stage.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cheevx_2stage(int matrix_layout, char jobz, char range, char uplo, int n, _Complex float *a, int lda, float vl, float vu, int il, int iu, float abstol, int *m, float *w, _Complex float *z, int ldz, int *ifail)
     * }
     */
    public static MethodHandle LAPACKE_cheevx_2stage$handle() {
        return LAPACKE_cheevx_2stage.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cheevx_2stage(int matrix_layout, char jobz, char range, char uplo, int n, _Complex float *a, int lda, float vl, float vu, int il, int iu, float abstol, int *m, float *w, _Complex float *z, int ldz, int *ifail)
     * }
     */
    public static MemorySegment LAPACKE_cheevx_2stage$address() {
        return LAPACKE_cheevx_2stage.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cheevx_2stage(int matrix_layout, char jobz, char range, char uplo, int n, _Complex float *a, int lda, float vl, float vu, int il, int iu, float abstol, int *m, float *w, _Complex float *z, int ldz, int *ifail)
     * }
     */
    public static int LAPACKE_cheevx_2stage(int matrix_layout, byte jobz, byte range, byte uplo, int n, MemorySegment a, int lda, float vl, float vu, int il, int iu, float abstol, MemorySegment m, MemorySegment w, MemorySegment z, int ldz, MemorySegment ifail) {
        var mh$ = LAPACKE_cheevx_2stage.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cheevx_2stage", matrix_layout, jobz, range, uplo, n, a, lda, vl, vu, il, iu, abstol, m, w, z, ldz, ifail);
            }
            return (int)mh$.invokeExact(matrix_layout, jobz, range, uplo, n, a, lda, vl, vu, il, iu, abstol, m, w, z, ldz, ifail);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zheevx_2stage {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zheevx_2stage");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zheevx_2stage(int matrix_layout, char jobz, char range, char uplo, int n, _Complex double *a, int lda, double vl, double vu, int il, int iu, double abstol, int *m, double *w, _Complex double *z, int ldz, int *ifail)
     * }
     */
    public static FunctionDescriptor LAPACKE_zheevx_2stage$descriptor() {
        return LAPACKE_zheevx_2stage.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zheevx_2stage(int matrix_layout, char jobz, char range, char uplo, int n, _Complex double *a, int lda, double vl, double vu, int il, int iu, double abstol, int *m, double *w, _Complex double *z, int ldz, int *ifail)
     * }
     */
    public static MethodHandle LAPACKE_zheevx_2stage$handle() {
        return LAPACKE_zheevx_2stage.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zheevx_2stage(int matrix_layout, char jobz, char range, char uplo, int n, _Complex double *a, int lda, double vl, double vu, int il, int iu, double abstol, int *m, double *w, _Complex double *z, int ldz, int *ifail)
     * }
     */
    public static MemorySegment LAPACKE_zheevx_2stage$address() {
        return LAPACKE_zheevx_2stage.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zheevx_2stage(int matrix_layout, char jobz, char range, char uplo, int n, _Complex double *a, int lda, double vl, double vu, int il, int iu, double abstol, int *m, double *w, _Complex double *z, int ldz, int *ifail)
     * }
     */
    public static int LAPACKE_zheevx_2stage(int matrix_layout, byte jobz, byte range, byte uplo, int n, MemorySegment a, int lda, double vl, double vu, int il, int iu, double abstol, MemorySegment m, MemorySegment w, MemorySegment z, int ldz, MemorySegment ifail) {
        var mh$ = LAPACKE_zheevx_2stage.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zheevx_2stage", matrix_layout, jobz, range, uplo, n, a, lda, vl, vu, il, iu, abstol, m, w, z, ldz, ifail);
            }
            return (int)mh$.invokeExact(matrix_layout, jobz, range, uplo, n, a, lda, vl, vu, il, iu, abstol, m, w, z, ldz, ifail);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cheev_2stage_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_cheev_2stage_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cheev_2stage_work(int matrix_layout, char jobz, char uplo, int n, _Complex float *a, int lda, float *w, _Complex float *work, int lwork, float *rwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_cheev_2stage_work$descriptor() {
        return LAPACKE_cheev_2stage_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cheev_2stage_work(int matrix_layout, char jobz, char uplo, int n, _Complex float *a, int lda, float *w, _Complex float *work, int lwork, float *rwork)
     * }
     */
    public static MethodHandle LAPACKE_cheev_2stage_work$handle() {
        return LAPACKE_cheev_2stage_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cheev_2stage_work(int matrix_layout, char jobz, char uplo, int n, _Complex float *a, int lda, float *w, _Complex float *work, int lwork, float *rwork)
     * }
     */
    public static MemorySegment LAPACKE_cheev_2stage_work$address() {
        return LAPACKE_cheev_2stage_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cheev_2stage_work(int matrix_layout, char jobz, char uplo, int n, _Complex float *a, int lda, float *w, _Complex float *work, int lwork, float *rwork)
     * }
     */
    public static int LAPACKE_cheev_2stage_work(int matrix_layout, byte jobz, byte uplo, int n, MemorySegment a, int lda, MemorySegment w, MemorySegment work, int lwork, MemorySegment rwork) {
        var mh$ = LAPACKE_cheev_2stage_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cheev_2stage_work", matrix_layout, jobz, uplo, n, a, lda, w, work, lwork, rwork);
            }
            return (int)mh$.invokeExact(matrix_layout, jobz, uplo, n, a, lda, w, work, lwork, rwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zheev_2stage_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zheev_2stage_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zheev_2stage_work(int matrix_layout, char jobz, char uplo, int n, _Complex double *a, int lda, double *w, _Complex double *work, int lwork, double *rwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_zheev_2stage_work$descriptor() {
        return LAPACKE_zheev_2stage_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zheev_2stage_work(int matrix_layout, char jobz, char uplo, int n, _Complex double *a, int lda, double *w, _Complex double *work, int lwork, double *rwork)
     * }
     */
    public static MethodHandle LAPACKE_zheev_2stage_work$handle() {
        return LAPACKE_zheev_2stage_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zheev_2stage_work(int matrix_layout, char jobz, char uplo, int n, _Complex double *a, int lda, double *w, _Complex double *work, int lwork, double *rwork)
     * }
     */
    public static MemorySegment LAPACKE_zheev_2stage_work$address() {
        return LAPACKE_zheev_2stage_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zheev_2stage_work(int matrix_layout, char jobz, char uplo, int n, _Complex double *a, int lda, double *w, _Complex double *work, int lwork, double *rwork)
     * }
     */
    public static int LAPACKE_zheev_2stage_work(int matrix_layout, byte jobz, byte uplo, int n, MemorySegment a, int lda, MemorySegment w, MemorySegment work, int lwork, MemorySegment rwork) {
        var mh$ = LAPACKE_zheev_2stage_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zheev_2stage_work", matrix_layout, jobz, uplo, n, a, lda, w, work, lwork, rwork);
            }
            return (int)mh$.invokeExact(matrix_layout, jobz, uplo, n, a, lda, w, work, lwork, rwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cheevd_2stage_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_cheevd_2stage_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cheevd_2stage_work(int matrix_layout, char jobz, char uplo, int n, _Complex float *a, int lda, float *w, _Complex float *work, int lwork, float *rwork, int lrwork, int *iwork, int liwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_cheevd_2stage_work$descriptor() {
        return LAPACKE_cheevd_2stage_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cheevd_2stage_work(int matrix_layout, char jobz, char uplo, int n, _Complex float *a, int lda, float *w, _Complex float *work, int lwork, float *rwork, int lrwork, int *iwork, int liwork)
     * }
     */
    public static MethodHandle LAPACKE_cheevd_2stage_work$handle() {
        return LAPACKE_cheevd_2stage_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cheevd_2stage_work(int matrix_layout, char jobz, char uplo, int n, _Complex float *a, int lda, float *w, _Complex float *work, int lwork, float *rwork, int lrwork, int *iwork, int liwork)
     * }
     */
    public static MemorySegment LAPACKE_cheevd_2stage_work$address() {
        return LAPACKE_cheevd_2stage_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cheevd_2stage_work(int matrix_layout, char jobz, char uplo, int n, _Complex float *a, int lda, float *w, _Complex float *work, int lwork, float *rwork, int lrwork, int *iwork, int liwork)
     * }
     */
    public static int LAPACKE_cheevd_2stage_work(int matrix_layout, byte jobz, byte uplo, int n, MemorySegment a, int lda, MemorySegment w, MemorySegment work, int lwork, MemorySegment rwork, int lrwork, MemorySegment iwork, int liwork) {
        var mh$ = LAPACKE_cheevd_2stage_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cheevd_2stage_work", matrix_layout, jobz, uplo, n, a, lda, w, work, lwork, rwork, lrwork, iwork, liwork);
            }
            return (int)mh$.invokeExact(matrix_layout, jobz, uplo, n, a, lda, w, work, lwork, rwork, lrwork, iwork, liwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zheevd_2stage_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zheevd_2stage_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zheevd_2stage_work(int matrix_layout, char jobz, char uplo, int n, _Complex double *a, int lda, double *w, _Complex double *work, int lwork, double *rwork, int lrwork, int *iwork, int liwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_zheevd_2stage_work$descriptor() {
        return LAPACKE_zheevd_2stage_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zheevd_2stage_work(int matrix_layout, char jobz, char uplo, int n, _Complex double *a, int lda, double *w, _Complex double *work, int lwork, double *rwork, int lrwork, int *iwork, int liwork)
     * }
     */
    public static MethodHandle LAPACKE_zheevd_2stage_work$handle() {
        return LAPACKE_zheevd_2stage_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zheevd_2stage_work(int matrix_layout, char jobz, char uplo, int n, _Complex double *a, int lda, double *w, _Complex double *work, int lwork, double *rwork, int lrwork, int *iwork, int liwork)
     * }
     */
    public static MemorySegment LAPACKE_zheevd_2stage_work$address() {
        return LAPACKE_zheevd_2stage_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zheevd_2stage_work(int matrix_layout, char jobz, char uplo, int n, _Complex double *a, int lda, double *w, _Complex double *work, int lwork, double *rwork, int lrwork, int *iwork, int liwork)
     * }
     */
    public static int LAPACKE_zheevd_2stage_work(int matrix_layout, byte jobz, byte uplo, int n, MemorySegment a, int lda, MemorySegment w, MemorySegment work, int lwork, MemorySegment rwork, int lrwork, MemorySegment iwork, int liwork) {
        var mh$ = LAPACKE_zheevd_2stage_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zheevd_2stage_work", matrix_layout, jobz, uplo, n, a, lda, w, work, lwork, rwork, lrwork, iwork, liwork);
            }
            return (int)mh$.invokeExact(matrix_layout, jobz, uplo, n, a, lda, w, work, lwork, rwork, lrwork, iwork, liwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cheevr_2stage_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_cheevr_2stage_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cheevr_2stage_work(int matrix_layout, char jobz, char range, char uplo, int n, _Complex float *a, int lda, float vl, float vu, int il, int iu, float abstol, int *m, float *w, _Complex float *z, int ldz, int *isuppz, _Complex float *work, int lwork, float *rwork, int lrwork, int *iwork, int liwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_cheevr_2stage_work$descriptor() {
        return LAPACKE_cheevr_2stage_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cheevr_2stage_work(int matrix_layout, char jobz, char range, char uplo, int n, _Complex float *a, int lda, float vl, float vu, int il, int iu, float abstol, int *m, float *w, _Complex float *z, int ldz, int *isuppz, _Complex float *work, int lwork, float *rwork, int lrwork, int *iwork, int liwork)
     * }
     */
    public static MethodHandle LAPACKE_cheevr_2stage_work$handle() {
        return LAPACKE_cheevr_2stage_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cheevr_2stage_work(int matrix_layout, char jobz, char range, char uplo, int n, _Complex float *a, int lda, float vl, float vu, int il, int iu, float abstol, int *m, float *w, _Complex float *z, int ldz, int *isuppz, _Complex float *work, int lwork, float *rwork, int lrwork, int *iwork, int liwork)
     * }
     */
    public static MemorySegment LAPACKE_cheevr_2stage_work$address() {
        return LAPACKE_cheevr_2stage_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cheevr_2stage_work(int matrix_layout, char jobz, char range, char uplo, int n, _Complex float *a, int lda, float vl, float vu, int il, int iu, float abstol, int *m, float *w, _Complex float *z, int ldz, int *isuppz, _Complex float *work, int lwork, float *rwork, int lrwork, int *iwork, int liwork)
     * }
     */
    public static int LAPACKE_cheevr_2stage_work(int matrix_layout, byte jobz, byte range, byte uplo, int n, MemorySegment a, int lda, float vl, float vu, int il, int iu, float abstol, MemorySegment m, MemorySegment w, MemorySegment z, int ldz, MemorySegment isuppz, MemorySegment work, int lwork, MemorySegment rwork, int lrwork, MemorySegment iwork, int liwork) {
        var mh$ = LAPACKE_cheevr_2stage_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cheevr_2stage_work", matrix_layout, jobz, range, uplo, n, a, lda, vl, vu, il, iu, abstol, m, w, z, ldz, isuppz, work, lwork, rwork, lrwork, iwork, liwork);
            }
            return (int)mh$.invokeExact(matrix_layout, jobz, range, uplo, n, a, lda, vl, vu, il, iu, abstol, m, w, z, ldz, isuppz, work, lwork, rwork, lrwork, iwork, liwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zheevr_2stage_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zheevr_2stage_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zheevr_2stage_work(int matrix_layout, char jobz, char range, char uplo, int n, _Complex double *a, int lda, double vl, double vu, int il, int iu, double abstol, int *m, double *w, _Complex double *z, int ldz, int *isuppz, _Complex double *work, int lwork, double *rwork, int lrwork, int *iwork, int liwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_zheevr_2stage_work$descriptor() {
        return LAPACKE_zheevr_2stage_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zheevr_2stage_work(int matrix_layout, char jobz, char range, char uplo, int n, _Complex double *a, int lda, double vl, double vu, int il, int iu, double abstol, int *m, double *w, _Complex double *z, int ldz, int *isuppz, _Complex double *work, int lwork, double *rwork, int lrwork, int *iwork, int liwork)
     * }
     */
    public static MethodHandle LAPACKE_zheevr_2stage_work$handle() {
        return LAPACKE_zheevr_2stage_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zheevr_2stage_work(int matrix_layout, char jobz, char range, char uplo, int n, _Complex double *a, int lda, double vl, double vu, int il, int iu, double abstol, int *m, double *w, _Complex double *z, int ldz, int *isuppz, _Complex double *work, int lwork, double *rwork, int lrwork, int *iwork, int liwork)
     * }
     */
    public static MemorySegment LAPACKE_zheevr_2stage_work$address() {
        return LAPACKE_zheevr_2stage_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zheevr_2stage_work(int matrix_layout, char jobz, char range, char uplo, int n, _Complex double *a, int lda, double vl, double vu, int il, int iu, double abstol, int *m, double *w, _Complex double *z, int ldz, int *isuppz, _Complex double *work, int lwork, double *rwork, int lrwork, int *iwork, int liwork)
     * }
     */
    public static int LAPACKE_zheevr_2stage_work(int matrix_layout, byte jobz, byte range, byte uplo, int n, MemorySegment a, int lda, double vl, double vu, int il, int iu, double abstol, MemorySegment m, MemorySegment w, MemorySegment z, int ldz, MemorySegment isuppz, MemorySegment work, int lwork, MemorySegment rwork, int lrwork, MemorySegment iwork, int liwork) {
        var mh$ = LAPACKE_zheevr_2stage_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zheevr_2stage_work", matrix_layout, jobz, range, uplo, n, a, lda, vl, vu, il, iu, abstol, m, w, z, ldz, isuppz, work, lwork, rwork, lrwork, iwork, liwork);
            }
            return (int)mh$.invokeExact(matrix_layout, jobz, range, uplo, n, a, lda, vl, vu, il, iu, abstol, m, w, z, ldz, isuppz, work, lwork, rwork, lrwork, iwork, liwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cheevx_2stage_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_cheevx_2stage_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cheevx_2stage_work(int matrix_layout, char jobz, char range, char uplo, int n, _Complex float *a, int lda, float vl, float vu, int il, int iu, float abstol, int *m, float *w, _Complex float *z, int ldz, _Complex float *work, int lwork, float *rwork, int *iwork, int *ifail)
     * }
     */
    public static FunctionDescriptor LAPACKE_cheevx_2stage_work$descriptor() {
        return LAPACKE_cheevx_2stage_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cheevx_2stage_work(int matrix_layout, char jobz, char range, char uplo, int n, _Complex float *a, int lda, float vl, float vu, int il, int iu, float abstol, int *m, float *w, _Complex float *z, int ldz, _Complex float *work, int lwork, float *rwork, int *iwork, int *ifail)
     * }
     */
    public static MethodHandle LAPACKE_cheevx_2stage_work$handle() {
        return LAPACKE_cheevx_2stage_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cheevx_2stage_work(int matrix_layout, char jobz, char range, char uplo, int n, _Complex float *a, int lda, float vl, float vu, int il, int iu, float abstol, int *m, float *w, _Complex float *z, int ldz, _Complex float *work, int lwork, float *rwork, int *iwork, int *ifail)
     * }
     */
    public static MemorySegment LAPACKE_cheevx_2stage_work$address() {
        return LAPACKE_cheevx_2stage_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cheevx_2stage_work(int matrix_layout, char jobz, char range, char uplo, int n, _Complex float *a, int lda, float vl, float vu, int il, int iu, float abstol, int *m, float *w, _Complex float *z, int ldz, _Complex float *work, int lwork, float *rwork, int *iwork, int *ifail)
     * }
     */
    public static int LAPACKE_cheevx_2stage_work(int matrix_layout, byte jobz, byte range, byte uplo, int n, MemorySegment a, int lda, float vl, float vu, int il, int iu, float abstol, MemorySegment m, MemorySegment w, MemorySegment z, int ldz, MemorySegment work, int lwork, MemorySegment rwork, MemorySegment iwork, MemorySegment ifail) {
        var mh$ = LAPACKE_cheevx_2stage_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cheevx_2stage_work", matrix_layout, jobz, range, uplo, n, a, lda, vl, vu, il, iu, abstol, m, w, z, ldz, work, lwork, rwork, iwork, ifail);
            }
            return (int)mh$.invokeExact(matrix_layout, jobz, range, uplo, n, a, lda, vl, vu, il, iu, abstol, m, w, z, ldz, work, lwork, rwork, iwork, ifail);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zheevx_2stage_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zheevx_2stage_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zheevx_2stage_work(int matrix_layout, char jobz, char range, char uplo, int n, _Complex double *a, int lda, double vl, double vu, int il, int iu, double abstol, int *m, double *w, _Complex double *z, int ldz, _Complex double *work, int lwork, double *rwork, int *iwork, int *ifail)
     * }
     */
    public static FunctionDescriptor LAPACKE_zheevx_2stage_work$descriptor() {
        return LAPACKE_zheevx_2stage_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zheevx_2stage_work(int matrix_layout, char jobz, char range, char uplo, int n, _Complex double *a, int lda, double vl, double vu, int il, int iu, double abstol, int *m, double *w, _Complex double *z, int ldz, _Complex double *work, int lwork, double *rwork, int *iwork, int *ifail)
     * }
     */
    public static MethodHandle LAPACKE_zheevx_2stage_work$handle() {
        return LAPACKE_zheevx_2stage_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zheevx_2stage_work(int matrix_layout, char jobz, char range, char uplo, int n, _Complex double *a, int lda, double vl, double vu, int il, int iu, double abstol, int *m, double *w, _Complex double *z, int ldz, _Complex double *work, int lwork, double *rwork, int *iwork, int *ifail)
     * }
     */
    public static MemorySegment LAPACKE_zheevx_2stage_work$address() {
        return LAPACKE_zheevx_2stage_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zheevx_2stage_work(int matrix_layout, char jobz, char range, char uplo, int n, _Complex double *a, int lda, double vl, double vu, int il, int iu, double abstol, int *m, double *w, _Complex double *z, int ldz, _Complex double *work, int lwork, double *rwork, int *iwork, int *ifail)
     * }
     */
    public static int LAPACKE_zheevx_2stage_work(int matrix_layout, byte jobz, byte range, byte uplo, int n, MemorySegment a, int lda, double vl, double vu, int il, int iu, double abstol, MemorySegment m, MemorySegment w, MemorySegment z, int ldz, MemorySegment work, int lwork, MemorySegment rwork, MemorySegment iwork, MemorySegment ifail) {
        var mh$ = LAPACKE_zheevx_2stage_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zheevx_2stage_work", matrix_layout, jobz, range, uplo, n, a, lda, vl, vu, il, iu, abstol, m, w, z, ldz, work, lwork, rwork, iwork, ifail);
            }
            return (int)mh$.invokeExact(matrix_layout, jobz, range, uplo, n, a, lda, vl, vu, il, iu, abstol, m, w, z, ldz, work, lwork, rwork, iwork, ifail);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ssbev_2stage {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_ssbev_2stage");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ssbev_2stage(int matrix_layout, char jobz, char uplo, int n, int kd, float *ab, int ldab, float *w, float *z, int ldz)
     * }
     */
    public static FunctionDescriptor LAPACKE_ssbev_2stage$descriptor() {
        return LAPACKE_ssbev_2stage.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ssbev_2stage(int matrix_layout, char jobz, char uplo, int n, int kd, float *ab, int ldab, float *w, float *z, int ldz)
     * }
     */
    public static MethodHandle LAPACKE_ssbev_2stage$handle() {
        return LAPACKE_ssbev_2stage.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ssbev_2stage(int matrix_layout, char jobz, char uplo, int n, int kd, float *ab, int ldab, float *w, float *z, int ldz)
     * }
     */
    public static MemorySegment LAPACKE_ssbev_2stage$address() {
        return LAPACKE_ssbev_2stage.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ssbev_2stage(int matrix_layout, char jobz, char uplo, int n, int kd, float *ab, int ldab, float *w, float *z, int ldz)
     * }
     */
    public static int LAPACKE_ssbev_2stage(int matrix_layout, byte jobz, byte uplo, int n, int kd, MemorySegment ab, int ldab, MemorySegment w, MemorySegment z, int ldz) {
        var mh$ = LAPACKE_ssbev_2stage.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ssbev_2stage", matrix_layout, jobz, uplo, n, kd, ab, ldab, w, z, ldz);
            }
            return (int)mh$.invokeExact(matrix_layout, jobz, uplo, n, kd, ab, ldab, w, z, ldz);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dsbev_2stage {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dsbev_2stage");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dsbev_2stage(int matrix_layout, char jobz, char uplo, int n, int kd, double *ab, int ldab, double *w, double *z, int ldz)
     * }
     */
    public static FunctionDescriptor LAPACKE_dsbev_2stage$descriptor() {
        return LAPACKE_dsbev_2stage.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dsbev_2stage(int matrix_layout, char jobz, char uplo, int n, int kd, double *ab, int ldab, double *w, double *z, int ldz)
     * }
     */
    public static MethodHandle LAPACKE_dsbev_2stage$handle() {
        return LAPACKE_dsbev_2stage.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dsbev_2stage(int matrix_layout, char jobz, char uplo, int n, int kd, double *ab, int ldab, double *w, double *z, int ldz)
     * }
     */
    public static MemorySegment LAPACKE_dsbev_2stage$address() {
        return LAPACKE_dsbev_2stage.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dsbev_2stage(int matrix_layout, char jobz, char uplo, int n, int kd, double *ab, int ldab, double *w, double *z, int ldz)
     * }
     */
    public static int LAPACKE_dsbev_2stage(int matrix_layout, byte jobz, byte uplo, int n, int kd, MemorySegment ab, int ldab, MemorySegment w, MemorySegment z, int ldz) {
        var mh$ = LAPACKE_dsbev_2stage.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dsbev_2stage", matrix_layout, jobz, uplo, n, kd, ab, ldab, w, z, ldz);
            }
            return (int)mh$.invokeExact(matrix_layout, jobz, uplo, n, kd, ab, ldab, w, z, ldz);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ssbevd_2stage {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_ssbevd_2stage");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ssbevd_2stage(int matrix_layout, char jobz, char uplo, int n, int kd, float *ab, int ldab, float *w, float *z, int ldz)
     * }
     */
    public static FunctionDescriptor LAPACKE_ssbevd_2stage$descriptor() {
        return LAPACKE_ssbevd_2stage.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ssbevd_2stage(int matrix_layout, char jobz, char uplo, int n, int kd, float *ab, int ldab, float *w, float *z, int ldz)
     * }
     */
    public static MethodHandle LAPACKE_ssbevd_2stage$handle() {
        return LAPACKE_ssbevd_2stage.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ssbevd_2stage(int matrix_layout, char jobz, char uplo, int n, int kd, float *ab, int ldab, float *w, float *z, int ldz)
     * }
     */
    public static MemorySegment LAPACKE_ssbevd_2stage$address() {
        return LAPACKE_ssbevd_2stage.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ssbevd_2stage(int matrix_layout, char jobz, char uplo, int n, int kd, float *ab, int ldab, float *w, float *z, int ldz)
     * }
     */
    public static int LAPACKE_ssbevd_2stage(int matrix_layout, byte jobz, byte uplo, int n, int kd, MemorySegment ab, int ldab, MemorySegment w, MemorySegment z, int ldz) {
        var mh$ = LAPACKE_ssbevd_2stage.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ssbevd_2stage", matrix_layout, jobz, uplo, n, kd, ab, ldab, w, z, ldz);
            }
            return (int)mh$.invokeExact(matrix_layout, jobz, uplo, n, kd, ab, ldab, w, z, ldz);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dsbevd_2stage {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dsbevd_2stage");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dsbevd_2stage(int matrix_layout, char jobz, char uplo, int n, int kd, double *ab, int ldab, double *w, double *z, int ldz)
     * }
     */
    public static FunctionDescriptor LAPACKE_dsbevd_2stage$descriptor() {
        return LAPACKE_dsbevd_2stage.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dsbevd_2stage(int matrix_layout, char jobz, char uplo, int n, int kd, double *ab, int ldab, double *w, double *z, int ldz)
     * }
     */
    public static MethodHandle LAPACKE_dsbevd_2stage$handle() {
        return LAPACKE_dsbevd_2stage.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dsbevd_2stage(int matrix_layout, char jobz, char uplo, int n, int kd, double *ab, int ldab, double *w, double *z, int ldz)
     * }
     */
    public static MemorySegment LAPACKE_dsbevd_2stage$address() {
        return LAPACKE_dsbevd_2stage.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dsbevd_2stage(int matrix_layout, char jobz, char uplo, int n, int kd, double *ab, int ldab, double *w, double *z, int ldz)
     * }
     */
    public static int LAPACKE_dsbevd_2stage(int matrix_layout, byte jobz, byte uplo, int n, int kd, MemorySegment ab, int ldab, MemorySegment w, MemorySegment z, int ldz) {
        var mh$ = LAPACKE_dsbevd_2stage.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dsbevd_2stage", matrix_layout, jobz, uplo, n, kd, ab, ldab, w, z, ldz);
            }
            return (int)mh$.invokeExact(matrix_layout, jobz, uplo, n, kd, ab, ldab, w, z, ldz);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ssbevx_2stage {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_ssbevx_2stage");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ssbevx_2stage(int matrix_layout, char jobz, char range, char uplo, int n, int kd, float *ab, int ldab, float *q, int ldq, float vl, float vu, int il, int iu, float abstol, int *m, float *w, float *z, int ldz, int *ifail)
     * }
     */
    public static FunctionDescriptor LAPACKE_ssbevx_2stage$descriptor() {
        return LAPACKE_ssbevx_2stage.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ssbevx_2stage(int matrix_layout, char jobz, char range, char uplo, int n, int kd, float *ab, int ldab, float *q, int ldq, float vl, float vu, int il, int iu, float abstol, int *m, float *w, float *z, int ldz, int *ifail)
     * }
     */
    public static MethodHandle LAPACKE_ssbevx_2stage$handle() {
        return LAPACKE_ssbevx_2stage.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ssbevx_2stage(int matrix_layout, char jobz, char range, char uplo, int n, int kd, float *ab, int ldab, float *q, int ldq, float vl, float vu, int il, int iu, float abstol, int *m, float *w, float *z, int ldz, int *ifail)
     * }
     */
    public static MemorySegment LAPACKE_ssbevx_2stage$address() {
        return LAPACKE_ssbevx_2stage.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ssbevx_2stage(int matrix_layout, char jobz, char range, char uplo, int n, int kd, float *ab, int ldab, float *q, int ldq, float vl, float vu, int il, int iu, float abstol, int *m, float *w, float *z, int ldz, int *ifail)
     * }
     */
    public static int LAPACKE_ssbevx_2stage(int matrix_layout, byte jobz, byte range, byte uplo, int n, int kd, MemorySegment ab, int ldab, MemorySegment q, int ldq, float vl, float vu, int il, int iu, float abstol, MemorySegment m, MemorySegment w, MemorySegment z, int ldz, MemorySegment ifail) {
        var mh$ = LAPACKE_ssbevx_2stage.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ssbevx_2stage", matrix_layout, jobz, range, uplo, n, kd, ab, ldab, q, ldq, vl, vu, il, iu, abstol, m, w, z, ldz, ifail);
            }
            return (int)mh$.invokeExact(matrix_layout, jobz, range, uplo, n, kd, ab, ldab, q, ldq, vl, vu, il, iu, abstol, m, w, z, ldz, ifail);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dsbevx_2stage {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dsbevx_2stage");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dsbevx_2stage(int matrix_layout, char jobz, char range, char uplo, int n, int kd, double *ab, int ldab, double *q, int ldq, double vl, double vu, int il, int iu, double abstol, int *m, double *w, double *z, int ldz, int *ifail)
     * }
     */
    public static FunctionDescriptor LAPACKE_dsbevx_2stage$descriptor() {
        return LAPACKE_dsbevx_2stage.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dsbevx_2stage(int matrix_layout, char jobz, char range, char uplo, int n, int kd, double *ab, int ldab, double *q, int ldq, double vl, double vu, int il, int iu, double abstol, int *m, double *w, double *z, int ldz, int *ifail)
     * }
     */
    public static MethodHandle LAPACKE_dsbevx_2stage$handle() {
        return LAPACKE_dsbevx_2stage.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dsbevx_2stage(int matrix_layout, char jobz, char range, char uplo, int n, int kd, double *ab, int ldab, double *q, int ldq, double vl, double vu, int il, int iu, double abstol, int *m, double *w, double *z, int ldz, int *ifail)
     * }
     */
    public static MemorySegment LAPACKE_dsbevx_2stage$address() {
        return LAPACKE_dsbevx_2stage.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dsbevx_2stage(int matrix_layout, char jobz, char range, char uplo, int n, int kd, double *ab, int ldab, double *q, int ldq, double vl, double vu, int il, int iu, double abstol, int *m, double *w, double *z, int ldz, int *ifail)
     * }
     */
    public static int LAPACKE_dsbevx_2stage(int matrix_layout, byte jobz, byte range, byte uplo, int n, int kd, MemorySegment ab, int ldab, MemorySegment q, int ldq, double vl, double vu, int il, int iu, double abstol, MemorySegment m, MemorySegment w, MemorySegment z, int ldz, MemorySegment ifail) {
        var mh$ = LAPACKE_dsbevx_2stage.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dsbevx_2stage", matrix_layout, jobz, range, uplo, n, kd, ab, ldab, q, ldq, vl, vu, il, iu, abstol, m, w, z, ldz, ifail);
            }
            return (int)mh$.invokeExact(matrix_layout, jobz, range, uplo, n, kd, ab, ldab, q, ldq, vl, vu, il, iu, abstol, m, w, z, ldz, ifail);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ssbev_2stage_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_ssbev_2stage_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ssbev_2stage_work(int matrix_layout, char jobz, char uplo, int n, int kd, float *ab, int ldab, float *w, float *z, int ldz, float *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_ssbev_2stage_work$descriptor() {
        return LAPACKE_ssbev_2stage_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ssbev_2stage_work(int matrix_layout, char jobz, char uplo, int n, int kd, float *ab, int ldab, float *w, float *z, int ldz, float *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_ssbev_2stage_work$handle() {
        return LAPACKE_ssbev_2stage_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ssbev_2stage_work(int matrix_layout, char jobz, char uplo, int n, int kd, float *ab, int ldab, float *w, float *z, int ldz, float *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_ssbev_2stage_work$address() {
        return LAPACKE_ssbev_2stage_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ssbev_2stage_work(int matrix_layout, char jobz, char uplo, int n, int kd, float *ab, int ldab, float *w, float *z, int ldz, float *work, int lwork)
     * }
     */
    public static int LAPACKE_ssbev_2stage_work(int matrix_layout, byte jobz, byte uplo, int n, int kd, MemorySegment ab, int ldab, MemorySegment w, MemorySegment z, int ldz, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_ssbev_2stage_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ssbev_2stage_work", matrix_layout, jobz, uplo, n, kd, ab, ldab, w, z, ldz, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, jobz, uplo, n, kd, ab, ldab, w, z, ldz, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dsbev_2stage_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dsbev_2stage_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dsbev_2stage_work(int matrix_layout, char jobz, char uplo, int n, int kd, double *ab, int ldab, double *w, double *z, int ldz, double *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_dsbev_2stage_work$descriptor() {
        return LAPACKE_dsbev_2stage_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dsbev_2stage_work(int matrix_layout, char jobz, char uplo, int n, int kd, double *ab, int ldab, double *w, double *z, int ldz, double *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_dsbev_2stage_work$handle() {
        return LAPACKE_dsbev_2stage_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dsbev_2stage_work(int matrix_layout, char jobz, char uplo, int n, int kd, double *ab, int ldab, double *w, double *z, int ldz, double *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_dsbev_2stage_work$address() {
        return LAPACKE_dsbev_2stage_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dsbev_2stage_work(int matrix_layout, char jobz, char uplo, int n, int kd, double *ab, int ldab, double *w, double *z, int ldz, double *work, int lwork)
     * }
     */
    public static int LAPACKE_dsbev_2stage_work(int matrix_layout, byte jobz, byte uplo, int n, int kd, MemorySegment ab, int ldab, MemorySegment w, MemorySegment z, int ldz, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_dsbev_2stage_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dsbev_2stage_work", matrix_layout, jobz, uplo, n, kd, ab, ldab, w, z, ldz, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, jobz, uplo, n, kd, ab, ldab, w, z, ldz, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ssbevd_2stage_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_ssbevd_2stage_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ssbevd_2stage_work(int matrix_layout, char jobz, char uplo, int n, int kd, float *ab, int ldab, float *w, float *z, int ldz, float *work, int lwork, int *iwork, int liwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_ssbevd_2stage_work$descriptor() {
        return LAPACKE_ssbevd_2stage_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ssbevd_2stage_work(int matrix_layout, char jobz, char uplo, int n, int kd, float *ab, int ldab, float *w, float *z, int ldz, float *work, int lwork, int *iwork, int liwork)
     * }
     */
    public static MethodHandle LAPACKE_ssbevd_2stage_work$handle() {
        return LAPACKE_ssbevd_2stage_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ssbevd_2stage_work(int matrix_layout, char jobz, char uplo, int n, int kd, float *ab, int ldab, float *w, float *z, int ldz, float *work, int lwork, int *iwork, int liwork)
     * }
     */
    public static MemorySegment LAPACKE_ssbevd_2stage_work$address() {
        return LAPACKE_ssbevd_2stage_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ssbevd_2stage_work(int matrix_layout, char jobz, char uplo, int n, int kd, float *ab, int ldab, float *w, float *z, int ldz, float *work, int lwork, int *iwork, int liwork)
     * }
     */
    public static int LAPACKE_ssbevd_2stage_work(int matrix_layout, byte jobz, byte uplo, int n, int kd, MemorySegment ab, int ldab, MemorySegment w, MemorySegment z, int ldz, MemorySegment work, int lwork, MemorySegment iwork, int liwork) {
        var mh$ = LAPACKE_ssbevd_2stage_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ssbevd_2stage_work", matrix_layout, jobz, uplo, n, kd, ab, ldab, w, z, ldz, work, lwork, iwork, liwork);
            }
            return (int)mh$.invokeExact(matrix_layout, jobz, uplo, n, kd, ab, ldab, w, z, ldz, work, lwork, iwork, liwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dsbevd_2stage_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dsbevd_2stage_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dsbevd_2stage_work(int matrix_layout, char jobz, char uplo, int n, int kd, double *ab, int ldab, double *w, double *z, int ldz, double *work, int lwork, int *iwork, int liwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_dsbevd_2stage_work$descriptor() {
        return LAPACKE_dsbevd_2stage_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dsbevd_2stage_work(int matrix_layout, char jobz, char uplo, int n, int kd, double *ab, int ldab, double *w, double *z, int ldz, double *work, int lwork, int *iwork, int liwork)
     * }
     */
    public static MethodHandle LAPACKE_dsbevd_2stage_work$handle() {
        return LAPACKE_dsbevd_2stage_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dsbevd_2stage_work(int matrix_layout, char jobz, char uplo, int n, int kd, double *ab, int ldab, double *w, double *z, int ldz, double *work, int lwork, int *iwork, int liwork)
     * }
     */
    public static MemorySegment LAPACKE_dsbevd_2stage_work$address() {
        return LAPACKE_dsbevd_2stage_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dsbevd_2stage_work(int matrix_layout, char jobz, char uplo, int n, int kd, double *ab, int ldab, double *w, double *z, int ldz, double *work, int lwork, int *iwork, int liwork)
     * }
     */
    public static int LAPACKE_dsbevd_2stage_work(int matrix_layout, byte jobz, byte uplo, int n, int kd, MemorySegment ab, int ldab, MemorySegment w, MemorySegment z, int ldz, MemorySegment work, int lwork, MemorySegment iwork, int liwork) {
        var mh$ = LAPACKE_dsbevd_2stage_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dsbevd_2stage_work", matrix_layout, jobz, uplo, n, kd, ab, ldab, w, z, ldz, work, lwork, iwork, liwork);
            }
            return (int)mh$.invokeExact(matrix_layout, jobz, uplo, n, kd, ab, ldab, w, z, ldz, work, lwork, iwork, liwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ssbevx_2stage_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_ssbevx_2stage_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ssbevx_2stage_work(int matrix_layout, char jobz, char range, char uplo, int n, int kd, float *ab, int ldab, float *q, int ldq, float vl, float vu, int il, int iu, float abstol, int *m, float *w, float *z, int ldz, float *work, int lwork, int *iwork, int *ifail)
     * }
     */
    public static FunctionDescriptor LAPACKE_ssbevx_2stage_work$descriptor() {
        return LAPACKE_ssbevx_2stage_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ssbevx_2stage_work(int matrix_layout, char jobz, char range, char uplo, int n, int kd, float *ab, int ldab, float *q, int ldq, float vl, float vu, int il, int iu, float abstol, int *m, float *w, float *z, int ldz, float *work, int lwork, int *iwork, int *ifail)
     * }
     */
    public static MethodHandle LAPACKE_ssbevx_2stage_work$handle() {
        return LAPACKE_ssbevx_2stage_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ssbevx_2stage_work(int matrix_layout, char jobz, char range, char uplo, int n, int kd, float *ab, int ldab, float *q, int ldq, float vl, float vu, int il, int iu, float abstol, int *m, float *w, float *z, int ldz, float *work, int lwork, int *iwork, int *ifail)
     * }
     */
    public static MemorySegment LAPACKE_ssbevx_2stage_work$address() {
        return LAPACKE_ssbevx_2stage_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ssbevx_2stage_work(int matrix_layout, char jobz, char range, char uplo, int n, int kd, float *ab, int ldab, float *q, int ldq, float vl, float vu, int il, int iu, float abstol, int *m, float *w, float *z, int ldz, float *work, int lwork, int *iwork, int *ifail)
     * }
     */
    public static int LAPACKE_ssbevx_2stage_work(int matrix_layout, byte jobz, byte range, byte uplo, int n, int kd, MemorySegment ab, int ldab, MemorySegment q, int ldq, float vl, float vu, int il, int iu, float abstol, MemorySegment m, MemorySegment w, MemorySegment z, int ldz, MemorySegment work, int lwork, MemorySegment iwork, MemorySegment ifail) {
        var mh$ = LAPACKE_ssbevx_2stage_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ssbevx_2stage_work", matrix_layout, jobz, range, uplo, n, kd, ab, ldab, q, ldq, vl, vu, il, iu, abstol, m, w, z, ldz, work, lwork, iwork, ifail);
            }
            return (int)mh$.invokeExact(matrix_layout, jobz, range, uplo, n, kd, ab, ldab, q, ldq, vl, vu, il, iu, abstol, m, w, z, ldz, work, lwork, iwork, ifail);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dsbevx_2stage_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dsbevx_2stage_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dsbevx_2stage_work(int matrix_layout, char jobz, char range, char uplo, int n, int kd, double *ab, int ldab, double *q, int ldq, double vl, double vu, int il, int iu, double abstol, int *m, double *w, double *z, int ldz, double *work, int lwork, int *iwork, int *ifail)
     * }
     */
    public static FunctionDescriptor LAPACKE_dsbevx_2stage_work$descriptor() {
        return LAPACKE_dsbevx_2stage_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dsbevx_2stage_work(int matrix_layout, char jobz, char range, char uplo, int n, int kd, double *ab, int ldab, double *q, int ldq, double vl, double vu, int il, int iu, double abstol, int *m, double *w, double *z, int ldz, double *work, int lwork, int *iwork, int *ifail)
     * }
     */
    public static MethodHandle LAPACKE_dsbevx_2stage_work$handle() {
        return LAPACKE_dsbevx_2stage_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dsbevx_2stage_work(int matrix_layout, char jobz, char range, char uplo, int n, int kd, double *ab, int ldab, double *q, int ldq, double vl, double vu, int il, int iu, double abstol, int *m, double *w, double *z, int ldz, double *work, int lwork, int *iwork, int *ifail)
     * }
     */
    public static MemorySegment LAPACKE_dsbevx_2stage_work$address() {
        return LAPACKE_dsbevx_2stage_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dsbevx_2stage_work(int matrix_layout, char jobz, char range, char uplo, int n, int kd, double *ab, int ldab, double *q, int ldq, double vl, double vu, int il, int iu, double abstol, int *m, double *w, double *z, int ldz, double *work, int lwork, int *iwork, int *ifail)
     * }
     */
    public static int LAPACKE_dsbevx_2stage_work(int matrix_layout, byte jobz, byte range, byte uplo, int n, int kd, MemorySegment ab, int ldab, MemorySegment q, int ldq, double vl, double vu, int il, int iu, double abstol, MemorySegment m, MemorySegment w, MemorySegment z, int ldz, MemorySegment work, int lwork, MemorySegment iwork, MemorySegment ifail) {
        var mh$ = LAPACKE_dsbevx_2stage_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dsbevx_2stage_work", matrix_layout, jobz, range, uplo, n, kd, ab, ldab, q, ldq, vl, vu, il, iu, abstol, m, w, z, ldz, work, lwork, iwork, ifail);
            }
            return (int)mh$.invokeExact(matrix_layout, jobz, range, uplo, n, kd, ab, ldab, q, ldq, vl, vu, il, iu, abstol, m, w, z, ldz, work, lwork, iwork, ifail);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_chbev_2stage {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_chbev_2stage");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_chbev_2stage(int matrix_layout, char jobz, char uplo, int n, int kd, _Complex float *ab, int ldab, float *w, _Complex float *z, int ldz)
     * }
     */
    public static FunctionDescriptor LAPACKE_chbev_2stage$descriptor() {
        return LAPACKE_chbev_2stage.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_chbev_2stage(int matrix_layout, char jobz, char uplo, int n, int kd, _Complex float *ab, int ldab, float *w, _Complex float *z, int ldz)
     * }
     */
    public static MethodHandle LAPACKE_chbev_2stage$handle() {
        return LAPACKE_chbev_2stage.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_chbev_2stage(int matrix_layout, char jobz, char uplo, int n, int kd, _Complex float *ab, int ldab, float *w, _Complex float *z, int ldz)
     * }
     */
    public static MemorySegment LAPACKE_chbev_2stage$address() {
        return LAPACKE_chbev_2stage.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_chbev_2stage(int matrix_layout, char jobz, char uplo, int n, int kd, _Complex float *ab, int ldab, float *w, _Complex float *z, int ldz)
     * }
     */
    public static int LAPACKE_chbev_2stage(int matrix_layout, byte jobz, byte uplo, int n, int kd, MemorySegment ab, int ldab, MemorySegment w, MemorySegment z, int ldz) {
        var mh$ = LAPACKE_chbev_2stage.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_chbev_2stage", matrix_layout, jobz, uplo, n, kd, ab, ldab, w, z, ldz);
            }
            return (int)mh$.invokeExact(matrix_layout, jobz, uplo, n, kd, ab, ldab, w, z, ldz);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zhbev_2stage {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zhbev_2stage");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zhbev_2stage(int matrix_layout, char jobz, char uplo, int n, int kd, _Complex double *ab, int ldab, double *w, _Complex double *z, int ldz)
     * }
     */
    public static FunctionDescriptor LAPACKE_zhbev_2stage$descriptor() {
        return LAPACKE_zhbev_2stage.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zhbev_2stage(int matrix_layout, char jobz, char uplo, int n, int kd, _Complex double *ab, int ldab, double *w, _Complex double *z, int ldz)
     * }
     */
    public static MethodHandle LAPACKE_zhbev_2stage$handle() {
        return LAPACKE_zhbev_2stage.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zhbev_2stage(int matrix_layout, char jobz, char uplo, int n, int kd, _Complex double *ab, int ldab, double *w, _Complex double *z, int ldz)
     * }
     */
    public static MemorySegment LAPACKE_zhbev_2stage$address() {
        return LAPACKE_zhbev_2stage.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zhbev_2stage(int matrix_layout, char jobz, char uplo, int n, int kd, _Complex double *ab, int ldab, double *w, _Complex double *z, int ldz)
     * }
     */
    public static int LAPACKE_zhbev_2stage(int matrix_layout, byte jobz, byte uplo, int n, int kd, MemorySegment ab, int ldab, MemorySegment w, MemorySegment z, int ldz) {
        var mh$ = LAPACKE_zhbev_2stage.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zhbev_2stage", matrix_layout, jobz, uplo, n, kd, ab, ldab, w, z, ldz);
            }
            return (int)mh$.invokeExact(matrix_layout, jobz, uplo, n, kd, ab, ldab, w, z, ldz);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_chbevd_2stage {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_chbevd_2stage");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_chbevd_2stage(int matrix_layout, char jobz, char uplo, int n, int kd, _Complex float *ab, int ldab, float *w, _Complex float *z, int ldz)
     * }
     */
    public static FunctionDescriptor LAPACKE_chbevd_2stage$descriptor() {
        return LAPACKE_chbevd_2stage.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_chbevd_2stage(int matrix_layout, char jobz, char uplo, int n, int kd, _Complex float *ab, int ldab, float *w, _Complex float *z, int ldz)
     * }
     */
    public static MethodHandle LAPACKE_chbevd_2stage$handle() {
        return LAPACKE_chbevd_2stage.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_chbevd_2stage(int matrix_layout, char jobz, char uplo, int n, int kd, _Complex float *ab, int ldab, float *w, _Complex float *z, int ldz)
     * }
     */
    public static MemorySegment LAPACKE_chbevd_2stage$address() {
        return LAPACKE_chbevd_2stage.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_chbevd_2stage(int matrix_layout, char jobz, char uplo, int n, int kd, _Complex float *ab, int ldab, float *w, _Complex float *z, int ldz)
     * }
     */
    public static int LAPACKE_chbevd_2stage(int matrix_layout, byte jobz, byte uplo, int n, int kd, MemorySegment ab, int ldab, MemorySegment w, MemorySegment z, int ldz) {
        var mh$ = LAPACKE_chbevd_2stage.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_chbevd_2stage", matrix_layout, jobz, uplo, n, kd, ab, ldab, w, z, ldz);
            }
            return (int)mh$.invokeExact(matrix_layout, jobz, uplo, n, kd, ab, ldab, w, z, ldz);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zhbevd_2stage {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zhbevd_2stage");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zhbevd_2stage(int matrix_layout, char jobz, char uplo, int n, int kd, _Complex double *ab, int ldab, double *w, _Complex double *z, int ldz)
     * }
     */
    public static FunctionDescriptor LAPACKE_zhbevd_2stage$descriptor() {
        return LAPACKE_zhbevd_2stage.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zhbevd_2stage(int matrix_layout, char jobz, char uplo, int n, int kd, _Complex double *ab, int ldab, double *w, _Complex double *z, int ldz)
     * }
     */
    public static MethodHandle LAPACKE_zhbevd_2stage$handle() {
        return LAPACKE_zhbevd_2stage.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zhbevd_2stage(int matrix_layout, char jobz, char uplo, int n, int kd, _Complex double *ab, int ldab, double *w, _Complex double *z, int ldz)
     * }
     */
    public static MemorySegment LAPACKE_zhbevd_2stage$address() {
        return LAPACKE_zhbevd_2stage.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zhbevd_2stage(int matrix_layout, char jobz, char uplo, int n, int kd, _Complex double *ab, int ldab, double *w, _Complex double *z, int ldz)
     * }
     */
    public static int LAPACKE_zhbevd_2stage(int matrix_layout, byte jobz, byte uplo, int n, int kd, MemorySegment ab, int ldab, MemorySegment w, MemorySegment z, int ldz) {
        var mh$ = LAPACKE_zhbevd_2stage.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zhbevd_2stage", matrix_layout, jobz, uplo, n, kd, ab, ldab, w, z, ldz);
            }
            return (int)mh$.invokeExact(matrix_layout, jobz, uplo, n, kd, ab, ldab, w, z, ldz);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_chbevx_2stage {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_chbevx_2stage");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_chbevx_2stage(int matrix_layout, char jobz, char range, char uplo, int n, int kd, _Complex float *ab, int ldab, _Complex float *q, int ldq, float vl, float vu, int il, int iu, float abstol, int *m, float *w, _Complex float *z, int ldz, int *ifail)
     * }
     */
    public static FunctionDescriptor LAPACKE_chbevx_2stage$descriptor() {
        return LAPACKE_chbevx_2stage.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_chbevx_2stage(int matrix_layout, char jobz, char range, char uplo, int n, int kd, _Complex float *ab, int ldab, _Complex float *q, int ldq, float vl, float vu, int il, int iu, float abstol, int *m, float *w, _Complex float *z, int ldz, int *ifail)
     * }
     */
    public static MethodHandle LAPACKE_chbevx_2stage$handle() {
        return LAPACKE_chbevx_2stage.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_chbevx_2stage(int matrix_layout, char jobz, char range, char uplo, int n, int kd, _Complex float *ab, int ldab, _Complex float *q, int ldq, float vl, float vu, int il, int iu, float abstol, int *m, float *w, _Complex float *z, int ldz, int *ifail)
     * }
     */
    public static MemorySegment LAPACKE_chbevx_2stage$address() {
        return LAPACKE_chbevx_2stage.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_chbevx_2stage(int matrix_layout, char jobz, char range, char uplo, int n, int kd, _Complex float *ab, int ldab, _Complex float *q, int ldq, float vl, float vu, int il, int iu, float abstol, int *m, float *w, _Complex float *z, int ldz, int *ifail)
     * }
     */
    public static int LAPACKE_chbevx_2stage(int matrix_layout, byte jobz, byte range, byte uplo, int n, int kd, MemorySegment ab, int ldab, MemorySegment q, int ldq, float vl, float vu, int il, int iu, float abstol, MemorySegment m, MemorySegment w, MemorySegment z, int ldz, MemorySegment ifail) {
        var mh$ = LAPACKE_chbevx_2stage.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_chbevx_2stage", matrix_layout, jobz, range, uplo, n, kd, ab, ldab, q, ldq, vl, vu, il, iu, abstol, m, w, z, ldz, ifail);
            }
            return (int)mh$.invokeExact(matrix_layout, jobz, range, uplo, n, kd, ab, ldab, q, ldq, vl, vu, il, iu, abstol, m, w, z, ldz, ifail);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zhbevx_2stage {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zhbevx_2stage");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zhbevx_2stage(int matrix_layout, char jobz, char range, char uplo, int n, int kd, _Complex double *ab, int ldab, _Complex double *q, int ldq, double vl, double vu, int il, int iu, double abstol, int *m, double *w, _Complex double *z, int ldz, int *ifail)
     * }
     */
    public static FunctionDescriptor LAPACKE_zhbevx_2stage$descriptor() {
        return LAPACKE_zhbevx_2stage.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zhbevx_2stage(int matrix_layout, char jobz, char range, char uplo, int n, int kd, _Complex double *ab, int ldab, _Complex double *q, int ldq, double vl, double vu, int il, int iu, double abstol, int *m, double *w, _Complex double *z, int ldz, int *ifail)
     * }
     */
    public static MethodHandle LAPACKE_zhbevx_2stage$handle() {
        return LAPACKE_zhbevx_2stage.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zhbevx_2stage(int matrix_layout, char jobz, char range, char uplo, int n, int kd, _Complex double *ab, int ldab, _Complex double *q, int ldq, double vl, double vu, int il, int iu, double abstol, int *m, double *w, _Complex double *z, int ldz, int *ifail)
     * }
     */
    public static MemorySegment LAPACKE_zhbevx_2stage$address() {
        return LAPACKE_zhbevx_2stage.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zhbevx_2stage(int matrix_layout, char jobz, char range, char uplo, int n, int kd, _Complex double *ab, int ldab, _Complex double *q, int ldq, double vl, double vu, int il, int iu, double abstol, int *m, double *w, _Complex double *z, int ldz, int *ifail)
     * }
     */
    public static int LAPACKE_zhbevx_2stage(int matrix_layout, byte jobz, byte range, byte uplo, int n, int kd, MemorySegment ab, int ldab, MemorySegment q, int ldq, double vl, double vu, int il, int iu, double abstol, MemorySegment m, MemorySegment w, MemorySegment z, int ldz, MemorySegment ifail) {
        var mh$ = LAPACKE_zhbevx_2stage.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zhbevx_2stage", matrix_layout, jobz, range, uplo, n, kd, ab, ldab, q, ldq, vl, vu, il, iu, abstol, m, w, z, ldz, ifail);
            }
            return (int)mh$.invokeExact(matrix_layout, jobz, range, uplo, n, kd, ab, ldab, q, ldq, vl, vu, il, iu, abstol, m, w, z, ldz, ifail);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_chbev_2stage_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_chbev_2stage_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_chbev_2stage_work(int matrix_layout, char jobz, char uplo, int n, int kd, _Complex float *ab, int ldab, float *w, _Complex float *z, int ldz, _Complex float *work, int lwork, float *rwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_chbev_2stage_work$descriptor() {
        return LAPACKE_chbev_2stage_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_chbev_2stage_work(int matrix_layout, char jobz, char uplo, int n, int kd, _Complex float *ab, int ldab, float *w, _Complex float *z, int ldz, _Complex float *work, int lwork, float *rwork)
     * }
     */
    public static MethodHandle LAPACKE_chbev_2stage_work$handle() {
        return LAPACKE_chbev_2stage_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_chbev_2stage_work(int matrix_layout, char jobz, char uplo, int n, int kd, _Complex float *ab, int ldab, float *w, _Complex float *z, int ldz, _Complex float *work, int lwork, float *rwork)
     * }
     */
    public static MemorySegment LAPACKE_chbev_2stage_work$address() {
        return LAPACKE_chbev_2stage_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_chbev_2stage_work(int matrix_layout, char jobz, char uplo, int n, int kd, _Complex float *ab, int ldab, float *w, _Complex float *z, int ldz, _Complex float *work, int lwork, float *rwork)
     * }
     */
    public static int LAPACKE_chbev_2stage_work(int matrix_layout, byte jobz, byte uplo, int n, int kd, MemorySegment ab, int ldab, MemorySegment w, MemorySegment z, int ldz, MemorySegment work, int lwork, MemorySegment rwork) {
        var mh$ = LAPACKE_chbev_2stage_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_chbev_2stage_work", matrix_layout, jobz, uplo, n, kd, ab, ldab, w, z, ldz, work, lwork, rwork);
            }
            return (int)mh$.invokeExact(matrix_layout, jobz, uplo, n, kd, ab, ldab, w, z, ldz, work, lwork, rwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zhbev_2stage_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zhbev_2stage_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zhbev_2stage_work(int matrix_layout, char jobz, char uplo, int n, int kd, _Complex double *ab, int ldab, double *w, _Complex double *z, int ldz, _Complex double *work, int lwork, double *rwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_zhbev_2stage_work$descriptor() {
        return LAPACKE_zhbev_2stage_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zhbev_2stage_work(int matrix_layout, char jobz, char uplo, int n, int kd, _Complex double *ab, int ldab, double *w, _Complex double *z, int ldz, _Complex double *work, int lwork, double *rwork)
     * }
     */
    public static MethodHandle LAPACKE_zhbev_2stage_work$handle() {
        return LAPACKE_zhbev_2stage_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zhbev_2stage_work(int matrix_layout, char jobz, char uplo, int n, int kd, _Complex double *ab, int ldab, double *w, _Complex double *z, int ldz, _Complex double *work, int lwork, double *rwork)
     * }
     */
    public static MemorySegment LAPACKE_zhbev_2stage_work$address() {
        return LAPACKE_zhbev_2stage_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zhbev_2stage_work(int matrix_layout, char jobz, char uplo, int n, int kd, _Complex double *ab, int ldab, double *w, _Complex double *z, int ldz, _Complex double *work, int lwork, double *rwork)
     * }
     */
    public static int LAPACKE_zhbev_2stage_work(int matrix_layout, byte jobz, byte uplo, int n, int kd, MemorySegment ab, int ldab, MemorySegment w, MemorySegment z, int ldz, MemorySegment work, int lwork, MemorySegment rwork) {
        var mh$ = LAPACKE_zhbev_2stage_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zhbev_2stage_work", matrix_layout, jobz, uplo, n, kd, ab, ldab, w, z, ldz, work, lwork, rwork);
            }
            return (int)mh$.invokeExact(matrix_layout, jobz, uplo, n, kd, ab, ldab, w, z, ldz, work, lwork, rwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_chbevd_2stage_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_chbevd_2stage_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_chbevd_2stage_work(int matrix_layout, char jobz, char uplo, int n, int kd, _Complex float *ab, int ldab, float *w, _Complex float *z, int ldz, _Complex float *work, int lwork, float *rwork, int lrwork, int *iwork, int liwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_chbevd_2stage_work$descriptor() {
        return LAPACKE_chbevd_2stage_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_chbevd_2stage_work(int matrix_layout, char jobz, char uplo, int n, int kd, _Complex float *ab, int ldab, float *w, _Complex float *z, int ldz, _Complex float *work, int lwork, float *rwork, int lrwork, int *iwork, int liwork)
     * }
     */
    public static MethodHandle LAPACKE_chbevd_2stage_work$handle() {
        return LAPACKE_chbevd_2stage_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_chbevd_2stage_work(int matrix_layout, char jobz, char uplo, int n, int kd, _Complex float *ab, int ldab, float *w, _Complex float *z, int ldz, _Complex float *work, int lwork, float *rwork, int lrwork, int *iwork, int liwork)
     * }
     */
    public static MemorySegment LAPACKE_chbevd_2stage_work$address() {
        return LAPACKE_chbevd_2stage_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_chbevd_2stage_work(int matrix_layout, char jobz, char uplo, int n, int kd, _Complex float *ab, int ldab, float *w, _Complex float *z, int ldz, _Complex float *work, int lwork, float *rwork, int lrwork, int *iwork, int liwork)
     * }
     */
    public static int LAPACKE_chbevd_2stage_work(int matrix_layout, byte jobz, byte uplo, int n, int kd, MemorySegment ab, int ldab, MemorySegment w, MemorySegment z, int ldz, MemorySegment work, int lwork, MemorySegment rwork, int lrwork, MemorySegment iwork, int liwork) {
        var mh$ = LAPACKE_chbevd_2stage_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_chbevd_2stage_work", matrix_layout, jobz, uplo, n, kd, ab, ldab, w, z, ldz, work, lwork, rwork, lrwork, iwork, liwork);
            }
            return (int)mh$.invokeExact(matrix_layout, jobz, uplo, n, kd, ab, ldab, w, z, ldz, work, lwork, rwork, lrwork, iwork, liwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zhbevd_2stage_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zhbevd_2stage_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zhbevd_2stage_work(int matrix_layout, char jobz, char uplo, int n, int kd, _Complex double *ab, int ldab, double *w, _Complex double *z, int ldz, _Complex double *work, int lwork, double *rwork, int lrwork, int *iwork, int liwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_zhbevd_2stage_work$descriptor() {
        return LAPACKE_zhbevd_2stage_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zhbevd_2stage_work(int matrix_layout, char jobz, char uplo, int n, int kd, _Complex double *ab, int ldab, double *w, _Complex double *z, int ldz, _Complex double *work, int lwork, double *rwork, int lrwork, int *iwork, int liwork)
     * }
     */
    public static MethodHandle LAPACKE_zhbevd_2stage_work$handle() {
        return LAPACKE_zhbevd_2stage_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zhbevd_2stage_work(int matrix_layout, char jobz, char uplo, int n, int kd, _Complex double *ab, int ldab, double *w, _Complex double *z, int ldz, _Complex double *work, int lwork, double *rwork, int lrwork, int *iwork, int liwork)
     * }
     */
    public static MemorySegment LAPACKE_zhbevd_2stage_work$address() {
        return LAPACKE_zhbevd_2stage_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zhbevd_2stage_work(int matrix_layout, char jobz, char uplo, int n, int kd, _Complex double *ab, int ldab, double *w, _Complex double *z, int ldz, _Complex double *work, int lwork, double *rwork, int lrwork, int *iwork, int liwork)
     * }
     */
    public static int LAPACKE_zhbevd_2stage_work(int matrix_layout, byte jobz, byte uplo, int n, int kd, MemorySegment ab, int ldab, MemorySegment w, MemorySegment z, int ldz, MemorySegment work, int lwork, MemorySegment rwork, int lrwork, MemorySegment iwork, int liwork) {
        var mh$ = LAPACKE_zhbevd_2stage_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zhbevd_2stage_work", matrix_layout, jobz, uplo, n, kd, ab, ldab, w, z, ldz, work, lwork, rwork, lrwork, iwork, liwork);
            }
            return (int)mh$.invokeExact(matrix_layout, jobz, uplo, n, kd, ab, ldab, w, z, ldz, work, lwork, rwork, lrwork, iwork, liwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_chbevx_2stage_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_FLOAT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_chbevx_2stage_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_chbevx_2stage_work(int matrix_layout, char jobz, char range, char uplo, int n, int kd, _Complex float *ab, int ldab, _Complex float *q, int ldq, float vl, float vu, int il, int iu, float abstol, int *m, float *w, _Complex float *z, int ldz, _Complex float *work, int lwork, float *rwork, int *iwork, int *ifail)
     * }
     */
    public static FunctionDescriptor LAPACKE_chbevx_2stage_work$descriptor() {
        return LAPACKE_chbevx_2stage_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_chbevx_2stage_work(int matrix_layout, char jobz, char range, char uplo, int n, int kd, _Complex float *ab, int ldab, _Complex float *q, int ldq, float vl, float vu, int il, int iu, float abstol, int *m, float *w, _Complex float *z, int ldz, _Complex float *work, int lwork, float *rwork, int *iwork, int *ifail)
     * }
     */
    public static MethodHandle LAPACKE_chbevx_2stage_work$handle() {
        return LAPACKE_chbevx_2stage_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_chbevx_2stage_work(int matrix_layout, char jobz, char range, char uplo, int n, int kd, _Complex float *ab, int ldab, _Complex float *q, int ldq, float vl, float vu, int il, int iu, float abstol, int *m, float *w, _Complex float *z, int ldz, _Complex float *work, int lwork, float *rwork, int *iwork, int *ifail)
     * }
     */
    public static MemorySegment LAPACKE_chbevx_2stage_work$address() {
        return LAPACKE_chbevx_2stage_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_chbevx_2stage_work(int matrix_layout, char jobz, char range, char uplo, int n, int kd, _Complex float *ab, int ldab, _Complex float *q, int ldq, float vl, float vu, int il, int iu, float abstol, int *m, float *w, _Complex float *z, int ldz, _Complex float *work, int lwork, float *rwork, int *iwork, int *ifail)
     * }
     */
    public static int LAPACKE_chbevx_2stage_work(int matrix_layout, byte jobz, byte range, byte uplo, int n, int kd, MemorySegment ab, int ldab, MemorySegment q, int ldq, float vl, float vu, int il, int iu, float abstol, MemorySegment m, MemorySegment w, MemorySegment z, int ldz, MemorySegment work, int lwork, MemorySegment rwork, MemorySegment iwork, MemorySegment ifail) {
        var mh$ = LAPACKE_chbevx_2stage_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_chbevx_2stage_work", matrix_layout, jobz, range, uplo, n, kd, ab, ldab, q, ldq, vl, vu, il, iu, abstol, m, w, z, ldz, work, lwork, rwork, iwork, ifail);
            }
            return (int)mh$.invokeExact(matrix_layout, jobz, range, uplo, n, kd, ab, ldab, q, ldq, vl, vu, il, iu, abstol, m, w, z, ldz, work, lwork, rwork, iwork, ifail);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zhbevx_2stage_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_DOUBLE,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zhbevx_2stage_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zhbevx_2stage_work(int matrix_layout, char jobz, char range, char uplo, int n, int kd, _Complex double *ab, int ldab, _Complex double *q, int ldq, double vl, double vu, int il, int iu, double abstol, int *m, double *w, _Complex double *z, int ldz, _Complex double *work, int lwork, double *rwork, int *iwork, int *ifail)
     * }
     */
    public static FunctionDescriptor LAPACKE_zhbevx_2stage_work$descriptor() {
        return LAPACKE_zhbevx_2stage_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zhbevx_2stage_work(int matrix_layout, char jobz, char range, char uplo, int n, int kd, _Complex double *ab, int ldab, _Complex double *q, int ldq, double vl, double vu, int il, int iu, double abstol, int *m, double *w, _Complex double *z, int ldz, _Complex double *work, int lwork, double *rwork, int *iwork, int *ifail)
     * }
     */
    public static MethodHandle LAPACKE_zhbevx_2stage_work$handle() {
        return LAPACKE_zhbevx_2stage_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zhbevx_2stage_work(int matrix_layout, char jobz, char range, char uplo, int n, int kd, _Complex double *ab, int ldab, _Complex double *q, int ldq, double vl, double vu, int il, int iu, double abstol, int *m, double *w, _Complex double *z, int ldz, _Complex double *work, int lwork, double *rwork, int *iwork, int *ifail)
     * }
     */
    public static MemorySegment LAPACKE_zhbevx_2stage_work$address() {
        return LAPACKE_zhbevx_2stage_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zhbevx_2stage_work(int matrix_layout, char jobz, char range, char uplo, int n, int kd, _Complex double *ab, int ldab, _Complex double *q, int ldq, double vl, double vu, int il, int iu, double abstol, int *m, double *w, _Complex double *z, int ldz, _Complex double *work, int lwork, double *rwork, int *iwork, int *ifail)
     * }
     */
    public static int LAPACKE_zhbevx_2stage_work(int matrix_layout, byte jobz, byte range, byte uplo, int n, int kd, MemorySegment ab, int ldab, MemorySegment q, int ldq, double vl, double vu, int il, int iu, double abstol, MemorySegment m, MemorySegment w, MemorySegment z, int ldz, MemorySegment work, int lwork, MemorySegment rwork, MemorySegment iwork, MemorySegment ifail) {
        var mh$ = LAPACKE_zhbevx_2stage_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zhbevx_2stage_work", matrix_layout, jobz, range, uplo, n, kd, ab, ldab, q, ldq, vl, vu, il, iu, abstol, m, w, z, ldz, work, lwork, rwork, iwork, ifail);
            }
            return (int)mh$.invokeExact(matrix_layout, jobz, range, uplo, n, kd, ab, ldab, q, ldq, vl, vu, il, iu, abstol, m, w, z, ldz, work, lwork, rwork, iwork, ifail);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ssygv_2stage {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_ssygv_2stage");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ssygv_2stage(int matrix_layout, int itype, char jobz, char uplo, int n, float *a, int lda, float *b, int ldb, float *w)
     * }
     */
    public static FunctionDescriptor LAPACKE_ssygv_2stage$descriptor() {
        return LAPACKE_ssygv_2stage.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ssygv_2stage(int matrix_layout, int itype, char jobz, char uplo, int n, float *a, int lda, float *b, int ldb, float *w)
     * }
     */
    public static MethodHandle LAPACKE_ssygv_2stage$handle() {
        return LAPACKE_ssygv_2stage.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ssygv_2stage(int matrix_layout, int itype, char jobz, char uplo, int n, float *a, int lda, float *b, int ldb, float *w)
     * }
     */
    public static MemorySegment LAPACKE_ssygv_2stage$address() {
        return LAPACKE_ssygv_2stage.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ssygv_2stage(int matrix_layout, int itype, char jobz, char uplo, int n, float *a, int lda, float *b, int ldb, float *w)
     * }
     */
    public static int LAPACKE_ssygv_2stage(int matrix_layout, int itype, byte jobz, byte uplo, int n, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment w) {
        var mh$ = LAPACKE_ssygv_2stage.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ssygv_2stage", matrix_layout, itype, jobz, uplo, n, a, lda, b, ldb, w);
            }
            return (int)mh$.invokeExact(matrix_layout, itype, jobz, uplo, n, a, lda, b, ldb, w);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dsygv_2stage {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dsygv_2stage");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dsygv_2stage(int matrix_layout, int itype, char jobz, char uplo, int n, double *a, int lda, double *b, int ldb, double *w)
     * }
     */
    public static FunctionDescriptor LAPACKE_dsygv_2stage$descriptor() {
        return LAPACKE_dsygv_2stage.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dsygv_2stage(int matrix_layout, int itype, char jobz, char uplo, int n, double *a, int lda, double *b, int ldb, double *w)
     * }
     */
    public static MethodHandle LAPACKE_dsygv_2stage$handle() {
        return LAPACKE_dsygv_2stage.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dsygv_2stage(int matrix_layout, int itype, char jobz, char uplo, int n, double *a, int lda, double *b, int ldb, double *w)
     * }
     */
    public static MemorySegment LAPACKE_dsygv_2stage$address() {
        return LAPACKE_dsygv_2stage.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dsygv_2stage(int matrix_layout, int itype, char jobz, char uplo, int n, double *a, int lda, double *b, int ldb, double *w)
     * }
     */
    public static int LAPACKE_dsygv_2stage(int matrix_layout, int itype, byte jobz, byte uplo, int n, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment w) {
        var mh$ = LAPACKE_dsygv_2stage.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dsygv_2stage", matrix_layout, itype, jobz, uplo, n, a, lda, b, ldb, w);
            }
            return (int)mh$.invokeExact(matrix_layout, itype, jobz, uplo, n, a, lda, b, ldb, w);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ssygv_2stage_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_ssygv_2stage_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ssygv_2stage_work(int matrix_layout, int itype, char jobz, char uplo, int n, float *a, int lda, float *b, int ldb, float *w, float *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_ssygv_2stage_work$descriptor() {
        return LAPACKE_ssygv_2stage_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ssygv_2stage_work(int matrix_layout, int itype, char jobz, char uplo, int n, float *a, int lda, float *b, int ldb, float *w, float *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_ssygv_2stage_work$handle() {
        return LAPACKE_ssygv_2stage_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ssygv_2stage_work(int matrix_layout, int itype, char jobz, char uplo, int n, float *a, int lda, float *b, int ldb, float *w, float *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_ssygv_2stage_work$address() {
        return LAPACKE_ssygv_2stage_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ssygv_2stage_work(int matrix_layout, int itype, char jobz, char uplo, int n, float *a, int lda, float *b, int ldb, float *w, float *work, int lwork)
     * }
     */
    public static int LAPACKE_ssygv_2stage_work(int matrix_layout, int itype, byte jobz, byte uplo, int n, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment w, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_ssygv_2stage_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ssygv_2stage_work", matrix_layout, itype, jobz, uplo, n, a, lda, b, ldb, w, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, itype, jobz, uplo, n, a, lda, b, ldb, w, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dsygv_2stage_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dsygv_2stage_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dsygv_2stage_work(int matrix_layout, int itype, char jobz, char uplo, int n, double *a, int lda, double *b, int ldb, double *w, double *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_dsygv_2stage_work$descriptor() {
        return LAPACKE_dsygv_2stage_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dsygv_2stage_work(int matrix_layout, int itype, char jobz, char uplo, int n, double *a, int lda, double *b, int ldb, double *w, double *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_dsygv_2stage_work$handle() {
        return LAPACKE_dsygv_2stage_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dsygv_2stage_work(int matrix_layout, int itype, char jobz, char uplo, int n, double *a, int lda, double *b, int ldb, double *w, double *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_dsygv_2stage_work$address() {
        return LAPACKE_dsygv_2stage_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dsygv_2stage_work(int matrix_layout, int itype, char jobz, char uplo, int n, double *a, int lda, double *b, int ldb, double *w, double *work, int lwork)
     * }
     */
    public static int LAPACKE_dsygv_2stage_work(int matrix_layout, int itype, byte jobz, byte uplo, int n, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment w, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_dsygv_2stage_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dsygv_2stage_work", matrix_layout, itype, jobz, uplo, n, a, lda, b, ldb, w, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, itype, jobz, uplo, n, a, lda, b, ldb, w, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_chegv_2stage {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_chegv_2stage");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_chegv_2stage(int matrix_layout, int itype, char jobz, char uplo, int n, _Complex float *a, int lda, _Complex float *b, int ldb, float *w)
     * }
     */
    public static FunctionDescriptor LAPACKE_chegv_2stage$descriptor() {
        return LAPACKE_chegv_2stage.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_chegv_2stage(int matrix_layout, int itype, char jobz, char uplo, int n, _Complex float *a, int lda, _Complex float *b, int ldb, float *w)
     * }
     */
    public static MethodHandle LAPACKE_chegv_2stage$handle() {
        return LAPACKE_chegv_2stage.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_chegv_2stage(int matrix_layout, int itype, char jobz, char uplo, int n, _Complex float *a, int lda, _Complex float *b, int ldb, float *w)
     * }
     */
    public static MemorySegment LAPACKE_chegv_2stage$address() {
        return LAPACKE_chegv_2stage.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_chegv_2stage(int matrix_layout, int itype, char jobz, char uplo, int n, _Complex float *a, int lda, _Complex float *b, int ldb, float *w)
     * }
     */
    public static int LAPACKE_chegv_2stage(int matrix_layout, int itype, byte jobz, byte uplo, int n, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment w) {
        var mh$ = LAPACKE_chegv_2stage.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_chegv_2stage", matrix_layout, itype, jobz, uplo, n, a, lda, b, ldb, w);
            }
            return (int)mh$.invokeExact(matrix_layout, itype, jobz, uplo, n, a, lda, b, ldb, w);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zhegv_2stage {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zhegv_2stage");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zhegv_2stage(int matrix_layout, int itype, char jobz, char uplo, int n, _Complex double *a, int lda, _Complex double *b, int ldb, double *w)
     * }
     */
    public static FunctionDescriptor LAPACKE_zhegv_2stage$descriptor() {
        return LAPACKE_zhegv_2stage.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zhegv_2stage(int matrix_layout, int itype, char jobz, char uplo, int n, _Complex double *a, int lda, _Complex double *b, int ldb, double *w)
     * }
     */
    public static MethodHandle LAPACKE_zhegv_2stage$handle() {
        return LAPACKE_zhegv_2stage.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zhegv_2stage(int matrix_layout, int itype, char jobz, char uplo, int n, _Complex double *a, int lda, _Complex double *b, int ldb, double *w)
     * }
     */
    public static MemorySegment LAPACKE_zhegv_2stage$address() {
        return LAPACKE_zhegv_2stage.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zhegv_2stage(int matrix_layout, int itype, char jobz, char uplo, int n, _Complex double *a, int lda, _Complex double *b, int ldb, double *w)
     * }
     */
    public static int LAPACKE_zhegv_2stage(int matrix_layout, int itype, byte jobz, byte uplo, int n, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment w) {
        var mh$ = LAPACKE_zhegv_2stage.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zhegv_2stage", matrix_layout, itype, jobz, uplo, n, a, lda, b, ldb, w);
            }
            return (int)mh$.invokeExact(matrix_layout, itype, jobz, uplo, n, a, lda, b, ldb, w);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_chegv_2stage_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_chegv_2stage_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_chegv_2stage_work(int matrix_layout, int itype, char jobz, char uplo, int n, _Complex float *a, int lda, _Complex float *b, int ldb, float *w, _Complex float *work, int lwork, float *rwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_chegv_2stage_work$descriptor() {
        return LAPACKE_chegv_2stage_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_chegv_2stage_work(int matrix_layout, int itype, char jobz, char uplo, int n, _Complex float *a, int lda, _Complex float *b, int ldb, float *w, _Complex float *work, int lwork, float *rwork)
     * }
     */
    public static MethodHandle LAPACKE_chegv_2stage_work$handle() {
        return LAPACKE_chegv_2stage_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_chegv_2stage_work(int matrix_layout, int itype, char jobz, char uplo, int n, _Complex float *a, int lda, _Complex float *b, int ldb, float *w, _Complex float *work, int lwork, float *rwork)
     * }
     */
    public static MemorySegment LAPACKE_chegv_2stage_work$address() {
        return LAPACKE_chegv_2stage_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_chegv_2stage_work(int matrix_layout, int itype, char jobz, char uplo, int n, _Complex float *a, int lda, _Complex float *b, int ldb, float *w, _Complex float *work, int lwork, float *rwork)
     * }
     */
    public static int LAPACKE_chegv_2stage_work(int matrix_layout, int itype, byte jobz, byte uplo, int n, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment w, MemorySegment work, int lwork, MemorySegment rwork) {
        var mh$ = LAPACKE_chegv_2stage_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_chegv_2stage_work", matrix_layout, itype, jobz, uplo, n, a, lda, b, ldb, w, work, lwork, rwork);
            }
            return (int)mh$.invokeExact(matrix_layout, itype, jobz, uplo, n, a, lda, b, ldb, w, work, lwork, rwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zhegv_2stage_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zhegv_2stage_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zhegv_2stage_work(int matrix_layout, int itype, char jobz, char uplo, int n, _Complex double *a, int lda, _Complex double *b, int ldb, double *w, _Complex double *work, int lwork, double *rwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_zhegv_2stage_work$descriptor() {
        return LAPACKE_zhegv_2stage_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zhegv_2stage_work(int matrix_layout, int itype, char jobz, char uplo, int n, _Complex double *a, int lda, _Complex double *b, int ldb, double *w, _Complex double *work, int lwork, double *rwork)
     * }
     */
    public static MethodHandle LAPACKE_zhegv_2stage_work$handle() {
        return LAPACKE_zhegv_2stage_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zhegv_2stage_work(int matrix_layout, int itype, char jobz, char uplo, int n, _Complex double *a, int lda, _Complex double *b, int ldb, double *w, _Complex double *work, int lwork, double *rwork)
     * }
     */
    public static MemorySegment LAPACKE_zhegv_2stage_work$address() {
        return LAPACKE_zhegv_2stage_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zhegv_2stage_work(int matrix_layout, int itype, char jobz, char uplo, int n, _Complex double *a, int lda, _Complex double *b, int ldb, double *w, _Complex double *work, int lwork, double *rwork)
     * }
     */
    public static int LAPACKE_zhegv_2stage_work(int matrix_layout, int itype, byte jobz, byte uplo, int n, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment w, MemorySegment work, int lwork, MemorySegment rwork) {
        var mh$ = LAPACKE_zhegv_2stage_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zhegv_2stage_work", matrix_layout, itype, jobz, uplo, n, a, lda, b, ldb, w, work, lwork, rwork);
            }
            return (int)mh$.invokeExact(matrix_layout, itype, jobz, uplo, n, a, lda, b, ldb, w, work, lwork, rwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ssysv_aa_2stage {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_ssysv_aa_2stage");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ssysv_aa_2stage(int matrix_layout, char uplo, int n, int nrhs, float *a, int lda, float *tb, int ltb, int *ipiv, int *ipiv2, float *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_ssysv_aa_2stage$descriptor() {
        return LAPACKE_ssysv_aa_2stage.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ssysv_aa_2stage(int matrix_layout, char uplo, int n, int nrhs, float *a, int lda, float *tb, int ltb, int *ipiv, int *ipiv2, float *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_ssysv_aa_2stage$handle() {
        return LAPACKE_ssysv_aa_2stage.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ssysv_aa_2stage(int matrix_layout, char uplo, int n, int nrhs, float *a, int lda, float *tb, int ltb, int *ipiv, int *ipiv2, float *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_ssysv_aa_2stage$address() {
        return LAPACKE_ssysv_aa_2stage.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ssysv_aa_2stage(int matrix_layout, char uplo, int n, int nrhs, float *a, int lda, float *tb, int ltb, int *ipiv, int *ipiv2, float *b, int ldb)
     * }
     */
    public static int LAPACKE_ssysv_aa_2stage(int matrix_layout, byte uplo, int n, int nrhs, MemorySegment a, int lda, MemorySegment tb, int ltb, MemorySegment ipiv, MemorySegment ipiv2, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_ssysv_aa_2stage.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ssysv_aa_2stage", matrix_layout, uplo, n, nrhs, a, lda, tb, ltb, ipiv, ipiv2, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, nrhs, a, lda, tb, ltb, ipiv, ipiv2, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ssysv_aa_2stage_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_ssysv_aa_2stage_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ssysv_aa_2stage_work(int matrix_layout, char uplo, int n, int nrhs, float *a, int lda, float *tb, int ltb, int *ipiv, int *ipiv2, float *b, int ldb, float *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_ssysv_aa_2stage_work$descriptor() {
        return LAPACKE_ssysv_aa_2stage_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ssysv_aa_2stage_work(int matrix_layout, char uplo, int n, int nrhs, float *a, int lda, float *tb, int ltb, int *ipiv, int *ipiv2, float *b, int ldb, float *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_ssysv_aa_2stage_work$handle() {
        return LAPACKE_ssysv_aa_2stage_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ssysv_aa_2stage_work(int matrix_layout, char uplo, int n, int nrhs, float *a, int lda, float *tb, int ltb, int *ipiv, int *ipiv2, float *b, int ldb, float *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_ssysv_aa_2stage_work$address() {
        return LAPACKE_ssysv_aa_2stage_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ssysv_aa_2stage_work(int matrix_layout, char uplo, int n, int nrhs, float *a, int lda, float *tb, int ltb, int *ipiv, int *ipiv2, float *b, int ldb, float *work, int lwork)
     * }
     */
    public static int LAPACKE_ssysv_aa_2stage_work(int matrix_layout, byte uplo, int n, int nrhs, MemorySegment a, int lda, MemorySegment tb, int ltb, MemorySegment ipiv, MemorySegment ipiv2, MemorySegment b, int ldb, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_ssysv_aa_2stage_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ssysv_aa_2stage_work", matrix_layout, uplo, n, nrhs, a, lda, tb, ltb, ipiv, ipiv2, b, ldb, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, nrhs, a, lda, tb, ltb, ipiv, ipiv2, b, ldb, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dsysv_aa_2stage {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dsysv_aa_2stage");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dsysv_aa_2stage(int matrix_layout, char uplo, int n, int nrhs, double *a, int lda, double *tb, int ltb, int *ipiv, int *ipiv2, double *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_dsysv_aa_2stage$descriptor() {
        return LAPACKE_dsysv_aa_2stage.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dsysv_aa_2stage(int matrix_layout, char uplo, int n, int nrhs, double *a, int lda, double *tb, int ltb, int *ipiv, int *ipiv2, double *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_dsysv_aa_2stage$handle() {
        return LAPACKE_dsysv_aa_2stage.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dsysv_aa_2stage(int matrix_layout, char uplo, int n, int nrhs, double *a, int lda, double *tb, int ltb, int *ipiv, int *ipiv2, double *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_dsysv_aa_2stage$address() {
        return LAPACKE_dsysv_aa_2stage.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dsysv_aa_2stage(int matrix_layout, char uplo, int n, int nrhs, double *a, int lda, double *tb, int ltb, int *ipiv, int *ipiv2, double *b, int ldb)
     * }
     */
    public static int LAPACKE_dsysv_aa_2stage(int matrix_layout, byte uplo, int n, int nrhs, MemorySegment a, int lda, MemorySegment tb, int ltb, MemorySegment ipiv, MemorySegment ipiv2, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_dsysv_aa_2stage.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dsysv_aa_2stage", matrix_layout, uplo, n, nrhs, a, lda, tb, ltb, ipiv, ipiv2, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, nrhs, a, lda, tb, ltb, ipiv, ipiv2, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dsysv_aa_2stage_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dsysv_aa_2stage_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dsysv_aa_2stage_work(int matrix_layout, char uplo, int n, int nrhs, double *a, int lda, double *tb, int ltb, int *ipiv, int *ipiv2, double *b, int ldb, double *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_dsysv_aa_2stage_work$descriptor() {
        return LAPACKE_dsysv_aa_2stage_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dsysv_aa_2stage_work(int matrix_layout, char uplo, int n, int nrhs, double *a, int lda, double *tb, int ltb, int *ipiv, int *ipiv2, double *b, int ldb, double *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_dsysv_aa_2stage_work$handle() {
        return LAPACKE_dsysv_aa_2stage_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dsysv_aa_2stage_work(int matrix_layout, char uplo, int n, int nrhs, double *a, int lda, double *tb, int ltb, int *ipiv, int *ipiv2, double *b, int ldb, double *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_dsysv_aa_2stage_work$address() {
        return LAPACKE_dsysv_aa_2stage_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dsysv_aa_2stage_work(int matrix_layout, char uplo, int n, int nrhs, double *a, int lda, double *tb, int ltb, int *ipiv, int *ipiv2, double *b, int ldb, double *work, int lwork)
     * }
     */
    public static int LAPACKE_dsysv_aa_2stage_work(int matrix_layout, byte uplo, int n, int nrhs, MemorySegment a, int lda, MemorySegment tb, int ltb, MemorySegment ipiv, MemorySegment ipiv2, MemorySegment b, int ldb, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_dsysv_aa_2stage_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dsysv_aa_2stage_work", matrix_layout, uplo, n, nrhs, a, lda, tb, ltb, ipiv, ipiv2, b, ldb, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, nrhs, a, lda, tb, ltb, ipiv, ipiv2, b, ldb, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_csysv_aa_2stage {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_csysv_aa_2stage");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_csysv_aa_2stage(int matrix_layout, char uplo, int n, int nrhs, _Complex float *a, int lda, _Complex float *tb, int ltb, int *ipiv, int *ipiv2, _Complex float *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_csysv_aa_2stage$descriptor() {
        return LAPACKE_csysv_aa_2stage.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_csysv_aa_2stage(int matrix_layout, char uplo, int n, int nrhs, _Complex float *a, int lda, _Complex float *tb, int ltb, int *ipiv, int *ipiv2, _Complex float *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_csysv_aa_2stage$handle() {
        return LAPACKE_csysv_aa_2stage.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_csysv_aa_2stage(int matrix_layout, char uplo, int n, int nrhs, _Complex float *a, int lda, _Complex float *tb, int ltb, int *ipiv, int *ipiv2, _Complex float *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_csysv_aa_2stage$address() {
        return LAPACKE_csysv_aa_2stage.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_csysv_aa_2stage(int matrix_layout, char uplo, int n, int nrhs, _Complex float *a, int lda, _Complex float *tb, int ltb, int *ipiv, int *ipiv2, _Complex float *b, int ldb)
     * }
     */
    public static int LAPACKE_csysv_aa_2stage(int matrix_layout, byte uplo, int n, int nrhs, MemorySegment a, int lda, MemorySegment tb, int ltb, MemorySegment ipiv, MemorySegment ipiv2, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_csysv_aa_2stage.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_csysv_aa_2stage", matrix_layout, uplo, n, nrhs, a, lda, tb, ltb, ipiv, ipiv2, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, nrhs, a, lda, tb, ltb, ipiv, ipiv2, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_csysv_aa_2stage_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_csysv_aa_2stage_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_csysv_aa_2stage_work(int matrix_layout, char uplo, int n, int nrhs, _Complex float *a, int lda, _Complex float *tb, int ltb, int *ipiv, int *ipiv2, _Complex float *b, int ldb, _Complex float *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_csysv_aa_2stage_work$descriptor() {
        return LAPACKE_csysv_aa_2stage_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_csysv_aa_2stage_work(int matrix_layout, char uplo, int n, int nrhs, _Complex float *a, int lda, _Complex float *tb, int ltb, int *ipiv, int *ipiv2, _Complex float *b, int ldb, _Complex float *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_csysv_aa_2stage_work$handle() {
        return LAPACKE_csysv_aa_2stage_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_csysv_aa_2stage_work(int matrix_layout, char uplo, int n, int nrhs, _Complex float *a, int lda, _Complex float *tb, int ltb, int *ipiv, int *ipiv2, _Complex float *b, int ldb, _Complex float *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_csysv_aa_2stage_work$address() {
        return LAPACKE_csysv_aa_2stage_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_csysv_aa_2stage_work(int matrix_layout, char uplo, int n, int nrhs, _Complex float *a, int lda, _Complex float *tb, int ltb, int *ipiv, int *ipiv2, _Complex float *b, int ldb, _Complex float *work, int lwork)
     * }
     */
    public static int LAPACKE_csysv_aa_2stage_work(int matrix_layout, byte uplo, int n, int nrhs, MemorySegment a, int lda, MemorySegment tb, int ltb, MemorySegment ipiv, MemorySegment ipiv2, MemorySegment b, int ldb, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_csysv_aa_2stage_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_csysv_aa_2stage_work", matrix_layout, uplo, n, nrhs, a, lda, tb, ltb, ipiv, ipiv2, b, ldb, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, nrhs, a, lda, tb, ltb, ipiv, ipiv2, b, ldb, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zsysv_aa_2stage {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zsysv_aa_2stage");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zsysv_aa_2stage(int matrix_layout, char uplo, int n, int nrhs, _Complex double *a, int lda, _Complex double *tb, int ltb, int *ipiv, int *ipiv2, _Complex double *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_zsysv_aa_2stage$descriptor() {
        return LAPACKE_zsysv_aa_2stage.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zsysv_aa_2stage(int matrix_layout, char uplo, int n, int nrhs, _Complex double *a, int lda, _Complex double *tb, int ltb, int *ipiv, int *ipiv2, _Complex double *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_zsysv_aa_2stage$handle() {
        return LAPACKE_zsysv_aa_2stage.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zsysv_aa_2stage(int matrix_layout, char uplo, int n, int nrhs, _Complex double *a, int lda, _Complex double *tb, int ltb, int *ipiv, int *ipiv2, _Complex double *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_zsysv_aa_2stage$address() {
        return LAPACKE_zsysv_aa_2stage.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zsysv_aa_2stage(int matrix_layout, char uplo, int n, int nrhs, _Complex double *a, int lda, _Complex double *tb, int ltb, int *ipiv, int *ipiv2, _Complex double *b, int ldb)
     * }
     */
    public static int LAPACKE_zsysv_aa_2stage(int matrix_layout, byte uplo, int n, int nrhs, MemorySegment a, int lda, MemorySegment tb, int ltb, MemorySegment ipiv, MemorySegment ipiv2, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_zsysv_aa_2stage.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zsysv_aa_2stage", matrix_layout, uplo, n, nrhs, a, lda, tb, ltb, ipiv, ipiv2, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, nrhs, a, lda, tb, ltb, ipiv, ipiv2, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zsysv_aa_2stage_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zsysv_aa_2stage_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zsysv_aa_2stage_work(int matrix_layout, char uplo, int n, int nrhs, _Complex double *a, int lda, _Complex double *tb, int ltb, int *ipiv, int *ipiv2, _Complex double *b, int ldb, _Complex double *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_zsysv_aa_2stage_work$descriptor() {
        return LAPACKE_zsysv_aa_2stage_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zsysv_aa_2stage_work(int matrix_layout, char uplo, int n, int nrhs, _Complex double *a, int lda, _Complex double *tb, int ltb, int *ipiv, int *ipiv2, _Complex double *b, int ldb, _Complex double *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_zsysv_aa_2stage_work$handle() {
        return LAPACKE_zsysv_aa_2stage_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zsysv_aa_2stage_work(int matrix_layout, char uplo, int n, int nrhs, _Complex double *a, int lda, _Complex double *tb, int ltb, int *ipiv, int *ipiv2, _Complex double *b, int ldb, _Complex double *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_zsysv_aa_2stage_work$address() {
        return LAPACKE_zsysv_aa_2stage_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zsysv_aa_2stage_work(int matrix_layout, char uplo, int n, int nrhs, _Complex double *a, int lda, _Complex double *tb, int ltb, int *ipiv, int *ipiv2, _Complex double *b, int ldb, _Complex double *work, int lwork)
     * }
     */
    public static int LAPACKE_zsysv_aa_2stage_work(int matrix_layout, byte uplo, int n, int nrhs, MemorySegment a, int lda, MemorySegment tb, int ltb, MemorySegment ipiv, MemorySegment ipiv2, MemorySegment b, int ldb, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_zsysv_aa_2stage_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zsysv_aa_2stage_work", matrix_layout, uplo, n, nrhs, a, lda, tb, ltb, ipiv, ipiv2, b, ldb, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, nrhs, a, lda, tb, ltb, ipiv, ipiv2, b, ldb, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_chesv_aa_2stage {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_chesv_aa_2stage");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_chesv_aa_2stage(int matrix_layout, char uplo, int n, int nrhs, _Complex float *a, int lda, _Complex float *tb, int ltb, int *ipiv, int *ipiv2, _Complex float *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_chesv_aa_2stage$descriptor() {
        return LAPACKE_chesv_aa_2stage.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_chesv_aa_2stage(int matrix_layout, char uplo, int n, int nrhs, _Complex float *a, int lda, _Complex float *tb, int ltb, int *ipiv, int *ipiv2, _Complex float *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_chesv_aa_2stage$handle() {
        return LAPACKE_chesv_aa_2stage.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_chesv_aa_2stage(int matrix_layout, char uplo, int n, int nrhs, _Complex float *a, int lda, _Complex float *tb, int ltb, int *ipiv, int *ipiv2, _Complex float *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_chesv_aa_2stage$address() {
        return LAPACKE_chesv_aa_2stage.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_chesv_aa_2stage(int matrix_layout, char uplo, int n, int nrhs, _Complex float *a, int lda, _Complex float *tb, int ltb, int *ipiv, int *ipiv2, _Complex float *b, int ldb)
     * }
     */
    public static int LAPACKE_chesv_aa_2stage(int matrix_layout, byte uplo, int n, int nrhs, MemorySegment a, int lda, MemorySegment tb, int ltb, MemorySegment ipiv, MemorySegment ipiv2, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_chesv_aa_2stage.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_chesv_aa_2stage", matrix_layout, uplo, n, nrhs, a, lda, tb, ltb, ipiv, ipiv2, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, nrhs, a, lda, tb, ltb, ipiv, ipiv2, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_chesv_aa_2stage_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_chesv_aa_2stage_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_chesv_aa_2stage_work(int matrix_layout, char uplo, int n, int nrhs, _Complex float *a, int lda, _Complex float *tb, int ltb, int *ipiv, int *ipiv2, _Complex float *b, int ldb, _Complex float *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_chesv_aa_2stage_work$descriptor() {
        return LAPACKE_chesv_aa_2stage_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_chesv_aa_2stage_work(int matrix_layout, char uplo, int n, int nrhs, _Complex float *a, int lda, _Complex float *tb, int ltb, int *ipiv, int *ipiv2, _Complex float *b, int ldb, _Complex float *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_chesv_aa_2stage_work$handle() {
        return LAPACKE_chesv_aa_2stage_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_chesv_aa_2stage_work(int matrix_layout, char uplo, int n, int nrhs, _Complex float *a, int lda, _Complex float *tb, int ltb, int *ipiv, int *ipiv2, _Complex float *b, int ldb, _Complex float *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_chesv_aa_2stage_work$address() {
        return LAPACKE_chesv_aa_2stage_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_chesv_aa_2stage_work(int matrix_layout, char uplo, int n, int nrhs, _Complex float *a, int lda, _Complex float *tb, int ltb, int *ipiv, int *ipiv2, _Complex float *b, int ldb, _Complex float *work, int lwork)
     * }
     */
    public static int LAPACKE_chesv_aa_2stage_work(int matrix_layout, byte uplo, int n, int nrhs, MemorySegment a, int lda, MemorySegment tb, int ltb, MemorySegment ipiv, MemorySegment ipiv2, MemorySegment b, int ldb, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_chesv_aa_2stage_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_chesv_aa_2stage_work", matrix_layout, uplo, n, nrhs, a, lda, tb, ltb, ipiv, ipiv2, b, ldb, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, nrhs, a, lda, tb, ltb, ipiv, ipiv2, b, ldb, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zhesv_aa_2stage {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zhesv_aa_2stage");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zhesv_aa_2stage(int matrix_layout, char uplo, int n, int nrhs, _Complex double *a, int lda, _Complex double *tb, int ltb, int *ipiv, int *ipiv2, _Complex double *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_zhesv_aa_2stage$descriptor() {
        return LAPACKE_zhesv_aa_2stage.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zhesv_aa_2stage(int matrix_layout, char uplo, int n, int nrhs, _Complex double *a, int lda, _Complex double *tb, int ltb, int *ipiv, int *ipiv2, _Complex double *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_zhesv_aa_2stage$handle() {
        return LAPACKE_zhesv_aa_2stage.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zhesv_aa_2stage(int matrix_layout, char uplo, int n, int nrhs, _Complex double *a, int lda, _Complex double *tb, int ltb, int *ipiv, int *ipiv2, _Complex double *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_zhesv_aa_2stage$address() {
        return LAPACKE_zhesv_aa_2stage.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zhesv_aa_2stage(int matrix_layout, char uplo, int n, int nrhs, _Complex double *a, int lda, _Complex double *tb, int ltb, int *ipiv, int *ipiv2, _Complex double *b, int ldb)
     * }
     */
    public static int LAPACKE_zhesv_aa_2stage(int matrix_layout, byte uplo, int n, int nrhs, MemorySegment a, int lda, MemorySegment tb, int ltb, MemorySegment ipiv, MemorySegment ipiv2, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_zhesv_aa_2stage.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zhesv_aa_2stage", matrix_layout, uplo, n, nrhs, a, lda, tb, ltb, ipiv, ipiv2, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, nrhs, a, lda, tb, ltb, ipiv, ipiv2, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zhesv_aa_2stage_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zhesv_aa_2stage_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zhesv_aa_2stage_work(int matrix_layout, char uplo, int n, int nrhs, _Complex double *a, int lda, _Complex double *tb, int ltb, int *ipiv, int *ipiv2, _Complex double *b, int ldb, _Complex double *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_zhesv_aa_2stage_work$descriptor() {
        return LAPACKE_zhesv_aa_2stage_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zhesv_aa_2stage_work(int matrix_layout, char uplo, int n, int nrhs, _Complex double *a, int lda, _Complex double *tb, int ltb, int *ipiv, int *ipiv2, _Complex double *b, int ldb, _Complex double *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_zhesv_aa_2stage_work$handle() {
        return LAPACKE_zhesv_aa_2stage_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zhesv_aa_2stage_work(int matrix_layout, char uplo, int n, int nrhs, _Complex double *a, int lda, _Complex double *tb, int ltb, int *ipiv, int *ipiv2, _Complex double *b, int ldb, _Complex double *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_zhesv_aa_2stage_work$address() {
        return LAPACKE_zhesv_aa_2stage_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zhesv_aa_2stage_work(int matrix_layout, char uplo, int n, int nrhs, _Complex double *a, int lda, _Complex double *tb, int ltb, int *ipiv, int *ipiv2, _Complex double *b, int ldb, _Complex double *work, int lwork)
     * }
     */
    public static int LAPACKE_zhesv_aa_2stage_work(int matrix_layout, byte uplo, int n, int nrhs, MemorySegment a, int lda, MemorySegment tb, int ltb, MemorySegment ipiv, MemorySegment ipiv2, MemorySegment b, int ldb, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_zhesv_aa_2stage_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zhesv_aa_2stage_work", matrix_layout, uplo, n, nrhs, a, lda, tb, ltb, ipiv, ipiv2, b, ldb, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, nrhs, a, lda, tb, ltb, ipiv, ipiv2, b, ldb, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ssytrf_aa_2stage {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_ssytrf_aa_2stage");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ssytrf_aa_2stage(int matrix_layout, char uplo, int n, float *a, int lda, float *tb, int ltb, int *ipiv, int *ipiv2)
     * }
     */
    public static FunctionDescriptor LAPACKE_ssytrf_aa_2stage$descriptor() {
        return LAPACKE_ssytrf_aa_2stage.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ssytrf_aa_2stage(int matrix_layout, char uplo, int n, float *a, int lda, float *tb, int ltb, int *ipiv, int *ipiv2)
     * }
     */
    public static MethodHandle LAPACKE_ssytrf_aa_2stage$handle() {
        return LAPACKE_ssytrf_aa_2stage.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ssytrf_aa_2stage(int matrix_layout, char uplo, int n, float *a, int lda, float *tb, int ltb, int *ipiv, int *ipiv2)
     * }
     */
    public static MemorySegment LAPACKE_ssytrf_aa_2stage$address() {
        return LAPACKE_ssytrf_aa_2stage.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ssytrf_aa_2stage(int matrix_layout, char uplo, int n, float *a, int lda, float *tb, int ltb, int *ipiv, int *ipiv2)
     * }
     */
    public static int LAPACKE_ssytrf_aa_2stage(int matrix_layout, byte uplo, int n, MemorySegment a, int lda, MemorySegment tb, int ltb, MemorySegment ipiv, MemorySegment ipiv2) {
        var mh$ = LAPACKE_ssytrf_aa_2stage.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ssytrf_aa_2stage", matrix_layout, uplo, n, a, lda, tb, ltb, ipiv, ipiv2);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, a, lda, tb, ltb, ipiv, ipiv2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ssytrf_aa_2stage_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_ssytrf_aa_2stage_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ssytrf_aa_2stage_work(int matrix_layout, char uplo, int n, float *a, int lda, float *tb, int ltb, int *ipiv, int *ipiv2, float *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_ssytrf_aa_2stage_work$descriptor() {
        return LAPACKE_ssytrf_aa_2stage_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ssytrf_aa_2stage_work(int matrix_layout, char uplo, int n, float *a, int lda, float *tb, int ltb, int *ipiv, int *ipiv2, float *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_ssytrf_aa_2stage_work$handle() {
        return LAPACKE_ssytrf_aa_2stage_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ssytrf_aa_2stage_work(int matrix_layout, char uplo, int n, float *a, int lda, float *tb, int ltb, int *ipiv, int *ipiv2, float *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_ssytrf_aa_2stage_work$address() {
        return LAPACKE_ssytrf_aa_2stage_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ssytrf_aa_2stage_work(int matrix_layout, char uplo, int n, float *a, int lda, float *tb, int ltb, int *ipiv, int *ipiv2, float *work, int lwork)
     * }
     */
    public static int LAPACKE_ssytrf_aa_2stage_work(int matrix_layout, byte uplo, int n, MemorySegment a, int lda, MemorySegment tb, int ltb, MemorySegment ipiv, MemorySegment ipiv2, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_ssytrf_aa_2stage_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ssytrf_aa_2stage_work", matrix_layout, uplo, n, a, lda, tb, ltb, ipiv, ipiv2, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, a, lda, tb, ltb, ipiv, ipiv2, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dsytrf_aa_2stage {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dsytrf_aa_2stage");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dsytrf_aa_2stage(int matrix_layout, char uplo, int n, double *a, int lda, double *tb, int ltb, int *ipiv, int *ipiv2)
     * }
     */
    public static FunctionDescriptor LAPACKE_dsytrf_aa_2stage$descriptor() {
        return LAPACKE_dsytrf_aa_2stage.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dsytrf_aa_2stage(int matrix_layout, char uplo, int n, double *a, int lda, double *tb, int ltb, int *ipiv, int *ipiv2)
     * }
     */
    public static MethodHandle LAPACKE_dsytrf_aa_2stage$handle() {
        return LAPACKE_dsytrf_aa_2stage.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dsytrf_aa_2stage(int matrix_layout, char uplo, int n, double *a, int lda, double *tb, int ltb, int *ipiv, int *ipiv2)
     * }
     */
    public static MemorySegment LAPACKE_dsytrf_aa_2stage$address() {
        return LAPACKE_dsytrf_aa_2stage.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dsytrf_aa_2stage(int matrix_layout, char uplo, int n, double *a, int lda, double *tb, int ltb, int *ipiv, int *ipiv2)
     * }
     */
    public static int LAPACKE_dsytrf_aa_2stage(int matrix_layout, byte uplo, int n, MemorySegment a, int lda, MemorySegment tb, int ltb, MemorySegment ipiv, MemorySegment ipiv2) {
        var mh$ = LAPACKE_dsytrf_aa_2stage.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dsytrf_aa_2stage", matrix_layout, uplo, n, a, lda, tb, ltb, ipiv, ipiv2);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, a, lda, tb, ltb, ipiv, ipiv2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dsytrf_aa_2stage_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dsytrf_aa_2stage_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dsytrf_aa_2stage_work(int matrix_layout, char uplo, int n, double *a, int lda, double *tb, int ltb, int *ipiv, int *ipiv2, double *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_dsytrf_aa_2stage_work$descriptor() {
        return LAPACKE_dsytrf_aa_2stage_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dsytrf_aa_2stage_work(int matrix_layout, char uplo, int n, double *a, int lda, double *tb, int ltb, int *ipiv, int *ipiv2, double *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_dsytrf_aa_2stage_work$handle() {
        return LAPACKE_dsytrf_aa_2stage_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dsytrf_aa_2stage_work(int matrix_layout, char uplo, int n, double *a, int lda, double *tb, int ltb, int *ipiv, int *ipiv2, double *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_dsytrf_aa_2stage_work$address() {
        return LAPACKE_dsytrf_aa_2stage_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dsytrf_aa_2stage_work(int matrix_layout, char uplo, int n, double *a, int lda, double *tb, int ltb, int *ipiv, int *ipiv2, double *work, int lwork)
     * }
     */
    public static int LAPACKE_dsytrf_aa_2stage_work(int matrix_layout, byte uplo, int n, MemorySegment a, int lda, MemorySegment tb, int ltb, MemorySegment ipiv, MemorySegment ipiv2, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_dsytrf_aa_2stage_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dsytrf_aa_2stage_work", matrix_layout, uplo, n, a, lda, tb, ltb, ipiv, ipiv2, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, a, lda, tb, ltb, ipiv, ipiv2, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_csytrf_aa_2stage {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_csytrf_aa_2stage");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_csytrf_aa_2stage(int matrix_layout, char uplo, int n, _Complex float *a, int lda, _Complex float *tb, int ltb, int *ipiv, int *ipiv2)
     * }
     */
    public static FunctionDescriptor LAPACKE_csytrf_aa_2stage$descriptor() {
        return LAPACKE_csytrf_aa_2stage.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_csytrf_aa_2stage(int matrix_layout, char uplo, int n, _Complex float *a, int lda, _Complex float *tb, int ltb, int *ipiv, int *ipiv2)
     * }
     */
    public static MethodHandle LAPACKE_csytrf_aa_2stage$handle() {
        return LAPACKE_csytrf_aa_2stage.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_csytrf_aa_2stage(int matrix_layout, char uplo, int n, _Complex float *a, int lda, _Complex float *tb, int ltb, int *ipiv, int *ipiv2)
     * }
     */
    public static MemorySegment LAPACKE_csytrf_aa_2stage$address() {
        return LAPACKE_csytrf_aa_2stage.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_csytrf_aa_2stage(int matrix_layout, char uplo, int n, _Complex float *a, int lda, _Complex float *tb, int ltb, int *ipiv, int *ipiv2)
     * }
     */
    public static int LAPACKE_csytrf_aa_2stage(int matrix_layout, byte uplo, int n, MemorySegment a, int lda, MemorySegment tb, int ltb, MemorySegment ipiv, MemorySegment ipiv2) {
        var mh$ = LAPACKE_csytrf_aa_2stage.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_csytrf_aa_2stage", matrix_layout, uplo, n, a, lda, tb, ltb, ipiv, ipiv2);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, a, lda, tb, ltb, ipiv, ipiv2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_csytrf_aa_2stage_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_csytrf_aa_2stage_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_csytrf_aa_2stage_work(int matrix_layout, char uplo, int n, _Complex float *a, int lda, _Complex float *tb, int ltb, int *ipiv, int *ipiv2, _Complex float *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_csytrf_aa_2stage_work$descriptor() {
        return LAPACKE_csytrf_aa_2stage_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_csytrf_aa_2stage_work(int matrix_layout, char uplo, int n, _Complex float *a, int lda, _Complex float *tb, int ltb, int *ipiv, int *ipiv2, _Complex float *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_csytrf_aa_2stage_work$handle() {
        return LAPACKE_csytrf_aa_2stage_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_csytrf_aa_2stage_work(int matrix_layout, char uplo, int n, _Complex float *a, int lda, _Complex float *tb, int ltb, int *ipiv, int *ipiv2, _Complex float *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_csytrf_aa_2stage_work$address() {
        return LAPACKE_csytrf_aa_2stage_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_csytrf_aa_2stage_work(int matrix_layout, char uplo, int n, _Complex float *a, int lda, _Complex float *tb, int ltb, int *ipiv, int *ipiv2, _Complex float *work, int lwork)
     * }
     */
    public static int LAPACKE_csytrf_aa_2stage_work(int matrix_layout, byte uplo, int n, MemorySegment a, int lda, MemorySegment tb, int ltb, MemorySegment ipiv, MemorySegment ipiv2, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_csytrf_aa_2stage_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_csytrf_aa_2stage_work", matrix_layout, uplo, n, a, lda, tb, ltb, ipiv, ipiv2, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, a, lda, tb, ltb, ipiv, ipiv2, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zsytrf_aa_2stage {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zsytrf_aa_2stage");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zsytrf_aa_2stage(int matrix_layout, char uplo, int n, _Complex double *a, int lda, _Complex double *tb, int ltb, int *ipiv, int *ipiv2)
     * }
     */
    public static FunctionDescriptor LAPACKE_zsytrf_aa_2stage$descriptor() {
        return LAPACKE_zsytrf_aa_2stage.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zsytrf_aa_2stage(int matrix_layout, char uplo, int n, _Complex double *a, int lda, _Complex double *tb, int ltb, int *ipiv, int *ipiv2)
     * }
     */
    public static MethodHandle LAPACKE_zsytrf_aa_2stage$handle() {
        return LAPACKE_zsytrf_aa_2stage.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zsytrf_aa_2stage(int matrix_layout, char uplo, int n, _Complex double *a, int lda, _Complex double *tb, int ltb, int *ipiv, int *ipiv2)
     * }
     */
    public static MemorySegment LAPACKE_zsytrf_aa_2stage$address() {
        return LAPACKE_zsytrf_aa_2stage.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zsytrf_aa_2stage(int matrix_layout, char uplo, int n, _Complex double *a, int lda, _Complex double *tb, int ltb, int *ipiv, int *ipiv2)
     * }
     */
    public static int LAPACKE_zsytrf_aa_2stage(int matrix_layout, byte uplo, int n, MemorySegment a, int lda, MemorySegment tb, int ltb, MemorySegment ipiv, MemorySegment ipiv2) {
        var mh$ = LAPACKE_zsytrf_aa_2stage.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zsytrf_aa_2stage", matrix_layout, uplo, n, a, lda, tb, ltb, ipiv, ipiv2);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, a, lda, tb, ltb, ipiv, ipiv2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zsytrf_aa_2stage_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zsytrf_aa_2stage_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zsytrf_aa_2stage_work(int matrix_layout, char uplo, int n, _Complex double *a, int lda, _Complex double *tb, int ltb, int *ipiv, int *ipiv2, _Complex double *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_zsytrf_aa_2stage_work$descriptor() {
        return LAPACKE_zsytrf_aa_2stage_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zsytrf_aa_2stage_work(int matrix_layout, char uplo, int n, _Complex double *a, int lda, _Complex double *tb, int ltb, int *ipiv, int *ipiv2, _Complex double *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_zsytrf_aa_2stage_work$handle() {
        return LAPACKE_zsytrf_aa_2stage_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zsytrf_aa_2stage_work(int matrix_layout, char uplo, int n, _Complex double *a, int lda, _Complex double *tb, int ltb, int *ipiv, int *ipiv2, _Complex double *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_zsytrf_aa_2stage_work$address() {
        return LAPACKE_zsytrf_aa_2stage_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zsytrf_aa_2stage_work(int matrix_layout, char uplo, int n, _Complex double *a, int lda, _Complex double *tb, int ltb, int *ipiv, int *ipiv2, _Complex double *work, int lwork)
     * }
     */
    public static int LAPACKE_zsytrf_aa_2stage_work(int matrix_layout, byte uplo, int n, MemorySegment a, int lda, MemorySegment tb, int ltb, MemorySegment ipiv, MemorySegment ipiv2, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_zsytrf_aa_2stage_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zsytrf_aa_2stage_work", matrix_layout, uplo, n, a, lda, tb, ltb, ipiv, ipiv2, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, a, lda, tb, ltb, ipiv, ipiv2, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_chetrf_aa_2stage {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_chetrf_aa_2stage");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_chetrf_aa_2stage(int matrix_layout, char uplo, int n, _Complex float *a, int lda, _Complex float *tb, int ltb, int *ipiv, int *ipiv2)
     * }
     */
    public static FunctionDescriptor LAPACKE_chetrf_aa_2stage$descriptor() {
        return LAPACKE_chetrf_aa_2stage.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_chetrf_aa_2stage(int matrix_layout, char uplo, int n, _Complex float *a, int lda, _Complex float *tb, int ltb, int *ipiv, int *ipiv2)
     * }
     */
    public static MethodHandle LAPACKE_chetrf_aa_2stage$handle() {
        return LAPACKE_chetrf_aa_2stage.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_chetrf_aa_2stage(int matrix_layout, char uplo, int n, _Complex float *a, int lda, _Complex float *tb, int ltb, int *ipiv, int *ipiv2)
     * }
     */
    public static MemorySegment LAPACKE_chetrf_aa_2stage$address() {
        return LAPACKE_chetrf_aa_2stage.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_chetrf_aa_2stage(int matrix_layout, char uplo, int n, _Complex float *a, int lda, _Complex float *tb, int ltb, int *ipiv, int *ipiv2)
     * }
     */
    public static int LAPACKE_chetrf_aa_2stage(int matrix_layout, byte uplo, int n, MemorySegment a, int lda, MemorySegment tb, int ltb, MemorySegment ipiv, MemorySegment ipiv2) {
        var mh$ = LAPACKE_chetrf_aa_2stage.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_chetrf_aa_2stage", matrix_layout, uplo, n, a, lda, tb, ltb, ipiv, ipiv2);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, a, lda, tb, ltb, ipiv, ipiv2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_chetrf_aa_2stage_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_chetrf_aa_2stage_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_chetrf_aa_2stage_work(int matrix_layout, char uplo, int n, _Complex float *a, int lda, _Complex float *tb, int ltb, int *ipiv, int *ipiv2, _Complex float *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_chetrf_aa_2stage_work$descriptor() {
        return LAPACKE_chetrf_aa_2stage_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_chetrf_aa_2stage_work(int matrix_layout, char uplo, int n, _Complex float *a, int lda, _Complex float *tb, int ltb, int *ipiv, int *ipiv2, _Complex float *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_chetrf_aa_2stage_work$handle() {
        return LAPACKE_chetrf_aa_2stage_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_chetrf_aa_2stage_work(int matrix_layout, char uplo, int n, _Complex float *a, int lda, _Complex float *tb, int ltb, int *ipiv, int *ipiv2, _Complex float *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_chetrf_aa_2stage_work$address() {
        return LAPACKE_chetrf_aa_2stage_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_chetrf_aa_2stage_work(int matrix_layout, char uplo, int n, _Complex float *a, int lda, _Complex float *tb, int ltb, int *ipiv, int *ipiv2, _Complex float *work, int lwork)
     * }
     */
    public static int LAPACKE_chetrf_aa_2stage_work(int matrix_layout, byte uplo, int n, MemorySegment a, int lda, MemorySegment tb, int ltb, MemorySegment ipiv, MemorySegment ipiv2, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_chetrf_aa_2stage_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_chetrf_aa_2stage_work", matrix_layout, uplo, n, a, lda, tb, ltb, ipiv, ipiv2, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, a, lda, tb, ltb, ipiv, ipiv2, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zhetrf_aa_2stage {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zhetrf_aa_2stage");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zhetrf_aa_2stage(int matrix_layout, char uplo, int n, _Complex double *a, int lda, _Complex double *tb, int ltb, int *ipiv, int *ipiv2)
     * }
     */
    public static FunctionDescriptor LAPACKE_zhetrf_aa_2stage$descriptor() {
        return LAPACKE_zhetrf_aa_2stage.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zhetrf_aa_2stage(int matrix_layout, char uplo, int n, _Complex double *a, int lda, _Complex double *tb, int ltb, int *ipiv, int *ipiv2)
     * }
     */
    public static MethodHandle LAPACKE_zhetrf_aa_2stage$handle() {
        return LAPACKE_zhetrf_aa_2stage.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zhetrf_aa_2stage(int matrix_layout, char uplo, int n, _Complex double *a, int lda, _Complex double *tb, int ltb, int *ipiv, int *ipiv2)
     * }
     */
    public static MemorySegment LAPACKE_zhetrf_aa_2stage$address() {
        return LAPACKE_zhetrf_aa_2stage.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zhetrf_aa_2stage(int matrix_layout, char uplo, int n, _Complex double *a, int lda, _Complex double *tb, int ltb, int *ipiv, int *ipiv2)
     * }
     */
    public static int LAPACKE_zhetrf_aa_2stage(int matrix_layout, byte uplo, int n, MemorySegment a, int lda, MemorySegment tb, int ltb, MemorySegment ipiv, MemorySegment ipiv2) {
        var mh$ = LAPACKE_zhetrf_aa_2stage.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zhetrf_aa_2stage", matrix_layout, uplo, n, a, lda, tb, ltb, ipiv, ipiv2);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, a, lda, tb, ltb, ipiv, ipiv2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zhetrf_aa_2stage_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zhetrf_aa_2stage_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zhetrf_aa_2stage_work(int matrix_layout, char uplo, int n, _Complex double *a, int lda, _Complex double *tb, int ltb, int *ipiv, int *ipiv2, _Complex double *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_zhetrf_aa_2stage_work$descriptor() {
        return LAPACKE_zhetrf_aa_2stage_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zhetrf_aa_2stage_work(int matrix_layout, char uplo, int n, _Complex double *a, int lda, _Complex double *tb, int ltb, int *ipiv, int *ipiv2, _Complex double *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_zhetrf_aa_2stage_work$handle() {
        return LAPACKE_zhetrf_aa_2stage_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zhetrf_aa_2stage_work(int matrix_layout, char uplo, int n, _Complex double *a, int lda, _Complex double *tb, int ltb, int *ipiv, int *ipiv2, _Complex double *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_zhetrf_aa_2stage_work$address() {
        return LAPACKE_zhetrf_aa_2stage_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zhetrf_aa_2stage_work(int matrix_layout, char uplo, int n, _Complex double *a, int lda, _Complex double *tb, int ltb, int *ipiv, int *ipiv2, _Complex double *work, int lwork)
     * }
     */
    public static int LAPACKE_zhetrf_aa_2stage_work(int matrix_layout, byte uplo, int n, MemorySegment a, int lda, MemorySegment tb, int ltb, MemorySegment ipiv, MemorySegment ipiv2, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_zhetrf_aa_2stage_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zhetrf_aa_2stage_work", matrix_layout, uplo, n, a, lda, tb, ltb, ipiv, ipiv2, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, a, lda, tb, ltb, ipiv, ipiv2, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ssytrs_aa_2stage {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_ssytrs_aa_2stage");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ssytrs_aa_2stage(int matrix_layout, char uplo, int n, int nrhs, float *a, int lda, float *tb, int ltb, int *ipiv, int *ipiv2, float *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_ssytrs_aa_2stage$descriptor() {
        return LAPACKE_ssytrs_aa_2stage.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ssytrs_aa_2stage(int matrix_layout, char uplo, int n, int nrhs, float *a, int lda, float *tb, int ltb, int *ipiv, int *ipiv2, float *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_ssytrs_aa_2stage$handle() {
        return LAPACKE_ssytrs_aa_2stage.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ssytrs_aa_2stage(int matrix_layout, char uplo, int n, int nrhs, float *a, int lda, float *tb, int ltb, int *ipiv, int *ipiv2, float *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_ssytrs_aa_2stage$address() {
        return LAPACKE_ssytrs_aa_2stage.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ssytrs_aa_2stage(int matrix_layout, char uplo, int n, int nrhs, float *a, int lda, float *tb, int ltb, int *ipiv, int *ipiv2, float *b, int ldb)
     * }
     */
    public static int LAPACKE_ssytrs_aa_2stage(int matrix_layout, byte uplo, int n, int nrhs, MemorySegment a, int lda, MemorySegment tb, int ltb, MemorySegment ipiv, MemorySegment ipiv2, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_ssytrs_aa_2stage.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ssytrs_aa_2stage", matrix_layout, uplo, n, nrhs, a, lda, tb, ltb, ipiv, ipiv2, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, nrhs, a, lda, tb, ltb, ipiv, ipiv2, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ssytrs_aa_2stage_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_ssytrs_aa_2stage_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ssytrs_aa_2stage_work(int matrix_layout, char uplo, int n, int nrhs, float *a, int lda, float *tb, int ltb, int *ipiv, int *ipiv2, float *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_ssytrs_aa_2stage_work$descriptor() {
        return LAPACKE_ssytrs_aa_2stage_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ssytrs_aa_2stage_work(int matrix_layout, char uplo, int n, int nrhs, float *a, int lda, float *tb, int ltb, int *ipiv, int *ipiv2, float *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_ssytrs_aa_2stage_work$handle() {
        return LAPACKE_ssytrs_aa_2stage_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ssytrs_aa_2stage_work(int matrix_layout, char uplo, int n, int nrhs, float *a, int lda, float *tb, int ltb, int *ipiv, int *ipiv2, float *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_ssytrs_aa_2stage_work$address() {
        return LAPACKE_ssytrs_aa_2stage_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ssytrs_aa_2stage_work(int matrix_layout, char uplo, int n, int nrhs, float *a, int lda, float *tb, int ltb, int *ipiv, int *ipiv2, float *b, int ldb)
     * }
     */
    public static int LAPACKE_ssytrs_aa_2stage_work(int matrix_layout, byte uplo, int n, int nrhs, MemorySegment a, int lda, MemorySegment tb, int ltb, MemorySegment ipiv, MemorySegment ipiv2, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_ssytrs_aa_2stage_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ssytrs_aa_2stage_work", matrix_layout, uplo, n, nrhs, a, lda, tb, ltb, ipiv, ipiv2, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, nrhs, a, lda, tb, ltb, ipiv, ipiv2, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dsytrs_aa_2stage {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dsytrs_aa_2stage");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dsytrs_aa_2stage(int matrix_layout, char uplo, int n, int nrhs, double *a, int lda, double *tb, int ltb, int *ipiv, int *ipiv2, double *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_dsytrs_aa_2stage$descriptor() {
        return LAPACKE_dsytrs_aa_2stage.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dsytrs_aa_2stage(int matrix_layout, char uplo, int n, int nrhs, double *a, int lda, double *tb, int ltb, int *ipiv, int *ipiv2, double *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_dsytrs_aa_2stage$handle() {
        return LAPACKE_dsytrs_aa_2stage.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dsytrs_aa_2stage(int matrix_layout, char uplo, int n, int nrhs, double *a, int lda, double *tb, int ltb, int *ipiv, int *ipiv2, double *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_dsytrs_aa_2stage$address() {
        return LAPACKE_dsytrs_aa_2stage.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dsytrs_aa_2stage(int matrix_layout, char uplo, int n, int nrhs, double *a, int lda, double *tb, int ltb, int *ipiv, int *ipiv2, double *b, int ldb)
     * }
     */
    public static int LAPACKE_dsytrs_aa_2stage(int matrix_layout, byte uplo, int n, int nrhs, MemorySegment a, int lda, MemorySegment tb, int ltb, MemorySegment ipiv, MemorySegment ipiv2, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_dsytrs_aa_2stage.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dsytrs_aa_2stage", matrix_layout, uplo, n, nrhs, a, lda, tb, ltb, ipiv, ipiv2, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, nrhs, a, lda, tb, ltb, ipiv, ipiv2, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dsytrs_aa_2stage_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_dsytrs_aa_2stage_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dsytrs_aa_2stage_work(int matrix_layout, char uplo, int n, int nrhs, double *a, int lda, double *tb, int ltb, int *ipiv, int *ipiv2, double *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_dsytrs_aa_2stage_work$descriptor() {
        return LAPACKE_dsytrs_aa_2stage_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dsytrs_aa_2stage_work(int matrix_layout, char uplo, int n, int nrhs, double *a, int lda, double *tb, int ltb, int *ipiv, int *ipiv2, double *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_dsytrs_aa_2stage_work$handle() {
        return LAPACKE_dsytrs_aa_2stage_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dsytrs_aa_2stage_work(int matrix_layout, char uplo, int n, int nrhs, double *a, int lda, double *tb, int ltb, int *ipiv, int *ipiv2, double *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_dsytrs_aa_2stage_work$address() {
        return LAPACKE_dsytrs_aa_2stage_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dsytrs_aa_2stage_work(int matrix_layout, char uplo, int n, int nrhs, double *a, int lda, double *tb, int ltb, int *ipiv, int *ipiv2, double *b, int ldb)
     * }
     */
    public static int LAPACKE_dsytrs_aa_2stage_work(int matrix_layout, byte uplo, int n, int nrhs, MemorySegment a, int lda, MemorySegment tb, int ltb, MemorySegment ipiv, MemorySegment ipiv2, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_dsytrs_aa_2stage_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dsytrs_aa_2stage_work", matrix_layout, uplo, n, nrhs, a, lda, tb, ltb, ipiv, ipiv2, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, nrhs, a, lda, tb, ltb, ipiv, ipiv2, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_csytrs_aa_2stage {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_csytrs_aa_2stage");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_csytrs_aa_2stage(int matrix_layout, char uplo, int n, int nrhs, _Complex float *a, int lda, _Complex float *tb, int ltb, int *ipiv, int *ipiv2, _Complex float *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_csytrs_aa_2stage$descriptor() {
        return LAPACKE_csytrs_aa_2stage.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_csytrs_aa_2stage(int matrix_layout, char uplo, int n, int nrhs, _Complex float *a, int lda, _Complex float *tb, int ltb, int *ipiv, int *ipiv2, _Complex float *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_csytrs_aa_2stage$handle() {
        return LAPACKE_csytrs_aa_2stage.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_csytrs_aa_2stage(int matrix_layout, char uplo, int n, int nrhs, _Complex float *a, int lda, _Complex float *tb, int ltb, int *ipiv, int *ipiv2, _Complex float *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_csytrs_aa_2stage$address() {
        return LAPACKE_csytrs_aa_2stage.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_csytrs_aa_2stage(int matrix_layout, char uplo, int n, int nrhs, _Complex float *a, int lda, _Complex float *tb, int ltb, int *ipiv, int *ipiv2, _Complex float *b, int ldb)
     * }
     */
    public static int LAPACKE_csytrs_aa_2stage(int matrix_layout, byte uplo, int n, int nrhs, MemorySegment a, int lda, MemorySegment tb, int ltb, MemorySegment ipiv, MemorySegment ipiv2, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_csytrs_aa_2stage.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_csytrs_aa_2stage", matrix_layout, uplo, n, nrhs, a, lda, tb, ltb, ipiv, ipiv2, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, nrhs, a, lda, tb, ltb, ipiv, ipiv2, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_csytrs_aa_2stage_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_csytrs_aa_2stage_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_csytrs_aa_2stage_work(int matrix_layout, char uplo, int n, int nrhs, _Complex float *a, int lda, _Complex float *tb, int ltb, int *ipiv, int *ipiv2, _Complex float *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_csytrs_aa_2stage_work$descriptor() {
        return LAPACKE_csytrs_aa_2stage_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_csytrs_aa_2stage_work(int matrix_layout, char uplo, int n, int nrhs, _Complex float *a, int lda, _Complex float *tb, int ltb, int *ipiv, int *ipiv2, _Complex float *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_csytrs_aa_2stage_work$handle() {
        return LAPACKE_csytrs_aa_2stage_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_csytrs_aa_2stage_work(int matrix_layout, char uplo, int n, int nrhs, _Complex float *a, int lda, _Complex float *tb, int ltb, int *ipiv, int *ipiv2, _Complex float *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_csytrs_aa_2stage_work$address() {
        return LAPACKE_csytrs_aa_2stage_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_csytrs_aa_2stage_work(int matrix_layout, char uplo, int n, int nrhs, _Complex float *a, int lda, _Complex float *tb, int ltb, int *ipiv, int *ipiv2, _Complex float *b, int ldb)
     * }
     */
    public static int LAPACKE_csytrs_aa_2stage_work(int matrix_layout, byte uplo, int n, int nrhs, MemorySegment a, int lda, MemorySegment tb, int ltb, MemorySegment ipiv, MemorySegment ipiv2, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_csytrs_aa_2stage_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_csytrs_aa_2stage_work", matrix_layout, uplo, n, nrhs, a, lda, tb, ltb, ipiv, ipiv2, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, nrhs, a, lda, tb, ltb, ipiv, ipiv2, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zsytrs_aa_2stage {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zsytrs_aa_2stage");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zsytrs_aa_2stage(int matrix_layout, char uplo, int n, int nrhs, _Complex double *a, int lda, _Complex double *tb, int ltb, int *ipiv, int *ipiv2, _Complex double *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_zsytrs_aa_2stage$descriptor() {
        return LAPACKE_zsytrs_aa_2stage.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zsytrs_aa_2stage(int matrix_layout, char uplo, int n, int nrhs, _Complex double *a, int lda, _Complex double *tb, int ltb, int *ipiv, int *ipiv2, _Complex double *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_zsytrs_aa_2stage$handle() {
        return LAPACKE_zsytrs_aa_2stage.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zsytrs_aa_2stage(int matrix_layout, char uplo, int n, int nrhs, _Complex double *a, int lda, _Complex double *tb, int ltb, int *ipiv, int *ipiv2, _Complex double *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_zsytrs_aa_2stage$address() {
        return LAPACKE_zsytrs_aa_2stage.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zsytrs_aa_2stage(int matrix_layout, char uplo, int n, int nrhs, _Complex double *a, int lda, _Complex double *tb, int ltb, int *ipiv, int *ipiv2, _Complex double *b, int ldb)
     * }
     */
    public static int LAPACKE_zsytrs_aa_2stage(int matrix_layout, byte uplo, int n, int nrhs, MemorySegment a, int lda, MemorySegment tb, int ltb, MemorySegment ipiv, MemorySegment ipiv2, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_zsytrs_aa_2stage.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zsytrs_aa_2stage", matrix_layout, uplo, n, nrhs, a, lda, tb, ltb, ipiv, ipiv2, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, nrhs, a, lda, tb, ltb, ipiv, ipiv2, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zsytrs_aa_2stage_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zsytrs_aa_2stage_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zsytrs_aa_2stage_work(int matrix_layout, char uplo, int n, int nrhs, _Complex double *a, int lda, _Complex double *tb, int ltb, int *ipiv, int *ipiv2, _Complex double *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_zsytrs_aa_2stage_work$descriptor() {
        return LAPACKE_zsytrs_aa_2stage_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zsytrs_aa_2stage_work(int matrix_layout, char uplo, int n, int nrhs, _Complex double *a, int lda, _Complex double *tb, int ltb, int *ipiv, int *ipiv2, _Complex double *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_zsytrs_aa_2stage_work$handle() {
        return LAPACKE_zsytrs_aa_2stage_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zsytrs_aa_2stage_work(int matrix_layout, char uplo, int n, int nrhs, _Complex double *a, int lda, _Complex double *tb, int ltb, int *ipiv, int *ipiv2, _Complex double *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_zsytrs_aa_2stage_work$address() {
        return LAPACKE_zsytrs_aa_2stage_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zsytrs_aa_2stage_work(int matrix_layout, char uplo, int n, int nrhs, _Complex double *a, int lda, _Complex double *tb, int ltb, int *ipiv, int *ipiv2, _Complex double *b, int ldb)
     * }
     */
    public static int LAPACKE_zsytrs_aa_2stage_work(int matrix_layout, byte uplo, int n, int nrhs, MemorySegment a, int lda, MemorySegment tb, int ltb, MemorySegment ipiv, MemorySegment ipiv2, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_zsytrs_aa_2stage_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zsytrs_aa_2stage_work", matrix_layout, uplo, n, nrhs, a, lda, tb, ltb, ipiv, ipiv2, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, nrhs, a, lda, tb, ltb, ipiv, ipiv2, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_chetrs_aa_2stage {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_chetrs_aa_2stage");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_chetrs_aa_2stage(int matrix_layout, char uplo, int n, int nrhs, _Complex float *a, int lda, _Complex float *tb, int ltb, int *ipiv, int *ipiv2, _Complex float *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_chetrs_aa_2stage$descriptor() {
        return LAPACKE_chetrs_aa_2stage.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_chetrs_aa_2stage(int matrix_layout, char uplo, int n, int nrhs, _Complex float *a, int lda, _Complex float *tb, int ltb, int *ipiv, int *ipiv2, _Complex float *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_chetrs_aa_2stage$handle() {
        return LAPACKE_chetrs_aa_2stage.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_chetrs_aa_2stage(int matrix_layout, char uplo, int n, int nrhs, _Complex float *a, int lda, _Complex float *tb, int ltb, int *ipiv, int *ipiv2, _Complex float *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_chetrs_aa_2stage$address() {
        return LAPACKE_chetrs_aa_2stage.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_chetrs_aa_2stage(int matrix_layout, char uplo, int n, int nrhs, _Complex float *a, int lda, _Complex float *tb, int ltb, int *ipiv, int *ipiv2, _Complex float *b, int ldb)
     * }
     */
    public static int LAPACKE_chetrs_aa_2stage(int matrix_layout, byte uplo, int n, int nrhs, MemorySegment a, int lda, MemorySegment tb, int ltb, MemorySegment ipiv, MemorySegment ipiv2, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_chetrs_aa_2stage.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_chetrs_aa_2stage", matrix_layout, uplo, n, nrhs, a, lda, tb, ltb, ipiv, ipiv2, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, nrhs, a, lda, tb, ltb, ipiv, ipiv2, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_chetrs_aa_2stage_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_chetrs_aa_2stage_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_chetrs_aa_2stage_work(int matrix_layout, char uplo, int n, int nrhs, _Complex float *a, int lda, _Complex float *tb, int ltb, int *ipiv, int *ipiv2, _Complex float *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_chetrs_aa_2stage_work$descriptor() {
        return LAPACKE_chetrs_aa_2stage_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_chetrs_aa_2stage_work(int matrix_layout, char uplo, int n, int nrhs, _Complex float *a, int lda, _Complex float *tb, int ltb, int *ipiv, int *ipiv2, _Complex float *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_chetrs_aa_2stage_work$handle() {
        return LAPACKE_chetrs_aa_2stage_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_chetrs_aa_2stage_work(int matrix_layout, char uplo, int n, int nrhs, _Complex float *a, int lda, _Complex float *tb, int ltb, int *ipiv, int *ipiv2, _Complex float *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_chetrs_aa_2stage_work$address() {
        return LAPACKE_chetrs_aa_2stage_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_chetrs_aa_2stage_work(int matrix_layout, char uplo, int n, int nrhs, _Complex float *a, int lda, _Complex float *tb, int ltb, int *ipiv, int *ipiv2, _Complex float *b, int ldb)
     * }
     */
    public static int LAPACKE_chetrs_aa_2stage_work(int matrix_layout, byte uplo, int n, int nrhs, MemorySegment a, int lda, MemorySegment tb, int ltb, MemorySegment ipiv, MemorySegment ipiv2, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_chetrs_aa_2stage_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_chetrs_aa_2stage_work", matrix_layout, uplo, n, nrhs, a, lda, tb, ltb, ipiv, ipiv2, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, nrhs, a, lda, tb, ltb, ipiv, ipiv2, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zhetrs_aa_2stage {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zhetrs_aa_2stage");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zhetrs_aa_2stage(int matrix_layout, char uplo, int n, int nrhs, _Complex double *a, int lda, _Complex double *tb, int ltb, int *ipiv, int *ipiv2, _Complex double *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_zhetrs_aa_2stage$descriptor() {
        return LAPACKE_zhetrs_aa_2stage.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zhetrs_aa_2stage(int matrix_layout, char uplo, int n, int nrhs, _Complex double *a, int lda, _Complex double *tb, int ltb, int *ipiv, int *ipiv2, _Complex double *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_zhetrs_aa_2stage$handle() {
        return LAPACKE_zhetrs_aa_2stage.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zhetrs_aa_2stage(int matrix_layout, char uplo, int n, int nrhs, _Complex double *a, int lda, _Complex double *tb, int ltb, int *ipiv, int *ipiv2, _Complex double *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_zhetrs_aa_2stage$address() {
        return LAPACKE_zhetrs_aa_2stage.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zhetrs_aa_2stage(int matrix_layout, char uplo, int n, int nrhs, _Complex double *a, int lda, _Complex double *tb, int ltb, int *ipiv, int *ipiv2, _Complex double *b, int ldb)
     * }
     */
    public static int LAPACKE_zhetrs_aa_2stage(int matrix_layout, byte uplo, int n, int nrhs, MemorySegment a, int lda, MemorySegment tb, int ltb, MemorySegment ipiv, MemorySegment ipiv2, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_zhetrs_aa_2stage.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zhetrs_aa_2stage", matrix_layout, uplo, n, nrhs, a, lda, tb, ltb, ipiv, ipiv2, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, nrhs, a, lda, tb, ltb, ipiv, ipiv2, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zhetrs_aa_2stage_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_CHAR,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_POINTER,
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_zhetrs_aa_2stage_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zhetrs_aa_2stage_work(int matrix_layout, char uplo, int n, int nrhs, _Complex double *a, int lda, _Complex double *tb, int ltb, int *ipiv, int *ipiv2, _Complex double *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_zhetrs_aa_2stage_work$descriptor() {
        return LAPACKE_zhetrs_aa_2stage_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zhetrs_aa_2stage_work(int matrix_layout, char uplo, int n, int nrhs, _Complex double *a, int lda, _Complex double *tb, int ltb, int *ipiv, int *ipiv2, _Complex double *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_zhetrs_aa_2stage_work$handle() {
        return LAPACKE_zhetrs_aa_2stage_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zhetrs_aa_2stage_work(int matrix_layout, char uplo, int n, int nrhs, _Complex double *a, int lda, _Complex double *tb, int ltb, int *ipiv, int *ipiv2, _Complex double *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_zhetrs_aa_2stage_work$address() {
        return LAPACKE_zhetrs_aa_2stage_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zhetrs_aa_2stage_work(int matrix_layout, char uplo, int n, int nrhs, _Complex double *a, int lda, _Complex double *tb, int ltb, int *ipiv, int *ipiv2, _Complex double *b, int ldb)
     * }
     */
    public static int LAPACKE_zhetrs_aa_2stage_work(int matrix_layout, byte uplo, int n, int nrhs, MemorySegment a, int lda, MemorySegment tb, int ltb, MemorySegment ipiv, MemorySegment ipiv2, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_zhetrs_aa_2stage_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zhetrs_aa_2stage_work", matrix_layout, uplo, n, nrhs, a, lda, tb, ltb, ipiv, ipiv2, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, nrhs, a, lda, tb, ltb, ipiv, ipiv2, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_set_nancheck {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            cblas_openblas_h.C_INT
        );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_set_nancheck");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void LAPACKE_set_nancheck(int flag)
     * }
     */
    public static FunctionDescriptor LAPACKE_set_nancheck$descriptor() {
        return LAPACKE_set_nancheck.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void LAPACKE_set_nancheck(int flag)
     * }
     */
    public static MethodHandle LAPACKE_set_nancheck$handle() {
        return LAPACKE_set_nancheck.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void LAPACKE_set_nancheck(int flag)
     * }
     */
    public static MemorySegment LAPACKE_set_nancheck$address() {
        return LAPACKE_set_nancheck.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void LAPACKE_set_nancheck(int flag)
     * }
     */
    public static void LAPACKE_set_nancheck(int flag) {
        var mh$ = LAPACKE_set_nancheck.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_set_nancheck", flag);
            }
            mh$.invokeExact(flag);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_get_nancheck {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            cblas_openblas_h.C_INT    );

        public static final MemorySegment ADDR = cblas_openblas_h.findOrThrow("LAPACKE_get_nancheck");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_get_nancheck()
     * }
     */
    public static FunctionDescriptor LAPACKE_get_nancheck$descriptor() {
        return LAPACKE_get_nancheck.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_get_nancheck()
     * }
     */
    public static MethodHandle LAPACKE_get_nancheck$handle() {
        return LAPACKE_get_nancheck.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_get_nancheck()
     * }
     */
    public static MemorySegment LAPACKE_get_nancheck$address() {
        return LAPACKE_get_nancheck.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_get_nancheck()
     * }
     */
    public static int LAPACKE_get_nancheck() {
        var mh$ = LAPACKE_get_nancheck.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_get_nancheck");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final MemorySegment NULL = MemorySegment.ofAddress(0L);
    /**
     * {@snippet lang=c :
     * #define NULL (void*) 0
     * }
     */
    public static MemorySegment NULL() {
        return NULL;
    }
    /**
     * {@snippet lang=c :
     * #define OPENBLAS_CHAR_CORENAME "generic"
     * }
     */
    public static MemorySegment OPENBLAS_CHAR_CORENAME() {
        class Holder {
            static final MemorySegment OPENBLAS_CHAR_CORENAME
                = cblas_openblas_h.LIBRARY_ARENA.allocateFrom("generic");
        }
        return Holder.OPENBLAS_CHAR_CORENAME;
    }
    /**
     * {@snippet lang=c :
     * #define OPENBLAS_VERSION " OpenBLAS 0.3.20 "
     * }
     */
    public static MemorySegment OPENBLAS_VERSION() {
        class Holder {
            static final MemorySegment OPENBLAS_VERSION
                = cblas_openblas_h.LIBRARY_ARENA.allocateFrom(" OpenBLAS 0.3.20 ");
        }
        return Holder.OPENBLAS_VERSION;
    }
    private static final long _POSIX_C_SOURCE = 200809L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_C_SOURCE 200809
     * }
     */
    public static long _POSIX_C_SOURCE() {
        return _POSIX_C_SOURCE;
    }
    private static final int __TIMESIZE = (int)64L;
    /**
     * {@snippet lang=c :
     * #define __TIMESIZE 64
     * }
     */
    public static int __TIMESIZE() {
        return __TIMESIZE;
    }
    private static final long __STDC_IEC_60559_BFP__ = 201404L;
    /**
     * {@snippet lang=c :
     * #define __STDC_IEC_60559_BFP__ 201404
     * }
     */
    public static long __STDC_IEC_60559_BFP__() {
        return __STDC_IEC_60559_BFP__;
    }
    private static final long __STDC_IEC_60559_COMPLEX__ = 201404L;
    /**
     * {@snippet lang=c :
     * #define __STDC_IEC_60559_COMPLEX__ 201404
     * }
     */
    public static long __STDC_IEC_60559_COMPLEX__() {
        return __STDC_IEC_60559_COMPLEX__;
    }
    private static final long __STDC_ISO_10646__ = 201706L;
    /**
     * {@snippet lang=c :
     * #define __STDC_ISO_10646__ 201706
     * }
     */
    public static long __STDC_ISO_10646__() {
        return __STDC_ISO_10646__;
    }
    private static final int __WCHAR_MAX = (int)2147483647L;
    /**
     * {@snippet lang=c :
     * #define __WCHAR_MAX 2147483647
     * }
     */
    public static int __WCHAR_MAX() {
        return __WCHAR_MAX;
    }
    private static final int __WCHAR_MIN = (int)-2147483648L;
    /**
     * {@snippet lang=c :
     * #define __WCHAR_MIN -2147483648
     * }
     */
    public static int __WCHAR_MIN() {
        return __WCHAR_MIN;
    }
    private static final int INT8_MIN = (int)-128L;
    /**
     * {@snippet lang=c :
     * #define INT8_MIN -128
     * }
     */
    public static int INT8_MIN() {
        return INT8_MIN;
    }
    private static final int INT16_MIN = (int)-32768L;
    /**
     * {@snippet lang=c :
     * #define INT16_MIN -32768
     * }
     */
    public static int INT16_MIN() {
        return INT16_MIN;
    }
    private static final int INT32_MIN = (int)-2147483648L;
    /**
     * {@snippet lang=c :
     * #define INT32_MIN -2147483648
     * }
     */
    public static int INT32_MIN() {
        return INT32_MIN;
    }
    private static final long INT64_MIN = -9223372036854775808L;
    /**
     * {@snippet lang=c :
     * #define INT64_MIN -9223372036854775808
     * }
     */
    public static long INT64_MIN() {
        return INT64_MIN;
    }
    private static final int INT8_MAX = (int)127L;
    /**
     * {@snippet lang=c :
     * #define INT8_MAX 127
     * }
     */
    public static int INT8_MAX() {
        return INT8_MAX;
    }
    private static final int INT16_MAX = (int)32767L;
    /**
     * {@snippet lang=c :
     * #define INT16_MAX 32767
     * }
     */
    public static int INT16_MAX() {
        return INT16_MAX;
    }
    private static final int INT32_MAX = (int)2147483647L;
    /**
     * {@snippet lang=c :
     * #define INT32_MAX 2147483647
     * }
     */
    public static int INT32_MAX() {
        return INT32_MAX;
    }
    private static final long INT64_MAX = 9223372036854775807L;
    /**
     * {@snippet lang=c :
     * #define INT64_MAX 9223372036854775807
     * }
     */
    public static long INT64_MAX() {
        return INT64_MAX;
    }
    private static final int UINT8_MAX = (int)255L;
    /**
     * {@snippet lang=c :
     * #define UINT8_MAX 255
     * }
     */
    public static int UINT8_MAX() {
        return UINT8_MAX;
    }
    private static final int UINT16_MAX = (int)65535L;
    /**
     * {@snippet lang=c :
     * #define UINT16_MAX 65535
     * }
     */
    public static int UINT16_MAX() {
        return UINT16_MAX;
    }
    private static final int UINT32_MAX = (int)4294967295L;
    /**
     * {@snippet lang=c :
     * #define UINT32_MAX 4294967295
     * }
     */
    public static int UINT32_MAX() {
        return UINT32_MAX;
    }
    private static final long UINT64_MAX = -1L;
    /**
     * {@snippet lang=c :
     * #define UINT64_MAX -1
     * }
     */
    public static long UINT64_MAX() {
        return UINT64_MAX;
    }
    private static final int INT_LEAST8_MIN = (int)-128L;
    /**
     * {@snippet lang=c :
     * #define INT_LEAST8_MIN -128
     * }
     */
    public static int INT_LEAST8_MIN() {
        return INT_LEAST8_MIN;
    }
    private static final int INT_LEAST16_MIN = (int)-32768L;
    /**
     * {@snippet lang=c :
     * #define INT_LEAST16_MIN -32768
     * }
     */
    public static int INT_LEAST16_MIN() {
        return INT_LEAST16_MIN;
    }
    private static final int INT_LEAST32_MIN = (int)-2147483648L;
    /**
     * {@snippet lang=c :
     * #define INT_LEAST32_MIN -2147483648
     * }
     */
    public static int INT_LEAST32_MIN() {
        return INT_LEAST32_MIN;
    }
    private static final long INT_LEAST64_MIN = -9223372036854775808L;
    /**
     * {@snippet lang=c :
     * #define INT_LEAST64_MIN -9223372036854775808
     * }
     */
    public static long INT_LEAST64_MIN() {
        return INT_LEAST64_MIN;
    }
    private static final int INT_LEAST8_MAX = (int)127L;
    /**
     * {@snippet lang=c :
     * #define INT_LEAST8_MAX 127
     * }
     */
    public static int INT_LEAST8_MAX() {
        return INT_LEAST8_MAX;
    }
    private static final int INT_LEAST16_MAX = (int)32767L;
    /**
     * {@snippet lang=c :
     * #define INT_LEAST16_MAX 32767
     * }
     */
    public static int INT_LEAST16_MAX() {
        return INT_LEAST16_MAX;
    }
    private static final int INT_LEAST32_MAX = (int)2147483647L;
    /**
     * {@snippet lang=c :
     * #define INT_LEAST32_MAX 2147483647
     * }
     */
    public static int INT_LEAST32_MAX() {
        return INT_LEAST32_MAX;
    }
    private static final long INT_LEAST64_MAX = 9223372036854775807L;
    /**
     * {@snippet lang=c :
     * #define INT_LEAST64_MAX 9223372036854775807
     * }
     */
    public static long INT_LEAST64_MAX() {
        return INT_LEAST64_MAX;
    }
    private static final int UINT_LEAST8_MAX = (int)255L;
    /**
     * {@snippet lang=c :
     * #define UINT_LEAST8_MAX 255
     * }
     */
    public static int UINT_LEAST8_MAX() {
        return UINT_LEAST8_MAX;
    }
    private static final int UINT_LEAST16_MAX = (int)65535L;
    /**
     * {@snippet lang=c :
     * #define UINT_LEAST16_MAX 65535
     * }
     */
    public static int UINT_LEAST16_MAX() {
        return UINT_LEAST16_MAX;
    }
    private static final int UINT_LEAST32_MAX = (int)4294967295L;
    /**
     * {@snippet lang=c :
     * #define UINT_LEAST32_MAX 4294967295
     * }
     */
    public static int UINT_LEAST32_MAX() {
        return UINT_LEAST32_MAX;
    }
    private static final long UINT_LEAST64_MAX = -1L;
    /**
     * {@snippet lang=c :
     * #define UINT_LEAST64_MAX -1
     * }
     */
    public static long UINT_LEAST64_MAX() {
        return UINT_LEAST64_MAX;
    }
    private static final int INT_FAST8_MIN = (int)-128L;
    /**
     * {@snippet lang=c :
     * #define INT_FAST8_MIN -128
     * }
     */
    public static int INT_FAST8_MIN() {
        return INT_FAST8_MIN;
    }
    private static final long INT_FAST16_MIN = -9223372036854775808L;
    /**
     * {@snippet lang=c :
     * #define INT_FAST16_MIN -9223372036854775808
     * }
     */
    public static long INT_FAST16_MIN() {
        return INT_FAST16_MIN;
    }
    private static final long INT_FAST32_MIN = -9223372036854775808L;
    /**
     * {@snippet lang=c :
     * #define INT_FAST32_MIN -9223372036854775808
     * }
     */
    public static long INT_FAST32_MIN() {
        return INT_FAST32_MIN;
    }
    private static final long INT_FAST64_MIN = -9223372036854775808L;
    /**
     * {@snippet lang=c :
     * #define INT_FAST64_MIN -9223372036854775808
     * }
     */
    public static long INT_FAST64_MIN() {
        return INT_FAST64_MIN;
    }
    private static final int INT_FAST8_MAX = (int)127L;
    /**
     * {@snippet lang=c :
     * #define INT_FAST8_MAX 127
     * }
     */
    public static int INT_FAST8_MAX() {
        return INT_FAST8_MAX;
    }
    private static final long INT_FAST16_MAX = 9223372036854775807L;
    /**
     * {@snippet lang=c :
     * #define INT_FAST16_MAX 9223372036854775807
     * }
     */
    public static long INT_FAST16_MAX() {
        return INT_FAST16_MAX;
    }
    private static final long INT_FAST32_MAX = 9223372036854775807L;
    /**
     * {@snippet lang=c :
     * #define INT_FAST32_MAX 9223372036854775807
     * }
     */
    public static long INT_FAST32_MAX() {
        return INT_FAST32_MAX;
    }
    private static final long INT_FAST64_MAX = 9223372036854775807L;
    /**
     * {@snippet lang=c :
     * #define INT_FAST64_MAX 9223372036854775807
     * }
     */
    public static long INT_FAST64_MAX() {
        return INT_FAST64_MAX;
    }
    private static final int UINT_FAST8_MAX = (int)255L;
    /**
     * {@snippet lang=c :
     * #define UINT_FAST8_MAX 255
     * }
     */
    public static int UINT_FAST8_MAX() {
        return UINT_FAST8_MAX;
    }
    private static final long UINT_FAST16_MAX = -1L;
    /**
     * {@snippet lang=c :
     * #define UINT_FAST16_MAX -1
     * }
     */
    public static long UINT_FAST16_MAX() {
        return UINT_FAST16_MAX;
    }
    private static final long UINT_FAST32_MAX = -1L;
    /**
     * {@snippet lang=c :
     * #define UINT_FAST32_MAX -1
     * }
     */
    public static long UINT_FAST32_MAX() {
        return UINT_FAST32_MAX;
    }
    private static final long UINT_FAST64_MAX = -1L;
    /**
     * {@snippet lang=c :
     * #define UINT_FAST64_MAX -1
     * }
     */
    public static long UINT_FAST64_MAX() {
        return UINT_FAST64_MAX;
    }
    private static final long INTPTR_MIN = -9223372036854775808L;
    /**
     * {@snippet lang=c :
     * #define INTPTR_MIN -9223372036854775808
     * }
     */
    public static long INTPTR_MIN() {
        return INTPTR_MIN;
    }
    private static final long INTPTR_MAX = 9223372036854775807L;
    /**
     * {@snippet lang=c :
     * #define INTPTR_MAX 9223372036854775807
     * }
     */
    public static long INTPTR_MAX() {
        return INTPTR_MAX;
    }
    private static final long UINTPTR_MAX = -1L;
    /**
     * {@snippet lang=c :
     * #define UINTPTR_MAX -1
     * }
     */
    public static long UINTPTR_MAX() {
        return UINTPTR_MAX;
    }
    private static final long INTMAX_MIN = -9223372036854775808L;
    /**
     * {@snippet lang=c :
     * #define INTMAX_MIN -9223372036854775808
     * }
     */
    public static long INTMAX_MIN() {
        return INTMAX_MIN;
    }
    private static final long INTMAX_MAX = 9223372036854775807L;
    /**
     * {@snippet lang=c :
     * #define INTMAX_MAX 9223372036854775807
     * }
     */
    public static long INTMAX_MAX() {
        return INTMAX_MAX;
    }
    private static final long UINTMAX_MAX = -1L;
    /**
     * {@snippet lang=c :
     * #define UINTMAX_MAX -1
     * }
     */
    public static long UINTMAX_MAX() {
        return UINTMAX_MAX;
    }
    private static final long PTRDIFF_MIN = -9223372036854775808L;
    /**
     * {@snippet lang=c :
     * #define PTRDIFF_MIN -9223372036854775808
     * }
     */
    public static long PTRDIFF_MIN() {
        return PTRDIFF_MIN;
    }
    private static final long PTRDIFF_MAX = 9223372036854775807L;
    /**
     * {@snippet lang=c :
     * #define PTRDIFF_MAX 9223372036854775807
     * }
     */
    public static long PTRDIFF_MAX() {
        return PTRDIFF_MAX;
    }
    private static final int SIG_ATOMIC_MIN = (int)-2147483648L;
    /**
     * {@snippet lang=c :
     * #define SIG_ATOMIC_MIN -2147483648
     * }
     */
    public static int SIG_ATOMIC_MIN() {
        return SIG_ATOMIC_MIN;
    }
    private static final int SIG_ATOMIC_MAX = (int)2147483647L;
    /**
     * {@snippet lang=c :
     * #define SIG_ATOMIC_MAX 2147483647
     * }
     */
    public static int SIG_ATOMIC_MAX() {
        return SIG_ATOMIC_MAX;
    }
    private static final long SIZE_MAX = -1L;
    /**
     * {@snippet lang=c :
     * #define SIZE_MAX -1
     * }
     */
    public static long SIZE_MAX() {
        return SIZE_MAX;
    }
    private static final int WCHAR_MIN = (int)-2147483648L;
    /**
     * {@snippet lang=c :
     * #define WCHAR_MIN -2147483648
     * }
     */
    public static int WCHAR_MIN() {
        return WCHAR_MIN;
    }
    private static final int WCHAR_MAX = (int)2147483647L;
    /**
     * {@snippet lang=c :
     * #define WCHAR_MAX 2147483647
     * }
     */
    public static int WCHAR_MAX() {
        return WCHAR_MAX;
    }
    private static final int WINT_MIN = (int)0L;
    /**
     * {@snippet lang=c :
     * #define WINT_MIN 0
     * }
     */
    public static int WINT_MIN() {
        return WINT_MIN;
    }
    private static final int WINT_MAX = (int)4294967295L;
    /**
     * {@snippet lang=c :
     * #define WINT_MAX 4294967295
     * }
     */
    public static int WINT_MAX() {
        return WINT_MAX;
    }
    private static final int EOF = (int)-1L;
    /**
     * {@snippet lang=c :
     * #define EOF -1
     * }
     */
    public static int EOF() {
        return EOF;
    }
    /**
     * {@snippet lang=c :
     * #define P_tmpdir "/tmp"
     * }
     */
    public static MemorySegment P_tmpdir() {
        class Holder {
            static final MemorySegment P_tmpdir
                = cblas_openblas_h.LIBRARY_ARENA.allocateFrom("/tmp");
        }
        return Holder.P_tmpdir;
    }
    private static final int __HAVE_DISTINCT_FLOAT16 = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __HAVE_DISTINCT_FLOAT16 0
     * }
     */
    public static int __HAVE_DISTINCT_FLOAT16() {
        return __HAVE_DISTINCT_FLOAT16;
    }
    private static final int __HAVE_DISTINCT_FLOAT128X = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __HAVE_DISTINCT_FLOAT128X 0
     * }
     */
    public static int __HAVE_DISTINCT_FLOAT128X() {
        return __HAVE_DISTINCT_FLOAT128X;
    }
    private static final int __HAVE_FLOAT128_UNLIKE_LDBL = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __HAVE_FLOAT128_UNLIKE_LDBL 0
     * }
     */
    public static int __HAVE_FLOAT128_UNLIKE_LDBL() {
        return __HAVE_FLOAT128_UNLIKE_LDBL;
    }
    private static final float _Complex_I = 0f;
    /**
     * {@snippet lang=c :
     * #define _Complex_I 0
     * }
     */
    public static float _Complex_I() {
        return _Complex_I;
    }
    private static final float I = 0f;
    /**
     * {@snippet lang=c :
     * #define I 0
     * }
     */
    public static float I() {
        return I;
    }
    private static final int __BYTE_ORDER = (int)1234L;
    /**
     * {@snippet lang=c :
     * #define __BYTE_ORDER 1234
     * }
     */
    public static int __BYTE_ORDER() {
        return __BYTE_ORDER;
    }
    private static final int __FLOAT_WORD_ORDER = (int)1234L;
    /**
     * {@snippet lang=c :
     * #define __FLOAT_WORD_ORDER 1234
     * }
     */
    public static int __FLOAT_WORD_ORDER() {
        return __FLOAT_WORD_ORDER;
    }
    private static final long __NCPUBITS = 64L;
    /**
     * {@snippet lang=c :
     * #define __NCPUBITS 64
     * }
     */
    public static long __NCPUBITS() {
        return __NCPUBITS;
    }
    private static final int __WCLONE = (int)2147483648L;
    /**
     * {@snippet lang=c :
     * #define __WCLONE 2147483648
     * }
     */
    public static int __WCLONE() {
        return __WCLONE;
    }
    private static final int LITTLE_ENDIAN = (int)1234L;
    /**
     * {@snippet lang=c :
     * #define LITTLE_ENDIAN 1234
     * }
     */
    public static int LITTLE_ENDIAN() {
        return LITTLE_ENDIAN;
    }
    private static final int BIG_ENDIAN = (int)4321L;
    /**
     * {@snippet lang=c :
     * #define BIG_ENDIAN 4321
     * }
     */
    public static int BIG_ENDIAN() {
        return BIG_ENDIAN;
    }
    private static final int PDP_ENDIAN = (int)3412L;
    /**
     * {@snippet lang=c :
     * #define PDP_ENDIAN 3412
     * }
     */
    public static int PDP_ENDIAN() {
        return PDP_ENDIAN;
    }
    private static final int BYTE_ORDER = (int)1234L;
    /**
     * {@snippet lang=c :
     * #define BYTE_ORDER 1234
     * }
     */
    public static int BYTE_ORDER() {
        return BYTE_ORDER;
    }
    private static final long _SIGSET_NWORDS = 16L;
    /**
     * {@snippet lang=c :
     * #define _SIGSET_NWORDS 16
     * }
     */
    public static long _SIGSET_NWORDS() {
        return _SIGSET_NWORDS;
    }
    private static final int __NFDBITS = (int)64L;
    /**
     * {@snippet lang=c :
     * #define __NFDBITS 64
     * }
     */
    public static int __NFDBITS() {
        return __NFDBITS;
    }
    private static final int FD_SETSIZE = (int)1024L;
    /**
     * {@snippet lang=c :
     * #define FD_SETSIZE 1024
     * }
     */
    public static int FD_SETSIZE() {
        return FD_SETSIZE;
    }
    private static final int NFDBITS = (int)64L;
    /**
     * {@snippet lang=c :
     * #define NFDBITS 64
     * }
     */
    public static int NFDBITS() {
        return NFDBITS;
    }
    private static final int __PTHREAD_RWLOCK_ELISION_EXTRA = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __PTHREAD_RWLOCK_ELISION_EXTRA 0
     * }
     */
    public static int __PTHREAD_RWLOCK_ELISION_EXTRA() {
        return __PTHREAD_RWLOCK_ELISION_EXTRA;
    }
    private static final int LAPACK_WORK_MEMORY_ERROR = (int)-1010L;
    /**
     * {@snippet lang=c :
     * #define LAPACK_WORK_MEMORY_ERROR -1010
     * }
     */
    public static int LAPACK_WORK_MEMORY_ERROR() {
        return LAPACK_WORK_MEMORY_ERROR;
    }
    private static final int LAPACK_TRANSPOSE_MEMORY_ERROR = (int)-1011L;
    /**
     * {@snippet lang=c :
     * #define LAPACK_TRANSPOSE_MEMORY_ERROR -1011
     * }
     */
    public static int LAPACK_TRANSPOSE_MEMORY_ERROR() {
        return LAPACK_TRANSPOSE_MEMORY_ERROR;
    }
}

