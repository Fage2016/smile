// Generated by jextract

package smile.linalg.lapack;

import java.lang.invoke.*;
import java.lang.foreign.*;
import java.nio.ByteOrder;
import java.util.*;
import java.util.function.*;
import java.util.stream.*;

import static java.lang.foreign.ValueLayout.*;
import static java.lang.foreign.MemoryLayout.PathElement.*;

public class lapacke_h_1 extends lapacke_h_2 {

    lapacke_h_1() {
        // Should not be called directly
    }

    private static class LAPACKE_zgglse_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zgglse_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zgglse_work(int matrix_layout, int m, int n, int p, _Complex double *a, int lda, _Complex double *b, int ldb, _Complex double *c, _Complex double *d, _Complex double *x, _Complex double *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_zgglse_work$descriptor() {
        return LAPACKE_zgglse_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zgglse_work(int matrix_layout, int m, int n, int p, _Complex double *a, int lda, _Complex double *b, int ldb, _Complex double *c, _Complex double *d, _Complex double *x, _Complex double *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_zgglse_work$handle() {
        return LAPACKE_zgglse_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zgglse_work(int matrix_layout, int m, int n, int p, _Complex double *a, int lda, _Complex double *b, int ldb, _Complex double *c, _Complex double *d, _Complex double *x, _Complex double *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_zgglse_work$address() {
        return LAPACKE_zgglse_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zgglse_work(int matrix_layout, int m, int n, int p, _Complex double *a, int lda, _Complex double *b, int ldb, _Complex double *c, _Complex double *d, _Complex double *x, _Complex double *work, int lwork)
     * }
     */
    public static int LAPACKE_zgglse_work(int matrix_layout, int m, int n, int p, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment c, MemorySegment d, MemorySegment x, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_zgglse_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zgglse_work", matrix_layout, m, n, p, a, lda, b, ldb, c, d, x, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, p, a, lda, b, ldb, c, d, x, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sggqrf_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_sggqrf_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sggqrf_work(int matrix_layout, int n, int m, int p, float *a, int lda, float *taua, float *b, int ldb, float *taub, float *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_sggqrf_work$descriptor() {
        return LAPACKE_sggqrf_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sggqrf_work(int matrix_layout, int n, int m, int p, float *a, int lda, float *taua, float *b, int ldb, float *taub, float *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_sggqrf_work$handle() {
        return LAPACKE_sggqrf_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sggqrf_work(int matrix_layout, int n, int m, int p, float *a, int lda, float *taua, float *b, int ldb, float *taub, float *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_sggqrf_work$address() {
        return LAPACKE_sggqrf_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sggqrf_work(int matrix_layout, int n, int m, int p, float *a, int lda, float *taua, float *b, int ldb, float *taub, float *work, int lwork)
     * }
     */
    public static int LAPACKE_sggqrf_work(int matrix_layout, int n, int m, int p, MemorySegment a, int lda, MemorySegment taua, MemorySegment b, int ldb, MemorySegment taub, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_sggqrf_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sggqrf_work", matrix_layout, n, m, p, a, lda, taua, b, ldb, taub, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, n, m, p, a, lda, taua, b, ldb, taub, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dggqrf_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dggqrf_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dggqrf_work(int matrix_layout, int n, int m, int p, double *a, int lda, double *taua, double *b, int ldb, double *taub, double *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_dggqrf_work$descriptor() {
        return LAPACKE_dggqrf_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dggqrf_work(int matrix_layout, int n, int m, int p, double *a, int lda, double *taua, double *b, int ldb, double *taub, double *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_dggqrf_work$handle() {
        return LAPACKE_dggqrf_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dggqrf_work(int matrix_layout, int n, int m, int p, double *a, int lda, double *taua, double *b, int ldb, double *taub, double *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_dggqrf_work$address() {
        return LAPACKE_dggqrf_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dggqrf_work(int matrix_layout, int n, int m, int p, double *a, int lda, double *taua, double *b, int ldb, double *taub, double *work, int lwork)
     * }
     */
    public static int LAPACKE_dggqrf_work(int matrix_layout, int n, int m, int p, MemorySegment a, int lda, MemorySegment taua, MemorySegment b, int ldb, MemorySegment taub, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_dggqrf_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dggqrf_work", matrix_layout, n, m, p, a, lda, taua, b, ldb, taub, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, n, m, p, a, lda, taua, b, ldb, taub, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cggqrf_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_cggqrf_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cggqrf_work(int matrix_layout, int n, int m, int p, _Complex float *a, int lda, _Complex float *taua, _Complex float *b, int ldb, _Complex float *taub, _Complex float *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_cggqrf_work$descriptor() {
        return LAPACKE_cggqrf_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cggqrf_work(int matrix_layout, int n, int m, int p, _Complex float *a, int lda, _Complex float *taua, _Complex float *b, int ldb, _Complex float *taub, _Complex float *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_cggqrf_work$handle() {
        return LAPACKE_cggqrf_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cggqrf_work(int matrix_layout, int n, int m, int p, _Complex float *a, int lda, _Complex float *taua, _Complex float *b, int ldb, _Complex float *taub, _Complex float *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_cggqrf_work$address() {
        return LAPACKE_cggqrf_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cggqrf_work(int matrix_layout, int n, int m, int p, _Complex float *a, int lda, _Complex float *taua, _Complex float *b, int ldb, _Complex float *taub, _Complex float *work, int lwork)
     * }
     */
    public static int LAPACKE_cggqrf_work(int matrix_layout, int n, int m, int p, MemorySegment a, int lda, MemorySegment taua, MemorySegment b, int ldb, MemorySegment taub, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_cggqrf_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cggqrf_work", matrix_layout, n, m, p, a, lda, taua, b, ldb, taub, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, n, m, p, a, lda, taua, b, ldb, taub, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zggqrf_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zggqrf_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zggqrf_work(int matrix_layout, int n, int m, int p, _Complex double *a, int lda, _Complex double *taua, _Complex double *b, int ldb, _Complex double *taub, _Complex double *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_zggqrf_work$descriptor() {
        return LAPACKE_zggqrf_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zggqrf_work(int matrix_layout, int n, int m, int p, _Complex double *a, int lda, _Complex double *taua, _Complex double *b, int ldb, _Complex double *taub, _Complex double *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_zggqrf_work$handle() {
        return LAPACKE_zggqrf_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zggqrf_work(int matrix_layout, int n, int m, int p, _Complex double *a, int lda, _Complex double *taua, _Complex double *b, int ldb, _Complex double *taub, _Complex double *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_zggqrf_work$address() {
        return LAPACKE_zggqrf_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zggqrf_work(int matrix_layout, int n, int m, int p, _Complex double *a, int lda, _Complex double *taua, _Complex double *b, int ldb, _Complex double *taub, _Complex double *work, int lwork)
     * }
     */
    public static int LAPACKE_zggqrf_work(int matrix_layout, int n, int m, int p, MemorySegment a, int lda, MemorySegment taua, MemorySegment b, int ldb, MemorySegment taub, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_zggqrf_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zggqrf_work", matrix_layout, n, m, p, a, lda, taua, b, ldb, taub, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, n, m, p, a, lda, taua, b, ldb, taub, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sggrqf_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_sggrqf_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sggrqf_work(int matrix_layout, int m, int p, int n, float *a, int lda, float *taua, float *b, int ldb, float *taub, float *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_sggrqf_work$descriptor() {
        return LAPACKE_sggrqf_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sggrqf_work(int matrix_layout, int m, int p, int n, float *a, int lda, float *taua, float *b, int ldb, float *taub, float *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_sggrqf_work$handle() {
        return LAPACKE_sggrqf_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sggrqf_work(int matrix_layout, int m, int p, int n, float *a, int lda, float *taua, float *b, int ldb, float *taub, float *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_sggrqf_work$address() {
        return LAPACKE_sggrqf_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sggrqf_work(int matrix_layout, int m, int p, int n, float *a, int lda, float *taua, float *b, int ldb, float *taub, float *work, int lwork)
     * }
     */
    public static int LAPACKE_sggrqf_work(int matrix_layout, int m, int p, int n, MemorySegment a, int lda, MemorySegment taua, MemorySegment b, int ldb, MemorySegment taub, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_sggrqf_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sggrqf_work", matrix_layout, m, p, n, a, lda, taua, b, ldb, taub, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, m, p, n, a, lda, taua, b, ldb, taub, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dggrqf_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dggrqf_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dggrqf_work(int matrix_layout, int m, int p, int n, double *a, int lda, double *taua, double *b, int ldb, double *taub, double *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_dggrqf_work$descriptor() {
        return LAPACKE_dggrqf_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dggrqf_work(int matrix_layout, int m, int p, int n, double *a, int lda, double *taua, double *b, int ldb, double *taub, double *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_dggrqf_work$handle() {
        return LAPACKE_dggrqf_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dggrqf_work(int matrix_layout, int m, int p, int n, double *a, int lda, double *taua, double *b, int ldb, double *taub, double *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_dggrqf_work$address() {
        return LAPACKE_dggrqf_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dggrqf_work(int matrix_layout, int m, int p, int n, double *a, int lda, double *taua, double *b, int ldb, double *taub, double *work, int lwork)
     * }
     */
    public static int LAPACKE_dggrqf_work(int matrix_layout, int m, int p, int n, MemorySegment a, int lda, MemorySegment taua, MemorySegment b, int ldb, MemorySegment taub, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_dggrqf_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dggrqf_work", matrix_layout, m, p, n, a, lda, taua, b, ldb, taub, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, m, p, n, a, lda, taua, b, ldb, taub, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cggrqf_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_cggrqf_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cggrqf_work(int matrix_layout, int m, int p, int n, _Complex float *a, int lda, _Complex float *taua, _Complex float *b, int ldb, _Complex float *taub, _Complex float *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_cggrqf_work$descriptor() {
        return LAPACKE_cggrqf_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cggrqf_work(int matrix_layout, int m, int p, int n, _Complex float *a, int lda, _Complex float *taua, _Complex float *b, int ldb, _Complex float *taub, _Complex float *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_cggrqf_work$handle() {
        return LAPACKE_cggrqf_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cggrqf_work(int matrix_layout, int m, int p, int n, _Complex float *a, int lda, _Complex float *taua, _Complex float *b, int ldb, _Complex float *taub, _Complex float *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_cggrqf_work$address() {
        return LAPACKE_cggrqf_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cggrqf_work(int matrix_layout, int m, int p, int n, _Complex float *a, int lda, _Complex float *taua, _Complex float *b, int ldb, _Complex float *taub, _Complex float *work, int lwork)
     * }
     */
    public static int LAPACKE_cggrqf_work(int matrix_layout, int m, int p, int n, MemorySegment a, int lda, MemorySegment taua, MemorySegment b, int ldb, MemorySegment taub, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_cggrqf_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cggrqf_work", matrix_layout, m, p, n, a, lda, taua, b, ldb, taub, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, m, p, n, a, lda, taua, b, ldb, taub, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zggrqf_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zggrqf_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zggrqf_work(int matrix_layout, int m, int p, int n, _Complex double *a, int lda, _Complex double *taua, _Complex double *b, int ldb, _Complex double *taub, _Complex double *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_zggrqf_work$descriptor() {
        return LAPACKE_zggrqf_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zggrqf_work(int matrix_layout, int m, int p, int n, _Complex double *a, int lda, _Complex double *taua, _Complex double *b, int ldb, _Complex double *taub, _Complex double *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_zggrqf_work$handle() {
        return LAPACKE_zggrqf_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zggrqf_work(int matrix_layout, int m, int p, int n, _Complex double *a, int lda, _Complex double *taua, _Complex double *b, int ldb, _Complex double *taub, _Complex double *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_zggrqf_work$address() {
        return LAPACKE_zggrqf_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zggrqf_work(int matrix_layout, int m, int p, int n, _Complex double *a, int lda, _Complex double *taua, _Complex double *b, int ldb, _Complex double *taub, _Complex double *work, int lwork)
     * }
     */
    public static int LAPACKE_zggrqf_work(int matrix_layout, int m, int p, int n, MemorySegment a, int lda, MemorySegment taua, MemorySegment b, int ldb, MemorySegment taub, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_zggrqf_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zggrqf_work", matrix_layout, m, p, n, a, lda, taua, b, ldb, taub, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, m, p, n, a, lda, taua, b, ldb, taub, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sggsvd_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_sggsvd_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sggsvd_work(int matrix_layout, char jobu, char jobv, char jobq, int m, int n, int p, int *k, int *l, float *a, int lda, float *b, int ldb, float *alpha, float *beta, float *u, int ldu, float *v, int ldv, float *q, int ldq, float *work, int *iwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_sggsvd_work$descriptor() {
        return LAPACKE_sggsvd_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sggsvd_work(int matrix_layout, char jobu, char jobv, char jobq, int m, int n, int p, int *k, int *l, float *a, int lda, float *b, int ldb, float *alpha, float *beta, float *u, int ldu, float *v, int ldv, float *q, int ldq, float *work, int *iwork)
     * }
     */
    public static MethodHandle LAPACKE_sggsvd_work$handle() {
        return LAPACKE_sggsvd_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sggsvd_work(int matrix_layout, char jobu, char jobv, char jobq, int m, int n, int p, int *k, int *l, float *a, int lda, float *b, int ldb, float *alpha, float *beta, float *u, int ldu, float *v, int ldv, float *q, int ldq, float *work, int *iwork)
     * }
     */
    public static MemorySegment LAPACKE_sggsvd_work$address() {
        return LAPACKE_sggsvd_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sggsvd_work(int matrix_layout, char jobu, char jobv, char jobq, int m, int n, int p, int *k, int *l, float *a, int lda, float *b, int ldb, float *alpha, float *beta, float *u, int ldu, float *v, int ldv, float *q, int ldq, float *work, int *iwork)
     * }
     */
    public static int LAPACKE_sggsvd_work(int matrix_layout, byte jobu, byte jobv, byte jobq, int m, int n, int p, MemorySegment k, MemorySegment l, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment alpha, MemorySegment beta, MemorySegment u, int ldu, MemorySegment v, int ldv, MemorySegment q, int ldq, MemorySegment work, MemorySegment iwork) {
        var mh$ = LAPACKE_sggsvd_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sggsvd_work", matrix_layout, jobu, jobv, jobq, m, n, p, k, l, a, lda, b, ldb, alpha, beta, u, ldu, v, ldv, q, ldq, work, iwork);
            }
            return (int)mh$.invokeExact(matrix_layout, jobu, jobv, jobq, m, n, p, k, l, a, lda, b, ldb, alpha, beta, u, ldu, v, ldv, q, ldq, work, iwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dggsvd_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dggsvd_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dggsvd_work(int matrix_layout, char jobu, char jobv, char jobq, int m, int n, int p, int *k, int *l, double *a, int lda, double *b, int ldb, double *alpha, double *beta, double *u, int ldu, double *v, int ldv, double *q, int ldq, double *work, int *iwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_dggsvd_work$descriptor() {
        return LAPACKE_dggsvd_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dggsvd_work(int matrix_layout, char jobu, char jobv, char jobq, int m, int n, int p, int *k, int *l, double *a, int lda, double *b, int ldb, double *alpha, double *beta, double *u, int ldu, double *v, int ldv, double *q, int ldq, double *work, int *iwork)
     * }
     */
    public static MethodHandle LAPACKE_dggsvd_work$handle() {
        return LAPACKE_dggsvd_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dggsvd_work(int matrix_layout, char jobu, char jobv, char jobq, int m, int n, int p, int *k, int *l, double *a, int lda, double *b, int ldb, double *alpha, double *beta, double *u, int ldu, double *v, int ldv, double *q, int ldq, double *work, int *iwork)
     * }
     */
    public static MemorySegment LAPACKE_dggsvd_work$address() {
        return LAPACKE_dggsvd_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dggsvd_work(int matrix_layout, char jobu, char jobv, char jobq, int m, int n, int p, int *k, int *l, double *a, int lda, double *b, int ldb, double *alpha, double *beta, double *u, int ldu, double *v, int ldv, double *q, int ldq, double *work, int *iwork)
     * }
     */
    public static int LAPACKE_dggsvd_work(int matrix_layout, byte jobu, byte jobv, byte jobq, int m, int n, int p, MemorySegment k, MemorySegment l, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment alpha, MemorySegment beta, MemorySegment u, int ldu, MemorySegment v, int ldv, MemorySegment q, int ldq, MemorySegment work, MemorySegment iwork) {
        var mh$ = LAPACKE_dggsvd_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dggsvd_work", matrix_layout, jobu, jobv, jobq, m, n, p, k, l, a, lda, b, ldb, alpha, beta, u, ldu, v, ldv, q, ldq, work, iwork);
            }
            return (int)mh$.invokeExact(matrix_layout, jobu, jobv, jobq, m, n, p, k, l, a, lda, b, ldb, alpha, beta, u, ldu, v, ldv, q, ldq, work, iwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cggsvd_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_cggsvd_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cggsvd_work(int matrix_layout, char jobu, char jobv, char jobq, int m, int n, int p, int *k, int *l, _Complex float *a, int lda, _Complex float *b, int ldb, float *alpha, float *beta, _Complex float *u, int ldu, _Complex float *v, int ldv, _Complex float *q, int ldq, _Complex float *work, float *rwork, int *iwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_cggsvd_work$descriptor() {
        return LAPACKE_cggsvd_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cggsvd_work(int matrix_layout, char jobu, char jobv, char jobq, int m, int n, int p, int *k, int *l, _Complex float *a, int lda, _Complex float *b, int ldb, float *alpha, float *beta, _Complex float *u, int ldu, _Complex float *v, int ldv, _Complex float *q, int ldq, _Complex float *work, float *rwork, int *iwork)
     * }
     */
    public static MethodHandle LAPACKE_cggsvd_work$handle() {
        return LAPACKE_cggsvd_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cggsvd_work(int matrix_layout, char jobu, char jobv, char jobq, int m, int n, int p, int *k, int *l, _Complex float *a, int lda, _Complex float *b, int ldb, float *alpha, float *beta, _Complex float *u, int ldu, _Complex float *v, int ldv, _Complex float *q, int ldq, _Complex float *work, float *rwork, int *iwork)
     * }
     */
    public static MemorySegment LAPACKE_cggsvd_work$address() {
        return LAPACKE_cggsvd_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cggsvd_work(int matrix_layout, char jobu, char jobv, char jobq, int m, int n, int p, int *k, int *l, _Complex float *a, int lda, _Complex float *b, int ldb, float *alpha, float *beta, _Complex float *u, int ldu, _Complex float *v, int ldv, _Complex float *q, int ldq, _Complex float *work, float *rwork, int *iwork)
     * }
     */
    public static int LAPACKE_cggsvd_work(int matrix_layout, byte jobu, byte jobv, byte jobq, int m, int n, int p, MemorySegment k, MemorySegment l, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment alpha, MemorySegment beta, MemorySegment u, int ldu, MemorySegment v, int ldv, MemorySegment q, int ldq, MemorySegment work, MemorySegment rwork, MemorySegment iwork) {
        var mh$ = LAPACKE_cggsvd_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cggsvd_work", matrix_layout, jobu, jobv, jobq, m, n, p, k, l, a, lda, b, ldb, alpha, beta, u, ldu, v, ldv, q, ldq, work, rwork, iwork);
            }
            return (int)mh$.invokeExact(matrix_layout, jobu, jobv, jobq, m, n, p, k, l, a, lda, b, ldb, alpha, beta, u, ldu, v, ldv, q, ldq, work, rwork, iwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zggsvd_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zggsvd_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zggsvd_work(int matrix_layout, char jobu, char jobv, char jobq, int m, int n, int p, int *k, int *l, _Complex double *a, int lda, _Complex double *b, int ldb, double *alpha, double *beta, _Complex double *u, int ldu, _Complex double *v, int ldv, _Complex double *q, int ldq, _Complex double *work, double *rwork, int *iwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_zggsvd_work$descriptor() {
        return LAPACKE_zggsvd_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zggsvd_work(int matrix_layout, char jobu, char jobv, char jobq, int m, int n, int p, int *k, int *l, _Complex double *a, int lda, _Complex double *b, int ldb, double *alpha, double *beta, _Complex double *u, int ldu, _Complex double *v, int ldv, _Complex double *q, int ldq, _Complex double *work, double *rwork, int *iwork)
     * }
     */
    public static MethodHandle LAPACKE_zggsvd_work$handle() {
        return LAPACKE_zggsvd_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zggsvd_work(int matrix_layout, char jobu, char jobv, char jobq, int m, int n, int p, int *k, int *l, _Complex double *a, int lda, _Complex double *b, int ldb, double *alpha, double *beta, _Complex double *u, int ldu, _Complex double *v, int ldv, _Complex double *q, int ldq, _Complex double *work, double *rwork, int *iwork)
     * }
     */
    public static MemorySegment LAPACKE_zggsvd_work$address() {
        return LAPACKE_zggsvd_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zggsvd_work(int matrix_layout, char jobu, char jobv, char jobq, int m, int n, int p, int *k, int *l, _Complex double *a, int lda, _Complex double *b, int ldb, double *alpha, double *beta, _Complex double *u, int ldu, _Complex double *v, int ldv, _Complex double *q, int ldq, _Complex double *work, double *rwork, int *iwork)
     * }
     */
    public static int LAPACKE_zggsvd_work(int matrix_layout, byte jobu, byte jobv, byte jobq, int m, int n, int p, MemorySegment k, MemorySegment l, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment alpha, MemorySegment beta, MemorySegment u, int ldu, MemorySegment v, int ldv, MemorySegment q, int ldq, MemorySegment work, MemorySegment rwork, MemorySegment iwork) {
        var mh$ = LAPACKE_zggsvd_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zggsvd_work", matrix_layout, jobu, jobv, jobq, m, n, p, k, l, a, lda, b, ldb, alpha, beta, u, ldu, v, ldv, q, ldq, work, rwork, iwork);
            }
            return (int)mh$.invokeExact(matrix_layout, jobu, jobv, jobq, m, n, p, k, l, a, lda, b, ldb, alpha, beta, u, ldu, v, ldv, q, ldq, work, rwork, iwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sggsvd3_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_sggsvd3_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sggsvd3_work(int matrix_layout, char jobu, char jobv, char jobq, int m, int n, int p, int *k, int *l, float *a, int lda, float *b, int ldb, float *alpha, float *beta, float *u, int ldu, float *v, int ldv, float *q, int ldq, float *work, int lwork, int *iwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_sggsvd3_work$descriptor() {
        return LAPACKE_sggsvd3_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sggsvd3_work(int matrix_layout, char jobu, char jobv, char jobq, int m, int n, int p, int *k, int *l, float *a, int lda, float *b, int ldb, float *alpha, float *beta, float *u, int ldu, float *v, int ldv, float *q, int ldq, float *work, int lwork, int *iwork)
     * }
     */
    public static MethodHandle LAPACKE_sggsvd3_work$handle() {
        return LAPACKE_sggsvd3_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sggsvd3_work(int matrix_layout, char jobu, char jobv, char jobq, int m, int n, int p, int *k, int *l, float *a, int lda, float *b, int ldb, float *alpha, float *beta, float *u, int ldu, float *v, int ldv, float *q, int ldq, float *work, int lwork, int *iwork)
     * }
     */
    public static MemorySegment LAPACKE_sggsvd3_work$address() {
        return LAPACKE_sggsvd3_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sggsvd3_work(int matrix_layout, char jobu, char jobv, char jobq, int m, int n, int p, int *k, int *l, float *a, int lda, float *b, int ldb, float *alpha, float *beta, float *u, int ldu, float *v, int ldv, float *q, int ldq, float *work, int lwork, int *iwork)
     * }
     */
    public static int LAPACKE_sggsvd3_work(int matrix_layout, byte jobu, byte jobv, byte jobq, int m, int n, int p, MemorySegment k, MemorySegment l, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment alpha, MemorySegment beta, MemorySegment u, int ldu, MemorySegment v, int ldv, MemorySegment q, int ldq, MemorySegment work, int lwork, MemorySegment iwork) {
        var mh$ = LAPACKE_sggsvd3_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sggsvd3_work", matrix_layout, jobu, jobv, jobq, m, n, p, k, l, a, lda, b, ldb, alpha, beta, u, ldu, v, ldv, q, ldq, work, lwork, iwork);
            }
            return (int)mh$.invokeExact(matrix_layout, jobu, jobv, jobq, m, n, p, k, l, a, lda, b, ldb, alpha, beta, u, ldu, v, ldv, q, ldq, work, lwork, iwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dggsvd3_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dggsvd3_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dggsvd3_work(int matrix_layout, char jobu, char jobv, char jobq, int m, int n, int p, int *k, int *l, double *a, int lda, double *b, int ldb, double *alpha, double *beta, double *u, int ldu, double *v, int ldv, double *q, int ldq, double *work, int lwork, int *iwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_dggsvd3_work$descriptor() {
        return LAPACKE_dggsvd3_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dggsvd3_work(int matrix_layout, char jobu, char jobv, char jobq, int m, int n, int p, int *k, int *l, double *a, int lda, double *b, int ldb, double *alpha, double *beta, double *u, int ldu, double *v, int ldv, double *q, int ldq, double *work, int lwork, int *iwork)
     * }
     */
    public static MethodHandle LAPACKE_dggsvd3_work$handle() {
        return LAPACKE_dggsvd3_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dggsvd3_work(int matrix_layout, char jobu, char jobv, char jobq, int m, int n, int p, int *k, int *l, double *a, int lda, double *b, int ldb, double *alpha, double *beta, double *u, int ldu, double *v, int ldv, double *q, int ldq, double *work, int lwork, int *iwork)
     * }
     */
    public static MemorySegment LAPACKE_dggsvd3_work$address() {
        return LAPACKE_dggsvd3_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dggsvd3_work(int matrix_layout, char jobu, char jobv, char jobq, int m, int n, int p, int *k, int *l, double *a, int lda, double *b, int ldb, double *alpha, double *beta, double *u, int ldu, double *v, int ldv, double *q, int ldq, double *work, int lwork, int *iwork)
     * }
     */
    public static int LAPACKE_dggsvd3_work(int matrix_layout, byte jobu, byte jobv, byte jobq, int m, int n, int p, MemorySegment k, MemorySegment l, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment alpha, MemorySegment beta, MemorySegment u, int ldu, MemorySegment v, int ldv, MemorySegment q, int ldq, MemorySegment work, int lwork, MemorySegment iwork) {
        var mh$ = LAPACKE_dggsvd3_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dggsvd3_work", matrix_layout, jobu, jobv, jobq, m, n, p, k, l, a, lda, b, ldb, alpha, beta, u, ldu, v, ldv, q, ldq, work, lwork, iwork);
            }
            return (int)mh$.invokeExact(matrix_layout, jobu, jobv, jobq, m, n, p, k, l, a, lda, b, ldb, alpha, beta, u, ldu, v, ldv, q, ldq, work, lwork, iwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cggsvd3_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_cggsvd3_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cggsvd3_work(int matrix_layout, char jobu, char jobv, char jobq, int m, int n, int p, int *k, int *l, _Complex float *a, int lda, _Complex float *b, int ldb, float *alpha, float *beta, _Complex float *u, int ldu, _Complex float *v, int ldv, _Complex float *q, int ldq, _Complex float *work, int lwork, float *rwork, int *iwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_cggsvd3_work$descriptor() {
        return LAPACKE_cggsvd3_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cggsvd3_work(int matrix_layout, char jobu, char jobv, char jobq, int m, int n, int p, int *k, int *l, _Complex float *a, int lda, _Complex float *b, int ldb, float *alpha, float *beta, _Complex float *u, int ldu, _Complex float *v, int ldv, _Complex float *q, int ldq, _Complex float *work, int lwork, float *rwork, int *iwork)
     * }
     */
    public static MethodHandle LAPACKE_cggsvd3_work$handle() {
        return LAPACKE_cggsvd3_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cggsvd3_work(int matrix_layout, char jobu, char jobv, char jobq, int m, int n, int p, int *k, int *l, _Complex float *a, int lda, _Complex float *b, int ldb, float *alpha, float *beta, _Complex float *u, int ldu, _Complex float *v, int ldv, _Complex float *q, int ldq, _Complex float *work, int lwork, float *rwork, int *iwork)
     * }
     */
    public static MemorySegment LAPACKE_cggsvd3_work$address() {
        return LAPACKE_cggsvd3_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cggsvd3_work(int matrix_layout, char jobu, char jobv, char jobq, int m, int n, int p, int *k, int *l, _Complex float *a, int lda, _Complex float *b, int ldb, float *alpha, float *beta, _Complex float *u, int ldu, _Complex float *v, int ldv, _Complex float *q, int ldq, _Complex float *work, int lwork, float *rwork, int *iwork)
     * }
     */
    public static int LAPACKE_cggsvd3_work(int matrix_layout, byte jobu, byte jobv, byte jobq, int m, int n, int p, MemorySegment k, MemorySegment l, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment alpha, MemorySegment beta, MemorySegment u, int ldu, MemorySegment v, int ldv, MemorySegment q, int ldq, MemorySegment work, int lwork, MemorySegment rwork, MemorySegment iwork) {
        var mh$ = LAPACKE_cggsvd3_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cggsvd3_work", matrix_layout, jobu, jobv, jobq, m, n, p, k, l, a, lda, b, ldb, alpha, beta, u, ldu, v, ldv, q, ldq, work, lwork, rwork, iwork);
            }
            return (int)mh$.invokeExact(matrix_layout, jobu, jobv, jobq, m, n, p, k, l, a, lda, b, ldb, alpha, beta, u, ldu, v, ldv, q, ldq, work, lwork, rwork, iwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zggsvd3_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zggsvd3_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zggsvd3_work(int matrix_layout, char jobu, char jobv, char jobq, int m, int n, int p, int *k, int *l, _Complex double *a, int lda, _Complex double *b, int ldb, double *alpha, double *beta, _Complex double *u, int ldu, _Complex double *v, int ldv, _Complex double *q, int ldq, _Complex double *work, int lwork, double *rwork, int *iwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_zggsvd3_work$descriptor() {
        return LAPACKE_zggsvd3_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zggsvd3_work(int matrix_layout, char jobu, char jobv, char jobq, int m, int n, int p, int *k, int *l, _Complex double *a, int lda, _Complex double *b, int ldb, double *alpha, double *beta, _Complex double *u, int ldu, _Complex double *v, int ldv, _Complex double *q, int ldq, _Complex double *work, int lwork, double *rwork, int *iwork)
     * }
     */
    public static MethodHandle LAPACKE_zggsvd3_work$handle() {
        return LAPACKE_zggsvd3_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zggsvd3_work(int matrix_layout, char jobu, char jobv, char jobq, int m, int n, int p, int *k, int *l, _Complex double *a, int lda, _Complex double *b, int ldb, double *alpha, double *beta, _Complex double *u, int ldu, _Complex double *v, int ldv, _Complex double *q, int ldq, _Complex double *work, int lwork, double *rwork, int *iwork)
     * }
     */
    public static MemorySegment LAPACKE_zggsvd3_work$address() {
        return LAPACKE_zggsvd3_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zggsvd3_work(int matrix_layout, char jobu, char jobv, char jobq, int m, int n, int p, int *k, int *l, _Complex double *a, int lda, _Complex double *b, int ldb, double *alpha, double *beta, _Complex double *u, int ldu, _Complex double *v, int ldv, _Complex double *q, int ldq, _Complex double *work, int lwork, double *rwork, int *iwork)
     * }
     */
    public static int LAPACKE_zggsvd3_work(int matrix_layout, byte jobu, byte jobv, byte jobq, int m, int n, int p, MemorySegment k, MemorySegment l, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment alpha, MemorySegment beta, MemorySegment u, int ldu, MemorySegment v, int ldv, MemorySegment q, int ldq, MemorySegment work, int lwork, MemorySegment rwork, MemorySegment iwork) {
        var mh$ = LAPACKE_zggsvd3_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zggsvd3_work", matrix_layout, jobu, jobv, jobq, m, n, p, k, l, a, lda, b, ldb, alpha, beta, u, ldu, v, ldv, q, ldq, work, lwork, rwork, iwork);
            }
            return (int)mh$.invokeExact(matrix_layout, jobu, jobv, jobq, m, n, p, k, l, a, lda, b, ldb, alpha, beta, u, ldu, v, ldv, q, ldq, work, lwork, rwork, iwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sggsvp_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_FLOAT,
            lapacke_h.C_FLOAT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_sggsvp_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sggsvp_work(int matrix_layout, char jobu, char jobv, char jobq, int m, int p, int n, float *a, int lda, float *b, int ldb, float tola, float tolb, int *k, int *l, float *u, int ldu, float *v, int ldv, float *q, int ldq, int *iwork, float *tau, float *work)
     * }
     */
    public static FunctionDescriptor LAPACKE_sggsvp_work$descriptor() {
        return LAPACKE_sggsvp_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sggsvp_work(int matrix_layout, char jobu, char jobv, char jobq, int m, int p, int n, float *a, int lda, float *b, int ldb, float tola, float tolb, int *k, int *l, float *u, int ldu, float *v, int ldv, float *q, int ldq, int *iwork, float *tau, float *work)
     * }
     */
    public static MethodHandle LAPACKE_sggsvp_work$handle() {
        return LAPACKE_sggsvp_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sggsvp_work(int matrix_layout, char jobu, char jobv, char jobq, int m, int p, int n, float *a, int lda, float *b, int ldb, float tola, float tolb, int *k, int *l, float *u, int ldu, float *v, int ldv, float *q, int ldq, int *iwork, float *tau, float *work)
     * }
     */
    public static MemorySegment LAPACKE_sggsvp_work$address() {
        return LAPACKE_sggsvp_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sggsvp_work(int matrix_layout, char jobu, char jobv, char jobq, int m, int p, int n, float *a, int lda, float *b, int ldb, float tola, float tolb, int *k, int *l, float *u, int ldu, float *v, int ldv, float *q, int ldq, int *iwork, float *tau, float *work)
     * }
     */
    public static int LAPACKE_sggsvp_work(int matrix_layout, byte jobu, byte jobv, byte jobq, int m, int p, int n, MemorySegment a, int lda, MemorySegment b, int ldb, float tola, float tolb, MemorySegment k, MemorySegment l, MemorySegment u, int ldu, MemorySegment v, int ldv, MemorySegment q, int ldq, MemorySegment iwork, MemorySegment tau, MemorySegment work) {
        var mh$ = LAPACKE_sggsvp_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sggsvp_work", matrix_layout, jobu, jobv, jobq, m, p, n, a, lda, b, ldb, tola, tolb, k, l, u, ldu, v, ldv, q, ldq, iwork, tau, work);
            }
            return (int)mh$.invokeExact(matrix_layout, jobu, jobv, jobq, m, p, n, a, lda, b, ldb, tola, tolb, k, l, u, ldu, v, ldv, q, ldq, iwork, tau, work);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dggsvp_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_DOUBLE,
            lapacke_h.C_DOUBLE,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dggsvp_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dggsvp_work(int matrix_layout, char jobu, char jobv, char jobq, int m, int p, int n, double *a, int lda, double *b, int ldb, double tola, double tolb, int *k, int *l, double *u, int ldu, double *v, int ldv, double *q, int ldq, int *iwork, double *tau, double *work)
     * }
     */
    public static FunctionDescriptor LAPACKE_dggsvp_work$descriptor() {
        return LAPACKE_dggsvp_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dggsvp_work(int matrix_layout, char jobu, char jobv, char jobq, int m, int p, int n, double *a, int lda, double *b, int ldb, double tola, double tolb, int *k, int *l, double *u, int ldu, double *v, int ldv, double *q, int ldq, int *iwork, double *tau, double *work)
     * }
     */
    public static MethodHandle LAPACKE_dggsvp_work$handle() {
        return LAPACKE_dggsvp_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dggsvp_work(int matrix_layout, char jobu, char jobv, char jobq, int m, int p, int n, double *a, int lda, double *b, int ldb, double tola, double tolb, int *k, int *l, double *u, int ldu, double *v, int ldv, double *q, int ldq, int *iwork, double *tau, double *work)
     * }
     */
    public static MemorySegment LAPACKE_dggsvp_work$address() {
        return LAPACKE_dggsvp_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dggsvp_work(int matrix_layout, char jobu, char jobv, char jobq, int m, int p, int n, double *a, int lda, double *b, int ldb, double tola, double tolb, int *k, int *l, double *u, int ldu, double *v, int ldv, double *q, int ldq, int *iwork, double *tau, double *work)
     * }
     */
    public static int LAPACKE_dggsvp_work(int matrix_layout, byte jobu, byte jobv, byte jobq, int m, int p, int n, MemorySegment a, int lda, MemorySegment b, int ldb, double tola, double tolb, MemorySegment k, MemorySegment l, MemorySegment u, int ldu, MemorySegment v, int ldv, MemorySegment q, int ldq, MemorySegment iwork, MemorySegment tau, MemorySegment work) {
        var mh$ = LAPACKE_dggsvp_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dggsvp_work", matrix_layout, jobu, jobv, jobq, m, p, n, a, lda, b, ldb, tola, tolb, k, l, u, ldu, v, ldv, q, ldq, iwork, tau, work);
            }
            return (int)mh$.invokeExact(matrix_layout, jobu, jobv, jobq, m, p, n, a, lda, b, ldb, tola, tolb, k, l, u, ldu, v, ldv, q, ldq, iwork, tau, work);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cggsvp_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_FLOAT,
            lapacke_h.C_FLOAT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_cggsvp_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cggsvp_work(int matrix_layout, char jobu, char jobv, char jobq, int m, int p, int n, _Complex float *a, int lda, _Complex float *b, int ldb, float tola, float tolb, int *k, int *l, _Complex float *u, int ldu, _Complex float *v, int ldv, _Complex float *q, int ldq, int *iwork, float *rwork, _Complex float *tau, _Complex float *work)
     * }
     */
    public static FunctionDescriptor LAPACKE_cggsvp_work$descriptor() {
        return LAPACKE_cggsvp_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cggsvp_work(int matrix_layout, char jobu, char jobv, char jobq, int m, int p, int n, _Complex float *a, int lda, _Complex float *b, int ldb, float tola, float tolb, int *k, int *l, _Complex float *u, int ldu, _Complex float *v, int ldv, _Complex float *q, int ldq, int *iwork, float *rwork, _Complex float *tau, _Complex float *work)
     * }
     */
    public static MethodHandle LAPACKE_cggsvp_work$handle() {
        return LAPACKE_cggsvp_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cggsvp_work(int matrix_layout, char jobu, char jobv, char jobq, int m, int p, int n, _Complex float *a, int lda, _Complex float *b, int ldb, float tola, float tolb, int *k, int *l, _Complex float *u, int ldu, _Complex float *v, int ldv, _Complex float *q, int ldq, int *iwork, float *rwork, _Complex float *tau, _Complex float *work)
     * }
     */
    public static MemorySegment LAPACKE_cggsvp_work$address() {
        return LAPACKE_cggsvp_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cggsvp_work(int matrix_layout, char jobu, char jobv, char jobq, int m, int p, int n, _Complex float *a, int lda, _Complex float *b, int ldb, float tola, float tolb, int *k, int *l, _Complex float *u, int ldu, _Complex float *v, int ldv, _Complex float *q, int ldq, int *iwork, float *rwork, _Complex float *tau, _Complex float *work)
     * }
     */
    public static int LAPACKE_cggsvp_work(int matrix_layout, byte jobu, byte jobv, byte jobq, int m, int p, int n, MemorySegment a, int lda, MemorySegment b, int ldb, float tola, float tolb, MemorySegment k, MemorySegment l, MemorySegment u, int ldu, MemorySegment v, int ldv, MemorySegment q, int ldq, MemorySegment iwork, MemorySegment rwork, MemorySegment tau, MemorySegment work) {
        var mh$ = LAPACKE_cggsvp_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cggsvp_work", matrix_layout, jobu, jobv, jobq, m, p, n, a, lda, b, ldb, tola, tolb, k, l, u, ldu, v, ldv, q, ldq, iwork, rwork, tau, work);
            }
            return (int)mh$.invokeExact(matrix_layout, jobu, jobv, jobq, m, p, n, a, lda, b, ldb, tola, tolb, k, l, u, ldu, v, ldv, q, ldq, iwork, rwork, tau, work);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zggsvp_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_DOUBLE,
            lapacke_h.C_DOUBLE,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zggsvp_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zggsvp_work(int matrix_layout, char jobu, char jobv, char jobq, int m, int p, int n, _Complex double *a, int lda, _Complex double *b, int ldb, double tola, double tolb, int *k, int *l, _Complex double *u, int ldu, _Complex double *v, int ldv, _Complex double *q, int ldq, int *iwork, double *rwork, _Complex double *tau, _Complex double *work)
     * }
     */
    public static FunctionDescriptor LAPACKE_zggsvp_work$descriptor() {
        return LAPACKE_zggsvp_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zggsvp_work(int matrix_layout, char jobu, char jobv, char jobq, int m, int p, int n, _Complex double *a, int lda, _Complex double *b, int ldb, double tola, double tolb, int *k, int *l, _Complex double *u, int ldu, _Complex double *v, int ldv, _Complex double *q, int ldq, int *iwork, double *rwork, _Complex double *tau, _Complex double *work)
     * }
     */
    public static MethodHandle LAPACKE_zggsvp_work$handle() {
        return LAPACKE_zggsvp_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zggsvp_work(int matrix_layout, char jobu, char jobv, char jobq, int m, int p, int n, _Complex double *a, int lda, _Complex double *b, int ldb, double tola, double tolb, int *k, int *l, _Complex double *u, int ldu, _Complex double *v, int ldv, _Complex double *q, int ldq, int *iwork, double *rwork, _Complex double *tau, _Complex double *work)
     * }
     */
    public static MemorySegment LAPACKE_zggsvp_work$address() {
        return LAPACKE_zggsvp_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zggsvp_work(int matrix_layout, char jobu, char jobv, char jobq, int m, int p, int n, _Complex double *a, int lda, _Complex double *b, int ldb, double tola, double tolb, int *k, int *l, _Complex double *u, int ldu, _Complex double *v, int ldv, _Complex double *q, int ldq, int *iwork, double *rwork, _Complex double *tau, _Complex double *work)
     * }
     */
    public static int LAPACKE_zggsvp_work(int matrix_layout, byte jobu, byte jobv, byte jobq, int m, int p, int n, MemorySegment a, int lda, MemorySegment b, int ldb, double tola, double tolb, MemorySegment k, MemorySegment l, MemorySegment u, int ldu, MemorySegment v, int ldv, MemorySegment q, int ldq, MemorySegment iwork, MemorySegment rwork, MemorySegment tau, MemorySegment work) {
        var mh$ = LAPACKE_zggsvp_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zggsvp_work", matrix_layout, jobu, jobv, jobq, m, p, n, a, lda, b, ldb, tola, tolb, k, l, u, ldu, v, ldv, q, ldq, iwork, rwork, tau, work);
            }
            return (int)mh$.invokeExact(matrix_layout, jobu, jobv, jobq, m, p, n, a, lda, b, ldb, tola, tolb, k, l, u, ldu, v, ldv, q, ldq, iwork, rwork, tau, work);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sggsvp3_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_FLOAT,
            lapacke_h.C_FLOAT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_sggsvp3_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sggsvp3_work(int matrix_layout, char jobu, char jobv, char jobq, int m, int p, int n, float *a, int lda, float *b, int ldb, float tola, float tolb, int *k, int *l, float *u, int ldu, float *v, int ldv, float *q, int ldq, int *iwork, float *tau, float *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_sggsvp3_work$descriptor() {
        return LAPACKE_sggsvp3_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sggsvp3_work(int matrix_layout, char jobu, char jobv, char jobq, int m, int p, int n, float *a, int lda, float *b, int ldb, float tola, float tolb, int *k, int *l, float *u, int ldu, float *v, int ldv, float *q, int ldq, int *iwork, float *tau, float *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_sggsvp3_work$handle() {
        return LAPACKE_sggsvp3_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sggsvp3_work(int matrix_layout, char jobu, char jobv, char jobq, int m, int p, int n, float *a, int lda, float *b, int ldb, float tola, float tolb, int *k, int *l, float *u, int ldu, float *v, int ldv, float *q, int ldq, int *iwork, float *tau, float *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_sggsvp3_work$address() {
        return LAPACKE_sggsvp3_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sggsvp3_work(int matrix_layout, char jobu, char jobv, char jobq, int m, int p, int n, float *a, int lda, float *b, int ldb, float tola, float tolb, int *k, int *l, float *u, int ldu, float *v, int ldv, float *q, int ldq, int *iwork, float *tau, float *work, int lwork)
     * }
     */
    public static int LAPACKE_sggsvp3_work(int matrix_layout, byte jobu, byte jobv, byte jobq, int m, int p, int n, MemorySegment a, int lda, MemorySegment b, int ldb, float tola, float tolb, MemorySegment k, MemorySegment l, MemorySegment u, int ldu, MemorySegment v, int ldv, MemorySegment q, int ldq, MemorySegment iwork, MemorySegment tau, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_sggsvp3_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sggsvp3_work", matrix_layout, jobu, jobv, jobq, m, p, n, a, lda, b, ldb, tola, tolb, k, l, u, ldu, v, ldv, q, ldq, iwork, tau, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, jobu, jobv, jobq, m, p, n, a, lda, b, ldb, tola, tolb, k, l, u, ldu, v, ldv, q, ldq, iwork, tau, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dggsvp3_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_DOUBLE,
            lapacke_h.C_DOUBLE,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dggsvp3_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dggsvp3_work(int matrix_layout, char jobu, char jobv, char jobq, int m, int p, int n, double *a, int lda, double *b, int ldb, double tola, double tolb, int *k, int *l, double *u, int ldu, double *v, int ldv, double *q, int ldq, int *iwork, double *tau, double *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_dggsvp3_work$descriptor() {
        return LAPACKE_dggsvp3_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dggsvp3_work(int matrix_layout, char jobu, char jobv, char jobq, int m, int p, int n, double *a, int lda, double *b, int ldb, double tola, double tolb, int *k, int *l, double *u, int ldu, double *v, int ldv, double *q, int ldq, int *iwork, double *tau, double *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_dggsvp3_work$handle() {
        return LAPACKE_dggsvp3_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dggsvp3_work(int matrix_layout, char jobu, char jobv, char jobq, int m, int p, int n, double *a, int lda, double *b, int ldb, double tola, double tolb, int *k, int *l, double *u, int ldu, double *v, int ldv, double *q, int ldq, int *iwork, double *tau, double *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_dggsvp3_work$address() {
        return LAPACKE_dggsvp3_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dggsvp3_work(int matrix_layout, char jobu, char jobv, char jobq, int m, int p, int n, double *a, int lda, double *b, int ldb, double tola, double tolb, int *k, int *l, double *u, int ldu, double *v, int ldv, double *q, int ldq, int *iwork, double *tau, double *work, int lwork)
     * }
     */
    public static int LAPACKE_dggsvp3_work(int matrix_layout, byte jobu, byte jobv, byte jobq, int m, int p, int n, MemorySegment a, int lda, MemorySegment b, int ldb, double tola, double tolb, MemorySegment k, MemorySegment l, MemorySegment u, int ldu, MemorySegment v, int ldv, MemorySegment q, int ldq, MemorySegment iwork, MemorySegment tau, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_dggsvp3_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dggsvp3_work", matrix_layout, jobu, jobv, jobq, m, p, n, a, lda, b, ldb, tola, tolb, k, l, u, ldu, v, ldv, q, ldq, iwork, tau, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, jobu, jobv, jobq, m, p, n, a, lda, b, ldb, tola, tolb, k, l, u, ldu, v, ldv, q, ldq, iwork, tau, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cggsvp3_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_FLOAT,
            lapacke_h.C_FLOAT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_cggsvp3_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cggsvp3_work(int matrix_layout, char jobu, char jobv, char jobq, int m, int p, int n, _Complex float *a, int lda, _Complex float *b, int ldb, float tola, float tolb, int *k, int *l, _Complex float *u, int ldu, _Complex float *v, int ldv, _Complex float *q, int ldq, int *iwork, float *rwork, _Complex float *tau, _Complex float *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_cggsvp3_work$descriptor() {
        return LAPACKE_cggsvp3_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cggsvp3_work(int matrix_layout, char jobu, char jobv, char jobq, int m, int p, int n, _Complex float *a, int lda, _Complex float *b, int ldb, float tola, float tolb, int *k, int *l, _Complex float *u, int ldu, _Complex float *v, int ldv, _Complex float *q, int ldq, int *iwork, float *rwork, _Complex float *tau, _Complex float *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_cggsvp3_work$handle() {
        return LAPACKE_cggsvp3_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cggsvp3_work(int matrix_layout, char jobu, char jobv, char jobq, int m, int p, int n, _Complex float *a, int lda, _Complex float *b, int ldb, float tola, float tolb, int *k, int *l, _Complex float *u, int ldu, _Complex float *v, int ldv, _Complex float *q, int ldq, int *iwork, float *rwork, _Complex float *tau, _Complex float *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_cggsvp3_work$address() {
        return LAPACKE_cggsvp3_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cggsvp3_work(int matrix_layout, char jobu, char jobv, char jobq, int m, int p, int n, _Complex float *a, int lda, _Complex float *b, int ldb, float tola, float tolb, int *k, int *l, _Complex float *u, int ldu, _Complex float *v, int ldv, _Complex float *q, int ldq, int *iwork, float *rwork, _Complex float *tau, _Complex float *work, int lwork)
     * }
     */
    public static int LAPACKE_cggsvp3_work(int matrix_layout, byte jobu, byte jobv, byte jobq, int m, int p, int n, MemorySegment a, int lda, MemorySegment b, int ldb, float tola, float tolb, MemorySegment k, MemorySegment l, MemorySegment u, int ldu, MemorySegment v, int ldv, MemorySegment q, int ldq, MemorySegment iwork, MemorySegment rwork, MemorySegment tau, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_cggsvp3_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cggsvp3_work", matrix_layout, jobu, jobv, jobq, m, p, n, a, lda, b, ldb, tola, tolb, k, l, u, ldu, v, ldv, q, ldq, iwork, rwork, tau, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, jobu, jobv, jobq, m, p, n, a, lda, b, ldb, tola, tolb, k, l, u, ldu, v, ldv, q, ldq, iwork, rwork, tau, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zggsvp3_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_DOUBLE,
            lapacke_h.C_DOUBLE,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zggsvp3_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zggsvp3_work(int matrix_layout, char jobu, char jobv, char jobq, int m, int p, int n, _Complex double *a, int lda, _Complex double *b, int ldb, double tola, double tolb, int *k, int *l, _Complex double *u, int ldu, _Complex double *v, int ldv, _Complex double *q, int ldq, int *iwork, double *rwork, _Complex double *tau, _Complex double *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_zggsvp3_work$descriptor() {
        return LAPACKE_zggsvp3_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zggsvp3_work(int matrix_layout, char jobu, char jobv, char jobq, int m, int p, int n, _Complex double *a, int lda, _Complex double *b, int ldb, double tola, double tolb, int *k, int *l, _Complex double *u, int ldu, _Complex double *v, int ldv, _Complex double *q, int ldq, int *iwork, double *rwork, _Complex double *tau, _Complex double *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_zggsvp3_work$handle() {
        return LAPACKE_zggsvp3_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zggsvp3_work(int matrix_layout, char jobu, char jobv, char jobq, int m, int p, int n, _Complex double *a, int lda, _Complex double *b, int ldb, double tola, double tolb, int *k, int *l, _Complex double *u, int ldu, _Complex double *v, int ldv, _Complex double *q, int ldq, int *iwork, double *rwork, _Complex double *tau, _Complex double *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_zggsvp3_work$address() {
        return LAPACKE_zggsvp3_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zggsvp3_work(int matrix_layout, char jobu, char jobv, char jobq, int m, int p, int n, _Complex double *a, int lda, _Complex double *b, int ldb, double tola, double tolb, int *k, int *l, _Complex double *u, int ldu, _Complex double *v, int ldv, _Complex double *q, int ldq, int *iwork, double *rwork, _Complex double *tau, _Complex double *work, int lwork)
     * }
     */
    public static int LAPACKE_zggsvp3_work(int matrix_layout, byte jobu, byte jobv, byte jobq, int m, int p, int n, MemorySegment a, int lda, MemorySegment b, int ldb, double tola, double tolb, MemorySegment k, MemorySegment l, MemorySegment u, int ldu, MemorySegment v, int ldv, MemorySegment q, int ldq, MemorySegment iwork, MemorySegment rwork, MemorySegment tau, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_zggsvp3_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zggsvp3_work", matrix_layout, jobu, jobv, jobq, m, p, n, a, lda, b, ldb, tola, tolb, k, l, u, ldu, v, ldv, q, ldq, iwork, rwork, tau, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, jobu, jobv, jobq, m, p, n, a, lda, b, ldb, tola, tolb, k, l, u, ldu, v, ldv, q, ldq, iwork, rwork, tau, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sgtcon_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_FLOAT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_sgtcon_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sgtcon_work(char norm, int n, const float *dl, const float *d, const float *du, const float *du2, const int *ipiv, float anorm, float *rcond, float *work, int *iwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_sgtcon_work$descriptor() {
        return LAPACKE_sgtcon_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sgtcon_work(char norm, int n, const float *dl, const float *d, const float *du, const float *du2, const int *ipiv, float anorm, float *rcond, float *work, int *iwork)
     * }
     */
    public static MethodHandle LAPACKE_sgtcon_work$handle() {
        return LAPACKE_sgtcon_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sgtcon_work(char norm, int n, const float *dl, const float *d, const float *du, const float *du2, const int *ipiv, float anorm, float *rcond, float *work, int *iwork)
     * }
     */
    public static MemorySegment LAPACKE_sgtcon_work$address() {
        return LAPACKE_sgtcon_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sgtcon_work(char norm, int n, const float *dl, const float *d, const float *du, const float *du2, const int *ipiv, float anorm, float *rcond, float *work, int *iwork)
     * }
     */
    public static int LAPACKE_sgtcon_work(byte norm, int n, MemorySegment dl, MemorySegment d, MemorySegment du, MemorySegment du2, MemorySegment ipiv, float anorm, MemorySegment rcond, MemorySegment work, MemorySegment iwork) {
        var mh$ = LAPACKE_sgtcon_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sgtcon_work", norm, n, dl, d, du, du2, ipiv, anorm, rcond, work, iwork);
            }
            return (int)mh$.invokeExact(norm, n, dl, d, du, du2, ipiv, anorm, rcond, work, iwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dgtcon_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_DOUBLE,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dgtcon_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dgtcon_work(char norm, int n, const double *dl, const double *d, const double *du, const double *du2, const int *ipiv, double anorm, double *rcond, double *work, int *iwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_dgtcon_work$descriptor() {
        return LAPACKE_dgtcon_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dgtcon_work(char norm, int n, const double *dl, const double *d, const double *du, const double *du2, const int *ipiv, double anorm, double *rcond, double *work, int *iwork)
     * }
     */
    public static MethodHandle LAPACKE_dgtcon_work$handle() {
        return LAPACKE_dgtcon_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dgtcon_work(char norm, int n, const double *dl, const double *d, const double *du, const double *du2, const int *ipiv, double anorm, double *rcond, double *work, int *iwork)
     * }
     */
    public static MemorySegment LAPACKE_dgtcon_work$address() {
        return LAPACKE_dgtcon_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dgtcon_work(char norm, int n, const double *dl, const double *d, const double *du, const double *du2, const int *ipiv, double anorm, double *rcond, double *work, int *iwork)
     * }
     */
    public static int LAPACKE_dgtcon_work(byte norm, int n, MemorySegment dl, MemorySegment d, MemorySegment du, MemorySegment du2, MemorySegment ipiv, double anorm, MemorySegment rcond, MemorySegment work, MemorySegment iwork) {
        var mh$ = LAPACKE_dgtcon_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dgtcon_work", norm, n, dl, d, du, du2, ipiv, anorm, rcond, work, iwork);
            }
            return (int)mh$.invokeExact(norm, n, dl, d, du, du2, ipiv, anorm, rcond, work, iwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cgtcon_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_FLOAT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_cgtcon_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cgtcon_work(char norm, int n, const _Complex float *dl, const _Complex float *d, const _Complex float *du, const _Complex float *du2, const int *ipiv, float anorm, float *rcond, _Complex float *work)
     * }
     */
    public static FunctionDescriptor LAPACKE_cgtcon_work$descriptor() {
        return LAPACKE_cgtcon_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cgtcon_work(char norm, int n, const _Complex float *dl, const _Complex float *d, const _Complex float *du, const _Complex float *du2, const int *ipiv, float anorm, float *rcond, _Complex float *work)
     * }
     */
    public static MethodHandle LAPACKE_cgtcon_work$handle() {
        return LAPACKE_cgtcon_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cgtcon_work(char norm, int n, const _Complex float *dl, const _Complex float *d, const _Complex float *du, const _Complex float *du2, const int *ipiv, float anorm, float *rcond, _Complex float *work)
     * }
     */
    public static MemorySegment LAPACKE_cgtcon_work$address() {
        return LAPACKE_cgtcon_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cgtcon_work(char norm, int n, const _Complex float *dl, const _Complex float *d, const _Complex float *du, const _Complex float *du2, const int *ipiv, float anorm, float *rcond, _Complex float *work)
     * }
     */
    public static int LAPACKE_cgtcon_work(byte norm, int n, MemorySegment dl, MemorySegment d, MemorySegment du, MemorySegment du2, MemorySegment ipiv, float anorm, MemorySegment rcond, MemorySegment work) {
        var mh$ = LAPACKE_cgtcon_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cgtcon_work", norm, n, dl, d, du, du2, ipiv, anorm, rcond, work);
            }
            return (int)mh$.invokeExact(norm, n, dl, d, du, du2, ipiv, anorm, rcond, work);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zgtcon_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_DOUBLE,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zgtcon_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zgtcon_work(char norm, int n, const _Complex double *dl, const _Complex double *d, const _Complex double *du, const _Complex double *du2, const int *ipiv, double anorm, double *rcond, _Complex double *work)
     * }
     */
    public static FunctionDescriptor LAPACKE_zgtcon_work$descriptor() {
        return LAPACKE_zgtcon_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zgtcon_work(char norm, int n, const _Complex double *dl, const _Complex double *d, const _Complex double *du, const _Complex double *du2, const int *ipiv, double anorm, double *rcond, _Complex double *work)
     * }
     */
    public static MethodHandle LAPACKE_zgtcon_work$handle() {
        return LAPACKE_zgtcon_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zgtcon_work(char norm, int n, const _Complex double *dl, const _Complex double *d, const _Complex double *du, const _Complex double *du2, const int *ipiv, double anorm, double *rcond, _Complex double *work)
     * }
     */
    public static MemorySegment LAPACKE_zgtcon_work$address() {
        return LAPACKE_zgtcon_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zgtcon_work(char norm, int n, const _Complex double *dl, const _Complex double *d, const _Complex double *du, const _Complex double *du2, const int *ipiv, double anorm, double *rcond, _Complex double *work)
     * }
     */
    public static int LAPACKE_zgtcon_work(byte norm, int n, MemorySegment dl, MemorySegment d, MemorySegment du, MemorySegment du2, MemorySegment ipiv, double anorm, MemorySegment rcond, MemorySegment work) {
        var mh$ = LAPACKE_zgtcon_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zgtcon_work", norm, n, dl, d, du, du2, ipiv, anorm, rcond, work);
            }
            return (int)mh$.invokeExact(norm, n, dl, d, du, du2, ipiv, anorm, rcond, work);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sgtrfs_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_sgtrfs_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sgtrfs_work(int matrix_layout, char trans, int n, int nrhs, const float *dl, const float *d, const float *du, const float *dlf, const float *df, const float *duf, const float *du2, const int *ipiv, const float *b, int ldb, float *x, int ldx, float *ferr, float *berr, float *work, int *iwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_sgtrfs_work$descriptor() {
        return LAPACKE_sgtrfs_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sgtrfs_work(int matrix_layout, char trans, int n, int nrhs, const float *dl, const float *d, const float *du, const float *dlf, const float *df, const float *duf, const float *du2, const int *ipiv, const float *b, int ldb, float *x, int ldx, float *ferr, float *berr, float *work, int *iwork)
     * }
     */
    public static MethodHandle LAPACKE_sgtrfs_work$handle() {
        return LAPACKE_sgtrfs_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sgtrfs_work(int matrix_layout, char trans, int n, int nrhs, const float *dl, const float *d, const float *du, const float *dlf, const float *df, const float *duf, const float *du2, const int *ipiv, const float *b, int ldb, float *x, int ldx, float *ferr, float *berr, float *work, int *iwork)
     * }
     */
    public static MemorySegment LAPACKE_sgtrfs_work$address() {
        return LAPACKE_sgtrfs_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sgtrfs_work(int matrix_layout, char trans, int n, int nrhs, const float *dl, const float *d, const float *du, const float *dlf, const float *df, const float *duf, const float *du2, const int *ipiv, const float *b, int ldb, float *x, int ldx, float *ferr, float *berr, float *work, int *iwork)
     * }
     */
    public static int LAPACKE_sgtrfs_work(int matrix_layout, byte trans, int n, int nrhs, MemorySegment dl, MemorySegment d, MemorySegment du, MemorySegment dlf, MemorySegment df, MemorySegment duf, MemorySegment du2, MemorySegment ipiv, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment ferr, MemorySegment berr, MemorySegment work, MemorySegment iwork) {
        var mh$ = LAPACKE_sgtrfs_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sgtrfs_work", matrix_layout, trans, n, nrhs, dl, d, du, dlf, df, duf, du2, ipiv, b, ldb, x, ldx, ferr, berr, work, iwork);
            }
            return (int)mh$.invokeExact(matrix_layout, trans, n, nrhs, dl, d, du, dlf, df, duf, du2, ipiv, b, ldb, x, ldx, ferr, berr, work, iwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dgtrfs_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dgtrfs_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dgtrfs_work(int matrix_layout, char trans, int n, int nrhs, const double *dl, const double *d, const double *du, const double *dlf, const double *df, const double *duf, const double *du2, const int *ipiv, const double *b, int ldb, double *x, int ldx, double *ferr, double *berr, double *work, int *iwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_dgtrfs_work$descriptor() {
        return LAPACKE_dgtrfs_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dgtrfs_work(int matrix_layout, char trans, int n, int nrhs, const double *dl, const double *d, const double *du, const double *dlf, const double *df, const double *duf, const double *du2, const int *ipiv, const double *b, int ldb, double *x, int ldx, double *ferr, double *berr, double *work, int *iwork)
     * }
     */
    public static MethodHandle LAPACKE_dgtrfs_work$handle() {
        return LAPACKE_dgtrfs_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dgtrfs_work(int matrix_layout, char trans, int n, int nrhs, const double *dl, const double *d, const double *du, const double *dlf, const double *df, const double *duf, const double *du2, const int *ipiv, const double *b, int ldb, double *x, int ldx, double *ferr, double *berr, double *work, int *iwork)
     * }
     */
    public static MemorySegment LAPACKE_dgtrfs_work$address() {
        return LAPACKE_dgtrfs_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dgtrfs_work(int matrix_layout, char trans, int n, int nrhs, const double *dl, const double *d, const double *du, const double *dlf, const double *df, const double *duf, const double *du2, const int *ipiv, const double *b, int ldb, double *x, int ldx, double *ferr, double *berr, double *work, int *iwork)
     * }
     */
    public static int LAPACKE_dgtrfs_work(int matrix_layout, byte trans, int n, int nrhs, MemorySegment dl, MemorySegment d, MemorySegment du, MemorySegment dlf, MemorySegment df, MemorySegment duf, MemorySegment du2, MemorySegment ipiv, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment ferr, MemorySegment berr, MemorySegment work, MemorySegment iwork) {
        var mh$ = LAPACKE_dgtrfs_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dgtrfs_work", matrix_layout, trans, n, nrhs, dl, d, du, dlf, df, duf, du2, ipiv, b, ldb, x, ldx, ferr, berr, work, iwork);
            }
            return (int)mh$.invokeExact(matrix_layout, trans, n, nrhs, dl, d, du, dlf, df, duf, du2, ipiv, b, ldb, x, ldx, ferr, berr, work, iwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cgtrfs_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_cgtrfs_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cgtrfs_work(int matrix_layout, char trans, int n, int nrhs, const _Complex float *dl, const _Complex float *d, const _Complex float *du, const _Complex float *dlf, const _Complex float *df, const _Complex float *duf, const _Complex float *du2, const int *ipiv, const _Complex float *b, int ldb, _Complex float *x, int ldx, float *ferr, float *berr, _Complex float *work, float *rwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_cgtrfs_work$descriptor() {
        return LAPACKE_cgtrfs_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cgtrfs_work(int matrix_layout, char trans, int n, int nrhs, const _Complex float *dl, const _Complex float *d, const _Complex float *du, const _Complex float *dlf, const _Complex float *df, const _Complex float *duf, const _Complex float *du2, const int *ipiv, const _Complex float *b, int ldb, _Complex float *x, int ldx, float *ferr, float *berr, _Complex float *work, float *rwork)
     * }
     */
    public static MethodHandle LAPACKE_cgtrfs_work$handle() {
        return LAPACKE_cgtrfs_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cgtrfs_work(int matrix_layout, char trans, int n, int nrhs, const _Complex float *dl, const _Complex float *d, const _Complex float *du, const _Complex float *dlf, const _Complex float *df, const _Complex float *duf, const _Complex float *du2, const int *ipiv, const _Complex float *b, int ldb, _Complex float *x, int ldx, float *ferr, float *berr, _Complex float *work, float *rwork)
     * }
     */
    public static MemorySegment LAPACKE_cgtrfs_work$address() {
        return LAPACKE_cgtrfs_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cgtrfs_work(int matrix_layout, char trans, int n, int nrhs, const _Complex float *dl, const _Complex float *d, const _Complex float *du, const _Complex float *dlf, const _Complex float *df, const _Complex float *duf, const _Complex float *du2, const int *ipiv, const _Complex float *b, int ldb, _Complex float *x, int ldx, float *ferr, float *berr, _Complex float *work, float *rwork)
     * }
     */
    public static int LAPACKE_cgtrfs_work(int matrix_layout, byte trans, int n, int nrhs, MemorySegment dl, MemorySegment d, MemorySegment du, MemorySegment dlf, MemorySegment df, MemorySegment duf, MemorySegment du2, MemorySegment ipiv, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment ferr, MemorySegment berr, MemorySegment work, MemorySegment rwork) {
        var mh$ = LAPACKE_cgtrfs_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cgtrfs_work", matrix_layout, trans, n, nrhs, dl, d, du, dlf, df, duf, du2, ipiv, b, ldb, x, ldx, ferr, berr, work, rwork);
            }
            return (int)mh$.invokeExact(matrix_layout, trans, n, nrhs, dl, d, du, dlf, df, duf, du2, ipiv, b, ldb, x, ldx, ferr, berr, work, rwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zgtrfs_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zgtrfs_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zgtrfs_work(int matrix_layout, char trans, int n, int nrhs, const _Complex double *dl, const _Complex double *d, const _Complex double *du, const _Complex double *dlf, const _Complex double *df, const _Complex double *duf, const _Complex double *du2, const int *ipiv, const _Complex double *b, int ldb, _Complex double *x, int ldx, double *ferr, double *berr, _Complex double *work, double *rwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_zgtrfs_work$descriptor() {
        return LAPACKE_zgtrfs_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zgtrfs_work(int matrix_layout, char trans, int n, int nrhs, const _Complex double *dl, const _Complex double *d, const _Complex double *du, const _Complex double *dlf, const _Complex double *df, const _Complex double *duf, const _Complex double *du2, const int *ipiv, const _Complex double *b, int ldb, _Complex double *x, int ldx, double *ferr, double *berr, _Complex double *work, double *rwork)
     * }
     */
    public static MethodHandle LAPACKE_zgtrfs_work$handle() {
        return LAPACKE_zgtrfs_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zgtrfs_work(int matrix_layout, char trans, int n, int nrhs, const _Complex double *dl, const _Complex double *d, const _Complex double *du, const _Complex double *dlf, const _Complex double *df, const _Complex double *duf, const _Complex double *du2, const int *ipiv, const _Complex double *b, int ldb, _Complex double *x, int ldx, double *ferr, double *berr, _Complex double *work, double *rwork)
     * }
     */
    public static MemorySegment LAPACKE_zgtrfs_work$address() {
        return LAPACKE_zgtrfs_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zgtrfs_work(int matrix_layout, char trans, int n, int nrhs, const _Complex double *dl, const _Complex double *d, const _Complex double *du, const _Complex double *dlf, const _Complex double *df, const _Complex double *duf, const _Complex double *du2, const int *ipiv, const _Complex double *b, int ldb, _Complex double *x, int ldx, double *ferr, double *berr, _Complex double *work, double *rwork)
     * }
     */
    public static int LAPACKE_zgtrfs_work(int matrix_layout, byte trans, int n, int nrhs, MemorySegment dl, MemorySegment d, MemorySegment du, MemorySegment dlf, MemorySegment df, MemorySegment duf, MemorySegment du2, MemorySegment ipiv, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment ferr, MemorySegment berr, MemorySegment work, MemorySegment rwork) {
        var mh$ = LAPACKE_zgtrfs_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zgtrfs_work", matrix_layout, trans, n, nrhs, dl, d, du, dlf, df, duf, du2, ipiv, b, ldb, x, ldx, ferr, berr, work, rwork);
            }
            return (int)mh$.invokeExact(matrix_layout, trans, n, nrhs, dl, d, du, dlf, df, duf, du2, ipiv, b, ldb, x, ldx, ferr, berr, work, rwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sgtsv_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_sgtsv_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sgtsv_work(int matrix_layout, int n, int nrhs, float *dl, float *d, float *du, float *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_sgtsv_work$descriptor() {
        return LAPACKE_sgtsv_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sgtsv_work(int matrix_layout, int n, int nrhs, float *dl, float *d, float *du, float *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_sgtsv_work$handle() {
        return LAPACKE_sgtsv_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sgtsv_work(int matrix_layout, int n, int nrhs, float *dl, float *d, float *du, float *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_sgtsv_work$address() {
        return LAPACKE_sgtsv_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sgtsv_work(int matrix_layout, int n, int nrhs, float *dl, float *d, float *du, float *b, int ldb)
     * }
     */
    public static int LAPACKE_sgtsv_work(int matrix_layout, int n, int nrhs, MemorySegment dl, MemorySegment d, MemorySegment du, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_sgtsv_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sgtsv_work", matrix_layout, n, nrhs, dl, d, du, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, n, nrhs, dl, d, du, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dgtsv_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dgtsv_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dgtsv_work(int matrix_layout, int n, int nrhs, double *dl, double *d, double *du, double *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_dgtsv_work$descriptor() {
        return LAPACKE_dgtsv_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dgtsv_work(int matrix_layout, int n, int nrhs, double *dl, double *d, double *du, double *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_dgtsv_work$handle() {
        return LAPACKE_dgtsv_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dgtsv_work(int matrix_layout, int n, int nrhs, double *dl, double *d, double *du, double *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_dgtsv_work$address() {
        return LAPACKE_dgtsv_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dgtsv_work(int matrix_layout, int n, int nrhs, double *dl, double *d, double *du, double *b, int ldb)
     * }
     */
    public static int LAPACKE_dgtsv_work(int matrix_layout, int n, int nrhs, MemorySegment dl, MemorySegment d, MemorySegment du, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_dgtsv_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dgtsv_work", matrix_layout, n, nrhs, dl, d, du, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, n, nrhs, dl, d, du, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cgtsv_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_cgtsv_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cgtsv_work(int matrix_layout, int n, int nrhs, _Complex float *dl, _Complex float *d, _Complex float *du, _Complex float *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_cgtsv_work$descriptor() {
        return LAPACKE_cgtsv_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cgtsv_work(int matrix_layout, int n, int nrhs, _Complex float *dl, _Complex float *d, _Complex float *du, _Complex float *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_cgtsv_work$handle() {
        return LAPACKE_cgtsv_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cgtsv_work(int matrix_layout, int n, int nrhs, _Complex float *dl, _Complex float *d, _Complex float *du, _Complex float *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_cgtsv_work$address() {
        return LAPACKE_cgtsv_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cgtsv_work(int matrix_layout, int n, int nrhs, _Complex float *dl, _Complex float *d, _Complex float *du, _Complex float *b, int ldb)
     * }
     */
    public static int LAPACKE_cgtsv_work(int matrix_layout, int n, int nrhs, MemorySegment dl, MemorySegment d, MemorySegment du, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_cgtsv_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cgtsv_work", matrix_layout, n, nrhs, dl, d, du, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, n, nrhs, dl, d, du, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zgtsv_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zgtsv_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zgtsv_work(int matrix_layout, int n, int nrhs, _Complex double *dl, _Complex double *d, _Complex double *du, _Complex double *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_zgtsv_work$descriptor() {
        return LAPACKE_zgtsv_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zgtsv_work(int matrix_layout, int n, int nrhs, _Complex double *dl, _Complex double *d, _Complex double *du, _Complex double *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_zgtsv_work$handle() {
        return LAPACKE_zgtsv_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zgtsv_work(int matrix_layout, int n, int nrhs, _Complex double *dl, _Complex double *d, _Complex double *du, _Complex double *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_zgtsv_work$address() {
        return LAPACKE_zgtsv_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zgtsv_work(int matrix_layout, int n, int nrhs, _Complex double *dl, _Complex double *d, _Complex double *du, _Complex double *b, int ldb)
     * }
     */
    public static int LAPACKE_zgtsv_work(int matrix_layout, int n, int nrhs, MemorySegment dl, MemorySegment d, MemorySegment du, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_zgtsv_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zgtsv_work", matrix_layout, n, nrhs, dl, d, du, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, n, nrhs, dl, d, du, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sgtsvx_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_sgtsvx_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sgtsvx_work(int matrix_layout, char fact, char trans, int n, int nrhs, const float *dl, const float *d, const float *du, float *dlf, float *df, float *duf, float *du2, int *ipiv, const float *b, int ldb, float *x, int ldx, float *rcond, float *ferr, float *berr, float *work, int *iwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_sgtsvx_work$descriptor() {
        return LAPACKE_sgtsvx_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sgtsvx_work(int matrix_layout, char fact, char trans, int n, int nrhs, const float *dl, const float *d, const float *du, float *dlf, float *df, float *duf, float *du2, int *ipiv, const float *b, int ldb, float *x, int ldx, float *rcond, float *ferr, float *berr, float *work, int *iwork)
     * }
     */
    public static MethodHandle LAPACKE_sgtsvx_work$handle() {
        return LAPACKE_sgtsvx_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sgtsvx_work(int matrix_layout, char fact, char trans, int n, int nrhs, const float *dl, const float *d, const float *du, float *dlf, float *df, float *duf, float *du2, int *ipiv, const float *b, int ldb, float *x, int ldx, float *rcond, float *ferr, float *berr, float *work, int *iwork)
     * }
     */
    public static MemorySegment LAPACKE_sgtsvx_work$address() {
        return LAPACKE_sgtsvx_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sgtsvx_work(int matrix_layout, char fact, char trans, int n, int nrhs, const float *dl, const float *d, const float *du, float *dlf, float *df, float *duf, float *du2, int *ipiv, const float *b, int ldb, float *x, int ldx, float *rcond, float *ferr, float *berr, float *work, int *iwork)
     * }
     */
    public static int LAPACKE_sgtsvx_work(int matrix_layout, byte fact, byte trans, int n, int nrhs, MemorySegment dl, MemorySegment d, MemorySegment du, MemorySegment dlf, MemorySegment df, MemorySegment duf, MemorySegment du2, MemorySegment ipiv, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment rcond, MemorySegment ferr, MemorySegment berr, MemorySegment work, MemorySegment iwork) {
        var mh$ = LAPACKE_sgtsvx_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sgtsvx_work", matrix_layout, fact, trans, n, nrhs, dl, d, du, dlf, df, duf, du2, ipiv, b, ldb, x, ldx, rcond, ferr, berr, work, iwork);
            }
            return (int)mh$.invokeExact(matrix_layout, fact, trans, n, nrhs, dl, d, du, dlf, df, duf, du2, ipiv, b, ldb, x, ldx, rcond, ferr, berr, work, iwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dgtsvx_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dgtsvx_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dgtsvx_work(int matrix_layout, char fact, char trans, int n, int nrhs, const double *dl, const double *d, const double *du, double *dlf, double *df, double *duf, double *du2, int *ipiv, const double *b, int ldb, double *x, int ldx, double *rcond, double *ferr, double *berr, double *work, int *iwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_dgtsvx_work$descriptor() {
        return LAPACKE_dgtsvx_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dgtsvx_work(int matrix_layout, char fact, char trans, int n, int nrhs, const double *dl, const double *d, const double *du, double *dlf, double *df, double *duf, double *du2, int *ipiv, const double *b, int ldb, double *x, int ldx, double *rcond, double *ferr, double *berr, double *work, int *iwork)
     * }
     */
    public static MethodHandle LAPACKE_dgtsvx_work$handle() {
        return LAPACKE_dgtsvx_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dgtsvx_work(int matrix_layout, char fact, char trans, int n, int nrhs, const double *dl, const double *d, const double *du, double *dlf, double *df, double *duf, double *du2, int *ipiv, const double *b, int ldb, double *x, int ldx, double *rcond, double *ferr, double *berr, double *work, int *iwork)
     * }
     */
    public static MemorySegment LAPACKE_dgtsvx_work$address() {
        return LAPACKE_dgtsvx_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dgtsvx_work(int matrix_layout, char fact, char trans, int n, int nrhs, const double *dl, const double *d, const double *du, double *dlf, double *df, double *duf, double *du2, int *ipiv, const double *b, int ldb, double *x, int ldx, double *rcond, double *ferr, double *berr, double *work, int *iwork)
     * }
     */
    public static int LAPACKE_dgtsvx_work(int matrix_layout, byte fact, byte trans, int n, int nrhs, MemorySegment dl, MemorySegment d, MemorySegment du, MemorySegment dlf, MemorySegment df, MemorySegment duf, MemorySegment du2, MemorySegment ipiv, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment rcond, MemorySegment ferr, MemorySegment berr, MemorySegment work, MemorySegment iwork) {
        var mh$ = LAPACKE_dgtsvx_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dgtsvx_work", matrix_layout, fact, trans, n, nrhs, dl, d, du, dlf, df, duf, du2, ipiv, b, ldb, x, ldx, rcond, ferr, berr, work, iwork);
            }
            return (int)mh$.invokeExact(matrix_layout, fact, trans, n, nrhs, dl, d, du, dlf, df, duf, du2, ipiv, b, ldb, x, ldx, rcond, ferr, berr, work, iwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cgtsvx_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_cgtsvx_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cgtsvx_work(int matrix_layout, char fact, char trans, int n, int nrhs, const _Complex float *dl, const _Complex float *d, const _Complex float *du, _Complex float *dlf, _Complex float *df, _Complex float *duf, _Complex float *du2, int *ipiv, const _Complex float *b, int ldb, _Complex float *x, int ldx, float *rcond, float *ferr, float *berr, _Complex float *work, float *rwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_cgtsvx_work$descriptor() {
        return LAPACKE_cgtsvx_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cgtsvx_work(int matrix_layout, char fact, char trans, int n, int nrhs, const _Complex float *dl, const _Complex float *d, const _Complex float *du, _Complex float *dlf, _Complex float *df, _Complex float *duf, _Complex float *du2, int *ipiv, const _Complex float *b, int ldb, _Complex float *x, int ldx, float *rcond, float *ferr, float *berr, _Complex float *work, float *rwork)
     * }
     */
    public static MethodHandle LAPACKE_cgtsvx_work$handle() {
        return LAPACKE_cgtsvx_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cgtsvx_work(int matrix_layout, char fact, char trans, int n, int nrhs, const _Complex float *dl, const _Complex float *d, const _Complex float *du, _Complex float *dlf, _Complex float *df, _Complex float *duf, _Complex float *du2, int *ipiv, const _Complex float *b, int ldb, _Complex float *x, int ldx, float *rcond, float *ferr, float *berr, _Complex float *work, float *rwork)
     * }
     */
    public static MemorySegment LAPACKE_cgtsvx_work$address() {
        return LAPACKE_cgtsvx_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cgtsvx_work(int matrix_layout, char fact, char trans, int n, int nrhs, const _Complex float *dl, const _Complex float *d, const _Complex float *du, _Complex float *dlf, _Complex float *df, _Complex float *duf, _Complex float *du2, int *ipiv, const _Complex float *b, int ldb, _Complex float *x, int ldx, float *rcond, float *ferr, float *berr, _Complex float *work, float *rwork)
     * }
     */
    public static int LAPACKE_cgtsvx_work(int matrix_layout, byte fact, byte trans, int n, int nrhs, MemorySegment dl, MemorySegment d, MemorySegment du, MemorySegment dlf, MemorySegment df, MemorySegment duf, MemorySegment du2, MemorySegment ipiv, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment rcond, MemorySegment ferr, MemorySegment berr, MemorySegment work, MemorySegment rwork) {
        var mh$ = LAPACKE_cgtsvx_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cgtsvx_work", matrix_layout, fact, trans, n, nrhs, dl, d, du, dlf, df, duf, du2, ipiv, b, ldb, x, ldx, rcond, ferr, berr, work, rwork);
            }
            return (int)mh$.invokeExact(matrix_layout, fact, trans, n, nrhs, dl, d, du, dlf, df, duf, du2, ipiv, b, ldb, x, ldx, rcond, ferr, berr, work, rwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zgtsvx_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zgtsvx_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zgtsvx_work(int matrix_layout, char fact, char trans, int n, int nrhs, const _Complex double *dl, const _Complex double *d, const _Complex double *du, _Complex double *dlf, _Complex double *df, _Complex double *duf, _Complex double *du2, int *ipiv, const _Complex double *b, int ldb, _Complex double *x, int ldx, double *rcond, double *ferr, double *berr, _Complex double *work, double *rwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_zgtsvx_work$descriptor() {
        return LAPACKE_zgtsvx_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zgtsvx_work(int matrix_layout, char fact, char trans, int n, int nrhs, const _Complex double *dl, const _Complex double *d, const _Complex double *du, _Complex double *dlf, _Complex double *df, _Complex double *duf, _Complex double *du2, int *ipiv, const _Complex double *b, int ldb, _Complex double *x, int ldx, double *rcond, double *ferr, double *berr, _Complex double *work, double *rwork)
     * }
     */
    public static MethodHandle LAPACKE_zgtsvx_work$handle() {
        return LAPACKE_zgtsvx_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zgtsvx_work(int matrix_layout, char fact, char trans, int n, int nrhs, const _Complex double *dl, const _Complex double *d, const _Complex double *du, _Complex double *dlf, _Complex double *df, _Complex double *duf, _Complex double *du2, int *ipiv, const _Complex double *b, int ldb, _Complex double *x, int ldx, double *rcond, double *ferr, double *berr, _Complex double *work, double *rwork)
     * }
     */
    public static MemorySegment LAPACKE_zgtsvx_work$address() {
        return LAPACKE_zgtsvx_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zgtsvx_work(int matrix_layout, char fact, char trans, int n, int nrhs, const _Complex double *dl, const _Complex double *d, const _Complex double *du, _Complex double *dlf, _Complex double *df, _Complex double *duf, _Complex double *du2, int *ipiv, const _Complex double *b, int ldb, _Complex double *x, int ldx, double *rcond, double *ferr, double *berr, _Complex double *work, double *rwork)
     * }
     */
    public static int LAPACKE_zgtsvx_work(int matrix_layout, byte fact, byte trans, int n, int nrhs, MemorySegment dl, MemorySegment d, MemorySegment du, MemorySegment dlf, MemorySegment df, MemorySegment duf, MemorySegment du2, MemorySegment ipiv, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment rcond, MemorySegment ferr, MemorySegment berr, MemorySegment work, MemorySegment rwork) {
        var mh$ = LAPACKE_zgtsvx_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zgtsvx_work", matrix_layout, fact, trans, n, nrhs, dl, d, du, dlf, df, duf, du2, ipiv, b, ldb, x, ldx, rcond, ferr, berr, work, rwork);
            }
            return (int)mh$.invokeExact(matrix_layout, fact, trans, n, nrhs, dl, d, du, dlf, df, duf, du2, ipiv, b, ldb, x, ldx, rcond, ferr, berr, work, rwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sgttrf_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_sgttrf_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sgttrf_work(int n, float *dl, float *d, float *du, float *du2, int *ipiv)
     * }
     */
    public static FunctionDescriptor LAPACKE_sgttrf_work$descriptor() {
        return LAPACKE_sgttrf_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sgttrf_work(int n, float *dl, float *d, float *du, float *du2, int *ipiv)
     * }
     */
    public static MethodHandle LAPACKE_sgttrf_work$handle() {
        return LAPACKE_sgttrf_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sgttrf_work(int n, float *dl, float *d, float *du, float *du2, int *ipiv)
     * }
     */
    public static MemorySegment LAPACKE_sgttrf_work$address() {
        return LAPACKE_sgttrf_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sgttrf_work(int n, float *dl, float *d, float *du, float *du2, int *ipiv)
     * }
     */
    public static int LAPACKE_sgttrf_work(int n, MemorySegment dl, MemorySegment d, MemorySegment du, MemorySegment du2, MemorySegment ipiv) {
        var mh$ = LAPACKE_sgttrf_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sgttrf_work", n, dl, d, du, du2, ipiv);
            }
            return (int)mh$.invokeExact(n, dl, d, du, du2, ipiv);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dgttrf_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dgttrf_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dgttrf_work(int n, double *dl, double *d, double *du, double *du2, int *ipiv)
     * }
     */
    public static FunctionDescriptor LAPACKE_dgttrf_work$descriptor() {
        return LAPACKE_dgttrf_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dgttrf_work(int n, double *dl, double *d, double *du, double *du2, int *ipiv)
     * }
     */
    public static MethodHandle LAPACKE_dgttrf_work$handle() {
        return LAPACKE_dgttrf_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dgttrf_work(int n, double *dl, double *d, double *du, double *du2, int *ipiv)
     * }
     */
    public static MemorySegment LAPACKE_dgttrf_work$address() {
        return LAPACKE_dgttrf_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dgttrf_work(int n, double *dl, double *d, double *du, double *du2, int *ipiv)
     * }
     */
    public static int LAPACKE_dgttrf_work(int n, MemorySegment dl, MemorySegment d, MemorySegment du, MemorySegment du2, MemorySegment ipiv) {
        var mh$ = LAPACKE_dgttrf_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dgttrf_work", n, dl, d, du, du2, ipiv);
            }
            return (int)mh$.invokeExact(n, dl, d, du, du2, ipiv);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cgttrf_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_cgttrf_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cgttrf_work(int n, _Complex float *dl, _Complex float *d, _Complex float *du, _Complex float *du2, int *ipiv)
     * }
     */
    public static FunctionDescriptor LAPACKE_cgttrf_work$descriptor() {
        return LAPACKE_cgttrf_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cgttrf_work(int n, _Complex float *dl, _Complex float *d, _Complex float *du, _Complex float *du2, int *ipiv)
     * }
     */
    public static MethodHandle LAPACKE_cgttrf_work$handle() {
        return LAPACKE_cgttrf_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cgttrf_work(int n, _Complex float *dl, _Complex float *d, _Complex float *du, _Complex float *du2, int *ipiv)
     * }
     */
    public static MemorySegment LAPACKE_cgttrf_work$address() {
        return LAPACKE_cgttrf_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cgttrf_work(int n, _Complex float *dl, _Complex float *d, _Complex float *du, _Complex float *du2, int *ipiv)
     * }
     */
    public static int LAPACKE_cgttrf_work(int n, MemorySegment dl, MemorySegment d, MemorySegment du, MemorySegment du2, MemorySegment ipiv) {
        var mh$ = LAPACKE_cgttrf_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cgttrf_work", n, dl, d, du, du2, ipiv);
            }
            return (int)mh$.invokeExact(n, dl, d, du, du2, ipiv);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zgttrf_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zgttrf_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zgttrf_work(int n, _Complex double *dl, _Complex double *d, _Complex double *du, _Complex double *du2, int *ipiv)
     * }
     */
    public static FunctionDescriptor LAPACKE_zgttrf_work$descriptor() {
        return LAPACKE_zgttrf_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zgttrf_work(int n, _Complex double *dl, _Complex double *d, _Complex double *du, _Complex double *du2, int *ipiv)
     * }
     */
    public static MethodHandle LAPACKE_zgttrf_work$handle() {
        return LAPACKE_zgttrf_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zgttrf_work(int n, _Complex double *dl, _Complex double *d, _Complex double *du, _Complex double *du2, int *ipiv)
     * }
     */
    public static MemorySegment LAPACKE_zgttrf_work$address() {
        return LAPACKE_zgttrf_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zgttrf_work(int n, _Complex double *dl, _Complex double *d, _Complex double *du, _Complex double *du2, int *ipiv)
     * }
     */
    public static int LAPACKE_zgttrf_work(int n, MemorySegment dl, MemorySegment d, MemorySegment du, MemorySegment du2, MemorySegment ipiv) {
        var mh$ = LAPACKE_zgttrf_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zgttrf_work", n, dl, d, du, du2, ipiv);
            }
            return (int)mh$.invokeExact(n, dl, d, du, du2, ipiv);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sgttrs_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_sgttrs_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sgttrs_work(int matrix_layout, char trans, int n, int nrhs, const float *dl, const float *d, const float *du, const float *du2, const int *ipiv, float *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_sgttrs_work$descriptor() {
        return LAPACKE_sgttrs_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sgttrs_work(int matrix_layout, char trans, int n, int nrhs, const float *dl, const float *d, const float *du, const float *du2, const int *ipiv, float *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_sgttrs_work$handle() {
        return LAPACKE_sgttrs_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sgttrs_work(int matrix_layout, char trans, int n, int nrhs, const float *dl, const float *d, const float *du, const float *du2, const int *ipiv, float *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_sgttrs_work$address() {
        return LAPACKE_sgttrs_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sgttrs_work(int matrix_layout, char trans, int n, int nrhs, const float *dl, const float *d, const float *du, const float *du2, const int *ipiv, float *b, int ldb)
     * }
     */
    public static int LAPACKE_sgttrs_work(int matrix_layout, byte trans, int n, int nrhs, MemorySegment dl, MemorySegment d, MemorySegment du, MemorySegment du2, MemorySegment ipiv, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_sgttrs_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sgttrs_work", matrix_layout, trans, n, nrhs, dl, d, du, du2, ipiv, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, trans, n, nrhs, dl, d, du, du2, ipiv, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dgttrs_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dgttrs_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dgttrs_work(int matrix_layout, char trans, int n, int nrhs, const double *dl, const double *d, const double *du, const double *du2, const int *ipiv, double *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_dgttrs_work$descriptor() {
        return LAPACKE_dgttrs_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dgttrs_work(int matrix_layout, char trans, int n, int nrhs, const double *dl, const double *d, const double *du, const double *du2, const int *ipiv, double *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_dgttrs_work$handle() {
        return LAPACKE_dgttrs_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dgttrs_work(int matrix_layout, char trans, int n, int nrhs, const double *dl, const double *d, const double *du, const double *du2, const int *ipiv, double *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_dgttrs_work$address() {
        return LAPACKE_dgttrs_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dgttrs_work(int matrix_layout, char trans, int n, int nrhs, const double *dl, const double *d, const double *du, const double *du2, const int *ipiv, double *b, int ldb)
     * }
     */
    public static int LAPACKE_dgttrs_work(int matrix_layout, byte trans, int n, int nrhs, MemorySegment dl, MemorySegment d, MemorySegment du, MemorySegment du2, MemorySegment ipiv, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_dgttrs_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dgttrs_work", matrix_layout, trans, n, nrhs, dl, d, du, du2, ipiv, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, trans, n, nrhs, dl, d, du, du2, ipiv, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cgttrs_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_cgttrs_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cgttrs_work(int matrix_layout, char trans, int n, int nrhs, const _Complex float *dl, const _Complex float *d, const _Complex float *du, const _Complex float *du2, const int *ipiv, _Complex float *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_cgttrs_work$descriptor() {
        return LAPACKE_cgttrs_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cgttrs_work(int matrix_layout, char trans, int n, int nrhs, const _Complex float *dl, const _Complex float *d, const _Complex float *du, const _Complex float *du2, const int *ipiv, _Complex float *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_cgttrs_work$handle() {
        return LAPACKE_cgttrs_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cgttrs_work(int matrix_layout, char trans, int n, int nrhs, const _Complex float *dl, const _Complex float *d, const _Complex float *du, const _Complex float *du2, const int *ipiv, _Complex float *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_cgttrs_work$address() {
        return LAPACKE_cgttrs_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cgttrs_work(int matrix_layout, char trans, int n, int nrhs, const _Complex float *dl, const _Complex float *d, const _Complex float *du, const _Complex float *du2, const int *ipiv, _Complex float *b, int ldb)
     * }
     */
    public static int LAPACKE_cgttrs_work(int matrix_layout, byte trans, int n, int nrhs, MemorySegment dl, MemorySegment d, MemorySegment du, MemorySegment du2, MemorySegment ipiv, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_cgttrs_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cgttrs_work", matrix_layout, trans, n, nrhs, dl, d, du, du2, ipiv, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, trans, n, nrhs, dl, d, du, du2, ipiv, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zgttrs_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zgttrs_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zgttrs_work(int matrix_layout, char trans, int n, int nrhs, const _Complex double *dl, const _Complex double *d, const _Complex double *du, const _Complex double *du2, const int *ipiv, _Complex double *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_zgttrs_work$descriptor() {
        return LAPACKE_zgttrs_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zgttrs_work(int matrix_layout, char trans, int n, int nrhs, const _Complex double *dl, const _Complex double *d, const _Complex double *du, const _Complex double *du2, const int *ipiv, _Complex double *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_zgttrs_work$handle() {
        return LAPACKE_zgttrs_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zgttrs_work(int matrix_layout, char trans, int n, int nrhs, const _Complex double *dl, const _Complex double *d, const _Complex double *du, const _Complex double *du2, const int *ipiv, _Complex double *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_zgttrs_work$address() {
        return LAPACKE_zgttrs_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zgttrs_work(int matrix_layout, char trans, int n, int nrhs, const _Complex double *dl, const _Complex double *d, const _Complex double *du, const _Complex double *du2, const int *ipiv, _Complex double *b, int ldb)
     * }
     */
    public static int LAPACKE_zgttrs_work(int matrix_layout, byte trans, int n, int nrhs, MemorySegment dl, MemorySegment d, MemorySegment du, MemorySegment du2, MemorySegment ipiv, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_zgttrs_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zgttrs_work", matrix_layout, trans, n, nrhs, dl, d, du, du2, ipiv, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, trans, n, nrhs, dl, d, du, du2, ipiv, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_chbev_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_chbev_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_chbev_work(int matrix_layout, char jobz, char uplo, int n, int kd, _Complex float *ab, int ldab, float *w, _Complex float *z, int ldz, _Complex float *work, float *rwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_chbev_work$descriptor() {
        return LAPACKE_chbev_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_chbev_work(int matrix_layout, char jobz, char uplo, int n, int kd, _Complex float *ab, int ldab, float *w, _Complex float *z, int ldz, _Complex float *work, float *rwork)
     * }
     */
    public static MethodHandle LAPACKE_chbev_work$handle() {
        return LAPACKE_chbev_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_chbev_work(int matrix_layout, char jobz, char uplo, int n, int kd, _Complex float *ab, int ldab, float *w, _Complex float *z, int ldz, _Complex float *work, float *rwork)
     * }
     */
    public static MemorySegment LAPACKE_chbev_work$address() {
        return LAPACKE_chbev_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_chbev_work(int matrix_layout, char jobz, char uplo, int n, int kd, _Complex float *ab, int ldab, float *w, _Complex float *z, int ldz, _Complex float *work, float *rwork)
     * }
     */
    public static int LAPACKE_chbev_work(int matrix_layout, byte jobz, byte uplo, int n, int kd, MemorySegment ab, int ldab, MemorySegment w, MemorySegment z, int ldz, MemorySegment work, MemorySegment rwork) {
        var mh$ = LAPACKE_chbev_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_chbev_work", matrix_layout, jobz, uplo, n, kd, ab, ldab, w, z, ldz, work, rwork);
            }
            return (int)mh$.invokeExact(matrix_layout, jobz, uplo, n, kd, ab, ldab, w, z, ldz, work, rwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zhbev_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zhbev_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zhbev_work(int matrix_layout, char jobz, char uplo, int n, int kd, _Complex double *ab, int ldab, double *w, _Complex double *z, int ldz, _Complex double *work, double *rwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_zhbev_work$descriptor() {
        return LAPACKE_zhbev_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zhbev_work(int matrix_layout, char jobz, char uplo, int n, int kd, _Complex double *ab, int ldab, double *w, _Complex double *z, int ldz, _Complex double *work, double *rwork)
     * }
     */
    public static MethodHandle LAPACKE_zhbev_work$handle() {
        return LAPACKE_zhbev_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zhbev_work(int matrix_layout, char jobz, char uplo, int n, int kd, _Complex double *ab, int ldab, double *w, _Complex double *z, int ldz, _Complex double *work, double *rwork)
     * }
     */
    public static MemorySegment LAPACKE_zhbev_work$address() {
        return LAPACKE_zhbev_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zhbev_work(int matrix_layout, char jobz, char uplo, int n, int kd, _Complex double *ab, int ldab, double *w, _Complex double *z, int ldz, _Complex double *work, double *rwork)
     * }
     */
    public static int LAPACKE_zhbev_work(int matrix_layout, byte jobz, byte uplo, int n, int kd, MemorySegment ab, int ldab, MemorySegment w, MemorySegment z, int ldz, MemorySegment work, MemorySegment rwork) {
        var mh$ = LAPACKE_zhbev_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zhbev_work", matrix_layout, jobz, uplo, n, kd, ab, ldab, w, z, ldz, work, rwork);
            }
            return (int)mh$.invokeExact(matrix_layout, jobz, uplo, n, kd, ab, ldab, w, z, ldz, work, rwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_chbevd_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_chbevd_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_chbevd_work(int matrix_layout, char jobz, char uplo, int n, int kd, _Complex float *ab, int ldab, float *w, _Complex float *z, int ldz, _Complex float *work, int lwork, float *rwork, int lrwork, int *iwork, int liwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_chbevd_work$descriptor() {
        return LAPACKE_chbevd_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_chbevd_work(int matrix_layout, char jobz, char uplo, int n, int kd, _Complex float *ab, int ldab, float *w, _Complex float *z, int ldz, _Complex float *work, int lwork, float *rwork, int lrwork, int *iwork, int liwork)
     * }
     */
    public static MethodHandle LAPACKE_chbevd_work$handle() {
        return LAPACKE_chbevd_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_chbevd_work(int matrix_layout, char jobz, char uplo, int n, int kd, _Complex float *ab, int ldab, float *w, _Complex float *z, int ldz, _Complex float *work, int lwork, float *rwork, int lrwork, int *iwork, int liwork)
     * }
     */
    public static MemorySegment LAPACKE_chbevd_work$address() {
        return LAPACKE_chbevd_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_chbevd_work(int matrix_layout, char jobz, char uplo, int n, int kd, _Complex float *ab, int ldab, float *w, _Complex float *z, int ldz, _Complex float *work, int lwork, float *rwork, int lrwork, int *iwork, int liwork)
     * }
     */
    public static int LAPACKE_chbevd_work(int matrix_layout, byte jobz, byte uplo, int n, int kd, MemorySegment ab, int ldab, MemorySegment w, MemorySegment z, int ldz, MemorySegment work, int lwork, MemorySegment rwork, int lrwork, MemorySegment iwork, int liwork) {
        var mh$ = LAPACKE_chbevd_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_chbevd_work", matrix_layout, jobz, uplo, n, kd, ab, ldab, w, z, ldz, work, lwork, rwork, lrwork, iwork, liwork);
            }
            return (int)mh$.invokeExact(matrix_layout, jobz, uplo, n, kd, ab, ldab, w, z, ldz, work, lwork, rwork, lrwork, iwork, liwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zhbevd_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zhbevd_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zhbevd_work(int matrix_layout, char jobz, char uplo, int n, int kd, _Complex double *ab, int ldab, double *w, _Complex double *z, int ldz, _Complex double *work, int lwork, double *rwork, int lrwork, int *iwork, int liwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_zhbevd_work$descriptor() {
        return LAPACKE_zhbevd_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zhbevd_work(int matrix_layout, char jobz, char uplo, int n, int kd, _Complex double *ab, int ldab, double *w, _Complex double *z, int ldz, _Complex double *work, int lwork, double *rwork, int lrwork, int *iwork, int liwork)
     * }
     */
    public static MethodHandle LAPACKE_zhbevd_work$handle() {
        return LAPACKE_zhbevd_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zhbevd_work(int matrix_layout, char jobz, char uplo, int n, int kd, _Complex double *ab, int ldab, double *w, _Complex double *z, int ldz, _Complex double *work, int lwork, double *rwork, int lrwork, int *iwork, int liwork)
     * }
     */
    public static MemorySegment LAPACKE_zhbevd_work$address() {
        return LAPACKE_zhbevd_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zhbevd_work(int matrix_layout, char jobz, char uplo, int n, int kd, _Complex double *ab, int ldab, double *w, _Complex double *z, int ldz, _Complex double *work, int lwork, double *rwork, int lrwork, int *iwork, int liwork)
     * }
     */
    public static int LAPACKE_zhbevd_work(int matrix_layout, byte jobz, byte uplo, int n, int kd, MemorySegment ab, int ldab, MemorySegment w, MemorySegment z, int ldz, MemorySegment work, int lwork, MemorySegment rwork, int lrwork, MemorySegment iwork, int liwork) {
        var mh$ = LAPACKE_zhbevd_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zhbevd_work", matrix_layout, jobz, uplo, n, kd, ab, ldab, w, z, ldz, work, lwork, rwork, lrwork, iwork, liwork);
            }
            return (int)mh$.invokeExact(matrix_layout, jobz, uplo, n, kd, ab, ldab, w, z, ldz, work, lwork, rwork, lrwork, iwork, liwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_chbevx_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_FLOAT,
            lapacke_h.C_FLOAT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_FLOAT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_chbevx_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_chbevx_work(int matrix_layout, char jobz, char range, char uplo, int n, int kd, _Complex float *ab, int ldab, _Complex float *q, int ldq, float vl, float vu, int il, int iu, float abstol, int *m, float *w, _Complex float *z, int ldz, _Complex float *work, float *rwork, int *iwork, int *ifail)
     * }
     */
    public static FunctionDescriptor LAPACKE_chbevx_work$descriptor() {
        return LAPACKE_chbevx_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_chbevx_work(int matrix_layout, char jobz, char range, char uplo, int n, int kd, _Complex float *ab, int ldab, _Complex float *q, int ldq, float vl, float vu, int il, int iu, float abstol, int *m, float *w, _Complex float *z, int ldz, _Complex float *work, float *rwork, int *iwork, int *ifail)
     * }
     */
    public static MethodHandle LAPACKE_chbevx_work$handle() {
        return LAPACKE_chbevx_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_chbevx_work(int matrix_layout, char jobz, char range, char uplo, int n, int kd, _Complex float *ab, int ldab, _Complex float *q, int ldq, float vl, float vu, int il, int iu, float abstol, int *m, float *w, _Complex float *z, int ldz, _Complex float *work, float *rwork, int *iwork, int *ifail)
     * }
     */
    public static MemorySegment LAPACKE_chbevx_work$address() {
        return LAPACKE_chbevx_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_chbevx_work(int matrix_layout, char jobz, char range, char uplo, int n, int kd, _Complex float *ab, int ldab, _Complex float *q, int ldq, float vl, float vu, int il, int iu, float abstol, int *m, float *w, _Complex float *z, int ldz, _Complex float *work, float *rwork, int *iwork, int *ifail)
     * }
     */
    public static int LAPACKE_chbevx_work(int matrix_layout, byte jobz, byte range, byte uplo, int n, int kd, MemorySegment ab, int ldab, MemorySegment q, int ldq, float vl, float vu, int il, int iu, float abstol, MemorySegment m, MemorySegment w, MemorySegment z, int ldz, MemorySegment work, MemorySegment rwork, MemorySegment iwork, MemorySegment ifail) {
        var mh$ = LAPACKE_chbevx_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_chbevx_work", matrix_layout, jobz, range, uplo, n, kd, ab, ldab, q, ldq, vl, vu, il, iu, abstol, m, w, z, ldz, work, rwork, iwork, ifail);
            }
            return (int)mh$.invokeExact(matrix_layout, jobz, range, uplo, n, kd, ab, ldab, q, ldq, vl, vu, il, iu, abstol, m, w, z, ldz, work, rwork, iwork, ifail);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zhbevx_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_DOUBLE,
            lapacke_h.C_DOUBLE,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_DOUBLE,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zhbevx_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zhbevx_work(int matrix_layout, char jobz, char range, char uplo, int n, int kd, _Complex double *ab, int ldab, _Complex double *q, int ldq, double vl, double vu, int il, int iu, double abstol, int *m, double *w, _Complex double *z, int ldz, _Complex double *work, double *rwork, int *iwork, int *ifail)
     * }
     */
    public static FunctionDescriptor LAPACKE_zhbevx_work$descriptor() {
        return LAPACKE_zhbevx_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zhbevx_work(int matrix_layout, char jobz, char range, char uplo, int n, int kd, _Complex double *ab, int ldab, _Complex double *q, int ldq, double vl, double vu, int il, int iu, double abstol, int *m, double *w, _Complex double *z, int ldz, _Complex double *work, double *rwork, int *iwork, int *ifail)
     * }
     */
    public static MethodHandle LAPACKE_zhbevx_work$handle() {
        return LAPACKE_zhbevx_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zhbevx_work(int matrix_layout, char jobz, char range, char uplo, int n, int kd, _Complex double *ab, int ldab, _Complex double *q, int ldq, double vl, double vu, int il, int iu, double abstol, int *m, double *w, _Complex double *z, int ldz, _Complex double *work, double *rwork, int *iwork, int *ifail)
     * }
     */
    public static MemorySegment LAPACKE_zhbevx_work$address() {
        return LAPACKE_zhbevx_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zhbevx_work(int matrix_layout, char jobz, char range, char uplo, int n, int kd, _Complex double *ab, int ldab, _Complex double *q, int ldq, double vl, double vu, int il, int iu, double abstol, int *m, double *w, _Complex double *z, int ldz, _Complex double *work, double *rwork, int *iwork, int *ifail)
     * }
     */
    public static int LAPACKE_zhbevx_work(int matrix_layout, byte jobz, byte range, byte uplo, int n, int kd, MemorySegment ab, int ldab, MemorySegment q, int ldq, double vl, double vu, int il, int iu, double abstol, MemorySegment m, MemorySegment w, MemorySegment z, int ldz, MemorySegment work, MemorySegment rwork, MemorySegment iwork, MemorySegment ifail) {
        var mh$ = LAPACKE_zhbevx_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zhbevx_work", matrix_layout, jobz, range, uplo, n, kd, ab, ldab, q, ldq, vl, vu, il, iu, abstol, m, w, z, ldz, work, rwork, iwork, ifail);
            }
            return (int)mh$.invokeExact(matrix_layout, jobz, range, uplo, n, kd, ab, ldab, q, ldq, vl, vu, il, iu, abstol, m, w, z, ldz, work, rwork, iwork, ifail);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_chbgst_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_chbgst_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_chbgst_work(int matrix_layout, char vect, char uplo, int n, int ka, int kb, _Complex float *ab, int ldab, const _Complex float *bb, int ldbb, _Complex float *x, int ldx, _Complex float *work, float *rwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_chbgst_work$descriptor() {
        return LAPACKE_chbgst_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_chbgst_work(int matrix_layout, char vect, char uplo, int n, int ka, int kb, _Complex float *ab, int ldab, const _Complex float *bb, int ldbb, _Complex float *x, int ldx, _Complex float *work, float *rwork)
     * }
     */
    public static MethodHandle LAPACKE_chbgst_work$handle() {
        return LAPACKE_chbgst_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_chbgst_work(int matrix_layout, char vect, char uplo, int n, int ka, int kb, _Complex float *ab, int ldab, const _Complex float *bb, int ldbb, _Complex float *x, int ldx, _Complex float *work, float *rwork)
     * }
     */
    public static MemorySegment LAPACKE_chbgst_work$address() {
        return LAPACKE_chbgst_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_chbgst_work(int matrix_layout, char vect, char uplo, int n, int ka, int kb, _Complex float *ab, int ldab, const _Complex float *bb, int ldbb, _Complex float *x, int ldx, _Complex float *work, float *rwork)
     * }
     */
    public static int LAPACKE_chbgst_work(int matrix_layout, byte vect, byte uplo, int n, int ka, int kb, MemorySegment ab, int ldab, MemorySegment bb, int ldbb, MemorySegment x, int ldx, MemorySegment work, MemorySegment rwork) {
        var mh$ = LAPACKE_chbgst_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_chbgst_work", matrix_layout, vect, uplo, n, ka, kb, ab, ldab, bb, ldbb, x, ldx, work, rwork);
            }
            return (int)mh$.invokeExact(matrix_layout, vect, uplo, n, ka, kb, ab, ldab, bb, ldbb, x, ldx, work, rwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zhbgst_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zhbgst_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zhbgst_work(int matrix_layout, char vect, char uplo, int n, int ka, int kb, _Complex double *ab, int ldab, const _Complex double *bb, int ldbb, _Complex double *x, int ldx, _Complex double *work, double *rwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_zhbgst_work$descriptor() {
        return LAPACKE_zhbgst_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zhbgst_work(int matrix_layout, char vect, char uplo, int n, int ka, int kb, _Complex double *ab, int ldab, const _Complex double *bb, int ldbb, _Complex double *x, int ldx, _Complex double *work, double *rwork)
     * }
     */
    public static MethodHandle LAPACKE_zhbgst_work$handle() {
        return LAPACKE_zhbgst_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zhbgst_work(int matrix_layout, char vect, char uplo, int n, int ka, int kb, _Complex double *ab, int ldab, const _Complex double *bb, int ldbb, _Complex double *x, int ldx, _Complex double *work, double *rwork)
     * }
     */
    public static MemorySegment LAPACKE_zhbgst_work$address() {
        return LAPACKE_zhbgst_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zhbgst_work(int matrix_layout, char vect, char uplo, int n, int ka, int kb, _Complex double *ab, int ldab, const _Complex double *bb, int ldbb, _Complex double *x, int ldx, _Complex double *work, double *rwork)
     * }
     */
    public static int LAPACKE_zhbgst_work(int matrix_layout, byte vect, byte uplo, int n, int ka, int kb, MemorySegment ab, int ldab, MemorySegment bb, int ldbb, MemorySegment x, int ldx, MemorySegment work, MemorySegment rwork) {
        var mh$ = LAPACKE_zhbgst_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zhbgst_work", matrix_layout, vect, uplo, n, ka, kb, ab, ldab, bb, ldbb, x, ldx, work, rwork);
            }
            return (int)mh$.invokeExact(matrix_layout, vect, uplo, n, ka, kb, ab, ldab, bb, ldbb, x, ldx, work, rwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_chbgv_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_chbgv_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_chbgv_work(int matrix_layout, char jobz, char uplo, int n, int ka, int kb, _Complex float *ab, int ldab, _Complex float *bb, int ldbb, float *w, _Complex float *z, int ldz, _Complex float *work, float *rwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_chbgv_work$descriptor() {
        return LAPACKE_chbgv_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_chbgv_work(int matrix_layout, char jobz, char uplo, int n, int ka, int kb, _Complex float *ab, int ldab, _Complex float *bb, int ldbb, float *w, _Complex float *z, int ldz, _Complex float *work, float *rwork)
     * }
     */
    public static MethodHandle LAPACKE_chbgv_work$handle() {
        return LAPACKE_chbgv_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_chbgv_work(int matrix_layout, char jobz, char uplo, int n, int ka, int kb, _Complex float *ab, int ldab, _Complex float *bb, int ldbb, float *w, _Complex float *z, int ldz, _Complex float *work, float *rwork)
     * }
     */
    public static MemorySegment LAPACKE_chbgv_work$address() {
        return LAPACKE_chbgv_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_chbgv_work(int matrix_layout, char jobz, char uplo, int n, int ka, int kb, _Complex float *ab, int ldab, _Complex float *bb, int ldbb, float *w, _Complex float *z, int ldz, _Complex float *work, float *rwork)
     * }
     */
    public static int LAPACKE_chbgv_work(int matrix_layout, byte jobz, byte uplo, int n, int ka, int kb, MemorySegment ab, int ldab, MemorySegment bb, int ldbb, MemorySegment w, MemorySegment z, int ldz, MemorySegment work, MemorySegment rwork) {
        var mh$ = LAPACKE_chbgv_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_chbgv_work", matrix_layout, jobz, uplo, n, ka, kb, ab, ldab, bb, ldbb, w, z, ldz, work, rwork);
            }
            return (int)mh$.invokeExact(matrix_layout, jobz, uplo, n, ka, kb, ab, ldab, bb, ldbb, w, z, ldz, work, rwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zhbgv_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zhbgv_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zhbgv_work(int matrix_layout, char jobz, char uplo, int n, int ka, int kb, _Complex double *ab, int ldab, _Complex double *bb, int ldbb, double *w, _Complex double *z, int ldz, _Complex double *work, double *rwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_zhbgv_work$descriptor() {
        return LAPACKE_zhbgv_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zhbgv_work(int matrix_layout, char jobz, char uplo, int n, int ka, int kb, _Complex double *ab, int ldab, _Complex double *bb, int ldbb, double *w, _Complex double *z, int ldz, _Complex double *work, double *rwork)
     * }
     */
    public static MethodHandle LAPACKE_zhbgv_work$handle() {
        return LAPACKE_zhbgv_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zhbgv_work(int matrix_layout, char jobz, char uplo, int n, int ka, int kb, _Complex double *ab, int ldab, _Complex double *bb, int ldbb, double *w, _Complex double *z, int ldz, _Complex double *work, double *rwork)
     * }
     */
    public static MemorySegment LAPACKE_zhbgv_work$address() {
        return LAPACKE_zhbgv_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zhbgv_work(int matrix_layout, char jobz, char uplo, int n, int ka, int kb, _Complex double *ab, int ldab, _Complex double *bb, int ldbb, double *w, _Complex double *z, int ldz, _Complex double *work, double *rwork)
     * }
     */
    public static int LAPACKE_zhbgv_work(int matrix_layout, byte jobz, byte uplo, int n, int ka, int kb, MemorySegment ab, int ldab, MemorySegment bb, int ldbb, MemorySegment w, MemorySegment z, int ldz, MemorySegment work, MemorySegment rwork) {
        var mh$ = LAPACKE_zhbgv_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zhbgv_work", matrix_layout, jobz, uplo, n, ka, kb, ab, ldab, bb, ldbb, w, z, ldz, work, rwork);
            }
            return (int)mh$.invokeExact(matrix_layout, jobz, uplo, n, ka, kb, ab, ldab, bb, ldbb, w, z, ldz, work, rwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_chbgvd_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_chbgvd_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_chbgvd_work(int matrix_layout, char jobz, char uplo, int n, int ka, int kb, _Complex float *ab, int ldab, _Complex float *bb, int ldbb, float *w, _Complex float *z, int ldz, _Complex float *work, int lwork, float *rwork, int lrwork, int *iwork, int liwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_chbgvd_work$descriptor() {
        return LAPACKE_chbgvd_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_chbgvd_work(int matrix_layout, char jobz, char uplo, int n, int ka, int kb, _Complex float *ab, int ldab, _Complex float *bb, int ldbb, float *w, _Complex float *z, int ldz, _Complex float *work, int lwork, float *rwork, int lrwork, int *iwork, int liwork)
     * }
     */
    public static MethodHandle LAPACKE_chbgvd_work$handle() {
        return LAPACKE_chbgvd_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_chbgvd_work(int matrix_layout, char jobz, char uplo, int n, int ka, int kb, _Complex float *ab, int ldab, _Complex float *bb, int ldbb, float *w, _Complex float *z, int ldz, _Complex float *work, int lwork, float *rwork, int lrwork, int *iwork, int liwork)
     * }
     */
    public static MemorySegment LAPACKE_chbgvd_work$address() {
        return LAPACKE_chbgvd_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_chbgvd_work(int matrix_layout, char jobz, char uplo, int n, int ka, int kb, _Complex float *ab, int ldab, _Complex float *bb, int ldbb, float *w, _Complex float *z, int ldz, _Complex float *work, int lwork, float *rwork, int lrwork, int *iwork, int liwork)
     * }
     */
    public static int LAPACKE_chbgvd_work(int matrix_layout, byte jobz, byte uplo, int n, int ka, int kb, MemorySegment ab, int ldab, MemorySegment bb, int ldbb, MemorySegment w, MemorySegment z, int ldz, MemorySegment work, int lwork, MemorySegment rwork, int lrwork, MemorySegment iwork, int liwork) {
        var mh$ = LAPACKE_chbgvd_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_chbgvd_work", matrix_layout, jobz, uplo, n, ka, kb, ab, ldab, bb, ldbb, w, z, ldz, work, lwork, rwork, lrwork, iwork, liwork);
            }
            return (int)mh$.invokeExact(matrix_layout, jobz, uplo, n, ka, kb, ab, ldab, bb, ldbb, w, z, ldz, work, lwork, rwork, lrwork, iwork, liwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zhbgvd_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zhbgvd_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zhbgvd_work(int matrix_layout, char jobz, char uplo, int n, int ka, int kb, _Complex double *ab, int ldab, _Complex double *bb, int ldbb, double *w, _Complex double *z, int ldz, _Complex double *work, int lwork, double *rwork, int lrwork, int *iwork, int liwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_zhbgvd_work$descriptor() {
        return LAPACKE_zhbgvd_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zhbgvd_work(int matrix_layout, char jobz, char uplo, int n, int ka, int kb, _Complex double *ab, int ldab, _Complex double *bb, int ldbb, double *w, _Complex double *z, int ldz, _Complex double *work, int lwork, double *rwork, int lrwork, int *iwork, int liwork)
     * }
     */
    public static MethodHandle LAPACKE_zhbgvd_work$handle() {
        return LAPACKE_zhbgvd_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zhbgvd_work(int matrix_layout, char jobz, char uplo, int n, int ka, int kb, _Complex double *ab, int ldab, _Complex double *bb, int ldbb, double *w, _Complex double *z, int ldz, _Complex double *work, int lwork, double *rwork, int lrwork, int *iwork, int liwork)
     * }
     */
    public static MemorySegment LAPACKE_zhbgvd_work$address() {
        return LAPACKE_zhbgvd_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zhbgvd_work(int matrix_layout, char jobz, char uplo, int n, int ka, int kb, _Complex double *ab, int ldab, _Complex double *bb, int ldbb, double *w, _Complex double *z, int ldz, _Complex double *work, int lwork, double *rwork, int lrwork, int *iwork, int liwork)
     * }
     */
    public static int LAPACKE_zhbgvd_work(int matrix_layout, byte jobz, byte uplo, int n, int ka, int kb, MemorySegment ab, int ldab, MemorySegment bb, int ldbb, MemorySegment w, MemorySegment z, int ldz, MemorySegment work, int lwork, MemorySegment rwork, int lrwork, MemorySegment iwork, int liwork) {
        var mh$ = LAPACKE_zhbgvd_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zhbgvd_work", matrix_layout, jobz, uplo, n, ka, kb, ab, ldab, bb, ldbb, w, z, ldz, work, lwork, rwork, lrwork, iwork, liwork);
            }
            return (int)mh$.invokeExact(matrix_layout, jobz, uplo, n, ka, kb, ab, ldab, bb, ldbb, w, z, ldz, work, lwork, rwork, lrwork, iwork, liwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_chbgvx_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_FLOAT,
            lapacke_h.C_FLOAT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_FLOAT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_chbgvx_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_chbgvx_work(int matrix_layout, char jobz, char range, char uplo, int n, int ka, int kb, _Complex float *ab, int ldab, _Complex float *bb, int ldbb, _Complex float *q, int ldq, float vl, float vu, int il, int iu, float abstol, int *m, float *w, _Complex float *z, int ldz, _Complex float *work, float *rwork, int *iwork, int *ifail)
     * }
     */
    public static FunctionDescriptor LAPACKE_chbgvx_work$descriptor() {
        return LAPACKE_chbgvx_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_chbgvx_work(int matrix_layout, char jobz, char range, char uplo, int n, int ka, int kb, _Complex float *ab, int ldab, _Complex float *bb, int ldbb, _Complex float *q, int ldq, float vl, float vu, int il, int iu, float abstol, int *m, float *w, _Complex float *z, int ldz, _Complex float *work, float *rwork, int *iwork, int *ifail)
     * }
     */
    public static MethodHandle LAPACKE_chbgvx_work$handle() {
        return LAPACKE_chbgvx_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_chbgvx_work(int matrix_layout, char jobz, char range, char uplo, int n, int ka, int kb, _Complex float *ab, int ldab, _Complex float *bb, int ldbb, _Complex float *q, int ldq, float vl, float vu, int il, int iu, float abstol, int *m, float *w, _Complex float *z, int ldz, _Complex float *work, float *rwork, int *iwork, int *ifail)
     * }
     */
    public static MemorySegment LAPACKE_chbgvx_work$address() {
        return LAPACKE_chbgvx_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_chbgvx_work(int matrix_layout, char jobz, char range, char uplo, int n, int ka, int kb, _Complex float *ab, int ldab, _Complex float *bb, int ldbb, _Complex float *q, int ldq, float vl, float vu, int il, int iu, float abstol, int *m, float *w, _Complex float *z, int ldz, _Complex float *work, float *rwork, int *iwork, int *ifail)
     * }
     */
    public static int LAPACKE_chbgvx_work(int matrix_layout, byte jobz, byte range, byte uplo, int n, int ka, int kb, MemorySegment ab, int ldab, MemorySegment bb, int ldbb, MemorySegment q, int ldq, float vl, float vu, int il, int iu, float abstol, MemorySegment m, MemorySegment w, MemorySegment z, int ldz, MemorySegment work, MemorySegment rwork, MemorySegment iwork, MemorySegment ifail) {
        var mh$ = LAPACKE_chbgvx_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_chbgvx_work", matrix_layout, jobz, range, uplo, n, ka, kb, ab, ldab, bb, ldbb, q, ldq, vl, vu, il, iu, abstol, m, w, z, ldz, work, rwork, iwork, ifail);
            }
            return (int)mh$.invokeExact(matrix_layout, jobz, range, uplo, n, ka, kb, ab, ldab, bb, ldbb, q, ldq, vl, vu, il, iu, abstol, m, w, z, ldz, work, rwork, iwork, ifail);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zhbgvx_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_DOUBLE,
            lapacke_h.C_DOUBLE,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_DOUBLE,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zhbgvx_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zhbgvx_work(int matrix_layout, char jobz, char range, char uplo, int n, int ka, int kb, _Complex double *ab, int ldab, _Complex double *bb, int ldbb, _Complex double *q, int ldq, double vl, double vu, int il, int iu, double abstol, int *m, double *w, _Complex double *z, int ldz, _Complex double *work, double *rwork, int *iwork, int *ifail)
     * }
     */
    public static FunctionDescriptor LAPACKE_zhbgvx_work$descriptor() {
        return LAPACKE_zhbgvx_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zhbgvx_work(int matrix_layout, char jobz, char range, char uplo, int n, int ka, int kb, _Complex double *ab, int ldab, _Complex double *bb, int ldbb, _Complex double *q, int ldq, double vl, double vu, int il, int iu, double abstol, int *m, double *w, _Complex double *z, int ldz, _Complex double *work, double *rwork, int *iwork, int *ifail)
     * }
     */
    public static MethodHandle LAPACKE_zhbgvx_work$handle() {
        return LAPACKE_zhbgvx_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zhbgvx_work(int matrix_layout, char jobz, char range, char uplo, int n, int ka, int kb, _Complex double *ab, int ldab, _Complex double *bb, int ldbb, _Complex double *q, int ldq, double vl, double vu, int il, int iu, double abstol, int *m, double *w, _Complex double *z, int ldz, _Complex double *work, double *rwork, int *iwork, int *ifail)
     * }
     */
    public static MemorySegment LAPACKE_zhbgvx_work$address() {
        return LAPACKE_zhbgvx_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zhbgvx_work(int matrix_layout, char jobz, char range, char uplo, int n, int ka, int kb, _Complex double *ab, int ldab, _Complex double *bb, int ldbb, _Complex double *q, int ldq, double vl, double vu, int il, int iu, double abstol, int *m, double *w, _Complex double *z, int ldz, _Complex double *work, double *rwork, int *iwork, int *ifail)
     * }
     */
    public static int LAPACKE_zhbgvx_work(int matrix_layout, byte jobz, byte range, byte uplo, int n, int ka, int kb, MemorySegment ab, int ldab, MemorySegment bb, int ldbb, MemorySegment q, int ldq, double vl, double vu, int il, int iu, double abstol, MemorySegment m, MemorySegment w, MemorySegment z, int ldz, MemorySegment work, MemorySegment rwork, MemorySegment iwork, MemorySegment ifail) {
        var mh$ = LAPACKE_zhbgvx_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zhbgvx_work", matrix_layout, jobz, range, uplo, n, ka, kb, ab, ldab, bb, ldbb, q, ldq, vl, vu, il, iu, abstol, m, w, z, ldz, work, rwork, iwork, ifail);
            }
            return (int)mh$.invokeExact(matrix_layout, jobz, range, uplo, n, ka, kb, ab, ldab, bb, ldbb, q, ldq, vl, vu, il, iu, abstol, m, w, z, ldz, work, rwork, iwork, ifail);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_chbtrd_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_chbtrd_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_chbtrd_work(int matrix_layout, char vect, char uplo, int n, int kd, _Complex float *ab, int ldab, float *d, float *e, _Complex float *q, int ldq, _Complex float *work)
     * }
     */
    public static FunctionDescriptor LAPACKE_chbtrd_work$descriptor() {
        return LAPACKE_chbtrd_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_chbtrd_work(int matrix_layout, char vect, char uplo, int n, int kd, _Complex float *ab, int ldab, float *d, float *e, _Complex float *q, int ldq, _Complex float *work)
     * }
     */
    public static MethodHandle LAPACKE_chbtrd_work$handle() {
        return LAPACKE_chbtrd_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_chbtrd_work(int matrix_layout, char vect, char uplo, int n, int kd, _Complex float *ab, int ldab, float *d, float *e, _Complex float *q, int ldq, _Complex float *work)
     * }
     */
    public static MemorySegment LAPACKE_chbtrd_work$address() {
        return LAPACKE_chbtrd_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_chbtrd_work(int matrix_layout, char vect, char uplo, int n, int kd, _Complex float *ab, int ldab, float *d, float *e, _Complex float *q, int ldq, _Complex float *work)
     * }
     */
    public static int LAPACKE_chbtrd_work(int matrix_layout, byte vect, byte uplo, int n, int kd, MemorySegment ab, int ldab, MemorySegment d, MemorySegment e, MemorySegment q, int ldq, MemorySegment work) {
        var mh$ = LAPACKE_chbtrd_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_chbtrd_work", matrix_layout, vect, uplo, n, kd, ab, ldab, d, e, q, ldq, work);
            }
            return (int)mh$.invokeExact(matrix_layout, vect, uplo, n, kd, ab, ldab, d, e, q, ldq, work);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zhbtrd_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zhbtrd_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zhbtrd_work(int matrix_layout, char vect, char uplo, int n, int kd, _Complex double *ab, int ldab, double *d, double *e, _Complex double *q, int ldq, _Complex double *work)
     * }
     */
    public static FunctionDescriptor LAPACKE_zhbtrd_work$descriptor() {
        return LAPACKE_zhbtrd_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zhbtrd_work(int matrix_layout, char vect, char uplo, int n, int kd, _Complex double *ab, int ldab, double *d, double *e, _Complex double *q, int ldq, _Complex double *work)
     * }
     */
    public static MethodHandle LAPACKE_zhbtrd_work$handle() {
        return LAPACKE_zhbtrd_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zhbtrd_work(int matrix_layout, char vect, char uplo, int n, int kd, _Complex double *ab, int ldab, double *d, double *e, _Complex double *q, int ldq, _Complex double *work)
     * }
     */
    public static MemorySegment LAPACKE_zhbtrd_work$address() {
        return LAPACKE_zhbtrd_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zhbtrd_work(int matrix_layout, char vect, char uplo, int n, int kd, _Complex double *ab, int ldab, double *d, double *e, _Complex double *q, int ldq, _Complex double *work)
     * }
     */
    public static int LAPACKE_zhbtrd_work(int matrix_layout, byte vect, byte uplo, int n, int kd, MemorySegment ab, int ldab, MemorySegment d, MemorySegment e, MemorySegment q, int ldq, MemorySegment work) {
        var mh$ = LAPACKE_zhbtrd_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zhbtrd_work", matrix_layout, vect, uplo, n, kd, ab, ldab, d, e, q, ldq, work);
            }
            return (int)mh$.invokeExact(matrix_layout, vect, uplo, n, kd, ab, ldab, d, e, q, ldq, work);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_checon_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_FLOAT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_checon_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_checon_work(int matrix_layout, char uplo, int n, const _Complex float *a, int lda, const int *ipiv, float anorm, float *rcond, _Complex float *work)
     * }
     */
    public static FunctionDescriptor LAPACKE_checon_work$descriptor() {
        return LAPACKE_checon_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_checon_work(int matrix_layout, char uplo, int n, const _Complex float *a, int lda, const int *ipiv, float anorm, float *rcond, _Complex float *work)
     * }
     */
    public static MethodHandle LAPACKE_checon_work$handle() {
        return LAPACKE_checon_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_checon_work(int matrix_layout, char uplo, int n, const _Complex float *a, int lda, const int *ipiv, float anorm, float *rcond, _Complex float *work)
     * }
     */
    public static MemorySegment LAPACKE_checon_work$address() {
        return LAPACKE_checon_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_checon_work(int matrix_layout, char uplo, int n, const _Complex float *a, int lda, const int *ipiv, float anorm, float *rcond, _Complex float *work)
     * }
     */
    public static int LAPACKE_checon_work(int matrix_layout, byte uplo, int n, MemorySegment a, int lda, MemorySegment ipiv, float anorm, MemorySegment rcond, MemorySegment work) {
        var mh$ = LAPACKE_checon_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_checon_work", matrix_layout, uplo, n, a, lda, ipiv, anorm, rcond, work);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, a, lda, ipiv, anorm, rcond, work);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zhecon_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_DOUBLE,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zhecon_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zhecon_work(int matrix_layout, char uplo, int n, const _Complex double *a, int lda, const int *ipiv, double anorm, double *rcond, _Complex double *work)
     * }
     */
    public static FunctionDescriptor LAPACKE_zhecon_work$descriptor() {
        return LAPACKE_zhecon_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zhecon_work(int matrix_layout, char uplo, int n, const _Complex double *a, int lda, const int *ipiv, double anorm, double *rcond, _Complex double *work)
     * }
     */
    public static MethodHandle LAPACKE_zhecon_work$handle() {
        return LAPACKE_zhecon_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zhecon_work(int matrix_layout, char uplo, int n, const _Complex double *a, int lda, const int *ipiv, double anorm, double *rcond, _Complex double *work)
     * }
     */
    public static MemorySegment LAPACKE_zhecon_work$address() {
        return LAPACKE_zhecon_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zhecon_work(int matrix_layout, char uplo, int n, const _Complex double *a, int lda, const int *ipiv, double anorm, double *rcond, _Complex double *work)
     * }
     */
    public static int LAPACKE_zhecon_work(int matrix_layout, byte uplo, int n, MemorySegment a, int lda, MemorySegment ipiv, double anorm, MemorySegment rcond, MemorySegment work) {
        var mh$ = LAPACKE_zhecon_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zhecon_work", matrix_layout, uplo, n, a, lda, ipiv, anorm, rcond, work);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, a, lda, ipiv, anorm, rcond, work);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cheequb_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_cheequb_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cheequb_work(int matrix_layout, char uplo, int n, const _Complex float *a, int lda, float *s, float *scond, float *amax, _Complex float *work)
     * }
     */
    public static FunctionDescriptor LAPACKE_cheequb_work$descriptor() {
        return LAPACKE_cheequb_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cheequb_work(int matrix_layout, char uplo, int n, const _Complex float *a, int lda, float *s, float *scond, float *amax, _Complex float *work)
     * }
     */
    public static MethodHandle LAPACKE_cheequb_work$handle() {
        return LAPACKE_cheequb_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cheequb_work(int matrix_layout, char uplo, int n, const _Complex float *a, int lda, float *s, float *scond, float *amax, _Complex float *work)
     * }
     */
    public static MemorySegment LAPACKE_cheequb_work$address() {
        return LAPACKE_cheequb_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cheequb_work(int matrix_layout, char uplo, int n, const _Complex float *a, int lda, float *s, float *scond, float *amax, _Complex float *work)
     * }
     */
    public static int LAPACKE_cheequb_work(int matrix_layout, byte uplo, int n, MemorySegment a, int lda, MemorySegment s, MemorySegment scond, MemorySegment amax, MemorySegment work) {
        var mh$ = LAPACKE_cheequb_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cheequb_work", matrix_layout, uplo, n, a, lda, s, scond, amax, work);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, a, lda, s, scond, amax, work);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zheequb_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zheequb_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zheequb_work(int matrix_layout, char uplo, int n, const _Complex double *a, int lda, double *s, double *scond, double *amax, _Complex double *work)
     * }
     */
    public static FunctionDescriptor LAPACKE_zheequb_work$descriptor() {
        return LAPACKE_zheequb_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zheequb_work(int matrix_layout, char uplo, int n, const _Complex double *a, int lda, double *s, double *scond, double *amax, _Complex double *work)
     * }
     */
    public static MethodHandle LAPACKE_zheequb_work$handle() {
        return LAPACKE_zheequb_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zheequb_work(int matrix_layout, char uplo, int n, const _Complex double *a, int lda, double *s, double *scond, double *amax, _Complex double *work)
     * }
     */
    public static MemorySegment LAPACKE_zheequb_work$address() {
        return LAPACKE_zheequb_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zheequb_work(int matrix_layout, char uplo, int n, const _Complex double *a, int lda, double *s, double *scond, double *amax, _Complex double *work)
     * }
     */
    public static int LAPACKE_zheequb_work(int matrix_layout, byte uplo, int n, MemorySegment a, int lda, MemorySegment s, MemorySegment scond, MemorySegment amax, MemorySegment work) {
        var mh$ = LAPACKE_zheequb_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zheequb_work", matrix_layout, uplo, n, a, lda, s, scond, amax, work);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, a, lda, s, scond, amax, work);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cheev_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_cheev_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cheev_work(int matrix_layout, char jobz, char uplo, int n, _Complex float *a, int lda, float *w, _Complex float *work, int lwork, float *rwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_cheev_work$descriptor() {
        return LAPACKE_cheev_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cheev_work(int matrix_layout, char jobz, char uplo, int n, _Complex float *a, int lda, float *w, _Complex float *work, int lwork, float *rwork)
     * }
     */
    public static MethodHandle LAPACKE_cheev_work$handle() {
        return LAPACKE_cheev_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cheev_work(int matrix_layout, char jobz, char uplo, int n, _Complex float *a, int lda, float *w, _Complex float *work, int lwork, float *rwork)
     * }
     */
    public static MemorySegment LAPACKE_cheev_work$address() {
        return LAPACKE_cheev_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cheev_work(int matrix_layout, char jobz, char uplo, int n, _Complex float *a, int lda, float *w, _Complex float *work, int lwork, float *rwork)
     * }
     */
    public static int LAPACKE_cheev_work(int matrix_layout, byte jobz, byte uplo, int n, MemorySegment a, int lda, MemorySegment w, MemorySegment work, int lwork, MemorySegment rwork) {
        var mh$ = LAPACKE_cheev_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cheev_work", matrix_layout, jobz, uplo, n, a, lda, w, work, lwork, rwork);
            }
            return (int)mh$.invokeExact(matrix_layout, jobz, uplo, n, a, lda, w, work, lwork, rwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zheev_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zheev_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zheev_work(int matrix_layout, char jobz, char uplo, int n, _Complex double *a, int lda, double *w, _Complex double *work, int lwork, double *rwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_zheev_work$descriptor() {
        return LAPACKE_zheev_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zheev_work(int matrix_layout, char jobz, char uplo, int n, _Complex double *a, int lda, double *w, _Complex double *work, int lwork, double *rwork)
     * }
     */
    public static MethodHandle LAPACKE_zheev_work$handle() {
        return LAPACKE_zheev_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zheev_work(int matrix_layout, char jobz, char uplo, int n, _Complex double *a, int lda, double *w, _Complex double *work, int lwork, double *rwork)
     * }
     */
    public static MemorySegment LAPACKE_zheev_work$address() {
        return LAPACKE_zheev_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zheev_work(int matrix_layout, char jobz, char uplo, int n, _Complex double *a, int lda, double *w, _Complex double *work, int lwork, double *rwork)
     * }
     */
    public static int LAPACKE_zheev_work(int matrix_layout, byte jobz, byte uplo, int n, MemorySegment a, int lda, MemorySegment w, MemorySegment work, int lwork, MemorySegment rwork) {
        var mh$ = LAPACKE_zheev_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zheev_work", matrix_layout, jobz, uplo, n, a, lda, w, work, lwork, rwork);
            }
            return (int)mh$.invokeExact(matrix_layout, jobz, uplo, n, a, lda, w, work, lwork, rwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cheevd_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_cheevd_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cheevd_work(int matrix_layout, char jobz, char uplo, int n, _Complex float *a, int lda, float *w, _Complex float *work, int lwork, float *rwork, int lrwork, int *iwork, int liwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_cheevd_work$descriptor() {
        return LAPACKE_cheevd_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cheevd_work(int matrix_layout, char jobz, char uplo, int n, _Complex float *a, int lda, float *w, _Complex float *work, int lwork, float *rwork, int lrwork, int *iwork, int liwork)
     * }
     */
    public static MethodHandle LAPACKE_cheevd_work$handle() {
        return LAPACKE_cheevd_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cheevd_work(int matrix_layout, char jobz, char uplo, int n, _Complex float *a, int lda, float *w, _Complex float *work, int lwork, float *rwork, int lrwork, int *iwork, int liwork)
     * }
     */
    public static MemorySegment LAPACKE_cheevd_work$address() {
        return LAPACKE_cheevd_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cheevd_work(int matrix_layout, char jobz, char uplo, int n, _Complex float *a, int lda, float *w, _Complex float *work, int lwork, float *rwork, int lrwork, int *iwork, int liwork)
     * }
     */
    public static int LAPACKE_cheevd_work(int matrix_layout, byte jobz, byte uplo, int n, MemorySegment a, int lda, MemorySegment w, MemorySegment work, int lwork, MemorySegment rwork, int lrwork, MemorySegment iwork, int liwork) {
        var mh$ = LAPACKE_cheevd_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cheevd_work", matrix_layout, jobz, uplo, n, a, lda, w, work, lwork, rwork, lrwork, iwork, liwork);
            }
            return (int)mh$.invokeExact(matrix_layout, jobz, uplo, n, a, lda, w, work, lwork, rwork, lrwork, iwork, liwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zheevd_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zheevd_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zheevd_work(int matrix_layout, char jobz, char uplo, int n, _Complex double *a, int lda, double *w, _Complex double *work, int lwork, double *rwork, int lrwork, int *iwork, int liwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_zheevd_work$descriptor() {
        return LAPACKE_zheevd_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zheevd_work(int matrix_layout, char jobz, char uplo, int n, _Complex double *a, int lda, double *w, _Complex double *work, int lwork, double *rwork, int lrwork, int *iwork, int liwork)
     * }
     */
    public static MethodHandle LAPACKE_zheevd_work$handle() {
        return LAPACKE_zheevd_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zheevd_work(int matrix_layout, char jobz, char uplo, int n, _Complex double *a, int lda, double *w, _Complex double *work, int lwork, double *rwork, int lrwork, int *iwork, int liwork)
     * }
     */
    public static MemorySegment LAPACKE_zheevd_work$address() {
        return LAPACKE_zheevd_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zheevd_work(int matrix_layout, char jobz, char uplo, int n, _Complex double *a, int lda, double *w, _Complex double *work, int lwork, double *rwork, int lrwork, int *iwork, int liwork)
     * }
     */
    public static int LAPACKE_zheevd_work(int matrix_layout, byte jobz, byte uplo, int n, MemorySegment a, int lda, MemorySegment w, MemorySegment work, int lwork, MemorySegment rwork, int lrwork, MemorySegment iwork, int liwork) {
        var mh$ = LAPACKE_zheevd_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zheevd_work", matrix_layout, jobz, uplo, n, a, lda, w, work, lwork, rwork, lrwork, iwork, liwork);
            }
            return (int)mh$.invokeExact(matrix_layout, jobz, uplo, n, a, lda, w, work, lwork, rwork, lrwork, iwork, liwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cheevr_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_FLOAT,
            lapacke_h.C_FLOAT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_FLOAT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_cheevr_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cheevr_work(int matrix_layout, char jobz, char range, char uplo, int n, _Complex float *a, int lda, float vl, float vu, int il, int iu, float abstol, int *m, float *w, _Complex float *z, int ldz, int *isuppz, _Complex float *work, int lwork, float *rwork, int lrwork, int *iwork, int liwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_cheevr_work$descriptor() {
        return LAPACKE_cheevr_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cheevr_work(int matrix_layout, char jobz, char range, char uplo, int n, _Complex float *a, int lda, float vl, float vu, int il, int iu, float abstol, int *m, float *w, _Complex float *z, int ldz, int *isuppz, _Complex float *work, int lwork, float *rwork, int lrwork, int *iwork, int liwork)
     * }
     */
    public static MethodHandle LAPACKE_cheevr_work$handle() {
        return LAPACKE_cheevr_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cheevr_work(int matrix_layout, char jobz, char range, char uplo, int n, _Complex float *a, int lda, float vl, float vu, int il, int iu, float abstol, int *m, float *w, _Complex float *z, int ldz, int *isuppz, _Complex float *work, int lwork, float *rwork, int lrwork, int *iwork, int liwork)
     * }
     */
    public static MemorySegment LAPACKE_cheevr_work$address() {
        return LAPACKE_cheevr_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cheevr_work(int matrix_layout, char jobz, char range, char uplo, int n, _Complex float *a, int lda, float vl, float vu, int il, int iu, float abstol, int *m, float *w, _Complex float *z, int ldz, int *isuppz, _Complex float *work, int lwork, float *rwork, int lrwork, int *iwork, int liwork)
     * }
     */
    public static int LAPACKE_cheevr_work(int matrix_layout, byte jobz, byte range, byte uplo, int n, MemorySegment a, int lda, float vl, float vu, int il, int iu, float abstol, MemorySegment m, MemorySegment w, MemorySegment z, int ldz, MemorySegment isuppz, MemorySegment work, int lwork, MemorySegment rwork, int lrwork, MemorySegment iwork, int liwork) {
        var mh$ = LAPACKE_cheevr_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cheevr_work", matrix_layout, jobz, range, uplo, n, a, lda, vl, vu, il, iu, abstol, m, w, z, ldz, isuppz, work, lwork, rwork, lrwork, iwork, liwork);
            }
            return (int)mh$.invokeExact(matrix_layout, jobz, range, uplo, n, a, lda, vl, vu, il, iu, abstol, m, w, z, ldz, isuppz, work, lwork, rwork, lrwork, iwork, liwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zheevr_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_DOUBLE,
            lapacke_h.C_DOUBLE,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_DOUBLE,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zheevr_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zheevr_work(int matrix_layout, char jobz, char range, char uplo, int n, _Complex double *a, int lda, double vl, double vu, int il, int iu, double abstol, int *m, double *w, _Complex double *z, int ldz, int *isuppz, _Complex double *work, int lwork, double *rwork, int lrwork, int *iwork, int liwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_zheevr_work$descriptor() {
        return LAPACKE_zheevr_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zheevr_work(int matrix_layout, char jobz, char range, char uplo, int n, _Complex double *a, int lda, double vl, double vu, int il, int iu, double abstol, int *m, double *w, _Complex double *z, int ldz, int *isuppz, _Complex double *work, int lwork, double *rwork, int lrwork, int *iwork, int liwork)
     * }
     */
    public static MethodHandle LAPACKE_zheevr_work$handle() {
        return LAPACKE_zheevr_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zheevr_work(int matrix_layout, char jobz, char range, char uplo, int n, _Complex double *a, int lda, double vl, double vu, int il, int iu, double abstol, int *m, double *w, _Complex double *z, int ldz, int *isuppz, _Complex double *work, int lwork, double *rwork, int lrwork, int *iwork, int liwork)
     * }
     */
    public static MemorySegment LAPACKE_zheevr_work$address() {
        return LAPACKE_zheevr_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zheevr_work(int matrix_layout, char jobz, char range, char uplo, int n, _Complex double *a, int lda, double vl, double vu, int il, int iu, double abstol, int *m, double *w, _Complex double *z, int ldz, int *isuppz, _Complex double *work, int lwork, double *rwork, int lrwork, int *iwork, int liwork)
     * }
     */
    public static int LAPACKE_zheevr_work(int matrix_layout, byte jobz, byte range, byte uplo, int n, MemorySegment a, int lda, double vl, double vu, int il, int iu, double abstol, MemorySegment m, MemorySegment w, MemorySegment z, int ldz, MemorySegment isuppz, MemorySegment work, int lwork, MemorySegment rwork, int lrwork, MemorySegment iwork, int liwork) {
        var mh$ = LAPACKE_zheevr_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zheevr_work", matrix_layout, jobz, range, uplo, n, a, lda, vl, vu, il, iu, abstol, m, w, z, ldz, isuppz, work, lwork, rwork, lrwork, iwork, liwork);
            }
            return (int)mh$.invokeExact(matrix_layout, jobz, range, uplo, n, a, lda, vl, vu, il, iu, abstol, m, w, z, ldz, isuppz, work, lwork, rwork, lrwork, iwork, liwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cheevx_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_FLOAT,
            lapacke_h.C_FLOAT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_FLOAT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_cheevx_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cheevx_work(int matrix_layout, char jobz, char range, char uplo, int n, _Complex float *a, int lda, float vl, float vu, int il, int iu, float abstol, int *m, float *w, _Complex float *z, int ldz, _Complex float *work, int lwork, float *rwork, int *iwork, int *ifail)
     * }
     */
    public static FunctionDescriptor LAPACKE_cheevx_work$descriptor() {
        return LAPACKE_cheevx_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cheevx_work(int matrix_layout, char jobz, char range, char uplo, int n, _Complex float *a, int lda, float vl, float vu, int il, int iu, float abstol, int *m, float *w, _Complex float *z, int ldz, _Complex float *work, int lwork, float *rwork, int *iwork, int *ifail)
     * }
     */
    public static MethodHandle LAPACKE_cheevx_work$handle() {
        return LAPACKE_cheevx_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cheevx_work(int matrix_layout, char jobz, char range, char uplo, int n, _Complex float *a, int lda, float vl, float vu, int il, int iu, float abstol, int *m, float *w, _Complex float *z, int ldz, _Complex float *work, int lwork, float *rwork, int *iwork, int *ifail)
     * }
     */
    public static MemorySegment LAPACKE_cheevx_work$address() {
        return LAPACKE_cheevx_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cheevx_work(int matrix_layout, char jobz, char range, char uplo, int n, _Complex float *a, int lda, float vl, float vu, int il, int iu, float abstol, int *m, float *w, _Complex float *z, int ldz, _Complex float *work, int lwork, float *rwork, int *iwork, int *ifail)
     * }
     */
    public static int LAPACKE_cheevx_work(int matrix_layout, byte jobz, byte range, byte uplo, int n, MemorySegment a, int lda, float vl, float vu, int il, int iu, float abstol, MemorySegment m, MemorySegment w, MemorySegment z, int ldz, MemorySegment work, int lwork, MemorySegment rwork, MemorySegment iwork, MemorySegment ifail) {
        var mh$ = LAPACKE_cheevx_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cheevx_work", matrix_layout, jobz, range, uplo, n, a, lda, vl, vu, il, iu, abstol, m, w, z, ldz, work, lwork, rwork, iwork, ifail);
            }
            return (int)mh$.invokeExact(matrix_layout, jobz, range, uplo, n, a, lda, vl, vu, il, iu, abstol, m, w, z, ldz, work, lwork, rwork, iwork, ifail);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zheevx_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_DOUBLE,
            lapacke_h.C_DOUBLE,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_DOUBLE,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zheevx_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zheevx_work(int matrix_layout, char jobz, char range, char uplo, int n, _Complex double *a, int lda, double vl, double vu, int il, int iu, double abstol, int *m, double *w, _Complex double *z, int ldz, _Complex double *work, int lwork, double *rwork, int *iwork, int *ifail)
     * }
     */
    public static FunctionDescriptor LAPACKE_zheevx_work$descriptor() {
        return LAPACKE_zheevx_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zheevx_work(int matrix_layout, char jobz, char range, char uplo, int n, _Complex double *a, int lda, double vl, double vu, int il, int iu, double abstol, int *m, double *w, _Complex double *z, int ldz, _Complex double *work, int lwork, double *rwork, int *iwork, int *ifail)
     * }
     */
    public static MethodHandle LAPACKE_zheevx_work$handle() {
        return LAPACKE_zheevx_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zheevx_work(int matrix_layout, char jobz, char range, char uplo, int n, _Complex double *a, int lda, double vl, double vu, int il, int iu, double abstol, int *m, double *w, _Complex double *z, int ldz, _Complex double *work, int lwork, double *rwork, int *iwork, int *ifail)
     * }
     */
    public static MemorySegment LAPACKE_zheevx_work$address() {
        return LAPACKE_zheevx_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zheevx_work(int matrix_layout, char jobz, char range, char uplo, int n, _Complex double *a, int lda, double vl, double vu, int il, int iu, double abstol, int *m, double *w, _Complex double *z, int ldz, _Complex double *work, int lwork, double *rwork, int *iwork, int *ifail)
     * }
     */
    public static int LAPACKE_zheevx_work(int matrix_layout, byte jobz, byte range, byte uplo, int n, MemorySegment a, int lda, double vl, double vu, int il, int iu, double abstol, MemorySegment m, MemorySegment w, MemorySegment z, int ldz, MemorySegment work, int lwork, MemorySegment rwork, MemorySegment iwork, MemorySegment ifail) {
        var mh$ = LAPACKE_zheevx_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zheevx_work", matrix_layout, jobz, range, uplo, n, a, lda, vl, vu, il, iu, abstol, m, w, z, ldz, work, lwork, rwork, iwork, ifail);
            }
            return (int)mh$.invokeExact(matrix_layout, jobz, range, uplo, n, a, lda, vl, vu, il, iu, abstol, m, w, z, ldz, work, lwork, rwork, iwork, ifail);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_chegst_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_chegst_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_chegst_work(int matrix_layout, int itype, char uplo, int n, _Complex float *a, int lda, const _Complex float *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_chegst_work$descriptor() {
        return LAPACKE_chegst_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_chegst_work(int matrix_layout, int itype, char uplo, int n, _Complex float *a, int lda, const _Complex float *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_chegst_work$handle() {
        return LAPACKE_chegst_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_chegst_work(int matrix_layout, int itype, char uplo, int n, _Complex float *a, int lda, const _Complex float *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_chegst_work$address() {
        return LAPACKE_chegst_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_chegst_work(int matrix_layout, int itype, char uplo, int n, _Complex float *a, int lda, const _Complex float *b, int ldb)
     * }
     */
    public static int LAPACKE_chegst_work(int matrix_layout, int itype, byte uplo, int n, MemorySegment a, int lda, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_chegst_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_chegst_work", matrix_layout, itype, uplo, n, a, lda, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, itype, uplo, n, a, lda, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zhegst_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zhegst_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zhegst_work(int matrix_layout, int itype, char uplo, int n, _Complex double *a, int lda, const _Complex double *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_zhegst_work$descriptor() {
        return LAPACKE_zhegst_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zhegst_work(int matrix_layout, int itype, char uplo, int n, _Complex double *a, int lda, const _Complex double *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_zhegst_work$handle() {
        return LAPACKE_zhegst_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zhegst_work(int matrix_layout, int itype, char uplo, int n, _Complex double *a, int lda, const _Complex double *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_zhegst_work$address() {
        return LAPACKE_zhegst_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zhegst_work(int matrix_layout, int itype, char uplo, int n, _Complex double *a, int lda, const _Complex double *b, int ldb)
     * }
     */
    public static int LAPACKE_zhegst_work(int matrix_layout, int itype, byte uplo, int n, MemorySegment a, int lda, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_zhegst_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zhegst_work", matrix_layout, itype, uplo, n, a, lda, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, itype, uplo, n, a, lda, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_chegv_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_chegv_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_chegv_work(int matrix_layout, int itype, char jobz, char uplo, int n, _Complex float *a, int lda, _Complex float *b, int ldb, float *w, _Complex float *work, int lwork, float *rwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_chegv_work$descriptor() {
        return LAPACKE_chegv_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_chegv_work(int matrix_layout, int itype, char jobz, char uplo, int n, _Complex float *a, int lda, _Complex float *b, int ldb, float *w, _Complex float *work, int lwork, float *rwork)
     * }
     */
    public static MethodHandle LAPACKE_chegv_work$handle() {
        return LAPACKE_chegv_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_chegv_work(int matrix_layout, int itype, char jobz, char uplo, int n, _Complex float *a, int lda, _Complex float *b, int ldb, float *w, _Complex float *work, int lwork, float *rwork)
     * }
     */
    public static MemorySegment LAPACKE_chegv_work$address() {
        return LAPACKE_chegv_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_chegv_work(int matrix_layout, int itype, char jobz, char uplo, int n, _Complex float *a, int lda, _Complex float *b, int ldb, float *w, _Complex float *work, int lwork, float *rwork)
     * }
     */
    public static int LAPACKE_chegv_work(int matrix_layout, int itype, byte jobz, byte uplo, int n, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment w, MemorySegment work, int lwork, MemorySegment rwork) {
        var mh$ = LAPACKE_chegv_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_chegv_work", matrix_layout, itype, jobz, uplo, n, a, lda, b, ldb, w, work, lwork, rwork);
            }
            return (int)mh$.invokeExact(matrix_layout, itype, jobz, uplo, n, a, lda, b, ldb, w, work, lwork, rwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zhegv_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zhegv_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zhegv_work(int matrix_layout, int itype, char jobz, char uplo, int n, _Complex double *a, int lda, _Complex double *b, int ldb, double *w, _Complex double *work, int lwork, double *rwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_zhegv_work$descriptor() {
        return LAPACKE_zhegv_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zhegv_work(int matrix_layout, int itype, char jobz, char uplo, int n, _Complex double *a, int lda, _Complex double *b, int ldb, double *w, _Complex double *work, int lwork, double *rwork)
     * }
     */
    public static MethodHandle LAPACKE_zhegv_work$handle() {
        return LAPACKE_zhegv_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zhegv_work(int matrix_layout, int itype, char jobz, char uplo, int n, _Complex double *a, int lda, _Complex double *b, int ldb, double *w, _Complex double *work, int lwork, double *rwork)
     * }
     */
    public static MemorySegment LAPACKE_zhegv_work$address() {
        return LAPACKE_zhegv_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zhegv_work(int matrix_layout, int itype, char jobz, char uplo, int n, _Complex double *a, int lda, _Complex double *b, int ldb, double *w, _Complex double *work, int lwork, double *rwork)
     * }
     */
    public static int LAPACKE_zhegv_work(int matrix_layout, int itype, byte jobz, byte uplo, int n, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment w, MemorySegment work, int lwork, MemorySegment rwork) {
        var mh$ = LAPACKE_zhegv_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zhegv_work", matrix_layout, itype, jobz, uplo, n, a, lda, b, ldb, w, work, lwork, rwork);
            }
            return (int)mh$.invokeExact(matrix_layout, itype, jobz, uplo, n, a, lda, b, ldb, w, work, lwork, rwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_chegvd_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_chegvd_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_chegvd_work(int matrix_layout, int itype, char jobz, char uplo, int n, _Complex float *a, int lda, _Complex float *b, int ldb, float *w, _Complex float *work, int lwork, float *rwork, int lrwork, int *iwork, int liwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_chegvd_work$descriptor() {
        return LAPACKE_chegvd_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_chegvd_work(int matrix_layout, int itype, char jobz, char uplo, int n, _Complex float *a, int lda, _Complex float *b, int ldb, float *w, _Complex float *work, int lwork, float *rwork, int lrwork, int *iwork, int liwork)
     * }
     */
    public static MethodHandle LAPACKE_chegvd_work$handle() {
        return LAPACKE_chegvd_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_chegvd_work(int matrix_layout, int itype, char jobz, char uplo, int n, _Complex float *a, int lda, _Complex float *b, int ldb, float *w, _Complex float *work, int lwork, float *rwork, int lrwork, int *iwork, int liwork)
     * }
     */
    public static MemorySegment LAPACKE_chegvd_work$address() {
        return LAPACKE_chegvd_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_chegvd_work(int matrix_layout, int itype, char jobz, char uplo, int n, _Complex float *a, int lda, _Complex float *b, int ldb, float *w, _Complex float *work, int lwork, float *rwork, int lrwork, int *iwork, int liwork)
     * }
     */
    public static int LAPACKE_chegvd_work(int matrix_layout, int itype, byte jobz, byte uplo, int n, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment w, MemorySegment work, int lwork, MemorySegment rwork, int lrwork, MemorySegment iwork, int liwork) {
        var mh$ = LAPACKE_chegvd_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_chegvd_work", matrix_layout, itype, jobz, uplo, n, a, lda, b, ldb, w, work, lwork, rwork, lrwork, iwork, liwork);
            }
            return (int)mh$.invokeExact(matrix_layout, itype, jobz, uplo, n, a, lda, b, ldb, w, work, lwork, rwork, lrwork, iwork, liwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zhegvd_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zhegvd_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zhegvd_work(int matrix_layout, int itype, char jobz, char uplo, int n, _Complex double *a, int lda, _Complex double *b, int ldb, double *w, _Complex double *work, int lwork, double *rwork, int lrwork, int *iwork, int liwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_zhegvd_work$descriptor() {
        return LAPACKE_zhegvd_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zhegvd_work(int matrix_layout, int itype, char jobz, char uplo, int n, _Complex double *a, int lda, _Complex double *b, int ldb, double *w, _Complex double *work, int lwork, double *rwork, int lrwork, int *iwork, int liwork)
     * }
     */
    public static MethodHandle LAPACKE_zhegvd_work$handle() {
        return LAPACKE_zhegvd_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zhegvd_work(int matrix_layout, int itype, char jobz, char uplo, int n, _Complex double *a, int lda, _Complex double *b, int ldb, double *w, _Complex double *work, int lwork, double *rwork, int lrwork, int *iwork, int liwork)
     * }
     */
    public static MemorySegment LAPACKE_zhegvd_work$address() {
        return LAPACKE_zhegvd_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zhegvd_work(int matrix_layout, int itype, char jobz, char uplo, int n, _Complex double *a, int lda, _Complex double *b, int ldb, double *w, _Complex double *work, int lwork, double *rwork, int lrwork, int *iwork, int liwork)
     * }
     */
    public static int LAPACKE_zhegvd_work(int matrix_layout, int itype, byte jobz, byte uplo, int n, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment w, MemorySegment work, int lwork, MemorySegment rwork, int lrwork, MemorySegment iwork, int liwork) {
        var mh$ = LAPACKE_zhegvd_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zhegvd_work", matrix_layout, itype, jobz, uplo, n, a, lda, b, ldb, w, work, lwork, rwork, lrwork, iwork, liwork);
            }
            return (int)mh$.invokeExact(matrix_layout, itype, jobz, uplo, n, a, lda, b, ldb, w, work, lwork, rwork, lrwork, iwork, liwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_chegvx_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_FLOAT,
            lapacke_h.C_FLOAT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_FLOAT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_chegvx_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_chegvx_work(int matrix_layout, int itype, char jobz, char range, char uplo, int n, _Complex float *a, int lda, _Complex float *b, int ldb, float vl, float vu, int il, int iu, float abstol, int *m, float *w, _Complex float *z, int ldz, _Complex float *work, int lwork, float *rwork, int *iwork, int *ifail)
     * }
     */
    public static FunctionDescriptor LAPACKE_chegvx_work$descriptor() {
        return LAPACKE_chegvx_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_chegvx_work(int matrix_layout, int itype, char jobz, char range, char uplo, int n, _Complex float *a, int lda, _Complex float *b, int ldb, float vl, float vu, int il, int iu, float abstol, int *m, float *w, _Complex float *z, int ldz, _Complex float *work, int lwork, float *rwork, int *iwork, int *ifail)
     * }
     */
    public static MethodHandle LAPACKE_chegvx_work$handle() {
        return LAPACKE_chegvx_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_chegvx_work(int matrix_layout, int itype, char jobz, char range, char uplo, int n, _Complex float *a, int lda, _Complex float *b, int ldb, float vl, float vu, int il, int iu, float abstol, int *m, float *w, _Complex float *z, int ldz, _Complex float *work, int lwork, float *rwork, int *iwork, int *ifail)
     * }
     */
    public static MemorySegment LAPACKE_chegvx_work$address() {
        return LAPACKE_chegvx_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_chegvx_work(int matrix_layout, int itype, char jobz, char range, char uplo, int n, _Complex float *a, int lda, _Complex float *b, int ldb, float vl, float vu, int il, int iu, float abstol, int *m, float *w, _Complex float *z, int ldz, _Complex float *work, int lwork, float *rwork, int *iwork, int *ifail)
     * }
     */
    public static int LAPACKE_chegvx_work(int matrix_layout, int itype, byte jobz, byte range, byte uplo, int n, MemorySegment a, int lda, MemorySegment b, int ldb, float vl, float vu, int il, int iu, float abstol, MemorySegment m, MemorySegment w, MemorySegment z, int ldz, MemorySegment work, int lwork, MemorySegment rwork, MemorySegment iwork, MemorySegment ifail) {
        var mh$ = LAPACKE_chegvx_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_chegvx_work", matrix_layout, itype, jobz, range, uplo, n, a, lda, b, ldb, vl, vu, il, iu, abstol, m, w, z, ldz, work, lwork, rwork, iwork, ifail);
            }
            return (int)mh$.invokeExact(matrix_layout, itype, jobz, range, uplo, n, a, lda, b, ldb, vl, vu, il, iu, abstol, m, w, z, ldz, work, lwork, rwork, iwork, ifail);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zhegvx_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_DOUBLE,
            lapacke_h.C_DOUBLE,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_DOUBLE,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zhegvx_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zhegvx_work(int matrix_layout, int itype, char jobz, char range, char uplo, int n, _Complex double *a, int lda, _Complex double *b, int ldb, double vl, double vu, int il, int iu, double abstol, int *m, double *w, _Complex double *z, int ldz, _Complex double *work, int lwork, double *rwork, int *iwork, int *ifail)
     * }
     */
    public static FunctionDescriptor LAPACKE_zhegvx_work$descriptor() {
        return LAPACKE_zhegvx_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zhegvx_work(int matrix_layout, int itype, char jobz, char range, char uplo, int n, _Complex double *a, int lda, _Complex double *b, int ldb, double vl, double vu, int il, int iu, double abstol, int *m, double *w, _Complex double *z, int ldz, _Complex double *work, int lwork, double *rwork, int *iwork, int *ifail)
     * }
     */
    public static MethodHandle LAPACKE_zhegvx_work$handle() {
        return LAPACKE_zhegvx_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zhegvx_work(int matrix_layout, int itype, char jobz, char range, char uplo, int n, _Complex double *a, int lda, _Complex double *b, int ldb, double vl, double vu, int il, int iu, double abstol, int *m, double *w, _Complex double *z, int ldz, _Complex double *work, int lwork, double *rwork, int *iwork, int *ifail)
     * }
     */
    public static MemorySegment LAPACKE_zhegvx_work$address() {
        return LAPACKE_zhegvx_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zhegvx_work(int matrix_layout, int itype, char jobz, char range, char uplo, int n, _Complex double *a, int lda, _Complex double *b, int ldb, double vl, double vu, int il, int iu, double abstol, int *m, double *w, _Complex double *z, int ldz, _Complex double *work, int lwork, double *rwork, int *iwork, int *ifail)
     * }
     */
    public static int LAPACKE_zhegvx_work(int matrix_layout, int itype, byte jobz, byte range, byte uplo, int n, MemorySegment a, int lda, MemorySegment b, int ldb, double vl, double vu, int il, int iu, double abstol, MemorySegment m, MemorySegment w, MemorySegment z, int ldz, MemorySegment work, int lwork, MemorySegment rwork, MemorySegment iwork, MemorySegment ifail) {
        var mh$ = LAPACKE_zhegvx_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zhegvx_work", matrix_layout, itype, jobz, range, uplo, n, a, lda, b, ldb, vl, vu, il, iu, abstol, m, w, z, ldz, work, lwork, rwork, iwork, ifail);
            }
            return (int)mh$.invokeExact(matrix_layout, itype, jobz, range, uplo, n, a, lda, b, ldb, vl, vu, il, iu, abstol, m, w, z, ldz, work, lwork, rwork, iwork, ifail);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cherfs_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_cherfs_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cherfs_work(int matrix_layout, char uplo, int n, int nrhs, const _Complex float *a, int lda, const _Complex float *af, int ldaf, const int *ipiv, const _Complex float *b, int ldb, _Complex float *x, int ldx, float *ferr, float *berr, _Complex float *work, float *rwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_cherfs_work$descriptor() {
        return LAPACKE_cherfs_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cherfs_work(int matrix_layout, char uplo, int n, int nrhs, const _Complex float *a, int lda, const _Complex float *af, int ldaf, const int *ipiv, const _Complex float *b, int ldb, _Complex float *x, int ldx, float *ferr, float *berr, _Complex float *work, float *rwork)
     * }
     */
    public static MethodHandle LAPACKE_cherfs_work$handle() {
        return LAPACKE_cherfs_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cherfs_work(int matrix_layout, char uplo, int n, int nrhs, const _Complex float *a, int lda, const _Complex float *af, int ldaf, const int *ipiv, const _Complex float *b, int ldb, _Complex float *x, int ldx, float *ferr, float *berr, _Complex float *work, float *rwork)
     * }
     */
    public static MemorySegment LAPACKE_cherfs_work$address() {
        return LAPACKE_cherfs_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cherfs_work(int matrix_layout, char uplo, int n, int nrhs, const _Complex float *a, int lda, const _Complex float *af, int ldaf, const int *ipiv, const _Complex float *b, int ldb, _Complex float *x, int ldx, float *ferr, float *berr, _Complex float *work, float *rwork)
     * }
     */
    public static int LAPACKE_cherfs_work(int matrix_layout, byte uplo, int n, int nrhs, MemorySegment a, int lda, MemorySegment af, int ldaf, MemorySegment ipiv, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment ferr, MemorySegment berr, MemorySegment work, MemorySegment rwork) {
        var mh$ = LAPACKE_cherfs_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cherfs_work", matrix_layout, uplo, n, nrhs, a, lda, af, ldaf, ipiv, b, ldb, x, ldx, ferr, berr, work, rwork);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, nrhs, a, lda, af, ldaf, ipiv, b, ldb, x, ldx, ferr, berr, work, rwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zherfs_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zherfs_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zherfs_work(int matrix_layout, char uplo, int n, int nrhs, const _Complex double *a, int lda, const _Complex double *af, int ldaf, const int *ipiv, const _Complex double *b, int ldb, _Complex double *x, int ldx, double *ferr, double *berr, _Complex double *work, double *rwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_zherfs_work$descriptor() {
        return LAPACKE_zherfs_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zherfs_work(int matrix_layout, char uplo, int n, int nrhs, const _Complex double *a, int lda, const _Complex double *af, int ldaf, const int *ipiv, const _Complex double *b, int ldb, _Complex double *x, int ldx, double *ferr, double *berr, _Complex double *work, double *rwork)
     * }
     */
    public static MethodHandle LAPACKE_zherfs_work$handle() {
        return LAPACKE_zherfs_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zherfs_work(int matrix_layout, char uplo, int n, int nrhs, const _Complex double *a, int lda, const _Complex double *af, int ldaf, const int *ipiv, const _Complex double *b, int ldb, _Complex double *x, int ldx, double *ferr, double *berr, _Complex double *work, double *rwork)
     * }
     */
    public static MemorySegment LAPACKE_zherfs_work$address() {
        return LAPACKE_zherfs_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zherfs_work(int matrix_layout, char uplo, int n, int nrhs, const _Complex double *a, int lda, const _Complex double *af, int ldaf, const int *ipiv, const _Complex double *b, int ldb, _Complex double *x, int ldx, double *ferr, double *berr, _Complex double *work, double *rwork)
     * }
     */
    public static int LAPACKE_zherfs_work(int matrix_layout, byte uplo, int n, int nrhs, MemorySegment a, int lda, MemorySegment af, int ldaf, MemorySegment ipiv, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment ferr, MemorySegment berr, MemorySegment work, MemorySegment rwork) {
        var mh$ = LAPACKE_zherfs_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zherfs_work", matrix_layout, uplo, n, nrhs, a, lda, af, ldaf, ipiv, b, ldb, x, ldx, ferr, berr, work, rwork);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, nrhs, a, lda, af, ldaf, ipiv, b, ldb, x, ldx, ferr, berr, work, rwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cherfsx_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_cherfsx_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cherfsx_work(int matrix_layout, char uplo, char equed, int n, int nrhs, const _Complex float *a, int lda, const _Complex float *af, int ldaf, const int *ipiv, const float *s, const _Complex float *b, int ldb, _Complex float *x, int ldx, float *rcond, float *berr, int n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, int nparams, float *params, _Complex float *work, float *rwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_cherfsx_work$descriptor() {
        return LAPACKE_cherfsx_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cherfsx_work(int matrix_layout, char uplo, char equed, int n, int nrhs, const _Complex float *a, int lda, const _Complex float *af, int ldaf, const int *ipiv, const float *s, const _Complex float *b, int ldb, _Complex float *x, int ldx, float *rcond, float *berr, int n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, int nparams, float *params, _Complex float *work, float *rwork)
     * }
     */
    public static MethodHandle LAPACKE_cherfsx_work$handle() {
        return LAPACKE_cherfsx_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cherfsx_work(int matrix_layout, char uplo, char equed, int n, int nrhs, const _Complex float *a, int lda, const _Complex float *af, int ldaf, const int *ipiv, const float *s, const _Complex float *b, int ldb, _Complex float *x, int ldx, float *rcond, float *berr, int n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, int nparams, float *params, _Complex float *work, float *rwork)
     * }
     */
    public static MemorySegment LAPACKE_cherfsx_work$address() {
        return LAPACKE_cherfsx_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cherfsx_work(int matrix_layout, char uplo, char equed, int n, int nrhs, const _Complex float *a, int lda, const _Complex float *af, int ldaf, const int *ipiv, const float *s, const _Complex float *b, int ldb, _Complex float *x, int ldx, float *rcond, float *berr, int n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, int nparams, float *params, _Complex float *work, float *rwork)
     * }
     */
    public static int LAPACKE_cherfsx_work(int matrix_layout, byte uplo, byte equed, int n, int nrhs, MemorySegment a, int lda, MemorySegment af, int ldaf, MemorySegment ipiv, MemorySegment s, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment rcond, MemorySegment berr, int n_err_bnds, MemorySegment err_bnds_norm, MemorySegment err_bnds_comp, int nparams, MemorySegment params, MemorySegment work, MemorySegment rwork) {
        var mh$ = LAPACKE_cherfsx_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cherfsx_work", matrix_layout, uplo, equed, n, nrhs, a, lda, af, ldaf, ipiv, s, b, ldb, x, ldx, rcond, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params, work, rwork);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, equed, n, nrhs, a, lda, af, ldaf, ipiv, s, b, ldb, x, ldx, rcond, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params, work, rwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zherfsx_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zherfsx_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zherfsx_work(int matrix_layout, char uplo, char equed, int n, int nrhs, const _Complex double *a, int lda, const _Complex double *af, int ldaf, const int *ipiv, const double *s, const _Complex double *b, int ldb, _Complex double *x, int ldx, double *rcond, double *berr, int n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, int nparams, double *params, _Complex double *work, double *rwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_zherfsx_work$descriptor() {
        return LAPACKE_zherfsx_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zherfsx_work(int matrix_layout, char uplo, char equed, int n, int nrhs, const _Complex double *a, int lda, const _Complex double *af, int ldaf, const int *ipiv, const double *s, const _Complex double *b, int ldb, _Complex double *x, int ldx, double *rcond, double *berr, int n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, int nparams, double *params, _Complex double *work, double *rwork)
     * }
     */
    public static MethodHandle LAPACKE_zherfsx_work$handle() {
        return LAPACKE_zherfsx_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zherfsx_work(int matrix_layout, char uplo, char equed, int n, int nrhs, const _Complex double *a, int lda, const _Complex double *af, int ldaf, const int *ipiv, const double *s, const _Complex double *b, int ldb, _Complex double *x, int ldx, double *rcond, double *berr, int n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, int nparams, double *params, _Complex double *work, double *rwork)
     * }
     */
    public static MemorySegment LAPACKE_zherfsx_work$address() {
        return LAPACKE_zherfsx_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zherfsx_work(int matrix_layout, char uplo, char equed, int n, int nrhs, const _Complex double *a, int lda, const _Complex double *af, int ldaf, const int *ipiv, const double *s, const _Complex double *b, int ldb, _Complex double *x, int ldx, double *rcond, double *berr, int n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, int nparams, double *params, _Complex double *work, double *rwork)
     * }
     */
    public static int LAPACKE_zherfsx_work(int matrix_layout, byte uplo, byte equed, int n, int nrhs, MemorySegment a, int lda, MemorySegment af, int ldaf, MemorySegment ipiv, MemorySegment s, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment rcond, MemorySegment berr, int n_err_bnds, MemorySegment err_bnds_norm, MemorySegment err_bnds_comp, int nparams, MemorySegment params, MemorySegment work, MemorySegment rwork) {
        var mh$ = LAPACKE_zherfsx_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zherfsx_work", matrix_layout, uplo, equed, n, nrhs, a, lda, af, ldaf, ipiv, s, b, ldb, x, ldx, rcond, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params, work, rwork);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, equed, n, nrhs, a, lda, af, ldaf, ipiv, s, b, ldb, x, ldx, rcond, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params, work, rwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_chesv_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_chesv_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_chesv_work(int matrix_layout, char uplo, int n, int nrhs, _Complex float *a, int lda, int *ipiv, _Complex float *b, int ldb, _Complex float *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_chesv_work$descriptor() {
        return LAPACKE_chesv_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_chesv_work(int matrix_layout, char uplo, int n, int nrhs, _Complex float *a, int lda, int *ipiv, _Complex float *b, int ldb, _Complex float *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_chesv_work$handle() {
        return LAPACKE_chesv_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_chesv_work(int matrix_layout, char uplo, int n, int nrhs, _Complex float *a, int lda, int *ipiv, _Complex float *b, int ldb, _Complex float *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_chesv_work$address() {
        return LAPACKE_chesv_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_chesv_work(int matrix_layout, char uplo, int n, int nrhs, _Complex float *a, int lda, int *ipiv, _Complex float *b, int ldb, _Complex float *work, int lwork)
     * }
     */
    public static int LAPACKE_chesv_work(int matrix_layout, byte uplo, int n, int nrhs, MemorySegment a, int lda, MemorySegment ipiv, MemorySegment b, int ldb, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_chesv_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_chesv_work", matrix_layout, uplo, n, nrhs, a, lda, ipiv, b, ldb, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, nrhs, a, lda, ipiv, b, ldb, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zhesv_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zhesv_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zhesv_work(int matrix_layout, char uplo, int n, int nrhs, _Complex double *a, int lda, int *ipiv, _Complex double *b, int ldb, _Complex double *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_zhesv_work$descriptor() {
        return LAPACKE_zhesv_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zhesv_work(int matrix_layout, char uplo, int n, int nrhs, _Complex double *a, int lda, int *ipiv, _Complex double *b, int ldb, _Complex double *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_zhesv_work$handle() {
        return LAPACKE_zhesv_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zhesv_work(int matrix_layout, char uplo, int n, int nrhs, _Complex double *a, int lda, int *ipiv, _Complex double *b, int ldb, _Complex double *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_zhesv_work$address() {
        return LAPACKE_zhesv_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zhesv_work(int matrix_layout, char uplo, int n, int nrhs, _Complex double *a, int lda, int *ipiv, _Complex double *b, int ldb, _Complex double *work, int lwork)
     * }
     */
    public static int LAPACKE_zhesv_work(int matrix_layout, byte uplo, int n, int nrhs, MemorySegment a, int lda, MemorySegment ipiv, MemorySegment b, int ldb, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_zhesv_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zhesv_work", matrix_layout, uplo, n, nrhs, a, lda, ipiv, b, ldb, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, nrhs, a, lda, ipiv, b, ldb, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_chesvx_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_chesvx_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_chesvx_work(int matrix_layout, char fact, char uplo, int n, int nrhs, const _Complex float *a, int lda, _Complex float *af, int ldaf, int *ipiv, const _Complex float *b, int ldb, _Complex float *x, int ldx, float *rcond, float *ferr, float *berr, _Complex float *work, int lwork, float *rwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_chesvx_work$descriptor() {
        return LAPACKE_chesvx_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_chesvx_work(int matrix_layout, char fact, char uplo, int n, int nrhs, const _Complex float *a, int lda, _Complex float *af, int ldaf, int *ipiv, const _Complex float *b, int ldb, _Complex float *x, int ldx, float *rcond, float *ferr, float *berr, _Complex float *work, int lwork, float *rwork)
     * }
     */
    public static MethodHandle LAPACKE_chesvx_work$handle() {
        return LAPACKE_chesvx_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_chesvx_work(int matrix_layout, char fact, char uplo, int n, int nrhs, const _Complex float *a, int lda, _Complex float *af, int ldaf, int *ipiv, const _Complex float *b, int ldb, _Complex float *x, int ldx, float *rcond, float *ferr, float *berr, _Complex float *work, int lwork, float *rwork)
     * }
     */
    public static MemorySegment LAPACKE_chesvx_work$address() {
        return LAPACKE_chesvx_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_chesvx_work(int matrix_layout, char fact, char uplo, int n, int nrhs, const _Complex float *a, int lda, _Complex float *af, int ldaf, int *ipiv, const _Complex float *b, int ldb, _Complex float *x, int ldx, float *rcond, float *ferr, float *berr, _Complex float *work, int lwork, float *rwork)
     * }
     */
    public static int LAPACKE_chesvx_work(int matrix_layout, byte fact, byte uplo, int n, int nrhs, MemorySegment a, int lda, MemorySegment af, int ldaf, MemorySegment ipiv, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment rcond, MemorySegment ferr, MemorySegment berr, MemorySegment work, int lwork, MemorySegment rwork) {
        var mh$ = LAPACKE_chesvx_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_chesvx_work", matrix_layout, fact, uplo, n, nrhs, a, lda, af, ldaf, ipiv, b, ldb, x, ldx, rcond, ferr, berr, work, lwork, rwork);
            }
            return (int)mh$.invokeExact(matrix_layout, fact, uplo, n, nrhs, a, lda, af, ldaf, ipiv, b, ldb, x, ldx, rcond, ferr, berr, work, lwork, rwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zhesvx_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zhesvx_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zhesvx_work(int matrix_layout, char fact, char uplo, int n, int nrhs, const _Complex double *a, int lda, _Complex double *af, int ldaf, int *ipiv, const _Complex double *b, int ldb, _Complex double *x, int ldx, double *rcond, double *ferr, double *berr, _Complex double *work, int lwork, double *rwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_zhesvx_work$descriptor() {
        return LAPACKE_zhesvx_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zhesvx_work(int matrix_layout, char fact, char uplo, int n, int nrhs, const _Complex double *a, int lda, _Complex double *af, int ldaf, int *ipiv, const _Complex double *b, int ldb, _Complex double *x, int ldx, double *rcond, double *ferr, double *berr, _Complex double *work, int lwork, double *rwork)
     * }
     */
    public static MethodHandle LAPACKE_zhesvx_work$handle() {
        return LAPACKE_zhesvx_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zhesvx_work(int matrix_layout, char fact, char uplo, int n, int nrhs, const _Complex double *a, int lda, _Complex double *af, int ldaf, int *ipiv, const _Complex double *b, int ldb, _Complex double *x, int ldx, double *rcond, double *ferr, double *berr, _Complex double *work, int lwork, double *rwork)
     * }
     */
    public static MemorySegment LAPACKE_zhesvx_work$address() {
        return LAPACKE_zhesvx_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zhesvx_work(int matrix_layout, char fact, char uplo, int n, int nrhs, const _Complex double *a, int lda, _Complex double *af, int ldaf, int *ipiv, const _Complex double *b, int ldb, _Complex double *x, int ldx, double *rcond, double *ferr, double *berr, _Complex double *work, int lwork, double *rwork)
     * }
     */
    public static int LAPACKE_zhesvx_work(int matrix_layout, byte fact, byte uplo, int n, int nrhs, MemorySegment a, int lda, MemorySegment af, int ldaf, MemorySegment ipiv, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment rcond, MemorySegment ferr, MemorySegment berr, MemorySegment work, int lwork, MemorySegment rwork) {
        var mh$ = LAPACKE_zhesvx_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zhesvx_work", matrix_layout, fact, uplo, n, nrhs, a, lda, af, ldaf, ipiv, b, ldb, x, ldx, rcond, ferr, berr, work, lwork, rwork);
            }
            return (int)mh$.invokeExact(matrix_layout, fact, uplo, n, nrhs, a, lda, af, ldaf, ipiv, b, ldb, x, ldx, rcond, ferr, berr, work, lwork, rwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_chesvxx_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_chesvxx_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_chesvxx_work(int matrix_layout, char fact, char uplo, int n, int nrhs, _Complex float *a, int lda, _Complex float *af, int ldaf, int *ipiv, char *equed, float *s, _Complex float *b, int ldb, _Complex float *x, int ldx, float *rcond, float *rpvgrw, float *berr, int n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, int nparams, float *params, _Complex float *work, float *rwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_chesvxx_work$descriptor() {
        return LAPACKE_chesvxx_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_chesvxx_work(int matrix_layout, char fact, char uplo, int n, int nrhs, _Complex float *a, int lda, _Complex float *af, int ldaf, int *ipiv, char *equed, float *s, _Complex float *b, int ldb, _Complex float *x, int ldx, float *rcond, float *rpvgrw, float *berr, int n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, int nparams, float *params, _Complex float *work, float *rwork)
     * }
     */
    public static MethodHandle LAPACKE_chesvxx_work$handle() {
        return LAPACKE_chesvxx_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_chesvxx_work(int matrix_layout, char fact, char uplo, int n, int nrhs, _Complex float *a, int lda, _Complex float *af, int ldaf, int *ipiv, char *equed, float *s, _Complex float *b, int ldb, _Complex float *x, int ldx, float *rcond, float *rpvgrw, float *berr, int n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, int nparams, float *params, _Complex float *work, float *rwork)
     * }
     */
    public static MemorySegment LAPACKE_chesvxx_work$address() {
        return LAPACKE_chesvxx_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_chesvxx_work(int matrix_layout, char fact, char uplo, int n, int nrhs, _Complex float *a, int lda, _Complex float *af, int ldaf, int *ipiv, char *equed, float *s, _Complex float *b, int ldb, _Complex float *x, int ldx, float *rcond, float *rpvgrw, float *berr, int n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, int nparams, float *params, _Complex float *work, float *rwork)
     * }
     */
    public static int LAPACKE_chesvxx_work(int matrix_layout, byte fact, byte uplo, int n, int nrhs, MemorySegment a, int lda, MemorySegment af, int ldaf, MemorySegment ipiv, MemorySegment equed, MemorySegment s, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment rcond, MemorySegment rpvgrw, MemorySegment berr, int n_err_bnds, MemorySegment err_bnds_norm, MemorySegment err_bnds_comp, int nparams, MemorySegment params, MemorySegment work, MemorySegment rwork) {
        var mh$ = LAPACKE_chesvxx_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_chesvxx_work", matrix_layout, fact, uplo, n, nrhs, a, lda, af, ldaf, ipiv, equed, s, b, ldb, x, ldx, rcond, rpvgrw, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params, work, rwork);
            }
            return (int)mh$.invokeExact(matrix_layout, fact, uplo, n, nrhs, a, lda, af, ldaf, ipiv, equed, s, b, ldb, x, ldx, rcond, rpvgrw, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params, work, rwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zhesvxx_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zhesvxx_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zhesvxx_work(int matrix_layout, char fact, char uplo, int n, int nrhs, _Complex double *a, int lda, _Complex double *af, int ldaf, int *ipiv, char *equed, double *s, _Complex double *b, int ldb, _Complex double *x, int ldx, double *rcond, double *rpvgrw, double *berr, int n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, int nparams, double *params, _Complex double *work, double *rwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_zhesvxx_work$descriptor() {
        return LAPACKE_zhesvxx_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zhesvxx_work(int matrix_layout, char fact, char uplo, int n, int nrhs, _Complex double *a, int lda, _Complex double *af, int ldaf, int *ipiv, char *equed, double *s, _Complex double *b, int ldb, _Complex double *x, int ldx, double *rcond, double *rpvgrw, double *berr, int n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, int nparams, double *params, _Complex double *work, double *rwork)
     * }
     */
    public static MethodHandle LAPACKE_zhesvxx_work$handle() {
        return LAPACKE_zhesvxx_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zhesvxx_work(int matrix_layout, char fact, char uplo, int n, int nrhs, _Complex double *a, int lda, _Complex double *af, int ldaf, int *ipiv, char *equed, double *s, _Complex double *b, int ldb, _Complex double *x, int ldx, double *rcond, double *rpvgrw, double *berr, int n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, int nparams, double *params, _Complex double *work, double *rwork)
     * }
     */
    public static MemorySegment LAPACKE_zhesvxx_work$address() {
        return LAPACKE_zhesvxx_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zhesvxx_work(int matrix_layout, char fact, char uplo, int n, int nrhs, _Complex double *a, int lda, _Complex double *af, int ldaf, int *ipiv, char *equed, double *s, _Complex double *b, int ldb, _Complex double *x, int ldx, double *rcond, double *rpvgrw, double *berr, int n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, int nparams, double *params, _Complex double *work, double *rwork)
     * }
     */
    public static int LAPACKE_zhesvxx_work(int matrix_layout, byte fact, byte uplo, int n, int nrhs, MemorySegment a, int lda, MemorySegment af, int ldaf, MemorySegment ipiv, MemorySegment equed, MemorySegment s, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment rcond, MemorySegment rpvgrw, MemorySegment berr, int n_err_bnds, MemorySegment err_bnds_norm, MemorySegment err_bnds_comp, int nparams, MemorySegment params, MemorySegment work, MemorySegment rwork) {
        var mh$ = LAPACKE_zhesvxx_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zhesvxx_work", matrix_layout, fact, uplo, n, nrhs, a, lda, af, ldaf, ipiv, equed, s, b, ldb, x, ldx, rcond, rpvgrw, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params, work, rwork);
            }
            return (int)mh$.invokeExact(matrix_layout, fact, uplo, n, nrhs, a, lda, af, ldaf, ipiv, equed, s, b, ldb, x, ldx, rcond, rpvgrw, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params, work, rwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_chetrd_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_chetrd_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_chetrd_work(int matrix_layout, char uplo, int n, _Complex float *a, int lda, float *d, float *e, _Complex float *tau, _Complex float *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_chetrd_work$descriptor() {
        return LAPACKE_chetrd_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_chetrd_work(int matrix_layout, char uplo, int n, _Complex float *a, int lda, float *d, float *e, _Complex float *tau, _Complex float *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_chetrd_work$handle() {
        return LAPACKE_chetrd_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_chetrd_work(int matrix_layout, char uplo, int n, _Complex float *a, int lda, float *d, float *e, _Complex float *tau, _Complex float *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_chetrd_work$address() {
        return LAPACKE_chetrd_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_chetrd_work(int matrix_layout, char uplo, int n, _Complex float *a, int lda, float *d, float *e, _Complex float *tau, _Complex float *work, int lwork)
     * }
     */
    public static int LAPACKE_chetrd_work(int matrix_layout, byte uplo, int n, MemorySegment a, int lda, MemorySegment d, MemorySegment e, MemorySegment tau, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_chetrd_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_chetrd_work", matrix_layout, uplo, n, a, lda, d, e, tau, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, a, lda, d, e, tau, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zhetrd_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zhetrd_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zhetrd_work(int matrix_layout, char uplo, int n, _Complex double *a, int lda, double *d, double *e, _Complex double *tau, _Complex double *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_zhetrd_work$descriptor() {
        return LAPACKE_zhetrd_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zhetrd_work(int matrix_layout, char uplo, int n, _Complex double *a, int lda, double *d, double *e, _Complex double *tau, _Complex double *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_zhetrd_work$handle() {
        return LAPACKE_zhetrd_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zhetrd_work(int matrix_layout, char uplo, int n, _Complex double *a, int lda, double *d, double *e, _Complex double *tau, _Complex double *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_zhetrd_work$address() {
        return LAPACKE_zhetrd_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zhetrd_work(int matrix_layout, char uplo, int n, _Complex double *a, int lda, double *d, double *e, _Complex double *tau, _Complex double *work, int lwork)
     * }
     */
    public static int LAPACKE_zhetrd_work(int matrix_layout, byte uplo, int n, MemorySegment a, int lda, MemorySegment d, MemorySegment e, MemorySegment tau, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_zhetrd_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zhetrd_work", matrix_layout, uplo, n, a, lda, d, e, tau, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, a, lda, d, e, tau, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_chetrf_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_chetrf_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_chetrf_work(int matrix_layout, char uplo, int n, _Complex float *a, int lda, int *ipiv, _Complex float *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_chetrf_work$descriptor() {
        return LAPACKE_chetrf_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_chetrf_work(int matrix_layout, char uplo, int n, _Complex float *a, int lda, int *ipiv, _Complex float *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_chetrf_work$handle() {
        return LAPACKE_chetrf_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_chetrf_work(int matrix_layout, char uplo, int n, _Complex float *a, int lda, int *ipiv, _Complex float *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_chetrf_work$address() {
        return LAPACKE_chetrf_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_chetrf_work(int matrix_layout, char uplo, int n, _Complex float *a, int lda, int *ipiv, _Complex float *work, int lwork)
     * }
     */
    public static int LAPACKE_chetrf_work(int matrix_layout, byte uplo, int n, MemorySegment a, int lda, MemorySegment ipiv, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_chetrf_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_chetrf_work", matrix_layout, uplo, n, a, lda, ipiv, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, a, lda, ipiv, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zhetrf_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zhetrf_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zhetrf_work(int matrix_layout, char uplo, int n, _Complex double *a, int lda, int *ipiv, _Complex double *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_zhetrf_work$descriptor() {
        return LAPACKE_zhetrf_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zhetrf_work(int matrix_layout, char uplo, int n, _Complex double *a, int lda, int *ipiv, _Complex double *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_zhetrf_work$handle() {
        return LAPACKE_zhetrf_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zhetrf_work(int matrix_layout, char uplo, int n, _Complex double *a, int lda, int *ipiv, _Complex double *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_zhetrf_work$address() {
        return LAPACKE_zhetrf_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zhetrf_work(int matrix_layout, char uplo, int n, _Complex double *a, int lda, int *ipiv, _Complex double *work, int lwork)
     * }
     */
    public static int LAPACKE_zhetrf_work(int matrix_layout, byte uplo, int n, MemorySegment a, int lda, MemorySegment ipiv, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_zhetrf_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zhetrf_work", matrix_layout, uplo, n, a, lda, ipiv, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, a, lda, ipiv, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_chetri_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_chetri_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_chetri_work(int matrix_layout, char uplo, int n, _Complex float *a, int lda, const int *ipiv, _Complex float *work)
     * }
     */
    public static FunctionDescriptor LAPACKE_chetri_work$descriptor() {
        return LAPACKE_chetri_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_chetri_work(int matrix_layout, char uplo, int n, _Complex float *a, int lda, const int *ipiv, _Complex float *work)
     * }
     */
    public static MethodHandle LAPACKE_chetri_work$handle() {
        return LAPACKE_chetri_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_chetri_work(int matrix_layout, char uplo, int n, _Complex float *a, int lda, const int *ipiv, _Complex float *work)
     * }
     */
    public static MemorySegment LAPACKE_chetri_work$address() {
        return LAPACKE_chetri_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_chetri_work(int matrix_layout, char uplo, int n, _Complex float *a, int lda, const int *ipiv, _Complex float *work)
     * }
     */
    public static int LAPACKE_chetri_work(int matrix_layout, byte uplo, int n, MemorySegment a, int lda, MemorySegment ipiv, MemorySegment work) {
        var mh$ = LAPACKE_chetri_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_chetri_work", matrix_layout, uplo, n, a, lda, ipiv, work);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, a, lda, ipiv, work);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zhetri_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zhetri_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zhetri_work(int matrix_layout, char uplo, int n, _Complex double *a, int lda, const int *ipiv, _Complex double *work)
     * }
     */
    public static FunctionDescriptor LAPACKE_zhetri_work$descriptor() {
        return LAPACKE_zhetri_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zhetri_work(int matrix_layout, char uplo, int n, _Complex double *a, int lda, const int *ipiv, _Complex double *work)
     * }
     */
    public static MethodHandle LAPACKE_zhetri_work$handle() {
        return LAPACKE_zhetri_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zhetri_work(int matrix_layout, char uplo, int n, _Complex double *a, int lda, const int *ipiv, _Complex double *work)
     * }
     */
    public static MemorySegment LAPACKE_zhetri_work$address() {
        return LAPACKE_zhetri_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zhetri_work(int matrix_layout, char uplo, int n, _Complex double *a, int lda, const int *ipiv, _Complex double *work)
     * }
     */
    public static int LAPACKE_zhetri_work(int matrix_layout, byte uplo, int n, MemorySegment a, int lda, MemorySegment ipiv, MemorySegment work) {
        var mh$ = LAPACKE_zhetri_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zhetri_work", matrix_layout, uplo, n, a, lda, ipiv, work);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, a, lda, ipiv, work);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_chetrs_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_chetrs_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_chetrs_work(int matrix_layout, char uplo, int n, int nrhs, const _Complex float *a, int lda, const int *ipiv, _Complex float *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_chetrs_work$descriptor() {
        return LAPACKE_chetrs_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_chetrs_work(int matrix_layout, char uplo, int n, int nrhs, const _Complex float *a, int lda, const int *ipiv, _Complex float *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_chetrs_work$handle() {
        return LAPACKE_chetrs_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_chetrs_work(int matrix_layout, char uplo, int n, int nrhs, const _Complex float *a, int lda, const int *ipiv, _Complex float *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_chetrs_work$address() {
        return LAPACKE_chetrs_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_chetrs_work(int matrix_layout, char uplo, int n, int nrhs, const _Complex float *a, int lda, const int *ipiv, _Complex float *b, int ldb)
     * }
     */
    public static int LAPACKE_chetrs_work(int matrix_layout, byte uplo, int n, int nrhs, MemorySegment a, int lda, MemorySegment ipiv, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_chetrs_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_chetrs_work", matrix_layout, uplo, n, nrhs, a, lda, ipiv, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, nrhs, a, lda, ipiv, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zhetrs_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zhetrs_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zhetrs_work(int matrix_layout, char uplo, int n, int nrhs, const _Complex double *a, int lda, const int *ipiv, _Complex double *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_zhetrs_work$descriptor() {
        return LAPACKE_zhetrs_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zhetrs_work(int matrix_layout, char uplo, int n, int nrhs, const _Complex double *a, int lda, const int *ipiv, _Complex double *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_zhetrs_work$handle() {
        return LAPACKE_zhetrs_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zhetrs_work(int matrix_layout, char uplo, int n, int nrhs, const _Complex double *a, int lda, const int *ipiv, _Complex double *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_zhetrs_work$address() {
        return LAPACKE_zhetrs_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zhetrs_work(int matrix_layout, char uplo, int n, int nrhs, const _Complex double *a, int lda, const int *ipiv, _Complex double *b, int ldb)
     * }
     */
    public static int LAPACKE_zhetrs_work(int matrix_layout, byte uplo, int n, int nrhs, MemorySegment a, int lda, MemorySegment ipiv, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_zhetrs_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zhetrs_work", matrix_layout, uplo, n, nrhs, a, lda, ipiv, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, nrhs, a, lda, ipiv, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_chfrk_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_FLOAT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_FLOAT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_chfrk_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_chfrk_work(int matrix_layout, char transr, char uplo, char trans, int n, int k, float alpha, const _Complex float *a, int lda, float beta, _Complex float *c)
     * }
     */
    public static FunctionDescriptor LAPACKE_chfrk_work$descriptor() {
        return LAPACKE_chfrk_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_chfrk_work(int matrix_layout, char transr, char uplo, char trans, int n, int k, float alpha, const _Complex float *a, int lda, float beta, _Complex float *c)
     * }
     */
    public static MethodHandle LAPACKE_chfrk_work$handle() {
        return LAPACKE_chfrk_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_chfrk_work(int matrix_layout, char transr, char uplo, char trans, int n, int k, float alpha, const _Complex float *a, int lda, float beta, _Complex float *c)
     * }
     */
    public static MemorySegment LAPACKE_chfrk_work$address() {
        return LAPACKE_chfrk_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_chfrk_work(int matrix_layout, char transr, char uplo, char trans, int n, int k, float alpha, const _Complex float *a, int lda, float beta, _Complex float *c)
     * }
     */
    public static int LAPACKE_chfrk_work(int matrix_layout, byte transr, byte uplo, byte trans, int n, int k, float alpha, MemorySegment a, int lda, float beta, MemorySegment c) {
        var mh$ = LAPACKE_chfrk_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_chfrk_work", matrix_layout, transr, uplo, trans, n, k, alpha, a, lda, beta, c);
            }
            return (int)mh$.invokeExact(matrix_layout, transr, uplo, trans, n, k, alpha, a, lda, beta, c);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zhfrk_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_DOUBLE,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_DOUBLE,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zhfrk_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zhfrk_work(int matrix_layout, char transr, char uplo, char trans, int n, int k, double alpha, const _Complex double *a, int lda, double beta, _Complex double *c)
     * }
     */
    public static FunctionDescriptor LAPACKE_zhfrk_work$descriptor() {
        return LAPACKE_zhfrk_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zhfrk_work(int matrix_layout, char transr, char uplo, char trans, int n, int k, double alpha, const _Complex double *a, int lda, double beta, _Complex double *c)
     * }
     */
    public static MethodHandle LAPACKE_zhfrk_work$handle() {
        return LAPACKE_zhfrk_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zhfrk_work(int matrix_layout, char transr, char uplo, char trans, int n, int k, double alpha, const _Complex double *a, int lda, double beta, _Complex double *c)
     * }
     */
    public static MemorySegment LAPACKE_zhfrk_work$address() {
        return LAPACKE_zhfrk_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zhfrk_work(int matrix_layout, char transr, char uplo, char trans, int n, int k, double alpha, const _Complex double *a, int lda, double beta, _Complex double *c)
     * }
     */
    public static int LAPACKE_zhfrk_work(int matrix_layout, byte transr, byte uplo, byte trans, int n, int k, double alpha, MemorySegment a, int lda, double beta, MemorySegment c) {
        var mh$ = LAPACKE_zhfrk_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zhfrk_work", matrix_layout, transr, uplo, trans, n, k, alpha, a, lda, beta, c);
            }
            return (int)mh$.invokeExact(matrix_layout, transr, uplo, trans, n, k, alpha, a, lda, beta, c);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_shgeqz_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_shgeqz_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_shgeqz_work(int matrix_layout, char job, char compq, char compz, int n, int ilo, int ihi, float *h, int ldh, float *t, int ldt, float *alphar, float *alphai, float *beta, float *q, int ldq, float *z, int ldz, float *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_shgeqz_work$descriptor() {
        return LAPACKE_shgeqz_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_shgeqz_work(int matrix_layout, char job, char compq, char compz, int n, int ilo, int ihi, float *h, int ldh, float *t, int ldt, float *alphar, float *alphai, float *beta, float *q, int ldq, float *z, int ldz, float *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_shgeqz_work$handle() {
        return LAPACKE_shgeqz_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_shgeqz_work(int matrix_layout, char job, char compq, char compz, int n, int ilo, int ihi, float *h, int ldh, float *t, int ldt, float *alphar, float *alphai, float *beta, float *q, int ldq, float *z, int ldz, float *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_shgeqz_work$address() {
        return LAPACKE_shgeqz_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_shgeqz_work(int matrix_layout, char job, char compq, char compz, int n, int ilo, int ihi, float *h, int ldh, float *t, int ldt, float *alphar, float *alphai, float *beta, float *q, int ldq, float *z, int ldz, float *work, int lwork)
     * }
     */
    public static int LAPACKE_shgeqz_work(int matrix_layout, byte job, byte compq, byte compz, int n, int ilo, int ihi, MemorySegment h, int ldh, MemorySegment t, int ldt, MemorySegment alphar, MemorySegment alphai, MemorySegment beta, MemorySegment q, int ldq, MemorySegment z, int ldz, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_shgeqz_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_shgeqz_work", matrix_layout, job, compq, compz, n, ilo, ihi, h, ldh, t, ldt, alphar, alphai, beta, q, ldq, z, ldz, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, job, compq, compz, n, ilo, ihi, h, ldh, t, ldt, alphar, alphai, beta, q, ldq, z, ldz, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dhgeqz_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dhgeqz_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dhgeqz_work(int matrix_layout, char job, char compq, char compz, int n, int ilo, int ihi, double *h, int ldh, double *t, int ldt, double *alphar, double *alphai, double *beta, double *q, int ldq, double *z, int ldz, double *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_dhgeqz_work$descriptor() {
        return LAPACKE_dhgeqz_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dhgeqz_work(int matrix_layout, char job, char compq, char compz, int n, int ilo, int ihi, double *h, int ldh, double *t, int ldt, double *alphar, double *alphai, double *beta, double *q, int ldq, double *z, int ldz, double *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_dhgeqz_work$handle() {
        return LAPACKE_dhgeqz_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dhgeqz_work(int matrix_layout, char job, char compq, char compz, int n, int ilo, int ihi, double *h, int ldh, double *t, int ldt, double *alphar, double *alphai, double *beta, double *q, int ldq, double *z, int ldz, double *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_dhgeqz_work$address() {
        return LAPACKE_dhgeqz_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dhgeqz_work(int matrix_layout, char job, char compq, char compz, int n, int ilo, int ihi, double *h, int ldh, double *t, int ldt, double *alphar, double *alphai, double *beta, double *q, int ldq, double *z, int ldz, double *work, int lwork)
     * }
     */
    public static int LAPACKE_dhgeqz_work(int matrix_layout, byte job, byte compq, byte compz, int n, int ilo, int ihi, MemorySegment h, int ldh, MemorySegment t, int ldt, MemorySegment alphar, MemorySegment alphai, MemorySegment beta, MemorySegment q, int ldq, MemorySegment z, int ldz, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_dhgeqz_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dhgeqz_work", matrix_layout, job, compq, compz, n, ilo, ihi, h, ldh, t, ldt, alphar, alphai, beta, q, ldq, z, ldz, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, job, compq, compz, n, ilo, ihi, h, ldh, t, ldt, alphar, alphai, beta, q, ldq, z, ldz, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_chgeqz_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_chgeqz_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_chgeqz_work(int matrix_layout, char job, char compq, char compz, int n, int ilo, int ihi, _Complex float *h, int ldh, _Complex float *t, int ldt, _Complex float *alpha, _Complex float *beta, _Complex float *q, int ldq, _Complex float *z, int ldz, _Complex float *work, int lwork, float *rwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_chgeqz_work$descriptor() {
        return LAPACKE_chgeqz_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_chgeqz_work(int matrix_layout, char job, char compq, char compz, int n, int ilo, int ihi, _Complex float *h, int ldh, _Complex float *t, int ldt, _Complex float *alpha, _Complex float *beta, _Complex float *q, int ldq, _Complex float *z, int ldz, _Complex float *work, int lwork, float *rwork)
     * }
     */
    public static MethodHandle LAPACKE_chgeqz_work$handle() {
        return LAPACKE_chgeqz_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_chgeqz_work(int matrix_layout, char job, char compq, char compz, int n, int ilo, int ihi, _Complex float *h, int ldh, _Complex float *t, int ldt, _Complex float *alpha, _Complex float *beta, _Complex float *q, int ldq, _Complex float *z, int ldz, _Complex float *work, int lwork, float *rwork)
     * }
     */
    public static MemorySegment LAPACKE_chgeqz_work$address() {
        return LAPACKE_chgeqz_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_chgeqz_work(int matrix_layout, char job, char compq, char compz, int n, int ilo, int ihi, _Complex float *h, int ldh, _Complex float *t, int ldt, _Complex float *alpha, _Complex float *beta, _Complex float *q, int ldq, _Complex float *z, int ldz, _Complex float *work, int lwork, float *rwork)
     * }
     */
    public static int LAPACKE_chgeqz_work(int matrix_layout, byte job, byte compq, byte compz, int n, int ilo, int ihi, MemorySegment h, int ldh, MemorySegment t, int ldt, MemorySegment alpha, MemorySegment beta, MemorySegment q, int ldq, MemorySegment z, int ldz, MemorySegment work, int lwork, MemorySegment rwork) {
        var mh$ = LAPACKE_chgeqz_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_chgeqz_work", matrix_layout, job, compq, compz, n, ilo, ihi, h, ldh, t, ldt, alpha, beta, q, ldq, z, ldz, work, lwork, rwork);
            }
            return (int)mh$.invokeExact(matrix_layout, job, compq, compz, n, ilo, ihi, h, ldh, t, ldt, alpha, beta, q, ldq, z, ldz, work, lwork, rwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zhgeqz_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zhgeqz_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zhgeqz_work(int matrix_layout, char job, char compq, char compz, int n, int ilo, int ihi, _Complex double *h, int ldh, _Complex double *t, int ldt, _Complex double *alpha, _Complex double *beta, _Complex double *q, int ldq, _Complex double *z, int ldz, _Complex double *work, int lwork, double *rwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_zhgeqz_work$descriptor() {
        return LAPACKE_zhgeqz_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zhgeqz_work(int matrix_layout, char job, char compq, char compz, int n, int ilo, int ihi, _Complex double *h, int ldh, _Complex double *t, int ldt, _Complex double *alpha, _Complex double *beta, _Complex double *q, int ldq, _Complex double *z, int ldz, _Complex double *work, int lwork, double *rwork)
     * }
     */
    public static MethodHandle LAPACKE_zhgeqz_work$handle() {
        return LAPACKE_zhgeqz_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zhgeqz_work(int matrix_layout, char job, char compq, char compz, int n, int ilo, int ihi, _Complex double *h, int ldh, _Complex double *t, int ldt, _Complex double *alpha, _Complex double *beta, _Complex double *q, int ldq, _Complex double *z, int ldz, _Complex double *work, int lwork, double *rwork)
     * }
     */
    public static MemorySegment LAPACKE_zhgeqz_work$address() {
        return LAPACKE_zhgeqz_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zhgeqz_work(int matrix_layout, char job, char compq, char compz, int n, int ilo, int ihi, _Complex double *h, int ldh, _Complex double *t, int ldt, _Complex double *alpha, _Complex double *beta, _Complex double *q, int ldq, _Complex double *z, int ldz, _Complex double *work, int lwork, double *rwork)
     * }
     */
    public static int LAPACKE_zhgeqz_work(int matrix_layout, byte job, byte compq, byte compz, int n, int ilo, int ihi, MemorySegment h, int ldh, MemorySegment t, int ldt, MemorySegment alpha, MemorySegment beta, MemorySegment q, int ldq, MemorySegment z, int ldz, MemorySegment work, int lwork, MemorySegment rwork) {
        var mh$ = LAPACKE_zhgeqz_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zhgeqz_work", matrix_layout, job, compq, compz, n, ilo, ihi, h, ldh, t, ldt, alpha, beta, q, ldq, z, ldz, work, lwork, rwork);
            }
            return (int)mh$.invokeExact(matrix_layout, job, compq, compz, n, ilo, ihi, h, ldh, t, ldt, alpha, beta, q, ldq, z, ldz, work, lwork, rwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_chpcon_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_FLOAT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_chpcon_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_chpcon_work(int matrix_layout, char uplo, int n, const _Complex float *ap, const int *ipiv, float anorm, float *rcond, _Complex float *work)
     * }
     */
    public static FunctionDescriptor LAPACKE_chpcon_work$descriptor() {
        return LAPACKE_chpcon_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_chpcon_work(int matrix_layout, char uplo, int n, const _Complex float *ap, const int *ipiv, float anorm, float *rcond, _Complex float *work)
     * }
     */
    public static MethodHandle LAPACKE_chpcon_work$handle() {
        return LAPACKE_chpcon_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_chpcon_work(int matrix_layout, char uplo, int n, const _Complex float *ap, const int *ipiv, float anorm, float *rcond, _Complex float *work)
     * }
     */
    public static MemorySegment LAPACKE_chpcon_work$address() {
        return LAPACKE_chpcon_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_chpcon_work(int matrix_layout, char uplo, int n, const _Complex float *ap, const int *ipiv, float anorm, float *rcond, _Complex float *work)
     * }
     */
    public static int LAPACKE_chpcon_work(int matrix_layout, byte uplo, int n, MemorySegment ap, MemorySegment ipiv, float anorm, MemorySegment rcond, MemorySegment work) {
        var mh$ = LAPACKE_chpcon_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_chpcon_work", matrix_layout, uplo, n, ap, ipiv, anorm, rcond, work);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, ap, ipiv, anorm, rcond, work);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zhpcon_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_DOUBLE,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zhpcon_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zhpcon_work(int matrix_layout, char uplo, int n, const _Complex double *ap, const int *ipiv, double anorm, double *rcond, _Complex double *work)
     * }
     */
    public static FunctionDescriptor LAPACKE_zhpcon_work$descriptor() {
        return LAPACKE_zhpcon_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zhpcon_work(int matrix_layout, char uplo, int n, const _Complex double *ap, const int *ipiv, double anorm, double *rcond, _Complex double *work)
     * }
     */
    public static MethodHandle LAPACKE_zhpcon_work$handle() {
        return LAPACKE_zhpcon_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zhpcon_work(int matrix_layout, char uplo, int n, const _Complex double *ap, const int *ipiv, double anorm, double *rcond, _Complex double *work)
     * }
     */
    public static MemorySegment LAPACKE_zhpcon_work$address() {
        return LAPACKE_zhpcon_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zhpcon_work(int matrix_layout, char uplo, int n, const _Complex double *ap, const int *ipiv, double anorm, double *rcond, _Complex double *work)
     * }
     */
    public static int LAPACKE_zhpcon_work(int matrix_layout, byte uplo, int n, MemorySegment ap, MemorySegment ipiv, double anorm, MemorySegment rcond, MemorySegment work) {
        var mh$ = LAPACKE_zhpcon_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zhpcon_work", matrix_layout, uplo, n, ap, ipiv, anorm, rcond, work);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, ap, ipiv, anorm, rcond, work);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_chpev_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_chpev_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_chpev_work(int matrix_layout, char jobz, char uplo, int n, _Complex float *ap, float *w, _Complex float *z, int ldz, _Complex float *work, float *rwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_chpev_work$descriptor() {
        return LAPACKE_chpev_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_chpev_work(int matrix_layout, char jobz, char uplo, int n, _Complex float *ap, float *w, _Complex float *z, int ldz, _Complex float *work, float *rwork)
     * }
     */
    public static MethodHandle LAPACKE_chpev_work$handle() {
        return LAPACKE_chpev_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_chpev_work(int matrix_layout, char jobz, char uplo, int n, _Complex float *ap, float *w, _Complex float *z, int ldz, _Complex float *work, float *rwork)
     * }
     */
    public static MemorySegment LAPACKE_chpev_work$address() {
        return LAPACKE_chpev_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_chpev_work(int matrix_layout, char jobz, char uplo, int n, _Complex float *ap, float *w, _Complex float *z, int ldz, _Complex float *work, float *rwork)
     * }
     */
    public static int LAPACKE_chpev_work(int matrix_layout, byte jobz, byte uplo, int n, MemorySegment ap, MemorySegment w, MemorySegment z, int ldz, MemorySegment work, MemorySegment rwork) {
        var mh$ = LAPACKE_chpev_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_chpev_work", matrix_layout, jobz, uplo, n, ap, w, z, ldz, work, rwork);
            }
            return (int)mh$.invokeExact(matrix_layout, jobz, uplo, n, ap, w, z, ldz, work, rwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zhpev_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zhpev_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zhpev_work(int matrix_layout, char jobz, char uplo, int n, _Complex double *ap, double *w, _Complex double *z, int ldz, _Complex double *work, double *rwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_zhpev_work$descriptor() {
        return LAPACKE_zhpev_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zhpev_work(int matrix_layout, char jobz, char uplo, int n, _Complex double *ap, double *w, _Complex double *z, int ldz, _Complex double *work, double *rwork)
     * }
     */
    public static MethodHandle LAPACKE_zhpev_work$handle() {
        return LAPACKE_zhpev_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zhpev_work(int matrix_layout, char jobz, char uplo, int n, _Complex double *ap, double *w, _Complex double *z, int ldz, _Complex double *work, double *rwork)
     * }
     */
    public static MemorySegment LAPACKE_zhpev_work$address() {
        return LAPACKE_zhpev_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zhpev_work(int matrix_layout, char jobz, char uplo, int n, _Complex double *ap, double *w, _Complex double *z, int ldz, _Complex double *work, double *rwork)
     * }
     */
    public static int LAPACKE_zhpev_work(int matrix_layout, byte jobz, byte uplo, int n, MemorySegment ap, MemorySegment w, MemorySegment z, int ldz, MemorySegment work, MemorySegment rwork) {
        var mh$ = LAPACKE_zhpev_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zhpev_work", matrix_layout, jobz, uplo, n, ap, w, z, ldz, work, rwork);
            }
            return (int)mh$.invokeExact(matrix_layout, jobz, uplo, n, ap, w, z, ldz, work, rwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_chpevd_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_chpevd_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_chpevd_work(int matrix_layout, char jobz, char uplo, int n, _Complex float *ap, float *w, _Complex float *z, int ldz, _Complex float *work, int lwork, float *rwork, int lrwork, int *iwork, int liwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_chpevd_work$descriptor() {
        return LAPACKE_chpevd_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_chpevd_work(int matrix_layout, char jobz, char uplo, int n, _Complex float *ap, float *w, _Complex float *z, int ldz, _Complex float *work, int lwork, float *rwork, int lrwork, int *iwork, int liwork)
     * }
     */
    public static MethodHandle LAPACKE_chpevd_work$handle() {
        return LAPACKE_chpevd_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_chpevd_work(int matrix_layout, char jobz, char uplo, int n, _Complex float *ap, float *w, _Complex float *z, int ldz, _Complex float *work, int lwork, float *rwork, int lrwork, int *iwork, int liwork)
     * }
     */
    public static MemorySegment LAPACKE_chpevd_work$address() {
        return LAPACKE_chpevd_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_chpevd_work(int matrix_layout, char jobz, char uplo, int n, _Complex float *ap, float *w, _Complex float *z, int ldz, _Complex float *work, int lwork, float *rwork, int lrwork, int *iwork, int liwork)
     * }
     */
    public static int LAPACKE_chpevd_work(int matrix_layout, byte jobz, byte uplo, int n, MemorySegment ap, MemorySegment w, MemorySegment z, int ldz, MemorySegment work, int lwork, MemorySegment rwork, int lrwork, MemorySegment iwork, int liwork) {
        var mh$ = LAPACKE_chpevd_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_chpevd_work", matrix_layout, jobz, uplo, n, ap, w, z, ldz, work, lwork, rwork, lrwork, iwork, liwork);
            }
            return (int)mh$.invokeExact(matrix_layout, jobz, uplo, n, ap, w, z, ldz, work, lwork, rwork, lrwork, iwork, liwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zhpevd_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zhpevd_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zhpevd_work(int matrix_layout, char jobz, char uplo, int n, _Complex double *ap, double *w, _Complex double *z, int ldz, _Complex double *work, int lwork, double *rwork, int lrwork, int *iwork, int liwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_zhpevd_work$descriptor() {
        return LAPACKE_zhpevd_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zhpevd_work(int matrix_layout, char jobz, char uplo, int n, _Complex double *ap, double *w, _Complex double *z, int ldz, _Complex double *work, int lwork, double *rwork, int lrwork, int *iwork, int liwork)
     * }
     */
    public static MethodHandle LAPACKE_zhpevd_work$handle() {
        return LAPACKE_zhpevd_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zhpevd_work(int matrix_layout, char jobz, char uplo, int n, _Complex double *ap, double *w, _Complex double *z, int ldz, _Complex double *work, int lwork, double *rwork, int lrwork, int *iwork, int liwork)
     * }
     */
    public static MemorySegment LAPACKE_zhpevd_work$address() {
        return LAPACKE_zhpevd_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zhpevd_work(int matrix_layout, char jobz, char uplo, int n, _Complex double *ap, double *w, _Complex double *z, int ldz, _Complex double *work, int lwork, double *rwork, int lrwork, int *iwork, int liwork)
     * }
     */
    public static int LAPACKE_zhpevd_work(int matrix_layout, byte jobz, byte uplo, int n, MemorySegment ap, MemorySegment w, MemorySegment z, int ldz, MemorySegment work, int lwork, MemorySegment rwork, int lrwork, MemorySegment iwork, int liwork) {
        var mh$ = LAPACKE_zhpevd_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zhpevd_work", matrix_layout, jobz, uplo, n, ap, w, z, ldz, work, lwork, rwork, lrwork, iwork, liwork);
            }
            return (int)mh$.invokeExact(matrix_layout, jobz, uplo, n, ap, w, z, ldz, work, lwork, rwork, lrwork, iwork, liwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_chpevx_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_FLOAT,
            lapacke_h.C_FLOAT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_FLOAT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_chpevx_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_chpevx_work(int matrix_layout, char jobz, char range, char uplo, int n, _Complex float *ap, float vl, float vu, int il, int iu, float abstol, int *m, float *w, _Complex float *z, int ldz, _Complex float *work, float *rwork, int *iwork, int *ifail)
     * }
     */
    public static FunctionDescriptor LAPACKE_chpevx_work$descriptor() {
        return LAPACKE_chpevx_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_chpevx_work(int matrix_layout, char jobz, char range, char uplo, int n, _Complex float *ap, float vl, float vu, int il, int iu, float abstol, int *m, float *w, _Complex float *z, int ldz, _Complex float *work, float *rwork, int *iwork, int *ifail)
     * }
     */
    public static MethodHandle LAPACKE_chpevx_work$handle() {
        return LAPACKE_chpevx_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_chpevx_work(int matrix_layout, char jobz, char range, char uplo, int n, _Complex float *ap, float vl, float vu, int il, int iu, float abstol, int *m, float *w, _Complex float *z, int ldz, _Complex float *work, float *rwork, int *iwork, int *ifail)
     * }
     */
    public static MemorySegment LAPACKE_chpevx_work$address() {
        return LAPACKE_chpevx_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_chpevx_work(int matrix_layout, char jobz, char range, char uplo, int n, _Complex float *ap, float vl, float vu, int il, int iu, float abstol, int *m, float *w, _Complex float *z, int ldz, _Complex float *work, float *rwork, int *iwork, int *ifail)
     * }
     */
    public static int LAPACKE_chpevx_work(int matrix_layout, byte jobz, byte range, byte uplo, int n, MemorySegment ap, float vl, float vu, int il, int iu, float abstol, MemorySegment m, MemorySegment w, MemorySegment z, int ldz, MemorySegment work, MemorySegment rwork, MemorySegment iwork, MemorySegment ifail) {
        var mh$ = LAPACKE_chpevx_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_chpevx_work", matrix_layout, jobz, range, uplo, n, ap, vl, vu, il, iu, abstol, m, w, z, ldz, work, rwork, iwork, ifail);
            }
            return (int)mh$.invokeExact(matrix_layout, jobz, range, uplo, n, ap, vl, vu, il, iu, abstol, m, w, z, ldz, work, rwork, iwork, ifail);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zhpevx_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_DOUBLE,
            lapacke_h.C_DOUBLE,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_DOUBLE,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zhpevx_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zhpevx_work(int matrix_layout, char jobz, char range, char uplo, int n, _Complex double *ap, double vl, double vu, int il, int iu, double abstol, int *m, double *w, _Complex double *z, int ldz, _Complex double *work, double *rwork, int *iwork, int *ifail)
     * }
     */
    public static FunctionDescriptor LAPACKE_zhpevx_work$descriptor() {
        return LAPACKE_zhpevx_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zhpevx_work(int matrix_layout, char jobz, char range, char uplo, int n, _Complex double *ap, double vl, double vu, int il, int iu, double abstol, int *m, double *w, _Complex double *z, int ldz, _Complex double *work, double *rwork, int *iwork, int *ifail)
     * }
     */
    public static MethodHandle LAPACKE_zhpevx_work$handle() {
        return LAPACKE_zhpevx_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zhpevx_work(int matrix_layout, char jobz, char range, char uplo, int n, _Complex double *ap, double vl, double vu, int il, int iu, double abstol, int *m, double *w, _Complex double *z, int ldz, _Complex double *work, double *rwork, int *iwork, int *ifail)
     * }
     */
    public static MemorySegment LAPACKE_zhpevx_work$address() {
        return LAPACKE_zhpevx_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zhpevx_work(int matrix_layout, char jobz, char range, char uplo, int n, _Complex double *ap, double vl, double vu, int il, int iu, double abstol, int *m, double *w, _Complex double *z, int ldz, _Complex double *work, double *rwork, int *iwork, int *ifail)
     * }
     */
    public static int LAPACKE_zhpevx_work(int matrix_layout, byte jobz, byte range, byte uplo, int n, MemorySegment ap, double vl, double vu, int il, int iu, double abstol, MemorySegment m, MemorySegment w, MemorySegment z, int ldz, MemorySegment work, MemorySegment rwork, MemorySegment iwork, MemorySegment ifail) {
        var mh$ = LAPACKE_zhpevx_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zhpevx_work", matrix_layout, jobz, range, uplo, n, ap, vl, vu, il, iu, abstol, m, w, z, ldz, work, rwork, iwork, ifail);
            }
            return (int)mh$.invokeExact(matrix_layout, jobz, range, uplo, n, ap, vl, vu, il, iu, abstol, m, w, z, ldz, work, rwork, iwork, ifail);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_chpgst_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_chpgst_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_chpgst_work(int matrix_layout, int itype, char uplo, int n, _Complex float *ap, const _Complex float *bp)
     * }
     */
    public static FunctionDescriptor LAPACKE_chpgst_work$descriptor() {
        return LAPACKE_chpgst_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_chpgst_work(int matrix_layout, int itype, char uplo, int n, _Complex float *ap, const _Complex float *bp)
     * }
     */
    public static MethodHandle LAPACKE_chpgst_work$handle() {
        return LAPACKE_chpgst_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_chpgst_work(int matrix_layout, int itype, char uplo, int n, _Complex float *ap, const _Complex float *bp)
     * }
     */
    public static MemorySegment LAPACKE_chpgst_work$address() {
        return LAPACKE_chpgst_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_chpgst_work(int matrix_layout, int itype, char uplo, int n, _Complex float *ap, const _Complex float *bp)
     * }
     */
    public static int LAPACKE_chpgst_work(int matrix_layout, int itype, byte uplo, int n, MemorySegment ap, MemorySegment bp) {
        var mh$ = LAPACKE_chpgst_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_chpgst_work", matrix_layout, itype, uplo, n, ap, bp);
            }
            return (int)mh$.invokeExact(matrix_layout, itype, uplo, n, ap, bp);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zhpgst_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zhpgst_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zhpgst_work(int matrix_layout, int itype, char uplo, int n, _Complex double *ap, const _Complex double *bp)
     * }
     */
    public static FunctionDescriptor LAPACKE_zhpgst_work$descriptor() {
        return LAPACKE_zhpgst_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zhpgst_work(int matrix_layout, int itype, char uplo, int n, _Complex double *ap, const _Complex double *bp)
     * }
     */
    public static MethodHandle LAPACKE_zhpgst_work$handle() {
        return LAPACKE_zhpgst_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zhpgst_work(int matrix_layout, int itype, char uplo, int n, _Complex double *ap, const _Complex double *bp)
     * }
     */
    public static MemorySegment LAPACKE_zhpgst_work$address() {
        return LAPACKE_zhpgst_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zhpgst_work(int matrix_layout, int itype, char uplo, int n, _Complex double *ap, const _Complex double *bp)
     * }
     */
    public static int LAPACKE_zhpgst_work(int matrix_layout, int itype, byte uplo, int n, MemorySegment ap, MemorySegment bp) {
        var mh$ = LAPACKE_zhpgst_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zhpgst_work", matrix_layout, itype, uplo, n, ap, bp);
            }
            return (int)mh$.invokeExact(matrix_layout, itype, uplo, n, ap, bp);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_chpgv_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_chpgv_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_chpgv_work(int matrix_layout, int itype, char jobz, char uplo, int n, _Complex float *ap, _Complex float *bp, float *w, _Complex float *z, int ldz, _Complex float *work, float *rwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_chpgv_work$descriptor() {
        return LAPACKE_chpgv_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_chpgv_work(int matrix_layout, int itype, char jobz, char uplo, int n, _Complex float *ap, _Complex float *bp, float *w, _Complex float *z, int ldz, _Complex float *work, float *rwork)
     * }
     */
    public static MethodHandle LAPACKE_chpgv_work$handle() {
        return LAPACKE_chpgv_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_chpgv_work(int matrix_layout, int itype, char jobz, char uplo, int n, _Complex float *ap, _Complex float *bp, float *w, _Complex float *z, int ldz, _Complex float *work, float *rwork)
     * }
     */
    public static MemorySegment LAPACKE_chpgv_work$address() {
        return LAPACKE_chpgv_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_chpgv_work(int matrix_layout, int itype, char jobz, char uplo, int n, _Complex float *ap, _Complex float *bp, float *w, _Complex float *z, int ldz, _Complex float *work, float *rwork)
     * }
     */
    public static int LAPACKE_chpgv_work(int matrix_layout, int itype, byte jobz, byte uplo, int n, MemorySegment ap, MemorySegment bp, MemorySegment w, MemorySegment z, int ldz, MemorySegment work, MemorySegment rwork) {
        var mh$ = LAPACKE_chpgv_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_chpgv_work", matrix_layout, itype, jobz, uplo, n, ap, bp, w, z, ldz, work, rwork);
            }
            return (int)mh$.invokeExact(matrix_layout, itype, jobz, uplo, n, ap, bp, w, z, ldz, work, rwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zhpgv_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zhpgv_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zhpgv_work(int matrix_layout, int itype, char jobz, char uplo, int n, _Complex double *ap, _Complex double *bp, double *w, _Complex double *z, int ldz, _Complex double *work, double *rwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_zhpgv_work$descriptor() {
        return LAPACKE_zhpgv_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zhpgv_work(int matrix_layout, int itype, char jobz, char uplo, int n, _Complex double *ap, _Complex double *bp, double *w, _Complex double *z, int ldz, _Complex double *work, double *rwork)
     * }
     */
    public static MethodHandle LAPACKE_zhpgv_work$handle() {
        return LAPACKE_zhpgv_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zhpgv_work(int matrix_layout, int itype, char jobz, char uplo, int n, _Complex double *ap, _Complex double *bp, double *w, _Complex double *z, int ldz, _Complex double *work, double *rwork)
     * }
     */
    public static MemorySegment LAPACKE_zhpgv_work$address() {
        return LAPACKE_zhpgv_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zhpgv_work(int matrix_layout, int itype, char jobz, char uplo, int n, _Complex double *ap, _Complex double *bp, double *w, _Complex double *z, int ldz, _Complex double *work, double *rwork)
     * }
     */
    public static int LAPACKE_zhpgv_work(int matrix_layout, int itype, byte jobz, byte uplo, int n, MemorySegment ap, MemorySegment bp, MemorySegment w, MemorySegment z, int ldz, MemorySegment work, MemorySegment rwork) {
        var mh$ = LAPACKE_zhpgv_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zhpgv_work", matrix_layout, itype, jobz, uplo, n, ap, bp, w, z, ldz, work, rwork);
            }
            return (int)mh$.invokeExact(matrix_layout, itype, jobz, uplo, n, ap, bp, w, z, ldz, work, rwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_chpgvd_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_chpgvd_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_chpgvd_work(int matrix_layout, int itype, char jobz, char uplo, int n, _Complex float *ap, _Complex float *bp, float *w, _Complex float *z, int ldz, _Complex float *work, int lwork, float *rwork, int lrwork, int *iwork, int liwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_chpgvd_work$descriptor() {
        return LAPACKE_chpgvd_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_chpgvd_work(int matrix_layout, int itype, char jobz, char uplo, int n, _Complex float *ap, _Complex float *bp, float *w, _Complex float *z, int ldz, _Complex float *work, int lwork, float *rwork, int lrwork, int *iwork, int liwork)
     * }
     */
    public static MethodHandle LAPACKE_chpgvd_work$handle() {
        return LAPACKE_chpgvd_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_chpgvd_work(int matrix_layout, int itype, char jobz, char uplo, int n, _Complex float *ap, _Complex float *bp, float *w, _Complex float *z, int ldz, _Complex float *work, int lwork, float *rwork, int lrwork, int *iwork, int liwork)
     * }
     */
    public static MemorySegment LAPACKE_chpgvd_work$address() {
        return LAPACKE_chpgvd_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_chpgvd_work(int matrix_layout, int itype, char jobz, char uplo, int n, _Complex float *ap, _Complex float *bp, float *w, _Complex float *z, int ldz, _Complex float *work, int lwork, float *rwork, int lrwork, int *iwork, int liwork)
     * }
     */
    public static int LAPACKE_chpgvd_work(int matrix_layout, int itype, byte jobz, byte uplo, int n, MemorySegment ap, MemorySegment bp, MemorySegment w, MemorySegment z, int ldz, MemorySegment work, int lwork, MemorySegment rwork, int lrwork, MemorySegment iwork, int liwork) {
        var mh$ = LAPACKE_chpgvd_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_chpgvd_work", matrix_layout, itype, jobz, uplo, n, ap, bp, w, z, ldz, work, lwork, rwork, lrwork, iwork, liwork);
            }
            return (int)mh$.invokeExact(matrix_layout, itype, jobz, uplo, n, ap, bp, w, z, ldz, work, lwork, rwork, lrwork, iwork, liwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zhpgvd_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zhpgvd_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zhpgvd_work(int matrix_layout, int itype, char jobz, char uplo, int n, _Complex double *ap, _Complex double *bp, double *w, _Complex double *z, int ldz, _Complex double *work, int lwork, double *rwork, int lrwork, int *iwork, int liwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_zhpgvd_work$descriptor() {
        return LAPACKE_zhpgvd_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zhpgvd_work(int matrix_layout, int itype, char jobz, char uplo, int n, _Complex double *ap, _Complex double *bp, double *w, _Complex double *z, int ldz, _Complex double *work, int lwork, double *rwork, int lrwork, int *iwork, int liwork)
     * }
     */
    public static MethodHandle LAPACKE_zhpgvd_work$handle() {
        return LAPACKE_zhpgvd_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zhpgvd_work(int matrix_layout, int itype, char jobz, char uplo, int n, _Complex double *ap, _Complex double *bp, double *w, _Complex double *z, int ldz, _Complex double *work, int lwork, double *rwork, int lrwork, int *iwork, int liwork)
     * }
     */
    public static MemorySegment LAPACKE_zhpgvd_work$address() {
        return LAPACKE_zhpgvd_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zhpgvd_work(int matrix_layout, int itype, char jobz, char uplo, int n, _Complex double *ap, _Complex double *bp, double *w, _Complex double *z, int ldz, _Complex double *work, int lwork, double *rwork, int lrwork, int *iwork, int liwork)
     * }
     */
    public static int LAPACKE_zhpgvd_work(int matrix_layout, int itype, byte jobz, byte uplo, int n, MemorySegment ap, MemorySegment bp, MemorySegment w, MemorySegment z, int ldz, MemorySegment work, int lwork, MemorySegment rwork, int lrwork, MemorySegment iwork, int liwork) {
        var mh$ = LAPACKE_zhpgvd_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zhpgvd_work", matrix_layout, itype, jobz, uplo, n, ap, bp, w, z, ldz, work, lwork, rwork, lrwork, iwork, liwork);
            }
            return (int)mh$.invokeExact(matrix_layout, itype, jobz, uplo, n, ap, bp, w, z, ldz, work, lwork, rwork, lrwork, iwork, liwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_chpgvx_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_FLOAT,
            lapacke_h.C_FLOAT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_FLOAT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_chpgvx_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_chpgvx_work(int matrix_layout, int itype, char jobz, char range, char uplo, int n, _Complex float *ap, _Complex float *bp, float vl, float vu, int il, int iu, float abstol, int *m, float *w, _Complex float *z, int ldz, _Complex float *work, float *rwork, int *iwork, int *ifail)
     * }
     */
    public static FunctionDescriptor LAPACKE_chpgvx_work$descriptor() {
        return LAPACKE_chpgvx_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_chpgvx_work(int matrix_layout, int itype, char jobz, char range, char uplo, int n, _Complex float *ap, _Complex float *bp, float vl, float vu, int il, int iu, float abstol, int *m, float *w, _Complex float *z, int ldz, _Complex float *work, float *rwork, int *iwork, int *ifail)
     * }
     */
    public static MethodHandle LAPACKE_chpgvx_work$handle() {
        return LAPACKE_chpgvx_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_chpgvx_work(int matrix_layout, int itype, char jobz, char range, char uplo, int n, _Complex float *ap, _Complex float *bp, float vl, float vu, int il, int iu, float abstol, int *m, float *w, _Complex float *z, int ldz, _Complex float *work, float *rwork, int *iwork, int *ifail)
     * }
     */
    public static MemorySegment LAPACKE_chpgvx_work$address() {
        return LAPACKE_chpgvx_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_chpgvx_work(int matrix_layout, int itype, char jobz, char range, char uplo, int n, _Complex float *ap, _Complex float *bp, float vl, float vu, int il, int iu, float abstol, int *m, float *w, _Complex float *z, int ldz, _Complex float *work, float *rwork, int *iwork, int *ifail)
     * }
     */
    public static int LAPACKE_chpgvx_work(int matrix_layout, int itype, byte jobz, byte range, byte uplo, int n, MemorySegment ap, MemorySegment bp, float vl, float vu, int il, int iu, float abstol, MemorySegment m, MemorySegment w, MemorySegment z, int ldz, MemorySegment work, MemorySegment rwork, MemorySegment iwork, MemorySegment ifail) {
        var mh$ = LAPACKE_chpgvx_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_chpgvx_work", matrix_layout, itype, jobz, range, uplo, n, ap, bp, vl, vu, il, iu, abstol, m, w, z, ldz, work, rwork, iwork, ifail);
            }
            return (int)mh$.invokeExact(matrix_layout, itype, jobz, range, uplo, n, ap, bp, vl, vu, il, iu, abstol, m, w, z, ldz, work, rwork, iwork, ifail);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zhpgvx_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_DOUBLE,
            lapacke_h.C_DOUBLE,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_DOUBLE,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zhpgvx_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zhpgvx_work(int matrix_layout, int itype, char jobz, char range, char uplo, int n, _Complex double *ap, _Complex double *bp, double vl, double vu, int il, int iu, double abstol, int *m, double *w, _Complex double *z, int ldz, _Complex double *work, double *rwork, int *iwork, int *ifail)
     * }
     */
    public static FunctionDescriptor LAPACKE_zhpgvx_work$descriptor() {
        return LAPACKE_zhpgvx_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zhpgvx_work(int matrix_layout, int itype, char jobz, char range, char uplo, int n, _Complex double *ap, _Complex double *bp, double vl, double vu, int il, int iu, double abstol, int *m, double *w, _Complex double *z, int ldz, _Complex double *work, double *rwork, int *iwork, int *ifail)
     * }
     */
    public static MethodHandle LAPACKE_zhpgvx_work$handle() {
        return LAPACKE_zhpgvx_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zhpgvx_work(int matrix_layout, int itype, char jobz, char range, char uplo, int n, _Complex double *ap, _Complex double *bp, double vl, double vu, int il, int iu, double abstol, int *m, double *w, _Complex double *z, int ldz, _Complex double *work, double *rwork, int *iwork, int *ifail)
     * }
     */
    public static MemorySegment LAPACKE_zhpgvx_work$address() {
        return LAPACKE_zhpgvx_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zhpgvx_work(int matrix_layout, int itype, char jobz, char range, char uplo, int n, _Complex double *ap, _Complex double *bp, double vl, double vu, int il, int iu, double abstol, int *m, double *w, _Complex double *z, int ldz, _Complex double *work, double *rwork, int *iwork, int *ifail)
     * }
     */
    public static int LAPACKE_zhpgvx_work(int matrix_layout, int itype, byte jobz, byte range, byte uplo, int n, MemorySegment ap, MemorySegment bp, double vl, double vu, int il, int iu, double abstol, MemorySegment m, MemorySegment w, MemorySegment z, int ldz, MemorySegment work, MemorySegment rwork, MemorySegment iwork, MemorySegment ifail) {
        var mh$ = LAPACKE_zhpgvx_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zhpgvx_work", matrix_layout, itype, jobz, range, uplo, n, ap, bp, vl, vu, il, iu, abstol, m, w, z, ldz, work, rwork, iwork, ifail);
            }
            return (int)mh$.invokeExact(matrix_layout, itype, jobz, range, uplo, n, ap, bp, vl, vu, il, iu, abstol, m, w, z, ldz, work, rwork, iwork, ifail);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_chprfs_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_chprfs_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_chprfs_work(int matrix_layout, char uplo, int n, int nrhs, const _Complex float *ap, const _Complex float *afp, const int *ipiv, const _Complex float *b, int ldb, _Complex float *x, int ldx, float *ferr, float *berr, _Complex float *work, float *rwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_chprfs_work$descriptor() {
        return LAPACKE_chprfs_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_chprfs_work(int matrix_layout, char uplo, int n, int nrhs, const _Complex float *ap, const _Complex float *afp, const int *ipiv, const _Complex float *b, int ldb, _Complex float *x, int ldx, float *ferr, float *berr, _Complex float *work, float *rwork)
     * }
     */
    public static MethodHandle LAPACKE_chprfs_work$handle() {
        return LAPACKE_chprfs_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_chprfs_work(int matrix_layout, char uplo, int n, int nrhs, const _Complex float *ap, const _Complex float *afp, const int *ipiv, const _Complex float *b, int ldb, _Complex float *x, int ldx, float *ferr, float *berr, _Complex float *work, float *rwork)
     * }
     */
    public static MemorySegment LAPACKE_chprfs_work$address() {
        return LAPACKE_chprfs_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_chprfs_work(int matrix_layout, char uplo, int n, int nrhs, const _Complex float *ap, const _Complex float *afp, const int *ipiv, const _Complex float *b, int ldb, _Complex float *x, int ldx, float *ferr, float *berr, _Complex float *work, float *rwork)
     * }
     */
    public static int LAPACKE_chprfs_work(int matrix_layout, byte uplo, int n, int nrhs, MemorySegment ap, MemorySegment afp, MemorySegment ipiv, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment ferr, MemorySegment berr, MemorySegment work, MemorySegment rwork) {
        var mh$ = LAPACKE_chprfs_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_chprfs_work", matrix_layout, uplo, n, nrhs, ap, afp, ipiv, b, ldb, x, ldx, ferr, berr, work, rwork);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, nrhs, ap, afp, ipiv, b, ldb, x, ldx, ferr, berr, work, rwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zhprfs_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zhprfs_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zhprfs_work(int matrix_layout, char uplo, int n, int nrhs, const _Complex double *ap, const _Complex double *afp, const int *ipiv, const _Complex double *b, int ldb, _Complex double *x, int ldx, double *ferr, double *berr, _Complex double *work, double *rwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_zhprfs_work$descriptor() {
        return LAPACKE_zhprfs_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zhprfs_work(int matrix_layout, char uplo, int n, int nrhs, const _Complex double *ap, const _Complex double *afp, const int *ipiv, const _Complex double *b, int ldb, _Complex double *x, int ldx, double *ferr, double *berr, _Complex double *work, double *rwork)
     * }
     */
    public static MethodHandle LAPACKE_zhprfs_work$handle() {
        return LAPACKE_zhprfs_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zhprfs_work(int matrix_layout, char uplo, int n, int nrhs, const _Complex double *ap, const _Complex double *afp, const int *ipiv, const _Complex double *b, int ldb, _Complex double *x, int ldx, double *ferr, double *berr, _Complex double *work, double *rwork)
     * }
     */
    public static MemorySegment LAPACKE_zhprfs_work$address() {
        return LAPACKE_zhprfs_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zhprfs_work(int matrix_layout, char uplo, int n, int nrhs, const _Complex double *ap, const _Complex double *afp, const int *ipiv, const _Complex double *b, int ldb, _Complex double *x, int ldx, double *ferr, double *berr, _Complex double *work, double *rwork)
     * }
     */
    public static int LAPACKE_zhprfs_work(int matrix_layout, byte uplo, int n, int nrhs, MemorySegment ap, MemorySegment afp, MemorySegment ipiv, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment ferr, MemorySegment berr, MemorySegment work, MemorySegment rwork) {
        var mh$ = LAPACKE_zhprfs_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zhprfs_work", matrix_layout, uplo, n, nrhs, ap, afp, ipiv, b, ldb, x, ldx, ferr, berr, work, rwork);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, nrhs, ap, afp, ipiv, b, ldb, x, ldx, ferr, berr, work, rwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_chpsv_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_chpsv_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_chpsv_work(int matrix_layout, char uplo, int n, int nrhs, _Complex float *ap, int *ipiv, _Complex float *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_chpsv_work$descriptor() {
        return LAPACKE_chpsv_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_chpsv_work(int matrix_layout, char uplo, int n, int nrhs, _Complex float *ap, int *ipiv, _Complex float *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_chpsv_work$handle() {
        return LAPACKE_chpsv_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_chpsv_work(int matrix_layout, char uplo, int n, int nrhs, _Complex float *ap, int *ipiv, _Complex float *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_chpsv_work$address() {
        return LAPACKE_chpsv_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_chpsv_work(int matrix_layout, char uplo, int n, int nrhs, _Complex float *ap, int *ipiv, _Complex float *b, int ldb)
     * }
     */
    public static int LAPACKE_chpsv_work(int matrix_layout, byte uplo, int n, int nrhs, MemorySegment ap, MemorySegment ipiv, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_chpsv_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_chpsv_work", matrix_layout, uplo, n, nrhs, ap, ipiv, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, nrhs, ap, ipiv, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zhpsv_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zhpsv_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zhpsv_work(int matrix_layout, char uplo, int n, int nrhs, _Complex double *ap, int *ipiv, _Complex double *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_zhpsv_work$descriptor() {
        return LAPACKE_zhpsv_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zhpsv_work(int matrix_layout, char uplo, int n, int nrhs, _Complex double *ap, int *ipiv, _Complex double *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_zhpsv_work$handle() {
        return LAPACKE_zhpsv_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zhpsv_work(int matrix_layout, char uplo, int n, int nrhs, _Complex double *ap, int *ipiv, _Complex double *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_zhpsv_work$address() {
        return LAPACKE_zhpsv_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zhpsv_work(int matrix_layout, char uplo, int n, int nrhs, _Complex double *ap, int *ipiv, _Complex double *b, int ldb)
     * }
     */
    public static int LAPACKE_zhpsv_work(int matrix_layout, byte uplo, int n, int nrhs, MemorySegment ap, MemorySegment ipiv, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_zhpsv_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zhpsv_work", matrix_layout, uplo, n, nrhs, ap, ipiv, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, nrhs, ap, ipiv, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_chpsvx_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_chpsvx_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_chpsvx_work(int matrix_layout, char fact, char uplo, int n, int nrhs, const _Complex float *ap, _Complex float *afp, int *ipiv, const _Complex float *b, int ldb, _Complex float *x, int ldx, float *rcond, float *ferr, float *berr, _Complex float *work, float *rwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_chpsvx_work$descriptor() {
        return LAPACKE_chpsvx_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_chpsvx_work(int matrix_layout, char fact, char uplo, int n, int nrhs, const _Complex float *ap, _Complex float *afp, int *ipiv, const _Complex float *b, int ldb, _Complex float *x, int ldx, float *rcond, float *ferr, float *berr, _Complex float *work, float *rwork)
     * }
     */
    public static MethodHandle LAPACKE_chpsvx_work$handle() {
        return LAPACKE_chpsvx_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_chpsvx_work(int matrix_layout, char fact, char uplo, int n, int nrhs, const _Complex float *ap, _Complex float *afp, int *ipiv, const _Complex float *b, int ldb, _Complex float *x, int ldx, float *rcond, float *ferr, float *berr, _Complex float *work, float *rwork)
     * }
     */
    public static MemorySegment LAPACKE_chpsvx_work$address() {
        return LAPACKE_chpsvx_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_chpsvx_work(int matrix_layout, char fact, char uplo, int n, int nrhs, const _Complex float *ap, _Complex float *afp, int *ipiv, const _Complex float *b, int ldb, _Complex float *x, int ldx, float *rcond, float *ferr, float *berr, _Complex float *work, float *rwork)
     * }
     */
    public static int LAPACKE_chpsvx_work(int matrix_layout, byte fact, byte uplo, int n, int nrhs, MemorySegment ap, MemorySegment afp, MemorySegment ipiv, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment rcond, MemorySegment ferr, MemorySegment berr, MemorySegment work, MemorySegment rwork) {
        var mh$ = LAPACKE_chpsvx_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_chpsvx_work", matrix_layout, fact, uplo, n, nrhs, ap, afp, ipiv, b, ldb, x, ldx, rcond, ferr, berr, work, rwork);
            }
            return (int)mh$.invokeExact(matrix_layout, fact, uplo, n, nrhs, ap, afp, ipiv, b, ldb, x, ldx, rcond, ferr, berr, work, rwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zhpsvx_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zhpsvx_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zhpsvx_work(int matrix_layout, char fact, char uplo, int n, int nrhs, const _Complex double *ap, _Complex double *afp, int *ipiv, const _Complex double *b, int ldb, _Complex double *x, int ldx, double *rcond, double *ferr, double *berr, _Complex double *work, double *rwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_zhpsvx_work$descriptor() {
        return LAPACKE_zhpsvx_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zhpsvx_work(int matrix_layout, char fact, char uplo, int n, int nrhs, const _Complex double *ap, _Complex double *afp, int *ipiv, const _Complex double *b, int ldb, _Complex double *x, int ldx, double *rcond, double *ferr, double *berr, _Complex double *work, double *rwork)
     * }
     */
    public static MethodHandle LAPACKE_zhpsvx_work$handle() {
        return LAPACKE_zhpsvx_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zhpsvx_work(int matrix_layout, char fact, char uplo, int n, int nrhs, const _Complex double *ap, _Complex double *afp, int *ipiv, const _Complex double *b, int ldb, _Complex double *x, int ldx, double *rcond, double *ferr, double *berr, _Complex double *work, double *rwork)
     * }
     */
    public static MemorySegment LAPACKE_zhpsvx_work$address() {
        return LAPACKE_zhpsvx_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zhpsvx_work(int matrix_layout, char fact, char uplo, int n, int nrhs, const _Complex double *ap, _Complex double *afp, int *ipiv, const _Complex double *b, int ldb, _Complex double *x, int ldx, double *rcond, double *ferr, double *berr, _Complex double *work, double *rwork)
     * }
     */
    public static int LAPACKE_zhpsvx_work(int matrix_layout, byte fact, byte uplo, int n, int nrhs, MemorySegment ap, MemorySegment afp, MemorySegment ipiv, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment rcond, MemorySegment ferr, MemorySegment berr, MemorySegment work, MemorySegment rwork) {
        var mh$ = LAPACKE_zhpsvx_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zhpsvx_work", matrix_layout, fact, uplo, n, nrhs, ap, afp, ipiv, b, ldb, x, ldx, rcond, ferr, berr, work, rwork);
            }
            return (int)mh$.invokeExact(matrix_layout, fact, uplo, n, nrhs, ap, afp, ipiv, b, ldb, x, ldx, rcond, ferr, berr, work, rwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_chptrd_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_chptrd_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_chptrd_work(int matrix_layout, char uplo, int n, _Complex float *ap, float *d, float *e, _Complex float *tau)
     * }
     */
    public static FunctionDescriptor LAPACKE_chptrd_work$descriptor() {
        return LAPACKE_chptrd_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_chptrd_work(int matrix_layout, char uplo, int n, _Complex float *ap, float *d, float *e, _Complex float *tau)
     * }
     */
    public static MethodHandle LAPACKE_chptrd_work$handle() {
        return LAPACKE_chptrd_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_chptrd_work(int matrix_layout, char uplo, int n, _Complex float *ap, float *d, float *e, _Complex float *tau)
     * }
     */
    public static MemorySegment LAPACKE_chptrd_work$address() {
        return LAPACKE_chptrd_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_chptrd_work(int matrix_layout, char uplo, int n, _Complex float *ap, float *d, float *e, _Complex float *tau)
     * }
     */
    public static int LAPACKE_chptrd_work(int matrix_layout, byte uplo, int n, MemorySegment ap, MemorySegment d, MemorySegment e, MemorySegment tau) {
        var mh$ = LAPACKE_chptrd_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_chptrd_work", matrix_layout, uplo, n, ap, d, e, tau);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, ap, d, e, tau);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zhptrd_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zhptrd_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zhptrd_work(int matrix_layout, char uplo, int n, _Complex double *ap, double *d, double *e, _Complex double *tau)
     * }
     */
    public static FunctionDescriptor LAPACKE_zhptrd_work$descriptor() {
        return LAPACKE_zhptrd_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zhptrd_work(int matrix_layout, char uplo, int n, _Complex double *ap, double *d, double *e, _Complex double *tau)
     * }
     */
    public static MethodHandle LAPACKE_zhptrd_work$handle() {
        return LAPACKE_zhptrd_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zhptrd_work(int matrix_layout, char uplo, int n, _Complex double *ap, double *d, double *e, _Complex double *tau)
     * }
     */
    public static MemorySegment LAPACKE_zhptrd_work$address() {
        return LAPACKE_zhptrd_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zhptrd_work(int matrix_layout, char uplo, int n, _Complex double *ap, double *d, double *e, _Complex double *tau)
     * }
     */
    public static int LAPACKE_zhptrd_work(int matrix_layout, byte uplo, int n, MemorySegment ap, MemorySegment d, MemorySegment e, MemorySegment tau) {
        var mh$ = LAPACKE_zhptrd_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zhptrd_work", matrix_layout, uplo, n, ap, d, e, tau);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, ap, d, e, tau);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_chptrf_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_chptrf_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_chptrf_work(int matrix_layout, char uplo, int n, _Complex float *ap, int *ipiv)
     * }
     */
    public static FunctionDescriptor LAPACKE_chptrf_work$descriptor() {
        return LAPACKE_chptrf_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_chptrf_work(int matrix_layout, char uplo, int n, _Complex float *ap, int *ipiv)
     * }
     */
    public static MethodHandle LAPACKE_chptrf_work$handle() {
        return LAPACKE_chptrf_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_chptrf_work(int matrix_layout, char uplo, int n, _Complex float *ap, int *ipiv)
     * }
     */
    public static MemorySegment LAPACKE_chptrf_work$address() {
        return LAPACKE_chptrf_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_chptrf_work(int matrix_layout, char uplo, int n, _Complex float *ap, int *ipiv)
     * }
     */
    public static int LAPACKE_chptrf_work(int matrix_layout, byte uplo, int n, MemorySegment ap, MemorySegment ipiv) {
        var mh$ = LAPACKE_chptrf_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_chptrf_work", matrix_layout, uplo, n, ap, ipiv);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, ap, ipiv);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zhptrf_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zhptrf_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zhptrf_work(int matrix_layout, char uplo, int n, _Complex double *ap, int *ipiv)
     * }
     */
    public static FunctionDescriptor LAPACKE_zhptrf_work$descriptor() {
        return LAPACKE_zhptrf_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zhptrf_work(int matrix_layout, char uplo, int n, _Complex double *ap, int *ipiv)
     * }
     */
    public static MethodHandle LAPACKE_zhptrf_work$handle() {
        return LAPACKE_zhptrf_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zhptrf_work(int matrix_layout, char uplo, int n, _Complex double *ap, int *ipiv)
     * }
     */
    public static MemorySegment LAPACKE_zhptrf_work$address() {
        return LAPACKE_zhptrf_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zhptrf_work(int matrix_layout, char uplo, int n, _Complex double *ap, int *ipiv)
     * }
     */
    public static int LAPACKE_zhptrf_work(int matrix_layout, byte uplo, int n, MemorySegment ap, MemorySegment ipiv) {
        var mh$ = LAPACKE_zhptrf_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zhptrf_work", matrix_layout, uplo, n, ap, ipiv);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, ap, ipiv);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_chptri_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_chptri_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_chptri_work(int matrix_layout, char uplo, int n, _Complex float *ap, const int *ipiv, _Complex float *work)
     * }
     */
    public static FunctionDescriptor LAPACKE_chptri_work$descriptor() {
        return LAPACKE_chptri_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_chptri_work(int matrix_layout, char uplo, int n, _Complex float *ap, const int *ipiv, _Complex float *work)
     * }
     */
    public static MethodHandle LAPACKE_chptri_work$handle() {
        return LAPACKE_chptri_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_chptri_work(int matrix_layout, char uplo, int n, _Complex float *ap, const int *ipiv, _Complex float *work)
     * }
     */
    public static MemorySegment LAPACKE_chptri_work$address() {
        return LAPACKE_chptri_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_chptri_work(int matrix_layout, char uplo, int n, _Complex float *ap, const int *ipiv, _Complex float *work)
     * }
     */
    public static int LAPACKE_chptri_work(int matrix_layout, byte uplo, int n, MemorySegment ap, MemorySegment ipiv, MemorySegment work) {
        var mh$ = LAPACKE_chptri_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_chptri_work", matrix_layout, uplo, n, ap, ipiv, work);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, ap, ipiv, work);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zhptri_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zhptri_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zhptri_work(int matrix_layout, char uplo, int n, _Complex double *ap, const int *ipiv, _Complex double *work)
     * }
     */
    public static FunctionDescriptor LAPACKE_zhptri_work$descriptor() {
        return LAPACKE_zhptri_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zhptri_work(int matrix_layout, char uplo, int n, _Complex double *ap, const int *ipiv, _Complex double *work)
     * }
     */
    public static MethodHandle LAPACKE_zhptri_work$handle() {
        return LAPACKE_zhptri_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zhptri_work(int matrix_layout, char uplo, int n, _Complex double *ap, const int *ipiv, _Complex double *work)
     * }
     */
    public static MemorySegment LAPACKE_zhptri_work$address() {
        return LAPACKE_zhptri_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zhptri_work(int matrix_layout, char uplo, int n, _Complex double *ap, const int *ipiv, _Complex double *work)
     * }
     */
    public static int LAPACKE_zhptri_work(int matrix_layout, byte uplo, int n, MemorySegment ap, MemorySegment ipiv, MemorySegment work) {
        var mh$ = LAPACKE_zhptri_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zhptri_work", matrix_layout, uplo, n, ap, ipiv, work);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, ap, ipiv, work);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_chptrs_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_chptrs_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_chptrs_work(int matrix_layout, char uplo, int n, int nrhs, const _Complex float *ap, const int *ipiv, _Complex float *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_chptrs_work$descriptor() {
        return LAPACKE_chptrs_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_chptrs_work(int matrix_layout, char uplo, int n, int nrhs, const _Complex float *ap, const int *ipiv, _Complex float *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_chptrs_work$handle() {
        return LAPACKE_chptrs_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_chptrs_work(int matrix_layout, char uplo, int n, int nrhs, const _Complex float *ap, const int *ipiv, _Complex float *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_chptrs_work$address() {
        return LAPACKE_chptrs_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_chptrs_work(int matrix_layout, char uplo, int n, int nrhs, const _Complex float *ap, const int *ipiv, _Complex float *b, int ldb)
     * }
     */
    public static int LAPACKE_chptrs_work(int matrix_layout, byte uplo, int n, int nrhs, MemorySegment ap, MemorySegment ipiv, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_chptrs_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_chptrs_work", matrix_layout, uplo, n, nrhs, ap, ipiv, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, nrhs, ap, ipiv, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zhptrs_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zhptrs_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zhptrs_work(int matrix_layout, char uplo, int n, int nrhs, const _Complex double *ap, const int *ipiv, _Complex double *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_zhptrs_work$descriptor() {
        return LAPACKE_zhptrs_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zhptrs_work(int matrix_layout, char uplo, int n, int nrhs, const _Complex double *ap, const int *ipiv, _Complex double *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_zhptrs_work$handle() {
        return LAPACKE_zhptrs_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zhptrs_work(int matrix_layout, char uplo, int n, int nrhs, const _Complex double *ap, const int *ipiv, _Complex double *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_zhptrs_work$address() {
        return LAPACKE_zhptrs_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zhptrs_work(int matrix_layout, char uplo, int n, int nrhs, const _Complex double *ap, const int *ipiv, _Complex double *b, int ldb)
     * }
     */
    public static int LAPACKE_zhptrs_work(int matrix_layout, byte uplo, int n, int nrhs, MemorySegment ap, MemorySegment ipiv, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_zhptrs_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zhptrs_work", matrix_layout, uplo, n, nrhs, ap, ipiv, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, nrhs, ap, ipiv, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_shsein_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_shsein_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_shsein_work(int matrix_layout, char job, char eigsrc, char initv, int *select, int n, const float *h, int ldh, float *wr, const float *wi, float *vl, int ldvl, float *vr, int ldvr, int mm, int *m, float *work, int *ifaill, int *ifailr)
     * }
     */
    public static FunctionDescriptor LAPACKE_shsein_work$descriptor() {
        return LAPACKE_shsein_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_shsein_work(int matrix_layout, char job, char eigsrc, char initv, int *select, int n, const float *h, int ldh, float *wr, const float *wi, float *vl, int ldvl, float *vr, int ldvr, int mm, int *m, float *work, int *ifaill, int *ifailr)
     * }
     */
    public static MethodHandle LAPACKE_shsein_work$handle() {
        return LAPACKE_shsein_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_shsein_work(int matrix_layout, char job, char eigsrc, char initv, int *select, int n, const float *h, int ldh, float *wr, const float *wi, float *vl, int ldvl, float *vr, int ldvr, int mm, int *m, float *work, int *ifaill, int *ifailr)
     * }
     */
    public static MemorySegment LAPACKE_shsein_work$address() {
        return LAPACKE_shsein_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_shsein_work(int matrix_layout, char job, char eigsrc, char initv, int *select, int n, const float *h, int ldh, float *wr, const float *wi, float *vl, int ldvl, float *vr, int ldvr, int mm, int *m, float *work, int *ifaill, int *ifailr)
     * }
     */
    public static int LAPACKE_shsein_work(int matrix_layout, byte job, byte eigsrc, byte initv, MemorySegment select, int n, MemorySegment h, int ldh, MemorySegment wr, MemorySegment wi, MemorySegment vl, int ldvl, MemorySegment vr, int ldvr, int mm, MemorySegment m, MemorySegment work, MemorySegment ifaill, MemorySegment ifailr) {
        var mh$ = LAPACKE_shsein_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_shsein_work", matrix_layout, job, eigsrc, initv, select, n, h, ldh, wr, wi, vl, ldvl, vr, ldvr, mm, m, work, ifaill, ifailr);
            }
            return (int)mh$.invokeExact(matrix_layout, job, eigsrc, initv, select, n, h, ldh, wr, wi, vl, ldvl, vr, ldvr, mm, m, work, ifaill, ifailr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dhsein_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dhsein_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dhsein_work(int matrix_layout, char job, char eigsrc, char initv, int *select, int n, const double *h, int ldh, double *wr, const double *wi, double *vl, int ldvl, double *vr, int ldvr, int mm, int *m, double *work, int *ifaill, int *ifailr)
     * }
     */
    public static FunctionDescriptor LAPACKE_dhsein_work$descriptor() {
        return LAPACKE_dhsein_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dhsein_work(int matrix_layout, char job, char eigsrc, char initv, int *select, int n, const double *h, int ldh, double *wr, const double *wi, double *vl, int ldvl, double *vr, int ldvr, int mm, int *m, double *work, int *ifaill, int *ifailr)
     * }
     */
    public static MethodHandle LAPACKE_dhsein_work$handle() {
        return LAPACKE_dhsein_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dhsein_work(int matrix_layout, char job, char eigsrc, char initv, int *select, int n, const double *h, int ldh, double *wr, const double *wi, double *vl, int ldvl, double *vr, int ldvr, int mm, int *m, double *work, int *ifaill, int *ifailr)
     * }
     */
    public static MemorySegment LAPACKE_dhsein_work$address() {
        return LAPACKE_dhsein_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dhsein_work(int matrix_layout, char job, char eigsrc, char initv, int *select, int n, const double *h, int ldh, double *wr, const double *wi, double *vl, int ldvl, double *vr, int ldvr, int mm, int *m, double *work, int *ifaill, int *ifailr)
     * }
     */
    public static int LAPACKE_dhsein_work(int matrix_layout, byte job, byte eigsrc, byte initv, MemorySegment select, int n, MemorySegment h, int ldh, MemorySegment wr, MemorySegment wi, MemorySegment vl, int ldvl, MemorySegment vr, int ldvr, int mm, MemorySegment m, MemorySegment work, MemorySegment ifaill, MemorySegment ifailr) {
        var mh$ = LAPACKE_dhsein_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dhsein_work", matrix_layout, job, eigsrc, initv, select, n, h, ldh, wr, wi, vl, ldvl, vr, ldvr, mm, m, work, ifaill, ifailr);
            }
            return (int)mh$.invokeExact(matrix_layout, job, eigsrc, initv, select, n, h, ldh, wr, wi, vl, ldvl, vr, ldvr, mm, m, work, ifaill, ifailr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_chsein_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_chsein_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_chsein_work(int matrix_layout, char job, char eigsrc, char initv, const int *select, int n, const _Complex float *h, int ldh, _Complex float *w, _Complex float *vl, int ldvl, _Complex float *vr, int ldvr, int mm, int *m, _Complex float *work, float *rwork, int *ifaill, int *ifailr)
     * }
     */
    public static FunctionDescriptor LAPACKE_chsein_work$descriptor() {
        return LAPACKE_chsein_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_chsein_work(int matrix_layout, char job, char eigsrc, char initv, const int *select, int n, const _Complex float *h, int ldh, _Complex float *w, _Complex float *vl, int ldvl, _Complex float *vr, int ldvr, int mm, int *m, _Complex float *work, float *rwork, int *ifaill, int *ifailr)
     * }
     */
    public static MethodHandle LAPACKE_chsein_work$handle() {
        return LAPACKE_chsein_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_chsein_work(int matrix_layout, char job, char eigsrc, char initv, const int *select, int n, const _Complex float *h, int ldh, _Complex float *w, _Complex float *vl, int ldvl, _Complex float *vr, int ldvr, int mm, int *m, _Complex float *work, float *rwork, int *ifaill, int *ifailr)
     * }
     */
    public static MemorySegment LAPACKE_chsein_work$address() {
        return LAPACKE_chsein_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_chsein_work(int matrix_layout, char job, char eigsrc, char initv, const int *select, int n, const _Complex float *h, int ldh, _Complex float *w, _Complex float *vl, int ldvl, _Complex float *vr, int ldvr, int mm, int *m, _Complex float *work, float *rwork, int *ifaill, int *ifailr)
     * }
     */
    public static int LAPACKE_chsein_work(int matrix_layout, byte job, byte eigsrc, byte initv, MemorySegment select, int n, MemorySegment h, int ldh, MemorySegment w, MemorySegment vl, int ldvl, MemorySegment vr, int ldvr, int mm, MemorySegment m, MemorySegment work, MemorySegment rwork, MemorySegment ifaill, MemorySegment ifailr) {
        var mh$ = LAPACKE_chsein_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_chsein_work", matrix_layout, job, eigsrc, initv, select, n, h, ldh, w, vl, ldvl, vr, ldvr, mm, m, work, rwork, ifaill, ifailr);
            }
            return (int)mh$.invokeExact(matrix_layout, job, eigsrc, initv, select, n, h, ldh, w, vl, ldvl, vr, ldvr, mm, m, work, rwork, ifaill, ifailr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zhsein_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zhsein_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zhsein_work(int matrix_layout, char job, char eigsrc, char initv, const int *select, int n, const _Complex double *h, int ldh, _Complex double *w, _Complex double *vl, int ldvl, _Complex double *vr, int ldvr, int mm, int *m, _Complex double *work, double *rwork, int *ifaill, int *ifailr)
     * }
     */
    public static FunctionDescriptor LAPACKE_zhsein_work$descriptor() {
        return LAPACKE_zhsein_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zhsein_work(int matrix_layout, char job, char eigsrc, char initv, const int *select, int n, const _Complex double *h, int ldh, _Complex double *w, _Complex double *vl, int ldvl, _Complex double *vr, int ldvr, int mm, int *m, _Complex double *work, double *rwork, int *ifaill, int *ifailr)
     * }
     */
    public static MethodHandle LAPACKE_zhsein_work$handle() {
        return LAPACKE_zhsein_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zhsein_work(int matrix_layout, char job, char eigsrc, char initv, const int *select, int n, const _Complex double *h, int ldh, _Complex double *w, _Complex double *vl, int ldvl, _Complex double *vr, int ldvr, int mm, int *m, _Complex double *work, double *rwork, int *ifaill, int *ifailr)
     * }
     */
    public static MemorySegment LAPACKE_zhsein_work$address() {
        return LAPACKE_zhsein_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zhsein_work(int matrix_layout, char job, char eigsrc, char initv, const int *select, int n, const _Complex double *h, int ldh, _Complex double *w, _Complex double *vl, int ldvl, _Complex double *vr, int ldvr, int mm, int *m, _Complex double *work, double *rwork, int *ifaill, int *ifailr)
     * }
     */
    public static int LAPACKE_zhsein_work(int matrix_layout, byte job, byte eigsrc, byte initv, MemorySegment select, int n, MemorySegment h, int ldh, MemorySegment w, MemorySegment vl, int ldvl, MemorySegment vr, int ldvr, int mm, MemorySegment m, MemorySegment work, MemorySegment rwork, MemorySegment ifaill, MemorySegment ifailr) {
        var mh$ = LAPACKE_zhsein_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zhsein_work", matrix_layout, job, eigsrc, initv, select, n, h, ldh, w, vl, ldvl, vr, ldvr, mm, m, work, rwork, ifaill, ifailr);
            }
            return (int)mh$.invokeExact(matrix_layout, job, eigsrc, initv, select, n, h, ldh, w, vl, ldvl, vr, ldvr, mm, m, work, rwork, ifaill, ifailr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_shseqr_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_shseqr_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_shseqr_work(int matrix_layout, char job, char compz, int n, int ilo, int ihi, float *h, int ldh, float *wr, float *wi, float *z, int ldz, float *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_shseqr_work$descriptor() {
        return LAPACKE_shseqr_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_shseqr_work(int matrix_layout, char job, char compz, int n, int ilo, int ihi, float *h, int ldh, float *wr, float *wi, float *z, int ldz, float *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_shseqr_work$handle() {
        return LAPACKE_shseqr_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_shseqr_work(int matrix_layout, char job, char compz, int n, int ilo, int ihi, float *h, int ldh, float *wr, float *wi, float *z, int ldz, float *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_shseqr_work$address() {
        return LAPACKE_shseqr_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_shseqr_work(int matrix_layout, char job, char compz, int n, int ilo, int ihi, float *h, int ldh, float *wr, float *wi, float *z, int ldz, float *work, int lwork)
     * }
     */
    public static int LAPACKE_shseqr_work(int matrix_layout, byte job, byte compz, int n, int ilo, int ihi, MemorySegment h, int ldh, MemorySegment wr, MemorySegment wi, MemorySegment z, int ldz, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_shseqr_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_shseqr_work", matrix_layout, job, compz, n, ilo, ihi, h, ldh, wr, wi, z, ldz, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, job, compz, n, ilo, ihi, h, ldh, wr, wi, z, ldz, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dhseqr_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dhseqr_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dhseqr_work(int matrix_layout, char job, char compz, int n, int ilo, int ihi, double *h, int ldh, double *wr, double *wi, double *z, int ldz, double *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_dhseqr_work$descriptor() {
        return LAPACKE_dhseqr_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dhseqr_work(int matrix_layout, char job, char compz, int n, int ilo, int ihi, double *h, int ldh, double *wr, double *wi, double *z, int ldz, double *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_dhseqr_work$handle() {
        return LAPACKE_dhseqr_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dhseqr_work(int matrix_layout, char job, char compz, int n, int ilo, int ihi, double *h, int ldh, double *wr, double *wi, double *z, int ldz, double *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_dhseqr_work$address() {
        return LAPACKE_dhseqr_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dhseqr_work(int matrix_layout, char job, char compz, int n, int ilo, int ihi, double *h, int ldh, double *wr, double *wi, double *z, int ldz, double *work, int lwork)
     * }
     */
    public static int LAPACKE_dhseqr_work(int matrix_layout, byte job, byte compz, int n, int ilo, int ihi, MemorySegment h, int ldh, MemorySegment wr, MemorySegment wi, MemorySegment z, int ldz, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_dhseqr_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dhseqr_work", matrix_layout, job, compz, n, ilo, ihi, h, ldh, wr, wi, z, ldz, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, job, compz, n, ilo, ihi, h, ldh, wr, wi, z, ldz, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_chseqr_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_chseqr_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_chseqr_work(int matrix_layout, char job, char compz, int n, int ilo, int ihi, _Complex float *h, int ldh, _Complex float *w, _Complex float *z, int ldz, _Complex float *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_chseqr_work$descriptor() {
        return LAPACKE_chseqr_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_chseqr_work(int matrix_layout, char job, char compz, int n, int ilo, int ihi, _Complex float *h, int ldh, _Complex float *w, _Complex float *z, int ldz, _Complex float *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_chseqr_work$handle() {
        return LAPACKE_chseqr_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_chseqr_work(int matrix_layout, char job, char compz, int n, int ilo, int ihi, _Complex float *h, int ldh, _Complex float *w, _Complex float *z, int ldz, _Complex float *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_chseqr_work$address() {
        return LAPACKE_chseqr_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_chseqr_work(int matrix_layout, char job, char compz, int n, int ilo, int ihi, _Complex float *h, int ldh, _Complex float *w, _Complex float *z, int ldz, _Complex float *work, int lwork)
     * }
     */
    public static int LAPACKE_chseqr_work(int matrix_layout, byte job, byte compz, int n, int ilo, int ihi, MemorySegment h, int ldh, MemorySegment w, MemorySegment z, int ldz, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_chseqr_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_chseqr_work", matrix_layout, job, compz, n, ilo, ihi, h, ldh, w, z, ldz, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, job, compz, n, ilo, ihi, h, ldh, w, z, ldz, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zhseqr_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zhseqr_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zhseqr_work(int matrix_layout, char job, char compz, int n, int ilo, int ihi, _Complex double *h, int ldh, _Complex double *w, _Complex double *z, int ldz, _Complex double *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_zhseqr_work$descriptor() {
        return LAPACKE_zhseqr_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zhseqr_work(int matrix_layout, char job, char compz, int n, int ilo, int ihi, _Complex double *h, int ldh, _Complex double *w, _Complex double *z, int ldz, _Complex double *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_zhseqr_work$handle() {
        return LAPACKE_zhseqr_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zhseqr_work(int matrix_layout, char job, char compz, int n, int ilo, int ihi, _Complex double *h, int ldh, _Complex double *w, _Complex double *z, int ldz, _Complex double *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_zhseqr_work$address() {
        return LAPACKE_zhseqr_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zhseqr_work(int matrix_layout, char job, char compz, int n, int ilo, int ihi, _Complex double *h, int ldh, _Complex double *w, _Complex double *z, int ldz, _Complex double *work, int lwork)
     * }
     */
    public static int LAPACKE_zhseqr_work(int matrix_layout, byte job, byte compz, int n, int ilo, int ihi, MemorySegment h, int ldh, MemorySegment w, MemorySegment z, int ldz, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_zhseqr_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zhseqr_work", matrix_layout, job, compz, n, ilo, ihi, h, ldh, w, z, ldz, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, job, compz, n, ilo, ihi, h, ldh, w, z, ldz, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_clacgv_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_clacgv_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_clacgv_work(int n, _Complex float *x, int incx)
     * }
     */
    public static FunctionDescriptor LAPACKE_clacgv_work$descriptor() {
        return LAPACKE_clacgv_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_clacgv_work(int n, _Complex float *x, int incx)
     * }
     */
    public static MethodHandle LAPACKE_clacgv_work$handle() {
        return LAPACKE_clacgv_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_clacgv_work(int n, _Complex float *x, int incx)
     * }
     */
    public static MemorySegment LAPACKE_clacgv_work$address() {
        return LAPACKE_clacgv_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_clacgv_work(int n, _Complex float *x, int incx)
     * }
     */
    public static int LAPACKE_clacgv_work(int n, MemorySegment x, int incx) {
        var mh$ = LAPACKE_clacgv_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_clacgv_work", n, x, incx);
            }
            return (int)mh$.invokeExact(n, x, incx);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zlacgv_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zlacgv_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zlacgv_work(int n, _Complex double *x, int incx)
     * }
     */
    public static FunctionDescriptor LAPACKE_zlacgv_work$descriptor() {
        return LAPACKE_zlacgv_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zlacgv_work(int n, _Complex double *x, int incx)
     * }
     */
    public static MethodHandle LAPACKE_zlacgv_work$handle() {
        return LAPACKE_zlacgv_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zlacgv_work(int n, _Complex double *x, int incx)
     * }
     */
    public static MemorySegment LAPACKE_zlacgv_work$address() {
        return LAPACKE_zlacgv_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zlacgv_work(int n, _Complex double *x, int incx)
     * }
     */
    public static int LAPACKE_zlacgv_work(int n, MemorySegment x, int incx) {
        var mh$ = LAPACKE_zlacgv_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zlacgv_work", n, x, incx);
            }
            return (int)mh$.invokeExact(n, x, incx);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_slacn2_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_slacn2_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_slacn2_work(int n, float *v, float *x, int *isgn, float *est, int *kase, int *isave)
     * }
     */
    public static FunctionDescriptor LAPACKE_slacn2_work$descriptor() {
        return LAPACKE_slacn2_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_slacn2_work(int n, float *v, float *x, int *isgn, float *est, int *kase, int *isave)
     * }
     */
    public static MethodHandle LAPACKE_slacn2_work$handle() {
        return LAPACKE_slacn2_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_slacn2_work(int n, float *v, float *x, int *isgn, float *est, int *kase, int *isave)
     * }
     */
    public static MemorySegment LAPACKE_slacn2_work$address() {
        return LAPACKE_slacn2_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_slacn2_work(int n, float *v, float *x, int *isgn, float *est, int *kase, int *isave)
     * }
     */
    public static int LAPACKE_slacn2_work(int n, MemorySegment v, MemorySegment x, MemorySegment isgn, MemorySegment est, MemorySegment kase, MemorySegment isave) {
        var mh$ = LAPACKE_slacn2_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_slacn2_work", n, v, x, isgn, est, kase, isave);
            }
            return (int)mh$.invokeExact(n, v, x, isgn, est, kase, isave);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dlacn2_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dlacn2_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dlacn2_work(int n, double *v, double *x, int *isgn, double *est, int *kase, int *isave)
     * }
     */
    public static FunctionDescriptor LAPACKE_dlacn2_work$descriptor() {
        return LAPACKE_dlacn2_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dlacn2_work(int n, double *v, double *x, int *isgn, double *est, int *kase, int *isave)
     * }
     */
    public static MethodHandle LAPACKE_dlacn2_work$handle() {
        return LAPACKE_dlacn2_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dlacn2_work(int n, double *v, double *x, int *isgn, double *est, int *kase, int *isave)
     * }
     */
    public static MemorySegment LAPACKE_dlacn2_work$address() {
        return LAPACKE_dlacn2_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dlacn2_work(int n, double *v, double *x, int *isgn, double *est, int *kase, int *isave)
     * }
     */
    public static int LAPACKE_dlacn2_work(int n, MemorySegment v, MemorySegment x, MemorySegment isgn, MemorySegment est, MemorySegment kase, MemorySegment isave) {
        var mh$ = LAPACKE_dlacn2_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dlacn2_work", n, v, x, isgn, est, kase, isave);
            }
            return (int)mh$.invokeExact(n, v, x, isgn, est, kase, isave);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_clacn2_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_clacn2_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_clacn2_work(int n, _Complex float *v, _Complex float *x, float *est, int *kase, int *isave)
     * }
     */
    public static FunctionDescriptor LAPACKE_clacn2_work$descriptor() {
        return LAPACKE_clacn2_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_clacn2_work(int n, _Complex float *v, _Complex float *x, float *est, int *kase, int *isave)
     * }
     */
    public static MethodHandle LAPACKE_clacn2_work$handle() {
        return LAPACKE_clacn2_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_clacn2_work(int n, _Complex float *v, _Complex float *x, float *est, int *kase, int *isave)
     * }
     */
    public static MemorySegment LAPACKE_clacn2_work$address() {
        return LAPACKE_clacn2_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_clacn2_work(int n, _Complex float *v, _Complex float *x, float *est, int *kase, int *isave)
     * }
     */
    public static int LAPACKE_clacn2_work(int n, MemorySegment v, MemorySegment x, MemorySegment est, MemorySegment kase, MemorySegment isave) {
        var mh$ = LAPACKE_clacn2_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_clacn2_work", n, v, x, est, kase, isave);
            }
            return (int)mh$.invokeExact(n, v, x, est, kase, isave);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zlacn2_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zlacn2_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zlacn2_work(int n, _Complex double *v, _Complex double *x, double *est, int *kase, int *isave)
     * }
     */
    public static FunctionDescriptor LAPACKE_zlacn2_work$descriptor() {
        return LAPACKE_zlacn2_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zlacn2_work(int n, _Complex double *v, _Complex double *x, double *est, int *kase, int *isave)
     * }
     */
    public static MethodHandle LAPACKE_zlacn2_work$handle() {
        return LAPACKE_zlacn2_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zlacn2_work(int n, _Complex double *v, _Complex double *x, double *est, int *kase, int *isave)
     * }
     */
    public static MemorySegment LAPACKE_zlacn2_work$address() {
        return LAPACKE_zlacn2_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zlacn2_work(int n, _Complex double *v, _Complex double *x, double *est, int *kase, int *isave)
     * }
     */
    public static int LAPACKE_zlacn2_work(int n, MemorySegment v, MemorySegment x, MemorySegment est, MemorySegment kase, MemorySegment isave) {
        var mh$ = LAPACKE_zlacn2_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zlacn2_work", n, v, x, est, kase, isave);
            }
            return (int)mh$.invokeExact(n, v, x, est, kase, isave);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_slacpy_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_slacpy_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_slacpy_work(int matrix_layout, char uplo, int m, int n, const float *a, int lda, float *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_slacpy_work$descriptor() {
        return LAPACKE_slacpy_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_slacpy_work(int matrix_layout, char uplo, int m, int n, const float *a, int lda, float *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_slacpy_work$handle() {
        return LAPACKE_slacpy_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_slacpy_work(int matrix_layout, char uplo, int m, int n, const float *a, int lda, float *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_slacpy_work$address() {
        return LAPACKE_slacpy_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_slacpy_work(int matrix_layout, char uplo, int m, int n, const float *a, int lda, float *b, int ldb)
     * }
     */
    public static int LAPACKE_slacpy_work(int matrix_layout, byte uplo, int m, int n, MemorySegment a, int lda, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_slacpy_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_slacpy_work", matrix_layout, uplo, m, n, a, lda, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, m, n, a, lda, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dlacpy_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dlacpy_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dlacpy_work(int matrix_layout, char uplo, int m, int n, const double *a, int lda, double *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_dlacpy_work$descriptor() {
        return LAPACKE_dlacpy_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dlacpy_work(int matrix_layout, char uplo, int m, int n, const double *a, int lda, double *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_dlacpy_work$handle() {
        return LAPACKE_dlacpy_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dlacpy_work(int matrix_layout, char uplo, int m, int n, const double *a, int lda, double *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_dlacpy_work$address() {
        return LAPACKE_dlacpy_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dlacpy_work(int matrix_layout, char uplo, int m, int n, const double *a, int lda, double *b, int ldb)
     * }
     */
    public static int LAPACKE_dlacpy_work(int matrix_layout, byte uplo, int m, int n, MemorySegment a, int lda, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_dlacpy_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dlacpy_work", matrix_layout, uplo, m, n, a, lda, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, m, n, a, lda, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_clacpy_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_clacpy_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_clacpy_work(int matrix_layout, char uplo, int m, int n, const _Complex float *a, int lda, _Complex float *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_clacpy_work$descriptor() {
        return LAPACKE_clacpy_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_clacpy_work(int matrix_layout, char uplo, int m, int n, const _Complex float *a, int lda, _Complex float *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_clacpy_work$handle() {
        return LAPACKE_clacpy_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_clacpy_work(int matrix_layout, char uplo, int m, int n, const _Complex float *a, int lda, _Complex float *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_clacpy_work$address() {
        return LAPACKE_clacpy_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_clacpy_work(int matrix_layout, char uplo, int m, int n, const _Complex float *a, int lda, _Complex float *b, int ldb)
     * }
     */
    public static int LAPACKE_clacpy_work(int matrix_layout, byte uplo, int m, int n, MemorySegment a, int lda, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_clacpy_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_clacpy_work", matrix_layout, uplo, m, n, a, lda, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, m, n, a, lda, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zlacpy_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zlacpy_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zlacpy_work(int matrix_layout, char uplo, int m, int n, const _Complex double *a, int lda, _Complex double *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_zlacpy_work$descriptor() {
        return LAPACKE_zlacpy_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zlacpy_work(int matrix_layout, char uplo, int m, int n, const _Complex double *a, int lda, _Complex double *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_zlacpy_work$handle() {
        return LAPACKE_zlacpy_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zlacpy_work(int matrix_layout, char uplo, int m, int n, const _Complex double *a, int lda, _Complex double *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_zlacpy_work$address() {
        return LAPACKE_zlacpy_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zlacpy_work(int matrix_layout, char uplo, int m, int n, const _Complex double *a, int lda, _Complex double *b, int ldb)
     * }
     */
    public static int LAPACKE_zlacpy_work(int matrix_layout, byte uplo, int m, int n, MemorySegment a, int lda, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_zlacpy_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zlacpy_work", matrix_layout, uplo, m, n, a, lda, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, m, n, a, lda, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_clacp2_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_clacp2_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_clacp2_work(int matrix_layout, char uplo, int m, int n, const float *a, int lda, _Complex float *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_clacp2_work$descriptor() {
        return LAPACKE_clacp2_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_clacp2_work(int matrix_layout, char uplo, int m, int n, const float *a, int lda, _Complex float *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_clacp2_work$handle() {
        return LAPACKE_clacp2_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_clacp2_work(int matrix_layout, char uplo, int m, int n, const float *a, int lda, _Complex float *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_clacp2_work$address() {
        return LAPACKE_clacp2_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_clacp2_work(int matrix_layout, char uplo, int m, int n, const float *a, int lda, _Complex float *b, int ldb)
     * }
     */
    public static int LAPACKE_clacp2_work(int matrix_layout, byte uplo, int m, int n, MemorySegment a, int lda, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_clacp2_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_clacp2_work", matrix_layout, uplo, m, n, a, lda, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, m, n, a, lda, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zlacp2_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zlacp2_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zlacp2_work(int matrix_layout, char uplo, int m, int n, const double *a, int lda, _Complex double *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_zlacp2_work$descriptor() {
        return LAPACKE_zlacp2_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zlacp2_work(int matrix_layout, char uplo, int m, int n, const double *a, int lda, _Complex double *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_zlacp2_work$handle() {
        return LAPACKE_zlacp2_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zlacp2_work(int matrix_layout, char uplo, int m, int n, const double *a, int lda, _Complex double *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_zlacp2_work$address() {
        return LAPACKE_zlacp2_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zlacp2_work(int matrix_layout, char uplo, int m, int n, const double *a, int lda, _Complex double *b, int ldb)
     * }
     */
    public static int LAPACKE_zlacp2_work(int matrix_layout, byte uplo, int m, int n, MemorySegment a, int lda, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_zlacp2_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zlacp2_work", matrix_layout, uplo, m, n, a, lda, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, m, n, a, lda, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zlag2c_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zlag2c_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zlag2c_work(int matrix_layout, int m, int n, const _Complex double *a, int lda, _Complex float *sa, int ldsa)
     * }
     */
    public static FunctionDescriptor LAPACKE_zlag2c_work$descriptor() {
        return LAPACKE_zlag2c_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zlag2c_work(int matrix_layout, int m, int n, const _Complex double *a, int lda, _Complex float *sa, int ldsa)
     * }
     */
    public static MethodHandle LAPACKE_zlag2c_work$handle() {
        return LAPACKE_zlag2c_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zlag2c_work(int matrix_layout, int m, int n, const _Complex double *a, int lda, _Complex float *sa, int ldsa)
     * }
     */
    public static MemorySegment LAPACKE_zlag2c_work$address() {
        return LAPACKE_zlag2c_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zlag2c_work(int matrix_layout, int m, int n, const _Complex double *a, int lda, _Complex float *sa, int ldsa)
     * }
     */
    public static int LAPACKE_zlag2c_work(int matrix_layout, int m, int n, MemorySegment a, int lda, MemorySegment sa, int ldsa) {
        var mh$ = LAPACKE_zlag2c_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zlag2c_work", matrix_layout, m, n, a, lda, sa, ldsa);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, a, lda, sa, ldsa);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_slag2d_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_slag2d_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_slag2d_work(int matrix_layout, int m, int n, const float *sa, int ldsa, double *a, int lda)
     * }
     */
    public static FunctionDescriptor LAPACKE_slag2d_work$descriptor() {
        return LAPACKE_slag2d_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_slag2d_work(int matrix_layout, int m, int n, const float *sa, int ldsa, double *a, int lda)
     * }
     */
    public static MethodHandle LAPACKE_slag2d_work$handle() {
        return LAPACKE_slag2d_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_slag2d_work(int matrix_layout, int m, int n, const float *sa, int ldsa, double *a, int lda)
     * }
     */
    public static MemorySegment LAPACKE_slag2d_work$address() {
        return LAPACKE_slag2d_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_slag2d_work(int matrix_layout, int m, int n, const float *sa, int ldsa, double *a, int lda)
     * }
     */
    public static int LAPACKE_slag2d_work(int matrix_layout, int m, int n, MemorySegment sa, int ldsa, MemorySegment a, int lda) {
        var mh$ = LAPACKE_slag2d_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_slag2d_work", matrix_layout, m, n, sa, ldsa, a, lda);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, sa, ldsa, a, lda);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dlag2s_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dlag2s_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dlag2s_work(int matrix_layout, int m, int n, const double *a, int lda, float *sa, int ldsa)
     * }
     */
    public static FunctionDescriptor LAPACKE_dlag2s_work$descriptor() {
        return LAPACKE_dlag2s_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dlag2s_work(int matrix_layout, int m, int n, const double *a, int lda, float *sa, int ldsa)
     * }
     */
    public static MethodHandle LAPACKE_dlag2s_work$handle() {
        return LAPACKE_dlag2s_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dlag2s_work(int matrix_layout, int m, int n, const double *a, int lda, float *sa, int ldsa)
     * }
     */
    public static MemorySegment LAPACKE_dlag2s_work$address() {
        return LAPACKE_dlag2s_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dlag2s_work(int matrix_layout, int m, int n, const double *a, int lda, float *sa, int ldsa)
     * }
     */
    public static int LAPACKE_dlag2s_work(int matrix_layout, int m, int n, MemorySegment a, int lda, MemorySegment sa, int ldsa) {
        var mh$ = LAPACKE_dlag2s_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dlag2s_work", matrix_layout, m, n, a, lda, sa, ldsa);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, a, lda, sa, ldsa);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_clag2z_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_clag2z_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_clag2z_work(int matrix_layout, int m, int n, const _Complex float *sa, int ldsa, _Complex double *a, int lda)
     * }
     */
    public static FunctionDescriptor LAPACKE_clag2z_work$descriptor() {
        return LAPACKE_clag2z_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_clag2z_work(int matrix_layout, int m, int n, const _Complex float *sa, int ldsa, _Complex double *a, int lda)
     * }
     */
    public static MethodHandle LAPACKE_clag2z_work$handle() {
        return LAPACKE_clag2z_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_clag2z_work(int matrix_layout, int m, int n, const _Complex float *sa, int ldsa, _Complex double *a, int lda)
     * }
     */
    public static MemorySegment LAPACKE_clag2z_work$address() {
        return LAPACKE_clag2z_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_clag2z_work(int matrix_layout, int m, int n, const _Complex float *sa, int ldsa, _Complex double *a, int lda)
     * }
     */
    public static int LAPACKE_clag2z_work(int matrix_layout, int m, int n, MemorySegment sa, int ldsa, MemorySegment a, int lda) {
        var mh$ = LAPACKE_clag2z_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_clag2z_work", matrix_layout, m, n, sa, ldsa, a, lda);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, sa, ldsa, a, lda);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_slagge_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_slagge_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_slagge_work(int matrix_layout, int m, int n, int kl, int ku, const float *d, float *a, int lda, int *iseed, float *work)
     * }
     */
    public static FunctionDescriptor LAPACKE_slagge_work$descriptor() {
        return LAPACKE_slagge_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_slagge_work(int matrix_layout, int m, int n, int kl, int ku, const float *d, float *a, int lda, int *iseed, float *work)
     * }
     */
    public static MethodHandle LAPACKE_slagge_work$handle() {
        return LAPACKE_slagge_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_slagge_work(int matrix_layout, int m, int n, int kl, int ku, const float *d, float *a, int lda, int *iseed, float *work)
     * }
     */
    public static MemorySegment LAPACKE_slagge_work$address() {
        return LAPACKE_slagge_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_slagge_work(int matrix_layout, int m, int n, int kl, int ku, const float *d, float *a, int lda, int *iseed, float *work)
     * }
     */
    public static int LAPACKE_slagge_work(int matrix_layout, int m, int n, int kl, int ku, MemorySegment d, MemorySegment a, int lda, MemorySegment iseed, MemorySegment work) {
        var mh$ = LAPACKE_slagge_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_slagge_work", matrix_layout, m, n, kl, ku, d, a, lda, iseed, work);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, kl, ku, d, a, lda, iseed, work);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dlagge_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dlagge_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dlagge_work(int matrix_layout, int m, int n, int kl, int ku, const double *d, double *a, int lda, int *iseed, double *work)
     * }
     */
    public static FunctionDescriptor LAPACKE_dlagge_work$descriptor() {
        return LAPACKE_dlagge_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dlagge_work(int matrix_layout, int m, int n, int kl, int ku, const double *d, double *a, int lda, int *iseed, double *work)
     * }
     */
    public static MethodHandle LAPACKE_dlagge_work$handle() {
        return LAPACKE_dlagge_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dlagge_work(int matrix_layout, int m, int n, int kl, int ku, const double *d, double *a, int lda, int *iseed, double *work)
     * }
     */
    public static MemorySegment LAPACKE_dlagge_work$address() {
        return LAPACKE_dlagge_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dlagge_work(int matrix_layout, int m, int n, int kl, int ku, const double *d, double *a, int lda, int *iseed, double *work)
     * }
     */
    public static int LAPACKE_dlagge_work(int matrix_layout, int m, int n, int kl, int ku, MemorySegment d, MemorySegment a, int lda, MemorySegment iseed, MemorySegment work) {
        var mh$ = LAPACKE_dlagge_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dlagge_work", matrix_layout, m, n, kl, ku, d, a, lda, iseed, work);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, kl, ku, d, a, lda, iseed, work);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_clagge_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_clagge_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_clagge_work(int matrix_layout, int m, int n, int kl, int ku, const float *d, _Complex float *a, int lda, int *iseed, _Complex float *work)
     * }
     */
    public static FunctionDescriptor LAPACKE_clagge_work$descriptor() {
        return LAPACKE_clagge_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_clagge_work(int matrix_layout, int m, int n, int kl, int ku, const float *d, _Complex float *a, int lda, int *iseed, _Complex float *work)
     * }
     */
    public static MethodHandle LAPACKE_clagge_work$handle() {
        return LAPACKE_clagge_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_clagge_work(int matrix_layout, int m, int n, int kl, int ku, const float *d, _Complex float *a, int lda, int *iseed, _Complex float *work)
     * }
     */
    public static MemorySegment LAPACKE_clagge_work$address() {
        return LAPACKE_clagge_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_clagge_work(int matrix_layout, int m, int n, int kl, int ku, const float *d, _Complex float *a, int lda, int *iseed, _Complex float *work)
     * }
     */
    public static int LAPACKE_clagge_work(int matrix_layout, int m, int n, int kl, int ku, MemorySegment d, MemorySegment a, int lda, MemorySegment iseed, MemorySegment work) {
        var mh$ = LAPACKE_clagge_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_clagge_work", matrix_layout, m, n, kl, ku, d, a, lda, iseed, work);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, kl, ku, d, a, lda, iseed, work);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zlagge_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zlagge_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zlagge_work(int matrix_layout, int m, int n, int kl, int ku, const double *d, _Complex double *a, int lda, int *iseed, _Complex double *work)
     * }
     */
    public static FunctionDescriptor LAPACKE_zlagge_work$descriptor() {
        return LAPACKE_zlagge_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zlagge_work(int matrix_layout, int m, int n, int kl, int ku, const double *d, _Complex double *a, int lda, int *iseed, _Complex double *work)
     * }
     */
    public static MethodHandle LAPACKE_zlagge_work$handle() {
        return LAPACKE_zlagge_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zlagge_work(int matrix_layout, int m, int n, int kl, int ku, const double *d, _Complex double *a, int lda, int *iseed, _Complex double *work)
     * }
     */
    public static MemorySegment LAPACKE_zlagge_work$address() {
        return LAPACKE_zlagge_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zlagge_work(int matrix_layout, int m, int n, int kl, int ku, const double *d, _Complex double *a, int lda, int *iseed, _Complex double *work)
     * }
     */
    public static int LAPACKE_zlagge_work(int matrix_layout, int m, int n, int kl, int ku, MemorySegment d, MemorySegment a, int lda, MemorySegment iseed, MemorySegment work) {
        var mh$ = LAPACKE_zlagge_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zlagge_work", matrix_layout, m, n, kl, ku, d, a, lda, iseed, work);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, kl, ku, d, a, lda, iseed, work);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_claghe_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_claghe_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_claghe_work(int matrix_layout, int n, int k, const float *d, _Complex float *a, int lda, int *iseed, _Complex float *work)
     * }
     */
    public static FunctionDescriptor LAPACKE_claghe_work$descriptor() {
        return LAPACKE_claghe_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_claghe_work(int matrix_layout, int n, int k, const float *d, _Complex float *a, int lda, int *iseed, _Complex float *work)
     * }
     */
    public static MethodHandle LAPACKE_claghe_work$handle() {
        return LAPACKE_claghe_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_claghe_work(int matrix_layout, int n, int k, const float *d, _Complex float *a, int lda, int *iseed, _Complex float *work)
     * }
     */
    public static MemorySegment LAPACKE_claghe_work$address() {
        return LAPACKE_claghe_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_claghe_work(int matrix_layout, int n, int k, const float *d, _Complex float *a, int lda, int *iseed, _Complex float *work)
     * }
     */
    public static int LAPACKE_claghe_work(int matrix_layout, int n, int k, MemorySegment d, MemorySegment a, int lda, MemorySegment iseed, MemorySegment work) {
        var mh$ = LAPACKE_claghe_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_claghe_work", matrix_layout, n, k, d, a, lda, iseed, work);
            }
            return (int)mh$.invokeExact(matrix_layout, n, k, d, a, lda, iseed, work);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zlaghe_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zlaghe_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zlaghe_work(int matrix_layout, int n, int k, const double *d, _Complex double *a, int lda, int *iseed, _Complex double *work)
     * }
     */
    public static FunctionDescriptor LAPACKE_zlaghe_work$descriptor() {
        return LAPACKE_zlaghe_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zlaghe_work(int matrix_layout, int n, int k, const double *d, _Complex double *a, int lda, int *iseed, _Complex double *work)
     * }
     */
    public static MethodHandle LAPACKE_zlaghe_work$handle() {
        return LAPACKE_zlaghe_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zlaghe_work(int matrix_layout, int n, int k, const double *d, _Complex double *a, int lda, int *iseed, _Complex double *work)
     * }
     */
    public static MemorySegment LAPACKE_zlaghe_work$address() {
        return LAPACKE_zlaghe_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zlaghe_work(int matrix_layout, int n, int k, const double *d, _Complex double *a, int lda, int *iseed, _Complex double *work)
     * }
     */
    public static int LAPACKE_zlaghe_work(int matrix_layout, int n, int k, MemorySegment d, MemorySegment a, int lda, MemorySegment iseed, MemorySegment work) {
        var mh$ = LAPACKE_zlaghe_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zlaghe_work", matrix_layout, n, k, d, a, lda, iseed, work);
            }
            return (int)mh$.invokeExact(matrix_layout, n, k, d, a, lda, iseed, work);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_slagsy_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_slagsy_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_slagsy_work(int matrix_layout, int n, int k, const float *d, float *a, int lda, int *iseed, float *work)
     * }
     */
    public static FunctionDescriptor LAPACKE_slagsy_work$descriptor() {
        return LAPACKE_slagsy_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_slagsy_work(int matrix_layout, int n, int k, const float *d, float *a, int lda, int *iseed, float *work)
     * }
     */
    public static MethodHandle LAPACKE_slagsy_work$handle() {
        return LAPACKE_slagsy_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_slagsy_work(int matrix_layout, int n, int k, const float *d, float *a, int lda, int *iseed, float *work)
     * }
     */
    public static MemorySegment LAPACKE_slagsy_work$address() {
        return LAPACKE_slagsy_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_slagsy_work(int matrix_layout, int n, int k, const float *d, float *a, int lda, int *iseed, float *work)
     * }
     */
    public static int LAPACKE_slagsy_work(int matrix_layout, int n, int k, MemorySegment d, MemorySegment a, int lda, MemorySegment iseed, MemorySegment work) {
        var mh$ = LAPACKE_slagsy_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_slagsy_work", matrix_layout, n, k, d, a, lda, iseed, work);
            }
            return (int)mh$.invokeExact(matrix_layout, n, k, d, a, lda, iseed, work);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dlagsy_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dlagsy_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dlagsy_work(int matrix_layout, int n, int k, const double *d, double *a, int lda, int *iseed, double *work)
     * }
     */
    public static FunctionDescriptor LAPACKE_dlagsy_work$descriptor() {
        return LAPACKE_dlagsy_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dlagsy_work(int matrix_layout, int n, int k, const double *d, double *a, int lda, int *iseed, double *work)
     * }
     */
    public static MethodHandle LAPACKE_dlagsy_work$handle() {
        return LAPACKE_dlagsy_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dlagsy_work(int matrix_layout, int n, int k, const double *d, double *a, int lda, int *iseed, double *work)
     * }
     */
    public static MemorySegment LAPACKE_dlagsy_work$address() {
        return LAPACKE_dlagsy_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dlagsy_work(int matrix_layout, int n, int k, const double *d, double *a, int lda, int *iseed, double *work)
     * }
     */
    public static int LAPACKE_dlagsy_work(int matrix_layout, int n, int k, MemorySegment d, MemorySegment a, int lda, MemorySegment iseed, MemorySegment work) {
        var mh$ = LAPACKE_dlagsy_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dlagsy_work", matrix_layout, n, k, d, a, lda, iseed, work);
            }
            return (int)mh$.invokeExact(matrix_layout, n, k, d, a, lda, iseed, work);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_clagsy_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_clagsy_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_clagsy_work(int matrix_layout, int n, int k, const float *d, _Complex float *a, int lda, int *iseed, _Complex float *work)
     * }
     */
    public static FunctionDescriptor LAPACKE_clagsy_work$descriptor() {
        return LAPACKE_clagsy_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_clagsy_work(int matrix_layout, int n, int k, const float *d, _Complex float *a, int lda, int *iseed, _Complex float *work)
     * }
     */
    public static MethodHandle LAPACKE_clagsy_work$handle() {
        return LAPACKE_clagsy_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_clagsy_work(int matrix_layout, int n, int k, const float *d, _Complex float *a, int lda, int *iseed, _Complex float *work)
     * }
     */
    public static MemorySegment LAPACKE_clagsy_work$address() {
        return LAPACKE_clagsy_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_clagsy_work(int matrix_layout, int n, int k, const float *d, _Complex float *a, int lda, int *iseed, _Complex float *work)
     * }
     */
    public static int LAPACKE_clagsy_work(int matrix_layout, int n, int k, MemorySegment d, MemorySegment a, int lda, MemorySegment iseed, MemorySegment work) {
        var mh$ = LAPACKE_clagsy_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_clagsy_work", matrix_layout, n, k, d, a, lda, iseed, work);
            }
            return (int)mh$.invokeExact(matrix_layout, n, k, d, a, lda, iseed, work);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zlagsy_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zlagsy_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zlagsy_work(int matrix_layout, int n, int k, const double *d, _Complex double *a, int lda, int *iseed, _Complex double *work)
     * }
     */
    public static FunctionDescriptor LAPACKE_zlagsy_work$descriptor() {
        return LAPACKE_zlagsy_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zlagsy_work(int matrix_layout, int n, int k, const double *d, _Complex double *a, int lda, int *iseed, _Complex double *work)
     * }
     */
    public static MethodHandle LAPACKE_zlagsy_work$handle() {
        return LAPACKE_zlagsy_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zlagsy_work(int matrix_layout, int n, int k, const double *d, _Complex double *a, int lda, int *iseed, _Complex double *work)
     * }
     */
    public static MemorySegment LAPACKE_zlagsy_work$address() {
        return LAPACKE_zlagsy_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zlagsy_work(int matrix_layout, int n, int k, const double *d, _Complex double *a, int lda, int *iseed, _Complex double *work)
     * }
     */
    public static int LAPACKE_zlagsy_work(int matrix_layout, int n, int k, MemorySegment d, MemorySegment a, int lda, MemorySegment iseed, MemorySegment work) {
        var mh$ = LAPACKE_zlagsy_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zlagsy_work", matrix_layout, n, k, d, a, lda, iseed, work);
            }
            return (int)mh$.invokeExact(matrix_layout, n, k, d, a, lda, iseed, work);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_slapmr_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_slapmr_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_slapmr_work(int matrix_layout, int forwrd, int m, int n, float *x, int ldx, int *k)
     * }
     */
    public static FunctionDescriptor LAPACKE_slapmr_work$descriptor() {
        return LAPACKE_slapmr_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_slapmr_work(int matrix_layout, int forwrd, int m, int n, float *x, int ldx, int *k)
     * }
     */
    public static MethodHandle LAPACKE_slapmr_work$handle() {
        return LAPACKE_slapmr_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_slapmr_work(int matrix_layout, int forwrd, int m, int n, float *x, int ldx, int *k)
     * }
     */
    public static MemorySegment LAPACKE_slapmr_work$address() {
        return LAPACKE_slapmr_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_slapmr_work(int matrix_layout, int forwrd, int m, int n, float *x, int ldx, int *k)
     * }
     */
    public static int LAPACKE_slapmr_work(int matrix_layout, int forwrd, int m, int n, MemorySegment x, int ldx, MemorySegment k) {
        var mh$ = LAPACKE_slapmr_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_slapmr_work", matrix_layout, forwrd, m, n, x, ldx, k);
            }
            return (int)mh$.invokeExact(matrix_layout, forwrd, m, n, x, ldx, k);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dlapmr_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dlapmr_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dlapmr_work(int matrix_layout, int forwrd, int m, int n, double *x, int ldx, int *k)
     * }
     */
    public static FunctionDescriptor LAPACKE_dlapmr_work$descriptor() {
        return LAPACKE_dlapmr_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dlapmr_work(int matrix_layout, int forwrd, int m, int n, double *x, int ldx, int *k)
     * }
     */
    public static MethodHandle LAPACKE_dlapmr_work$handle() {
        return LAPACKE_dlapmr_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dlapmr_work(int matrix_layout, int forwrd, int m, int n, double *x, int ldx, int *k)
     * }
     */
    public static MemorySegment LAPACKE_dlapmr_work$address() {
        return LAPACKE_dlapmr_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dlapmr_work(int matrix_layout, int forwrd, int m, int n, double *x, int ldx, int *k)
     * }
     */
    public static int LAPACKE_dlapmr_work(int matrix_layout, int forwrd, int m, int n, MemorySegment x, int ldx, MemorySegment k) {
        var mh$ = LAPACKE_dlapmr_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dlapmr_work", matrix_layout, forwrd, m, n, x, ldx, k);
            }
            return (int)mh$.invokeExact(matrix_layout, forwrd, m, n, x, ldx, k);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_clapmr_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_clapmr_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_clapmr_work(int matrix_layout, int forwrd, int m, int n, _Complex float *x, int ldx, int *k)
     * }
     */
    public static FunctionDescriptor LAPACKE_clapmr_work$descriptor() {
        return LAPACKE_clapmr_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_clapmr_work(int matrix_layout, int forwrd, int m, int n, _Complex float *x, int ldx, int *k)
     * }
     */
    public static MethodHandle LAPACKE_clapmr_work$handle() {
        return LAPACKE_clapmr_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_clapmr_work(int matrix_layout, int forwrd, int m, int n, _Complex float *x, int ldx, int *k)
     * }
     */
    public static MemorySegment LAPACKE_clapmr_work$address() {
        return LAPACKE_clapmr_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_clapmr_work(int matrix_layout, int forwrd, int m, int n, _Complex float *x, int ldx, int *k)
     * }
     */
    public static int LAPACKE_clapmr_work(int matrix_layout, int forwrd, int m, int n, MemorySegment x, int ldx, MemorySegment k) {
        var mh$ = LAPACKE_clapmr_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_clapmr_work", matrix_layout, forwrd, m, n, x, ldx, k);
            }
            return (int)mh$.invokeExact(matrix_layout, forwrd, m, n, x, ldx, k);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zlapmr_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zlapmr_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zlapmr_work(int matrix_layout, int forwrd, int m, int n, _Complex double *x, int ldx, int *k)
     * }
     */
    public static FunctionDescriptor LAPACKE_zlapmr_work$descriptor() {
        return LAPACKE_zlapmr_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zlapmr_work(int matrix_layout, int forwrd, int m, int n, _Complex double *x, int ldx, int *k)
     * }
     */
    public static MethodHandle LAPACKE_zlapmr_work$handle() {
        return LAPACKE_zlapmr_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zlapmr_work(int matrix_layout, int forwrd, int m, int n, _Complex double *x, int ldx, int *k)
     * }
     */
    public static MemorySegment LAPACKE_zlapmr_work$address() {
        return LAPACKE_zlapmr_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zlapmr_work(int matrix_layout, int forwrd, int m, int n, _Complex double *x, int ldx, int *k)
     * }
     */
    public static int LAPACKE_zlapmr_work(int matrix_layout, int forwrd, int m, int n, MemorySegment x, int ldx, MemorySegment k) {
        var mh$ = LAPACKE_zlapmr_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zlapmr_work", matrix_layout, forwrd, m, n, x, ldx, k);
            }
            return (int)mh$.invokeExact(matrix_layout, forwrd, m, n, x, ldx, k);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_slapmt_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_slapmt_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_slapmt_work(int matrix_layout, int forwrd, int m, int n, float *x, int ldx, int *k)
     * }
     */
    public static FunctionDescriptor LAPACKE_slapmt_work$descriptor() {
        return LAPACKE_slapmt_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_slapmt_work(int matrix_layout, int forwrd, int m, int n, float *x, int ldx, int *k)
     * }
     */
    public static MethodHandle LAPACKE_slapmt_work$handle() {
        return LAPACKE_slapmt_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_slapmt_work(int matrix_layout, int forwrd, int m, int n, float *x, int ldx, int *k)
     * }
     */
    public static MemorySegment LAPACKE_slapmt_work$address() {
        return LAPACKE_slapmt_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_slapmt_work(int matrix_layout, int forwrd, int m, int n, float *x, int ldx, int *k)
     * }
     */
    public static int LAPACKE_slapmt_work(int matrix_layout, int forwrd, int m, int n, MemorySegment x, int ldx, MemorySegment k) {
        var mh$ = LAPACKE_slapmt_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_slapmt_work", matrix_layout, forwrd, m, n, x, ldx, k);
            }
            return (int)mh$.invokeExact(matrix_layout, forwrd, m, n, x, ldx, k);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dlapmt_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dlapmt_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dlapmt_work(int matrix_layout, int forwrd, int m, int n, double *x, int ldx, int *k)
     * }
     */
    public static FunctionDescriptor LAPACKE_dlapmt_work$descriptor() {
        return LAPACKE_dlapmt_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dlapmt_work(int matrix_layout, int forwrd, int m, int n, double *x, int ldx, int *k)
     * }
     */
    public static MethodHandle LAPACKE_dlapmt_work$handle() {
        return LAPACKE_dlapmt_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dlapmt_work(int matrix_layout, int forwrd, int m, int n, double *x, int ldx, int *k)
     * }
     */
    public static MemorySegment LAPACKE_dlapmt_work$address() {
        return LAPACKE_dlapmt_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dlapmt_work(int matrix_layout, int forwrd, int m, int n, double *x, int ldx, int *k)
     * }
     */
    public static int LAPACKE_dlapmt_work(int matrix_layout, int forwrd, int m, int n, MemorySegment x, int ldx, MemorySegment k) {
        var mh$ = LAPACKE_dlapmt_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dlapmt_work", matrix_layout, forwrd, m, n, x, ldx, k);
            }
            return (int)mh$.invokeExact(matrix_layout, forwrd, m, n, x, ldx, k);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_clapmt_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_clapmt_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_clapmt_work(int matrix_layout, int forwrd, int m, int n, _Complex float *x, int ldx, int *k)
     * }
     */
    public static FunctionDescriptor LAPACKE_clapmt_work$descriptor() {
        return LAPACKE_clapmt_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_clapmt_work(int matrix_layout, int forwrd, int m, int n, _Complex float *x, int ldx, int *k)
     * }
     */
    public static MethodHandle LAPACKE_clapmt_work$handle() {
        return LAPACKE_clapmt_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_clapmt_work(int matrix_layout, int forwrd, int m, int n, _Complex float *x, int ldx, int *k)
     * }
     */
    public static MemorySegment LAPACKE_clapmt_work$address() {
        return LAPACKE_clapmt_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_clapmt_work(int matrix_layout, int forwrd, int m, int n, _Complex float *x, int ldx, int *k)
     * }
     */
    public static int LAPACKE_clapmt_work(int matrix_layout, int forwrd, int m, int n, MemorySegment x, int ldx, MemorySegment k) {
        var mh$ = LAPACKE_clapmt_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_clapmt_work", matrix_layout, forwrd, m, n, x, ldx, k);
            }
            return (int)mh$.invokeExact(matrix_layout, forwrd, m, n, x, ldx, k);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zlapmt_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zlapmt_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zlapmt_work(int matrix_layout, int forwrd, int m, int n, _Complex double *x, int ldx, int *k)
     * }
     */
    public static FunctionDescriptor LAPACKE_zlapmt_work$descriptor() {
        return LAPACKE_zlapmt_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zlapmt_work(int matrix_layout, int forwrd, int m, int n, _Complex double *x, int ldx, int *k)
     * }
     */
    public static MethodHandle LAPACKE_zlapmt_work$handle() {
        return LAPACKE_zlapmt_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zlapmt_work(int matrix_layout, int forwrd, int m, int n, _Complex double *x, int ldx, int *k)
     * }
     */
    public static MemorySegment LAPACKE_zlapmt_work$address() {
        return LAPACKE_zlapmt_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zlapmt_work(int matrix_layout, int forwrd, int m, int n, _Complex double *x, int ldx, int *k)
     * }
     */
    public static int LAPACKE_zlapmt_work(int matrix_layout, int forwrd, int m, int n, MemorySegment x, int ldx, MemorySegment k) {
        var mh$ = LAPACKE_zlapmt_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zlapmt_work", matrix_layout, forwrd, m, n, x, ldx, k);
            }
            return (int)mh$.invokeExact(matrix_layout, forwrd, m, n, x, ldx, k);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_slartgp_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_FLOAT,
            lapacke_h.C_FLOAT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_slartgp_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_slartgp_work(float f, float g, float *cs, float *sn, float *r)
     * }
     */
    public static FunctionDescriptor LAPACKE_slartgp_work$descriptor() {
        return LAPACKE_slartgp_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_slartgp_work(float f, float g, float *cs, float *sn, float *r)
     * }
     */
    public static MethodHandle LAPACKE_slartgp_work$handle() {
        return LAPACKE_slartgp_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_slartgp_work(float f, float g, float *cs, float *sn, float *r)
     * }
     */
    public static MemorySegment LAPACKE_slartgp_work$address() {
        return LAPACKE_slartgp_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_slartgp_work(float f, float g, float *cs, float *sn, float *r)
     * }
     */
    public static int LAPACKE_slartgp_work(float f, float g, MemorySegment cs, MemorySegment sn, MemorySegment r) {
        var mh$ = LAPACKE_slartgp_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_slartgp_work", f, g, cs, sn, r);
            }
            return (int)mh$.invokeExact(f, g, cs, sn, r);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dlartgp_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_DOUBLE,
            lapacke_h.C_DOUBLE,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dlartgp_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dlartgp_work(double f, double g, double *cs, double *sn, double *r)
     * }
     */
    public static FunctionDescriptor LAPACKE_dlartgp_work$descriptor() {
        return LAPACKE_dlartgp_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dlartgp_work(double f, double g, double *cs, double *sn, double *r)
     * }
     */
    public static MethodHandle LAPACKE_dlartgp_work$handle() {
        return LAPACKE_dlartgp_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dlartgp_work(double f, double g, double *cs, double *sn, double *r)
     * }
     */
    public static MemorySegment LAPACKE_dlartgp_work$address() {
        return LAPACKE_dlartgp_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dlartgp_work(double f, double g, double *cs, double *sn, double *r)
     * }
     */
    public static int LAPACKE_dlartgp_work(double f, double g, MemorySegment cs, MemorySegment sn, MemorySegment r) {
        var mh$ = LAPACKE_dlartgp_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dlartgp_work", f, g, cs, sn, r);
            }
            return (int)mh$.invokeExact(f, g, cs, sn, r);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_slartgs_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_FLOAT,
            lapacke_h.C_FLOAT,
            lapacke_h.C_FLOAT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_slartgs_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_slartgs_work(float x, float y, float sigma, float *cs, float *sn)
     * }
     */
    public static FunctionDescriptor LAPACKE_slartgs_work$descriptor() {
        return LAPACKE_slartgs_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_slartgs_work(float x, float y, float sigma, float *cs, float *sn)
     * }
     */
    public static MethodHandle LAPACKE_slartgs_work$handle() {
        return LAPACKE_slartgs_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_slartgs_work(float x, float y, float sigma, float *cs, float *sn)
     * }
     */
    public static MemorySegment LAPACKE_slartgs_work$address() {
        return LAPACKE_slartgs_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_slartgs_work(float x, float y, float sigma, float *cs, float *sn)
     * }
     */
    public static int LAPACKE_slartgs_work(float x, float y, float sigma, MemorySegment cs, MemorySegment sn) {
        var mh$ = LAPACKE_slartgs_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_slartgs_work", x, y, sigma, cs, sn);
            }
            return (int)mh$.invokeExact(x, y, sigma, cs, sn);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dlartgs_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_DOUBLE,
            lapacke_h.C_DOUBLE,
            lapacke_h.C_DOUBLE,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dlartgs_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dlartgs_work(double x, double y, double sigma, double *cs, double *sn)
     * }
     */
    public static FunctionDescriptor LAPACKE_dlartgs_work$descriptor() {
        return LAPACKE_dlartgs_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dlartgs_work(double x, double y, double sigma, double *cs, double *sn)
     * }
     */
    public static MethodHandle LAPACKE_dlartgs_work$handle() {
        return LAPACKE_dlartgs_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dlartgs_work(double x, double y, double sigma, double *cs, double *sn)
     * }
     */
    public static MemorySegment LAPACKE_dlartgs_work$address() {
        return LAPACKE_dlartgs_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dlartgs_work(double x, double y, double sigma, double *cs, double *sn)
     * }
     */
    public static int LAPACKE_dlartgs_work(double x, double y, double sigma, MemorySegment cs, MemorySegment sn) {
        var mh$ = LAPACKE_dlartgs_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dlartgs_work", x, y, sigma, cs, sn);
            }
            return (int)mh$.invokeExact(x, y, sigma, cs, sn);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_slapy2_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_FLOAT,
            lapacke_h.C_FLOAT,
            lapacke_h.C_FLOAT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_slapy2_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float LAPACKE_slapy2_work(float x, float y)
     * }
     */
    public static FunctionDescriptor LAPACKE_slapy2_work$descriptor() {
        return LAPACKE_slapy2_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float LAPACKE_slapy2_work(float x, float y)
     * }
     */
    public static MethodHandle LAPACKE_slapy2_work$handle() {
        return LAPACKE_slapy2_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float LAPACKE_slapy2_work(float x, float y)
     * }
     */
    public static MemorySegment LAPACKE_slapy2_work$address() {
        return LAPACKE_slapy2_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float LAPACKE_slapy2_work(float x, float y)
     * }
     */
    public static float LAPACKE_slapy2_work(float x, float y) {
        var mh$ = LAPACKE_slapy2_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_slapy2_work", x, y);
            }
            return (float)mh$.invokeExact(x, y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dlapy2_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_DOUBLE,
            lapacke_h.C_DOUBLE,
            lapacke_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dlapy2_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double LAPACKE_dlapy2_work(double x, double y)
     * }
     */
    public static FunctionDescriptor LAPACKE_dlapy2_work$descriptor() {
        return LAPACKE_dlapy2_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double LAPACKE_dlapy2_work(double x, double y)
     * }
     */
    public static MethodHandle LAPACKE_dlapy2_work$handle() {
        return LAPACKE_dlapy2_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double LAPACKE_dlapy2_work(double x, double y)
     * }
     */
    public static MemorySegment LAPACKE_dlapy2_work$address() {
        return LAPACKE_dlapy2_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double LAPACKE_dlapy2_work(double x, double y)
     * }
     */
    public static double LAPACKE_dlapy2_work(double x, double y) {
        var mh$ = LAPACKE_dlapy2_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dlapy2_work", x, y);
            }
            return (double)mh$.invokeExact(x, y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_slapy3_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_FLOAT,
            lapacke_h.C_FLOAT,
            lapacke_h.C_FLOAT,
            lapacke_h.C_FLOAT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_slapy3_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float LAPACKE_slapy3_work(float x, float y, float z)
     * }
     */
    public static FunctionDescriptor LAPACKE_slapy3_work$descriptor() {
        return LAPACKE_slapy3_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float LAPACKE_slapy3_work(float x, float y, float z)
     * }
     */
    public static MethodHandle LAPACKE_slapy3_work$handle() {
        return LAPACKE_slapy3_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float LAPACKE_slapy3_work(float x, float y, float z)
     * }
     */
    public static MemorySegment LAPACKE_slapy3_work$address() {
        return LAPACKE_slapy3_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float LAPACKE_slapy3_work(float x, float y, float z)
     * }
     */
    public static float LAPACKE_slapy3_work(float x, float y, float z) {
        var mh$ = LAPACKE_slapy3_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_slapy3_work", x, y, z);
            }
            return (float)mh$.invokeExact(x, y, z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dlapy3_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_DOUBLE,
            lapacke_h.C_DOUBLE,
            lapacke_h.C_DOUBLE,
            lapacke_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dlapy3_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double LAPACKE_dlapy3_work(double x, double y, double z)
     * }
     */
    public static FunctionDescriptor LAPACKE_dlapy3_work$descriptor() {
        return LAPACKE_dlapy3_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double LAPACKE_dlapy3_work(double x, double y, double z)
     * }
     */
    public static MethodHandle LAPACKE_dlapy3_work$handle() {
        return LAPACKE_dlapy3_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double LAPACKE_dlapy3_work(double x, double y, double z)
     * }
     */
    public static MemorySegment LAPACKE_dlapy3_work$address() {
        return LAPACKE_dlapy3_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double LAPACKE_dlapy3_work(double x, double y, double z)
     * }
     */
    public static double LAPACKE_dlapy3_work(double x, double y, double z) {
        var mh$ = LAPACKE_dlapy3_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dlapy3_work", x, y, z);
            }
            return (double)mh$.invokeExact(x, y, z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_slamch_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_FLOAT,
            lapacke_h.C_CHAR
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_slamch_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float LAPACKE_slamch_work(char cmach)
     * }
     */
    public static FunctionDescriptor LAPACKE_slamch_work$descriptor() {
        return LAPACKE_slamch_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float LAPACKE_slamch_work(char cmach)
     * }
     */
    public static MethodHandle LAPACKE_slamch_work$handle() {
        return LAPACKE_slamch_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float LAPACKE_slamch_work(char cmach)
     * }
     */
    public static MemorySegment LAPACKE_slamch_work$address() {
        return LAPACKE_slamch_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float LAPACKE_slamch_work(char cmach)
     * }
     */
    public static float LAPACKE_slamch_work(byte cmach) {
        var mh$ = LAPACKE_slamch_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_slamch_work", cmach);
            }
            return (float)mh$.invokeExact(cmach);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dlamch_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_DOUBLE,
            lapacke_h.C_CHAR
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dlamch_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double LAPACKE_dlamch_work(char cmach)
     * }
     */
    public static FunctionDescriptor LAPACKE_dlamch_work$descriptor() {
        return LAPACKE_dlamch_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double LAPACKE_dlamch_work(char cmach)
     * }
     */
    public static MethodHandle LAPACKE_dlamch_work$handle() {
        return LAPACKE_dlamch_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double LAPACKE_dlamch_work(char cmach)
     * }
     */
    public static MemorySegment LAPACKE_dlamch_work$address() {
        return LAPACKE_dlamch_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double LAPACKE_dlamch_work(char cmach)
     * }
     */
    public static double LAPACKE_dlamch_work(byte cmach) {
        var mh$ = LAPACKE_dlamch_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dlamch_work", cmach);
            }
            return (double)mh$.invokeExact(cmach);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_slange_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_FLOAT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_slange_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float LAPACKE_slange_work(int matrix_layout, char norm, int m, int n, const float *a, int lda, float *work)
     * }
     */
    public static FunctionDescriptor LAPACKE_slange_work$descriptor() {
        return LAPACKE_slange_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float LAPACKE_slange_work(int matrix_layout, char norm, int m, int n, const float *a, int lda, float *work)
     * }
     */
    public static MethodHandle LAPACKE_slange_work$handle() {
        return LAPACKE_slange_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float LAPACKE_slange_work(int matrix_layout, char norm, int m, int n, const float *a, int lda, float *work)
     * }
     */
    public static MemorySegment LAPACKE_slange_work$address() {
        return LAPACKE_slange_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float LAPACKE_slange_work(int matrix_layout, char norm, int m, int n, const float *a, int lda, float *work)
     * }
     */
    public static float LAPACKE_slange_work(int matrix_layout, byte norm, int m, int n, MemorySegment a, int lda, MemorySegment work) {
        var mh$ = LAPACKE_slange_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_slange_work", matrix_layout, norm, m, n, a, lda, work);
            }
            return (float)mh$.invokeExact(matrix_layout, norm, m, n, a, lda, work);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dlange_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_DOUBLE,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dlange_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double LAPACKE_dlange_work(int matrix_layout, char norm, int m, int n, const double *a, int lda, double *work)
     * }
     */
    public static FunctionDescriptor LAPACKE_dlange_work$descriptor() {
        return LAPACKE_dlange_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double LAPACKE_dlange_work(int matrix_layout, char norm, int m, int n, const double *a, int lda, double *work)
     * }
     */
    public static MethodHandle LAPACKE_dlange_work$handle() {
        return LAPACKE_dlange_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double LAPACKE_dlange_work(int matrix_layout, char norm, int m, int n, const double *a, int lda, double *work)
     * }
     */
    public static MemorySegment LAPACKE_dlange_work$address() {
        return LAPACKE_dlange_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double LAPACKE_dlange_work(int matrix_layout, char norm, int m, int n, const double *a, int lda, double *work)
     * }
     */
    public static double LAPACKE_dlange_work(int matrix_layout, byte norm, int m, int n, MemorySegment a, int lda, MemorySegment work) {
        var mh$ = LAPACKE_dlange_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dlange_work", matrix_layout, norm, m, n, a, lda, work);
            }
            return (double)mh$.invokeExact(matrix_layout, norm, m, n, a, lda, work);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_clange_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_FLOAT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_clange_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float LAPACKE_clange_work(int matrix_layout, char norm, int m, int n, const _Complex float *a, int lda, float *work)
     * }
     */
    public static FunctionDescriptor LAPACKE_clange_work$descriptor() {
        return LAPACKE_clange_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float LAPACKE_clange_work(int matrix_layout, char norm, int m, int n, const _Complex float *a, int lda, float *work)
     * }
     */
    public static MethodHandle LAPACKE_clange_work$handle() {
        return LAPACKE_clange_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float LAPACKE_clange_work(int matrix_layout, char norm, int m, int n, const _Complex float *a, int lda, float *work)
     * }
     */
    public static MemorySegment LAPACKE_clange_work$address() {
        return LAPACKE_clange_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float LAPACKE_clange_work(int matrix_layout, char norm, int m, int n, const _Complex float *a, int lda, float *work)
     * }
     */
    public static float LAPACKE_clange_work(int matrix_layout, byte norm, int m, int n, MemorySegment a, int lda, MemorySegment work) {
        var mh$ = LAPACKE_clange_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_clange_work", matrix_layout, norm, m, n, a, lda, work);
            }
            return (float)mh$.invokeExact(matrix_layout, norm, m, n, a, lda, work);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zlange_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_DOUBLE,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zlange_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double LAPACKE_zlange_work(int matrix_layout, char norm, int m, int n, const _Complex double *a, int lda, double *work)
     * }
     */
    public static FunctionDescriptor LAPACKE_zlange_work$descriptor() {
        return LAPACKE_zlange_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double LAPACKE_zlange_work(int matrix_layout, char norm, int m, int n, const _Complex double *a, int lda, double *work)
     * }
     */
    public static MethodHandle LAPACKE_zlange_work$handle() {
        return LAPACKE_zlange_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double LAPACKE_zlange_work(int matrix_layout, char norm, int m, int n, const _Complex double *a, int lda, double *work)
     * }
     */
    public static MemorySegment LAPACKE_zlange_work$address() {
        return LAPACKE_zlange_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double LAPACKE_zlange_work(int matrix_layout, char norm, int m, int n, const _Complex double *a, int lda, double *work)
     * }
     */
    public static double LAPACKE_zlange_work(int matrix_layout, byte norm, int m, int n, MemorySegment a, int lda, MemorySegment work) {
        var mh$ = LAPACKE_zlange_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zlange_work", matrix_layout, norm, m, n, a, lda, work);
            }
            return (double)mh$.invokeExact(matrix_layout, norm, m, n, a, lda, work);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_clanhe_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_FLOAT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_clanhe_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float LAPACKE_clanhe_work(int matrix_layout, char norm, char uplo, int n, const _Complex float *a, int lda, float *work)
     * }
     */
    public static FunctionDescriptor LAPACKE_clanhe_work$descriptor() {
        return LAPACKE_clanhe_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float LAPACKE_clanhe_work(int matrix_layout, char norm, char uplo, int n, const _Complex float *a, int lda, float *work)
     * }
     */
    public static MethodHandle LAPACKE_clanhe_work$handle() {
        return LAPACKE_clanhe_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float LAPACKE_clanhe_work(int matrix_layout, char norm, char uplo, int n, const _Complex float *a, int lda, float *work)
     * }
     */
    public static MemorySegment LAPACKE_clanhe_work$address() {
        return LAPACKE_clanhe_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float LAPACKE_clanhe_work(int matrix_layout, char norm, char uplo, int n, const _Complex float *a, int lda, float *work)
     * }
     */
    public static float LAPACKE_clanhe_work(int matrix_layout, byte norm, byte uplo, int n, MemorySegment a, int lda, MemorySegment work) {
        var mh$ = LAPACKE_clanhe_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_clanhe_work", matrix_layout, norm, uplo, n, a, lda, work);
            }
            return (float)mh$.invokeExact(matrix_layout, norm, uplo, n, a, lda, work);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zlanhe_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_DOUBLE,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zlanhe_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double LAPACKE_zlanhe_work(int matrix_layout, char norm, char uplo, int n, const _Complex double *a, int lda, double *work)
     * }
     */
    public static FunctionDescriptor LAPACKE_zlanhe_work$descriptor() {
        return LAPACKE_zlanhe_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double LAPACKE_zlanhe_work(int matrix_layout, char norm, char uplo, int n, const _Complex double *a, int lda, double *work)
     * }
     */
    public static MethodHandle LAPACKE_zlanhe_work$handle() {
        return LAPACKE_zlanhe_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double LAPACKE_zlanhe_work(int matrix_layout, char norm, char uplo, int n, const _Complex double *a, int lda, double *work)
     * }
     */
    public static MemorySegment LAPACKE_zlanhe_work$address() {
        return LAPACKE_zlanhe_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double LAPACKE_zlanhe_work(int matrix_layout, char norm, char uplo, int n, const _Complex double *a, int lda, double *work)
     * }
     */
    public static double LAPACKE_zlanhe_work(int matrix_layout, byte norm, byte uplo, int n, MemorySegment a, int lda, MemorySegment work) {
        var mh$ = LAPACKE_zlanhe_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zlanhe_work", matrix_layout, norm, uplo, n, a, lda, work);
            }
            return (double)mh$.invokeExact(matrix_layout, norm, uplo, n, a, lda, work);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_clacrm_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_clacrm_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_clacrm_work(int matrix_layout, int m, int n, const _Complex float *a, int lda, const float *b, int ldb, _Complex float *c, int ldc, float *work)
     * }
     */
    public static FunctionDescriptor LAPACKE_clacrm_work$descriptor() {
        return LAPACKE_clacrm_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_clacrm_work(int matrix_layout, int m, int n, const _Complex float *a, int lda, const float *b, int ldb, _Complex float *c, int ldc, float *work)
     * }
     */
    public static MethodHandle LAPACKE_clacrm_work$handle() {
        return LAPACKE_clacrm_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_clacrm_work(int matrix_layout, int m, int n, const _Complex float *a, int lda, const float *b, int ldb, _Complex float *c, int ldc, float *work)
     * }
     */
    public static MemorySegment LAPACKE_clacrm_work$address() {
        return LAPACKE_clacrm_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_clacrm_work(int matrix_layout, int m, int n, const _Complex float *a, int lda, const float *b, int ldb, _Complex float *c, int ldc, float *work)
     * }
     */
    public static int LAPACKE_clacrm_work(int matrix_layout, int m, int n, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment c, int ldc, MemorySegment work) {
        var mh$ = LAPACKE_clacrm_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_clacrm_work", matrix_layout, m, n, a, lda, b, ldb, c, ldc, work);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, a, lda, b, ldb, c, ldc, work);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zlacrm_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zlacrm_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zlacrm_work(int matrix_layout, int m, int n, const _Complex double *a, int lda, const double *b, int ldb, _Complex double *c, int ldc, double *work)
     * }
     */
    public static FunctionDescriptor LAPACKE_zlacrm_work$descriptor() {
        return LAPACKE_zlacrm_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zlacrm_work(int matrix_layout, int m, int n, const _Complex double *a, int lda, const double *b, int ldb, _Complex double *c, int ldc, double *work)
     * }
     */
    public static MethodHandle LAPACKE_zlacrm_work$handle() {
        return LAPACKE_zlacrm_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zlacrm_work(int matrix_layout, int m, int n, const _Complex double *a, int lda, const double *b, int ldb, _Complex double *c, int ldc, double *work)
     * }
     */
    public static MemorySegment LAPACKE_zlacrm_work$address() {
        return LAPACKE_zlacrm_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zlacrm_work(int matrix_layout, int m, int n, const _Complex double *a, int lda, const double *b, int ldb, _Complex double *c, int ldc, double *work)
     * }
     */
    public static int LAPACKE_zlacrm_work(int matrix_layout, int m, int n, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment c, int ldc, MemorySegment work) {
        var mh$ = LAPACKE_zlacrm_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zlacrm_work", matrix_layout, m, n, a, lda, b, ldb, c, ldc, work);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, a, lda, b, ldb, c, ldc, work);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_clarcm_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_clarcm_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_clarcm_work(int matrix_layout, int m, int n, const float *a, int lda, const _Complex float *b, int ldb, _Complex float *c, int ldc, float *work)
     * }
     */
    public static FunctionDescriptor LAPACKE_clarcm_work$descriptor() {
        return LAPACKE_clarcm_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_clarcm_work(int matrix_layout, int m, int n, const float *a, int lda, const _Complex float *b, int ldb, _Complex float *c, int ldc, float *work)
     * }
     */
    public static MethodHandle LAPACKE_clarcm_work$handle() {
        return LAPACKE_clarcm_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_clarcm_work(int matrix_layout, int m, int n, const float *a, int lda, const _Complex float *b, int ldb, _Complex float *c, int ldc, float *work)
     * }
     */
    public static MemorySegment LAPACKE_clarcm_work$address() {
        return LAPACKE_clarcm_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_clarcm_work(int matrix_layout, int m, int n, const float *a, int lda, const _Complex float *b, int ldb, _Complex float *c, int ldc, float *work)
     * }
     */
    public static int LAPACKE_clarcm_work(int matrix_layout, int m, int n, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment c, int ldc, MemorySegment work) {
        var mh$ = LAPACKE_clarcm_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_clarcm_work", matrix_layout, m, n, a, lda, b, ldb, c, ldc, work);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, a, lda, b, ldb, c, ldc, work);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zlarcm_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zlarcm_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zlarcm_work(int matrix_layout, int m, int n, const double *a, int lda, const _Complex double *b, int ldb, _Complex double *c, int ldc, double *work)
     * }
     */
    public static FunctionDescriptor LAPACKE_zlarcm_work$descriptor() {
        return LAPACKE_zlarcm_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zlarcm_work(int matrix_layout, int m, int n, const double *a, int lda, const _Complex double *b, int ldb, _Complex double *c, int ldc, double *work)
     * }
     */
    public static MethodHandle LAPACKE_zlarcm_work$handle() {
        return LAPACKE_zlarcm_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zlarcm_work(int matrix_layout, int m, int n, const double *a, int lda, const _Complex double *b, int ldb, _Complex double *c, int ldc, double *work)
     * }
     */
    public static MemorySegment LAPACKE_zlarcm_work$address() {
        return LAPACKE_zlarcm_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zlarcm_work(int matrix_layout, int m, int n, const double *a, int lda, const _Complex double *b, int ldb, _Complex double *c, int ldc, double *work)
     * }
     */
    public static int LAPACKE_zlarcm_work(int matrix_layout, int m, int n, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment c, int ldc, MemorySegment work) {
        var mh$ = LAPACKE_zlarcm_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zlarcm_work", matrix_layout, m, n, a, lda, b, ldb, c, ldc, work);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, a, lda, b, ldb, c, ldc, work);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_slansy_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_FLOAT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_slansy_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float LAPACKE_slansy_work(int matrix_layout, char norm, char uplo, int n, const float *a, int lda, float *work)
     * }
     */
    public static FunctionDescriptor LAPACKE_slansy_work$descriptor() {
        return LAPACKE_slansy_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float LAPACKE_slansy_work(int matrix_layout, char norm, char uplo, int n, const float *a, int lda, float *work)
     * }
     */
    public static MethodHandle LAPACKE_slansy_work$handle() {
        return LAPACKE_slansy_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float LAPACKE_slansy_work(int matrix_layout, char norm, char uplo, int n, const float *a, int lda, float *work)
     * }
     */
    public static MemorySegment LAPACKE_slansy_work$address() {
        return LAPACKE_slansy_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float LAPACKE_slansy_work(int matrix_layout, char norm, char uplo, int n, const float *a, int lda, float *work)
     * }
     */
    public static float LAPACKE_slansy_work(int matrix_layout, byte norm, byte uplo, int n, MemorySegment a, int lda, MemorySegment work) {
        var mh$ = LAPACKE_slansy_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_slansy_work", matrix_layout, norm, uplo, n, a, lda, work);
            }
            return (float)mh$.invokeExact(matrix_layout, norm, uplo, n, a, lda, work);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dlansy_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_DOUBLE,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dlansy_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double LAPACKE_dlansy_work(int matrix_layout, char norm, char uplo, int n, const double *a, int lda, double *work)
     * }
     */
    public static FunctionDescriptor LAPACKE_dlansy_work$descriptor() {
        return LAPACKE_dlansy_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double LAPACKE_dlansy_work(int matrix_layout, char norm, char uplo, int n, const double *a, int lda, double *work)
     * }
     */
    public static MethodHandle LAPACKE_dlansy_work$handle() {
        return LAPACKE_dlansy_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double LAPACKE_dlansy_work(int matrix_layout, char norm, char uplo, int n, const double *a, int lda, double *work)
     * }
     */
    public static MemorySegment LAPACKE_dlansy_work$address() {
        return LAPACKE_dlansy_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double LAPACKE_dlansy_work(int matrix_layout, char norm, char uplo, int n, const double *a, int lda, double *work)
     * }
     */
    public static double LAPACKE_dlansy_work(int matrix_layout, byte norm, byte uplo, int n, MemorySegment a, int lda, MemorySegment work) {
        var mh$ = LAPACKE_dlansy_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dlansy_work", matrix_layout, norm, uplo, n, a, lda, work);
            }
            return (double)mh$.invokeExact(matrix_layout, norm, uplo, n, a, lda, work);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_clansy_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_FLOAT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_clansy_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float LAPACKE_clansy_work(int matrix_layout, char norm, char uplo, int n, const _Complex float *a, int lda, float *work)
     * }
     */
    public static FunctionDescriptor LAPACKE_clansy_work$descriptor() {
        return LAPACKE_clansy_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float LAPACKE_clansy_work(int matrix_layout, char norm, char uplo, int n, const _Complex float *a, int lda, float *work)
     * }
     */
    public static MethodHandle LAPACKE_clansy_work$handle() {
        return LAPACKE_clansy_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float LAPACKE_clansy_work(int matrix_layout, char norm, char uplo, int n, const _Complex float *a, int lda, float *work)
     * }
     */
    public static MemorySegment LAPACKE_clansy_work$address() {
        return LAPACKE_clansy_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float LAPACKE_clansy_work(int matrix_layout, char norm, char uplo, int n, const _Complex float *a, int lda, float *work)
     * }
     */
    public static float LAPACKE_clansy_work(int matrix_layout, byte norm, byte uplo, int n, MemorySegment a, int lda, MemorySegment work) {
        var mh$ = LAPACKE_clansy_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_clansy_work", matrix_layout, norm, uplo, n, a, lda, work);
            }
            return (float)mh$.invokeExact(matrix_layout, norm, uplo, n, a, lda, work);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zlansy_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_DOUBLE,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zlansy_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double LAPACKE_zlansy_work(int matrix_layout, char norm, char uplo, int n, const _Complex double *a, int lda, double *work)
     * }
     */
    public static FunctionDescriptor LAPACKE_zlansy_work$descriptor() {
        return LAPACKE_zlansy_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double LAPACKE_zlansy_work(int matrix_layout, char norm, char uplo, int n, const _Complex double *a, int lda, double *work)
     * }
     */
    public static MethodHandle LAPACKE_zlansy_work$handle() {
        return LAPACKE_zlansy_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double LAPACKE_zlansy_work(int matrix_layout, char norm, char uplo, int n, const _Complex double *a, int lda, double *work)
     * }
     */
    public static MemorySegment LAPACKE_zlansy_work$address() {
        return LAPACKE_zlansy_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double LAPACKE_zlansy_work(int matrix_layout, char norm, char uplo, int n, const _Complex double *a, int lda, double *work)
     * }
     */
    public static double LAPACKE_zlansy_work(int matrix_layout, byte norm, byte uplo, int n, MemorySegment a, int lda, MemorySegment work) {
        var mh$ = LAPACKE_zlansy_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zlansy_work", matrix_layout, norm, uplo, n, a, lda, work);
            }
            return (double)mh$.invokeExact(matrix_layout, norm, uplo, n, a, lda, work);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_slantr_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_FLOAT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_slantr_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float LAPACKE_slantr_work(int matrix_layout, char norm, char uplo, char diag, int m, int n, const float *a, int lda, float *work)
     * }
     */
    public static FunctionDescriptor LAPACKE_slantr_work$descriptor() {
        return LAPACKE_slantr_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float LAPACKE_slantr_work(int matrix_layout, char norm, char uplo, char diag, int m, int n, const float *a, int lda, float *work)
     * }
     */
    public static MethodHandle LAPACKE_slantr_work$handle() {
        return LAPACKE_slantr_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float LAPACKE_slantr_work(int matrix_layout, char norm, char uplo, char diag, int m, int n, const float *a, int lda, float *work)
     * }
     */
    public static MemorySegment LAPACKE_slantr_work$address() {
        return LAPACKE_slantr_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float LAPACKE_slantr_work(int matrix_layout, char norm, char uplo, char diag, int m, int n, const float *a, int lda, float *work)
     * }
     */
    public static float LAPACKE_slantr_work(int matrix_layout, byte norm, byte uplo, byte diag, int m, int n, MemorySegment a, int lda, MemorySegment work) {
        var mh$ = LAPACKE_slantr_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_slantr_work", matrix_layout, norm, uplo, diag, m, n, a, lda, work);
            }
            return (float)mh$.invokeExact(matrix_layout, norm, uplo, diag, m, n, a, lda, work);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dlantr_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_DOUBLE,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dlantr_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double LAPACKE_dlantr_work(int matrix_layout, char norm, char uplo, char diag, int m, int n, const double *a, int lda, double *work)
     * }
     */
    public static FunctionDescriptor LAPACKE_dlantr_work$descriptor() {
        return LAPACKE_dlantr_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double LAPACKE_dlantr_work(int matrix_layout, char norm, char uplo, char diag, int m, int n, const double *a, int lda, double *work)
     * }
     */
    public static MethodHandle LAPACKE_dlantr_work$handle() {
        return LAPACKE_dlantr_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double LAPACKE_dlantr_work(int matrix_layout, char norm, char uplo, char diag, int m, int n, const double *a, int lda, double *work)
     * }
     */
    public static MemorySegment LAPACKE_dlantr_work$address() {
        return LAPACKE_dlantr_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double LAPACKE_dlantr_work(int matrix_layout, char norm, char uplo, char diag, int m, int n, const double *a, int lda, double *work)
     * }
     */
    public static double LAPACKE_dlantr_work(int matrix_layout, byte norm, byte uplo, byte diag, int m, int n, MemorySegment a, int lda, MemorySegment work) {
        var mh$ = LAPACKE_dlantr_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dlantr_work", matrix_layout, norm, uplo, diag, m, n, a, lda, work);
            }
            return (double)mh$.invokeExact(matrix_layout, norm, uplo, diag, m, n, a, lda, work);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_clantr_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_FLOAT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_clantr_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float LAPACKE_clantr_work(int matrix_layout, char norm, char uplo, char diag, int m, int n, const _Complex float *a, int lda, float *work)
     * }
     */
    public static FunctionDescriptor LAPACKE_clantr_work$descriptor() {
        return LAPACKE_clantr_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float LAPACKE_clantr_work(int matrix_layout, char norm, char uplo, char diag, int m, int n, const _Complex float *a, int lda, float *work)
     * }
     */
    public static MethodHandle LAPACKE_clantr_work$handle() {
        return LAPACKE_clantr_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float LAPACKE_clantr_work(int matrix_layout, char norm, char uplo, char diag, int m, int n, const _Complex float *a, int lda, float *work)
     * }
     */
    public static MemorySegment LAPACKE_clantr_work$address() {
        return LAPACKE_clantr_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float LAPACKE_clantr_work(int matrix_layout, char norm, char uplo, char diag, int m, int n, const _Complex float *a, int lda, float *work)
     * }
     */
    public static float LAPACKE_clantr_work(int matrix_layout, byte norm, byte uplo, byte diag, int m, int n, MemorySegment a, int lda, MemorySegment work) {
        var mh$ = LAPACKE_clantr_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_clantr_work", matrix_layout, norm, uplo, diag, m, n, a, lda, work);
            }
            return (float)mh$.invokeExact(matrix_layout, norm, uplo, diag, m, n, a, lda, work);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zlantr_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_DOUBLE,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zlantr_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double LAPACKE_zlantr_work(int matrix_layout, char norm, char uplo, char diag, int m, int n, const _Complex double *a, int lda, double *work)
     * }
     */
    public static FunctionDescriptor LAPACKE_zlantr_work$descriptor() {
        return LAPACKE_zlantr_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double LAPACKE_zlantr_work(int matrix_layout, char norm, char uplo, char diag, int m, int n, const _Complex double *a, int lda, double *work)
     * }
     */
    public static MethodHandle LAPACKE_zlantr_work$handle() {
        return LAPACKE_zlantr_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double LAPACKE_zlantr_work(int matrix_layout, char norm, char uplo, char diag, int m, int n, const _Complex double *a, int lda, double *work)
     * }
     */
    public static MemorySegment LAPACKE_zlantr_work$address() {
        return LAPACKE_zlantr_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double LAPACKE_zlantr_work(int matrix_layout, char norm, char uplo, char diag, int m, int n, const _Complex double *a, int lda, double *work)
     * }
     */
    public static double LAPACKE_zlantr_work(int matrix_layout, byte norm, byte uplo, byte diag, int m, int n, MemorySegment a, int lda, MemorySegment work) {
        var mh$ = LAPACKE_zlantr_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zlantr_work", matrix_layout, norm, uplo, diag, m, n, a, lda, work);
            }
            return (double)mh$.invokeExact(matrix_layout, norm, uplo, diag, m, n, a, lda, work);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_slarfb_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_slarfb_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_slarfb_work(int matrix_layout, char side, char trans, char direct, char storev, int m, int n, int k, const float *v, int ldv, const float *t, int ldt, float *c, int ldc, float *work, int ldwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_slarfb_work$descriptor() {
        return LAPACKE_slarfb_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_slarfb_work(int matrix_layout, char side, char trans, char direct, char storev, int m, int n, int k, const float *v, int ldv, const float *t, int ldt, float *c, int ldc, float *work, int ldwork)
     * }
     */
    public static MethodHandle LAPACKE_slarfb_work$handle() {
        return LAPACKE_slarfb_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_slarfb_work(int matrix_layout, char side, char trans, char direct, char storev, int m, int n, int k, const float *v, int ldv, const float *t, int ldt, float *c, int ldc, float *work, int ldwork)
     * }
     */
    public static MemorySegment LAPACKE_slarfb_work$address() {
        return LAPACKE_slarfb_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_slarfb_work(int matrix_layout, char side, char trans, char direct, char storev, int m, int n, int k, const float *v, int ldv, const float *t, int ldt, float *c, int ldc, float *work, int ldwork)
     * }
     */
    public static int LAPACKE_slarfb_work(int matrix_layout, byte side, byte trans, byte direct, byte storev, int m, int n, int k, MemorySegment v, int ldv, MemorySegment t, int ldt, MemorySegment c, int ldc, MemorySegment work, int ldwork) {
        var mh$ = LAPACKE_slarfb_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_slarfb_work", matrix_layout, side, trans, direct, storev, m, n, k, v, ldv, t, ldt, c, ldc, work, ldwork);
            }
            return (int)mh$.invokeExact(matrix_layout, side, trans, direct, storev, m, n, k, v, ldv, t, ldt, c, ldc, work, ldwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dlarfb_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dlarfb_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dlarfb_work(int matrix_layout, char side, char trans, char direct, char storev, int m, int n, int k, const double *v, int ldv, const double *t, int ldt, double *c, int ldc, double *work, int ldwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_dlarfb_work$descriptor() {
        return LAPACKE_dlarfb_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dlarfb_work(int matrix_layout, char side, char trans, char direct, char storev, int m, int n, int k, const double *v, int ldv, const double *t, int ldt, double *c, int ldc, double *work, int ldwork)
     * }
     */
    public static MethodHandle LAPACKE_dlarfb_work$handle() {
        return LAPACKE_dlarfb_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dlarfb_work(int matrix_layout, char side, char trans, char direct, char storev, int m, int n, int k, const double *v, int ldv, const double *t, int ldt, double *c, int ldc, double *work, int ldwork)
     * }
     */
    public static MemorySegment LAPACKE_dlarfb_work$address() {
        return LAPACKE_dlarfb_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dlarfb_work(int matrix_layout, char side, char trans, char direct, char storev, int m, int n, int k, const double *v, int ldv, const double *t, int ldt, double *c, int ldc, double *work, int ldwork)
     * }
     */
    public static int LAPACKE_dlarfb_work(int matrix_layout, byte side, byte trans, byte direct, byte storev, int m, int n, int k, MemorySegment v, int ldv, MemorySegment t, int ldt, MemorySegment c, int ldc, MemorySegment work, int ldwork) {
        var mh$ = LAPACKE_dlarfb_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dlarfb_work", matrix_layout, side, trans, direct, storev, m, n, k, v, ldv, t, ldt, c, ldc, work, ldwork);
            }
            return (int)mh$.invokeExact(matrix_layout, side, trans, direct, storev, m, n, k, v, ldv, t, ldt, c, ldc, work, ldwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_clarfb_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_clarfb_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_clarfb_work(int matrix_layout, char side, char trans, char direct, char storev, int m, int n, int k, const _Complex float *v, int ldv, const _Complex float *t, int ldt, _Complex float *c, int ldc, _Complex float *work, int ldwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_clarfb_work$descriptor() {
        return LAPACKE_clarfb_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_clarfb_work(int matrix_layout, char side, char trans, char direct, char storev, int m, int n, int k, const _Complex float *v, int ldv, const _Complex float *t, int ldt, _Complex float *c, int ldc, _Complex float *work, int ldwork)
     * }
     */
    public static MethodHandle LAPACKE_clarfb_work$handle() {
        return LAPACKE_clarfb_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_clarfb_work(int matrix_layout, char side, char trans, char direct, char storev, int m, int n, int k, const _Complex float *v, int ldv, const _Complex float *t, int ldt, _Complex float *c, int ldc, _Complex float *work, int ldwork)
     * }
     */
    public static MemorySegment LAPACKE_clarfb_work$address() {
        return LAPACKE_clarfb_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_clarfb_work(int matrix_layout, char side, char trans, char direct, char storev, int m, int n, int k, const _Complex float *v, int ldv, const _Complex float *t, int ldt, _Complex float *c, int ldc, _Complex float *work, int ldwork)
     * }
     */
    public static int LAPACKE_clarfb_work(int matrix_layout, byte side, byte trans, byte direct, byte storev, int m, int n, int k, MemorySegment v, int ldv, MemorySegment t, int ldt, MemorySegment c, int ldc, MemorySegment work, int ldwork) {
        var mh$ = LAPACKE_clarfb_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_clarfb_work", matrix_layout, side, trans, direct, storev, m, n, k, v, ldv, t, ldt, c, ldc, work, ldwork);
            }
            return (int)mh$.invokeExact(matrix_layout, side, trans, direct, storev, m, n, k, v, ldv, t, ldt, c, ldc, work, ldwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zlarfb_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zlarfb_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zlarfb_work(int matrix_layout, char side, char trans, char direct, char storev, int m, int n, int k, const _Complex double *v, int ldv, const _Complex double *t, int ldt, _Complex double *c, int ldc, _Complex double *work, int ldwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_zlarfb_work$descriptor() {
        return LAPACKE_zlarfb_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zlarfb_work(int matrix_layout, char side, char trans, char direct, char storev, int m, int n, int k, const _Complex double *v, int ldv, const _Complex double *t, int ldt, _Complex double *c, int ldc, _Complex double *work, int ldwork)
     * }
     */
    public static MethodHandle LAPACKE_zlarfb_work$handle() {
        return LAPACKE_zlarfb_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zlarfb_work(int matrix_layout, char side, char trans, char direct, char storev, int m, int n, int k, const _Complex double *v, int ldv, const _Complex double *t, int ldt, _Complex double *c, int ldc, _Complex double *work, int ldwork)
     * }
     */
    public static MemorySegment LAPACKE_zlarfb_work$address() {
        return LAPACKE_zlarfb_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zlarfb_work(int matrix_layout, char side, char trans, char direct, char storev, int m, int n, int k, const _Complex double *v, int ldv, const _Complex double *t, int ldt, _Complex double *c, int ldc, _Complex double *work, int ldwork)
     * }
     */
    public static int LAPACKE_zlarfb_work(int matrix_layout, byte side, byte trans, byte direct, byte storev, int m, int n, int k, MemorySegment v, int ldv, MemorySegment t, int ldt, MemorySegment c, int ldc, MemorySegment work, int ldwork) {
        var mh$ = LAPACKE_zlarfb_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zlarfb_work", matrix_layout, side, trans, direct, storev, m, n, k, v, ldv, t, ldt, c, ldc, work, ldwork);
            }
            return (int)mh$.invokeExact(matrix_layout, side, trans, direct, storev, m, n, k, v, ldv, t, ldt, c, ldc, work, ldwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_slarfg_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_slarfg_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_slarfg_work(int n, float *alpha, float *x, int incx, float *tau)
     * }
     */
    public static FunctionDescriptor LAPACKE_slarfg_work$descriptor() {
        return LAPACKE_slarfg_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_slarfg_work(int n, float *alpha, float *x, int incx, float *tau)
     * }
     */
    public static MethodHandle LAPACKE_slarfg_work$handle() {
        return LAPACKE_slarfg_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_slarfg_work(int n, float *alpha, float *x, int incx, float *tau)
     * }
     */
    public static MemorySegment LAPACKE_slarfg_work$address() {
        return LAPACKE_slarfg_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_slarfg_work(int n, float *alpha, float *x, int incx, float *tau)
     * }
     */
    public static int LAPACKE_slarfg_work(int n, MemorySegment alpha, MemorySegment x, int incx, MemorySegment tau) {
        var mh$ = LAPACKE_slarfg_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_slarfg_work", n, alpha, x, incx, tau);
            }
            return (int)mh$.invokeExact(n, alpha, x, incx, tau);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dlarfg_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dlarfg_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dlarfg_work(int n, double *alpha, double *x, int incx, double *tau)
     * }
     */
    public static FunctionDescriptor LAPACKE_dlarfg_work$descriptor() {
        return LAPACKE_dlarfg_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dlarfg_work(int n, double *alpha, double *x, int incx, double *tau)
     * }
     */
    public static MethodHandle LAPACKE_dlarfg_work$handle() {
        return LAPACKE_dlarfg_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dlarfg_work(int n, double *alpha, double *x, int incx, double *tau)
     * }
     */
    public static MemorySegment LAPACKE_dlarfg_work$address() {
        return LAPACKE_dlarfg_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dlarfg_work(int n, double *alpha, double *x, int incx, double *tau)
     * }
     */
    public static int LAPACKE_dlarfg_work(int n, MemorySegment alpha, MemorySegment x, int incx, MemorySegment tau) {
        var mh$ = LAPACKE_dlarfg_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dlarfg_work", n, alpha, x, incx, tau);
            }
            return (int)mh$.invokeExact(n, alpha, x, incx, tau);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_clarfg_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_clarfg_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_clarfg_work(int n, _Complex float *alpha, _Complex float *x, int incx, _Complex float *tau)
     * }
     */
    public static FunctionDescriptor LAPACKE_clarfg_work$descriptor() {
        return LAPACKE_clarfg_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_clarfg_work(int n, _Complex float *alpha, _Complex float *x, int incx, _Complex float *tau)
     * }
     */
    public static MethodHandle LAPACKE_clarfg_work$handle() {
        return LAPACKE_clarfg_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_clarfg_work(int n, _Complex float *alpha, _Complex float *x, int incx, _Complex float *tau)
     * }
     */
    public static MemorySegment LAPACKE_clarfg_work$address() {
        return LAPACKE_clarfg_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_clarfg_work(int n, _Complex float *alpha, _Complex float *x, int incx, _Complex float *tau)
     * }
     */
    public static int LAPACKE_clarfg_work(int n, MemorySegment alpha, MemorySegment x, int incx, MemorySegment tau) {
        var mh$ = LAPACKE_clarfg_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_clarfg_work", n, alpha, x, incx, tau);
            }
            return (int)mh$.invokeExact(n, alpha, x, incx, tau);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zlarfg_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zlarfg_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zlarfg_work(int n, _Complex double *alpha, _Complex double *x, int incx, _Complex double *tau)
     * }
     */
    public static FunctionDescriptor LAPACKE_zlarfg_work$descriptor() {
        return LAPACKE_zlarfg_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zlarfg_work(int n, _Complex double *alpha, _Complex double *x, int incx, _Complex double *tau)
     * }
     */
    public static MethodHandle LAPACKE_zlarfg_work$handle() {
        return LAPACKE_zlarfg_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zlarfg_work(int n, _Complex double *alpha, _Complex double *x, int incx, _Complex double *tau)
     * }
     */
    public static MemorySegment LAPACKE_zlarfg_work$address() {
        return LAPACKE_zlarfg_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zlarfg_work(int n, _Complex double *alpha, _Complex double *x, int incx, _Complex double *tau)
     * }
     */
    public static int LAPACKE_zlarfg_work(int n, MemorySegment alpha, MemorySegment x, int incx, MemorySegment tau) {
        var mh$ = LAPACKE_zlarfg_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zlarfg_work", n, alpha, x, incx, tau);
            }
            return (int)mh$.invokeExact(n, alpha, x, incx, tau);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_slarft_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_slarft_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_slarft_work(int matrix_layout, char direct, char storev, int n, int k, const float *v, int ldv, const float *tau, float *t, int ldt)
     * }
     */
    public static FunctionDescriptor LAPACKE_slarft_work$descriptor() {
        return LAPACKE_slarft_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_slarft_work(int matrix_layout, char direct, char storev, int n, int k, const float *v, int ldv, const float *tau, float *t, int ldt)
     * }
     */
    public static MethodHandle LAPACKE_slarft_work$handle() {
        return LAPACKE_slarft_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_slarft_work(int matrix_layout, char direct, char storev, int n, int k, const float *v, int ldv, const float *tau, float *t, int ldt)
     * }
     */
    public static MemorySegment LAPACKE_slarft_work$address() {
        return LAPACKE_slarft_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_slarft_work(int matrix_layout, char direct, char storev, int n, int k, const float *v, int ldv, const float *tau, float *t, int ldt)
     * }
     */
    public static int LAPACKE_slarft_work(int matrix_layout, byte direct, byte storev, int n, int k, MemorySegment v, int ldv, MemorySegment tau, MemorySegment t, int ldt) {
        var mh$ = LAPACKE_slarft_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_slarft_work", matrix_layout, direct, storev, n, k, v, ldv, tau, t, ldt);
            }
            return (int)mh$.invokeExact(matrix_layout, direct, storev, n, k, v, ldv, tau, t, ldt);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dlarft_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dlarft_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dlarft_work(int matrix_layout, char direct, char storev, int n, int k, const double *v, int ldv, const double *tau, double *t, int ldt)
     * }
     */
    public static FunctionDescriptor LAPACKE_dlarft_work$descriptor() {
        return LAPACKE_dlarft_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dlarft_work(int matrix_layout, char direct, char storev, int n, int k, const double *v, int ldv, const double *tau, double *t, int ldt)
     * }
     */
    public static MethodHandle LAPACKE_dlarft_work$handle() {
        return LAPACKE_dlarft_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dlarft_work(int matrix_layout, char direct, char storev, int n, int k, const double *v, int ldv, const double *tau, double *t, int ldt)
     * }
     */
    public static MemorySegment LAPACKE_dlarft_work$address() {
        return LAPACKE_dlarft_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dlarft_work(int matrix_layout, char direct, char storev, int n, int k, const double *v, int ldv, const double *tau, double *t, int ldt)
     * }
     */
    public static int LAPACKE_dlarft_work(int matrix_layout, byte direct, byte storev, int n, int k, MemorySegment v, int ldv, MemorySegment tau, MemorySegment t, int ldt) {
        var mh$ = LAPACKE_dlarft_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dlarft_work", matrix_layout, direct, storev, n, k, v, ldv, tau, t, ldt);
            }
            return (int)mh$.invokeExact(matrix_layout, direct, storev, n, k, v, ldv, tau, t, ldt);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_clarft_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_clarft_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_clarft_work(int matrix_layout, char direct, char storev, int n, int k, const _Complex float *v, int ldv, const _Complex float *tau, _Complex float *t, int ldt)
     * }
     */
    public static FunctionDescriptor LAPACKE_clarft_work$descriptor() {
        return LAPACKE_clarft_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_clarft_work(int matrix_layout, char direct, char storev, int n, int k, const _Complex float *v, int ldv, const _Complex float *tau, _Complex float *t, int ldt)
     * }
     */
    public static MethodHandle LAPACKE_clarft_work$handle() {
        return LAPACKE_clarft_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_clarft_work(int matrix_layout, char direct, char storev, int n, int k, const _Complex float *v, int ldv, const _Complex float *tau, _Complex float *t, int ldt)
     * }
     */
    public static MemorySegment LAPACKE_clarft_work$address() {
        return LAPACKE_clarft_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_clarft_work(int matrix_layout, char direct, char storev, int n, int k, const _Complex float *v, int ldv, const _Complex float *tau, _Complex float *t, int ldt)
     * }
     */
    public static int LAPACKE_clarft_work(int matrix_layout, byte direct, byte storev, int n, int k, MemorySegment v, int ldv, MemorySegment tau, MemorySegment t, int ldt) {
        var mh$ = LAPACKE_clarft_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_clarft_work", matrix_layout, direct, storev, n, k, v, ldv, tau, t, ldt);
            }
            return (int)mh$.invokeExact(matrix_layout, direct, storev, n, k, v, ldv, tau, t, ldt);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zlarft_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zlarft_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zlarft_work(int matrix_layout, char direct, char storev, int n, int k, const _Complex double *v, int ldv, const _Complex double *tau, _Complex double *t, int ldt)
     * }
     */
    public static FunctionDescriptor LAPACKE_zlarft_work$descriptor() {
        return LAPACKE_zlarft_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zlarft_work(int matrix_layout, char direct, char storev, int n, int k, const _Complex double *v, int ldv, const _Complex double *tau, _Complex double *t, int ldt)
     * }
     */
    public static MethodHandle LAPACKE_zlarft_work$handle() {
        return LAPACKE_zlarft_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zlarft_work(int matrix_layout, char direct, char storev, int n, int k, const _Complex double *v, int ldv, const _Complex double *tau, _Complex double *t, int ldt)
     * }
     */
    public static MemorySegment LAPACKE_zlarft_work$address() {
        return LAPACKE_zlarft_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zlarft_work(int matrix_layout, char direct, char storev, int n, int k, const _Complex double *v, int ldv, const _Complex double *tau, _Complex double *t, int ldt)
     * }
     */
    public static int LAPACKE_zlarft_work(int matrix_layout, byte direct, byte storev, int n, int k, MemorySegment v, int ldv, MemorySegment tau, MemorySegment t, int ldt) {
        var mh$ = LAPACKE_zlarft_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zlarft_work", matrix_layout, direct, storev, n, k, v, ldv, tau, t, ldt);
            }
            return (int)mh$.invokeExact(matrix_layout, direct, storev, n, k, v, ldv, tau, t, ldt);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_slarfx_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_FLOAT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_slarfx_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_slarfx_work(int matrix_layout, char side, int m, int n, const float *v, float tau, float *c, int ldc, float *work)
     * }
     */
    public static FunctionDescriptor LAPACKE_slarfx_work$descriptor() {
        return LAPACKE_slarfx_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_slarfx_work(int matrix_layout, char side, int m, int n, const float *v, float tau, float *c, int ldc, float *work)
     * }
     */
    public static MethodHandle LAPACKE_slarfx_work$handle() {
        return LAPACKE_slarfx_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_slarfx_work(int matrix_layout, char side, int m, int n, const float *v, float tau, float *c, int ldc, float *work)
     * }
     */
    public static MemorySegment LAPACKE_slarfx_work$address() {
        return LAPACKE_slarfx_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_slarfx_work(int matrix_layout, char side, int m, int n, const float *v, float tau, float *c, int ldc, float *work)
     * }
     */
    public static int LAPACKE_slarfx_work(int matrix_layout, byte side, int m, int n, MemorySegment v, float tau, MemorySegment c, int ldc, MemorySegment work) {
        var mh$ = LAPACKE_slarfx_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_slarfx_work", matrix_layout, side, m, n, v, tau, c, ldc, work);
            }
            return (int)mh$.invokeExact(matrix_layout, side, m, n, v, tau, c, ldc, work);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dlarfx_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_DOUBLE,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dlarfx_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dlarfx_work(int matrix_layout, char side, int m, int n, const double *v, double tau, double *c, int ldc, double *work)
     * }
     */
    public static FunctionDescriptor LAPACKE_dlarfx_work$descriptor() {
        return LAPACKE_dlarfx_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dlarfx_work(int matrix_layout, char side, int m, int n, const double *v, double tau, double *c, int ldc, double *work)
     * }
     */
    public static MethodHandle LAPACKE_dlarfx_work$handle() {
        return LAPACKE_dlarfx_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dlarfx_work(int matrix_layout, char side, int m, int n, const double *v, double tau, double *c, int ldc, double *work)
     * }
     */
    public static MemorySegment LAPACKE_dlarfx_work$address() {
        return LAPACKE_dlarfx_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dlarfx_work(int matrix_layout, char side, int m, int n, const double *v, double tau, double *c, int ldc, double *work)
     * }
     */
    public static int LAPACKE_dlarfx_work(int matrix_layout, byte side, int m, int n, MemorySegment v, double tau, MemorySegment c, int ldc, MemorySegment work) {
        var mh$ = LAPACKE_dlarfx_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dlarfx_work", matrix_layout, side, m, n, v, tau, c, ldc, work);
            }
            return (int)mh$.invokeExact(matrix_layout, side, m, n, v, tau, c, ldc, work);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_clarfx_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_FLOAT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_clarfx_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_clarfx_work(int matrix_layout, char side, int m, int n, const _Complex float *v, _Complex float tau, _Complex float *c, int ldc, _Complex float *work)
     * }
     */
    public static FunctionDescriptor LAPACKE_clarfx_work$descriptor() {
        return LAPACKE_clarfx_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_clarfx_work(int matrix_layout, char side, int m, int n, const _Complex float *v, _Complex float tau, _Complex float *c, int ldc, _Complex float *work)
     * }
     */
    public static MethodHandle LAPACKE_clarfx_work$handle() {
        return LAPACKE_clarfx_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_clarfx_work(int matrix_layout, char side, int m, int n, const _Complex float *v, _Complex float tau, _Complex float *c, int ldc, _Complex float *work)
     * }
     */
    public static MemorySegment LAPACKE_clarfx_work$address() {
        return LAPACKE_clarfx_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_clarfx_work(int matrix_layout, char side, int m, int n, const _Complex float *v, _Complex float tau, _Complex float *c, int ldc, _Complex float *work)
     * }
     */
    public static int LAPACKE_clarfx_work(int matrix_layout, byte side, int m, int n, MemorySegment v, float tau, MemorySegment c, int ldc, MemorySegment work) {
        var mh$ = LAPACKE_clarfx_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_clarfx_work", matrix_layout, side, m, n, v, tau, c, ldc, work);
            }
            return (int)mh$.invokeExact(matrix_layout, side, m, n, v, tau, c, ldc, work);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zlarfx_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_DOUBLE,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zlarfx_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zlarfx_work(int matrix_layout, char side, int m, int n, const _Complex double *v, _Complex double tau, _Complex double *c, int ldc, _Complex double *work)
     * }
     */
    public static FunctionDescriptor LAPACKE_zlarfx_work$descriptor() {
        return LAPACKE_zlarfx_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zlarfx_work(int matrix_layout, char side, int m, int n, const _Complex double *v, _Complex double tau, _Complex double *c, int ldc, _Complex double *work)
     * }
     */
    public static MethodHandle LAPACKE_zlarfx_work$handle() {
        return LAPACKE_zlarfx_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zlarfx_work(int matrix_layout, char side, int m, int n, const _Complex double *v, _Complex double tau, _Complex double *c, int ldc, _Complex double *work)
     * }
     */
    public static MemorySegment LAPACKE_zlarfx_work$address() {
        return LAPACKE_zlarfx_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zlarfx_work(int matrix_layout, char side, int m, int n, const _Complex double *v, _Complex double tau, _Complex double *c, int ldc, _Complex double *work)
     * }
     */
    public static int LAPACKE_zlarfx_work(int matrix_layout, byte side, int m, int n, MemorySegment v, double tau, MemorySegment c, int ldc, MemorySegment work) {
        var mh$ = LAPACKE_zlarfx_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zlarfx_work", matrix_layout, side, m, n, v, tau, c, ldc, work);
            }
            return (int)mh$.invokeExact(matrix_layout, side, m, n, v, tau, c, ldc, work);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_slarnv_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_slarnv_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_slarnv_work(int idist, int *iseed, int n, float *x)
     * }
     */
    public static FunctionDescriptor LAPACKE_slarnv_work$descriptor() {
        return LAPACKE_slarnv_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_slarnv_work(int idist, int *iseed, int n, float *x)
     * }
     */
    public static MethodHandle LAPACKE_slarnv_work$handle() {
        return LAPACKE_slarnv_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_slarnv_work(int idist, int *iseed, int n, float *x)
     * }
     */
    public static MemorySegment LAPACKE_slarnv_work$address() {
        return LAPACKE_slarnv_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_slarnv_work(int idist, int *iseed, int n, float *x)
     * }
     */
    public static int LAPACKE_slarnv_work(int idist, MemorySegment iseed, int n, MemorySegment x) {
        var mh$ = LAPACKE_slarnv_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_slarnv_work", idist, iseed, n, x);
            }
            return (int)mh$.invokeExact(idist, iseed, n, x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dlarnv_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dlarnv_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dlarnv_work(int idist, int *iseed, int n, double *x)
     * }
     */
    public static FunctionDescriptor LAPACKE_dlarnv_work$descriptor() {
        return LAPACKE_dlarnv_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dlarnv_work(int idist, int *iseed, int n, double *x)
     * }
     */
    public static MethodHandle LAPACKE_dlarnv_work$handle() {
        return LAPACKE_dlarnv_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dlarnv_work(int idist, int *iseed, int n, double *x)
     * }
     */
    public static MemorySegment LAPACKE_dlarnv_work$address() {
        return LAPACKE_dlarnv_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dlarnv_work(int idist, int *iseed, int n, double *x)
     * }
     */
    public static int LAPACKE_dlarnv_work(int idist, MemorySegment iseed, int n, MemorySegment x) {
        var mh$ = LAPACKE_dlarnv_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dlarnv_work", idist, iseed, n, x);
            }
            return (int)mh$.invokeExact(idist, iseed, n, x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_clarnv_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_clarnv_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_clarnv_work(int idist, int *iseed, int n, _Complex float *x)
     * }
     */
    public static FunctionDescriptor LAPACKE_clarnv_work$descriptor() {
        return LAPACKE_clarnv_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_clarnv_work(int idist, int *iseed, int n, _Complex float *x)
     * }
     */
    public static MethodHandle LAPACKE_clarnv_work$handle() {
        return LAPACKE_clarnv_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_clarnv_work(int idist, int *iseed, int n, _Complex float *x)
     * }
     */
    public static MemorySegment LAPACKE_clarnv_work$address() {
        return LAPACKE_clarnv_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_clarnv_work(int idist, int *iseed, int n, _Complex float *x)
     * }
     */
    public static int LAPACKE_clarnv_work(int idist, MemorySegment iseed, int n, MemorySegment x) {
        var mh$ = LAPACKE_clarnv_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_clarnv_work", idist, iseed, n, x);
            }
            return (int)mh$.invokeExact(idist, iseed, n, x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zlarnv_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zlarnv_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zlarnv_work(int idist, int *iseed, int n, _Complex double *x)
     * }
     */
    public static FunctionDescriptor LAPACKE_zlarnv_work$descriptor() {
        return LAPACKE_zlarnv_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zlarnv_work(int idist, int *iseed, int n, _Complex double *x)
     * }
     */
    public static MethodHandle LAPACKE_zlarnv_work$handle() {
        return LAPACKE_zlarnv_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zlarnv_work(int idist, int *iseed, int n, _Complex double *x)
     * }
     */
    public static MemorySegment LAPACKE_zlarnv_work$address() {
        return LAPACKE_zlarnv_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zlarnv_work(int idist, int *iseed, int n, _Complex double *x)
     * }
     */
    public static int LAPACKE_zlarnv_work(int idist, MemorySegment iseed, int n, MemorySegment x) {
        var mh$ = LAPACKE_zlarnv_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zlarnv_work", idist, iseed, n, x);
            }
            return (int)mh$.invokeExact(idist, iseed, n, x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_slascl_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_FLOAT,
            lapacke_h.C_FLOAT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_slascl_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_slascl_work(int matrix_layout, char type, int kl, int ku, float cfrom, float cto, int m, int n, float *a, int lda)
     * }
     */
    public static FunctionDescriptor LAPACKE_slascl_work$descriptor() {
        return LAPACKE_slascl_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_slascl_work(int matrix_layout, char type, int kl, int ku, float cfrom, float cto, int m, int n, float *a, int lda)
     * }
     */
    public static MethodHandle LAPACKE_slascl_work$handle() {
        return LAPACKE_slascl_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_slascl_work(int matrix_layout, char type, int kl, int ku, float cfrom, float cto, int m, int n, float *a, int lda)
     * }
     */
    public static MemorySegment LAPACKE_slascl_work$address() {
        return LAPACKE_slascl_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_slascl_work(int matrix_layout, char type, int kl, int ku, float cfrom, float cto, int m, int n, float *a, int lda)
     * }
     */
    public static int LAPACKE_slascl_work(int matrix_layout, byte type, int kl, int ku, float cfrom, float cto, int m, int n, MemorySegment a, int lda) {
        var mh$ = LAPACKE_slascl_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_slascl_work", matrix_layout, type, kl, ku, cfrom, cto, m, n, a, lda);
            }
            return (int)mh$.invokeExact(matrix_layout, type, kl, ku, cfrom, cto, m, n, a, lda);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dlascl_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_DOUBLE,
            lapacke_h.C_DOUBLE,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dlascl_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dlascl_work(int matrix_layout, char type, int kl, int ku, double cfrom, double cto, int m, int n, double *a, int lda)
     * }
     */
    public static FunctionDescriptor LAPACKE_dlascl_work$descriptor() {
        return LAPACKE_dlascl_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dlascl_work(int matrix_layout, char type, int kl, int ku, double cfrom, double cto, int m, int n, double *a, int lda)
     * }
     */
    public static MethodHandle LAPACKE_dlascl_work$handle() {
        return LAPACKE_dlascl_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dlascl_work(int matrix_layout, char type, int kl, int ku, double cfrom, double cto, int m, int n, double *a, int lda)
     * }
     */
    public static MemorySegment LAPACKE_dlascl_work$address() {
        return LAPACKE_dlascl_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dlascl_work(int matrix_layout, char type, int kl, int ku, double cfrom, double cto, int m, int n, double *a, int lda)
     * }
     */
    public static int LAPACKE_dlascl_work(int matrix_layout, byte type, int kl, int ku, double cfrom, double cto, int m, int n, MemorySegment a, int lda) {
        var mh$ = LAPACKE_dlascl_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dlascl_work", matrix_layout, type, kl, ku, cfrom, cto, m, n, a, lda);
            }
            return (int)mh$.invokeExact(matrix_layout, type, kl, ku, cfrom, cto, m, n, a, lda);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_clascl_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_FLOAT,
            lapacke_h.C_FLOAT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_clascl_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_clascl_work(int matrix_layout, char type, int kl, int ku, float cfrom, float cto, int m, int n, _Complex float *a, int lda)
     * }
     */
    public static FunctionDescriptor LAPACKE_clascl_work$descriptor() {
        return LAPACKE_clascl_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_clascl_work(int matrix_layout, char type, int kl, int ku, float cfrom, float cto, int m, int n, _Complex float *a, int lda)
     * }
     */
    public static MethodHandle LAPACKE_clascl_work$handle() {
        return LAPACKE_clascl_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_clascl_work(int matrix_layout, char type, int kl, int ku, float cfrom, float cto, int m, int n, _Complex float *a, int lda)
     * }
     */
    public static MemorySegment LAPACKE_clascl_work$address() {
        return LAPACKE_clascl_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_clascl_work(int matrix_layout, char type, int kl, int ku, float cfrom, float cto, int m, int n, _Complex float *a, int lda)
     * }
     */
    public static int LAPACKE_clascl_work(int matrix_layout, byte type, int kl, int ku, float cfrom, float cto, int m, int n, MemorySegment a, int lda) {
        var mh$ = LAPACKE_clascl_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_clascl_work", matrix_layout, type, kl, ku, cfrom, cto, m, n, a, lda);
            }
            return (int)mh$.invokeExact(matrix_layout, type, kl, ku, cfrom, cto, m, n, a, lda);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zlascl_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_DOUBLE,
            lapacke_h.C_DOUBLE,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zlascl_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zlascl_work(int matrix_layout, char type, int kl, int ku, double cfrom, double cto, int m, int n, _Complex double *a, int lda)
     * }
     */
    public static FunctionDescriptor LAPACKE_zlascl_work$descriptor() {
        return LAPACKE_zlascl_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zlascl_work(int matrix_layout, char type, int kl, int ku, double cfrom, double cto, int m, int n, _Complex double *a, int lda)
     * }
     */
    public static MethodHandle LAPACKE_zlascl_work$handle() {
        return LAPACKE_zlascl_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zlascl_work(int matrix_layout, char type, int kl, int ku, double cfrom, double cto, int m, int n, _Complex double *a, int lda)
     * }
     */
    public static MemorySegment LAPACKE_zlascl_work$address() {
        return LAPACKE_zlascl_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zlascl_work(int matrix_layout, char type, int kl, int ku, double cfrom, double cto, int m, int n, _Complex double *a, int lda)
     * }
     */
    public static int LAPACKE_zlascl_work(int matrix_layout, byte type, int kl, int ku, double cfrom, double cto, int m, int n, MemorySegment a, int lda) {
        var mh$ = LAPACKE_zlascl_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zlascl_work", matrix_layout, type, kl, ku, cfrom, cto, m, n, a, lda);
            }
            return (int)mh$.invokeExact(matrix_layout, type, kl, ku, cfrom, cto, m, n, a, lda);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_slaset_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_FLOAT,
            lapacke_h.C_FLOAT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_slaset_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_slaset_work(int matrix_layout, char uplo, int m, int n, float alpha, float beta, float *a, int lda)
     * }
     */
    public static FunctionDescriptor LAPACKE_slaset_work$descriptor() {
        return LAPACKE_slaset_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_slaset_work(int matrix_layout, char uplo, int m, int n, float alpha, float beta, float *a, int lda)
     * }
     */
    public static MethodHandle LAPACKE_slaset_work$handle() {
        return LAPACKE_slaset_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_slaset_work(int matrix_layout, char uplo, int m, int n, float alpha, float beta, float *a, int lda)
     * }
     */
    public static MemorySegment LAPACKE_slaset_work$address() {
        return LAPACKE_slaset_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_slaset_work(int matrix_layout, char uplo, int m, int n, float alpha, float beta, float *a, int lda)
     * }
     */
    public static int LAPACKE_slaset_work(int matrix_layout, byte uplo, int m, int n, float alpha, float beta, MemorySegment a, int lda) {
        var mh$ = LAPACKE_slaset_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_slaset_work", matrix_layout, uplo, m, n, alpha, beta, a, lda);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, m, n, alpha, beta, a, lda);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dlaset_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_DOUBLE,
            lapacke_h.C_DOUBLE,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dlaset_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dlaset_work(int matrix_layout, char uplo, int m, int n, double alpha, double beta, double *a, int lda)
     * }
     */
    public static FunctionDescriptor LAPACKE_dlaset_work$descriptor() {
        return LAPACKE_dlaset_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dlaset_work(int matrix_layout, char uplo, int m, int n, double alpha, double beta, double *a, int lda)
     * }
     */
    public static MethodHandle LAPACKE_dlaset_work$handle() {
        return LAPACKE_dlaset_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dlaset_work(int matrix_layout, char uplo, int m, int n, double alpha, double beta, double *a, int lda)
     * }
     */
    public static MemorySegment LAPACKE_dlaset_work$address() {
        return LAPACKE_dlaset_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dlaset_work(int matrix_layout, char uplo, int m, int n, double alpha, double beta, double *a, int lda)
     * }
     */
    public static int LAPACKE_dlaset_work(int matrix_layout, byte uplo, int m, int n, double alpha, double beta, MemorySegment a, int lda) {
        var mh$ = LAPACKE_dlaset_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dlaset_work", matrix_layout, uplo, m, n, alpha, beta, a, lda);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, m, n, alpha, beta, a, lda);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_claset_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_FLOAT,
            lapacke_h.C_FLOAT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_claset_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_claset_work(int matrix_layout, char uplo, int m, int n, _Complex float alpha, _Complex float beta, _Complex float *a, int lda)
     * }
     */
    public static FunctionDescriptor LAPACKE_claset_work$descriptor() {
        return LAPACKE_claset_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_claset_work(int matrix_layout, char uplo, int m, int n, _Complex float alpha, _Complex float beta, _Complex float *a, int lda)
     * }
     */
    public static MethodHandle LAPACKE_claset_work$handle() {
        return LAPACKE_claset_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_claset_work(int matrix_layout, char uplo, int m, int n, _Complex float alpha, _Complex float beta, _Complex float *a, int lda)
     * }
     */
    public static MemorySegment LAPACKE_claset_work$address() {
        return LAPACKE_claset_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_claset_work(int matrix_layout, char uplo, int m, int n, _Complex float alpha, _Complex float beta, _Complex float *a, int lda)
     * }
     */
    public static int LAPACKE_claset_work(int matrix_layout, byte uplo, int m, int n, float alpha, float beta, MemorySegment a, int lda) {
        var mh$ = LAPACKE_claset_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_claset_work", matrix_layout, uplo, m, n, alpha, beta, a, lda);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, m, n, alpha, beta, a, lda);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zlaset_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_DOUBLE,
            lapacke_h.C_DOUBLE,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zlaset_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zlaset_work(int matrix_layout, char uplo, int m, int n, _Complex double alpha, _Complex double beta, _Complex double *a, int lda)
     * }
     */
    public static FunctionDescriptor LAPACKE_zlaset_work$descriptor() {
        return LAPACKE_zlaset_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zlaset_work(int matrix_layout, char uplo, int m, int n, _Complex double alpha, _Complex double beta, _Complex double *a, int lda)
     * }
     */
    public static MethodHandle LAPACKE_zlaset_work$handle() {
        return LAPACKE_zlaset_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zlaset_work(int matrix_layout, char uplo, int m, int n, _Complex double alpha, _Complex double beta, _Complex double *a, int lda)
     * }
     */
    public static MemorySegment LAPACKE_zlaset_work$address() {
        return LAPACKE_zlaset_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zlaset_work(int matrix_layout, char uplo, int m, int n, _Complex double alpha, _Complex double beta, _Complex double *a, int lda)
     * }
     */
    public static int LAPACKE_zlaset_work(int matrix_layout, byte uplo, int m, int n, double alpha, double beta, MemorySegment a, int lda) {
        var mh$ = LAPACKE_zlaset_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zlaset_work", matrix_layout, uplo, m, n, alpha, beta, a, lda);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, m, n, alpha, beta, a, lda);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_slasrt_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_slasrt_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_slasrt_work(char id, int n, float *d)
     * }
     */
    public static FunctionDescriptor LAPACKE_slasrt_work$descriptor() {
        return LAPACKE_slasrt_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_slasrt_work(char id, int n, float *d)
     * }
     */
    public static MethodHandle LAPACKE_slasrt_work$handle() {
        return LAPACKE_slasrt_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_slasrt_work(char id, int n, float *d)
     * }
     */
    public static MemorySegment LAPACKE_slasrt_work$address() {
        return LAPACKE_slasrt_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_slasrt_work(char id, int n, float *d)
     * }
     */
    public static int LAPACKE_slasrt_work(byte id, int n, MemorySegment d) {
        var mh$ = LAPACKE_slasrt_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_slasrt_work", id, n, d);
            }
            return (int)mh$.invokeExact(id, n, d);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dlasrt_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dlasrt_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dlasrt_work(char id, int n, double *d)
     * }
     */
    public static FunctionDescriptor LAPACKE_dlasrt_work$descriptor() {
        return LAPACKE_dlasrt_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dlasrt_work(char id, int n, double *d)
     * }
     */
    public static MethodHandle LAPACKE_dlasrt_work$handle() {
        return LAPACKE_dlasrt_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dlasrt_work(char id, int n, double *d)
     * }
     */
    public static MemorySegment LAPACKE_dlasrt_work$address() {
        return LAPACKE_dlasrt_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dlasrt_work(char id, int n, double *d)
     * }
     */
    public static int LAPACKE_dlasrt_work(byte id, int n, MemorySegment d) {
        var mh$ = LAPACKE_dlasrt_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dlasrt_work", id, n, d);
            }
            return (int)mh$.invokeExact(id, n, d);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_slassq_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_slassq_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_slassq_work(int n, float *x, int incx, float *scale, float *sumsq)
     * }
     */
    public static FunctionDescriptor LAPACKE_slassq_work$descriptor() {
        return LAPACKE_slassq_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_slassq_work(int n, float *x, int incx, float *scale, float *sumsq)
     * }
     */
    public static MethodHandle LAPACKE_slassq_work$handle() {
        return LAPACKE_slassq_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_slassq_work(int n, float *x, int incx, float *scale, float *sumsq)
     * }
     */
    public static MemorySegment LAPACKE_slassq_work$address() {
        return LAPACKE_slassq_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_slassq_work(int n, float *x, int incx, float *scale, float *sumsq)
     * }
     */
    public static int LAPACKE_slassq_work(int n, MemorySegment x, int incx, MemorySegment scale, MemorySegment sumsq) {
        var mh$ = LAPACKE_slassq_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_slassq_work", n, x, incx, scale, sumsq);
            }
            return (int)mh$.invokeExact(n, x, incx, scale, sumsq);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dlassq_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dlassq_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dlassq_work(int n, double *x, int incx, double *scale, double *sumsq)
     * }
     */
    public static FunctionDescriptor LAPACKE_dlassq_work$descriptor() {
        return LAPACKE_dlassq_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dlassq_work(int n, double *x, int incx, double *scale, double *sumsq)
     * }
     */
    public static MethodHandle LAPACKE_dlassq_work$handle() {
        return LAPACKE_dlassq_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dlassq_work(int n, double *x, int incx, double *scale, double *sumsq)
     * }
     */
    public static MemorySegment LAPACKE_dlassq_work$address() {
        return LAPACKE_dlassq_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dlassq_work(int n, double *x, int incx, double *scale, double *sumsq)
     * }
     */
    public static int LAPACKE_dlassq_work(int n, MemorySegment x, int incx, MemorySegment scale, MemorySegment sumsq) {
        var mh$ = LAPACKE_dlassq_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dlassq_work", n, x, incx, scale, sumsq);
            }
            return (int)mh$.invokeExact(n, x, incx, scale, sumsq);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_classq_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_classq_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_classq_work(int n, _Complex float *x, int incx, float *scale, float *sumsq)
     * }
     */
    public static FunctionDescriptor LAPACKE_classq_work$descriptor() {
        return LAPACKE_classq_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_classq_work(int n, _Complex float *x, int incx, float *scale, float *sumsq)
     * }
     */
    public static MethodHandle LAPACKE_classq_work$handle() {
        return LAPACKE_classq_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_classq_work(int n, _Complex float *x, int incx, float *scale, float *sumsq)
     * }
     */
    public static MemorySegment LAPACKE_classq_work$address() {
        return LAPACKE_classq_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_classq_work(int n, _Complex float *x, int incx, float *scale, float *sumsq)
     * }
     */
    public static int LAPACKE_classq_work(int n, MemorySegment x, int incx, MemorySegment scale, MemorySegment sumsq) {
        var mh$ = LAPACKE_classq_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_classq_work", n, x, incx, scale, sumsq);
            }
            return (int)mh$.invokeExact(n, x, incx, scale, sumsq);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zlassq_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zlassq_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zlassq_work(int n, _Complex double *x, int incx, double *scale, double *sumsq)
     * }
     */
    public static FunctionDescriptor LAPACKE_zlassq_work$descriptor() {
        return LAPACKE_zlassq_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zlassq_work(int n, _Complex double *x, int incx, double *scale, double *sumsq)
     * }
     */
    public static MethodHandle LAPACKE_zlassq_work$handle() {
        return LAPACKE_zlassq_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zlassq_work(int n, _Complex double *x, int incx, double *scale, double *sumsq)
     * }
     */
    public static MemorySegment LAPACKE_zlassq_work$address() {
        return LAPACKE_zlassq_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zlassq_work(int n, _Complex double *x, int incx, double *scale, double *sumsq)
     * }
     */
    public static int LAPACKE_zlassq_work(int n, MemorySegment x, int incx, MemorySegment scale, MemorySegment sumsq) {
        var mh$ = LAPACKE_zlassq_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zlassq_work", n, x, incx, scale, sumsq);
            }
            return (int)mh$.invokeExact(n, x, incx, scale, sumsq);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_slaswp_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_slaswp_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_slaswp_work(int matrix_layout, int n, float *a, int lda, int k1, int k2, const int *ipiv, int incx)
     * }
     */
    public static FunctionDescriptor LAPACKE_slaswp_work$descriptor() {
        return LAPACKE_slaswp_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_slaswp_work(int matrix_layout, int n, float *a, int lda, int k1, int k2, const int *ipiv, int incx)
     * }
     */
    public static MethodHandle LAPACKE_slaswp_work$handle() {
        return LAPACKE_slaswp_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_slaswp_work(int matrix_layout, int n, float *a, int lda, int k1, int k2, const int *ipiv, int incx)
     * }
     */
    public static MemorySegment LAPACKE_slaswp_work$address() {
        return LAPACKE_slaswp_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_slaswp_work(int matrix_layout, int n, float *a, int lda, int k1, int k2, const int *ipiv, int incx)
     * }
     */
    public static int LAPACKE_slaswp_work(int matrix_layout, int n, MemorySegment a, int lda, int k1, int k2, MemorySegment ipiv, int incx) {
        var mh$ = LAPACKE_slaswp_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_slaswp_work", matrix_layout, n, a, lda, k1, k2, ipiv, incx);
            }
            return (int)mh$.invokeExact(matrix_layout, n, a, lda, k1, k2, ipiv, incx);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dlaswp_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dlaswp_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dlaswp_work(int matrix_layout, int n, double *a, int lda, int k1, int k2, const int *ipiv, int incx)
     * }
     */
    public static FunctionDescriptor LAPACKE_dlaswp_work$descriptor() {
        return LAPACKE_dlaswp_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dlaswp_work(int matrix_layout, int n, double *a, int lda, int k1, int k2, const int *ipiv, int incx)
     * }
     */
    public static MethodHandle LAPACKE_dlaswp_work$handle() {
        return LAPACKE_dlaswp_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dlaswp_work(int matrix_layout, int n, double *a, int lda, int k1, int k2, const int *ipiv, int incx)
     * }
     */
    public static MemorySegment LAPACKE_dlaswp_work$address() {
        return LAPACKE_dlaswp_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dlaswp_work(int matrix_layout, int n, double *a, int lda, int k1, int k2, const int *ipiv, int incx)
     * }
     */
    public static int LAPACKE_dlaswp_work(int matrix_layout, int n, MemorySegment a, int lda, int k1, int k2, MemorySegment ipiv, int incx) {
        var mh$ = LAPACKE_dlaswp_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dlaswp_work", matrix_layout, n, a, lda, k1, k2, ipiv, incx);
            }
            return (int)mh$.invokeExact(matrix_layout, n, a, lda, k1, k2, ipiv, incx);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_claswp_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_claswp_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_claswp_work(int matrix_layout, int n, _Complex float *a, int lda, int k1, int k2, const int *ipiv, int incx)
     * }
     */
    public static FunctionDescriptor LAPACKE_claswp_work$descriptor() {
        return LAPACKE_claswp_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_claswp_work(int matrix_layout, int n, _Complex float *a, int lda, int k1, int k2, const int *ipiv, int incx)
     * }
     */
    public static MethodHandle LAPACKE_claswp_work$handle() {
        return LAPACKE_claswp_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_claswp_work(int matrix_layout, int n, _Complex float *a, int lda, int k1, int k2, const int *ipiv, int incx)
     * }
     */
    public static MemorySegment LAPACKE_claswp_work$address() {
        return LAPACKE_claswp_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_claswp_work(int matrix_layout, int n, _Complex float *a, int lda, int k1, int k2, const int *ipiv, int incx)
     * }
     */
    public static int LAPACKE_claswp_work(int matrix_layout, int n, MemorySegment a, int lda, int k1, int k2, MemorySegment ipiv, int incx) {
        var mh$ = LAPACKE_claswp_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_claswp_work", matrix_layout, n, a, lda, k1, k2, ipiv, incx);
            }
            return (int)mh$.invokeExact(matrix_layout, n, a, lda, k1, k2, ipiv, incx);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zlaswp_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zlaswp_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zlaswp_work(int matrix_layout, int n, _Complex double *a, int lda, int k1, int k2, const int *ipiv, int incx)
     * }
     */
    public static FunctionDescriptor LAPACKE_zlaswp_work$descriptor() {
        return LAPACKE_zlaswp_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zlaswp_work(int matrix_layout, int n, _Complex double *a, int lda, int k1, int k2, const int *ipiv, int incx)
     * }
     */
    public static MethodHandle LAPACKE_zlaswp_work$handle() {
        return LAPACKE_zlaswp_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zlaswp_work(int matrix_layout, int n, _Complex double *a, int lda, int k1, int k2, const int *ipiv, int incx)
     * }
     */
    public static MemorySegment LAPACKE_zlaswp_work$address() {
        return LAPACKE_zlaswp_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zlaswp_work(int matrix_layout, int n, _Complex double *a, int lda, int k1, int k2, const int *ipiv, int incx)
     * }
     */
    public static int LAPACKE_zlaswp_work(int matrix_layout, int n, MemorySegment a, int lda, int k1, int k2, MemorySegment ipiv, int incx) {
        var mh$ = LAPACKE_zlaswp_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zlaswp_work", matrix_layout, n, a, lda, k1, k2, ipiv, incx);
            }
            return (int)mh$.invokeExact(matrix_layout, n, a, lda, k1, k2, ipiv, incx);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_slatms_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_POINTER,
            lapacke_h.C_CHAR,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_FLOAT,
            lapacke_h.C_FLOAT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_slatms_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_slatms_work(int matrix_layout, int m, int n, char dist, int *iseed, char sym, float *d, int mode, float cond, float dmax, int kl, int ku, char pack, float *a, int lda, float *work)
     * }
     */
    public static FunctionDescriptor LAPACKE_slatms_work$descriptor() {
        return LAPACKE_slatms_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_slatms_work(int matrix_layout, int m, int n, char dist, int *iseed, char sym, float *d, int mode, float cond, float dmax, int kl, int ku, char pack, float *a, int lda, float *work)
     * }
     */
    public static MethodHandle LAPACKE_slatms_work$handle() {
        return LAPACKE_slatms_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_slatms_work(int matrix_layout, int m, int n, char dist, int *iseed, char sym, float *d, int mode, float cond, float dmax, int kl, int ku, char pack, float *a, int lda, float *work)
     * }
     */
    public static MemorySegment LAPACKE_slatms_work$address() {
        return LAPACKE_slatms_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_slatms_work(int matrix_layout, int m, int n, char dist, int *iseed, char sym, float *d, int mode, float cond, float dmax, int kl, int ku, char pack, float *a, int lda, float *work)
     * }
     */
    public static int LAPACKE_slatms_work(int matrix_layout, int m, int n, byte dist, MemorySegment iseed, byte sym, MemorySegment d, int mode, float cond, float dmax, int kl, int ku, byte pack, MemorySegment a, int lda, MemorySegment work) {
        var mh$ = LAPACKE_slatms_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_slatms_work", matrix_layout, m, n, dist, iseed, sym, d, mode, cond, dmax, kl, ku, pack, a, lda, work);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, dist, iseed, sym, d, mode, cond, dmax, kl, ku, pack, a, lda, work);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dlatms_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_POINTER,
            lapacke_h.C_CHAR,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_DOUBLE,
            lapacke_h.C_DOUBLE,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dlatms_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dlatms_work(int matrix_layout, int m, int n, char dist, int *iseed, char sym, double *d, int mode, double cond, double dmax, int kl, int ku, char pack, double *a, int lda, double *work)
     * }
     */
    public static FunctionDescriptor LAPACKE_dlatms_work$descriptor() {
        return LAPACKE_dlatms_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dlatms_work(int matrix_layout, int m, int n, char dist, int *iseed, char sym, double *d, int mode, double cond, double dmax, int kl, int ku, char pack, double *a, int lda, double *work)
     * }
     */
    public static MethodHandle LAPACKE_dlatms_work$handle() {
        return LAPACKE_dlatms_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dlatms_work(int matrix_layout, int m, int n, char dist, int *iseed, char sym, double *d, int mode, double cond, double dmax, int kl, int ku, char pack, double *a, int lda, double *work)
     * }
     */
    public static MemorySegment LAPACKE_dlatms_work$address() {
        return LAPACKE_dlatms_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dlatms_work(int matrix_layout, int m, int n, char dist, int *iseed, char sym, double *d, int mode, double cond, double dmax, int kl, int ku, char pack, double *a, int lda, double *work)
     * }
     */
    public static int LAPACKE_dlatms_work(int matrix_layout, int m, int n, byte dist, MemorySegment iseed, byte sym, MemorySegment d, int mode, double cond, double dmax, int kl, int ku, byte pack, MemorySegment a, int lda, MemorySegment work) {
        var mh$ = LAPACKE_dlatms_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dlatms_work", matrix_layout, m, n, dist, iseed, sym, d, mode, cond, dmax, kl, ku, pack, a, lda, work);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, dist, iseed, sym, d, mode, cond, dmax, kl, ku, pack, a, lda, work);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_clatms_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_POINTER,
            lapacke_h.C_CHAR,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_FLOAT,
            lapacke_h.C_FLOAT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_clatms_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_clatms_work(int matrix_layout, int m, int n, char dist, int *iseed, char sym, float *d, int mode, float cond, float dmax, int kl, int ku, char pack, _Complex float *a, int lda, _Complex float *work)
     * }
     */
    public static FunctionDescriptor LAPACKE_clatms_work$descriptor() {
        return LAPACKE_clatms_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_clatms_work(int matrix_layout, int m, int n, char dist, int *iseed, char sym, float *d, int mode, float cond, float dmax, int kl, int ku, char pack, _Complex float *a, int lda, _Complex float *work)
     * }
     */
    public static MethodHandle LAPACKE_clatms_work$handle() {
        return LAPACKE_clatms_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_clatms_work(int matrix_layout, int m, int n, char dist, int *iseed, char sym, float *d, int mode, float cond, float dmax, int kl, int ku, char pack, _Complex float *a, int lda, _Complex float *work)
     * }
     */
    public static MemorySegment LAPACKE_clatms_work$address() {
        return LAPACKE_clatms_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_clatms_work(int matrix_layout, int m, int n, char dist, int *iseed, char sym, float *d, int mode, float cond, float dmax, int kl, int ku, char pack, _Complex float *a, int lda, _Complex float *work)
     * }
     */
    public static int LAPACKE_clatms_work(int matrix_layout, int m, int n, byte dist, MemorySegment iseed, byte sym, MemorySegment d, int mode, float cond, float dmax, int kl, int ku, byte pack, MemorySegment a, int lda, MemorySegment work) {
        var mh$ = LAPACKE_clatms_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_clatms_work", matrix_layout, m, n, dist, iseed, sym, d, mode, cond, dmax, kl, ku, pack, a, lda, work);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, dist, iseed, sym, d, mode, cond, dmax, kl, ku, pack, a, lda, work);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zlatms_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_POINTER,
            lapacke_h.C_CHAR,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_DOUBLE,
            lapacke_h.C_DOUBLE,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zlatms_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zlatms_work(int matrix_layout, int m, int n, char dist, int *iseed, char sym, double *d, int mode, double cond, double dmax, int kl, int ku, char pack, _Complex double *a, int lda, _Complex double *work)
     * }
     */
    public static FunctionDescriptor LAPACKE_zlatms_work$descriptor() {
        return LAPACKE_zlatms_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zlatms_work(int matrix_layout, int m, int n, char dist, int *iseed, char sym, double *d, int mode, double cond, double dmax, int kl, int ku, char pack, _Complex double *a, int lda, _Complex double *work)
     * }
     */
    public static MethodHandle LAPACKE_zlatms_work$handle() {
        return LAPACKE_zlatms_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zlatms_work(int matrix_layout, int m, int n, char dist, int *iseed, char sym, double *d, int mode, double cond, double dmax, int kl, int ku, char pack, _Complex double *a, int lda, _Complex double *work)
     * }
     */
    public static MemorySegment LAPACKE_zlatms_work$address() {
        return LAPACKE_zlatms_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zlatms_work(int matrix_layout, int m, int n, char dist, int *iseed, char sym, double *d, int mode, double cond, double dmax, int kl, int ku, char pack, _Complex double *a, int lda, _Complex double *work)
     * }
     */
    public static int LAPACKE_zlatms_work(int matrix_layout, int m, int n, byte dist, MemorySegment iseed, byte sym, MemorySegment d, int mode, double cond, double dmax, int kl, int ku, byte pack, MemorySegment a, int lda, MemorySegment work) {
        var mh$ = LAPACKE_zlatms_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zlatms_work", matrix_layout, m, n, dist, iseed, sym, d, mode, cond, dmax, kl, ku, pack, a, lda, work);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, dist, iseed, sym, d, mode, cond, dmax, kl, ku, pack, a, lda, work);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_slauum_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_slauum_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_slauum_work(int matrix_layout, char uplo, int n, float *a, int lda)
     * }
     */
    public static FunctionDescriptor LAPACKE_slauum_work$descriptor() {
        return LAPACKE_slauum_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_slauum_work(int matrix_layout, char uplo, int n, float *a, int lda)
     * }
     */
    public static MethodHandle LAPACKE_slauum_work$handle() {
        return LAPACKE_slauum_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_slauum_work(int matrix_layout, char uplo, int n, float *a, int lda)
     * }
     */
    public static MemorySegment LAPACKE_slauum_work$address() {
        return LAPACKE_slauum_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_slauum_work(int matrix_layout, char uplo, int n, float *a, int lda)
     * }
     */
    public static int LAPACKE_slauum_work(int matrix_layout, byte uplo, int n, MemorySegment a, int lda) {
        var mh$ = LAPACKE_slauum_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_slauum_work", matrix_layout, uplo, n, a, lda);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, a, lda);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dlauum_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dlauum_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dlauum_work(int matrix_layout, char uplo, int n, double *a, int lda)
     * }
     */
    public static FunctionDescriptor LAPACKE_dlauum_work$descriptor() {
        return LAPACKE_dlauum_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dlauum_work(int matrix_layout, char uplo, int n, double *a, int lda)
     * }
     */
    public static MethodHandle LAPACKE_dlauum_work$handle() {
        return LAPACKE_dlauum_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dlauum_work(int matrix_layout, char uplo, int n, double *a, int lda)
     * }
     */
    public static MemorySegment LAPACKE_dlauum_work$address() {
        return LAPACKE_dlauum_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dlauum_work(int matrix_layout, char uplo, int n, double *a, int lda)
     * }
     */
    public static int LAPACKE_dlauum_work(int matrix_layout, byte uplo, int n, MemorySegment a, int lda) {
        var mh$ = LAPACKE_dlauum_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dlauum_work", matrix_layout, uplo, n, a, lda);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, a, lda);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_clauum_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_clauum_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_clauum_work(int matrix_layout, char uplo, int n, _Complex float *a, int lda)
     * }
     */
    public static FunctionDescriptor LAPACKE_clauum_work$descriptor() {
        return LAPACKE_clauum_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_clauum_work(int matrix_layout, char uplo, int n, _Complex float *a, int lda)
     * }
     */
    public static MethodHandle LAPACKE_clauum_work$handle() {
        return LAPACKE_clauum_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_clauum_work(int matrix_layout, char uplo, int n, _Complex float *a, int lda)
     * }
     */
    public static MemorySegment LAPACKE_clauum_work$address() {
        return LAPACKE_clauum_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_clauum_work(int matrix_layout, char uplo, int n, _Complex float *a, int lda)
     * }
     */
    public static int LAPACKE_clauum_work(int matrix_layout, byte uplo, int n, MemorySegment a, int lda) {
        var mh$ = LAPACKE_clauum_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_clauum_work", matrix_layout, uplo, n, a, lda);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, a, lda);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zlauum_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zlauum_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zlauum_work(int matrix_layout, char uplo, int n, _Complex double *a, int lda)
     * }
     */
    public static FunctionDescriptor LAPACKE_zlauum_work$descriptor() {
        return LAPACKE_zlauum_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zlauum_work(int matrix_layout, char uplo, int n, _Complex double *a, int lda)
     * }
     */
    public static MethodHandle LAPACKE_zlauum_work$handle() {
        return LAPACKE_zlauum_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zlauum_work(int matrix_layout, char uplo, int n, _Complex double *a, int lda)
     * }
     */
    public static MemorySegment LAPACKE_zlauum_work$address() {
        return LAPACKE_zlauum_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zlauum_work(int matrix_layout, char uplo, int n, _Complex double *a, int lda)
     * }
     */
    public static int LAPACKE_zlauum_work(int matrix_layout, byte uplo, int n, MemorySegment a, int lda) {
        var mh$ = LAPACKE_zlauum_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zlauum_work", matrix_layout, uplo, n, a, lda);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, a, lda);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sopgtr_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_sopgtr_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sopgtr_work(int matrix_layout, char uplo, int n, const float *ap, const float *tau, float *q, int ldq, float *work)
     * }
     */
    public static FunctionDescriptor LAPACKE_sopgtr_work$descriptor() {
        return LAPACKE_sopgtr_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sopgtr_work(int matrix_layout, char uplo, int n, const float *ap, const float *tau, float *q, int ldq, float *work)
     * }
     */
    public static MethodHandle LAPACKE_sopgtr_work$handle() {
        return LAPACKE_sopgtr_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sopgtr_work(int matrix_layout, char uplo, int n, const float *ap, const float *tau, float *q, int ldq, float *work)
     * }
     */
    public static MemorySegment LAPACKE_sopgtr_work$address() {
        return LAPACKE_sopgtr_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sopgtr_work(int matrix_layout, char uplo, int n, const float *ap, const float *tau, float *q, int ldq, float *work)
     * }
     */
    public static int LAPACKE_sopgtr_work(int matrix_layout, byte uplo, int n, MemorySegment ap, MemorySegment tau, MemorySegment q, int ldq, MemorySegment work) {
        var mh$ = LAPACKE_sopgtr_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sopgtr_work", matrix_layout, uplo, n, ap, tau, q, ldq, work);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, ap, tau, q, ldq, work);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dopgtr_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dopgtr_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dopgtr_work(int matrix_layout, char uplo, int n, const double *ap, const double *tau, double *q, int ldq, double *work)
     * }
     */
    public static FunctionDescriptor LAPACKE_dopgtr_work$descriptor() {
        return LAPACKE_dopgtr_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dopgtr_work(int matrix_layout, char uplo, int n, const double *ap, const double *tau, double *q, int ldq, double *work)
     * }
     */
    public static MethodHandle LAPACKE_dopgtr_work$handle() {
        return LAPACKE_dopgtr_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dopgtr_work(int matrix_layout, char uplo, int n, const double *ap, const double *tau, double *q, int ldq, double *work)
     * }
     */
    public static MemorySegment LAPACKE_dopgtr_work$address() {
        return LAPACKE_dopgtr_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dopgtr_work(int matrix_layout, char uplo, int n, const double *ap, const double *tau, double *q, int ldq, double *work)
     * }
     */
    public static int LAPACKE_dopgtr_work(int matrix_layout, byte uplo, int n, MemorySegment ap, MemorySegment tau, MemorySegment q, int ldq, MemorySegment work) {
        var mh$ = LAPACKE_dopgtr_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dopgtr_work", matrix_layout, uplo, n, ap, tau, q, ldq, work);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, ap, tau, q, ldq, work);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sopmtr_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_sopmtr_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sopmtr_work(int matrix_layout, char side, char uplo, char trans, int m, int n, const float *ap, const float *tau, float *c, int ldc, float *work)
     * }
     */
    public static FunctionDescriptor LAPACKE_sopmtr_work$descriptor() {
        return LAPACKE_sopmtr_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sopmtr_work(int matrix_layout, char side, char uplo, char trans, int m, int n, const float *ap, const float *tau, float *c, int ldc, float *work)
     * }
     */
    public static MethodHandle LAPACKE_sopmtr_work$handle() {
        return LAPACKE_sopmtr_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sopmtr_work(int matrix_layout, char side, char uplo, char trans, int m, int n, const float *ap, const float *tau, float *c, int ldc, float *work)
     * }
     */
    public static MemorySegment LAPACKE_sopmtr_work$address() {
        return LAPACKE_sopmtr_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sopmtr_work(int matrix_layout, char side, char uplo, char trans, int m, int n, const float *ap, const float *tau, float *c, int ldc, float *work)
     * }
     */
    public static int LAPACKE_sopmtr_work(int matrix_layout, byte side, byte uplo, byte trans, int m, int n, MemorySegment ap, MemorySegment tau, MemorySegment c, int ldc, MemorySegment work) {
        var mh$ = LAPACKE_sopmtr_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sopmtr_work", matrix_layout, side, uplo, trans, m, n, ap, tau, c, ldc, work);
            }
            return (int)mh$.invokeExact(matrix_layout, side, uplo, trans, m, n, ap, tau, c, ldc, work);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dopmtr_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dopmtr_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dopmtr_work(int matrix_layout, char side, char uplo, char trans, int m, int n, const double *ap, const double *tau, double *c, int ldc, double *work)
     * }
     */
    public static FunctionDescriptor LAPACKE_dopmtr_work$descriptor() {
        return LAPACKE_dopmtr_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dopmtr_work(int matrix_layout, char side, char uplo, char trans, int m, int n, const double *ap, const double *tau, double *c, int ldc, double *work)
     * }
     */
    public static MethodHandle LAPACKE_dopmtr_work$handle() {
        return LAPACKE_dopmtr_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dopmtr_work(int matrix_layout, char side, char uplo, char trans, int m, int n, const double *ap, const double *tau, double *c, int ldc, double *work)
     * }
     */
    public static MemorySegment LAPACKE_dopmtr_work$address() {
        return LAPACKE_dopmtr_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dopmtr_work(int matrix_layout, char side, char uplo, char trans, int m, int n, const double *ap, const double *tau, double *c, int ldc, double *work)
     * }
     */
    public static int LAPACKE_dopmtr_work(int matrix_layout, byte side, byte uplo, byte trans, int m, int n, MemorySegment ap, MemorySegment tau, MemorySegment c, int ldc, MemorySegment work) {
        var mh$ = LAPACKE_dopmtr_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dopmtr_work", matrix_layout, side, uplo, trans, m, n, ap, tau, c, ldc, work);
            }
            return (int)mh$.invokeExact(matrix_layout, side, uplo, trans, m, n, ap, tau, c, ldc, work);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sorgbr_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_sorgbr_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sorgbr_work(int matrix_layout, char vect, int m, int n, int k, float *a, int lda, const float *tau, float *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_sorgbr_work$descriptor() {
        return LAPACKE_sorgbr_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sorgbr_work(int matrix_layout, char vect, int m, int n, int k, float *a, int lda, const float *tau, float *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_sorgbr_work$handle() {
        return LAPACKE_sorgbr_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sorgbr_work(int matrix_layout, char vect, int m, int n, int k, float *a, int lda, const float *tau, float *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_sorgbr_work$address() {
        return LAPACKE_sorgbr_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sorgbr_work(int matrix_layout, char vect, int m, int n, int k, float *a, int lda, const float *tau, float *work, int lwork)
     * }
     */
    public static int LAPACKE_sorgbr_work(int matrix_layout, byte vect, int m, int n, int k, MemorySegment a, int lda, MemorySegment tau, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_sorgbr_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sorgbr_work", matrix_layout, vect, m, n, k, a, lda, tau, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, vect, m, n, k, a, lda, tau, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dorgbr_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dorgbr_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dorgbr_work(int matrix_layout, char vect, int m, int n, int k, double *a, int lda, const double *tau, double *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_dorgbr_work$descriptor() {
        return LAPACKE_dorgbr_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dorgbr_work(int matrix_layout, char vect, int m, int n, int k, double *a, int lda, const double *tau, double *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_dorgbr_work$handle() {
        return LAPACKE_dorgbr_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dorgbr_work(int matrix_layout, char vect, int m, int n, int k, double *a, int lda, const double *tau, double *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_dorgbr_work$address() {
        return LAPACKE_dorgbr_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dorgbr_work(int matrix_layout, char vect, int m, int n, int k, double *a, int lda, const double *tau, double *work, int lwork)
     * }
     */
    public static int LAPACKE_dorgbr_work(int matrix_layout, byte vect, int m, int n, int k, MemorySegment a, int lda, MemorySegment tau, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_dorgbr_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dorgbr_work", matrix_layout, vect, m, n, k, a, lda, tau, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, vect, m, n, k, a, lda, tau, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sorghr_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_sorghr_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sorghr_work(int matrix_layout, int n, int ilo, int ihi, float *a, int lda, const float *tau, float *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_sorghr_work$descriptor() {
        return LAPACKE_sorghr_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sorghr_work(int matrix_layout, int n, int ilo, int ihi, float *a, int lda, const float *tau, float *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_sorghr_work$handle() {
        return LAPACKE_sorghr_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sorghr_work(int matrix_layout, int n, int ilo, int ihi, float *a, int lda, const float *tau, float *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_sorghr_work$address() {
        return LAPACKE_sorghr_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sorghr_work(int matrix_layout, int n, int ilo, int ihi, float *a, int lda, const float *tau, float *work, int lwork)
     * }
     */
    public static int LAPACKE_sorghr_work(int matrix_layout, int n, int ilo, int ihi, MemorySegment a, int lda, MemorySegment tau, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_sorghr_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sorghr_work", matrix_layout, n, ilo, ihi, a, lda, tau, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, n, ilo, ihi, a, lda, tau, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dorghr_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dorghr_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dorghr_work(int matrix_layout, int n, int ilo, int ihi, double *a, int lda, const double *tau, double *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_dorghr_work$descriptor() {
        return LAPACKE_dorghr_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dorghr_work(int matrix_layout, int n, int ilo, int ihi, double *a, int lda, const double *tau, double *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_dorghr_work$handle() {
        return LAPACKE_dorghr_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dorghr_work(int matrix_layout, int n, int ilo, int ihi, double *a, int lda, const double *tau, double *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_dorghr_work$address() {
        return LAPACKE_dorghr_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dorghr_work(int matrix_layout, int n, int ilo, int ihi, double *a, int lda, const double *tau, double *work, int lwork)
     * }
     */
    public static int LAPACKE_dorghr_work(int matrix_layout, int n, int ilo, int ihi, MemorySegment a, int lda, MemorySegment tau, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_dorghr_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dorghr_work", matrix_layout, n, ilo, ihi, a, lda, tau, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, n, ilo, ihi, a, lda, tau, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sorglq_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_sorglq_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sorglq_work(int matrix_layout, int m, int n, int k, float *a, int lda, const float *tau, float *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_sorglq_work$descriptor() {
        return LAPACKE_sorglq_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sorglq_work(int matrix_layout, int m, int n, int k, float *a, int lda, const float *tau, float *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_sorglq_work$handle() {
        return LAPACKE_sorglq_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sorglq_work(int matrix_layout, int m, int n, int k, float *a, int lda, const float *tau, float *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_sorglq_work$address() {
        return LAPACKE_sorglq_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sorglq_work(int matrix_layout, int m, int n, int k, float *a, int lda, const float *tau, float *work, int lwork)
     * }
     */
    public static int LAPACKE_sorglq_work(int matrix_layout, int m, int n, int k, MemorySegment a, int lda, MemorySegment tau, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_sorglq_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sorglq_work", matrix_layout, m, n, k, a, lda, tau, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, k, a, lda, tau, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dorglq_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dorglq_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dorglq_work(int matrix_layout, int m, int n, int k, double *a, int lda, const double *tau, double *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_dorglq_work$descriptor() {
        return LAPACKE_dorglq_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dorglq_work(int matrix_layout, int m, int n, int k, double *a, int lda, const double *tau, double *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_dorglq_work$handle() {
        return LAPACKE_dorglq_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dorglq_work(int matrix_layout, int m, int n, int k, double *a, int lda, const double *tau, double *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_dorglq_work$address() {
        return LAPACKE_dorglq_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dorglq_work(int matrix_layout, int m, int n, int k, double *a, int lda, const double *tau, double *work, int lwork)
     * }
     */
    public static int LAPACKE_dorglq_work(int matrix_layout, int m, int n, int k, MemorySegment a, int lda, MemorySegment tau, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_dorglq_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dorglq_work", matrix_layout, m, n, k, a, lda, tau, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, k, a, lda, tau, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sorgql_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_sorgql_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sorgql_work(int matrix_layout, int m, int n, int k, float *a, int lda, const float *tau, float *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_sorgql_work$descriptor() {
        return LAPACKE_sorgql_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sorgql_work(int matrix_layout, int m, int n, int k, float *a, int lda, const float *tau, float *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_sorgql_work$handle() {
        return LAPACKE_sorgql_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sorgql_work(int matrix_layout, int m, int n, int k, float *a, int lda, const float *tau, float *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_sorgql_work$address() {
        return LAPACKE_sorgql_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sorgql_work(int matrix_layout, int m, int n, int k, float *a, int lda, const float *tau, float *work, int lwork)
     * }
     */
    public static int LAPACKE_sorgql_work(int matrix_layout, int m, int n, int k, MemorySegment a, int lda, MemorySegment tau, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_sorgql_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sorgql_work", matrix_layout, m, n, k, a, lda, tau, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, k, a, lda, tau, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dorgql_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dorgql_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dorgql_work(int matrix_layout, int m, int n, int k, double *a, int lda, const double *tau, double *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_dorgql_work$descriptor() {
        return LAPACKE_dorgql_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dorgql_work(int matrix_layout, int m, int n, int k, double *a, int lda, const double *tau, double *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_dorgql_work$handle() {
        return LAPACKE_dorgql_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dorgql_work(int matrix_layout, int m, int n, int k, double *a, int lda, const double *tau, double *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_dorgql_work$address() {
        return LAPACKE_dorgql_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dorgql_work(int matrix_layout, int m, int n, int k, double *a, int lda, const double *tau, double *work, int lwork)
     * }
     */
    public static int LAPACKE_dorgql_work(int matrix_layout, int m, int n, int k, MemorySegment a, int lda, MemorySegment tau, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_dorgql_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dorgql_work", matrix_layout, m, n, k, a, lda, tau, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, k, a, lda, tau, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sorgqr_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_sorgqr_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sorgqr_work(int matrix_layout, int m, int n, int k, float *a, int lda, const float *tau, float *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_sorgqr_work$descriptor() {
        return LAPACKE_sorgqr_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sorgqr_work(int matrix_layout, int m, int n, int k, float *a, int lda, const float *tau, float *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_sorgqr_work$handle() {
        return LAPACKE_sorgqr_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sorgqr_work(int matrix_layout, int m, int n, int k, float *a, int lda, const float *tau, float *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_sorgqr_work$address() {
        return LAPACKE_sorgqr_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sorgqr_work(int matrix_layout, int m, int n, int k, float *a, int lda, const float *tau, float *work, int lwork)
     * }
     */
    public static int LAPACKE_sorgqr_work(int matrix_layout, int m, int n, int k, MemorySegment a, int lda, MemorySegment tau, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_sorgqr_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sorgqr_work", matrix_layout, m, n, k, a, lda, tau, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, k, a, lda, tau, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dorgqr_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dorgqr_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dorgqr_work(int matrix_layout, int m, int n, int k, double *a, int lda, const double *tau, double *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_dorgqr_work$descriptor() {
        return LAPACKE_dorgqr_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dorgqr_work(int matrix_layout, int m, int n, int k, double *a, int lda, const double *tau, double *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_dorgqr_work$handle() {
        return LAPACKE_dorgqr_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dorgqr_work(int matrix_layout, int m, int n, int k, double *a, int lda, const double *tau, double *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_dorgqr_work$address() {
        return LAPACKE_dorgqr_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dorgqr_work(int matrix_layout, int m, int n, int k, double *a, int lda, const double *tau, double *work, int lwork)
     * }
     */
    public static int LAPACKE_dorgqr_work(int matrix_layout, int m, int n, int k, MemorySegment a, int lda, MemorySegment tau, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_dorgqr_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dorgqr_work", matrix_layout, m, n, k, a, lda, tau, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, k, a, lda, tau, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sorgrq_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_sorgrq_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sorgrq_work(int matrix_layout, int m, int n, int k, float *a, int lda, const float *tau, float *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_sorgrq_work$descriptor() {
        return LAPACKE_sorgrq_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sorgrq_work(int matrix_layout, int m, int n, int k, float *a, int lda, const float *tau, float *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_sorgrq_work$handle() {
        return LAPACKE_sorgrq_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sorgrq_work(int matrix_layout, int m, int n, int k, float *a, int lda, const float *tau, float *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_sorgrq_work$address() {
        return LAPACKE_sorgrq_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sorgrq_work(int matrix_layout, int m, int n, int k, float *a, int lda, const float *tau, float *work, int lwork)
     * }
     */
    public static int LAPACKE_sorgrq_work(int matrix_layout, int m, int n, int k, MemorySegment a, int lda, MemorySegment tau, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_sorgrq_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sorgrq_work", matrix_layout, m, n, k, a, lda, tau, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, k, a, lda, tau, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dorgrq_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dorgrq_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dorgrq_work(int matrix_layout, int m, int n, int k, double *a, int lda, const double *tau, double *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_dorgrq_work$descriptor() {
        return LAPACKE_dorgrq_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dorgrq_work(int matrix_layout, int m, int n, int k, double *a, int lda, const double *tau, double *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_dorgrq_work$handle() {
        return LAPACKE_dorgrq_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dorgrq_work(int matrix_layout, int m, int n, int k, double *a, int lda, const double *tau, double *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_dorgrq_work$address() {
        return LAPACKE_dorgrq_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dorgrq_work(int matrix_layout, int m, int n, int k, double *a, int lda, const double *tau, double *work, int lwork)
     * }
     */
    public static int LAPACKE_dorgrq_work(int matrix_layout, int m, int n, int k, MemorySegment a, int lda, MemorySegment tau, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_dorgrq_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dorgrq_work", matrix_layout, m, n, k, a, lda, tau, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, k, a, lda, tau, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sorgtr_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_sorgtr_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sorgtr_work(int matrix_layout, char uplo, int n, float *a, int lda, const float *tau, float *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_sorgtr_work$descriptor() {
        return LAPACKE_sorgtr_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sorgtr_work(int matrix_layout, char uplo, int n, float *a, int lda, const float *tau, float *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_sorgtr_work$handle() {
        return LAPACKE_sorgtr_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sorgtr_work(int matrix_layout, char uplo, int n, float *a, int lda, const float *tau, float *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_sorgtr_work$address() {
        return LAPACKE_sorgtr_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sorgtr_work(int matrix_layout, char uplo, int n, float *a, int lda, const float *tau, float *work, int lwork)
     * }
     */
    public static int LAPACKE_sorgtr_work(int matrix_layout, byte uplo, int n, MemorySegment a, int lda, MemorySegment tau, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_sorgtr_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sorgtr_work", matrix_layout, uplo, n, a, lda, tau, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, a, lda, tau, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dorgtr_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dorgtr_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dorgtr_work(int matrix_layout, char uplo, int n, double *a, int lda, const double *tau, double *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_dorgtr_work$descriptor() {
        return LAPACKE_dorgtr_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dorgtr_work(int matrix_layout, char uplo, int n, double *a, int lda, const double *tau, double *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_dorgtr_work$handle() {
        return LAPACKE_dorgtr_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dorgtr_work(int matrix_layout, char uplo, int n, double *a, int lda, const double *tau, double *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_dorgtr_work$address() {
        return LAPACKE_dorgtr_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dorgtr_work(int matrix_layout, char uplo, int n, double *a, int lda, const double *tau, double *work, int lwork)
     * }
     */
    public static int LAPACKE_dorgtr_work(int matrix_layout, byte uplo, int n, MemorySegment a, int lda, MemorySegment tau, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_dorgtr_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dorgtr_work", matrix_layout, uplo, n, a, lda, tau, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, a, lda, tau, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sorgtsqr_row_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_sorgtsqr_row_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sorgtsqr_row_work(int matrix_layout, int m, int n, int mb, int nb, float *a, int lda, const float *t, int ldt, float *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_sorgtsqr_row_work$descriptor() {
        return LAPACKE_sorgtsqr_row_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sorgtsqr_row_work(int matrix_layout, int m, int n, int mb, int nb, float *a, int lda, const float *t, int ldt, float *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_sorgtsqr_row_work$handle() {
        return LAPACKE_sorgtsqr_row_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sorgtsqr_row_work(int matrix_layout, int m, int n, int mb, int nb, float *a, int lda, const float *t, int ldt, float *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_sorgtsqr_row_work$address() {
        return LAPACKE_sorgtsqr_row_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sorgtsqr_row_work(int matrix_layout, int m, int n, int mb, int nb, float *a, int lda, const float *t, int ldt, float *work, int lwork)
     * }
     */
    public static int LAPACKE_sorgtsqr_row_work(int matrix_layout, int m, int n, int mb, int nb, MemorySegment a, int lda, MemorySegment t, int ldt, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_sorgtsqr_row_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sorgtsqr_row_work", matrix_layout, m, n, mb, nb, a, lda, t, ldt, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, mb, nb, a, lda, t, ldt, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dorgtsqr_row_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dorgtsqr_row_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dorgtsqr_row_work(int matrix_layout, int m, int n, int mb, int nb, double *a, int lda, const double *t, int ldt, double *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_dorgtsqr_row_work$descriptor() {
        return LAPACKE_dorgtsqr_row_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dorgtsqr_row_work(int matrix_layout, int m, int n, int mb, int nb, double *a, int lda, const double *t, int ldt, double *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_dorgtsqr_row_work$handle() {
        return LAPACKE_dorgtsqr_row_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dorgtsqr_row_work(int matrix_layout, int m, int n, int mb, int nb, double *a, int lda, const double *t, int ldt, double *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_dorgtsqr_row_work$address() {
        return LAPACKE_dorgtsqr_row_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dorgtsqr_row_work(int matrix_layout, int m, int n, int mb, int nb, double *a, int lda, const double *t, int ldt, double *work, int lwork)
     * }
     */
    public static int LAPACKE_dorgtsqr_row_work(int matrix_layout, int m, int n, int mb, int nb, MemorySegment a, int lda, MemorySegment t, int ldt, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_dorgtsqr_row_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dorgtsqr_row_work", matrix_layout, m, n, mb, nb, a, lda, t, ldt, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, mb, nb, a, lda, t, ldt, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sormbr_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_sormbr_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sormbr_work(int matrix_layout, char vect, char side, char trans, int m, int n, int k, const float *a, int lda, const float *tau, float *c, int ldc, float *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_sormbr_work$descriptor() {
        return LAPACKE_sormbr_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sormbr_work(int matrix_layout, char vect, char side, char trans, int m, int n, int k, const float *a, int lda, const float *tau, float *c, int ldc, float *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_sormbr_work$handle() {
        return LAPACKE_sormbr_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sormbr_work(int matrix_layout, char vect, char side, char trans, int m, int n, int k, const float *a, int lda, const float *tau, float *c, int ldc, float *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_sormbr_work$address() {
        return LAPACKE_sormbr_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sormbr_work(int matrix_layout, char vect, char side, char trans, int m, int n, int k, const float *a, int lda, const float *tau, float *c, int ldc, float *work, int lwork)
     * }
     */
    public static int LAPACKE_sormbr_work(int matrix_layout, byte vect, byte side, byte trans, int m, int n, int k, MemorySegment a, int lda, MemorySegment tau, MemorySegment c, int ldc, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_sormbr_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sormbr_work", matrix_layout, vect, side, trans, m, n, k, a, lda, tau, c, ldc, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, vect, side, trans, m, n, k, a, lda, tau, c, ldc, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dormbr_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dormbr_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dormbr_work(int matrix_layout, char vect, char side, char trans, int m, int n, int k, const double *a, int lda, const double *tau, double *c, int ldc, double *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_dormbr_work$descriptor() {
        return LAPACKE_dormbr_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dormbr_work(int matrix_layout, char vect, char side, char trans, int m, int n, int k, const double *a, int lda, const double *tau, double *c, int ldc, double *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_dormbr_work$handle() {
        return LAPACKE_dormbr_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dormbr_work(int matrix_layout, char vect, char side, char trans, int m, int n, int k, const double *a, int lda, const double *tau, double *c, int ldc, double *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_dormbr_work$address() {
        return LAPACKE_dormbr_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dormbr_work(int matrix_layout, char vect, char side, char trans, int m, int n, int k, const double *a, int lda, const double *tau, double *c, int ldc, double *work, int lwork)
     * }
     */
    public static int LAPACKE_dormbr_work(int matrix_layout, byte vect, byte side, byte trans, int m, int n, int k, MemorySegment a, int lda, MemorySegment tau, MemorySegment c, int ldc, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_dormbr_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dormbr_work", matrix_layout, vect, side, trans, m, n, k, a, lda, tau, c, ldc, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, vect, side, trans, m, n, k, a, lda, tau, c, ldc, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sormhr_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_sormhr_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sormhr_work(int matrix_layout, char side, char trans, int m, int n, int ilo, int ihi, const float *a, int lda, const float *tau, float *c, int ldc, float *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_sormhr_work$descriptor() {
        return LAPACKE_sormhr_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sormhr_work(int matrix_layout, char side, char trans, int m, int n, int ilo, int ihi, const float *a, int lda, const float *tau, float *c, int ldc, float *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_sormhr_work$handle() {
        return LAPACKE_sormhr_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sormhr_work(int matrix_layout, char side, char trans, int m, int n, int ilo, int ihi, const float *a, int lda, const float *tau, float *c, int ldc, float *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_sormhr_work$address() {
        return LAPACKE_sormhr_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sormhr_work(int matrix_layout, char side, char trans, int m, int n, int ilo, int ihi, const float *a, int lda, const float *tau, float *c, int ldc, float *work, int lwork)
     * }
     */
    public static int LAPACKE_sormhr_work(int matrix_layout, byte side, byte trans, int m, int n, int ilo, int ihi, MemorySegment a, int lda, MemorySegment tau, MemorySegment c, int ldc, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_sormhr_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sormhr_work", matrix_layout, side, trans, m, n, ilo, ihi, a, lda, tau, c, ldc, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, side, trans, m, n, ilo, ihi, a, lda, tau, c, ldc, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dormhr_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dormhr_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dormhr_work(int matrix_layout, char side, char trans, int m, int n, int ilo, int ihi, const double *a, int lda, const double *tau, double *c, int ldc, double *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_dormhr_work$descriptor() {
        return LAPACKE_dormhr_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dormhr_work(int matrix_layout, char side, char trans, int m, int n, int ilo, int ihi, const double *a, int lda, const double *tau, double *c, int ldc, double *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_dormhr_work$handle() {
        return LAPACKE_dormhr_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dormhr_work(int matrix_layout, char side, char trans, int m, int n, int ilo, int ihi, const double *a, int lda, const double *tau, double *c, int ldc, double *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_dormhr_work$address() {
        return LAPACKE_dormhr_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dormhr_work(int matrix_layout, char side, char trans, int m, int n, int ilo, int ihi, const double *a, int lda, const double *tau, double *c, int ldc, double *work, int lwork)
     * }
     */
    public static int LAPACKE_dormhr_work(int matrix_layout, byte side, byte trans, int m, int n, int ilo, int ihi, MemorySegment a, int lda, MemorySegment tau, MemorySegment c, int ldc, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_dormhr_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dormhr_work", matrix_layout, side, trans, m, n, ilo, ihi, a, lda, tau, c, ldc, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, side, trans, m, n, ilo, ihi, a, lda, tau, c, ldc, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sormlq_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_sormlq_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sormlq_work(int matrix_layout, char side, char trans, int m, int n, int k, const float *a, int lda, const float *tau, float *c, int ldc, float *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_sormlq_work$descriptor() {
        return LAPACKE_sormlq_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sormlq_work(int matrix_layout, char side, char trans, int m, int n, int k, const float *a, int lda, const float *tau, float *c, int ldc, float *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_sormlq_work$handle() {
        return LAPACKE_sormlq_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sormlq_work(int matrix_layout, char side, char trans, int m, int n, int k, const float *a, int lda, const float *tau, float *c, int ldc, float *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_sormlq_work$address() {
        return LAPACKE_sormlq_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sormlq_work(int matrix_layout, char side, char trans, int m, int n, int k, const float *a, int lda, const float *tau, float *c, int ldc, float *work, int lwork)
     * }
     */
    public static int LAPACKE_sormlq_work(int matrix_layout, byte side, byte trans, int m, int n, int k, MemorySegment a, int lda, MemorySegment tau, MemorySegment c, int ldc, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_sormlq_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sormlq_work", matrix_layout, side, trans, m, n, k, a, lda, tau, c, ldc, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, side, trans, m, n, k, a, lda, tau, c, ldc, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dormlq_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dormlq_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dormlq_work(int matrix_layout, char side, char trans, int m, int n, int k, const double *a, int lda, const double *tau, double *c, int ldc, double *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_dormlq_work$descriptor() {
        return LAPACKE_dormlq_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dormlq_work(int matrix_layout, char side, char trans, int m, int n, int k, const double *a, int lda, const double *tau, double *c, int ldc, double *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_dormlq_work$handle() {
        return LAPACKE_dormlq_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dormlq_work(int matrix_layout, char side, char trans, int m, int n, int k, const double *a, int lda, const double *tau, double *c, int ldc, double *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_dormlq_work$address() {
        return LAPACKE_dormlq_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dormlq_work(int matrix_layout, char side, char trans, int m, int n, int k, const double *a, int lda, const double *tau, double *c, int ldc, double *work, int lwork)
     * }
     */
    public static int LAPACKE_dormlq_work(int matrix_layout, byte side, byte trans, int m, int n, int k, MemorySegment a, int lda, MemorySegment tau, MemorySegment c, int ldc, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_dormlq_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dormlq_work", matrix_layout, side, trans, m, n, k, a, lda, tau, c, ldc, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, side, trans, m, n, k, a, lda, tau, c, ldc, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sormql_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_sormql_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sormql_work(int matrix_layout, char side, char trans, int m, int n, int k, const float *a, int lda, const float *tau, float *c, int ldc, float *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_sormql_work$descriptor() {
        return LAPACKE_sormql_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sormql_work(int matrix_layout, char side, char trans, int m, int n, int k, const float *a, int lda, const float *tau, float *c, int ldc, float *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_sormql_work$handle() {
        return LAPACKE_sormql_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sormql_work(int matrix_layout, char side, char trans, int m, int n, int k, const float *a, int lda, const float *tau, float *c, int ldc, float *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_sormql_work$address() {
        return LAPACKE_sormql_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sormql_work(int matrix_layout, char side, char trans, int m, int n, int k, const float *a, int lda, const float *tau, float *c, int ldc, float *work, int lwork)
     * }
     */
    public static int LAPACKE_sormql_work(int matrix_layout, byte side, byte trans, int m, int n, int k, MemorySegment a, int lda, MemorySegment tau, MemorySegment c, int ldc, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_sormql_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sormql_work", matrix_layout, side, trans, m, n, k, a, lda, tau, c, ldc, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, side, trans, m, n, k, a, lda, tau, c, ldc, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dormql_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dormql_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dormql_work(int matrix_layout, char side, char trans, int m, int n, int k, const double *a, int lda, const double *tau, double *c, int ldc, double *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_dormql_work$descriptor() {
        return LAPACKE_dormql_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dormql_work(int matrix_layout, char side, char trans, int m, int n, int k, const double *a, int lda, const double *tau, double *c, int ldc, double *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_dormql_work$handle() {
        return LAPACKE_dormql_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dormql_work(int matrix_layout, char side, char trans, int m, int n, int k, const double *a, int lda, const double *tau, double *c, int ldc, double *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_dormql_work$address() {
        return LAPACKE_dormql_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dormql_work(int matrix_layout, char side, char trans, int m, int n, int k, const double *a, int lda, const double *tau, double *c, int ldc, double *work, int lwork)
     * }
     */
    public static int LAPACKE_dormql_work(int matrix_layout, byte side, byte trans, int m, int n, int k, MemorySegment a, int lda, MemorySegment tau, MemorySegment c, int ldc, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_dormql_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dormql_work", matrix_layout, side, trans, m, n, k, a, lda, tau, c, ldc, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, side, trans, m, n, k, a, lda, tau, c, ldc, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sormqr_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_sormqr_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sormqr_work(int matrix_layout, char side, char trans, int m, int n, int k, const float *a, int lda, const float *tau, float *c, int ldc, float *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_sormqr_work$descriptor() {
        return LAPACKE_sormqr_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sormqr_work(int matrix_layout, char side, char trans, int m, int n, int k, const float *a, int lda, const float *tau, float *c, int ldc, float *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_sormqr_work$handle() {
        return LAPACKE_sormqr_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sormqr_work(int matrix_layout, char side, char trans, int m, int n, int k, const float *a, int lda, const float *tau, float *c, int ldc, float *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_sormqr_work$address() {
        return LAPACKE_sormqr_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sormqr_work(int matrix_layout, char side, char trans, int m, int n, int k, const float *a, int lda, const float *tau, float *c, int ldc, float *work, int lwork)
     * }
     */
    public static int LAPACKE_sormqr_work(int matrix_layout, byte side, byte trans, int m, int n, int k, MemorySegment a, int lda, MemorySegment tau, MemorySegment c, int ldc, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_sormqr_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sormqr_work", matrix_layout, side, trans, m, n, k, a, lda, tau, c, ldc, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, side, trans, m, n, k, a, lda, tau, c, ldc, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dormqr_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dormqr_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dormqr_work(int matrix_layout, char side, char trans, int m, int n, int k, const double *a, int lda, const double *tau, double *c, int ldc, double *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_dormqr_work$descriptor() {
        return LAPACKE_dormqr_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dormqr_work(int matrix_layout, char side, char trans, int m, int n, int k, const double *a, int lda, const double *tau, double *c, int ldc, double *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_dormqr_work$handle() {
        return LAPACKE_dormqr_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dormqr_work(int matrix_layout, char side, char trans, int m, int n, int k, const double *a, int lda, const double *tau, double *c, int ldc, double *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_dormqr_work$address() {
        return LAPACKE_dormqr_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dormqr_work(int matrix_layout, char side, char trans, int m, int n, int k, const double *a, int lda, const double *tau, double *c, int ldc, double *work, int lwork)
     * }
     */
    public static int LAPACKE_dormqr_work(int matrix_layout, byte side, byte trans, int m, int n, int k, MemorySegment a, int lda, MemorySegment tau, MemorySegment c, int ldc, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_dormqr_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dormqr_work", matrix_layout, side, trans, m, n, k, a, lda, tau, c, ldc, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, side, trans, m, n, k, a, lda, tau, c, ldc, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sormrq_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_sormrq_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sormrq_work(int matrix_layout, char side, char trans, int m, int n, int k, const float *a, int lda, const float *tau, float *c, int ldc, float *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_sormrq_work$descriptor() {
        return LAPACKE_sormrq_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sormrq_work(int matrix_layout, char side, char trans, int m, int n, int k, const float *a, int lda, const float *tau, float *c, int ldc, float *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_sormrq_work$handle() {
        return LAPACKE_sormrq_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sormrq_work(int matrix_layout, char side, char trans, int m, int n, int k, const float *a, int lda, const float *tau, float *c, int ldc, float *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_sormrq_work$address() {
        return LAPACKE_sormrq_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sormrq_work(int matrix_layout, char side, char trans, int m, int n, int k, const float *a, int lda, const float *tau, float *c, int ldc, float *work, int lwork)
     * }
     */
    public static int LAPACKE_sormrq_work(int matrix_layout, byte side, byte trans, int m, int n, int k, MemorySegment a, int lda, MemorySegment tau, MemorySegment c, int ldc, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_sormrq_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sormrq_work", matrix_layout, side, trans, m, n, k, a, lda, tau, c, ldc, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, side, trans, m, n, k, a, lda, tau, c, ldc, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dormrq_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dormrq_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dormrq_work(int matrix_layout, char side, char trans, int m, int n, int k, const double *a, int lda, const double *tau, double *c, int ldc, double *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_dormrq_work$descriptor() {
        return LAPACKE_dormrq_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dormrq_work(int matrix_layout, char side, char trans, int m, int n, int k, const double *a, int lda, const double *tau, double *c, int ldc, double *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_dormrq_work$handle() {
        return LAPACKE_dormrq_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dormrq_work(int matrix_layout, char side, char trans, int m, int n, int k, const double *a, int lda, const double *tau, double *c, int ldc, double *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_dormrq_work$address() {
        return LAPACKE_dormrq_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dormrq_work(int matrix_layout, char side, char trans, int m, int n, int k, const double *a, int lda, const double *tau, double *c, int ldc, double *work, int lwork)
     * }
     */
    public static int LAPACKE_dormrq_work(int matrix_layout, byte side, byte trans, int m, int n, int k, MemorySegment a, int lda, MemorySegment tau, MemorySegment c, int ldc, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_dormrq_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dormrq_work", matrix_layout, side, trans, m, n, k, a, lda, tau, c, ldc, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, side, trans, m, n, k, a, lda, tau, c, ldc, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sormrz_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_sormrz_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sormrz_work(int matrix_layout, char side, char trans, int m, int n, int k, int l, const float *a, int lda, const float *tau, float *c, int ldc, float *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_sormrz_work$descriptor() {
        return LAPACKE_sormrz_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sormrz_work(int matrix_layout, char side, char trans, int m, int n, int k, int l, const float *a, int lda, const float *tau, float *c, int ldc, float *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_sormrz_work$handle() {
        return LAPACKE_sormrz_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sormrz_work(int matrix_layout, char side, char trans, int m, int n, int k, int l, const float *a, int lda, const float *tau, float *c, int ldc, float *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_sormrz_work$address() {
        return LAPACKE_sormrz_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sormrz_work(int matrix_layout, char side, char trans, int m, int n, int k, int l, const float *a, int lda, const float *tau, float *c, int ldc, float *work, int lwork)
     * }
     */
    public static int LAPACKE_sormrz_work(int matrix_layout, byte side, byte trans, int m, int n, int k, int l, MemorySegment a, int lda, MemorySegment tau, MemorySegment c, int ldc, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_sormrz_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sormrz_work", matrix_layout, side, trans, m, n, k, l, a, lda, tau, c, ldc, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, side, trans, m, n, k, l, a, lda, tau, c, ldc, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dormrz_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dormrz_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dormrz_work(int matrix_layout, char side, char trans, int m, int n, int k, int l, const double *a, int lda, const double *tau, double *c, int ldc, double *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_dormrz_work$descriptor() {
        return LAPACKE_dormrz_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dormrz_work(int matrix_layout, char side, char trans, int m, int n, int k, int l, const double *a, int lda, const double *tau, double *c, int ldc, double *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_dormrz_work$handle() {
        return LAPACKE_dormrz_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dormrz_work(int matrix_layout, char side, char trans, int m, int n, int k, int l, const double *a, int lda, const double *tau, double *c, int ldc, double *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_dormrz_work$address() {
        return LAPACKE_dormrz_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dormrz_work(int matrix_layout, char side, char trans, int m, int n, int k, int l, const double *a, int lda, const double *tau, double *c, int ldc, double *work, int lwork)
     * }
     */
    public static int LAPACKE_dormrz_work(int matrix_layout, byte side, byte trans, int m, int n, int k, int l, MemorySegment a, int lda, MemorySegment tau, MemorySegment c, int ldc, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_dormrz_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dormrz_work", matrix_layout, side, trans, m, n, k, l, a, lda, tau, c, ldc, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, side, trans, m, n, k, l, a, lda, tau, c, ldc, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sormtr_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_sormtr_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sormtr_work(int matrix_layout, char side, char uplo, char trans, int m, int n, const float *a, int lda, const float *tau, float *c, int ldc, float *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_sormtr_work$descriptor() {
        return LAPACKE_sormtr_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sormtr_work(int matrix_layout, char side, char uplo, char trans, int m, int n, const float *a, int lda, const float *tau, float *c, int ldc, float *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_sormtr_work$handle() {
        return LAPACKE_sormtr_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sormtr_work(int matrix_layout, char side, char uplo, char trans, int m, int n, const float *a, int lda, const float *tau, float *c, int ldc, float *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_sormtr_work$address() {
        return LAPACKE_sormtr_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sormtr_work(int matrix_layout, char side, char uplo, char trans, int m, int n, const float *a, int lda, const float *tau, float *c, int ldc, float *work, int lwork)
     * }
     */
    public static int LAPACKE_sormtr_work(int matrix_layout, byte side, byte uplo, byte trans, int m, int n, MemorySegment a, int lda, MemorySegment tau, MemorySegment c, int ldc, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_sormtr_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sormtr_work", matrix_layout, side, uplo, trans, m, n, a, lda, tau, c, ldc, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, side, uplo, trans, m, n, a, lda, tau, c, ldc, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dormtr_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dormtr_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dormtr_work(int matrix_layout, char side, char uplo, char trans, int m, int n, const double *a, int lda, const double *tau, double *c, int ldc, double *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_dormtr_work$descriptor() {
        return LAPACKE_dormtr_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dormtr_work(int matrix_layout, char side, char uplo, char trans, int m, int n, const double *a, int lda, const double *tau, double *c, int ldc, double *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_dormtr_work$handle() {
        return LAPACKE_dormtr_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dormtr_work(int matrix_layout, char side, char uplo, char trans, int m, int n, const double *a, int lda, const double *tau, double *c, int ldc, double *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_dormtr_work$address() {
        return LAPACKE_dormtr_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dormtr_work(int matrix_layout, char side, char uplo, char trans, int m, int n, const double *a, int lda, const double *tau, double *c, int ldc, double *work, int lwork)
     * }
     */
    public static int LAPACKE_dormtr_work(int matrix_layout, byte side, byte uplo, byte trans, int m, int n, MemorySegment a, int lda, MemorySegment tau, MemorySegment c, int ldc, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_dormtr_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dormtr_work", matrix_layout, side, uplo, trans, m, n, a, lda, tau, c, ldc, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, side, uplo, trans, m, n, a, lda, tau, c, ldc, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_spbcon_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_FLOAT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_spbcon_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_spbcon_work(int matrix_layout, char uplo, int n, int kd, const float *ab, int ldab, float anorm, float *rcond, float *work, int *iwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_spbcon_work$descriptor() {
        return LAPACKE_spbcon_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_spbcon_work(int matrix_layout, char uplo, int n, int kd, const float *ab, int ldab, float anorm, float *rcond, float *work, int *iwork)
     * }
     */
    public static MethodHandle LAPACKE_spbcon_work$handle() {
        return LAPACKE_spbcon_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_spbcon_work(int matrix_layout, char uplo, int n, int kd, const float *ab, int ldab, float anorm, float *rcond, float *work, int *iwork)
     * }
     */
    public static MemorySegment LAPACKE_spbcon_work$address() {
        return LAPACKE_spbcon_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_spbcon_work(int matrix_layout, char uplo, int n, int kd, const float *ab, int ldab, float anorm, float *rcond, float *work, int *iwork)
     * }
     */
    public static int LAPACKE_spbcon_work(int matrix_layout, byte uplo, int n, int kd, MemorySegment ab, int ldab, float anorm, MemorySegment rcond, MemorySegment work, MemorySegment iwork) {
        var mh$ = LAPACKE_spbcon_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_spbcon_work", matrix_layout, uplo, n, kd, ab, ldab, anorm, rcond, work, iwork);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, kd, ab, ldab, anorm, rcond, work, iwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dpbcon_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_DOUBLE,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dpbcon_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dpbcon_work(int matrix_layout, char uplo, int n, int kd, const double *ab, int ldab, double anorm, double *rcond, double *work, int *iwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_dpbcon_work$descriptor() {
        return LAPACKE_dpbcon_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dpbcon_work(int matrix_layout, char uplo, int n, int kd, const double *ab, int ldab, double anorm, double *rcond, double *work, int *iwork)
     * }
     */
    public static MethodHandle LAPACKE_dpbcon_work$handle() {
        return LAPACKE_dpbcon_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dpbcon_work(int matrix_layout, char uplo, int n, int kd, const double *ab, int ldab, double anorm, double *rcond, double *work, int *iwork)
     * }
     */
    public static MemorySegment LAPACKE_dpbcon_work$address() {
        return LAPACKE_dpbcon_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dpbcon_work(int matrix_layout, char uplo, int n, int kd, const double *ab, int ldab, double anorm, double *rcond, double *work, int *iwork)
     * }
     */
    public static int LAPACKE_dpbcon_work(int matrix_layout, byte uplo, int n, int kd, MemorySegment ab, int ldab, double anorm, MemorySegment rcond, MemorySegment work, MemorySegment iwork) {
        var mh$ = LAPACKE_dpbcon_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dpbcon_work", matrix_layout, uplo, n, kd, ab, ldab, anorm, rcond, work, iwork);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, kd, ab, ldab, anorm, rcond, work, iwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cpbcon_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_FLOAT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_cpbcon_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cpbcon_work(int matrix_layout, char uplo, int n, int kd, const _Complex float *ab, int ldab, float anorm, float *rcond, _Complex float *work, float *rwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_cpbcon_work$descriptor() {
        return LAPACKE_cpbcon_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cpbcon_work(int matrix_layout, char uplo, int n, int kd, const _Complex float *ab, int ldab, float anorm, float *rcond, _Complex float *work, float *rwork)
     * }
     */
    public static MethodHandle LAPACKE_cpbcon_work$handle() {
        return LAPACKE_cpbcon_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cpbcon_work(int matrix_layout, char uplo, int n, int kd, const _Complex float *ab, int ldab, float anorm, float *rcond, _Complex float *work, float *rwork)
     * }
     */
    public static MemorySegment LAPACKE_cpbcon_work$address() {
        return LAPACKE_cpbcon_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cpbcon_work(int matrix_layout, char uplo, int n, int kd, const _Complex float *ab, int ldab, float anorm, float *rcond, _Complex float *work, float *rwork)
     * }
     */
    public static int LAPACKE_cpbcon_work(int matrix_layout, byte uplo, int n, int kd, MemorySegment ab, int ldab, float anorm, MemorySegment rcond, MemorySegment work, MemorySegment rwork) {
        var mh$ = LAPACKE_cpbcon_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cpbcon_work", matrix_layout, uplo, n, kd, ab, ldab, anorm, rcond, work, rwork);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, kd, ab, ldab, anorm, rcond, work, rwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zpbcon_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_DOUBLE,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zpbcon_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zpbcon_work(int matrix_layout, char uplo, int n, int kd, const _Complex double *ab, int ldab, double anorm, double *rcond, _Complex double *work, double *rwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_zpbcon_work$descriptor() {
        return LAPACKE_zpbcon_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zpbcon_work(int matrix_layout, char uplo, int n, int kd, const _Complex double *ab, int ldab, double anorm, double *rcond, _Complex double *work, double *rwork)
     * }
     */
    public static MethodHandle LAPACKE_zpbcon_work$handle() {
        return LAPACKE_zpbcon_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zpbcon_work(int matrix_layout, char uplo, int n, int kd, const _Complex double *ab, int ldab, double anorm, double *rcond, _Complex double *work, double *rwork)
     * }
     */
    public static MemorySegment LAPACKE_zpbcon_work$address() {
        return LAPACKE_zpbcon_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zpbcon_work(int matrix_layout, char uplo, int n, int kd, const _Complex double *ab, int ldab, double anorm, double *rcond, _Complex double *work, double *rwork)
     * }
     */
    public static int LAPACKE_zpbcon_work(int matrix_layout, byte uplo, int n, int kd, MemorySegment ab, int ldab, double anorm, MemorySegment rcond, MemorySegment work, MemorySegment rwork) {
        var mh$ = LAPACKE_zpbcon_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zpbcon_work", matrix_layout, uplo, n, kd, ab, ldab, anorm, rcond, work, rwork);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, kd, ab, ldab, anorm, rcond, work, rwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_spbequ_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_spbequ_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_spbequ_work(int matrix_layout, char uplo, int n, int kd, const float *ab, int ldab, float *s, float *scond, float *amax)
     * }
     */
    public static FunctionDescriptor LAPACKE_spbequ_work$descriptor() {
        return LAPACKE_spbequ_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_spbequ_work(int matrix_layout, char uplo, int n, int kd, const float *ab, int ldab, float *s, float *scond, float *amax)
     * }
     */
    public static MethodHandle LAPACKE_spbequ_work$handle() {
        return LAPACKE_spbequ_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_spbequ_work(int matrix_layout, char uplo, int n, int kd, const float *ab, int ldab, float *s, float *scond, float *amax)
     * }
     */
    public static MemorySegment LAPACKE_spbequ_work$address() {
        return LAPACKE_spbequ_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_spbequ_work(int matrix_layout, char uplo, int n, int kd, const float *ab, int ldab, float *s, float *scond, float *amax)
     * }
     */
    public static int LAPACKE_spbequ_work(int matrix_layout, byte uplo, int n, int kd, MemorySegment ab, int ldab, MemorySegment s, MemorySegment scond, MemorySegment amax) {
        var mh$ = LAPACKE_spbequ_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_spbequ_work", matrix_layout, uplo, n, kd, ab, ldab, s, scond, amax);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, kd, ab, ldab, s, scond, amax);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dpbequ_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dpbequ_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dpbequ_work(int matrix_layout, char uplo, int n, int kd, const double *ab, int ldab, double *s, double *scond, double *amax)
     * }
     */
    public static FunctionDescriptor LAPACKE_dpbequ_work$descriptor() {
        return LAPACKE_dpbequ_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dpbequ_work(int matrix_layout, char uplo, int n, int kd, const double *ab, int ldab, double *s, double *scond, double *amax)
     * }
     */
    public static MethodHandle LAPACKE_dpbequ_work$handle() {
        return LAPACKE_dpbequ_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dpbequ_work(int matrix_layout, char uplo, int n, int kd, const double *ab, int ldab, double *s, double *scond, double *amax)
     * }
     */
    public static MemorySegment LAPACKE_dpbequ_work$address() {
        return LAPACKE_dpbequ_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dpbequ_work(int matrix_layout, char uplo, int n, int kd, const double *ab, int ldab, double *s, double *scond, double *amax)
     * }
     */
    public static int LAPACKE_dpbequ_work(int matrix_layout, byte uplo, int n, int kd, MemorySegment ab, int ldab, MemorySegment s, MemorySegment scond, MemorySegment amax) {
        var mh$ = LAPACKE_dpbequ_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dpbequ_work", matrix_layout, uplo, n, kd, ab, ldab, s, scond, amax);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, kd, ab, ldab, s, scond, amax);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cpbequ_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_cpbequ_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cpbequ_work(int matrix_layout, char uplo, int n, int kd, const _Complex float *ab, int ldab, float *s, float *scond, float *amax)
     * }
     */
    public static FunctionDescriptor LAPACKE_cpbequ_work$descriptor() {
        return LAPACKE_cpbequ_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cpbequ_work(int matrix_layout, char uplo, int n, int kd, const _Complex float *ab, int ldab, float *s, float *scond, float *amax)
     * }
     */
    public static MethodHandle LAPACKE_cpbequ_work$handle() {
        return LAPACKE_cpbequ_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cpbequ_work(int matrix_layout, char uplo, int n, int kd, const _Complex float *ab, int ldab, float *s, float *scond, float *amax)
     * }
     */
    public static MemorySegment LAPACKE_cpbequ_work$address() {
        return LAPACKE_cpbequ_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cpbequ_work(int matrix_layout, char uplo, int n, int kd, const _Complex float *ab, int ldab, float *s, float *scond, float *amax)
     * }
     */
    public static int LAPACKE_cpbequ_work(int matrix_layout, byte uplo, int n, int kd, MemorySegment ab, int ldab, MemorySegment s, MemorySegment scond, MemorySegment amax) {
        var mh$ = LAPACKE_cpbequ_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cpbequ_work", matrix_layout, uplo, n, kd, ab, ldab, s, scond, amax);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, kd, ab, ldab, s, scond, amax);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zpbequ_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zpbequ_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zpbequ_work(int matrix_layout, char uplo, int n, int kd, const _Complex double *ab, int ldab, double *s, double *scond, double *amax)
     * }
     */
    public static FunctionDescriptor LAPACKE_zpbequ_work$descriptor() {
        return LAPACKE_zpbequ_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zpbequ_work(int matrix_layout, char uplo, int n, int kd, const _Complex double *ab, int ldab, double *s, double *scond, double *amax)
     * }
     */
    public static MethodHandle LAPACKE_zpbequ_work$handle() {
        return LAPACKE_zpbequ_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zpbequ_work(int matrix_layout, char uplo, int n, int kd, const _Complex double *ab, int ldab, double *s, double *scond, double *amax)
     * }
     */
    public static MemorySegment LAPACKE_zpbequ_work$address() {
        return LAPACKE_zpbequ_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zpbequ_work(int matrix_layout, char uplo, int n, int kd, const _Complex double *ab, int ldab, double *s, double *scond, double *amax)
     * }
     */
    public static int LAPACKE_zpbequ_work(int matrix_layout, byte uplo, int n, int kd, MemorySegment ab, int ldab, MemorySegment s, MemorySegment scond, MemorySegment amax) {
        var mh$ = LAPACKE_zpbequ_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zpbequ_work", matrix_layout, uplo, n, kd, ab, ldab, s, scond, amax);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, kd, ab, ldab, s, scond, amax);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_spbrfs_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_spbrfs_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_spbrfs_work(int matrix_layout, char uplo, int n, int kd, int nrhs, const float *ab, int ldab, const float *afb, int ldafb, const float *b, int ldb, float *x, int ldx, float *ferr, float *berr, float *work, int *iwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_spbrfs_work$descriptor() {
        return LAPACKE_spbrfs_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_spbrfs_work(int matrix_layout, char uplo, int n, int kd, int nrhs, const float *ab, int ldab, const float *afb, int ldafb, const float *b, int ldb, float *x, int ldx, float *ferr, float *berr, float *work, int *iwork)
     * }
     */
    public static MethodHandle LAPACKE_spbrfs_work$handle() {
        return LAPACKE_spbrfs_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_spbrfs_work(int matrix_layout, char uplo, int n, int kd, int nrhs, const float *ab, int ldab, const float *afb, int ldafb, const float *b, int ldb, float *x, int ldx, float *ferr, float *berr, float *work, int *iwork)
     * }
     */
    public static MemorySegment LAPACKE_spbrfs_work$address() {
        return LAPACKE_spbrfs_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_spbrfs_work(int matrix_layout, char uplo, int n, int kd, int nrhs, const float *ab, int ldab, const float *afb, int ldafb, const float *b, int ldb, float *x, int ldx, float *ferr, float *berr, float *work, int *iwork)
     * }
     */
    public static int LAPACKE_spbrfs_work(int matrix_layout, byte uplo, int n, int kd, int nrhs, MemorySegment ab, int ldab, MemorySegment afb, int ldafb, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment ferr, MemorySegment berr, MemorySegment work, MemorySegment iwork) {
        var mh$ = LAPACKE_spbrfs_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_spbrfs_work", matrix_layout, uplo, n, kd, nrhs, ab, ldab, afb, ldafb, b, ldb, x, ldx, ferr, berr, work, iwork);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, kd, nrhs, ab, ldab, afb, ldafb, b, ldb, x, ldx, ferr, berr, work, iwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dpbrfs_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dpbrfs_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dpbrfs_work(int matrix_layout, char uplo, int n, int kd, int nrhs, const double *ab, int ldab, const double *afb, int ldafb, const double *b, int ldb, double *x, int ldx, double *ferr, double *berr, double *work, int *iwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_dpbrfs_work$descriptor() {
        return LAPACKE_dpbrfs_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dpbrfs_work(int matrix_layout, char uplo, int n, int kd, int nrhs, const double *ab, int ldab, const double *afb, int ldafb, const double *b, int ldb, double *x, int ldx, double *ferr, double *berr, double *work, int *iwork)
     * }
     */
    public static MethodHandle LAPACKE_dpbrfs_work$handle() {
        return LAPACKE_dpbrfs_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dpbrfs_work(int matrix_layout, char uplo, int n, int kd, int nrhs, const double *ab, int ldab, const double *afb, int ldafb, const double *b, int ldb, double *x, int ldx, double *ferr, double *berr, double *work, int *iwork)
     * }
     */
    public static MemorySegment LAPACKE_dpbrfs_work$address() {
        return LAPACKE_dpbrfs_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dpbrfs_work(int matrix_layout, char uplo, int n, int kd, int nrhs, const double *ab, int ldab, const double *afb, int ldafb, const double *b, int ldb, double *x, int ldx, double *ferr, double *berr, double *work, int *iwork)
     * }
     */
    public static int LAPACKE_dpbrfs_work(int matrix_layout, byte uplo, int n, int kd, int nrhs, MemorySegment ab, int ldab, MemorySegment afb, int ldafb, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment ferr, MemorySegment berr, MemorySegment work, MemorySegment iwork) {
        var mh$ = LAPACKE_dpbrfs_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dpbrfs_work", matrix_layout, uplo, n, kd, nrhs, ab, ldab, afb, ldafb, b, ldb, x, ldx, ferr, berr, work, iwork);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, kd, nrhs, ab, ldab, afb, ldafb, b, ldb, x, ldx, ferr, berr, work, iwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cpbrfs_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_cpbrfs_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cpbrfs_work(int matrix_layout, char uplo, int n, int kd, int nrhs, const _Complex float *ab, int ldab, const _Complex float *afb, int ldafb, const _Complex float *b, int ldb, _Complex float *x, int ldx, float *ferr, float *berr, _Complex float *work, float *rwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_cpbrfs_work$descriptor() {
        return LAPACKE_cpbrfs_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cpbrfs_work(int matrix_layout, char uplo, int n, int kd, int nrhs, const _Complex float *ab, int ldab, const _Complex float *afb, int ldafb, const _Complex float *b, int ldb, _Complex float *x, int ldx, float *ferr, float *berr, _Complex float *work, float *rwork)
     * }
     */
    public static MethodHandle LAPACKE_cpbrfs_work$handle() {
        return LAPACKE_cpbrfs_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cpbrfs_work(int matrix_layout, char uplo, int n, int kd, int nrhs, const _Complex float *ab, int ldab, const _Complex float *afb, int ldafb, const _Complex float *b, int ldb, _Complex float *x, int ldx, float *ferr, float *berr, _Complex float *work, float *rwork)
     * }
     */
    public static MemorySegment LAPACKE_cpbrfs_work$address() {
        return LAPACKE_cpbrfs_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cpbrfs_work(int matrix_layout, char uplo, int n, int kd, int nrhs, const _Complex float *ab, int ldab, const _Complex float *afb, int ldafb, const _Complex float *b, int ldb, _Complex float *x, int ldx, float *ferr, float *berr, _Complex float *work, float *rwork)
     * }
     */
    public static int LAPACKE_cpbrfs_work(int matrix_layout, byte uplo, int n, int kd, int nrhs, MemorySegment ab, int ldab, MemorySegment afb, int ldafb, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment ferr, MemorySegment berr, MemorySegment work, MemorySegment rwork) {
        var mh$ = LAPACKE_cpbrfs_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cpbrfs_work", matrix_layout, uplo, n, kd, nrhs, ab, ldab, afb, ldafb, b, ldb, x, ldx, ferr, berr, work, rwork);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, kd, nrhs, ab, ldab, afb, ldafb, b, ldb, x, ldx, ferr, berr, work, rwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zpbrfs_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zpbrfs_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zpbrfs_work(int matrix_layout, char uplo, int n, int kd, int nrhs, const _Complex double *ab, int ldab, const _Complex double *afb, int ldafb, const _Complex double *b, int ldb, _Complex double *x, int ldx, double *ferr, double *berr, _Complex double *work, double *rwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_zpbrfs_work$descriptor() {
        return LAPACKE_zpbrfs_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zpbrfs_work(int matrix_layout, char uplo, int n, int kd, int nrhs, const _Complex double *ab, int ldab, const _Complex double *afb, int ldafb, const _Complex double *b, int ldb, _Complex double *x, int ldx, double *ferr, double *berr, _Complex double *work, double *rwork)
     * }
     */
    public static MethodHandle LAPACKE_zpbrfs_work$handle() {
        return LAPACKE_zpbrfs_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zpbrfs_work(int matrix_layout, char uplo, int n, int kd, int nrhs, const _Complex double *ab, int ldab, const _Complex double *afb, int ldafb, const _Complex double *b, int ldb, _Complex double *x, int ldx, double *ferr, double *berr, _Complex double *work, double *rwork)
     * }
     */
    public static MemorySegment LAPACKE_zpbrfs_work$address() {
        return LAPACKE_zpbrfs_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zpbrfs_work(int matrix_layout, char uplo, int n, int kd, int nrhs, const _Complex double *ab, int ldab, const _Complex double *afb, int ldafb, const _Complex double *b, int ldb, _Complex double *x, int ldx, double *ferr, double *berr, _Complex double *work, double *rwork)
     * }
     */
    public static int LAPACKE_zpbrfs_work(int matrix_layout, byte uplo, int n, int kd, int nrhs, MemorySegment ab, int ldab, MemorySegment afb, int ldafb, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment ferr, MemorySegment berr, MemorySegment work, MemorySegment rwork) {
        var mh$ = LAPACKE_zpbrfs_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zpbrfs_work", matrix_layout, uplo, n, kd, nrhs, ab, ldab, afb, ldafb, b, ldb, x, ldx, ferr, berr, work, rwork);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, kd, nrhs, ab, ldab, afb, ldafb, b, ldb, x, ldx, ferr, berr, work, rwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_spbstf_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_spbstf_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_spbstf_work(int matrix_layout, char uplo, int n, int kb, float *bb, int ldbb)
     * }
     */
    public static FunctionDescriptor LAPACKE_spbstf_work$descriptor() {
        return LAPACKE_spbstf_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_spbstf_work(int matrix_layout, char uplo, int n, int kb, float *bb, int ldbb)
     * }
     */
    public static MethodHandle LAPACKE_spbstf_work$handle() {
        return LAPACKE_spbstf_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_spbstf_work(int matrix_layout, char uplo, int n, int kb, float *bb, int ldbb)
     * }
     */
    public static MemorySegment LAPACKE_spbstf_work$address() {
        return LAPACKE_spbstf_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_spbstf_work(int matrix_layout, char uplo, int n, int kb, float *bb, int ldbb)
     * }
     */
    public static int LAPACKE_spbstf_work(int matrix_layout, byte uplo, int n, int kb, MemorySegment bb, int ldbb) {
        var mh$ = LAPACKE_spbstf_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_spbstf_work", matrix_layout, uplo, n, kb, bb, ldbb);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, kb, bb, ldbb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dpbstf_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dpbstf_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dpbstf_work(int matrix_layout, char uplo, int n, int kb, double *bb, int ldbb)
     * }
     */
    public static FunctionDescriptor LAPACKE_dpbstf_work$descriptor() {
        return LAPACKE_dpbstf_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dpbstf_work(int matrix_layout, char uplo, int n, int kb, double *bb, int ldbb)
     * }
     */
    public static MethodHandle LAPACKE_dpbstf_work$handle() {
        return LAPACKE_dpbstf_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dpbstf_work(int matrix_layout, char uplo, int n, int kb, double *bb, int ldbb)
     * }
     */
    public static MemorySegment LAPACKE_dpbstf_work$address() {
        return LAPACKE_dpbstf_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dpbstf_work(int matrix_layout, char uplo, int n, int kb, double *bb, int ldbb)
     * }
     */
    public static int LAPACKE_dpbstf_work(int matrix_layout, byte uplo, int n, int kb, MemorySegment bb, int ldbb) {
        var mh$ = LAPACKE_dpbstf_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dpbstf_work", matrix_layout, uplo, n, kb, bb, ldbb);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, kb, bb, ldbb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cpbstf_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_cpbstf_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cpbstf_work(int matrix_layout, char uplo, int n, int kb, _Complex float *bb, int ldbb)
     * }
     */
    public static FunctionDescriptor LAPACKE_cpbstf_work$descriptor() {
        return LAPACKE_cpbstf_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cpbstf_work(int matrix_layout, char uplo, int n, int kb, _Complex float *bb, int ldbb)
     * }
     */
    public static MethodHandle LAPACKE_cpbstf_work$handle() {
        return LAPACKE_cpbstf_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cpbstf_work(int matrix_layout, char uplo, int n, int kb, _Complex float *bb, int ldbb)
     * }
     */
    public static MemorySegment LAPACKE_cpbstf_work$address() {
        return LAPACKE_cpbstf_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cpbstf_work(int matrix_layout, char uplo, int n, int kb, _Complex float *bb, int ldbb)
     * }
     */
    public static int LAPACKE_cpbstf_work(int matrix_layout, byte uplo, int n, int kb, MemorySegment bb, int ldbb) {
        var mh$ = LAPACKE_cpbstf_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cpbstf_work", matrix_layout, uplo, n, kb, bb, ldbb);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, kb, bb, ldbb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zpbstf_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zpbstf_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zpbstf_work(int matrix_layout, char uplo, int n, int kb, _Complex double *bb, int ldbb)
     * }
     */
    public static FunctionDescriptor LAPACKE_zpbstf_work$descriptor() {
        return LAPACKE_zpbstf_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zpbstf_work(int matrix_layout, char uplo, int n, int kb, _Complex double *bb, int ldbb)
     * }
     */
    public static MethodHandle LAPACKE_zpbstf_work$handle() {
        return LAPACKE_zpbstf_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zpbstf_work(int matrix_layout, char uplo, int n, int kb, _Complex double *bb, int ldbb)
     * }
     */
    public static MemorySegment LAPACKE_zpbstf_work$address() {
        return LAPACKE_zpbstf_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zpbstf_work(int matrix_layout, char uplo, int n, int kb, _Complex double *bb, int ldbb)
     * }
     */
    public static int LAPACKE_zpbstf_work(int matrix_layout, byte uplo, int n, int kb, MemorySegment bb, int ldbb) {
        var mh$ = LAPACKE_zpbstf_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zpbstf_work", matrix_layout, uplo, n, kb, bb, ldbb);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, kb, bb, ldbb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_spbsv_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_spbsv_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_spbsv_work(int matrix_layout, char uplo, int n, int kd, int nrhs, float *ab, int ldab, float *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_spbsv_work$descriptor() {
        return LAPACKE_spbsv_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_spbsv_work(int matrix_layout, char uplo, int n, int kd, int nrhs, float *ab, int ldab, float *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_spbsv_work$handle() {
        return LAPACKE_spbsv_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_spbsv_work(int matrix_layout, char uplo, int n, int kd, int nrhs, float *ab, int ldab, float *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_spbsv_work$address() {
        return LAPACKE_spbsv_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_spbsv_work(int matrix_layout, char uplo, int n, int kd, int nrhs, float *ab, int ldab, float *b, int ldb)
     * }
     */
    public static int LAPACKE_spbsv_work(int matrix_layout, byte uplo, int n, int kd, int nrhs, MemorySegment ab, int ldab, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_spbsv_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_spbsv_work", matrix_layout, uplo, n, kd, nrhs, ab, ldab, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, kd, nrhs, ab, ldab, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dpbsv_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dpbsv_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dpbsv_work(int matrix_layout, char uplo, int n, int kd, int nrhs, double *ab, int ldab, double *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_dpbsv_work$descriptor() {
        return LAPACKE_dpbsv_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dpbsv_work(int matrix_layout, char uplo, int n, int kd, int nrhs, double *ab, int ldab, double *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_dpbsv_work$handle() {
        return LAPACKE_dpbsv_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dpbsv_work(int matrix_layout, char uplo, int n, int kd, int nrhs, double *ab, int ldab, double *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_dpbsv_work$address() {
        return LAPACKE_dpbsv_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dpbsv_work(int matrix_layout, char uplo, int n, int kd, int nrhs, double *ab, int ldab, double *b, int ldb)
     * }
     */
    public static int LAPACKE_dpbsv_work(int matrix_layout, byte uplo, int n, int kd, int nrhs, MemorySegment ab, int ldab, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_dpbsv_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dpbsv_work", matrix_layout, uplo, n, kd, nrhs, ab, ldab, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, kd, nrhs, ab, ldab, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cpbsv_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_cpbsv_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cpbsv_work(int matrix_layout, char uplo, int n, int kd, int nrhs, _Complex float *ab, int ldab, _Complex float *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_cpbsv_work$descriptor() {
        return LAPACKE_cpbsv_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cpbsv_work(int matrix_layout, char uplo, int n, int kd, int nrhs, _Complex float *ab, int ldab, _Complex float *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_cpbsv_work$handle() {
        return LAPACKE_cpbsv_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cpbsv_work(int matrix_layout, char uplo, int n, int kd, int nrhs, _Complex float *ab, int ldab, _Complex float *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_cpbsv_work$address() {
        return LAPACKE_cpbsv_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cpbsv_work(int matrix_layout, char uplo, int n, int kd, int nrhs, _Complex float *ab, int ldab, _Complex float *b, int ldb)
     * }
     */
    public static int LAPACKE_cpbsv_work(int matrix_layout, byte uplo, int n, int kd, int nrhs, MemorySegment ab, int ldab, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_cpbsv_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cpbsv_work", matrix_layout, uplo, n, kd, nrhs, ab, ldab, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, kd, nrhs, ab, ldab, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zpbsv_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zpbsv_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zpbsv_work(int matrix_layout, char uplo, int n, int kd, int nrhs, _Complex double *ab, int ldab, _Complex double *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_zpbsv_work$descriptor() {
        return LAPACKE_zpbsv_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zpbsv_work(int matrix_layout, char uplo, int n, int kd, int nrhs, _Complex double *ab, int ldab, _Complex double *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_zpbsv_work$handle() {
        return LAPACKE_zpbsv_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zpbsv_work(int matrix_layout, char uplo, int n, int kd, int nrhs, _Complex double *ab, int ldab, _Complex double *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_zpbsv_work$address() {
        return LAPACKE_zpbsv_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zpbsv_work(int matrix_layout, char uplo, int n, int kd, int nrhs, _Complex double *ab, int ldab, _Complex double *b, int ldb)
     * }
     */
    public static int LAPACKE_zpbsv_work(int matrix_layout, byte uplo, int n, int kd, int nrhs, MemorySegment ab, int ldab, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_zpbsv_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zpbsv_work", matrix_layout, uplo, n, kd, nrhs, ab, ldab, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, kd, nrhs, ab, ldab, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_spbsvx_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_spbsvx_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_spbsvx_work(int matrix_layout, char fact, char uplo, int n, int kd, int nrhs, float *ab, int ldab, float *afb, int ldafb, char *equed, float *s, float *b, int ldb, float *x, int ldx, float *rcond, float *ferr, float *berr, float *work, int *iwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_spbsvx_work$descriptor() {
        return LAPACKE_spbsvx_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_spbsvx_work(int matrix_layout, char fact, char uplo, int n, int kd, int nrhs, float *ab, int ldab, float *afb, int ldafb, char *equed, float *s, float *b, int ldb, float *x, int ldx, float *rcond, float *ferr, float *berr, float *work, int *iwork)
     * }
     */
    public static MethodHandle LAPACKE_spbsvx_work$handle() {
        return LAPACKE_spbsvx_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_spbsvx_work(int matrix_layout, char fact, char uplo, int n, int kd, int nrhs, float *ab, int ldab, float *afb, int ldafb, char *equed, float *s, float *b, int ldb, float *x, int ldx, float *rcond, float *ferr, float *berr, float *work, int *iwork)
     * }
     */
    public static MemorySegment LAPACKE_spbsvx_work$address() {
        return LAPACKE_spbsvx_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_spbsvx_work(int matrix_layout, char fact, char uplo, int n, int kd, int nrhs, float *ab, int ldab, float *afb, int ldafb, char *equed, float *s, float *b, int ldb, float *x, int ldx, float *rcond, float *ferr, float *berr, float *work, int *iwork)
     * }
     */
    public static int LAPACKE_spbsvx_work(int matrix_layout, byte fact, byte uplo, int n, int kd, int nrhs, MemorySegment ab, int ldab, MemorySegment afb, int ldafb, MemorySegment equed, MemorySegment s, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment rcond, MemorySegment ferr, MemorySegment berr, MemorySegment work, MemorySegment iwork) {
        var mh$ = LAPACKE_spbsvx_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_spbsvx_work", matrix_layout, fact, uplo, n, kd, nrhs, ab, ldab, afb, ldafb, equed, s, b, ldb, x, ldx, rcond, ferr, berr, work, iwork);
            }
            return (int)mh$.invokeExact(matrix_layout, fact, uplo, n, kd, nrhs, ab, ldab, afb, ldafb, equed, s, b, ldb, x, ldx, rcond, ferr, berr, work, iwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dpbsvx_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dpbsvx_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dpbsvx_work(int matrix_layout, char fact, char uplo, int n, int kd, int nrhs, double *ab, int ldab, double *afb, int ldafb, char *equed, double *s, double *b, int ldb, double *x, int ldx, double *rcond, double *ferr, double *berr, double *work, int *iwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_dpbsvx_work$descriptor() {
        return LAPACKE_dpbsvx_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dpbsvx_work(int matrix_layout, char fact, char uplo, int n, int kd, int nrhs, double *ab, int ldab, double *afb, int ldafb, char *equed, double *s, double *b, int ldb, double *x, int ldx, double *rcond, double *ferr, double *berr, double *work, int *iwork)
     * }
     */
    public static MethodHandle LAPACKE_dpbsvx_work$handle() {
        return LAPACKE_dpbsvx_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dpbsvx_work(int matrix_layout, char fact, char uplo, int n, int kd, int nrhs, double *ab, int ldab, double *afb, int ldafb, char *equed, double *s, double *b, int ldb, double *x, int ldx, double *rcond, double *ferr, double *berr, double *work, int *iwork)
     * }
     */
    public static MemorySegment LAPACKE_dpbsvx_work$address() {
        return LAPACKE_dpbsvx_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dpbsvx_work(int matrix_layout, char fact, char uplo, int n, int kd, int nrhs, double *ab, int ldab, double *afb, int ldafb, char *equed, double *s, double *b, int ldb, double *x, int ldx, double *rcond, double *ferr, double *berr, double *work, int *iwork)
     * }
     */
    public static int LAPACKE_dpbsvx_work(int matrix_layout, byte fact, byte uplo, int n, int kd, int nrhs, MemorySegment ab, int ldab, MemorySegment afb, int ldafb, MemorySegment equed, MemorySegment s, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment rcond, MemorySegment ferr, MemorySegment berr, MemorySegment work, MemorySegment iwork) {
        var mh$ = LAPACKE_dpbsvx_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dpbsvx_work", matrix_layout, fact, uplo, n, kd, nrhs, ab, ldab, afb, ldafb, equed, s, b, ldb, x, ldx, rcond, ferr, berr, work, iwork);
            }
            return (int)mh$.invokeExact(matrix_layout, fact, uplo, n, kd, nrhs, ab, ldab, afb, ldafb, equed, s, b, ldb, x, ldx, rcond, ferr, berr, work, iwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cpbsvx_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_cpbsvx_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cpbsvx_work(int matrix_layout, char fact, char uplo, int n, int kd, int nrhs, _Complex float *ab, int ldab, _Complex float *afb, int ldafb, char *equed, float *s, _Complex float *b, int ldb, _Complex float *x, int ldx, float *rcond, float *ferr, float *berr, _Complex float *work, float *rwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_cpbsvx_work$descriptor() {
        return LAPACKE_cpbsvx_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cpbsvx_work(int matrix_layout, char fact, char uplo, int n, int kd, int nrhs, _Complex float *ab, int ldab, _Complex float *afb, int ldafb, char *equed, float *s, _Complex float *b, int ldb, _Complex float *x, int ldx, float *rcond, float *ferr, float *berr, _Complex float *work, float *rwork)
     * }
     */
    public static MethodHandle LAPACKE_cpbsvx_work$handle() {
        return LAPACKE_cpbsvx_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cpbsvx_work(int matrix_layout, char fact, char uplo, int n, int kd, int nrhs, _Complex float *ab, int ldab, _Complex float *afb, int ldafb, char *equed, float *s, _Complex float *b, int ldb, _Complex float *x, int ldx, float *rcond, float *ferr, float *berr, _Complex float *work, float *rwork)
     * }
     */
    public static MemorySegment LAPACKE_cpbsvx_work$address() {
        return LAPACKE_cpbsvx_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cpbsvx_work(int matrix_layout, char fact, char uplo, int n, int kd, int nrhs, _Complex float *ab, int ldab, _Complex float *afb, int ldafb, char *equed, float *s, _Complex float *b, int ldb, _Complex float *x, int ldx, float *rcond, float *ferr, float *berr, _Complex float *work, float *rwork)
     * }
     */
    public static int LAPACKE_cpbsvx_work(int matrix_layout, byte fact, byte uplo, int n, int kd, int nrhs, MemorySegment ab, int ldab, MemorySegment afb, int ldafb, MemorySegment equed, MemorySegment s, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment rcond, MemorySegment ferr, MemorySegment berr, MemorySegment work, MemorySegment rwork) {
        var mh$ = LAPACKE_cpbsvx_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cpbsvx_work", matrix_layout, fact, uplo, n, kd, nrhs, ab, ldab, afb, ldafb, equed, s, b, ldb, x, ldx, rcond, ferr, berr, work, rwork);
            }
            return (int)mh$.invokeExact(matrix_layout, fact, uplo, n, kd, nrhs, ab, ldab, afb, ldafb, equed, s, b, ldb, x, ldx, rcond, ferr, berr, work, rwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zpbsvx_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zpbsvx_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zpbsvx_work(int matrix_layout, char fact, char uplo, int n, int kd, int nrhs, _Complex double *ab, int ldab, _Complex double *afb, int ldafb, char *equed, double *s, _Complex double *b, int ldb, _Complex double *x, int ldx, double *rcond, double *ferr, double *berr, _Complex double *work, double *rwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_zpbsvx_work$descriptor() {
        return LAPACKE_zpbsvx_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zpbsvx_work(int matrix_layout, char fact, char uplo, int n, int kd, int nrhs, _Complex double *ab, int ldab, _Complex double *afb, int ldafb, char *equed, double *s, _Complex double *b, int ldb, _Complex double *x, int ldx, double *rcond, double *ferr, double *berr, _Complex double *work, double *rwork)
     * }
     */
    public static MethodHandle LAPACKE_zpbsvx_work$handle() {
        return LAPACKE_zpbsvx_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zpbsvx_work(int matrix_layout, char fact, char uplo, int n, int kd, int nrhs, _Complex double *ab, int ldab, _Complex double *afb, int ldafb, char *equed, double *s, _Complex double *b, int ldb, _Complex double *x, int ldx, double *rcond, double *ferr, double *berr, _Complex double *work, double *rwork)
     * }
     */
    public static MemorySegment LAPACKE_zpbsvx_work$address() {
        return LAPACKE_zpbsvx_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zpbsvx_work(int matrix_layout, char fact, char uplo, int n, int kd, int nrhs, _Complex double *ab, int ldab, _Complex double *afb, int ldafb, char *equed, double *s, _Complex double *b, int ldb, _Complex double *x, int ldx, double *rcond, double *ferr, double *berr, _Complex double *work, double *rwork)
     * }
     */
    public static int LAPACKE_zpbsvx_work(int matrix_layout, byte fact, byte uplo, int n, int kd, int nrhs, MemorySegment ab, int ldab, MemorySegment afb, int ldafb, MemorySegment equed, MemorySegment s, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment rcond, MemorySegment ferr, MemorySegment berr, MemorySegment work, MemorySegment rwork) {
        var mh$ = LAPACKE_zpbsvx_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zpbsvx_work", matrix_layout, fact, uplo, n, kd, nrhs, ab, ldab, afb, ldafb, equed, s, b, ldb, x, ldx, rcond, ferr, berr, work, rwork);
            }
            return (int)mh$.invokeExact(matrix_layout, fact, uplo, n, kd, nrhs, ab, ldab, afb, ldafb, equed, s, b, ldb, x, ldx, rcond, ferr, berr, work, rwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_spbtrf_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_spbtrf_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_spbtrf_work(int matrix_layout, char uplo, int n, int kd, float *ab, int ldab)
     * }
     */
    public static FunctionDescriptor LAPACKE_spbtrf_work$descriptor() {
        return LAPACKE_spbtrf_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_spbtrf_work(int matrix_layout, char uplo, int n, int kd, float *ab, int ldab)
     * }
     */
    public static MethodHandle LAPACKE_spbtrf_work$handle() {
        return LAPACKE_spbtrf_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_spbtrf_work(int matrix_layout, char uplo, int n, int kd, float *ab, int ldab)
     * }
     */
    public static MemorySegment LAPACKE_spbtrf_work$address() {
        return LAPACKE_spbtrf_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_spbtrf_work(int matrix_layout, char uplo, int n, int kd, float *ab, int ldab)
     * }
     */
    public static int LAPACKE_spbtrf_work(int matrix_layout, byte uplo, int n, int kd, MemorySegment ab, int ldab) {
        var mh$ = LAPACKE_spbtrf_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_spbtrf_work", matrix_layout, uplo, n, kd, ab, ldab);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, kd, ab, ldab);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dpbtrf_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dpbtrf_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dpbtrf_work(int matrix_layout, char uplo, int n, int kd, double *ab, int ldab)
     * }
     */
    public static FunctionDescriptor LAPACKE_dpbtrf_work$descriptor() {
        return LAPACKE_dpbtrf_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dpbtrf_work(int matrix_layout, char uplo, int n, int kd, double *ab, int ldab)
     * }
     */
    public static MethodHandle LAPACKE_dpbtrf_work$handle() {
        return LAPACKE_dpbtrf_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dpbtrf_work(int matrix_layout, char uplo, int n, int kd, double *ab, int ldab)
     * }
     */
    public static MemorySegment LAPACKE_dpbtrf_work$address() {
        return LAPACKE_dpbtrf_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dpbtrf_work(int matrix_layout, char uplo, int n, int kd, double *ab, int ldab)
     * }
     */
    public static int LAPACKE_dpbtrf_work(int matrix_layout, byte uplo, int n, int kd, MemorySegment ab, int ldab) {
        var mh$ = LAPACKE_dpbtrf_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dpbtrf_work", matrix_layout, uplo, n, kd, ab, ldab);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, kd, ab, ldab);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cpbtrf_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_cpbtrf_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cpbtrf_work(int matrix_layout, char uplo, int n, int kd, _Complex float *ab, int ldab)
     * }
     */
    public static FunctionDescriptor LAPACKE_cpbtrf_work$descriptor() {
        return LAPACKE_cpbtrf_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cpbtrf_work(int matrix_layout, char uplo, int n, int kd, _Complex float *ab, int ldab)
     * }
     */
    public static MethodHandle LAPACKE_cpbtrf_work$handle() {
        return LAPACKE_cpbtrf_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cpbtrf_work(int matrix_layout, char uplo, int n, int kd, _Complex float *ab, int ldab)
     * }
     */
    public static MemorySegment LAPACKE_cpbtrf_work$address() {
        return LAPACKE_cpbtrf_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cpbtrf_work(int matrix_layout, char uplo, int n, int kd, _Complex float *ab, int ldab)
     * }
     */
    public static int LAPACKE_cpbtrf_work(int matrix_layout, byte uplo, int n, int kd, MemorySegment ab, int ldab) {
        var mh$ = LAPACKE_cpbtrf_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cpbtrf_work", matrix_layout, uplo, n, kd, ab, ldab);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, kd, ab, ldab);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zpbtrf_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zpbtrf_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zpbtrf_work(int matrix_layout, char uplo, int n, int kd, _Complex double *ab, int ldab)
     * }
     */
    public static FunctionDescriptor LAPACKE_zpbtrf_work$descriptor() {
        return LAPACKE_zpbtrf_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zpbtrf_work(int matrix_layout, char uplo, int n, int kd, _Complex double *ab, int ldab)
     * }
     */
    public static MethodHandle LAPACKE_zpbtrf_work$handle() {
        return LAPACKE_zpbtrf_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zpbtrf_work(int matrix_layout, char uplo, int n, int kd, _Complex double *ab, int ldab)
     * }
     */
    public static MemorySegment LAPACKE_zpbtrf_work$address() {
        return LAPACKE_zpbtrf_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zpbtrf_work(int matrix_layout, char uplo, int n, int kd, _Complex double *ab, int ldab)
     * }
     */
    public static int LAPACKE_zpbtrf_work(int matrix_layout, byte uplo, int n, int kd, MemorySegment ab, int ldab) {
        var mh$ = LAPACKE_zpbtrf_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zpbtrf_work", matrix_layout, uplo, n, kd, ab, ldab);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, kd, ab, ldab);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_spbtrs_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_spbtrs_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_spbtrs_work(int matrix_layout, char uplo, int n, int kd, int nrhs, const float *ab, int ldab, float *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_spbtrs_work$descriptor() {
        return LAPACKE_spbtrs_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_spbtrs_work(int matrix_layout, char uplo, int n, int kd, int nrhs, const float *ab, int ldab, float *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_spbtrs_work$handle() {
        return LAPACKE_spbtrs_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_spbtrs_work(int matrix_layout, char uplo, int n, int kd, int nrhs, const float *ab, int ldab, float *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_spbtrs_work$address() {
        return LAPACKE_spbtrs_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_spbtrs_work(int matrix_layout, char uplo, int n, int kd, int nrhs, const float *ab, int ldab, float *b, int ldb)
     * }
     */
    public static int LAPACKE_spbtrs_work(int matrix_layout, byte uplo, int n, int kd, int nrhs, MemorySegment ab, int ldab, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_spbtrs_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_spbtrs_work", matrix_layout, uplo, n, kd, nrhs, ab, ldab, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, kd, nrhs, ab, ldab, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dpbtrs_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dpbtrs_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dpbtrs_work(int matrix_layout, char uplo, int n, int kd, int nrhs, const double *ab, int ldab, double *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_dpbtrs_work$descriptor() {
        return LAPACKE_dpbtrs_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dpbtrs_work(int matrix_layout, char uplo, int n, int kd, int nrhs, const double *ab, int ldab, double *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_dpbtrs_work$handle() {
        return LAPACKE_dpbtrs_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dpbtrs_work(int matrix_layout, char uplo, int n, int kd, int nrhs, const double *ab, int ldab, double *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_dpbtrs_work$address() {
        return LAPACKE_dpbtrs_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dpbtrs_work(int matrix_layout, char uplo, int n, int kd, int nrhs, const double *ab, int ldab, double *b, int ldb)
     * }
     */
    public static int LAPACKE_dpbtrs_work(int matrix_layout, byte uplo, int n, int kd, int nrhs, MemorySegment ab, int ldab, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_dpbtrs_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dpbtrs_work", matrix_layout, uplo, n, kd, nrhs, ab, ldab, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, kd, nrhs, ab, ldab, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cpbtrs_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_cpbtrs_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cpbtrs_work(int matrix_layout, char uplo, int n, int kd, int nrhs, const _Complex float *ab, int ldab, _Complex float *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_cpbtrs_work$descriptor() {
        return LAPACKE_cpbtrs_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cpbtrs_work(int matrix_layout, char uplo, int n, int kd, int nrhs, const _Complex float *ab, int ldab, _Complex float *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_cpbtrs_work$handle() {
        return LAPACKE_cpbtrs_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cpbtrs_work(int matrix_layout, char uplo, int n, int kd, int nrhs, const _Complex float *ab, int ldab, _Complex float *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_cpbtrs_work$address() {
        return LAPACKE_cpbtrs_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cpbtrs_work(int matrix_layout, char uplo, int n, int kd, int nrhs, const _Complex float *ab, int ldab, _Complex float *b, int ldb)
     * }
     */
    public static int LAPACKE_cpbtrs_work(int matrix_layout, byte uplo, int n, int kd, int nrhs, MemorySegment ab, int ldab, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_cpbtrs_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cpbtrs_work", matrix_layout, uplo, n, kd, nrhs, ab, ldab, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, kd, nrhs, ab, ldab, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zpbtrs_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zpbtrs_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zpbtrs_work(int matrix_layout, char uplo, int n, int kd, int nrhs, const _Complex double *ab, int ldab, _Complex double *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_zpbtrs_work$descriptor() {
        return LAPACKE_zpbtrs_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zpbtrs_work(int matrix_layout, char uplo, int n, int kd, int nrhs, const _Complex double *ab, int ldab, _Complex double *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_zpbtrs_work$handle() {
        return LAPACKE_zpbtrs_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zpbtrs_work(int matrix_layout, char uplo, int n, int kd, int nrhs, const _Complex double *ab, int ldab, _Complex double *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_zpbtrs_work$address() {
        return LAPACKE_zpbtrs_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zpbtrs_work(int matrix_layout, char uplo, int n, int kd, int nrhs, const _Complex double *ab, int ldab, _Complex double *b, int ldb)
     * }
     */
    public static int LAPACKE_zpbtrs_work(int matrix_layout, byte uplo, int n, int kd, int nrhs, MemorySegment ab, int ldab, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_zpbtrs_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zpbtrs_work", matrix_layout, uplo, n, kd, nrhs, ab, ldab, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, kd, nrhs, ab, ldab, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_spftrf_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_spftrf_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_spftrf_work(int matrix_layout, char transr, char uplo, int n, float *a)
     * }
     */
    public static FunctionDescriptor LAPACKE_spftrf_work$descriptor() {
        return LAPACKE_spftrf_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_spftrf_work(int matrix_layout, char transr, char uplo, int n, float *a)
     * }
     */
    public static MethodHandle LAPACKE_spftrf_work$handle() {
        return LAPACKE_spftrf_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_spftrf_work(int matrix_layout, char transr, char uplo, int n, float *a)
     * }
     */
    public static MemorySegment LAPACKE_spftrf_work$address() {
        return LAPACKE_spftrf_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_spftrf_work(int matrix_layout, char transr, char uplo, int n, float *a)
     * }
     */
    public static int LAPACKE_spftrf_work(int matrix_layout, byte transr, byte uplo, int n, MemorySegment a) {
        var mh$ = LAPACKE_spftrf_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_spftrf_work", matrix_layout, transr, uplo, n, a);
            }
            return (int)mh$.invokeExact(matrix_layout, transr, uplo, n, a);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dpftrf_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dpftrf_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dpftrf_work(int matrix_layout, char transr, char uplo, int n, double *a)
     * }
     */
    public static FunctionDescriptor LAPACKE_dpftrf_work$descriptor() {
        return LAPACKE_dpftrf_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dpftrf_work(int matrix_layout, char transr, char uplo, int n, double *a)
     * }
     */
    public static MethodHandle LAPACKE_dpftrf_work$handle() {
        return LAPACKE_dpftrf_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dpftrf_work(int matrix_layout, char transr, char uplo, int n, double *a)
     * }
     */
    public static MemorySegment LAPACKE_dpftrf_work$address() {
        return LAPACKE_dpftrf_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dpftrf_work(int matrix_layout, char transr, char uplo, int n, double *a)
     * }
     */
    public static int LAPACKE_dpftrf_work(int matrix_layout, byte transr, byte uplo, int n, MemorySegment a) {
        var mh$ = LAPACKE_dpftrf_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dpftrf_work", matrix_layout, transr, uplo, n, a);
            }
            return (int)mh$.invokeExact(matrix_layout, transr, uplo, n, a);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cpftrf_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_cpftrf_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cpftrf_work(int matrix_layout, char transr, char uplo, int n, _Complex float *a)
     * }
     */
    public static FunctionDescriptor LAPACKE_cpftrf_work$descriptor() {
        return LAPACKE_cpftrf_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cpftrf_work(int matrix_layout, char transr, char uplo, int n, _Complex float *a)
     * }
     */
    public static MethodHandle LAPACKE_cpftrf_work$handle() {
        return LAPACKE_cpftrf_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cpftrf_work(int matrix_layout, char transr, char uplo, int n, _Complex float *a)
     * }
     */
    public static MemorySegment LAPACKE_cpftrf_work$address() {
        return LAPACKE_cpftrf_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cpftrf_work(int matrix_layout, char transr, char uplo, int n, _Complex float *a)
     * }
     */
    public static int LAPACKE_cpftrf_work(int matrix_layout, byte transr, byte uplo, int n, MemorySegment a) {
        var mh$ = LAPACKE_cpftrf_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cpftrf_work", matrix_layout, transr, uplo, n, a);
            }
            return (int)mh$.invokeExact(matrix_layout, transr, uplo, n, a);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zpftrf_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zpftrf_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zpftrf_work(int matrix_layout, char transr, char uplo, int n, _Complex double *a)
     * }
     */
    public static FunctionDescriptor LAPACKE_zpftrf_work$descriptor() {
        return LAPACKE_zpftrf_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zpftrf_work(int matrix_layout, char transr, char uplo, int n, _Complex double *a)
     * }
     */
    public static MethodHandle LAPACKE_zpftrf_work$handle() {
        return LAPACKE_zpftrf_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zpftrf_work(int matrix_layout, char transr, char uplo, int n, _Complex double *a)
     * }
     */
    public static MemorySegment LAPACKE_zpftrf_work$address() {
        return LAPACKE_zpftrf_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zpftrf_work(int matrix_layout, char transr, char uplo, int n, _Complex double *a)
     * }
     */
    public static int LAPACKE_zpftrf_work(int matrix_layout, byte transr, byte uplo, int n, MemorySegment a) {
        var mh$ = LAPACKE_zpftrf_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zpftrf_work", matrix_layout, transr, uplo, n, a);
            }
            return (int)mh$.invokeExact(matrix_layout, transr, uplo, n, a);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_spftri_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_spftri_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_spftri_work(int matrix_layout, char transr, char uplo, int n, float *a)
     * }
     */
    public static FunctionDescriptor LAPACKE_spftri_work$descriptor() {
        return LAPACKE_spftri_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_spftri_work(int matrix_layout, char transr, char uplo, int n, float *a)
     * }
     */
    public static MethodHandle LAPACKE_spftri_work$handle() {
        return LAPACKE_spftri_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_spftri_work(int matrix_layout, char transr, char uplo, int n, float *a)
     * }
     */
    public static MemorySegment LAPACKE_spftri_work$address() {
        return LAPACKE_spftri_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_spftri_work(int matrix_layout, char transr, char uplo, int n, float *a)
     * }
     */
    public static int LAPACKE_spftri_work(int matrix_layout, byte transr, byte uplo, int n, MemorySegment a) {
        var mh$ = LAPACKE_spftri_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_spftri_work", matrix_layout, transr, uplo, n, a);
            }
            return (int)mh$.invokeExact(matrix_layout, transr, uplo, n, a);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dpftri_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dpftri_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dpftri_work(int matrix_layout, char transr, char uplo, int n, double *a)
     * }
     */
    public static FunctionDescriptor LAPACKE_dpftri_work$descriptor() {
        return LAPACKE_dpftri_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dpftri_work(int matrix_layout, char transr, char uplo, int n, double *a)
     * }
     */
    public static MethodHandle LAPACKE_dpftri_work$handle() {
        return LAPACKE_dpftri_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dpftri_work(int matrix_layout, char transr, char uplo, int n, double *a)
     * }
     */
    public static MemorySegment LAPACKE_dpftri_work$address() {
        return LAPACKE_dpftri_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dpftri_work(int matrix_layout, char transr, char uplo, int n, double *a)
     * }
     */
    public static int LAPACKE_dpftri_work(int matrix_layout, byte transr, byte uplo, int n, MemorySegment a) {
        var mh$ = LAPACKE_dpftri_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dpftri_work", matrix_layout, transr, uplo, n, a);
            }
            return (int)mh$.invokeExact(matrix_layout, transr, uplo, n, a);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cpftri_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_cpftri_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cpftri_work(int matrix_layout, char transr, char uplo, int n, _Complex float *a)
     * }
     */
    public static FunctionDescriptor LAPACKE_cpftri_work$descriptor() {
        return LAPACKE_cpftri_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cpftri_work(int matrix_layout, char transr, char uplo, int n, _Complex float *a)
     * }
     */
    public static MethodHandle LAPACKE_cpftri_work$handle() {
        return LAPACKE_cpftri_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cpftri_work(int matrix_layout, char transr, char uplo, int n, _Complex float *a)
     * }
     */
    public static MemorySegment LAPACKE_cpftri_work$address() {
        return LAPACKE_cpftri_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cpftri_work(int matrix_layout, char transr, char uplo, int n, _Complex float *a)
     * }
     */
    public static int LAPACKE_cpftri_work(int matrix_layout, byte transr, byte uplo, int n, MemorySegment a) {
        var mh$ = LAPACKE_cpftri_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cpftri_work", matrix_layout, transr, uplo, n, a);
            }
            return (int)mh$.invokeExact(matrix_layout, transr, uplo, n, a);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zpftri_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zpftri_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zpftri_work(int matrix_layout, char transr, char uplo, int n, _Complex double *a)
     * }
     */
    public static FunctionDescriptor LAPACKE_zpftri_work$descriptor() {
        return LAPACKE_zpftri_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zpftri_work(int matrix_layout, char transr, char uplo, int n, _Complex double *a)
     * }
     */
    public static MethodHandle LAPACKE_zpftri_work$handle() {
        return LAPACKE_zpftri_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zpftri_work(int matrix_layout, char transr, char uplo, int n, _Complex double *a)
     * }
     */
    public static MemorySegment LAPACKE_zpftri_work$address() {
        return LAPACKE_zpftri_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zpftri_work(int matrix_layout, char transr, char uplo, int n, _Complex double *a)
     * }
     */
    public static int LAPACKE_zpftri_work(int matrix_layout, byte transr, byte uplo, int n, MemorySegment a) {
        var mh$ = LAPACKE_zpftri_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zpftri_work", matrix_layout, transr, uplo, n, a);
            }
            return (int)mh$.invokeExact(matrix_layout, transr, uplo, n, a);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_spftrs_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_spftrs_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_spftrs_work(int matrix_layout, char transr, char uplo, int n, int nrhs, const float *a, float *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_spftrs_work$descriptor() {
        return LAPACKE_spftrs_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_spftrs_work(int matrix_layout, char transr, char uplo, int n, int nrhs, const float *a, float *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_spftrs_work$handle() {
        return LAPACKE_spftrs_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_spftrs_work(int matrix_layout, char transr, char uplo, int n, int nrhs, const float *a, float *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_spftrs_work$address() {
        return LAPACKE_spftrs_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_spftrs_work(int matrix_layout, char transr, char uplo, int n, int nrhs, const float *a, float *b, int ldb)
     * }
     */
    public static int LAPACKE_spftrs_work(int matrix_layout, byte transr, byte uplo, int n, int nrhs, MemorySegment a, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_spftrs_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_spftrs_work", matrix_layout, transr, uplo, n, nrhs, a, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, transr, uplo, n, nrhs, a, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dpftrs_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dpftrs_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dpftrs_work(int matrix_layout, char transr, char uplo, int n, int nrhs, const double *a, double *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_dpftrs_work$descriptor() {
        return LAPACKE_dpftrs_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dpftrs_work(int matrix_layout, char transr, char uplo, int n, int nrhs, const double *a, double *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_dpftrs_work$handle() {
        return LAPACKE_dpftrs_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dpftrs_work(int matrix_layout, char transr, char uplo, int n, int nrhs, const double *a, double *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_dpftrs_work$address() {
        return LAPACKE_dpftrs_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dpftrs_work(int matrix_layout, char transr, char uplo, int n, int nrhs, const double *a, double *b, int ldb)
     * }
     */
    public static int LAPACKE_dpftrs_work(int matrix_layout, byte transr, byte uplo, int n, int nrhs, MemorySegment a, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_dpftrs_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dpftrs_work", matrix_layout, transr, uplo, n, nrhs, a, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, transr, uplo, n, nrhs, a, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cpftrs_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_cpftrs_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cpftrs_work(int matrix_layout, char transr, char uplo, int n, int nrhs, const _Complex float *a, _Complex float *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_cpftrs_work$descriptor() {
        return LAPACKE_cpftrs_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cpftrs_work(int matrix_layout, char transr, char uplo, int n, int nrhs, const _Complex float *a, _Complex float *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_cpftrs_work$handle() {
        return LAPACKE_cpftrs_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cpftrs_work(int matrix_layout, char transr, char uplo, int n, int nrhs, const _Complex float *a, _Complex float *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_cpftrs_work$address() {
        return LAPACKE_cpftrs_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cpftrs_work(int matrix_layout, char transr, char uplo, int n, int nrhs, const _Complex float *a, _Complex float *b, int ldb)
     * }
     */
    public static int LAPACKE_cpftrs_work(int matrix_layout, byte transr, byte uplo, int n, int nrhs, MemorySegment a, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_cpftrs_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cpftrs_work", matrix_layout, transr, uplo, n, nrhs, a, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, transr, uplo, n, nrhs, a, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zpftrs_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zpftrs_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zpftrs_work(int matrix_layout, char transr, char uplo, int n, int nrhs, const _Complex double *a, _Complex double *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_zpftrs_work$descriptor() {
        return LAPACKE_zpftrs_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zpftrs_work(int matrix_layout, char transr, char uplo, int n, int nrhs, const _Complex double *a, _Complex double *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_zpftrs_work$handle() {
        return LAPACKE_zpftrs_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zpftrs_work(int matrix_layout, char transr, char uplo, int n, int nrhs, const _Complex double *a, _Complex double *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_zpftrs_work$address() {
        return LAPACKE_zpftrs_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zpftrs_work(int matrix_layout, char transr, char uplo, int n, int nrhs, const _Complex double *a, _Complex double *b, int ldb)
     * }
     */
    public static int LAPACKE_zpftrs_work(int matrix_layout, byte transr, byte uplo, int n, int nrhs, MemorySegment a, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_zpftrs_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zpftrs_work", matrix_layout, transr, uplo, n, nrhs, a, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, transr, uplo, n, nrhs, a, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_spocon_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_FLOAT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_spocon_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_spocon_work(int matrix_layout, char uplo, int n, const float *a, int lda, float anorm, float *rcond, float *work, int *iwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_spocon_work$descriptor() {
        return LAPACKE_spocon_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_spocon_work(int matrix_layout, char uplo, int n, const float *a, int lda, float anorm, float *rcond, float *work, int *iwork)
     * }
     */
    public static MethodHandle LAPACKE_spocon_work$handle() {
        return LAPACKE_spocon_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_spocon_work(int matrix_layout, char uplo, int n, const float *a, int lda, float anorm, float *rcond, float *work, int *iwork)
     * }
     */
    public static MemorySegment LAPACKE_spocon_work$address() {
        return LAPACKE_spocon_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_spocon_work(int matrix_layout, char uplo, int n, const float *a, int lda, float anorm, float *rcond, float *work, int *iwork)
     * }
     */
    public static int LAPACKE_spocon_work(int matrix_layout, byte uplo, int n, MemorySegment a, int lda, float anorm, MemorySegment rcond, MemorySegment work, MemorySegment iwork) {
        var mh$ = LAPACKE_spocon_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_spocon_work", matrix_layout, uplo, n, a, lda, anorm, rcond, work, iwork);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, a, lda, anorm, rcond, work, iwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dpocon_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_DOUBLE,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dpocon_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dpocon_work(int matrix_layout, char uplo, int n, const double *a, int lda, double anorm, double *rcond, double *work, int *iwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_dpocon_work$descriptor() {
        return LAPACKE_dpocon_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dpocon_work(int matrix_layout, char uplo, int n, const double *a, int lda, double anorm, double *rcond, double *work, int *iwork)
     * }
     */
    public static MethodHandle LAPACKE_dpocon_work$handle() {
        return LAPACKE_dpocon_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dpocon_work(int matrix_layout, char uplo, int n, const double *a, int lda, double anorm, double *rcond, double *work, int *iwork)
     * }
     */
    public static MemorySegment LAPACKE_dpocon_work$address() {
        return LAPACKE_dpocon_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dpocon_work(int matrix_layout, char uplo, int n, const double *a, int lda, double anorm, double *rcond, double *work, int *iwork)
     * }
     */
    public static int LAPACKE_dpocon_work(int matrix_layout, byte uplo, int n, MemorySegment a, int lda, double anorm, MemorySegment rcond, MemorySegment work, MemorySegment iwork) {
        var mh$ = LAPACKE_dpocon_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dpocon_work", matrix_layout, uplo, n, a, lda, anorm, rcond, work, iwork);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, a, lda, anorm, rcond, work, iwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cpocon_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_FLOAT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_cpocon_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cpocon_work(int matrix_layout, char uplo, int n, const _Complex float *a, int lda, float anorm, float *rcond, _Complex float *work, float *rwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_cpocon_work$descriptor() {
        return LAPACKE_cpocon_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cpocon_work(int matrix_layout, char uplo, int n, const _Complex float *a, int lda, float anorm, float *rcond, _Complex float *work, float *rwork)
     * }
     */
    public static MethodHandle LAPACKE_cpocon_work$handle() {
        return LAPACKE_cpocon_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cpocon_work(int matrix_layout, char uplo, int n, const _Complex float *a, int lda, float anorm, float *rcond, _Complex float *work, float *rwork)
     * }
     */
    public static MemorySegment LAPACKE_cpocon_work$address() {
        return LAPACKE_cpocon_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cpocon_work(int matrix_layout, char uplo, int n, const _Complex float *a, int lda, float anorm, float *rcond, _Complex float *work, float *rwork)
     * }
     */
    public static int LAPACKE_cpocon_work(int matrix_layout, byte uplo, int n, MemorySegment a, int lda, float anorm, MemorySegment rcond, MemorySegment work, MemorySegment rwork) {
        var mh$ = LAPACKE_cpocon_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cpocon_work", matrix_layout, uplo, n, a, lda, anorm, rcond, work, rwork);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, a, lda, anorm, rcond, work, rwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zpocon_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_DOUBLE,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zpocon_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zpocon_work(int matrix_layout, char uplo, int n, const _Complex double *a, int lda, double anorm, double *rcond, _Complex double *work, double *rwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_zpocon_work$descriptor() {
        return LAPACKE_zpocon_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zpocon_work(int matrix_layout, char uplo, int n, const _Complex double *a, int lda, double anorm, double *rcond, _Complex double *work, double *rwork)
     * }
     */
    public static MethodHandle LAPACKE_zpocon_work$handle() {
        return LAPACKE_zpocon_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zpocon_work(int matrix_layout, char uplo, int n, const _Complex double *a, int lda, double anorm, double *rcond, _Complex double *work, double *rwork)
     * }
     */
    public static MemorySegment LAPACKE_zpocon_work$address() {
        return LAPACKE_zpocon_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zpocon_work(int matrix_layout, char uplo, int n, const _Complex double *a, int lda, double anorm, double *rcond, _Complex double *work, double *rwork)
     * }
     */
    public static int LAPACKE_zpocon_work(int matrix_layout, byte uplo, int n, MemorySegment a, int lda, double anorm, MemorySegment rcond, MemorySegment work, MemorySegment rwork) {
        var mh$ = LAPACKE_zpocon_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zpocon_work", matrix_layout, uplo, n, a, lda, anorm, rcond, work, rwork);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, a, lda, anorm, rcond, work, rwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_spoequ_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_spoequ_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_spoequ_work(int matrix_layout, int n, const float *a, int lda, float *s, float *scond, float *amax)
     * }
     */
    public static FunctionDescriptor LAPACKE_spoequ_work$descriptor() {
        return LAPACKE_spoequ_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_spoequ_work(int matrix_layout, int n, const float *a, int lda, float *s, float *scond, float *amax)
     * }
     */
    public static MethodHandle LAPACKE_spoequ_work$handle() {
        return LAPACKE_spoequ_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_spoequ_work(int matrix_layout, int n, const float *a, int lda, float *s, float *scond, float *amax)
     * }
     */
    public static MemorySegment LAPACKE_spoequ_work$address() {
        return LAPACKE_spoequ_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_spoequ_work(int matrix_layout, int n, const float *a, int lda, float *s, float *scond, float *amax)
     * }
     */
    public static int LAPACKE_spoequ_work(int matrix_layout, int n, MemorySegment a, int lda, MemorySegment s, MemorySegment scond, MemorySegment amax) {
        var mh$ = LAPACKE_spoequ_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_spoequ_work", matrix_layout, n, a, lda, s, scond, amax);
            }
            return (int)mh$.invokeExact(matrix_layout, n, a, lda, s, scond, amax);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dpoequ_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dpoequ_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dpoequ_work(int matrix_layout, int n, const double *a, int lda, double *s, double *scond, double *amax)
     * }
     */
    public static FunctionDescriptor LAPACKE_dpoequ_work$descriptor() {
        return LAPACKE_dpoequ_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dpoequ_work(int matrix_layout, int n, const double *a, int lda, double *s, double *scond, double *amax)
     * }
     */
    public static MethodHandle LAPACKE_dpoequ_work$handle() {
        return LAPACKE_dpoequ_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dpoequ_work(int matrix_layout, int n, const double *a, int lda, double *s, double *scond, double *amax)
     * }
     */
    public static MemorySegment LAPACKE_dpoequ_work$address() {
        return LAPACKE_dpoequ_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dpoequ_work(int matrix_layout, int n, const double *a, int lda, double *s, double *scond, double *amax)
     * }
     */
    public static int LAPACKE_dpoequ_work(int matrix_layout, int n, MemorySegment a, int lda, MemorySegment s, MemorySegment scond, MemorySegment amax) {
        var mh$ = LAPACKE_dpoequ_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dpoequ_work", matrix_layout, n, a, lda, s, scond, amax);
            }
            return (int)mh$.invokeExact(matrix_layout, n, a, lda, s, scond, amax);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cpoequ_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_cpoequ_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cpoequ_work(int matrix_layout, int n, const _Complex float *a, int lda, float *s, float *scond, float *amax)
     * }
     */
    public static FunctionDescriptor LAPACKE_cpoequ_work$descriptor() {
        return LAPACKE_cpoequ_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cpoequ_work(int matrix_layout, int n, const _Complex float *a, int lda, float *s, float *scond, float *amax)
     * }
     */
    public static MethodHandle LAPACKE_cpoequ_work$handle() {
        return LAPACKE_cpoequ_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cpoequ_work(int matrix_layout, int n, const _Complex float *a, int lda, float *s, float *scond, float *amax)
     * }
     */
    public static MemorySegment LAPACKE_cpoequ_work$address() {
        return LAPACKE_cpoequ_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cpoequ_work(int matrix_layout, int n, const _Complex float *a, int lda, float *s, float *scond, float *amax)
     * }
     */
    public static int LAPACKE_cpoequ_work(int matrix_layout, int n, MemorySegment a, int lda, MemorySegment s, MemorySegment scond, MemorySegment amax) {
        var mh$ = LAPACKE_cpoequ_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cpoequ_work", matrix_layout, n, a, lda, s, scond, amax);
            }
            return (int)mh$.invokeExact(matrix_layout, n, a, lda, s, scond, amax);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zpoequ_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zpoequ_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zpoequ_work(int matrix_layout, int n, const _Complex double *a, int lda, double *s, double *scond, double *amax)
     * }
     */
    public static FunctionDescriptor LAPACKE_zpoequ_work$descriptor() {
        return LAPACKE_zpoequ_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zpoequ_work(int matrix_layout, int n, const _Complex double *a, int lda, double *s, double *scond, double *amax)
     * }
     */
    public static MethodHandle LAPACKE_zpoequ_work$handle() {
        return LAPACKE_zpoequ_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zpoequ_work(int matrix_layout, int n, const _Complex double *a, int lda, double *s, double *scond, double *amax)
     * }
     */
    public static MemorySegment LAPACKE_zpoequ_work$address() {
        return LAPACKE_zpoequ_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zpoequ_work(int matrix_layout, int n, const _Complex double *a, int lda, double *s, double *scond, double *amax)
     * }
     */
    public static int LAPACKE_zpoequ_work(int matrix_layout, int n, MemorySegment a, int lda, MemorySegment s, MemorySegment scond, MemorySegment amax) {
        var mh$ = LAPACKE_zpoequ_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zpoequ_work", matrix_layout, n, a, lda, s, scond, amax);
            }
            return (int)mh$.invokeExact(matrix_layout, n, a, lda, s, scond, amax);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_spoequb_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_spoequb_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_spoequb_work(int matrix_layout, int n, const float *a, int lda, float *s, float *scond, float *amax)
     * }
     */
    public static FunctionDescriptor LAPACKE_spoequb_work$descriptor() {
        return LAPACKE_spoequb_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_spoequb_work(int matrix_layout, int n, const float *a, int lda, float *s, float *scond, float *amax)
     * }
     */
    public static MethodHandle LAPACKE_spoequb_work$handle() {
        return LAPACKE_spoequb_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_spoequb_work(int matrix_layout, int n, const float *a, int lda, float *s, float *scond, float *amax)
     * }
     */
    public static MemorySegment LAPACKE_spoequb_work$address() {
        return LAPACKE_spoequb_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_spoequb_work(int matrix_layout, int n, const float *a, int lda, float *s, float *scond, float *amax)
     * }
     */
    public static int LAPACKE_spoequb_work(int matrix_layout, int n, MemorySegment a, int lda, MemorySegment s, MemorySegment scond, MemorySegment amax) {
        var mh$ = LAPACKE_spoequb_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_spoequb_work", matrix_layout, n, a, lda, s, scond, amax);
            }
            return (int)mh$.invokeExact(matrix_layout, n, a, lda, s, scond, amax);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dpoequb_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dpoequb_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dpoequb_work(int matrix_layout, int n, const double *a, int lda, double *s, double *scond, double *amax)
     * }
     */
    public static FunctionDescriptor LAPACKE_dpoequb_work$descriptor() {
        return LAPACKE_dpoequb_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dpoequb_work(int matrix_layout, int n, const double *a, int lda, double *s, double *scond, double *amax)
     * }
     */
    public static MethodHandle LAPACKE_dpoequb_work$handle() {
        return LAPACKE_dpoequb_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dpoequb_work(int matrix_layout, int n, const double *a, int lda, double *s, double *scond, double *amax)
     * }
     */
    public static MemorySegment LAPACKE_dpoequb_work$address() {
        return LAPACKE_dpoequb_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dpoequb_work(int matrix_layout, int n, const double *a, int lda, double *s, double *scond, double *amax)
     * }
     */
    public static int LAPACKE_dpoequb_work(int matrix_layout, int n, MemorySegment a, int lda, MemorySegment s, MemorySegment scond, MemorySegment amax) {
        var mh$ = LAPACKE_dpoequb_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dpoequb_work", matrix_layout, n, a, lda, s, scond, amax);
            }
            return (int)mh$.invokeExact(matrix_layout, n, a, lda, s, scond, amax);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cpoequb_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_cpoequb_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cpoequb_work(int matrix_layout, int n, const _Complex float *a, int lda, float *s, float *scond, float *amax)
     * }
     */
    public static FunctionDescriptor LAPACKE_cpoequb_work$descriptor() {
        return LAPACKE_cpoequb_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cpoequb_work(int matrix_layout, int n, const _Complex float *a, int lda, float *s, float *scond, float *amax)
     * }
     */
    public static MethodHandle LAPACKE_cpoequb_work$handle() {
        return LAPACKE_cpoequb_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cpoequb_work(int matrix_layout, int n, const _Complex float *a, int lda, float *s, float *scond, float *amax)
     * }
     */
    public static MemorySegment LAPACKE_cpoequb_work$address() {
        return LAPACKE_cpoequb_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cpoequb_work(int matrix_layout, int n, const _Complex float *a, int lda, float *s, float *scond, float *amax)
     * }
     */
    public static int LAPACKE_cpoequb_work(int matrix_layout, int n, MemorySegment a, int lda, MemorySegment s, MemorySegment scond, MemorySegment amax) {
        var mh$ = LAPACKE_cpoequb_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cpoequb_work", matrix_layout, n, a, lda, s, scond, amax);
            }
            return (int)mh$.invokeExact(matrix_layout, n, a, lda, s, scond, amax);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zpoequb_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zpoequb_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zpoequb_work(int matrix_layout, int n, const _Complex double *a, int lda, double *s, double *scond, double *amax)
     * }
     */
    public static FunctionDescriptor LAPACKE_zpoequb_work$descriptor() {
        return LAPACKE_zpoequb_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zpoequb_work(int matrix_layout, int n, const _Complex double *a, int lda, double *s, double *scond, double *amax)
     * }
     */
    public static MethodHandle LAPACKE_zpoequb_work$handle() {
        return LAPACKE_zpoequb_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zpoequb_work(int matrix_layout, int n, const _Complex double *a, int lda, double *s, double *scond, double *amax)
     * }
     */
    public static MemorySegment LAPACKE_zpoequb_work$address() {
        return LAPACKE_zpoequb_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zpoequb_work(int matrix_layout, int n, const _Complex double *a, int lda, double *s, double *scond, double *amax)
     * }
     */
    public static int LAPACKE_zpoequb_work(int matrix_layout, int n, MemorySegment a, int lda, MemorySegment s, MemorySegment scond, MemorySegment amax) {
        var mh$ = LAPACKE_zpoequb_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zpoequb_work", matrix_layout, n, a, lda, s, scond, amax);
            }
            return (int)mh$.invokeExact(matrix_layout, n, a, lda, s, scond, amax);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sporfs_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_sporfs_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sporfs_work(int matrix_layout, char uplo, int n, int nrhs, const float *a, int lda, const float *af, int ldaf, const float *b, int ldb, float *x, int ldx, float *ferr, float *berr, float *work, int *iwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_sporfs_work$descriptor() {
        return LAPACKE_sporfs_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sporfs_work(int matrix_layout, char uplo, int n, int nrhs, const float *a, int lda, const float *af, int ldaf, const float *b, int ldb, float *x, int ldx, float *ferr, float *berr, float *work, int *iwork)
     * }
     */
    public static MethodHandle LAPACKE_sporfs_work$handle() {
        return LAPACKE_sporfs_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sporfs_work(int matrix_layout, char uplo, int n, int nrhs, const float *a, int lda, const float *af, int ldaf, const float *b, int ldb, float *x, int ldx, float *ferr, float *berr, float *work, int *iwork)
     * }
     */
    public static MemorySegment LAPACKE_sporfs_work$address() {
        return LAPACKE_sporfs_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sporfs_work(int matrix_layout, char uplo, int n, int nrhs, const float *a, int lda, const float *af, int ldaf, const float *b, int ldb, float *x, int ldx, float *ferr, float *berr, float *work, int *iwork)
     * }
     */
    public static int LAPACKE_sporfs_work(int matrix_layout, byte uplo, int n, int nrhs, MemorySegment a, int lda, MemorySegment af, int ldaf, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment ferr, MemorySegment berr, MemorySegment work, MemorySegment iwork) {
        var mh$ = LAPACKE_sporfs_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sporfs_work", matrix_layout, uplo, n, nrhs, a, lda, af, ldaf, b, ldb, x, ldx, ferr, berr, work, iwork);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, nrhs, a, lda, af, ldaf, b, ldb, x, ldx, ferr, berr, work, iwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dporfs_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dporfs_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dporfs_work(int matrix_layout, char uplo, int n, int nrhs, const double *a, int lda, const double *af, int ldaf, const double *b, int ldb, double *x, int ldx, double *ferr, double *berr, double *work, int *iwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_dporfs_work$descriptor() {
        return LAPACKE_dporfs_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dporfs_work(int matrix_layout, char uplo, int n, int nrhs, const double *a, int lda, const double *af, int ldaf, const double *b, int ldb, double *x, int ldx, double *ferr, double *berr, double *work, int *iwork)
     * }
     */
    public static MethodHandle LAPACKE_dporfs_work$handle() {
        return LAPACKE_dporfs_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dporfs_work(int matrix_layout, char uplo, int n, int nrhs, const double *a, int lda, const double *af, int ldaf, const double *b, int ldb, double *x, int ldx, double *ferr, double *berr, double *work, int *iwork)
     * }
     */
    public static MemorySegment LAPACKE_dporfs_work$address() {
        return LAPACKE_dporfs_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dporfs_work(int matrix_layout, char uplo, int n, int nrhs, const double *a, int lda, const double *af, int ldaf, const double *b, int ldb, double *x, int ldx, double *ferr, double *berr, double *work, int *iwork)
     * }
     */
    public static int LAPACKE_dporfs_work(int matrix_layout, byte uplo, int n, int nrhs, MemorySegment a, int lda, MemorySegment af, int ldaf, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment ferr, MemorySegment berr, MemorySegment work, MemorySegment iwork) {
        var mh$ = LAPACKE_dporfs_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dporfs_work", matrix_layout, uplo, n, nrhs, a, lda, af, ldaf, b, ldb, x, ldx, ferr, berr, work, iwork);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, nrhs, a, lda, af, ldaf, b, ldb, x, ldx, ferr, berr, work, iwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cporfs_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_cporfs_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cporfs_work(int matrix_layout, char uplo, int n, int nrhs, const _Complex float *a, int lda, const _Complex float *af, int ldaf, const _Complex float *b, int ldb, _Complex float *x, int ldx, float *ferr, float *berr, _Complex float *work, float *rwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_cporfs_work$descriptor() {
        return LAPACKE_cporfs_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cporfs_work(int matrix_layout, char uplo, int n, int nrhs, const _Complex float *a, int lda, const _Complex float *af, int ldaf, const _Complex float *b, int ldb, _Complex float *x, int ldx, float *ferr, float *berr, _Complex float *work, float *rwork)
     * }
     */
    public static MethodHandle LAPACKE_cporfs_work$handle() {
        return LAPACKE_cporfs_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cporfs_work(int matrix_layout, char uplo, int n, int nrhs, const _Complex float *a, int lda, const _Complex float *af, int ldaf, const _Complex float *b, int ldb, _Complex float *x, int ldx, float *ferr, float *berr, _Complex float *work, float *rwork)
     * }
     */
    public static MemorySegment LAPACKE_cporfs_work$address() {
        return LAPACKE_cporfs_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cporfs_work(int matrix_layout, char uplo, int n, int nrhs, const _Complex float *a, int lda, const _Complex float *af, int ldaf, const _Complex float *b, int ldb, _Complex float *x, int ldx, float *ferr, float *berr, _Complex float *work, float *rwork)
     * }
     */
    public static int LAPACKE_cporfs_work(int matrix_layout, byte uplo, int n, int nrhs, MemorySegment a, int lda, MemorySegment af, int ldaf, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment ferr, MemorySegment berr, MemorySegment work, MemorySegment rwork) {
        var mh$ = LAPACKE_cporfs_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cporfs_work", matrix_layout, uplo, n, nrhs, a, lda, af, ldaf, b, ldb, x, ldx, ferr, berr, work, rwork);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, nrhs, a, lda, af, ldaf, b, ldb, x, ldx, ferr, berr, work, rwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zporfs_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zporfs_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zporfs_work(int matrix_layout, char uplo, int n, int nrhs, const _Complex double *a, int lda, const _Complex double *af, int ldaf, const _Complex double *b, int ldb, _Complex double *x, int ldx, double *ferr, double *berr, _Complex double *work, double *rwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_zporfs_work$descriptor() {
        return LAPACKE_zporfs_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zporfs_work(int matrix_layout, char uplo, int n, int nrhs, const _Complex double *a, int lda, const _Complex double *af, int ldaf, const _Complex double *b, int ldb, _Complex double *x, int ldx, double *ferr, double *berr, _Complex double *work, double *rwork)
     * }
     */
    public static MethodHandle LAPACKE_zporfs_work$handle() {
        return LAPACKE_zporfs_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zporfs_work(int matrix_layout, char uplo, int n, int nrhs, const _Complex double *a, int lda, const _Complex double *af, int ldaf, const _Complex double *b, int ldb, _Complex double *x, int ldx, double *ferr, double *berr, _Complex double *work, double *rwork)
     * }
     */
    public static MemorySegment LAPACKE_zporfs_work$address() {
        return LAPACKE_zporfs_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zporfs_work(int matrix_layout, char uplo, int n, int nrhs, const _Complex double *a, int lda, const _Complex double *af, int ldaf, const _Complex double *b, int ldb, _Complex double *x, int ldx, double *ferr, double *berr, _Complex double *work, double *rwork)
     * }
     */
    public static int LAPACKE_zporfs_work(int matrix_layout, byte uplo, int n, int nrhs, MemorySegment a, int lda, MemorySegment af, int ldaf, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment ferr, MemorySegment berr, MemorySegment work, MemorySegment rwork) {
        var mh$ = LAPACKE_zporfs_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zporfs_work", matrix_layout, uplo, n, nrhs, a, lda, af, ldaf, b, ldb, x, ldx, ferr, berr, work, rwork);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, nrhs, a, lda, af, ldaf, b, ldb, x, ldx, ferr, berr, work, rwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sporfsx_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_sporfsx_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sporfsx_work(int matrix_layout, char uplo, char equed, int n, int nrhs, const float *a, int lda, const float *af, int ldaf, const float *s, const float *b, int ldb, float *x, int ldx, float *rcond, float *berr, int n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, int nparams, float *params, float *work, int *iwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_sporfsx_work$descriptor() {
        return LAPACKE_sporfsx_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sporfsx_work(int matrix_layout, char uplo, char equed, int n, int nrhs, const float *a, int lda, const float *af, int ldaf, const float *s, const float *b, int ldb, float *x, int ldx, float *rcond, float *berr, int n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, int nparams, float *params, float *work, int *iwork)
     * }
     */
    public static MethodHandle LAPACKE_sporfsx_work$handle() {
        return LAPACKE_sporfsx_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sporfsx_work(int matrix_layout, char uplo, char equed, int n, int nrhs, const float *a, int lda, const float *af, int ldaf, const float *s, const float *b, int ldb, float *x, int ldx, float *rcond, float *berr, int n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, int nparams, float *params, float *work, int *iwork)
     * }
     */
    public static MemorySegment LAPACKE_sporfsx_work$address() {
        return LAPACKE_sporfsx_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sporfsx_work(int matrix_layout, char uplo, char equed, int n, int nrhs, const float *a, int lda, const float *af, int ldaf, const float *s, const float *b, int ldb, float *x, int ldx, float *rcond, float *berr, int n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, int nparams, float *params, float *work, int *iwork)
     * }
     */
    public static int LAPACKE_sporfsx_work(int matrix_layout, byte uplo, byte equed, int n, int nrhs, MemorySegment a, int lda, MemorySegment af, int ldaf, MemorySegment s, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment rcond, MemorySegment berr, int n_err_bnds, MemorySegment err_bnds_norm, MemorySegment err_bnds_comp, int nparams, MemorySegment params, MemorySegment work, MemorySegment iwork) {
        var mh$ = LAPACKE_sporfsx_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sporfsx_work", matrix_layout, uplo, equed, n, nrhs, a, lda, af, ldaf, s, b, ldb, x, ldx, rcond, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params, work, iwork);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, equed, n, nrhs, a, lda, af, ldaf, s, b, ldb, x, ldx, rcond, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params, work, iwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dporfsx_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dporfsx_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dporfsx_work(int matrix_layout, char uplo, char equed, int n, int nrhs, const double *a, int lda, const double *af, int ldaf, const double *s, const double *b, int ldb, double *x, int ldx, double *rcond, double *berr, int n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, int nparams, double *params, double *work, int *iwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_dporfsx_work$descriptor() {
        return LAPACKE_dporfsx_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dporfsx_work(int matrix_layout, char uplo, char equed, int n, int nrhs, const double *a, int lda, const double *af, int ldaf, const double *s, const double *b, int ldb, double *x, int ldx, double *rcond, double *berr, int n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, int nparams, double *params, double *work, int *iwork)
     * }
     */
    public static MethodHandle LAPACKE_dporfsx_work$handle() {
        return LAPACKE_dporfsx_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dporfsx_work(int matrix_layout, char uplo, char equed, int n, int nrhs, const double *a, int lda, const double *af, int ldaf, const double *s, const double *b, int ldb, double *x, int ldx, double *rcond, double *berr, int n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, int nparams, double *params, double *work, int *iwork)
     * }
     */
    public static MemorySegment LAPACKE_dporfsx_work$address() {
        return LAPACKE_dporfsx_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dporfsx_work(int matrix_layout, char uplo, char equed, int n, int nrhs, const double *a, int lda, const double *af, int ldaf, const double *s, const double *b, int ldb, double *x, int ldx, double *rcond, double *berr, int n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, int nparams, double *params, double *work, int *iwork)
     * }
     */
    public static int LAPACKE_dporfsx_work(int matrix_layout, byte uplo, byte equed, int n, int nrhs, MemorySegment a, int lda, MemorySegment af, int ldaf, MemorySegment s, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment rcond, MemorySegment berr, int n_err_bnds, MemorySegment err_bnds_norm, MemorySegment err_bnds_comp, int nparams, MemorySegment params, MemorySegment work, MemorySegment iwork) {
        var mh$ = LAPACKE_dporfsx_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dporfsx_work", matrix_layout, uplo, equed, n, nrhs, a, lda, af, ldaf, s, b, ldb, x, ldx, rcond, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params, work, iwork);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, equed, n, nrhs, a, lda, af, ldaf, s, b, ldb, x, ldx, rcond, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params, work, iwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cporfsx_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_cporfsx_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cporfsx_work(int matrix_layout, char uplo, char equed, int n, int nrhs, const _Complex float *a, int lda, const _Complex float *af, int ldaf, const float *s, const _Complex float *b, int ldb, _Complex float *x, int ldx, float *rcond, float *berr, int n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, int nparams, float *params, _Complex float *work, float *rwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_cporfsx_work$descriptor() {
        return LAPACKE_cporfsx_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cporfsx_work(int matrix_layout, char uplo, char equed, int n, int nrhs, const _Complex float *a, int lda, const _Complex float *af, int ldaf, const float *s, const _Complex float *b, int ldb, _Complex float *x, int ldx, float *rcond, float *berr, int n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, int nparams, float *params, _Complex float *work, float *rwork)
     * }
     */
    public static MethodHandle LAPACKE_cporfsx_work$handle() {
        return LAPACKE_cporfsx_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cporfsx_work(int matrix_layout, char uplo, char equed, int n, int nrhs, const _Complex float *a, int lda, const _Complex float *af, int ldaf, const float *s, const _Complex float *b, int ldb, _Complex float *x, int ldx, float *rcond, float *berr, int n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, int nparams, float *params, _Complex float *work, float *rwork)
     * }
     */
    public static MemorySegment LAPACKE_cporfsx_work$address() {
        return LAPACKE_cporfsx_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cporfsx_work(int matrix_layout, char uplo, char equed, int n, int nrhs, const _Complex float *a, int lda, const _Complex float *af, int ldaf, const float *s, const _Complex float *b, int ldb, _Complex float *x, int ldx, float *rcond, float *berr, int n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, int nparams, float *params, _Complex float *work, float *rwork)
     * }
     */
    public static int LAPACKE_cporfsx_work(int matrix_layout, byte uplo, byte equed, int n, int nrhs, MemorySegment a, int lda, MemorySegment af, int ldaf, MemorySegment s, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment rcond, MemorySegment berr, int n_err_bnds, MemorySegment err_bnds_norm, MemorySegment err_bnds_comp, int nparams, MemorySegment params, MemorySegment work, MemorySegment rwork) {
        var mh$ = LAPACKE_cporfsx_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cporfsx_work", matrix_layout, uplo, equed, n, nrhs, a, lda, af, ldaf, s, b, ldb, x, ldx, rcond, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params, work, rwork);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, equed, n, nrhs, a, lda, af, ldaf, s, b, ldb, x, ldx, rcond, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params, work, rwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zporfsx_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zporfsx_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zporfsx_work(int matrix_layout, char uplo, char equed, int n, int nrhs, const _Complex double *a, int lda, const _Complex double *af, int ldaf, const double *s, const _Complex double *b, int ldb, _Complex double *x, int ldx, double *rcond, double *berr, int n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, int nparams, double *params, _Complex double *work, double *rwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_zporfsx_work$descriptor() {
        return LAPACKE_zporfsx_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zporfsx_work(int matrix_layout, char uplo, char equed, int n, int nrhs, const _Complex double *a, int lda, const _Complex double *af, int ldaf, const double *s, const _Complex double *b, int ldb, _Complex double *x, int ldx, double *rcond, double *berr, int n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, int nparams, double *params, _Complex double *work, double *rwork)
     * }
     */
    public static MethodHandle LAPACKE_zporfsx_work$handle() {
        return LAPACKE_zporfsx_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zporfsx_work(int matrix_layout, char uplo, char equed, int n, int nrhs, const _Complex double *a, int lda, const _Complex double *af, int ldaf, const double *s, const _Complex double *b, int ldb, _Complex double *x, int ldx, double *rcond, double *berr, int n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, int nparams, double *params, _Complex double *work, double *rwork)
     * }
     */
    public static MemorySegment LAPACKE_zporfsx_work$address() {
        return LAPACKE_zporfsx_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zporfsx_work(int matrix_layout, char uplo, char equed, int n, int nrhs, const _Complex double *a, int lda, const _Complex double *af, int ldaf, const double *s, const _Complex double *b, int ldb, _Complex double *x, int ldx, double *rcond, double *berr, int n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, int nparams, double *params, _Complex double *work, double *rwork)
     * }
     */
    public static int LAPACKE_zporfsx_work(int matrix_layout, byte uplo, byte equed, int n, int nrhs, MemorySegment a, int lda, MemorySegment af, int ldaf, MemorySegment s, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment rcond, MemorySegment berr, int n_err_bnds, MemorySegment err_bnds_norm, MemorySegment err_bnds_comp, int nparams, MemorySegment params, MemorySegment work, MemorySegment rwork) {
        var mh$ = LAPACKE_zporfsx_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zporfsx_work", matrix_layout, uplo, equed, n, nrhs, a, lda, af, ldaf, s, b, ldb, x, ldx, rcond, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params, work, rwork);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, equed, n, nrhs, a, lda, af, ldaf, s, b, ldb, x, ldx, rcond, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params, work, rwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sposv_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_sposv_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sposv_work(int matrix_layout, char uplo, int n, int nrhs, float *a, int lda, float *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_sposv_work$descriptor() {
        return LAPACKE_sposv_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sposv_work(int matrix_layout, char uplo, int n, int nrhs, float *a, int lda, float *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_sposv_work$handle() {
        return LAPACKE_sposv_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sposv_work(int matrix_layout, char uplo, int n, int nrhs, float *a, int lda, float *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_sposv_work$address() {
        return LAPACKE_sposv_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sposv_work(int matrix_layout, char uplo, int n, int nrhs, float *a, int lda, float *b, int ldb)
     * }
     */
    public static int LAPACKE_sposv_work(int matrix_layout, byte uplo, int n, int nrhs, MemorySegment a, int lda, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_sposv_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sposv_work", matrix_layout, uplo, n, nrhs, a, lda, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, nrhs, a, lda, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dposv_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dposv_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dposv_work(int matrix_layout, char uplo, int n, int nrhs, double *a, int lda, double *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_dposv_work$descriptor() {
        return LAPACKE_dposv_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dposv_work(int matrix_layout, char uplo, int n, int nrhs, double *a, int lda, double *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_dposv_work$handle() {
        return LAPACKE_dposv_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dposv_work(int matrix_layout, char uplo, int n, int nrhs, double *a, int lda, double *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_dposv_work$address() {
        return LAPACKE_dposv_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dposv_work(int matrix_layout, char uplo, int n, int nrhs, double *a, int lda, double *b, int ldb)
     * }
     */
    public static int LAPACKE_dposv_work(int matrix_layout, byte uplo, int n, int nrhs, MemorySegment a, int lda, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_dposv_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dposv_work", matrix_layout, uplo, n, nrhs, a, lda, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, nrhs, a, lda, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cposv_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_cposv_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cposv_work(int matrix_layout, char uplo, int n, int nrhs, _Complex float *a, int lda, _Complex float *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_cposv_work$descriptor() {
        return LAPACKE_cposv_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cposv_work(int matrix_layout, char uplo, int n, int nrhs, _Complex float *a, int lda, _Complex float *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_cposv_work$handle() {
        return LAPACKE_cposv_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cposv_work(int matrix_layout, char uplo, int n, int nrhs, _Complex float *a, int lda, _Complex float *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_cposv_work$address() {
        return LAPACKE_cposv_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cposv_work(int matrix_layout, char uplo, int n, int nrhs, _Complex float *a, int lda, _Complex float *b, int ldb)
     * }
     */
    public static int LAPACKE_cposv_work(int matrix_layout, byte uplo, int n, int nrhs, MemorySegment a, int lda, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_cposv_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cposv_work", matrix_layout, uplo, n, nrhs, a, lda, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, nrhs, a, lda, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zposv_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zposv_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zposv_work(int matrix_layout, char uplo, int n, int nrhs, _Complex double *a, int lda, _Complex double *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_zposv_work$descriptor() {
        return LAPACKE_zposv_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zposv_work(int matrix_layout, char uplo, int n, int nrhs, _Complex double *a, int lda, _Complex double *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_zposv_work$handle() {
        return LAPACKE_zposv_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zposv_work(int matrix_layout, char uplo, int n, int nrhs, _Complex double *a, int lda, _Complex double *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_zposv_work$address() {
        return LAPACKE_zposv_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zposv_work(int matrix_layout, char uplo, int n, int nrhs, _Complex double *a, int lda, _Complex double *b, int ldb)
     * }
     */
    public static int LAPACKE_zposv_work(int matrix_layout, byte uplo, int n, int nrhs, MemorySegment a, int lda, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_zposv_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zposv_work", matrix_layout, uplo, n, nrhs, a, lda, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, nrhs, a, lda, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dsposv_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dsposv_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dsposv_work(int matrix_layout, char uplo, int n, int nrhs, double *a, int lda, double *b, int ldb, double *x, int ldx, double *work, float *swork, int *iter)
     * }
     */
    public static FunctionDescriptor LAPACKE_dsposv_work$descriptor() {
        return LAPACKE_dsposv_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dsposv_work(int matrix_layout, char uplo, int n, int nrhs, double *a, int lda, double *b, int ldb, double *x, int ldx, double *work, float *swork, int *iter)
     * }
     */
    public static MethodHandle LAPACKE_dsposv_work$handle() {
        return LAPACKE_dsposv_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dsposv_work(int matrix_layout, char uplo, int n, int nrhs, double *a, int lda, double *b, int ldb, double *x, int ldx, double *work, float *swork, int *iter)
     * }
     */
    public static MemorySegment LAPACKE_dsposv_work$address() {
        return LAPACKE_dsposv_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dsposv_work(int matrix_layout, char uplo, int n, int nrhs, double *a, int lda, double *b, int ldb, double *x, int ldx, double *work, float *swork, int *iter)
     * }
     */
    public static int LAPACKE_dsposv_work(int matrix_layout, byte uplo, int n, int nrhs, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment work, MemorySegment swork, MemorySegment iter) {
        var mh$ = LAPACKE_dsposv_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dsposv_work", matrix_layout, uplo, n, nrhs, a, lda, b, ldb, x, ldx, work, swork, iter);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, nrhs, a, lda, b, ldb, x, ldx, work, swork, iter);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zcposv_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zcposv_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zcposv_work(int matrix_layout, char uplo, int n, int nrhs, _Complex double *a, int lda, _Complex double *b, int ldb, _Complex double *x, int ldx, _Complex double *work, _Complex float *swork, double *rwork, int *iter)
     * }
     */
    public static FunctionDescriptor LAPACKE_zcposv_work$descriptor() {
        return LAPACKE_zcposv_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zcposv_work(int matrix_layout, char uplo, int n, int nrhs, _Complex double *a, int lda, _Complex double *b, int ldb, _Complex double *x, int ldx, _Complex double *work, _Complex float *swork, double *rwork, int *iter)
     * }
     */
    public static MethodHandle LAPACKE_zcposv_work$handle() {
        return LAPACKE_zcposv_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zcposv_work(int matrix_layout, char uplo, int n, int nrhs, _Complex double *a, int lda, _Complex double *b, int ldb, _Complex double *x, int ldx, _Complex double *work, _Complex float *swork, double *rwork, int *iter)
     * }
     */
    public static MemorySegment LAPACKE_zcposv_work$address() {
        return LAPACKE_zcposv_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zcposv_work(int matrix_layout, char uplo, int n, int nrhs, _Complex double *a, int lda, _Complex double *b, int ldb, _Complex double *x, int ldx, _Complex double *work, _Complex float *swork, double *rwork, int *iter)
     * }
     */
    public static int LAPACKE_zcposv_work(int matrix_layout, byte uplo, int n, int nrhs, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment work, MemorySegment swork, MemorySegment rwork, MemorySegment iter) {
        var mh$ = LAPACKE_zcposv_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zcposv_work", matrix_layout, uplo, n, nrhs, a, lda, b, ldb, x, ldx, work, swork, rwork, iter);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, nrhs, a, lda, b, ldb, x, ldx, work, swork, rwork, iter);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sposvx_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_sposvx_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sposvx_work(int matrix_layout, char fact, char uplo, int n, int nrhs, float *a, int lda, float *af, int ldaf, char *equed, float *s, float *b, int ldb, float *x, int ldx, float *rcond, float *ferr, float *berr, float *work, int *iwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_sposvx_work$descriptor() {
        return LAPACKE_sposvx_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sposvx_work(int matrix_layout, char fact, char uplo, int n, int nrhs, float *a, int lda, float *af, int ldaf, char *equed, float *s, float *b, int ldb, float *x, int ldx, float *rcond, float *ferr, float *berr, float *work, int *iwork)
     * }
     */
    public static MethodHandle LAPACKE_sposvx_work$handle() {
        return LAPACKE_sposvx_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sposvx_work(int matrix_layout, char fact, char uplo, int n, int nrhs, float *a, int lda, float *af, int ldaf, char *equed, float *s, float *b, int ldb, float *x, int ldx, float *rcond, float *ferr, float *berr, float *work, int *iwork)
     * }
     */
    public static MemorySegment LAPACKE_sposvx_work$address() {
        return LAPACKE_sposvx_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sposvx_work(int matrix_layout, char fact, char uplo, int n, int nrhs, float *a, int lda, float *af, int ldaf, char *equed, float *s, float *b, int ldb, float *x, int ldx, float *rcond, float *ferr, float *berr, float *work, int *iwork)
     * }
     */
    public static int LAPACKE_sposvx_work(int matrix_layout, byte fact, byte uplo, int n, int nrhs, MemorySegment a, int lda, MemorySegment af, int ldaf, MemorySegment equed, MemorySegment s, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment rcond, MemorySegment ferr, MemorySegment berr, MemorySegment work, MemorySegment iwork) {
        var mh$ = LAPACKE_sposvx_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sposvx_work", matrix_layout, fact, uplo, n, nrhs, a, lda, af, ldaf, equed, s, b, ldb, x, ldx, rcond, ferr, berr, work, iwork);
            }
            return (int)mh$.invokeExact(matrix_layout, fact, uplo, n, nrhs, a, lda, af, ldaf, equed, s, b, ldb, x, ldx, rcond, ferr, berr, work, iwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dposvx_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dposvx_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dposvx_work(int matrix_layout, char fact, char uplo, int n, int nrhs, double *a, int lda, double *af, int ldaf, char *equed, double *s, double *b, int ldb, double *x, int ldx, double *rcond, double *ferr, double *berr, double *work, int *iwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_dposvx_work$descriptor() {
        return LAPACKE_dposvx_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dposvx_work(int matrix_layout, char fact, char uplo, int n, int nrhs, double *a, int lda, double *af, int ldaf, char *equed, double *s, double *b, int ldb, double *x, int ldx, double *rcond, double *ferr, double *berr, double *work, int *iwork)
     * }
     */
    public static MethodHandle LAPACKE_dposvx_work$handle() {
        return LAPACKE_dposvx_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dposvx_work(int matrix_layout, char fact, char uplo, int n, int nrhs, double *a, int lda, double *af, int ldaf, char *equed, double *s, double *b, int ldb, double *x, int ldx, double *rcond, double *ferr, double *berr, double *work, int *iwork)
     * }
     */
    public static MemorySegment LAPACKE_dposvx_work$address() {
        return LAPACKE_dposvx_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dposvx_work(int matrix_layout, char fact, char uplo, int n, int nrhs, double *a, int lda, double *af, int ldaf, char *equed, double *s, double *b, int ldb, double *x, int ldx, double *rcond, double *ferr, double *berr, double *work, int *iwork)
     * }
     */
    public static int LAPACKE_dposvx_work(int matrix_layout, byte fact, byte uplo, int n, int nrhs, MemorySegment a, int lda, MemorySegment af, int ldaf, MemorySegment equed, MemorySegment s, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment rcond, MemorySegment ferr, MemorySegment berr, MemorySegment work, MemorySegment iwork) {
        var mh$ = LAPACKE_dposvx_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dposvx_work", matrix_layout, fact, uplo, n, nrhs, a, lda, af, ldaf, equed, s, b, ldb, x, ldx, rcond, ferr, berr, work, iwork);
            }
            return (int)mh$.invokeExact(matrix_layout, fact, uplo, n, nrhs, a, lda, af, ldaf, equed, s, b, ldb, x, ldx, rcond, ferr, berr, work, iwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cposvx_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_cposvx_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cposvx_work(int matrix_layout, char fact, char uplo, int n, int nrhs, _Complex float *a, int lda, _Complex float *af, int ldaf, char *equed, float *s, _Complex float *b, int ldb, _Complex float *x, int ldx, float *rcond, float *ferr, float *berr, _Complex float *work, float *rwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_cposvx_work$descriptor() {
        return LAPACKE_cposvx_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cposvx_work(int matrix_layout, char fact, char uplo, int n, int nrhs, _Complex float *a, int lda, _Complex float *af, int ldaf, char *equed, float *s, _Complex float *b, int ldb, _Complex float *x, int ldx, float *rcond, float *ferr, float *berr, _Complex float *work, float *rwork)
     * }
     */
    public static MethodHandle LAPACKE_cposvx_work$handle() {
        return LAPACKE_cposvx_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cposvx_work(int matrix_layout, char fact, char uplo, int n, int nrhs, _Complex float *a, int lda, _Complex float *af, int ldaf, char *equed, float *s, _Complex float *b, int ldb, _Complex float *x, int ldx, float *rcond, float *ferr, float *berr, _Complex float *work, float *rwork)
     * }
     */
    public static MemorySegment LAPACKE_cposvx_work$address() {
        return LAPACKE_cposvx_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cposvx_work(int matrix_layout, char fact, char uplo, int n, int nrhs, _Complex float *a, int lda, _Complex float *af, int ldaf, char *equed, float *s, _Complex float *b, int ldb, _Complex float *x, int ldx, float *rcond, float *ferr, float *berr, _Complex float *work, float *rwork)
     * }
     */
    public static int LAPACKE_cposvx_work(int matrix_layout, byte fact, byte uplo, int n, int nrhs, MemorySegment a, int lda, MemorySegment af, int ldaf, MemorySegment equed, MemorySegment s, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment rcond, MemorySegment ferr, MemorySegment berr, MemorySegment work, MemorySegment rwork) {
        var mh$ = LAPACKE_cposvx_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cposvx_work", matrix_layout, fact, uplo, n, nrhs, a, lda, af, ldaf, equed, s, b, ldb, x, ldx, rcond, ferr, berr, work, rwork);
            }
            return (int)mh$.invokeExact(matrix_layout, fact, uplo, n, nrhs, a, lda, af, ldaf, equed, s, b, ldb, x, ldx, rcond, ferr, berr, work, rwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zposvx_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zposvx_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zposvx_work(int matrix_layout, char fact, char uplo, int n, int nrhs, _Complex double *a, int lda, _Complex double *af, int ldaf, char *equed, double *s, _Complex double *b, int ldb, _Complex double *x, int ldx, double *rcond, double *ferr, double *berr, _Complex double *work, double *rwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_zposvx_work$descriptor() {
        return LAPACKE_zposvx_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zposvx_work(int matrix_layout, char fact, char uplo, int n, int nrhs, _Complex double *a, int lda, _Complex double *af, int ldaf, char *equed, double *s, _Complex double *b, int ldb, _Complex double *x, int ldx, double *rcond, double *ferr, double *berr, _Complex double *work, double *rwork)
     * }
     */
    public static MethodHandle LAPACKE_zposvx_work$handle() {
        return LAPACKE_zposvx_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zposvx_work(int matrix_layout, char fact, char uplo, int n, int nrhs, _Complex double *a, int lda, _Complex double *af, int ldaf, char *equed, double *s, _Complex double *b, int ldb, _Complex double *x, int ldx, double *rcond, double *ferr, double *berr, _Complex double *work, double *rwork)
     * }
     */
    public static MemorySegment LAPACKE_zposvx_work$address() {
        return LAPACKE_zposvx_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zposvx_work(int matrix_layout, char fact, char uplo, int n, int nrhs, _Complex double *a, int lda, _Complex double *af, int ldaf, char *equed, double *s, _Complex double *b, int ldb, _Complex double *x, int ldx, double *rcond, double *ferr, double *berr, _Complex double *work, double *rwork)
     * }
     */
    public static int LAPACKE_zposvx_work(int matrix_layout, byte fact, byte uplo, int n, int nrhs, MemorySegment a, int lda, MemorySegment af, int ldaf, MemorySegment equed, MemorySegment s, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment rcond, MemorySegment ferr, MemorySegment berr, MemorySegment work, MemorySegment rwork) {
        var mh$ = LAPACKE_zposvx_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zposvx_work", matrix_layout, fact, uplo, n, nrhs, a, lda, af, ldaf, equed, s, b, ldb, x, ldx, rcond, ferr, berr, work, rwork);
            }
            return (int)mh$.invokeExact(matrix_layout, fact, uplo, n, nrhs, a, lda, af, ldaf, equed, s, b, ldb, x, ldx, rcond, ferr, berr, work, rwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sposvxx_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_sposvxx_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sposvxx_work(int matrix_layout, char fact, char uplo, int n, int nrhs, float *a, int lda, float *af, int ldaf, char *equed, float *s, float *b, int ldb, float *x, int ldx, float *rcond, float *rpvgrw, float *berr, int n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, int nparams, float *params, float *work, int *iwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_sposvxx_work$descriptor() {
        return LAPACKE_sposvxx_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sposvxx_work(int matrix_layout, char fact, char uplo, int n, int nrhs, float *a, int lda, float *af, int ldaf, char *equed, float *s, float *b, int ldb, float *x, int ldx, float *rcond, float *rpvgrw, float *berr, int n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, int nparams, float *params, float *work, int *iwork)
     * }
     */
    public static MethodHandle LAPACKE_sposvxx_work$handle() {
        return LAPACKE_sposvxx_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sposvxx_work(int matrix_layout, char fact, char uplo, int n, int nrhs, float *a, int lda, float *af, int ldaf, char *equed, float *s, float *b, int ldb, float *x, int ldx, float *rcond, float *rpvgrw, float *berr, int n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, int nparams, float *params, float *work, int *iwork)
     * }
     */
    public static MemorySegment LAPACKE_sposvxx_work$address() {
        return LAPACKE_sposvxx_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sposvxx_work(int matrix_layout, char fact, char uplo, int n, int nrhs, float *a, int lda, float *af, int ldaf, char *equed, float *s, float *b, int ldb, float *x, int ldx, float *rcond, float *rpvgrw, float *berr, int n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, int nparams, float *params, float *work, int *iwork)
     * }
     */
    public static int LAPACKE_sposvxx_work(int matrix_layout, byte fact, byte uplo, int n, int nrhs, MemorySegment a, int lda, MemorySegment af, int ldaf, MemorySegment equed, MemorySegment s, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment rcond, MemorySegment rpvgrw, MemorySegment berr, int n_err_bnds, MemorySegment err_bnds_norm, MemorySegment err_bnds_comp, int nparams, MemorySegment params, MemorySegment work, MemorySegment iwork) {
        var mh$ = LAPACKE_sposvxx_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sposvxx_work", matrix_layout, fact, uplo, n, nrhs, a, lda, af, ldaf, equed, s, b, ldb, x, ldx, rcond, rpvgrw, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params, work, iwork);
            }
            return (int)mh$.invokeExact(matrix_layout, fact, uplo, n, nrhs, a, lda, af, ldaf, equed, s, b, ldb, x, ldx, rcond, rpvgrw, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params, work, iwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dposvxx_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dposvxx_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dposvxx_work(int matrix_layout, char fact, char uplo, int n, int nrhs, double *a, int lda, double *af, int ldaf, char *equed, double *s, double *b, int ldb, double *x, int ldx, double *rcond, double *rpvgrw, double *berr, int n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, int nparams, double *params, double *work, int *iwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_dposvxx_work$descriptor() {
        return LAPACKE_dposvxx_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dposvxx_work(int matrix_layout, char fact, char uplo, int n, int nrhs, double *a, int lda, double *af, int ldaf, char *equed, double *s, double *b, int ldb, double *x, int ldx, double *rcond, double *rpvgrw, double *berr, int n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, int nparams, double *params, double *work, int *iwork)
     * }
     */
    public static MethodHandle LAPACKE_dposvxx_work$handle() {
        return LAPACKE_dposvxx_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dposvxx_work(int matrix_layout, char fact, char uplo, int n, int nrhs, double *a, int lda, double *af, int ldaf, char *equed, double *s, double *b, int ldb, double *x, int ldx, double *rcond, double *rpvgrw, double *berr, int n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, int nparams, double *params, double *work, int *iwork)
     * }
     */
    public static MemorySegment LAPACKE_dposvxx_work$address() {
        return LAPACKE_dposvxx_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dposvxx_work(int matrix_layout, char fact, char uplo, int n, int nrhs, double *a, int lda, double *af, int ldaf, char *equed, double *s, double *b, int ldb, double *x, int ldx, double *rcond, double *rpvgrw, double *berr, int n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, int nparams, double *params, double *work, int *iwork)
     * }
     */
    public static int LAPACKE_dposvxx_work(int matrix_layout, byte fact, byte uplo, int n, int nrhs, MemorySegment a, int lda, MemorySegment af, int ldaf, MemorySegment equed, MemorySegment s, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment rcond, MemorySegment rpvgrw, MemorySegment berr, int n_err_bnds, MemorySegment err_bnds_norm, MemorySegment err_bnds_comp, int nparams, MemorySegment params, MemorySegment work, MemorySegment iwork) {
        var mh$ = LAPACKE_dposvxx_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dposvxx_work", matrix_layout, fact, uplo, n, nrhs, a, lda, af, ldaf, equed, s, b, ldb, x, ldx, rcond, rpvgrw, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params, work, iwork);
            }
            return (int)mh$.invokeExact(matrix_layout, fact, uplo, n, nrhs, a, lda, af, ldaf, equed, s, b, ldb, x, ldx, rcond, rpvgrw, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params, work, iwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cposvxx_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_cposvxx_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cposvxx_work(int matrix_layout, char fact, char uplo, int n, int nrhs, _Complex float *a, int lda, _Complex float *af, int ldaf, char *equed, float *s, _Complex float *b, int ldb, _Complex float *x, int ldx, float *rcond, float *rpvgrw, float *berr, int n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, int nparams, float *params, _Complex float *work, float *rwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_cposvxx_work$descriptor() {
        return LAPACKE_cposvxx_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cposvxx_work(int matrix_layout, char fact, char uplo, int n, int nrhs, _Complex float *a, int lda, _Complex float *af, int ldaf, char *equed, float *s, _Complex float *b, int ldb, _Complex float *x, int ldx, float *rcond, float *rpvgrw, float *berr, int n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, int nparams, float *params, _Complex float *work, float *rwork)
     * }
     */
    public static MethodHandle LAPACKE_cposvxx_work$handle() {
        return LAPACKE_cposvxx_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cposvxx_work(int matrix_layout, char fact, char uplo, int n, int nrhs, _Complex float *a, int lda, _Complex float *af, int ldaf, char *equed, float *s, _Complex float *b, int ldb, _Complex float *x, int ldx, float *rcond, float *rpvgrw, float *berr, int n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, int nparams, float *params, _Complex float *work, float *rwork)
     * }
     */
    public static MemorySegment LAPACKE_cposvxx_work$address() {
        return LAPACKE_cposvxx_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cposvxx_work(int matrix_layout, char fact, char uplo, int n, int nrhs, _Complex float *a, int lda, _Complex float *af, int ldaf, char *equed, float *s, _Complex float *b, int ldb, _Complex float *x, int ldx, float *rcond, float *rpvgrw, float *berr, int n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, int nparams, float *params, _Complex float *work, float *rwork)
     * }
     */
    public static int LAPACKE_cposvxx_work(int matrix_layout, byte fact, byte uplo, int n, int nrhs, MemorySegment a, int lda, MemorySegment af, int ldaf, MemorySegment equed, MemorySegment s, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment rcond, MemorySegment rpvgrw, MemorySegment berr, int n_err_bnds, MemorySegment err_bnds_norm, MemorySegment err_bnds_comp, int nparams, MemorySegment params, MemorySegment work, MemorySegment rwork) {
        var mh$ = LAPACKE_cposvxx_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cposvxx_work", matrix_layout, fact, uplo, n, nrhs, a, lda, af, ldaf, equed, s, b, ldb, x, ldx, rcond, rpvgrw, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params, work, rwork);
            }
            return (int)mh$.invokeExact(matrix_layout, fact, uplo, n, nrhs, a, lda, af, ldaf, equed, s, b, ldb, x, ldx, rcond, rpvgrw, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params, work, rwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zposvxx_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zposvxx_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zposvxx_work(int matrix_layout, char fact, char uplo, int n, int nrhs, _Complex double *a, int lda, _Complex double *af, int ldaf, char *equed, double *s, _Complex double *b, int ldb, _Complex double *x, int ldx, double *rcond, double *rpvgrw, double *berr, int n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, int nparams, double *params, _Complex double *work, double *rwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_zposvxx_work$descriptor() {
        return LAPACKE_zposvxx_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zposvxx_work(int matrix_layout, char fact, char uplo, int n, int nrhs, _Complex double *a, int lda, _Complex double *af, int ldaf, char *equed, double *s, _Complex double *b, int ldb, _Complex double *x, int ldx, double *rcond, double *rpvgrw, double *berr, int n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, int nparams, double *params, _Complex double *work, double *rwork)
     * }
     */
    public static MethodHandle LAPACKE_zposvxx_work$handle() {
        return LAPACKE_zposvxx_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zposvxx_work(int matrix_layout, char fact, char uplo, int n, int nrhs, _Complex double *a, int lda, _Complex double *af, int ldaf, char *equed, double *s, _Complex double *b, int ldb, _Complex double *x, int ldx, double *rcond, double *rpvgrw, double *berr, int n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, int nparams, double *params, _Complex double *work, double *rwork)
     * }
     */
    public static MemorySegment LAPACKE_zposvxx_work$address() {
        return LAPACKE_zposvxx_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zposvxx_work(int matrix_layout, char fact, char uplo, int n, int nrhs, _Complex double *a, int lda, _Complex double *af, int ldaf, char *equed, double *s, _Complex double *b, int ldb, _Complex double *x, int ldx, double *rcond, double *rpvgrw, double *berr, int n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, int nparams, double *params, _Complex double *work, double *rwork)
     * }
     */
    public static int LAPACKE_zposvxx_work(int matrix_layout, byte fact, byte uplo, int n, int nrhs, MemorySegment a, int lda, MemorySegment af, int ldaf, MemorySegment equed, MemorySegment s, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment rcond, MemorySegment rpvgrw, MemorySegment berr, int n_err_bnds, MemorySegment err_bnds_norm, MemorySegment err_bnds_comp, int nparams, MemorySegment params, MemorySegment work, MemorySegment rwork) {
        var mh$ = LAPACKE_zposvxx_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zposvxx_work", matrix_layout, fact, uplo, n, nrhs, a, lda, af, ldaf, equed, s, b, ldb, x, ldx, rcond, rpvgrw, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params, work, rwork);
            }
            return (int)mh$.invokeExact(matrix_layout, fact, uplo, n, nrhs, a, lda, af, ldaf, equed, s, b, ldb, x, ldx, rcond, rpvgrw, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params, work, rwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_spotrf2_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_spotrf2_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_spotrf2_work(int matrix_layout, char uplo, int n, float *a, int lda)
     * }
     */
    public static FunctionDescriptor LAPACKE_spotrf2_work$descriptor() {
        return LAPACKE_spotrf2_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_spotrf2_work(int matrix_layout, char uplo, int n, float *a, int lda)
     * }
     */
    public static MethodHandle LAPACKE_spotrf2_work$handle() {
        return LAPACKE_spotrf2_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_spotrf2_work(int matrix_layout, char uplo, int n, float *a, int lda)
     * }
     */
    public static MemorySegment LAPACKE_spotrf2_work$address() {
        return LAPACKE_spotrf2_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_spotrf2_work(int matrix_layout, char uplo, int n, float *a, int lda)
     * }
     */
    public static int LAPACKE_spotrf2_work(int matrix_layout, byte uplo, int n, MemorySegment a, int lda) {
        var mh$ = LAPACKE_spotrf2_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_spotrf2_work", matrix_layout, uplo, n, a, lda);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, a, lda);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dpotrf2_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dpotrf2_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dpotrf2_work(int matrix_layout, char uplo, int n, double *a, int lda)
     * }
     */
    public static FunctionDescriptor LAPACKE_dpotrf2_work$descriptor() {
        return LAPACKE_dpotrf2_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dpotrf2_work(int matrix_layout, char uplo, int n, double *a, int lda)
     * }
     */
    public static MethodHandle LAPACKE_dpotrf2_work$handle() {
        return LAPACKE_dpotrf2_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dpotrf2_work(int matrix_layout, char uplo, int n, double *a, int lda)
     * }
     */
    public static MemorySegment LAPACKE_dpotrf2_work$address() {
        return LAPACKE_dpotrf2_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dpotrf2_work(int matrix_layout, char uplo, int n, double *a, int lda)
     * }
     */
    public static int LAPACKE_dpotrf2_work(int matrix_layout, byte uplo, int n, MemorySegment a, int lda) {
        var mh$ = LAPACKE_dpotrf2_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dpotrf2_work", matrix_layout, uplo, n, a, lda);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, a, lda);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cpotrf2_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_cpotrf2_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cpotrf2_work(int matrix_layout, char uplo, int n, _Complex float *a, int lda)
     * }
     */
    public static FunctionDescriptor LAPACKE_cpotrf2_work$descriptor() {
        return LAPACKE_cpotrf2_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cpotrf2_work(int matrix_layout, char uplo, int n, _Complex float *a, int lda)
     * }
     */
    public static MethodHandle LAPACKE_cpotrf2_work$handle() {
        return LAPACKE_cpotrf2_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cpotrf2_work(int matrix_layout, char uplo, int n, _Complex float *a, int lda)
     * }
     */
    public static MemorySegment LAPACKE_cpotrf2_work$address() {
        return LAPACKE_cpotrf2_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cpotrf2_work(int matrix_layout, char uplo, int n, _Complex float *a, int lda)
     * }
     */
    public static int LAPACKE_cpotrf2_work(int matrix_layout, byte uplo, int n, MemorySegment a, int lda) {
        var mh$ = LAPACKE_cpotrf2_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cpotrf2_work", matrix_layout, uplo, n, a, lda);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, a, lda);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zpotrf2_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zpotrf2_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zpotrf2_work(int matrix_layout, char uplo, int n, _Complex double *a, int lda)
     * }
     */
    public static FunctionDescriptor LAPACKE_zpotrf2_work$descriptor() {
        return LAPACKE_zpotrf2_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zpotrf2_work(int matrix_layout, char uplo, int n, _Complex double *a, int lda)
     * }
     */
    public static MethodHandle LAPACKE_zpotrf2_work$handle() {
        return LAPACKE_zpotrf2_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zpotrf2_work(int matrix_layout, char uplo, int n, _Complex double *a, int lda)
     * }
     */
    public static MemorySegment LAPACKE_zpotrf2_work$address() {
        return LAPACKE_zpotrf2_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zpotrf2_work(int matrix_layout, char uplo, int n, _Complex double *a, int lda)
     * }
     */
    public static int LAPACKE_zpotrf2_work(int matrix_layout, byte uplo, int n, MemorySegment a, int lda) {
        var mh$ = LAPACKE_zpotrf2_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zpotrf2_work", matrix_layout, uplo, n, a, lda);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, a, lda);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_spotrf_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_spotrf_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_spotrf_work(int matrix_layout, char uplo, int n, float *a, int lda)
     * }
     */
    public static FunctionDescriptor LAPACKE_spotrf_work$descriptor() {
        return LAPACKE_spotrf_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_spotrf_work(int matrix_layout, char uplo, int n, float *a, int lda)
     * }
     */
    public static MethodHandle LAPACKE_spotrf_work$handle() {
        return LAPACKE_spotrf_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_spotrf_work(int matrix_layout, char uplo, int n, float *a, int lda)
     * }
     */
    public static MemorySegment LAPACKE_spotrf_work$address() {
        return LAPACKE_spotrf_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_spotrf_work(int matrix_layout, char uplo, int n, float *a, int lda)
     * }
     */
    public static int LAPACKE_spotrf_work(int matrix_layout, byte uplo, int n, MemorySegment a, int lda) {
        var mh$ = LAPACKE_spotrf_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_spotrf_work", matrix_layout, uplo, n, a, lda);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, a, lda);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dpotrf_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dpotrf_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dpotrf_work(int matrix_layout, char uplo, int n, double *a, int lda)
     * }
     */
    public static FunctionDescriptor LAPACKE_dpotrf_work$descriptor() {
        return LAPACKE_dpotrf_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dpotrf_work(int matrix_layout, char uplo, int n, double *a, int lda)
     * }
     */
    public static MethodHandle LAPACKE_dpotrf_work$handle() {
        return LAPACKE_dpotrf_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dpotrf_work(int matrix_layout, char uplo, int n, double *a, int lda)
     * }
     */
    public static MemorySegment LAPACKE_dpotrf_work$address() {
        return LAPACKE_dpotrf_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dpotrf_work(int matrix_layout, char uplo, int n, double *a, int lda)
     * }
     */
    public static int LAPACKE_dpotrf_work(int matrix_layout, byte uplo, int n, MemorySegment a, int lda) {
        var mh$ = LAPACKE_dpotrf_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dpotrf_work", matrix_layout, uplo, n, a, lda);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, a, lda);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cpotrf_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_cpotrf_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cpotrf_work(int matrix_layout, char uplo, int n, _Complex float *a, int lda)
     * }
     */
    public static FunctionDescriptor LAPACKE_cpotrf_work$descriptor() {
        return LAPACKE_cpotrf_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cpotrf_work(int matrix_layout, char uplo, int n, _Complex float *a, int lda)
     * }
     */
    public static MethodHandle LAPACKE_cpotrf_work$handle() {
        return LAPACKE_cpotrf_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cpotrf_work(int matrix_layout, char uplo, int n, _Complex float *a, int lda)
     * }
     */
    public static MemorySegment LAPACKE_cpotrf_work$address() {
        return LAPACKE_cpotrf_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cpotrf_work(int matrix_layout, char uplo, int n, _Complex float *a, int lda)
     * }
     */
    public static int LAPACKE_cpotrf_work(int matrix_layout, byte uplo, int n, MemorySegment a, int lda) {
        var mh$ = LAPACKE_cpotrf_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cpotrf_work", matrix_layout, uplo, n, a, lda);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, a, lda);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zpotrf_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zpotrf_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zpotrf_work(int matrix_layout, char uplo, int n, _Complex double *a, int lda)
     * }
     */
    public static FunctionDescriptor LAPACKE_zpotrf_work$descriptor() {
        return LAPACKE_zpotrf_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zpotrf_work(int matrix_layout, char uplo, int n, _Complex double *a, int lda)
     * }
     */
    public static MethodHandle LAPACKE_zpotrf_work$handle() {
        return LAPACKE_zpotrf_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zpotrf_work(int matrix_layout, char uplo, int n, _Complex double *a, int lda)
     * }
     */
    public static MemorySegment LAPACKE_zpotrf_work$address() {
        return LAPACKE_zpotrf_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zpotrf_work(int matrix_layout, char uplo, int n, _Complex double *a, int lda)
     * }
     */
    public static int LAPACKE_zpotrf_work(int matrix_layout, byte uplo, int n, MemorySegment a, int lda) {
        var mh$ = LAPACKE_zpotrf_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zpotrf_work", matrix_layout, uplo, n, a, lda);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, a, lda);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_spotri_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_spotri_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_spotri_work(int matrix_layout, char uplo, int n, float *a, int lda)
     * }
     */
    public static FunctionDescriptor LAPACKE_spotri_work$descriptor() {
        return LAPACKE_spotri_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_spotri_work(int matrix_layout, char uplo, int n, float *a, int lda)
     * }
     */
    public static MethodHandle LAPACKE_spotri_work$handle() {
        return LAPACKE_spotri_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_spotri_work(int matrix_layout, char uplo, int n, float *a, int lda)
     * }
     */
    public static MemorySegment LAPACKE_spotri_work$address() {
        return LAPACKE_spotri_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_spotri_work(int matrix_layout, char uplo, int n, float *a, int lda)
     * }
     */
    public static int LAPACKE_spotri_work(int matrix_layout, byte uplo, int n, MemorySegment a, int lda) {
        var mh$ = LAPACKE_spotri_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_spotri_work", matrix_layout, uplo, n, a, lda);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, a, lda);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dpotri_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dpotri_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dpotri_work(int matrix_layout, char uplo, int n, double *a, int lda)
     * }
     */
    public static FunctionDescriptor LAPACKE_dpotri_work$descriptor() {
        return LAPACKE_dpotri_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dpotri_work(int matrix_layout, char uplo, int n, double *a, int lda)
     * }
     */
    public static MethodHandle LAPACKE_dpotri_work$handle() {
        return LAPACKE_dpotri_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dpotri_work(int matrix_layout, char uplo, int n, double *a, int lda)
     * }
     */
    public static MemorySegment LAPACKE_dpotri_work$address() {
        return LAPACKE_dpotri_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dpotri_work(int matrix_layout, char uplo, int n, double *a, int lda)
     * }
     */
    public static int LAPACKE_dpotri_work(int matrix_layout, byte uplo, int n, MemorySegment a, int lda) {
        var mh$ = LAPACKE_dpotri_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dpotri_work", matrix_layout, uplo, n, a, lda);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, a, lda);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cpotri_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_cpotri_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cpotri_work(int matrix_layout, char uplo, int n, _Complex float *a, int lda)
     * }
     */
    public static FunctionDescriptor LAPACKE_cpotri_work$descriptor() {
        return LAPACKE_cpotri_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cpotri_work(int matrix_layout, char uplo, int n, _Complex float *a, int lda)
     * }
     */
    public static MethodHandle LAPACKE_cpotri_work$handle() {
        return LAPACKE_cpotri_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cpotri_work(int matrix_layout, char uplo, int n, _Complex float *a, int lda)
     * }
     */
    public static MemorySegment LAPACKE_cpotri_work$address() {
        return LAPACKE_cpotri_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cpotri_work(int matrix_layout, char uplo, int n, _Complex float *a, int lda)
     * }
     */
    public static int LAPACKE_cpotri_work(int matrix_layout, byte uplo, int n, MemorySegment a, int lda) {
        var mh$ = LAPACKE_cpotri_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cpotri_work", matrix_layout, uplo, n, a, lda);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, a, lda);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zpotri_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zpotri_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zpotri_work(int matrix_layout, char uplo, int n, _Complex double *a, int lda)
     * }
     */
    public static FunctionDescriptor LAPACKE_zpotri_work$descriptor() {
        return LAPACKE_zpotri_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zpotri_work(int matrix_layout, char uplo, int n, _Complex double *a, int lda)
     * }
     */
    public static MethodHandle LAPACKE_zpotri_work$handle() {
        return LAPACKE_zpotri_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zpotri_work(int matrix_layout, char uplo, int n, _Complex double *a, int lda)
     * }
     */
    public static MemorySegment LAPACKE_zpotri_work$address() {
        return LAPACKE_zpotri_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zpotri_work(int matrix_layout, char uplo, int n, _Complex double *a, int lda)
     * }
     */
    public static int LAPACKE_zpotri_work(int matrix_layout, byte uplo, int n, MemorySegment a, int lda) {
        var mh$ = LAPACKE_zpotri_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zpotri_work", matrix_layout, uplo, n, a, lda);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, a, lda);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_spotrs_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_spotrs_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_spotrs_work(int matrix_layout, char uplo, int n, int nrhs, const float *a, int lda, float *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_spotrs_work$descriptor() {
        return LAPACKE_spotrs_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_spotrs_work(int matrix_layout, char uplo, int n, int nrhs, const float *a, int lda, float *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_spotrs_work$handle() {
        return LAPACKE_spotrs_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_spotrs_work(int matrix_layout, char uplo, int n, int nrhs, const float *a, int lda, float *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_spotrs_work$address() {
        return LAPACKE_spotrs_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_spotrs_work(int matrix_layout, char uplo, int n, int nrhs, const float *a, int lda, float *b, int ldb)
     * }
     */
    public static int LAPACKE_spotrs_work(int matrix_layout, byte uplo, int n, int nrhs, MemorySegment a, int lda, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_spotrs_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_spotrs_work", matrix_layout, uplo, n, nrhs, a, lda, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, nrhs, a, lda, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dpotrs_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dpotrs_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dpotrs_work(int matrix_layout, char uplo, int n, int nrhs, const double *a, int lda, double *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_dpotrs_work$descriptor() {
        return LAPACKE_dpotrs_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dpotrs_work(int matrix_layout, char uplo, int n, int nrhs, const double *a, int lda, double *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_dpotrs_work$handle() {
        return LAPACKE_dpotrs_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dpotrs_work(int matrix_layout, char uplo, int n, int nrhs, const double *a, int lda, double *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_dpotrs_work$address() {
        return LAPACKE_dpotrs_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dpotrs_work(int matrix_layout, char uplo, int n, int nrhs, const double *a, int lda, double *b, int ldb)
     * }
     */
    public static int LAPACKE_dpotrs_work(int matrix_layout, byte uplo, int n, int nrhs, MemorySegment a, int lda, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_dpotrs_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dpotrs_work", matrix_layout, uplo, n, nrhs, a, lda, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, nrhs, a, lda, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cpotrs_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_cpotrs_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cpotrs_work(int matrix_layout, char uplo, int n, int nrhs, const _Complex float *a, int lda, _Complex float *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_cpotrs_work$descriptor() {
        return LAPACKE_cpotrs_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cpotrs_work(int matrix_layout, char uplo, int n, int nrhs, const _Complex float *a, int lda, _Complex float *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_cpotrs_work$handle() {
        return LAPACKE_cpotrs_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cpotrs_work(int matrix_layout, char uplo, int n, int nrhs, const _Complex float *a, int lda, _Complex float *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_cpotrs_work$address() {
        return LAPACKE_cpotrs_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cpotrs_work(int matrix_layout, char uplo, int n, int nrhs, const _Complex float *a, int lda, _Complex float *b, int ldb)
     * }
     */
    public static int LAPACKE_cpotrs_work(int matrix_layout, byte uplo, int n, int nrhs, MemorySegment a, int lda, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_cpotrs_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cpotrs_work", matrix_layout, uplo, n, nrhs, a, lda, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, nrhs, a, lda, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zpotrs_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zpotrs_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zpotrs_work(int matrix_layout, char uplo, int n, int nrhs, const _Complex double *a, int lda, _Complex double *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_zpotrs_work$descriptor() {
        return LAPACKE_zpotrs_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zpotrs_work(int matrix_layout, char uplo, int n, int nrhs, const _Complex double *a, int lda, _Complex double *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_zpotrs_work$handle() {
        return LAPACKE_zpotrs_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zpotrs_work(int matrix_layout, char uplo, int n, int nrhs, const _Complex double *a, int lda, _Complex double *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_zpotrs_work$address() {
        return LAPACKE_zpotrs_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zpotrs_work(int matrix_layout, char uplo, int n, int nrhs, const _Complex double *a, int lda, _Complex double *b, int ldb)
     * }
     */
    public static int LAPACKE_zpotrs_work(int matrix_layout, byte uplo, int n, int nrhs, MemorySegment a, int lda, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_zpotrs_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zpotrs_work", matrix_layout, uplo, n, nrhs, a, lda, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, nrhs, a, lda, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sppcon_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_FLOAT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_sppcon_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sppcon_work(int matrix_layout, char uplo, int n, const float *ap, float anorm, float *rcond, float *work, int *iwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_sppcon_work$descriptor() {
        return LAPACKE_sppcon_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sppcon_work(int matrix_layout, char uplo, int n, const float *ap, float anorm, float *rcond, float *work, int *iwork)
     * }
     */
    public static MethodHandle LAPACKE_sppcon_work$handle() {
        return LAPACKE_sppcon_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sppcon_work(int matrix_layout, char uplo, int n, const float *ap, float anorm, float *rcond, float *work, int *iwork)
     * }
     */
    public static MemorySegment LAPACKE_sppcon_work$address() {
        return LAPACKE_sppcon_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sppcon_work(int matrix_layout, char uplo, int n, const float *ap, float anorm, float *rcond, float *work, int *iwork)
     * }
     */
    public static int LAPACKE_sppcon_work(int matrix_layout, byte uplo, int n, MemorySegment ap, float anorm, MemorySegment rcond, MemorySegment work, MemorySegment iwork) {
        var mh$ = LAPACKE_sppcon_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sppcon_work", matrix_layout, uplo, n, ap, anorm, rcond, work, iwork);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, ap, anorm, rcond, work, iwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dppcon_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_DOUBLE,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dppcon_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dppcon_work(int matrix_layout, char uplo, int n, const double *ap, double anorm, double *rcond, double *work, int *iwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_dppcon_work$descriptor() {
        return LAPACKE_dppcon_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dppcon_work(int matrix_layout, char uplo, int n, const double *ap, double anorm, double *rcond, double *work, int *iwork)
     * }
     */
    public static MethodHandle LAPACKE_dppcon_work$handle() {
        return LAPACKE_dppcon_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dppcon_work(int matrix_layout, char uplo, int n, const double *ap, double anorm, double *rcond, double *work, int *iwork)
     * }
     */
    public static MemorySegment LAPACKE_dppcon_work$address() {
        return LAPACKE_dppcon_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dppcon_work(int matrix_layout, char uplo, int n, const double *ap, double anorm, double *rcond, double *work, int *iwork)
     * }
     */
    public static int LAPACKE_dppcon_work(int matrix_layout, byte uplo, int n, MemorySegment ap, double anorm, MemorySegment rcond, MemorySegment work, MemorySegment iwork) {
        var mh$ = LAPACKE_dppcon_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dppcon_work", matrix_layout, uplo, n, ap, anorm, rcond, work, iwork);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, ap, anorm, rcond, work, iwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cppcon_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_FLOAT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_cppcon_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cppcon_work(int matrix_layout, char uplo, int n, const _Complex float *ap, float anorm, float *rcond, _Complex float *work, float *rwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_cppcon_work$descriptor() {
        return LAPACKE_cppcon_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cppcon_work(int matrix_layout, char uplo, int n, const _Complex float *ap, float anorm, float *rcond, _Complex float *work, float *rwork)
     * }
     */
    public static MethodHandle LAPACKE_cppcon_work$handle() {
        return LAPACKE_cppcon_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cppcon_work(int matrix_layout, char uplo, int n, const _Complex float *ap, float anorm, float *rcond, _Complex float *work, float *rwork)
     * }
     */
    public static MemorySegment LAPACKE_cppcon_work$address() {
        return LAPACKE_cppcon_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cppcon_work(int matrix_layout, char uplo, int n, const _Complex float *ap, float anorm, float *rcond, _Complex float *work, float *rwork)
     * }
     */
    public static int LAPACKE_cppcon_work(int matrix_layout, byte uplo, int n, MemorySegment ap, float anorm, MemorySegment rcond, MemorySegment work, MemorySegment rwork) {
        var mh$ = LAPACKE_cppcon_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cppcon_work", matrix_layout, uplo, n, ap, anorm, rcond, work, rwork);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, ap, anorm, rcond, work, rwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zppcon_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_DOUBLE,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zppcon_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zppcon_work(int matrix_layout, char uplo, int n, const _Complex double *ap, double anorm, double *rcond, _Complex double *work, double *rwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_zppcon_work$descriptor() {
        return LAPACKE_zppcon_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zppcon_work(int matrix_layout, char uplo, int n, const _Complex double *ap, double anorm, double *rcond, _Complex double *work, double *rwork)
     * }
     */
    public static MethodHandle LAPACKE_zppcon_work$handle() {
        return LAPACKE_zppcon_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zppcon_work(int matrix_layout, char uplo, int n, const _Complex double *ap, double anorm, double *rcond, _Complex double *work, double *rwork)
     * }
     */
    public static MemorySegment LAPACKE_zppcon_work$address() {
        return LAPACKE_zppcon_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zppcon_work(int matrix_layout, char uplo, int n, const _Complex double *ap, double anorm, double *rcond, _Complex double *work, double *rwork)
     * }
     */
    public static int LAPACKE_zppcon_work(int matrix_layout, byte uplo, int n, MemorySegment ap, double anorm, MemorySegment rcond, MemorySegment work, MemorySegment rwork) {
        var mh$ = LAPACKE_zppcon_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zppcon_work", matrix_layout, uplo, n, ap, anorm, rcond, work, rwork);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, ap, anorm, rcond, work, rwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sppequ_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_sppequ_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sppequ_work(int matrix_layout, char uplo, int n, const float *ap, float *s, float *scond, float *amax)
     * }
     */
    public static FunctionDescriptor LAPACKE_sppequ_work$descriptor() {
        return LAPACKE_sppequ_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sppequ_work(int matrix_layout, char uplo, int n, const float *ap, float *s, float *scond, float *amax)
     * }
     */
    public static MethodHandle LAPACKE_sppequ_work$handle() {
        return LAPACKE_sppequ_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sppequ_work(int matrix_layout, char uplo, int n, const float *ap, float *s, float *scond, float *amax)
     * }
     */
    public static MemorySegment LAPACKE_sppequ_work$address() {
        return LAPACKE_sppequ_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sppequ_work(int matrix_layout, char uplo, int n, const float *ap, float *s, float *scond, float *amax)
     * }
     */
    public static int LAPACKE_sppequ_work(int matrix_layout, byte uplo, int n, MemorySegment ap, MemorySegment s, MemorySegment scond, MemorySegment amax) {
        var mh$ = LAPACKE_sppequ_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sppequ_work", matrix_layout, uplo, n, ap, s, scond, amax);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, ap, s, scond, amax);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dppequ_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dppequ_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dppequ_work(int matrix_layout, char uplo, int n, const double *ap, double *s, double *scond, double *amax)
     * }
     */
    public static FunctionDescriptor LAPACKE_dppequ_work$descriptor() {
        return LAPACKE_dppequ_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dppequ_work(int matrix_layout, char uplo, int n, const double *ap, double *s, double *scond, double *amax)
     * }
     */
    public static MethodHandle LAPACKE_dppequ_work$handle() {
        return LAPACKE_dppequ_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dppequ_work(int matrix_layout, char uplo, int n, const double *ap, double *s, double *scond, double *amax)
     * }
     */
    public static MemorySegment LAPACKE_dppequ_work$address() {
        return LAPACKE_dppequ_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dppequ_work(int matrix_layout, char uplo, int n, const double *ap, double *s, double *scond, double *amax)
     * }
     */
    public static int LAPACKE_dppequ_work(int matrix_layout, byte uplo, int n, MemorySegment ap, MemorySegment s, MemorySegment scond, MemorySegment amax) {
        var mh$ = LAPACKE_dppequ_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dppequ_work", matrix_layout, uplo, n, ap, s, scond, amax);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, ap, s, scond, amax);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cppequ_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_cppequ_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cppequ_work(int matrix_layout, char uplo, int n, const _Complex float *ap, float *s, float *scond, float *amax)
     * }
     */
    public static FunctionDescriptor LAPACKE_cppequ_work$descriptor() {
        return LAPACKE_cppequ_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cppequ_work(int matrix_layout, char uplo, int n, const _Complex float *ap, float *s, float *scond, float *amax)
     * }
     */
    public static MethodHandle LAPACKE_cppequ_work$handle() {
        return LAPACKE_cppequ_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cppequ_work(int matrix_layout, char uplo, int n, const _Complex float *ap, float *s, float *scond, float *amax)
     * }
     */
    public static MemorySegment LAPACKE_cppequ_work$address() {
        return LAPACKE_cppequ_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cppequ_work(int matrix_layout, char uplo, int n, const _Complex float *ap, float *s, float *scond, float *amax)
     * }
     */
    public static int LAPACKE_cppequ_work(int matrix_layout, byte uplo, int n, MemorySegment ap, MemorySegment s, MemorySegment scond, MemorySegment amax) {
        var mh$ = LAPACKE_cppequ_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cppequ_work", matrix_layout, uplo, n, ap, s, scond, amax);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, ap, s, scond, amax);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zppequ_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zppequ_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zppequ_work(int matrix_layout, char uplo, int n, const _Complex double *ap, double *s, double *scond, double *amax)
     * }
     */
    public static FunctionDescriptor LAPACKE_zppequ_work$descriptor() {
        return LAPACKE_zppequ_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zppequ_work(int matrix_layout, char uplo, int n, const _Complex double *ap, double *s, double *scond, double *amax)
     * }
     */
    public static MethodHandle LAPACKE_zppequ_work$handle() {
        return LAPACKE_zppequ_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zppequ_work(int matrix_layout, char uplo, int n, const _Complex double *ap, double *s, double *scond, double *amax)
     * }
     */
    public static MemorySegment LAPACKE_zppequ_work$address() {
        return LAPACKE_zppequ_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zppequ_work(int matrix_layout, char uplo, int n, const _Complex double *ap, double *s, double *scond, double *amax)
     * }
     */
    public static int LAPACKE_zppequ_work(int matrix_layout, byte uplo, int n, MemorySegment ap, MemorySegment s, MemorySegment scond, MemorySegment amax) {
        var mh$ = LAPACKE_zppequ_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zppequ_work", matrix_layout, uplo, n, ap, s, scond, amax);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, ap, s, scond, amax);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_spprfs_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_spprfs_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_spprfs_work(int matrix_layout, char uplo, int n, int nrhs, const float *ap, const float *afp, const float *b, int ldb, float *x, int ldx, float *ferr, float *berr, float *work, int *iwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_spprfs_work$descriptor() {
        return LAPACKE_spprfs_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_spprfs_work(int matrix_layout, char uplo, int n, int nrhs, const float *ap, const float *afp, const float *b, int ldb, float *x, int ldx, float *ferr, float *berr, float *work, int *iwork)
     * }
     */
    public static MethodHandle LAPACKE_spprfs_work$handle() {
        return LAPACKE_spprfs_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_spprfs_work(int matrix_layout, char uplo, int n, int nrhs, const float *ap, const float *afp, const float *b, int ldb, float *x, int ldx, float *ferr, float *berr, float *work, int *iwork)
     * }
     */
    public static MemorySegment LAPACKE_spprfs_work$address() {
        return LAPACKE_spprfs_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_spprfs_work(int matrix_layout, char uplo, int n, int nrhs, const float *ap, const float *afp, const float *b, int ldb, float *x, int ldx, float *ferr, float *berr, float *work, int *iwork)
     * }
     */
    public static int LAPACKE_spprfs_work(int matrix_layout, byte uplo, int n, int nrhs, MemorySegment ap, MemorySegment afp, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment ferr, MemorySegment berr, MemorySegment work, MemorySegment iwork) {
        var mh$ = LAPACKE_spprfs_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_spprfs_work", matrix_layout, uplo, n, nrhs, ap, afp, b, ldb, x, ldx, ferr, berr, work, iwork);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, nrhs, ap, afp, b, ldb, x, ldx, ferr, berr, work, iwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dpprfs_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dpprfs_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dpprfs_work(int matrix_layout, char uplo, int n, int nrhs, const double *ap, const double *afp, const double *b, int ldb, double *x, int ldx, double *ferr, double *berr, double *work, int *iwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_dpprfs_work$descriptor() {
        return LAPACKE_dpprfs_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dpprfs_work(int matrix_layout, char uplo, int n, int nrhs, const double *ap, const double *afp, const double *b, int ldb, double *x, int ldx, double *ferr, double *berr, double *work, int *iwork)
     * }
     */
    public static MethodHandle LAPACKE_dpprfs_work$handle() {
        return LAPACKE_dpprfs_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dpprfs_work(int matrix_layout, char uplo, int n, int nrhs, const double *ap, const double *afp, const double *b, int ldb, double *x, int ldx, double *ferr, double *berr, double *work, int *iwork)
     * }
     */
    public static MemorySegment LAPACKE_dpprfs_work$address() {
        return LAPACKE_dpprfs_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dpprfs_work(int matrix_layout, char uplo, int n, int nrhs, const double *ap, const double *afp, const double *b, int ldb, double *x, int ldx, double *ferr, double *berr, double *work, int *iwork)
     * }
     */
    public static int LAPACKE_dpprfs_work(int matrix_layout, byte uplo, int n, int nrhs, MemorySegment ap, MemorySegment afp, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment ferr, MemorySegment berr, MemorySegment work, MemorySegment iwork) {
        var mh$ = LAPACKE_dpprfs_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dpprfs_work", matrix_layout, uplo, n, nrhs, ap, afp, b, ldb, x, ldx, ferr, berr, work, iwork);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, nrhs, ap, afp, b, ldb, x, ldx, ferr, berr, work, iwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cpprfs_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_cpprfs_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cpprfs_work(int matrix_layout, char uplo, int n, int nrhs, const _Complex float *ap, const _Complex float *afp, const _Complex float *b, int ldb, _Complex float *x, int ldx, float *ferr, float *berr, _Complex float *work, float *rwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_cpprfs_work$descriptor() {
        return LAPACKE_cpprfs_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cpprfs_work(int matrix_layout, char uplo, int n, int nrhs, const _Complex float *ap, const _Complex float *afp, const _Complex float *b, int ldb, _Complex float *x, int ldx, float *ferr, float *berr, _Complex float *work, float *rwork)
     * }
     */
    public static MethodHandle LAPACKE_cpprfs_work$handle() {
        return LAPACKE_cpprfs_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cpprfs_work(int matrix_layout, char uplo, int n, int nrhs, const _Complex float *ap, const _Complex float *afp, const _Complex float *b, int ldb, _Complex float *x, int ldx, float *ferr, float *berr, _Complex float *work, float *rwork)
     * }
     */
    public static MemorySegment LAPACKE_cpprfs_work$address() {
        return LAPACKE_cpprfs_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cpprfs_work(int matrix_layout, char uplo, int n, int nrhs, const _Complex float *ap, const _Complex float *afp, const _Complex float *b, int ldb, _Complex float *x, int ldx, float *ferr, float *berr, _Complex float *work, float *rwork)
     * }
     */
    public static int LAPACKE_cpprfs_work(int matrix_layout, byte uplo, int n, int nrhs, MemorySegment ap, MemorySegment afp, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment ferr, MemorySegment berr, MemorySegment work, MemorySegment rwork) {
        var mh$ = LAPACKE_cpprfs_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cpprfs_work", matrix_layout, uplo, n, nrhs, ap, afp, b, ldb, x, ldx, ferr, berr, work, rwork);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, nrhs, ap, afp, b, ldb, x, ldx, ferr, berr, work, rwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zpprfs_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zpprfs_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zpprfs_work(int matrix_layout, char uplo, int n, int nrhs, const _Complex double *ap, const _Complex double *afp, const _Complex double *b, int ldb, _Complex double *x, int ldx, double *ferr, double *berr, _Complex double *work, double *rwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_zpprfs_work$descriptor() {
        return LAPACKE_zpprfs_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zpprfs_work(int matrix_layout, char uplo, int n, int nrhs, const _Complex double *ap, const _Complex double *afp, const _Complex double *b, int ldb, _Complex double *x, int ldx, double *ferr, double *berr, _Complex double *work, double *rwork)
     * }
     */
    public static MethodHandle LAPACKE_zpprfs_work$handle() {
        return LAPACKE_zpprfs_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zpprfs_work(int matrix_layout, char uplo, int n, int nrhs, const _Complex double *ap, const _Complex double *afp, const _Complex double *b, int ldb, _Complex double *x, int ldx, double *ferr, double *berr, _Complex double *work, double *rwork)
     * }
     */
    public static MemorySegment LAPACKE_zpprfs_work$address() {
        return LAPACKE_zpprfs_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zpprfs_work(int matrix_layout, char uplo, int n, int nrhs, const _Complex double *ap, const _Complex double *afp, const _Complex double *b, int ldb, _Complex double *x, int ldx, double *ferr, double *berr, _Complex double *work, double *rwork)
     * }
     */
    public static int LAPACKE_zpprfs_work(int matrix_layout, byte uplo, int n, int nrhs, MemorySegment ap, MemorySegment afp, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment ferr, MemorySegment berr, MemorySegment work, MemorySegment rwork) {
        var mh$ = LAPACKE_zpprfs_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zpprfs_work", matrix_layout, uplo, n, nrhs, ap, afp, b, ldb, x, ldx, ferr, berr, work, rwork);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, nrhs, ap, afp, b, ldb, x, ldx, ferr, berr, work, rwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sppsv_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_sppsv_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sppsv_work(int matrix_layout, char uplo, int n, int nrhs, float *ap, float *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_sppsv_work$descriptor() {
        return LAPACKE_sppsv_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sppsv_work(int matrix_layout, char uplo, int n, int nrhs, float *ap, float *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_sppsv_work$handle() {
        return LAPACKE_sppsv_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sppsv_work(int matrix_layout, char uplo, int n, int nrhs, float *ap, float *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_sppsv_work$address() {
        return LAPACKE_sppsv_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sppsv_work(int matrix_layout, char uplo, int n, int nrhs, float *ap, float *b, int ldb)
     * }
     */
    public static int LAPACKE_sppsv_work(int matrix_layout, byte uplo, int n, int nrhs, MemorySegment ap, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_sppsv_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sppsv_work", matrix_layout, uplo, n, nrhs, ap, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, nrhs, ap, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dppsv_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dppsv_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dppsv_work(int matrix_layout, char uplo, int n, int nrhs, double *ap, double *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_dppsv_work$descriptor() {
        return LAPACKE_dppsv_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dppsv_work(int matrix_layout, char uplo, int n, int nrhs, double *ap, double *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_dppsv_work$handle() {
        return LAPACKE_dppsv_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dppsv_work(int matrix_layout, char uplo, int n, int nrhs, double *ap, double *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_dppsv_work$address() {
        return LAPACKE_dppsv_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dppsv_work(int matrix_layout, char uplo, int n, int nrhs, double *ap, double *b, int ldb)
     * }
     */
    public static int LAPACKE_dppsv_work(int matrix_layout, byte uplo, int n, int nrhs, MemorySegment ap, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_dppsv_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dppsv_work", matrix_layout, uplo, n, nrhs, ap, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, nrhs, ap, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cppsv_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_cppsv_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cppsv_work(int matrix_layout, char uplo, int n, int nrhs, _Complex float *ap, _Complex float *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_cppsv_work$descriptor() {
        return LAPACKE_cppsv_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cppsv_work(int matrix_layout, char uplo, int n, int nrhs, _Complex float *ap, _Complex float *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_cppsv_work$handle() {
        return LAPACKE_cppsv_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cppsv_work(int matrix_layout, char uplo, int n, int nrhs, _Complex float *ap, _Complex float *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_cppsv_work$address() {
        return LAPACKE_cppsv_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cppsv_work(int matrix_layout, char uplo, int n, int nrhs, _Complex float *ap, _Complex float *b, int ldb)
     * }
     */
    public static int LAPACKE_cppsv_work(int matrix_layout, byte uplo, int n, int nrhs, MemorySegment ap, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_cppsv_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cppsv_work", matrix_layout, uplo, n, nrhs, ap, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, nrhs, ap, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zppsv_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zppsv_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zppsv_work(int matrix_layout, char uplo, int n, int nrhs, _Complex double *ap, _Complex double *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_zppsv_work$descriptor() {
        return LAPACKE_zppsv_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zppsv_work(int matrix_layout, char uplo, int n, int nrhs, _Complex double *ap, _Complex double *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_zppsv_work$handle() {
        return LAPACKE_zppsv_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zppsv_work(int matrix_layout, char uplo, int n, int nrhs, _Complex double *ap, _Complex double *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_zppsv_work$address() {
        return LAPACKE_zppsv_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zppsv_work(int matrix_layout, char uplo, int n, int nrhs, _Complex double *ap, _Complex double *b, int ldb)
     * }
     */
    public static int LAPACKE_zppsv_work(int matrix_layout, byte uplo, int n, int nrhs, MemorySegment ap, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_zppsv_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zppsv_work", matrix_layout, uplo, n, nrhs, ap, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, nrhs, ap, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sppsvx_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_sppsvx_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sppsvx_work(int matrix_layout, char fact, char uplo, int n, int nrhs, float *ap, float *afp, char *equed, float *s, float *b, int ldb, float *x, int ldx, float *rcond, float *ferr, float *berr, float *work, int *iwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_sppsvx_work$descriptor() {
        return LAPACKE_sppsvx_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sppsvx_work(int matrix_layout, char fact, char uplo, int n, int nrhs, float *ap, float *afp, char *equed, float *s, float *b, int ldb, float *x, int ldx, float *rcond, float *ferr, float *berr, float *work, int *iwork)
     * }
     */
    public static MethodHandle LAPACKE_sppsvx_work$handle() {
        return LAPACKE_sppsvx_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sppsvx_work(int matrix_layout, char fact, char uplo, int n, int nrhs, float *ap, float *afp, char *equed, float *s, float *b, int ldb, float *x, int ldx, float *rcond, float *ferr, float *berr, float *work, int *iwork)
     * }
     */
    public static MemorySegment LAPACKE_sppsvx_work$address() {
        return LAPACKE_sppsvx_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sppsvx_work(int matrix_layout, char fact, char uplo, int n, int nrhs, float *ap, float *afp, char *equed, float *s, float *b, int ldb, float *x, int ldx, float *rcond, float *ferr, float *berr, float *work, int *iwork)
     * }
     */
    public static int LAPACKE_sppsvx_work(int matrix_layout, byte fact, byte uplo, int n, int nrhs, MemorySegment ap, MemorySegment afp, MemorySegment equed, MemorySegment s, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment rcond, MemorySegment ferr, MemorySegment berr, MemorySegment work, MemorySegment iwork) {
        var mh$ = LAPACKE_sppsvx_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sppsvx_work", matrix_layout, fact, uplo, n, nrhs, ap, afp, equed, s, b, ldb, x, ldx, rcond, ferr, berr, work, iwork);
            }
            return (int)mh$.invokeExact(matrix_layout, fact, uplo, n, nrhs, ap, afp, equed, s, b, ldb, x, ldx, rcond, ferr, berr, work, iwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dppsvx_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dppsvx_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dppsvx_work(int matrix_layout, char fact, char uplo, int n, int nrhs, double *ap, double *afp, char *equed, double *s, double *b, int ldb, double *x, int ldx, double *rcond, double *ferr, double *berr, double *work, int *iwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_dppsvx_work$descriptor() {
        return LAPACKE_dppsvx_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dppsvx_work(int matrix_layout, char fact, char uplo, int n, int nrhs, double *ap, double *afp, char *equed, double *s, double *b, int ldb, double *x, int ldx, double *rcond, double *ferr, double *berr, double *work, int *iwork)
     * }
     */
    public static MethodHandle LAPACKE_dppsvx_work$handle() {
        return LAPACKE_dppsvx_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dppsvx_work(int matrix_layout, char fact, char uplo, int n, int nrhs, double *ap, double *afp, char *equed, double *s, double *b, int ldb, double *x, int ldx, double *rcond, double *ferr, double *berr, double *work, int *iwork)
     * }
     */
    public static MemorySegment LAPACKE_dppsvx_work$address() {
        return LAPACKE_dppsvx_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dppsvx_work(int matrix_layout, char fact, char uplo, int n, int nrhs, double *ap, double *afp, char *equed, double *s, double *b, int ldb, double *x, int ldx, double *rcond, double *ferr, double *berr, double *work, int *iwork)
     * }
     */
    public static int LAPACKE_dppsvx_work(int matrix_layout, byte fact, byte uplo, int n, int nrhs, MemorySegment ap, MemorySegment afp, MemorySegment equed, MemorySegment s, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment rcond, MemorySegment ferr, MemorySegment berr, MemorySegment work, MemorySegment iwork) {
        var mh$ = LAPACKE_dppsvx_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dppsvx_work", matrix_layout, fact, uplo, n, nrhs, ap, afp, equed, s, b, ldb, x, ldx, rcond, ferr, berr, work, iwork);
            }
            return (int)mh$.invokeExact(matrix_layout, fact, uplo, n, nrhs, ap, afp, equed, s, b, ldb, x, ldx, rcond, ferr, berr, work, iwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cppsvx_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_cppsvx_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cppsvx_work(int matrix_layout, char fact, char uplo, int n, int nrhs, _Complex float *ap, _Complex float *afp, char *equed, float *s, _Complex float *b, int ldb, _Complex float *x, int ldx, float *rcond, float *ferr, float *berr, _Complex float *work, float *rwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_cppsvx_work$descriptor() {
        return LAPACKE_cppsvx_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cppsvx_work(int matrix_layout, char fact, char uplo, int n, int nrhs, _Complex float *ap, _Complex float *afp, char *equed, float *s, _Complex float *b, int ldb, _Complex float *x, int ldx, float *rcond, float *ferr, float *berr, _Complex float *work, float *rwork)
     * }
     */
    public static MethodHandle LAPACKE_cppsvx_work$handle() {
        return LAPACKE_cppsvx_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cppsvx_work(int matrix_layout, char fact, char uplo, int n, int nrhs, _Complex float *ap, _Complex float *afp, char *equed, float *s, _Complex float *b, int ldb, _Complex float *x, int ldx, float *rcond, float *ferr, float *berr, _Complex float *work, float *rwork)
     * }
     */
    public static MemorySegment LAPACKE_cppsvx_work$address() {
        return LAPACKE_cppsvx_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cppsvx_work(int matrix_layout, char fact, char uplo, int n, int nrhs, _Complex float *ap, _Complex float *afp, char *equed, float *s, _Complex float *b, int ldb, _Complex float *x, int ldx, float *rcond, float *ferr, float *berr, _Complex float *work, float *rwork)
     * }
     */
    public static int LAPACKE_cppsvx_work(int matrix_layout, byte fact, byte uplo, int n, int nrhs, MemorySegment ap, MemorySegment afp, MemorySegment equed, MemorySegment s, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment rcond, MemorySegment ferr, MemorySegment berr, MemorySegment work, MemorySegment rwork) {
        var mh$ = LAPACKE_cppsvx_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cppsvx_work", matrix_layout, fact, uplo, n, nrhs, ap, afp, equed, s, b, ldb, x, ldx, rcond, ferr, berr, work, rwork);
            }
            return (int)mh$.invokeExact(matrix_layout, fact, uplo, n, nrhs, ap, afp, equed, s, b, ldb, x, ldx, rcond, ferr, berr, work, rwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zppsvx_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zppsvx_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zppsvx_work(int matrix_layout, char fact, char uplo, int n, int nrhs, _Complex double *ap, _Complex double *afp, char *equed, double *s, _Complex double *b, int ldb, _Complex double *x, int ldx, double *rcond, double *ferr, double *berr, _Complex double *work, double *rwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_zppsvx_work$descriptor() {
        return LAPACKE_zppsvx_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zppsvx_work(int matrix_layout, char fact, char uplo, int n, int nrhs, _Complex double *ap, _Complex double *afp, char *equed, double *s, _Complex double *b, int ldb, _Complex double *x, int ldx, double *rcond, double *ferr, double *berr, _Complex double *work, double *rwork)
     * }
     */
    public static MethodHandle LAPACKE_zppsvx_work$handle() {
        return LAPACKE_zppsvx_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zppsvx_work(int matrix_layout, char fact, char uplo, int n, int nrhs, _Complex double *ap, _Complex double *afp, char *equed, double *s, _Complex double *b, int ldb, _Complex double *x, int ldx, double *rcond, double *ferr, double *berr, _Complex double *work, double *rwork)
     * }
     */
    public static MemorySegment LAPACKE_zppsvx_work$address() {
        return LAPACKE_zppsvx_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zppsvx_work(int matrix_layout, char fact, char uplo, int n, int nrhs, _Complex double *ap, _Complex double *afp, char *equed, double *s, _Complex double *b, int ldb, _Complex double *x, int ldx, double *rcond, double *ferr, double *berr, _Complex double *work, double *rwork)
     * }
     */
    public static int LAPACKE_zppsvx_work(int matrix_layout, byte fact, byte uplo, int n, int nrhs, MemorySegment ap, MemorySegment afp, MemorySegment equed, MemorySegment s, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment rcond, MemorySegment ferr, MemorySegment berr, MemorySegment work, MemorySegment rwork) {
        var mh$ = LAPACKE_zppsvx_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zppsvx_work", matrix_layout, fact, uplo, n, nrhs, ap, afp, equed, s, b, ldb, x, ldx, rcond, ferr, berr, work, rwork);
            }
            return (int)mh$.invokeExact(matrix_layout, fact, uplo, n, nrhs, ap, afp, equed, s, b, ldb, x, ldx, rcond, ferr, berr, work, rwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_spptrf_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_spptrf_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_spptrf_work(int matrix_layout, char uplo, int n, float *ap)
     * }
     */
    public static FunctionDescriptor LAPACKE_spptrf_work$descriptor() {
        return LAPACKE_spptrf_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_spptrf_work(int matrix_layout, char uplo, int n, float *ap)
     * }
     */
    public static MethodHandle LAPACKE_spptrf_work$handle() {
        return LAPACKE_spptrf_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_spptrf_work(int matrix_layout, char uplo, int n, float *ap)
     * }
     */
    public static MemorySegment LAPACKE_spptrf_work$address() {
        return LAPACKE_spptrf_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_spptrf_work(int matrix_layout, char uplo, int n, float *ap)
     * }
     */
    public static int LAPACKE_spptrf_work(int matrix_layout, byte uplo, int n, MemorySegment ap) {
        var mh$ = LAPACKE_spptrf_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_spptrf_work", matrix_layout, uplo, n, ap);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, ap);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dpptrf_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dpptrf_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dpptrf_work(int matrix_layout, char uplo, int n, double *ap)
     * }
     */
    public static FunctionDescriptor LAPACKE_dpptrf_work$descriptor() {
        return LAPACKE_dpptrf_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dpptrf_work(int matrix_layout, char uplo, int n, double *ap)
     * }
     */
    public static MethodHandle LAPACKE_dpptrf_work$handle() {
        return LAPACKE_dpptrf_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dpptrf_work(int matrix_layout, char uplo, int n, double *ap)
     * }
     */
    public static MemorySegment LAPACKE_dpptrf_work$address() {
        return LAPACKE_dpptrf_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dpptrf_work(int matrix_layout, char uplo, int n, double *ap)
     * }
     */
    public static int LAPACKE_dpptrf_work(int matrix_layout, byte uplo, int n, MemorySegment ap) {
        var mh$ = LAPACKE_dpptrf_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dpptrf_work", matrix_layout, uplo, n, ap);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, ap);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cpptrf_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_cpptrf_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cpptrf_work(int matrix_layout, char uplo, int n, _Complex float *ap)
     * }
     */
    public static FunctionDescriptor LAPACKE_cpptrf_work$descriptor() {
        return LAPACKE_cpptrf_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cpptrf_work(int matrix_layout, char uplo, int n, _Complex float *ap)
     * }
     */
    public static MethodHandle LAPACKE_cpptrf_work$handle() {
        return LAPACKE_cpptrf_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cpptrf_work(int matrix_layout, char uplo, int n, _Complex float *ap)
     * }
     */
    public static MemorySegment LAPACKE_cpptrf_work$address() {
        return LAPACKE_cpptrf_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cpptrf_work(int matrix_layout, char uplo, int n, _Complex float *ap)
     * }
     */
    public static int LAPACKE_cpptrf_work(int matrix_layout, byte uplo, int n, MemorySegment ap) {
        var mh$ = LAPACKE_cpptrf_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cpptrf_work", matrix_layout, uplo, n, ap);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, ap);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zpptrf_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zpptrf_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zpptrf_work(int matrix_layout, char uplo, int n, _Complex double *ap)
     * }
     */
    public static FunctionDescriptor LAPACKE_zpptrf_work$descriptor() {
        return LAPACKE_zpptrf_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zpptrf_work(int matrix_layout, char uplo, int n, _Complex double *ap)
     * }
     */
    public static MethodHandle LAPACKE_zpptrf_work$handle() {
        return LAPACKE_zpptrf_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zpptrf_work(int matrix_layout, char uplo, int n, _Complex double *ap)
     * }
     */
    public static MemorySegment LAPACKE_zpptrf_work$address() {
        return LAPACKE_zpptrf_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zpptrf_work(int matrix_layout, char uplo, int n, _Complex double *ap)
     * }
     */
    public static int LAPACKE_zpptrf_work(int matrix_layout, byte uplo, int n, MemorySegment ap) {
        var mh$ = LAPACKE_zpptrf_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zpptrf_work", matrix_layout, uplo, n, ap);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, ap);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_spptri_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_spptri_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_spptri_work(int matrix_layout, char uplo, int n, float *ap)
     * }
     */
    public static FunctionDescriptor LAPACKE_spptri_work$descriptor() {
        return LAPACKE_spptri_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_spptri_work(int matrix_layout, char uplo, int n, float *ap)
     * }
     */
    public static MethodHandle LAPACKE_spptri_work$handle() {
        return LAPACKE_spptri_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_spptri_work(int matrix_layout, char uplo, int n, float *ap)
     * }
     */
    public static MemorySegment LAPACKE_spptri_work$address() {
        return LAPACKE_spptri_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_spptri_work(int matrix_layout, char uplo, int n, float *ap)
     * }
     */
    public static int LAPACKE_spptri_work(int matrix_layout, byte uplo, int n, MemorySegment ap) {
        var mh$ = LAPACKE_spptri_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_spptri_work", matrix_layout, uplo, n, ap);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, ap);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dpptri_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dpptri_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dpptri_work(int matrix_layout, char uplo, int n, double *ap)
     * }
     */
    public static FunctionDescriptor LAPACKE_dpptri_work$descriptor() {
        return LAPACKE_dpptri_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dpptri_work(int matrix_layout, char uplo, int n, double *ap)
     * }
     */
    public static MethodHandle LAPACKE_dpptri_work$handle() {
        return LAPACKE_dpptri_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dpptri_work(int matrix_layout, char uplo, int n, double *ap)
     * }
     */
    public static MemorySegment LAPACKE_dpptri_work$address() {
        return LAPACKE_dpptri_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dpptri_work(int matrix_layout, char uplo, int n, double *ap)
     * }
     */
    public static int LAPACKE_dpptri_work(int matrix_layout, byte uplo, int n, MemorySegment ap) {
        var mh$ = LAPACKE_dpptri_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dpptri_work", matrix_layout, uplo, n, ap);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, ap);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cpptri_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_cpptri_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cpptri_work(int matrix_layout, char uplo, int n, _Complex float *ap)
     * }
     */
    public static FunctionDescriptor LAPACKE_cpptri_work$descriptor() {
        return LAPACKE_cpptri_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cpptri_work(int matrix_layout, char uplo, int n, _Complex float *ap)
     * }
     */
    public static MethodHandle LAPACKE_cpptri_work$handle() {
        return LAPACKE_cpptri_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cpptri_work(int matrix_layout, char uplo, int n, _Complex float *ap)
     * }
     */
    public static MemorySegment LAPACKE_cpptri_work$address() {
        return LAPACKE_cpptri_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cpptri_work(int matrix_layout, char uplo, int n, _Complex float *ap)
     * }
     */
    public static int LAPACKE_cpptri_work(int matrix_layout, byte uplo, int n, MemorySegment ap) {
        var mh$ = LAPACKE_cpptri_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cpptri_work", matrix_layout, uplo, n, ap);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, ap);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zpptri_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zpptri_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zpptri_work(int matrix_layout, char uplo, int n, _Complex double *ap)
     * }
     */
    public static FunctionDescriptor LAPACKE_zpptri_work$descriptor() {
        return LAPACKE_zpptri_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zpptri_work(int matrix_layout, char uplo, int n, _Complex double *ap)
     * }
     */
    public static MethodHandle LAPACKE_zpptri_work$handle() {
        return LAPACKE_zpptri_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zpptri_work(int matrix_layout, char uplo, int n, _Complex double *ap)
     * }
     */
    public static MemorySegment LAPACKE_zpptri_work$address() {
        return LAPACKE_zpptri_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zpptri_work(int matrix_layout, char uplo, int n, _Complex double *ap)
     * }
     */
    public static int LAPACKE_zpptri_work(int matrix_layout, byte uplo, int n, MemorySegment ap) {
        var mh$ = LAPACKE_zpptri_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zpptri_work", matrix_layout, uplo, n, ap);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, ap);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_spptrs_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_spptrs_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_spptrs_work(int matrix_layout, char uplo, int n, int nrhs, const float *ap, float *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_spptrs_work$descriptor() {
        return LAPACKE_spptrs_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_spptrs_work(int matrix_layout, char uplo, int n, int nrhs, const float *ap, float *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_spptrs_work$handle() {
        return LAPACKE_spptrs_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_spptrs_work(int matrix_layout, char uplo, int n, int nrhs, const float *ap, float *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_spptrs_work$address() {
        return LAPACKE_spptrs_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_spptrs_work(int matrix_layout, char uplo, int n, int nrhs, const float *ap, float *b, int ldb)
     * }
     */
    public static int LAPACKE_spptrs_work(int matrix_layout, byte uplo, int n, int nrhs, MemorySegment ap, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_spptrs_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_spptrs_work", matrix_layout, uplo, n, nrhs, ap, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, nrhs, ap, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dpptrs_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dpptrs_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dpptrs_work(int matrix_layout, char uplo, int n, int nrhs, const double *ap, double *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_dpptrs_work$descriptor() {
        return LAPACKE_dpptrs_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dpptrs_work(int matrix_layout, char uplo, int n, int nrhs, const double *ap, double *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_dpptrs_work$handle() {
        return LAPACKE_dpptrs_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dpptrs_work(int matrix_layout, char uplo, int n, int nrhs, const double *ap, double *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_dpptrs_work$address() {
        return LAPACKE_dpptrs_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dpptrs_work(int matrix_layout, char uplo, int n, int nrhs, const double *ap, double *b, int ldb)
     * }
     */
    public static int LAPACKE_dpptrs_work(int matrix_layout, byte uplo, int n, int nrhs, MemorySegment ap, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_dpptrs_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dpptrs_work", matrix_layout, uplo, n, nrhs, ap, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, nrhs, ap, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cpptrs_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_cpptrs_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cpptrs_work(int matrix_layout, char uplo, int n, int nrhs, const _Complex float *ap, _Complex float *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_cpptrs_work$descriptor() {
        return LAPACKE_cpptrs_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cpptrs_work(int matrix_layout, char uplo, int n, int nrhs, const _Complex float *ap, _Complex float *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_cpptrs_work$handle() {
        return LAPACKE_cpptrs_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cpptrs_work(int matrix_layout, char uplo, int n, int nrhs, const _Complex float *ap, _Complex float *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_cpptrs_work$address() {
        return LAPACKE_cpptrs_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cpptrs_work(int matrix_layout, char uplo, int n, int nrhs, const _Complex float *ap, _Complex float *b, int ldb)
     * }
     */
    public static int LAPACKE_cpptrs_work(int matrix_layout, byte uplo, int n, int nrhs, MemorySegment ap, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_cpptrs_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cpptrs_work", matrix_layout, uplo, n, nrhs, ap, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, nrhs, ap, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zpptrs_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zpptrs_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zpptrs_work(int matrix_layout, char uplo, int n, int nrhs, const _Complex double *ap, _Complex double *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_zpptrs_work$descriptor() {
        return LAPACKE_zpptrs_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zpptrs_work(int matrix_layout, char uplo, int n, int nrhs, const _Complex double *ap, _Complex double *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_zpptrs_work$handle() {
        return LAPACKE_zpptrs_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zpptrs_work(int matrix_layout, char uplo, int n, int nrhs, const _Complex double *ap, _Complex double *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_zpptrs_work$address() {
        return LAPACKE_zpptrs_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zpptrs_work(int matrix_layout, char uplo, int n, int nrhs, const _Complex double *ap, _Complex double *b, int ldb)
     * }
     */
    public static int LAPACKE_zpptrs_work(int matrix_layout, byte uplo, int n, int nrhs, MemorySegment ap, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_zpptrs_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zpptrs_work", matrix_layout, uplo, n, nrhs, ap, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, nrhs, ap, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_spstrf_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_FLOAT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_spstrf_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_spstrf_work(int matrix_layout, char uplo, int n, float *a, int lda, int *piv, int *rank, float tol, float *work)
     * }
     */
    public static FunctionDescriptor LAPACKE_spstrf_work$descriptor() {
        return LAPACKE_spstrf_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_spstrf_work(int matrix_layout, char uplo, int n, float *a, int lda, int *piv, int *rank, float tol, float *work)
     * }
     */
    public static MethodHandle LAPACKE_spstrf_work$handle() {
        return LAPACKE_spstrf_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_spstrf_work(int matrix_layout, char uplo, int n, float *a, int lda, int *piv, int *rank, float tol, float *work)
     * }
     */
    public static MemorySegment LAPACKE_spstrf_work$address() {
        return LAPACKE_spstrf_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_spstrf_work(int matrix_layout, char uplo, int n, float *a, int lda, int *piv, int *rank, float tol, float *work)
     * }
     */
    public static int LAPACKE_spstrf_work(int matrix_layout, byte uplo, int n, MemorySegment a, int lda, MemorySegment piv, MemorySegment rank, float tol, MemorySegment work) {
        var mh$ = LAPACKE_spstrf_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_spstrf_work", matrix_layout, uplo, n, a, lda, piv, rank, tol, work);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, a, lda, piv, rank, tol, work);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dpstrf_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_DOUBLE,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dpstrf_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dpstrf_work(int matrix_layout, char uplo, int n, double *a, int lda, int *piv, int *rank, double tol, double *work)
     * }
     */
    public static FunctionDescriptor LAPACKE_dpstrf_work$descriptor() {
        return LAPACKE_dpstrf_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dpstrf_work(int matrix_layout, char uplo, int n, double *a, int lda, int *piv, int *rank, double tol, double *work)
     * }
     */
    public static MethodHandle LAPACKE_dpstrf_work$handle() {
        return LAPACKE_dpstrf_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dpstrf_work(int matrix_layout, char uplo, int n, double *a, int lda, int *piv, int *rank, double tol, double *work)
     * }
     */
    public static MemorySegment LAPACKE_dpstrf_work$address() {
        return LAPACKE_dpstrf_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dpstrf_work(int matrix_layout, char uplo, int n, double *a, int lda, int *piv, int *rank, double tol, double *work)
     * }
     */
    public static int LAPACKE_dpstrf_work(int matrix_layout, byte uplo, int n, MemorySegment a, int lda, MemorySegment piv, MemorySegment rank, double tol, MemorySegment work) {
        var mh$ = LAPACKE_dpstrf_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dpstrf_work", matrix_layout, uplo, n, a, lda, piv, rank, tol, work);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, a, lda, piv, rank, tol, work);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cpstrf_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_FLOAT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_cpstrf_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cpstrf_work(int matrix_layout, char uplo, int n, _Complex float *a, int lda, int *piv, int *rank, float tol, float *work)
     * }
     */
    public static FunctionDescriptor LAPACKE_cpstrf_work$descriptor() {
        return LAPACKE_cpstrf_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cpstrf_work(int matrix_layout, char uplo, int n, _Complex float *a, int lda, int *piv, int *rank, float tol, float *work)
     * }
     */
    public static MethodHandle LAPACKE_cpstrf_work$handle() {
        return LAPACKE_cpstrf_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cpstrf_work(int matrix_layout, char uplo, int n, _Complex float *a, int lda, int *piv, int *rank, float tol, float *work)
     * }
     */
    public static MemorySegment LAPACKE_cpstrf_work$address() {
        return LAPACKE_cpstrf_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cpstrf_work(int matrix_layout, char uplo, int n, _Complex float *a, int lda, int *piv, int *rank, float tol, float *work)
     * }
     */
    public static int LAPACKE_cpstrf_work(int matrix_layout, byte uplo, int n, MemorySegment a, int lda, MemorySegment piv, MemorySegment rank, float tol, MemorySegment work) {
        var mh$ = LAPACKE_cpstrf_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cpstrf_work", matrix_layout, uplo, n, a, lda, piv, rank, tol, work);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, a, lda, piv, rank, tol, work);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zpstrf_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_DOUBLE,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zpstrf_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zpstrf_work(int matrix_layout, char uplo, int n, _Complex double *a, int lda, int *piv, int *rank, double tol, double *work)
     * }
     */
    public static FunctionDescriptor LAPACKE_zpstrf_work$descriptor() {
        return LAPACKE_zpstrf_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zpstrf_work(int matrix_layout, char uplo, int n, _Complex double *a, int lda, int *piv, int *rank, double tol, double *work)
     * }
     */
    public static MethodHandle LAPACKE_zpstrf_work$handle() {
        return LAPACKE_zpstrf_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zpstrf_work(int matrix_layout, char uplo, int n, _Complex double *a, int lda, int *piv, int *rank, double tol, double *work)
     * }
     */
    public static MemorySegment LAPACKE_zpstrf_work$address() {
        return LAPACKE_zpstrf_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zpstrf_work(int matrix_layout, char uplo, int n, _Complex double *a, int lda, int *piv, int *rank, double tol, double *work)
     * }
     */
    public static int LAPACKE_zpstrf_work(int matrix_layout, byte uplo, int n, MemorySegment a, int lda, MemorySegment piv, MemorySegment rank, double tol, MemorySegment work) {
        var mh$ = LAPACKE_zpstrf_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zpstrf_work", matrix_layout, uplo, n, a, lda, piv, rank, tol, work);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, a, lda, piv, rank, tol, work);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sptcon_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_FLOAT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_sptcon_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sptcon_work(int n, const float *d, const float *e, float anorm, float *rcond, float *work)
     * }
     */
    public static FunctionDescriptor LAPACKE_sptcon_work$descriptor() {
        return LAPACKE_sptcon_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sptcon_work(int n, const float *d, const float *e, float anorm, float *rcond, float *work)
     * }
     */
    public static MethodHandle LAPACKE_sptcon_work$handle() {
        return LAPACKE_sptcon_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sptcon_work(int n, const float *d, const float *e, float anorm, float *rcond, float *work)
     * }
     */
    public static MemorySegment LAPACKE_sptcon_work$address() {
        return LAPACKE_sptcon_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sptcon_work(int n, const float *d, const float *e, float anorm, float *rcond, float *work)
     * }
     */
    public static int LAPACKE_sptcon_work(int n, MemorySegment d, MemorySegment e, float anorm, MemorySegment rcond, MemorySegment work) {
        var mh$ = LAPACKE_sptcon_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sptcon_work", n, d, e, anorm, rcond, work);
            }
            return (int)mh$.invokeExact(n, d, e, anorm, rcond, work);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dptcon_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_DOUBLE,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dptcon_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dptcon_work(int n, const double *d, const double *e, double anorm, double *rcond, double *work)
     * }
     */
    public static FunctionDescriptor LAPACKE_dptcon_work$descriptor() {
        return LAPACKE_dptcon_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dptcon_work(int n, const double *d, const double *e, double anorm, double *rcond, double *work)
     * }
     */
    public static MethodHandle LAPACKE_dptcon_work$handle() {
        return LAPACKE_dptcon_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dptcon_work(int n, const double *d, const double *e, double anorm, double *rcond, double *work)
     * }
     */
    public static MemorySegment LAPACKE_dptcon_work$address() {
        return LAPACKE_dptcon_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dptcon_work(int n, const double *d, const double *e, double anorm, double *rcond, double *work)
     * }
     */
    public static int LAPACKE_dptcon_work(int n, MemorySegment d, MemorySegment e, double anorm, MemorySegment rcond, MemorySegment work) {
        var mh$ = LAPACKE_dptcon_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dptcon_work", n, d, e, anorm, rcond, work);
            }
            return (int)mh$.invokeExact(n, d, e, anorm, rcond, work);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cptcon_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_FLOAT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_cptcon_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cptcon_work(int n, const float *d, const _Complex float *e, float anorm, float *rcond, float *work)
     * }
     */
    public static FunctionDescriptor LAPACKE_cptcon_work$descriptor() {
        return LAPACKE_cptcon_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cptcon_work(int n, const float *d, const _Complex float *e, float anorm, float *rcond, float *work)
     * }
     */
    public static MethodHandle LAPACKE_cptcon_work$handle() {
        return LAPACKE_cptcon_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cptcon_work(int n, const float *d, const _Complex float *e, float anorm, float *rcond, float *work)
     * }
     */
    public static MemorySegment LAPACKE_cptcon_work$address() {
        return LAPACKE_cptcon_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cptcon_work(int n, const float *d, const _Complex float *e, float anorm, float *rcond, float *work)
     * }
     */
    public static int LAPACKE_cptcon_work(int n, MemorySegment d, MemorySegment e, float anorm, MemorySegment rcond, MemorySegment work) {
        var mh$ = LAPACKE_cptcon_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cptcon_work", n, d, e, anorm, rcond, work);
            }
            return (int)mh$.invokeExact(n, d, e, anorm, rcond, work);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zptcon_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_DOUBLE,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zptcon_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zptcon_work(int n, const double *d, const _Complex double *e, double anorm, double *rcond, double *work)
     * }
     */
    public static FunctionDescriptor LAPACKE_zptcon_work$descriptor() {
        return LAPACKE_zptcon_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zptcon_work(int n, const double *d, const _Complex double *e, double anorm, double *rcond, double *work)
     * }
     */
    public static MethodHandle LAPACKE_zptcon_work$handle() {
        return LAPACKE_zptcon_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zptcon_work(int n, const double *d, const _Complex double *e, double anorm, double *rcond, double *work)
     * }
     */
    public static MemorySegment LAPACKE_zptcon_work$address() {
        return LAPACKE_zptcon_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zptcon_work(int n, const double *d, const _Complex double *e, double anorm, double *rcond, double *work)
     * }
     */
    public static int LAPACKE_zptcon_work(int n, MemorySegment d, MemorySegment e, double anorm, MemorySegment rcond, MemorySegment work) {
        var mh$ = LAPACKE_zptcon_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zptcon_work", n, d, e, anorm, rcond, work);
            }
            return (int)mh$.invokeExact(n, d, e, anorm, rcond, work);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_spteqr_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_spteqr_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_spteqr_work(int matrix_layout, char compz, int n, float *d, float *e, float *z, int ldz, float *work)
     * }
     */
    public static FunctionDescriptor LAPACKE_spteqr_work$descriptor() {
        return LAPACKE_spteqr_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_spteqr_work(int matrix_layout, char compz, int n, float *d, float *e, float *z, int ldz, float *work)
     * }
     */
    public static MethodHandle LAPACKE_spteqr_work$handle() {
        return LAPACKE_spteqr_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_spteqr_work(int matrix_layout, char compz, int n, float *d, float *e, float *z, int ldz, float *work)
     * }
     */
    public static MemorySegment LAPACKE_spteqr_work$address() {
        return LAPACKE_spteqr_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_spteqr_work(int matrix_layout, char compz, int n, float *d, float *e, float *z, int ldz, float *work)
     * }
     */
    public static int LAPACKE_spteqr_work(int matrix_layout, byte compz, int n, MemorySegment d, MemorySegment e, MemorySegment z, int ldz, MemorySegment work) {
        var mh$ = LAPACKE_spteqr_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_spteqr_work", matrix_layout, compz, n, d, e, z, ldz, work);
            }
            return (int)mh$.invokeExact(matrix_layout, compz, n, d, e, z, ldz, work);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dpteqr_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dpteqr_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dpteqr_work(int matrix_layout, char compz, int n, double *d, double *e, double *z, int ldz, double *work)
     * }
     */
    public static FunctionDescriptor LAPACKE_dpteqr_work$descriptor() {
        return LAPACKE_dpteqr_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dpteqr_work(int matrix_layout, char compz, int n, double *d, double *e, double *z, int ldz, double *work)
     * }
     */
    public static MethodHandle LAPACKE_dpteqr_work$handle() {
        return LAPACKE_dpteqr_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dpteqr_work(int matrix_layout, char compz, int n, double *d, double *e, double *z, int ldz, double *work)
     * }
     */
    public static MemorySegment LAPACKE_dpteqr_work$address() {
        return LAPACKE_dpteqr_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dpteqr_work(int matrix_layout, char compz, int n, double *d, double *e, double *z, int ldz, double *work)
     * }
     */
    public static int LAPACKE_dpteqr_work(int matrix_layout, byte compz, int n, MemorySegment d, MemorySegment e, MemorySegment z, int ldz, MemorySegment work) {
        var mh$ = LAPACKE_dpteqr_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dpteqr_work", matrix_layout, compz, n, d, e, z, ldz, work);
            }
            return (int)mh$.invokeExact(matrix_layout, compz, n, d, e, z, ldz, work);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cpteqr_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_cpteqr_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cpteqr_work(int matrix_layout, char compz, int n, float *d, float *e, _Complex float *z, int ldz, float *work)
     * }
     */
    public static FunctionDescriptor LAPACKE_cpteqr_work$descriptor() {
        return LAPACKE_cpteqr_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cpteqr_work(int matrix_layout, char compz, int n, float *d, float *e, _Complex float *z, int ldz, float *work)
     * }
     */
    public static MethodHandle LAPACKE_cpteqr_work$handle() {
        return LAPACKE_cpteqr_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cpteqr_work(int matrix_layout, char compz, int n, float *d, float *e, _Complex float *z, int ldz, float *work)
     * }
     */
    public static MemorySegment LAPACKE_cpteqr_work$address() {
        return LAPACKE_cpteqr_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cpteqr_work(int matrix_layout, char compz, int n, float *d, float *e, _Complex float *z, int ldz, float *work)
     * }
     */
    public static int LAPACKE_cpteqr_work(int matrix_layout, byte compz, int n, MemorySegment d, MemorySegment e, MemorySegment z, int ldz, MemorySegment work) {
        var mh$ = LAPACKE_cpteqr_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cpteqr_work", matrix_layout, compz, n, d, e, z, ldz, work);
            }
            return (int)mh$.invokeExact(matrix_layout, compz, n, d, e, z, ldz, work);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zpteqr_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zpteqr_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zpteqr_work(int matrix_layout, char compz, int n, double *d, double *e, _Complex double *z, int ldz, double *work)
     * }
     */
    public static FunctionDescriptor LAPACKE_zpteqr_work$descriptor() {
        return LAPACKE_zpteqr_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zpteqr_work(int matrix_layout, char compz, int n, double *d, double *e, _Complex double *z, int ldz, double *work)
     * }
     */
    public static MethodHandle LAPACKE_zpteqr_work$handle() {
        return LAPACKE_zpteqr_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zpteqr_work(int matrix_layout, char compz, int n, double *d, double *e, _Complex double *z, int ldz, double *work)
     * }
     */
    public static MemorySegment LAPACKE_zpteqr_work$address() {
        return LAPACKE_zpteqr_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zpteqr_work(int matrix_layout, char compz, int n, double *d, double *e, _Complex double *z, int ldz, double *work)
     * }
     */
    public static int LAPACKE_zpteqr_work(int matrix_layout, byte compz, int n, MemorySegment d, MemorySegment e, MemorySegment z, int ldz, MemorySegment work) {
        var mh$ = LAPACKE_zpteqr_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zpteqr_work", matrix_layout, compz, n, d, e, z, ldz, work);
            }
            return (int)mh$.invokeExact(matrix_layout, compz, n, d, e, z, ldz, work);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sptrfs_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_sptrfs_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sptrfs_work(int matrix_layout, int n, int nrhs, const float *d, const float *e, const float *df, const float *ef, const float *b, int ldb, float *x, int ldx, float *ferr, float *berr, float *work)
     * }
     */
    public static FunctionDescriptor LAPACKE_sptrfs_work$descriptor() {
        return LAPACKE_sptrfs_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sptrfs_work(int matrix_layout, int n, int nrhs, const float *d, const float *e, const float *df, const float *ef, const float *b, int ldb, float *x, int ldx, float *ferr, float *berr, float *work)
     * }
     */
    public static MethodHandle LAPACKE_sptrfs_work$handle() {
        return LAPACKE_sptrfs_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sptrfs_work(int matrix_layout, int n, int nrhs, const float *d, const float *e, const float *df, const float *ef, const float *b, int ldb, float *x, int ldx, float *ferr, float *berr, float *work)
     * }
     */
    public static MemorySegment LAPACKE_sptrfs_work$address() {
        return LAPACKE_sptrfs_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sptrfs_work(int matrix_layout, int n, int nrhs, const float *d, const float *e, const float *df, const float *ef, const float *b, int ldb, float *x, int ldx, float *ferr, float *berr, float *work)
     * }
     */
    public static int LAPACKE_sptrfs_work(int matrix_layout, int n, int nrhs, MemorySegment d, MemorySegment e, MemorySegment df, MemorySegment ef, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment ferr, MemorySegment berr, MemorySegment work) {
        var mh$ = LAPACKE_sptrfs_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sptrfs_work", matrix_layout, n, nrhs, d, e, df, ef, b, ldb, x, ldx, ferr, berr, work);
            }
            return (int)mh$.invokeExact(matrix_layout, n, nrhs, d, e, df, ef, b, ldb, x, ldx, ferr, berr, work);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dptrfs_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dptrfs_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dptrfs_work(int matrix_layout, int n, int nrhs, const double *d, const double *e, const double *df, const double *ef, const double *b, int ldb, double *x, int ldx, double *ferr, double *berr, double *work)
     * }
     */
    public static FunctionDescriptor LAPACKE_dptrfs_work$descriptor() {
        return LAPACKE_dptrfs_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dptrfs_work(int matrix_layout, int n, int nrhs, const double *d, const double *e, const double *df, const double *ef, const double *b, int ldb, double *x, int ldx, double *ferr, double *berr, double *work)
     * }
     */
    public static MethodHandle LAPACKE_dptrfs_work$handle() {
        return LAPACKE_dptrfs_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dptrfs_work(int matrix_layout, int n, int nrhs, const double *d, const double *e, const double *df, const double *ef, const double *b, int ldb, double *x, int ldx, double *ferr, double *berr, double *work)
     * }
     */
    public static MemorySegment LAPACKE_dptrfs_work$address() {
        return LAPACKE_dptrfs_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dptrfs_work(int matrix_layout, int n, int nrhs, const double *d, const double *e, const double *df, const double *ef, const double *b, int ldb, double *x, int ldx, double *ferr, double *berr, double *work)
     * }
     */
    public static int LAPACKE_dptrfs_work(int matrix_layout, int n, int nrhs, MemorySegment d, MemorySegment e, MemorySegment df, MemorySegment ef, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment ferr, MemorySegment berr, MemorySegment work) {
        var mh$ = LAPACKE_dptrfs_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dptrfs_work", matrix_layout, n, nrhs, d, e, df, ef, b, ldb, x, ldx, ferr, berr, work);
            }
            return (int)mh$.invokeExact(matrix_layout, n, nrhs, d, e, df, ef, b, ldb, x, ldx, ferr, berr, work);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cptrfs_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_cptrfs_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cptrfs_work(int matrix_layout, char uplo, int n, int nrhs, const float *d, const _Complex float *e, const float *df, const _Complex float *ef, const _Complex float *b, int ldb, _Complex float *x, int ldx, float *ferr, float *berr, _Complex float *work, float *rwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_cptrfs_work$descriptor() {
        return LAPACKE_cptrfs_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cptrfs_work(int matrix_layout, char uplo, int n, int nrhs, const float *d, const _Complex float *e, const float *df, const _Complex float *ef, const _Complex float *b, int ldb, _Complex float *x, int ldx, float *ferr, float *berr, _Complex float *work, float *rwork)
     * }
     */
    public static MethodHandle LAPACKE_cptrfs_work$handle() {
        return LAPACKE_cptrfs_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cptrfs_work(int matrix_layout, char uplo, int n, int nrhs, const float *d, const _Complex float *e, const float *df, const _Complex float *ef, const _Complex float *b, int ldb, _Complex float *x, int ldx, float *ferr, float *berr, _Complex float *work, float *rwork)
     * }
     */
    public static MemorySegment LAPACKE_cptrfs_work$address() {
        return LAPACKE_cptrfs_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cptrfs_work(int matrix_layout, char uplo, int n, int nrhs, const float *d, const _Complex float *e, const float *df, const _Complex float *ef, const _Complex float *b, int ldb, _Complex float *x, int ldx, float *ferr, float *berr, _Complex float *work, float *rwork)
     * }
     */
    public static int LAPACKE_cptrfs_work(int matrix_layout, byte uplo, int n, int nrhs, MemorySegment d, MemorySegment e, MemorySegment df, MemorySegment ef, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment ferr, MemorySegment berr, MemorySegment work, MemorySegment rwork) {
        var mh$ = LAPACKE_cptrfs_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cptrfs_work", matrix_layout, uplo, n, nrhs, d, e, df, ef, b, ldb, x, ldx, ferr, berr, work, rwork);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, nrhs, d, e, df, ef, b, ldb, x, ldx, ferr, berr, work, rwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zptrfs_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zptrfs_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zptrfs_work(int matrix_layout, char uplo, int n, int nrhs, const double *d, const _Complex double *e, const double *df, const _Complex double *ef, const _Complex double *b, int ldb, _Complex double *x, int ldx, double *ferr, double *berr, _Complex double *work, double *rwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_zptrfs_work$descriptor() {
        return LAPACKE_zptrfs_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zptrfs_work(int matrix_layout, char uplo, int n, int nrhs, const double *d, const _Complex double *e, const double *df, const _Complex double *ef, const _Complex double *b, int ldb, _Complex double *x, int ldx, double *ferr, double *berr, _Complex double *work, double *rwork)
     * }
     */
    public static MethodHandle LAPACKE_zptrfs_work$handle() {
        return LAPACKE_zptrfs_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zptrfs_work(int matrix_layout, char uplo, int n, int nrhs, const double *d, const _Complex double *e, const double *df, const _Complex double *ef, const _Complex double *b, int ldb, _Complex double *x, int ldx, double *ferr, double *berr, _Complex double *work, double *rwork)
     * }
     */
    public static MemorySegment LAPACKE_zptrfs_work$address() {
        return LAPACKE_zptrfs_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zptrfs_work(int matrix_layout, char uplo, int n, int nrhs, const double *d, const _Complex double *e, const double *df, const _Complex double *ef, const _Complex double *b, int ldb, _Complex double *x, int ldx, double *ferr, double *berr, _Complex double *work, double *rwork)
     * }
     */
    public static int LAPACKE_zptrfs_work(int matrix_layout, byte uplo, int n, int nrhs, MemorySegment d, MemorySegment e, MemorySegment df, MemorySegment ef, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment ferr, MemorySegment berr, MemorySegment work, MemorySegment rwork) {
        var mh$ = LAPACKE_zptrfs_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zptrfs_work", matrix_layout, uplo, n, nrhs, d, e, df, ef, b, ldb, x, ldx, ferr, berr, work, rwork);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, nrhs, d, e, df, ef, b, ldb, x, ldx, ferr, berr, work, rwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sptsv_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_sptsv_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sptsv_work(int matrix_layout, int n, int nrhs, float *d, float *e, float *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_sptsv_work$descriptor() {
        return LAPACKE_sptsv_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sptsv_work(int matrix_layout, int n, int nrhs, float *d, float *e, float *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_sptsv_work$handle() {
        return LAPACKE_sptsv_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sptsv_work(int matrix_layout, int n, int nrhs, float *d, float *e, float *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_sptsv_work$address() {
        return LAPACKE_sptsv_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sptsv_work(int matrix_layout, int n, int nrhs, float *d, float *e, float *b, int ldb)
     * }
     */
    public static int LAPACKE_sptsv_work(int matrix_layout, int n, int nrhs, MemorySegment d, MemorySegment e, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_sptsv_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sptsv_work", matrix_layout, n, nrhs, d, e, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, n, nrhs, d, e, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dptsv_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dptsv_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dptsv_work(int matrix_layout, int n, int nrhs, double *d, double *e, double *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_dptsv_work$descriptor() {
        return LAPACKE_dptsv_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dptsv_work(int matrix_layout, int n, int nrhs, double *d, double *e, double *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_dptsv_work$handle() {
        return LAPACKE_dptsv_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dptsv_work(int matrix_layout, int n, int nrhs, double *d, double *e, double *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_dptsv_work$address() {
        return LAPACKE_dptsv_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dptsv_work(int matrix_layout, int n, int nrhs, double *d, double *e, double *b, int ldb)
     * }
     */
    public static int LAPACKE_dptsv_work(int matrix_layout, int n, int nrhs, MemorySegment d, MemorySegment e, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_dptsv_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dptsv_work", matrix_layout, n, nrhs, d, e, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, n, nrhs, d, e, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cptsv_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_cptsv_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cptsv_work(int matrix_layout, int n, int nrhs, float *d, _Complex float *e, _Complex float *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_cptsv_work$descriptor() {
        return LAPACKE_cptsv_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cptsv_work(int matrix_layout, int n, int nrhs, float *d, _Complex float *e, _Complex float *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_cptsv_work$handle() {
        return LAPACKE_cptsv_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cptsv_work(int matrix_layout, int n, int nrhs, float *d, _Complex float *e, _Complex float *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_cptsv_work$address() {
        return LAPACKE_cptsv_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cptsv_work(int matrix_layout, int n, int nrhs, float *d, _Complex float *e, _Complex float *b, int ldb)
     * }
     */
    public static int LAPACKE_cptsv_work(int matrix_layout, int n, int nrhs, MemorySegment d, MemorySegment e, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_cptsv_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cptsv_work", matrix_layout, n, nrhs, d, e, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, n, nrhs, d, e, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zptsv_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zptsv_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zptsv_work(int matrix_layout, int n, int nrhs, double *d, _Complex double *e, _Complex double *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_zptsv_work$descriptor() {
        return LAPACKE_zptsv_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zptsv_work(int matrix_layout, int n, int nrhs, double *d, _Complex double *e, _Complex double *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_zptsv_work$handle() {
        return LAPACKE_zptsv_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zptsv_work(int matrix_layout, int n, int nrhs, double *d, _Complex double *e, _Complex double *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_zptsv_work$address() {
        return LAPACKE_zptsv_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zptsv_work(int matrix_layout, int n, int nrhs, double *d, _Complex double *e, _Complex double *b, int ldb)
     * }
     */
    public static int LAPACKE_zptsv_work(int matrix_layout, int n, int nrhs, MemorySegment d, MemorySegment e, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_zptsv_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zptsv_work", matrix_layout, n, nrhs, d, e, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, n, nrhs, d, e, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sptsvx_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_sptsvx_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sptsvx_work(int matrix_layout, char fact, int n, int nrhs, const float *d, const float *e, float *df, float *ef, const float *b, int ldb, float *x, int ldx, float *rcond, float *ferr, float *berr, float *work)
     * }
     */
    public static FunctionDescriptor LAPACKE_sptsvx_work$descriptor() {
        return LAPACKE_sptsvx_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sptsvx_work(int matrix_layout, char fact, int n, int nrhs, const float *d, const float *e, float *df, float *ef, const float *b, int ldb, float *x, int ldx, float *rcond, float *ferr, float *berr, float *work)
     * }
     */
    public static MethodHandle LAPACKE_sptsvx_work$handle() {
        return LAPACKE_sptsvx_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sptsvx_work(int matrix_layout, char fact, int n, int nrhs, const float *d, const float *e, float *df, float *ef, const float *b, int ldb, float *x, int ldx, float *rcond, float *ferr, float *berr, float *work)
     * }
     */
    public static MemorySegment LAPACKE_sptsvx_work$address() {
        return LAPACKE_sptsvx_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sptsvx_work(int matrix_layout, char fact, int n, int nrhs, const float *d, const float *e, float *df, float *ef, const float *b, int ldb, float *x, int ldx, float *rcond, float *ferr, float *berr, float *work)
     * }
     */
    public static int LAPACKE_sptsvx_work(int matrix_layout, byte fact, int n, int nrhs, MemorySegment d, MemorySegment e, MemorySegment df, MemorySegment ef, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment rcond, MemorySegment ferr, MemorySegment berr, MemorySegment work) {
        var mh$ = LAPACKE_sptsvx_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sptsvx_work", matrix_layout, fact, n, nrhs, d, e, df, ef, b, ldb, x, ldx, rcond, ferr, berr, work);
            }
            return (int)mh$.invokeExact(matrix_layout, fact, n, nrhs, d, e, df, ef, b, ldb, x, ldx, rcond, ferr, berr, work);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dptsvx_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dptsvx_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dptsvx_work(int matrix_layout, char fact, int n, int nrhs, const double *d, const double *e, double *df, double *ef, const double *b, int ldb, double *x, int ldx, double *rcond, double *ferr, double *berr, double *work)
     * }
     */
    public static FunctionDescriptor LAPACKE_dptsvx_work$descriptor() {
        return LAPACKE_dptsvx_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dptsvx_work(int matrix_layout, char fact, int n, int nrhs, const double *d, const double *e, double *df, double *ef, const double *b, int ldb, double *x, int ldx, double *rcond, double *ferr, double *berr, double *work)
     * }
     */
    public static MethodHandle LAPACKE_dptsvx_work$handle() {
        return LAPACKE_dptsvx_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dptsvx_work(int matrix_layout, char fact, int n, int nrhs, const double *d, const double *e, double *df, double *ef, const double *b, int ldb, double *x, int ldx, double *rcond, double *ferr, double *berr, double *work)
     * }
     */
    public static MemorySegment LAPACKE_dptsvx_work$address() {
        return LAPACKE_dptsvx_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dptsvx_work(int matrix_layout, char fact, int n, int nrhs, const double *d, const double *e, double *df, double *ef, const double *b, int ldb, double *x, int ldx, double *rcond, double *ferr, double *berr, double *work)
     * }
     */
    public static int LAPACKE_dptsvx_work(int matrix_layout, byte fact, int n, int nrhs, MemorySegment d, MemorySegment e, MemorySegment df, MemorySegment ef, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment rcond, MemorySegment ferr, MemorySegment berr, MemorySegment work) {
        var mh$ = LAPACKE_dptsvx_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dptsvx_work", matrix_layout, fact, n, nrhs, d, e, df, ef, b, ldb, x, ldx, rcond, ferr, berr, work);
            }
            return (int)mh$.invokeExact(matrix_layout, fact, n, nrhs, d, e, df, ef, b, ldb, x, ldx, rcond, ferr, berr, work);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cptsvx_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_cptsvx_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cptsvx_work(int matrix_layout, char fact, int n, int nrhs, const float *d, const _Complex float *e, float *df, _Complex float *ef, const _Complex float *b, int ldb, _Complex float *x, int ldx, float *rcond, float *ferr, float *berr, _Complex float *work, float *rwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_cptsvx_work$descriptor() {
        return LAPACKE_cptsvx_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cptsvx_work(int matrix_layout, char fact, int n, int nrhs, const float *d, const _Complex float *e, float *df, _Complex float *ef, const _Complex float *b, int ldb, _Complex float *x, int ldx, float *rcond, float *ferr, float *berr, _Complex float *work, float *rwork)
     * }
     */
    public static MethodHandle LAPACKE_cptsvx_work$handle() {
        return LAPACKE_cptsvx_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cptsvx_work(int matrix_layout, char fact, int n, int nrhs, const float *d, const _Complex float *e, float *df, _Complex float *ef, const _Complex float *b, int ldb, _Complex float *x, int ldx, float *rcond, float *ferr, float *berr, _Complex float *work, float *rwork)
     * }
     */
    public static MemorySegment LAPACKE_cptsvx_work$address() {
        return LAPACKE_cptsvx_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cptsvx_work(int matrix_layout, char fact, int n, int nrhs, const float *d, const _Complex float *e, float *df, _Complex float *ef, const _Complex float *b, int ldb, _Complex float *x, int ldx, float *rcond, float *ferr, float *berr, _Complex float *work, float *rwork)
     * }
     */
    public static int LAPACKE_cptsvx_work(int matrix_layout, byte fact, int n, int nrhs, MemorySegment d, MemorySegment e, MemorySegment df, MemorySegment ef, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment rcond, MemorySegment ferr, MemorySegment berr, MemorySegment work, MemorySegment rwork) {
        var mh$ = LAPACKE_cptsvx_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cptsvx_work", matrix_layout, fact, n, nrhs, d, e, df, ef, b, ldb, x, ldx, rcond, ferr, berr, work, rwork);
            }
            return (int)mh$.invokeExact(matrix_layout, fact, n, nrhs, d, e, df, ef, b, ldb, x, ldx, rcond, ferr, berr, work, rwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zptsvx_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zptsvx_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zptsvx_work(int matrix_layout, char fact, int n, int nrhs, const double *d, const _Complex double *e, double *df, _Complex double *ef, const _Complex double *b, int ldb, _Complex double *x, int ldx, double *rcond, double *ferr, double *berr, _Complex double *work, double *rwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_zptsvx_work$descriptor() {
        return LAPACKE_zptsvx_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zptsvx_work(int matrix_layout, char fact, int n, int nrhs, const double *d, const _Complex double *e, double *df, _Complex double *ef, const _Complex double *b, int ldb, _Complex double *x, int ldx, double *rcond, double *ferr, double *berr, _Complex double *work, double *rwork)
     * }
     */
    public static MethodHandle LAPACKE_zptsvx_work$handle() {
        return LAPACKE_zptsvx_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zptsvx_work(int matrix_layout, char fact, int n, int nrhs, const double *d, const _Complex double *e, double *df, _Complex double *ef, const _Complex double *b, int ldb, _Complex double *x, int ldx, double *rcond, double *ferr, double *berr, _Complex double *work, double *rwork)
     * }
     */
    public static MemorySegment LAPACKE_zptsvx_work$address() {
        return LAPACKE_zptsvx_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zptsvx_work(int matrix_layout, char fact, int n, int nrhs, const double *d, const _Complex double *e, double *df, _Complex double *ef, const _Complex double *b, int ldb, _Complex double *x, int ldx, double *rcond, double *ferr, double *berr, _Complex double *work, double *rwork)
     * }
     */
    public static int LAPACKE_zptsvx_work(int matrix_layout, byte fact, int n, int nrhs, MemorySegment d, MemorySegment e, MemorySegment df, MemorySegment ef, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment rcond, MemorySegment ferr, MemorySegment berr, MemorySegment work, MemorySegment rwork) {
        var mh$ = LAPACKE_zptsvx_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zptsvx_work", matrix_layout, fact, n, nrhs, d, e, df, ef, b, ldb, x, ldx, rcond, ferr, berr, work, rwork);
            }
            return (int)mh$.invokeExact(matrix_layout, fact, n, nrhs, d, e, df, ef, b, ldb, x, ldx, rcond, ferr, berr, work, rwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_spttrf_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_spttrf_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_spttrf_work(int n, float *d, float *e)
     * }
     */
    public static FunctionDescriptor LAPACKE_spttrf_work$descriptor() {
        return LAPACKE_spttrf_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_spttrf_work(int n, float *d, float *e)
     * }
     */
    public static MethodHandle LAPACKE_spttrf_work$handle() {
        return LAPACKE_spttrf_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_spttrf_work(int n, float *d, float *e)
     * }
     */
    public static MemorySegment LAPACKE_spttrf_work$address() {
        return LAPACKE_spttrf_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_spttrf_work(int n, float *d, float *e)
     * }
     */
    public static int LAPACKE_spttrf_work(int n, MemorySegment d, MemorySegment e) {
        var mh$ = LAPACKE_spttrf_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_spttrf_work", n, d, e);
            }
            return (int)mh$.invokeExact(n, d, e);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dpttrf_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dpttrf_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dpttrf_work(int n, double *d, double *e)
     * }
     */
    public static FunctionDescriptor LAPACKE_dpttrf_work$descriptor() {
        return LAPACKE_dpttrf_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dpttrf_work(int n, double *d, double *e)
     * }
     */
    public static MethodHandle LAPACKE_dpttrf_work$handle() {
        return LAPACKE_dpttrf_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dpttrf_work(int n, double *d, double *e)
     * }
     */
    public static MemorySegment LAPACKE_dpttrf_work$address() {
        return LAPACKE_dpttrf_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dpttrf_work(int n, double *d, double *e)
     * }
     */
    public static int LAPACKE_dpttrf_work(int n, MemorySegment d, MemorySegment e) {
        var mh$ = LAPACKE_dpttrf_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dpttrf_work", n, d, e);
            }
            return (int)mh$.invokeExact(n, d, e);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cpttrf_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_cpttrf_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cpttrf_work(int n, float *d, _Complex float *e)
     * }
     */
    public static FunctionDescriptor LAPACKE_cpttrf_work$descriptor() {
        return LAPACKE_cpttrf_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cpttrf_work(int n, float *d, _Complex float *e)
     * }
     */
    public static MethodHandle LAPACKE_cpttrf_work$handle() {
        return LAPACKE_cpttrf_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cpttrf_work(int n, float *d, _Complex float *e)
     * }
     */
    public static MemorySegment LAPACKE_cpttrf_work$address() {
        return LAPACKE_cpttrf_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cpttrf_work(int n, float *d, _Complex float *e)
     * }
     */
    public static int LAPACKE_cpttrf_work(int n, MemorySegment d, MemorySegment e) {
        var mh$ = LAPACKE_cpttrf_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cpttrf_work", n, d, e);
            }
            return (int)mh$.invokeExact(n, d, e);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zpttrf_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zpttrf_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zpttrf_work(int n, double *d, _Complex double *e)
     * }
     */
    public static FunctionDescriptor LAPACKE_zpttrf_work$descriptor() {
        return LAPACKE_zpttrf_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zpttrf_work(int n, double *d, _Complex double *e)
     * }
     */
    public static MethodHandle LAPACKE_zpttrf_work$handle() {
        return LAPACKE_zpttrf_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zpttrf_work(int n, double *d, _Complex double *e)
     * }
     */
    public static MemorySegment LAPACKE_zpttrf_work$address() {
        return LAPACKE_zpttrf_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zpttrf_work(int n, double *d, _Complex double *e)
     * }
     */
    public static int LAPACKE_zpttrf_work(int n, MemorySegment d, MemorySegment e) {
        var mh$ = LAPACKE_zpttrf_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zpttrf_work", n, d, e);
            }
            return (int)mh$.invokeExact(n, d, e);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_spttrs_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_spttrs_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_spttrs_work(int matrix_layout, int n, int nrhs, const float *d, const float *e, float *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_spttrs_work$descriptor() {
        return LAPACKE_spttrs_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_spttrs_work(int matrix_layout, int n, int nrhs, const float *d, const float *e, float *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_spttrs_work$handle() {
        return LAPACKE_spttrs_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_spttrs_work(int matrix_layout, int n, int nrhs, const float *d, const float *e, float *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_spttrs_work$address() {
        return LAPACKE_spttrs_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_spttrs_work(int matrix_layout, int n, int nrhs, const float *d, const float *e, float *b, int ldb)
     * }
     */
    public static int LAPACKE_spttrs_work(int matrix_layout, int n, int nrhs, MemorySegment d, MemorySegment e, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_spttrs_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_spttrs_work", matrix_layout, n, nrhs, d, e, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, n, nrhs, d, e, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dpttrs_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dpttrs_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dpttrs_work(int matrix_layout, int n, int nrhs, const double *d, const double *e, double *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_dpttrs_work$descriptor() {
        return LAPACKE_dpttrs_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dpttrs_work(int matrix_layout, int n, int nrhs, const double *d, const double *e, double *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_dpttrs_work$handle() {
        return LAPACKE_dpttrs_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dpttrs_work(int matrix_layout, int n, int nrhs, const double *d, const double *e, double *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_dpttrs_work$address() {
        return LAPACKE_dpttrs_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dpttrs_work(int matrix_layout, int n, int nrhs, const double *d, const double *e, double *b, int ldb)
     * }
     */
    public static int LAPACKE_dpttrs_work(int matrix_layout, int n, int nrhs, MemorySegment d, MemorySegment e, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_dpttrs_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dpttrs_work", matrix_layout, n, nrhs, d, e, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, n, nrhs, d, e, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cpttrs_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_cpttrs_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cpttrs_work(int matrix_layout, char uplo, int n, int nrhs, const float *d, const _Complex float *e, _Complex float *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_cpttrs_work$descriptor() {
        return LAPACKE_cpttrs_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cpttrs_work(int matrix_layout, char uplo, int n, int nrhs, const float *d, const _Complex float *e, _Complex float *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_cpttrs_work$handle() {
        return LAPACKE_cpttrs_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cpttrs_work(int matrix_layout, char uplo, int n, int nrhs, const float *d, const _Complex float *e, _Complex float *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_cpttrs_work$address() {
        return LAPACKE_cpttrs_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cpttrs_work(int matrix_layout, char uplo, int n, int nrhs, const float *d, const _Complex float *e, _Complex float *b, int ldb)
     * }
     */
    public static int LAPACKE_cpttrs_work(int matrix_layout, byte uplo, int n, int nrhs, MemorySegment d, MemorySegment e, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_cpttrs_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cpttrs_work", matrix_layout, uplo, n, nrhs, d, e, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, nrhs, d, e, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zpttrs_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zpttrs_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zpttrs_work(int matrix_layout, char uplo, int n, int nrhs, const double *d, const _Complex double *e, _Complex double *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_zpttrs_work$descriptor() {
        return LAPACKE_zpttrs_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zpttrs_work(int matrix_layout, char uplo, int n, int nrhs, const double *d, const _Complex double *e, _Complex double *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_zpttrs_work$handle() {
        return LAPACKE_zpttrs_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zpttrs_work(int matrix_layout, char uplo, int n, int nrhs, const double *d, const _Complex double *e, _Complex double *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_zpttrs_work$address() {
        return LAPACKE_zpttrs_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zpttrs_work(int matrix_layout, char uplo, int n, int nrhs, const double *d, const _Complex double *e, _Complex double *b, int ldb)
     * }
     */
    public static int LAPACKE_zpttrs_work(int matrix_layout, byte uplo, int n, int nrhs, MemorySegment d, MemorySegment e, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_zpttrs_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zpttrs_work", matrix_layout, uplo, n, nrhs, d, e, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, nrhs, d, e, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ssbev_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_ssbev_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ssbev_work(int matrix_layout, char jobz, char uplo, int n, int kd, float *ab, int ldab, float *w, float *z, int ldz, float *work)
     * }
     */
    public static FunctionDescriptor LAPACKE_ssbev_work$descriptor() {
        return LAPACKE_ssbev_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ssbev_work(int matrix_layout, char jobz, char uplo, int n, int kd, float *ab, int ldab, float *w, float *z, int ldz, float *work)
     * }
     */
    public static MethodHandle LAPACKE_ssbev_work$handle() {
        return LAPACKE_ssbev_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ssbev_work(int matrix_layout, char jobz, char uplo, int n, int kd, float *ab, int ldab, float *w, float *z, int ldz, float *work)
     * }
     */
    public static MemorySegment LAPACKE_ssbev_work$address() {
        return LAPACKE_ssbev_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ssbev_work(int matrix_layout, char jobz, char uplo, int n, int kd, float *ab, int ldab, float *w, float *z, int ldz, float *work)
     * }
     */
    public static int LAPACKE_ssbev_work(int matrix_layout, byte jobz, byte uplo, int n, int kd, MemorySegment ab, int ldab, MemorySegment w, MemorySegment z, int ldz, MemorySegment work) {
        var mh$ = LAPACKE_ssbev_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ssbev_work", matrix_layout, jobz, uplo, n, kd, ab, ldab, w, z, ldz, work);
            }
            return (int)mh$.invokeExact(matrix_layout, jobz, uplo, n, kd, ab, ldab, w, z, ldz, work);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dsbev_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dsbev_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dsbev_work(int matrix_layout, char jobz, char uplo, int n, int kd, double *ab, int ldab, double *w, double *z, int ldz, double *work)
     * }
     */
    public static FunctionDescriptor LAPACKE_dsbev_work$descriptor() {
        return LAPACKE_dsbev_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dsbev_work(int matrix_layout, char jobz, char uplo, int n, int kd, double *ab, int ldab, double *w, double *z, int ldz, double *work)
     * }
     */
    public static MethodHandle LAPACKE_dsbev_work$handle() {
        return LAPACKE_dsbev_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dsbev_work(int matrix_layout, char jobz, char uplo, int n, int kd, double *ab, int ldab, double *w, double *z, int ldz, double *work)
     * }
     */
    public static MemorySegment LAPACKE_dsbev_work$address() {
        return LAPACKE_dsbev_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dsbev_work(int matrix_layout, char jobz, char uplo, int n, int kd, double *ab, int ldab, double *w, double *z, int ldz, double *work)
     * }
     */
    public static int LAPACKE_dsbev_work(int matrix_layout, byte jobz, byte uplo, int n, int kd, MemorySegment ab, int ldab, MemorySegment w, MemorySegment z, int ldz, MemorySegment work) {
        var mh$ = LAPACKE_dsbev_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dsbev_work", matrix_layout, jobz, uplo, n, kd, ab, ldab, w, z, ldz, work);
            }
            return (int)mh$.invokeExact(matrix_layout, jobz, uplo, n, kd, ab, ldab, w, z, ldz, work);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ssbevd_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_ssbevd_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ssbevd_work(int matrix_layout, char jobz, char uplo, int n, int kd, float *ab, int ldab, float *w, float *z, int ldz, float *work, int lwork, int *iwork, int liwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_ssbevd_work$descriptor() {
        return LAPACKE_ssbevd_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ssbevd_work(int matrix_layout, char jobz, char uplo, int n, int kd, float *ab, int ldab, float *w, float *z, int ldz, float *work, int lwork, int *iwork, int liwork)
     * }
     */
    public static MethodHandle LAPACKE_ssbevd_work$handle() {
        return LAPACKE_ssbevd_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ssbevd_work(int matrix_layout, char jobz, char uplo, int n, int kd, float *ab, int ldab, float *w, float *z, int ldz, float *work, int lwork, int *iwork, int liwork)
     * }
     */
    public static MemorySegment LAPACKE_ssbevd_work$address() {
        return LAPACKE_ssbevd_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ssbevd_work(int matrix_layout, char jobz, char uplo, int n, int kd, float *ab, int ldab, float *w, float *z, int ldz, float *work, int lwork, int *iwork, int liwork)
     * }
     */
    public static int LAPACKE_ssbevd_work(int matrix_layout, byte jobz, byte uplo, int n, int kd, MemorySegment ab, int ldab, MemorySegment w, MemorySegment z, int ldz, MemorySegment work, int lwork, MemorySegment iwork, int liwork) {
        var mh$ = LAPACKE_ssbevd_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ssbevd_work", matrix_layout, jobz, uplo, n, kd, ab, ldab, w, z, ldz, work, lwork, iwork, liwork);
            }
            return (int)mh$.invokeExact(matrix_layout, jobz, uplo, n, kd, ab, ldab, w, z, ldz, work, lwork, iwork, liwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dsbevd_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dsbevd_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dsbevd_work(int matrix_layout, char jobz, char uplo, int n, int kd, double *ab, int ldab, double *w, double *z, int ldz, double *work, int lwork, int *iwork, int liwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_dsbevd_work$descriptor() {
        return LAPACKE_dsbevd_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dsbevd_work(int matrix_layout, char jobz, char uplo, int n, int kd, double *ab, int ldab, double *w, double *z, int ldz, double *work, int lwork, int *iwork, int liwork)
     * }
     */
    public static MethodHandle LAPACKE_dsbevd_work$handle() {
        return LAPACKE_dsbevd_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dsbevd_work(int matrix_layout, char jobz, char uplo, int n, int kd, double *ab, int ldab, double *w, double *z, int ldz, double *work, int lwork, int *iwork, int liwork)
     * }
     */
    public static MemorySegment LAPACKE_dsbevd_work$address() {
        return LAPACKE_dsbevd_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dsbevd_work(int matrix_layout, char jobz, char uplo, int n, int kd, double *ab, int ldab, double *w, double *z, int ldz, double *work, int lwork, int *iwork, int liwork)
     * }
     */
    public static int LAPACKE_dsbevd_work(int matrix_layout, byte jobz, byte uplo, int n, int kd, MemorySegment ab, int ldab, MemorySegment w, MemorySegment z, int ldz, MemorySegment work, int lwork, MemorySegment iwork, int liwork) {
        var mh$ = LAPACKE_dsbevd_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dsbevd_work", matrix_layout, jobz, uplo, n, kd, ab, ldab, w, z, ldz, work, lwork, iwork, liwork);
            }
            return (int)mh$.invokeExact(matrix_layout, jobz, uplo, n, kd, ab, ldab, w, z, ldz, work, lwork, iwork, liwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ssbevx_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_FLOAT,
            lapacke_h.C_FLOAT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_FLOAT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_ssbevx_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ssbevx_work(int matrix_layout, char jobz, char range, char uplo, int n, int kd, float *ab, int ldab, float *q, int ldq, float vl, float vu, int il, int iu, float abstol, int *m, float *w, float *z, int ldz, float *work, int *iwork, int *ifail)
     * }
     */
    public static FunctionDescriptor LAPACKE_ssbevx_work$descriptor() {
        return LAPACKE_ssbevx_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ssbevx_work(int matrix_layout, char jobz, char range, char uplo, int n, int kd, float *ab, int ldab, float *q, int ldq, float vl, float vu, int il, int iu, float abstol, int *m, float *w, float *z, int ldz, float *work, int *iwork, int *ifail)
     * }
     */
    public static MethodHandle LAPACKE_ssbevx_work$handle() {
        return LAPACKE_ssbevx_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ssbevx_work(int matrix_layout, char jobz, char range, char uplo, int n, int kd, float *ab, int ldab, float *q, int ldq, float vl, float vu, int il, int iu, float abstol, int *m, float *w, float *z, int ldz, float *work, int *iwork, int *ifail)
     * }
     */
    public static MemorySegment LAPACKE_ssbevx_work$address() {
        return LAPACKE_ssbevx_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ssbevx_work(int matrix_layout, char jobz, char range, char uplo, int n, int kd, float *ab, int ldab, float *q, int ldq, float vl, float vu, int il, int iu, float abstol, int *m, float *w, float *z, int ldz, float *work, int *iwork, int *ifail)
     * }
     */
    public static int LAPACKE_ssbevx_work(int matrix_layout, byte jobz, byte range, byte uplo, int n, int kd, MemorySegment ab, int ldab, MemorySegment q, int ldq, float vl, float vu, int il, int iu, float abstol, MemorySegment m, MemorySegment w, MemorySegment z, int ldz, MemorySegment work, MemorySegment iwork, MemorySegment ifail) {
        var mh$ = LAPACKE_ssbevx_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ssbevx_work", matrix_layout, jobz, range, uplo, n, kd, ab, ldab, q, ldq, vl, vu, il, iu, abstol, m, w, z, ldz, work, iwork, ifail);
            }
            return (int)mh$.invokeExact(matrix_layout, jobz, range, uplo, n, kd, ab, ldab, q, ldq, vl, vu, il, iu, abstol, m, w, z, ldz, work, iwork, ifail);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dsbevx_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_DOUBLE,
            lapacke_h.C_DOUBLE,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_DOUBLE,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dsbevx_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dsbevx_work(int matrix_layout, char jobz, char range, char uplo, int n, int kd, double *ab, int ldab, double *q, int ldq, double vl, double vu, int il, int iu, double abstol, int *m, double *w, double *z, int ldz, double *work, int *iwork, int *ifail)
     * }
     */
    public static FunctionDescriptor LAPACKE_dsbevx_work$descriptor() {
        return LAPACKE_dsbevx_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dsbevx_work(int matrix_layout, char jobz, char range, char uplo, int n, int kd, double *ab, int ldab, double *q, int ldq, double vl, double vu, int il, int iu, double abstol, int *m, double *w, double *z, int ldz, double *work, int *iwork, int *ifail)
     * }
     */
    public static MethodHandle LAPACKE_dsbevx_work$handle() {
        return LAPACKE_dsbevx_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dsbevx_work(int matrix_layout, char jobz, char range, char uplo, int n, int kd, double *ab, int ldab, double *q, int ldq, double vl, double vu, int il, int iu, double abstol, int *m, double *w, double *z, int ldz, double *work, int *iwork, int *ifail)
     * }
     */
    public static MemorySegment LAPACKE_dsbevx_work$address() {
        return LAPACKE_dsbevx_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dsbevx_work(int matrix_layout, char jobz, char range, char uplo, int n, int kd, double *ab, int ldab, double *q, int ldq, double vl, double vu, int il, int iu, double abstol, int *m, double *w, double *z, int ldz, double *work, int *iwork, int *ifail)
     * }
     */
    public static int LAPACKE_dsbevx_work(int matrix_layout, byte jobz, byte range, byte uplo, int n, int kd, MemorySegment ab, int ldab, MemorySegment q, int ldq, double vl, double vu, int il, int iu, double abstol, MemorySegment m, MemorySegment w, MemorySegment z, int ldz, MemorySegment work, MemorySegment iwork, MemorySegment ifail) {
        var mh$ = LAPACKE_dsbevx_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dsbevx_work", matrix_layout, jobz, range, uplo, n, kd, ab, ldab, q, ldq, vl, vu, il, iu, abstol, m, w, z, ldz, work, iwork, ifail);
            }
            return (int)mh$.invokeExact(matrix_layout, jobz, range, uplo, n, kd, ab, ldab, q, ldq, vl, vu, il, iu, abstol, m, w, z, ldz, work, iwork, ifail);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ssbgst_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_ssbgst_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ssbgst_work(int matrix_layout, char vect, char uplo, int n, int ka, int kb, float *ab, int ldab, const float *bb, int ldbb, float *x, int ldx, float *work)
     * }
     */
    public static FunctionDescriptor LAPACKE_ssbgst_work$descriptor() {
        return LAPACKE_ssbgst_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ssbgst_work(int matrix_layout, char vect, char uplo, int n, int ka, int kb, float *ab, int ldab, const float *bb, int ldbb, float *x, int ldx, float *work)
     * }
     */
    public static MethodHandle LAPACKE_ssbgst_work$handle() {
        return LAPACKE_ssbgst_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ssbgst_work(int matrix_layout, char vect, char uplo, int n, int ka, int kb, float *ab, int ldab, const float *bb, int ldbb, float *x, int ldx, float *work)
     * }
     */
    public static MemorySegment LAPACKE_ssbgst_work$address() {
        return LAPACKE_ssbgst_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ssbgst_work(int matrix_layout, char vect, char uplo, int n, int ka, int kb, float *ab, int ldab, const float *bb, int ldbb, float *x, int ldx, float *work)
     * }
     */
    public static int LAPACKE_ssbgst_work(int matrix_layout, byte vect, byte uplo, int n, int ka, int kb, MemorySegment ab, int ldab, MemorySegment bb, int ldbb, MemorySegment x, int ldx, MemorySegment work) {
        var mh$ = LAPACKE_ssbgst_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ssbgst_work", matrix_layout, vect, uplo, n, ka, kb, ab, ldab, bb, ldbb, x, ldx, work);
            }
            return (int)mh$.invokeExact(matrix_layout, vect, uplo, n, ka, kb, ab, ldab, bb, ldbb, x, ldx, work);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dsbgst_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dsbgst_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dsbgst_work(int matrix_layout, char vect, char uplo, int n, int ka, int kb, double *ab, int ldab, const double *bb, int ldbb, double *x, int ldx, double *work)
     * }
     */
    public static FunctionDescriptor LAPACKE_dsbgst_work$descriptor() {
        return LAPACKE_dsbgst_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dsbgst_work(int matrix_layout, char vect, char uplo, int n, int ka, int kb, double *ab, int ldab, const double *bb, int ldbb, double *x, int ldx, double *work)
     * }
     */
    public static MethodHandle LAPACKE_dsbgst_work$handle() {
        return LAPACKE_dsbgst_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dsbgst_work(int matrix_layout, char vect, char uplo, int n, int ka, int kb, double *ab, int ldab, const double *bb, int ldbb, double *x, int ldx, double *work)
     * }
     */
    public static MemorySegment LAPACKE_dsbgst_work$address() {
        return LAPACKE_dsbgst_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dsbgst_work(int matrix_layout, char vect, char uplo, int n, int ka, int kb, double *ab, int ldab, const double *bb, int ldbb, double *x, int ldx, double *work)
     * }
     */
    public static int LAPACKE_dsbgst_work(int matrix_layout, byte vect, byte uplo, int n, int ka, int kb, MemorySegment ab, int ldab, MemorySegment bb, int ldbb, MemorySegment x, int ldx, MemorySegment work) {
        var mh$ = LAPACKE_dsbgst_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dsbgst_work", matrix_layout, vect, uplo, n, ka, kb, ab, ldab, bb, ldbb, x, ldx, work);
            }
            return (int)mh$.invokeExact(matrix_layout, vect, uplo, n, ka, kb, ab, ldab, bb, ldbb, x, ldx, work);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ssbgv_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_ssbgv_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ssbgv_work(int matrix_layout, char jobz, char uplo, int n, int ka, int kb, float *ab, int ldab, float *bb, int ldbb, float *w, float *z, int ldz, float *work)
     * }
     */
    public static FunctionDescriptor LAPACKE_ssbgv_work$descriptor() {
        return LAPACKE_ssbgv_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ssbgv_work(int matrix_layout, char jobz, char uplo, int n, int ka, int kb, float *ab, int ldab, float *bb, int ldbb, float *w, float *z, int ldz, float *work)
     * }
     */
    public static MethodHandle LAPACKE_ssbgv_work$handle() {
        return LAPACKE_ssbgv_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ssbgv_work(int matrix_layout, char jobz, char uplo, int n, int ka, int kb, float *ab, int ldab, float *bb, int ldbb, float *w, float *z, int ldz, float *work)
     * }
     */
    public static MemorySegment LAPACKE_ssbgv_work$address() {
        return LAPACKE_ssbgv_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ssbgv_work(int matrix_layout, char jobz, char uplo, int n, int ka, int kb, float *ab, int ldab, float *bb, int ldbb, float *w, float *z, int ldz, float *work)
     * }
     */
    public static int LAPACKE_ssbgv_work(int matrix_layout, byte jobz, byte uplo, int n, int ka, int kb, MemorySegment ab, int ldab, MemorySegment bb, int ldbb, MemorySegment w, MemorySegment z, int ldz, MemorySegment work) {
        var mh$ = LAPACKE_ssbgv_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ssbgv_work", matrix_layout, jobz, uplo, n, ka, kb, ab, ldab, bb, ldbb, w, z, ldz, work);
            }
            return (int)mh$.invokeExact(matrix_layout, jobz, uplo, n, ka, kb, ab, ldab, bb, ldbb, w, z, ldz, work);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dsbgv_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dsbgv_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dsbgv_work(int matrix_layout, char jobz, char uplo, int n, int ka, int kb, double *ab, int ldab, double *bb, int ldbb, double *w, double *z, int ldz, double *work)
     * }
     */
    public static FunctionDescriptor LAPACKE_dsbgv_work$descriptor() {
        return LAPACKE_dsbgv_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dsbgv_work(int matrix_layout, char jobz, char uplo, int n, int ka, int kb, double *ab, int ldab, double *bb, int ldbb, double *w, double *z, int ldz, double *work)
     * }
     */
    public static MethodHandle LAPACKE_dsbgv_work$handle() {
        return LAPACKE_dsbgv_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dsbgv_work(int matrix_layout, char jobz, char uplo, int n, int ka, int kb, double *ab, int ldab, double *bb, int ldbb, double *w, double *z, int ldz, double *work)
     * }
     */
    public static MemorySegment LAPACKE_dsbgv_work$address() {
        return LAPACKE_dsbgv_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dsbgv_work(int matrix_layout, char jobz, char uplo, int n, int ka, int kb, double *ab, int ldab, double *bb, int ldbb, double *w, double *z, int ldz, double *work)
     * }
     */
    public static int LAPACKE_dsbgv_work(int matrix_layout, byte jobz, byte uplo, int n, int ka, int kb, MemorySegment ab, int ldab, MemorySegment bb, int ldbb, MemorySegment w, MemorySegment z, int ldz, MemorySegment work) {
        var mh$ = LAPACKE_dsbgv_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dsbgv_work", matrix_layout, jobz, uplo, n, ka, kb, ab, ldab, bb, ldbb, w, z, ldz, work);
            }
            return (int)mh$.invokeExact(matrix_layout, jobz, uplo, n, ka, kb, ab, ldab, bb, ldbb, w, z, ldz, work);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ssbgvd_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_ssbgvd_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ssbgvd_work(int matrix_layout, char jobz, char uplo, int n, int ka, int kb, float *ab, int ldab, float *bb, int ldbb, float *w, float *z, int ldz, float *work, int lwork, int *iwork, int liwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_ssbgvd_work$descriptor() {
        return LAPACKE_ssbgvd_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ssbgvd_work(int matrix_layout, char jobz, char uplo, int n, int ka, int kb, float *ab, int ldab, float *bb, int ldbb, float *w, float *z, int ldz, float *work, int lwork, int *iwork, int liwork)
     * }
     */
    public static MethodHandle LAPACKE_ssbgvd_work$handle() {
        return LAPACKE_ssbgvd_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ssbgvd_work(int matrix_layout, char jobz, char uplo, int n, int ka, int kb, float *ab, int ldab, float *bb, int ldbb, float *w, float *z, int ldz, float *work, int lwork, int *iwork, int liwork)
     * }
     */
    public static MemorySegment LAPACKE_ssbgvd_work$address() {
        return LAPACKE_ssbgvd_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ssbgvd_work(int matrix_layout, char jobz, char uplo, int n, int ka, int kb, float *ab, int ldab, float *bb, int ldbb, float *w, float *z, int ldz, float *work, int lwork, int *iwork, int liwork)
     * }
     */
    public static int LAPACKE_ssbgvd_work(int matrix_layout, byte jobz, byte uplo, int n, int ka, int kb, MemorySegment ab, int ldab, MemorySegment bb, int ldbb, MemorySegment w, MemorySegment z, int ldz, MemorySegment work, int lwork, MemorySegment iwork, int liwork) {
        var mh$ = LAPACKE_ssbgvd_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ssbgvd_work", matrix_layout, jobz, uplo, n, ka, kb, ab, ldab, bb, ldbb, w, z, ldz, work, lwork, iwork, liwork);
            }
            return (int)mh$.invokeExact(matrix_layout, jobz, uplo, n, ka, kb, ab, ldab, bb, ldbb, w, z, ldz, work, lwork, iwork, liwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dsbgvd_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dsbgvd_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dsbgvd_work(int matrix_layout, char jobz, char uplo, int n, int ka, int kb, double *ab, int ldab, double *bb, int ldbb, double *w, double *z, int ldz, double *work, int lwork, int *iwork, int liwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_dsbgvd_work$descriptor() {
        return LAPACKE_dsbgvd_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dsbgvd_work(int matrix_layout, char jobz, char uplo, int n, int ka, int kb, double *ab, int ldab, double *bb, int ldbb, double *w, double *z, int ldz, double *work, int lwork, int *iwork, int liwork)
     * }
     */
    public static MethodHandle LAPACKE_dsbgvd_work$handle() {
        return LAPACKE_dsbgvd_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dsbgvd_work(int matrix_layout, char jobz, char uplo, int n, int ka, int kb, double *ab, int ldab, double *bb, int ldbb, double *w, double *z, int ldz, double *work, int lwork, int *iwork, int liwork)
     * }
     */
    public static MemorySegment LAPACKE_dsbgvd_work$address() {
        return LAPACKE_dsbgvd_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dsbgvd_work(int matrix_layout, char jobz, char uplo, int n, int ka, int kb, double *ab, int ldab, double *bb, int ldbb, double *w, double *z, int ldz, double *work, int lwork, int *iwork, int liwork)
     * }
     */
    public static int LAPACKE_dsbgvd_work(int matrix_layout, byte jobz, byte uplo, int n, int ka, int kb, MemorySegment ab, int ldab, MemorySegment bb, int ldbb, MemorySegment w, MemorySegment z, int ldz, MemorySegment work, int lwork, MemorySegment iwork, int liwork) {
        var mh$ = LAPACKE_dsbgvd_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dsbgvd_work", matrix_layout, jobz, uplo, n, ka, kb, ab, ldab, bb, ldbb, w, z, ldz, work, lwork, iwork, liwork);
            }
            return (int)mh$.invokeExact(matrix_layout, jobz, uplo, n, ka, kb, ab, ldab, bb, ldbb, w, z, ldz, work, lwork, iwork, liwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ssbgvx_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_FLOAT,
            lapacke_h.C_FLOAT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_FLOAT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_ssbgvx_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ssbgvx_work(int matrix_layout, char jobz, char range, char uplo, int n, int ka, int kb, float *ab, int ldab, float *bb, int ldbb, float *q, int ldq, float vl, float vu, int il, int iu, float abstol, int *m, float *w, float *z, int ldz, float *work, int *iwork, int *ifail)
     * }
     */
    public static FunctionDescriptor LAPACKE_ssbgvx_work$descriptor() {
        return LAPACKE_ssbgvx_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ssbgvx_work(int matrix_layout, char jobz, char range, char uplo, int n, int ka, int kb, float *ab, int ldab, float *bb, int ldbb, float *q, int ldq, float vl, float vu, int il, int iu, float abstol, int *m, float *w, float *z, int ldz, float *work, int *iwork, int *ifail)
     * }
     */
    public static MethodHandle LAPACKE_ssbgvx_work$handle() {
        return LAPACKE_ssbgvx_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ssbgvx_work(int matrix_layout, char jobz, char range, char uplo, int n, int ka, int kb, float *ab, int ldab, float *bb, int ldbb, float *q, int ldq, float vl, float vu, int il, int iu, float abstol, int *m, float *w, float *z, int ldz, float *work, int *iwork, int *ifail)
     * }
     */
    public static MemorySegment LAPACKE_ssbgvx_work$address() {
        return LAPACKE_ssbgvx_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ssbgvx_work(int matrix_layout, char jobz, char range, char uplo, int n, int ka, int kb, float *ab, int ldab, float *bb, int ldbb, float *q, int ldq, float vl, float vu, int il, int iu, float abstol, int *m, float *w, float *z, int ldz, float *work, int *iwork, int *ifail)
     * }
     */
    public static int LAPACKE_ssbgvx_work(int matrix_layout, byte jobz, byte range, byte uplo, int n, int ka, int kb, MemorySegment ab, int ldab, MemorySegment bb, int ldbb, MemorySegment q, int ldq, float vl, float vu, int il, int iu, float abstol, MemorySegment m, MemorySegment w, MemorySegment z, int ldz, MemorySegment work, MemorySegment iwork, MemorySegment ifail) {
        var mh$ = LAPACKE_ssbgvx_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ssbgvx_work", matrix_layout, jobz, range, uplo, n, ka, kb, ab, ldab, bb, ldbb, q, ldq, vl, vu, il, iu, abstol, m, w, z, ldz, work, iwork, ifail);
            }
            return (int)mh$.invokeExact(matrix_layout, jobz, range, uplo, n, ka, kb, ab, ldab, bb, ldbb, q, ldq, vl, vu, il, iu, abstol, m, w, z, ldz, work, iwork, ifail);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dsbgvx_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_DOUBLE,
            lapacke_h.C_DOUBLE,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_DOUBLE,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dsbgvx_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dsbgvx_work(int matrix_layout, char jobz, char range, char uplo, int n, int ka, int kb, double *ab, int ldab, double *bb, int ldbb, double *q, int ldq, double vl, double vu, int il, int iu, double abstol, int *m, double *w, double *z, int ldz, double *work, int *iwork, int *ifail)
     * }
     */
    public static FunctionDescriptor LAPACKE_dsbgvx_work$descriptor() {
        return LAPACKE_dsbgvx_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dsbgvx_work(int matrix_layout, char jobz, char range, char uplo, int n, int ka, int kb, double *ab, int ldab, double *bb, int ldbb, double *q, int ldq, double vl, double vu, int il, int iu, double abstol, int *m, double *w, double *z, int ldz, double *work, int *iwork, int *ifail)
     * }
     */
    public static MethodHandle LAPACKE_dsbgvx_work$handle() {
        return LAPACKE_dsbgvx_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dsbgvx_work(int matrix_layout, char jobz, char range, char uplo, int n, int ka, int kb, double *ab, int ldab, double *bb, int ldbb, double *q, int ldq, double vl, double vu, int il, int iu, double abstol, int *m, double *w, double *z, int ldz, double *work, int *iwork, int *ifail)
     * }
     */
    public static MemorySegment LAPACKE_dsbgvx_work$address() {
        return LAPACKE_dsbgvx_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dsbgvx_work(int matrix_layout, char jobz, char range, char uplo, int n, int ka, int kb, double *ab, int ldab, double *bb, int ldbb, double *q, int ldq, double vl, double vu, int il, int iu, double abstol, int *m, double *w, double *z, int ldz, double *work, int *iwork, int *ifail)
     * }
     */
    public static int LAPACKE_dsbgvx_work(int matrix_layout, byte jobz, byte range, byte uplo, int n, int ka, int kb, MemorySegment ab, int ldab, MemorySegment bb, int ldbb, MemorySegment q, int ldq, double vl, double vu, int il, int iu, double abstol, MemorySegment m, MemorySegment w, MemorySegment z, int ldz, MemorySegment work, MemorySegment iwork, MemorySegment ifail) {
        var mh$ = LAPACKE_dsbgvx_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dsbgvx_work", matrix_layout, jobz, range, uplo, n, ka, kb, ab, ldab, bb, ldbb, q, ldq, vl, vu, il, iu, abstol, m, w, z, ldz, work, iwork, ifail);
            }
            return (int)mh$.invokeExact(matrix_layout, jobz, range, uplo, n, ka, kb, ab, ldab, bb, ldbb, q, ldq, vl, vu, il, iu, abstol, m, w, z, ldz, work, iwork, ifail);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ssbtrd_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_ssbtrd_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ssbtrd_work(int matrix_layout, char vect, char uplo, int n, int kd, float *ab, int ldab, float *d, float *e, float *q, int ldq, float *work)
     * }
     */
    public static FunctionDescriptor LAPACKE_ssbtrd_work$descriptor() {
        return LAPACKE_ssbtrd_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ssbtrd_work(int matrix_layout, char vect, char uplo, int n, int kd, float *ab, int ldab, float *d, float *e, float *q, int ldq, float *work)
     * }
     */
    public static MethodHandle LAPACKE_ssbtrd_work$handle() {
        return LAPACKE_ssbtrd_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ssbtrd_work(int matrix_layout, char vect, char uplo, int n, int kd, float *ab, int ldab, float *d, float *e, float *q, int ldq, float *work)
     * }
     */
    public static MemorySegment LAPACKE_ssbtrd_work$address() {
        return LAPACKE_ssbtrd_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ssbtrd_work(int matrix_layout, char vect, char uplo, int n, int kd, float *ab, int ldab, float *d, float *e, float *q, int ldq, float *work)
     * }
     */
    public static int LAPACKE_ssbtrd_work(int matrix_layout, byte vect, byte uplo, int n, int kd, MemorySegment ab, int ldab, MemorySegment d, MemorySegment e, MemorySegment q, int ldq, MemorySegment work) {
        var mh$ = LAPACKE_ssbtrd_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ssbtrd_work", matrix_layout, vect, uplo, n, kd, ab, ldab, d, e, q, ldq, work);
            }
            return (int)mh$.invokeExact(matrix_layout, vect, uplo, n, kd, ab, ldab, d, e, q, ldq, work);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dsbtrd_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dsbtrd_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dsbtrd_work(int matrix_layout, char vect, char uplo, int n, int kd, double *ab, int ldab, double *d, double *e, double *q, int ldq, double *work)
     * }
     */
    public static FunctionDescriptor LAPACKE_dsbtrd_work$descriptor() {
        return LAPACKE_dsbtrd_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dsbtrd_work(int matrix_layout, char vect, char uplo, int n, int kd, double *ab, int ldab, double *d, double *e, double *q, int ldq, double *work)
     * }
     */
    public static MethodHandle LAPACKE_dsbtrd_work$handle() {
        return LAPACKE_dsbtrd_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dsbtrd_work(int matrix_layout, char vect, char uplo, int n, int kd, double *ab, int ldab, double *d, double *e, double *q, int ldq, double *work)
     * }
     */
    public static MemorySegment LAPACKE_dsbtrd_work$address() {
        return LAPACKE_dsbtrd_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dsbtrd_work(int matrix_layout, char vect, char uplo, int n, int kd, double *ab, int ldab, double *d, double *e, double *q, int ldq, double *work)
     * }
     */
    public static int LAPACKE_dsbtrd_work(int matrix_layout, byte vect, byte uplo, int n, int kd, MemorySegment ab, int ldab, MemorySegment d, MemorySegment e, MemorySegment q, int ldq, MemorySegment work) {
        var mh$ = LAPACKE_dsbtrd_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dsbtrd_work", matrix_layout, vect, uplo, n, kd, ab, ldab, d, e, q, ldq, work);
            }
            return (int)mh$.invokeExact(matrix_layout, vect, uplo, n, kd, ab, ldab, d, e, q, ldq, work);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ssfrk_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_FLOAT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_FLOAT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_ssfrk_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ssfrk_work(int matrix_layout, char transr, char uplo, char trans, int n, int k, float alpha, const float *a, int lda, float beta, float *c)
     * }
     */
    public static FunctionDescriptor LAPACKE_ssfrk_work$descriptor() {
        return LAPACKE_ssfrk_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ssfrk_work(int matrix_layout, char transr, char uplo, char trans, int n, int k, float alpha, const float *a, int lda, float beta, float *c)
     * }
     */
    public static MethodHandle LAPACKE_ssfrk_work$handle() {
        return LAPACKE_ssfrk_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ssfrk_work(int matrix_layout, char transr, char uplo, char trans, int n, int k, float alpha, const float *a, int lda, float beta, float *c)
     * }
     */
    public static MemorySegment LAPACKE_ssfrk_work$address() {
        return LAPACKE_ssfrk_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ssfrk_work(int matrix_layout, char transr, char uplo, char trans, int n, int k, float alpha, const float *a, int lda, float beta, float *c)
     * }
     */
    public static int LAPACKE_ssfrk_work(int matrix_layout, byte transr, byte uplo, byte trans, int n, int k, float alpha, MemorySegment a, int lda, float beta, MemorySegment c) {
        var mh$ = LAPACKE_ssfrk_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ssfrk_work", matrix_layout, transr, uplo, trans, n, k, alpha, a, lda, beta, c);
            }
            return (int)mh$.invokeExact(matrix_layout, transr, uplo, trans, n, k, alpha, a, lda, beta, c);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dsfrk_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_DOUBLE,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_DOUBLE,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dsfrk_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dsfrk_work(int matrix_layout, char transr, char uplo, char trans, int n, int k, double alpha, const double *a, int lda, double beta, double *c)
     * }
     */
    public static FunctionDescriptor LAPACKE_dsfrk_work$descriptor() {
        return LAPACKE_dsfrk_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dsfrk_work(int matrix_layout, char transr, char uplo, char trans, int n, int k, double alpha, const double *a, int lda, double beta, double *c)
     * }
     */
    public static MethodHandle LAPACKE_dsfrk_work$handle() {
        return LAPACKE_dsfrk_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dsfrk_work(int matrix_layout, char transr, char uplo, char trans, int n, int k, double alpha, const double *a, int lda, double beta, double *c)
     * }
     */
    public static MemorySegment LAPACKE_dsfrk_work$address() {
        return LAPACKE_dsfrk_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dsfrk_work(int matrix_layout, char transr, char uplo, char trans, int n, int k, double alpha, const double *a, int lda, double beta, double *c)
     * }
     */
    public static int LAPACKE_dsfrk_work(int matrix_layout, byte transr, byte uplo, byte trans, int n, int k, double alpha, MemorySegment a, int lda, double beta, MemorySegment c) {
        var mh$ = LAPACKE_dsfrk_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dsfrk_work", matrix_layout, transr, uplo, trans, n, k, alpha, a, lda, beta, c);
            }
            return (int)mh$.invokeExact(matrix_layout, transr, uplo, trans, n, k, alpha, a, lda, beta, c);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sspcon_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_FLOAT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_sspcon_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sspcon_work(int matrix_layout, char uplo, int n, const float *ap, const int *ipiv, float anorm, float *rcond, float *work, int *iwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_sspcon_work$descriptor() {
        return LAPACKE_sspcon_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sspcon_work(int matrix_layout, char uplo, int n, const float *ap, const int *ipiv, float anorm, float *rcond, float *work, int *iwork)
     * }
     */
    public static MethodHandle LAPACKE_sspcon_work$handle() {
        return LAPACKE_sspcon_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sspcon_work(int matrix_layout, char uplo, int n, const float *ap, const int *ipiv, float anorm, float *rcond, float *work, int *iwork)
     * }
     */
    public static MemorySegment LAPACKE_sspcon_work$address() {
        return LAPACKE_sspcon_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sspcon_work(int matrix_layout, char uplo, int n, const float *ap, const int *ipiv, float anorm, float *rcond, float *work, int *iwork)
     * }
     */
    public static int LAPACKE_sspcon_work(int matrix_layout, byte uplo, int n, MemorySegment ap, MemorySegment ipiv, float anorm, MemorySegment rcond, MemorySegment work, MemorySegment iwork) {
        var mh$ = LAPACKE_sspcon_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sspcon_work", matrix_layout, uplo, n, ap, ipiv, anorm, rcond, work, iwork);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, ap, ipiv, anorm, rcond, work, iwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dspcon_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_DOUBLE,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dspcon_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dspcon_work(int matrix_layout, char uplo, int n, const double *ap, const int *ipiv, double anorm, double *rcond, double *work, int *iwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_dspcon_work$descriptor() {
        return LAPACKE_dspcon_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dspcon_work(int matrix_layout, char uplo, int n, const double *ap, const int *ipiv, double anorm, double *rcond, double *work, int *iwork)
     * }
     */
    public static MethodHandle LAPACKE_dspcon_work$handle() {
        return LAPACKE_dspcon_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dspcon_work(int matrix_layout, char uplo, int n, const double *ap, const int *ipiv, double anorm, double *rcond, double *work, int *iwork)
     * }
     */
    public static MemorySegment LAPACKE_dspcon_work$address() {
        return LAPACKE_dspcon_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dspcon_work(int matrix_layout, char uplo, int n, const double *ap, const int *ipiv, double anorm, double *rcond, double *work, int *iwork)
     * }
     */
    public static int LAPACKE_dspcon_work(int matrix_layout, byte uplo, int n, MemorySegment ap, MemorySegment ipiv, double anorm, MemorySegment rcond, MemorySegment work, MemorySegment iwork) {
        var mh$ = LAPACKE_dspcon_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dspcon_work", matrix_layout, uplo, n, ap, ipiv, anorm, rcond, work, iwork);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, ap, ipiv, anorm, rcond, work, iwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cspcon_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_FLOAT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_cspcon_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cspcon_work(int matrix_layout, char uplo, int n, const _Complex float *ap, const int *ipiv, float anorm, float *rcond, _Complex float *work)
     * }
     */
    public static FunctionDescriptor LAPACKE_cspcon_work$descriptor() {
        return LAPACKE_cspcon_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cspcon_work(int matrix_layout, char uplo, int n, const _Complex float *ap, const int *ipiv, float anorm, float *rcond, _Complex float *work)
     * }
     */
    public static MethodHandle LAPACKE_cspcon_work$handle() {
        return LAPACKE_cspcon_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cspcon_work(int matrix_layout, char uplo, int n, const _Complex float *ap, const int *ipiv, float anorm, float *rcond, _Complex float *work)
     * }
     */
    public static MemorySegment LAPACKE_cspcon_work$address() {
        return LAPACKE_cspcon_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cspcon_work(int matrix_layout, char uplo, int n, const _Complex float *ap, const int *ipiv, float anorm, float *rcond, _Complex float *work)
     * }
     */
    public static int LAPACKE_cspcon_work(int matrix_layout, byte uplo, int n, MemorySegment ap, MemorySegment ipiv, float anorm, MemorySegment rcond, MemorySegment work) {
        var mh$ = LAPACKE_cspcon_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cspcon_work", matrix_layout, uplo, n, ap, ipiv, anorm, rcond, work);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, ap, ipiv, anorm, rcond, work);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zspcon_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_DOUBLE,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zspcon_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zspcon_work(int matrix_layout, char uplo, int n, const _Complex double *ap, const int *ipiv, double anorm, double *rcond, _Complex double *work)
     * }
     */
    public static FunctionDescriptor LAPACKE_zspcon_work$descriptor() {
        return LAPACKE_zspcon_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zspcon_work(int matrix_layout, char uplo, int n, const _Complex double *ap, const int *ipiv, double anorm, double *rcond, _Complex double *work)
     * }
     */
    public static MethodHandle LAPACKE_zspcon_work$handle() {
        return LAPACKE_zspcon_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zspcon_work(int matrix_layout, char uplo, int n, const _Complex double *ap, const int *ipiv, double anorm, double *rcond, _Complex double *work)
     * }
     */
    public static MemorySegment LAPACKE_zspcon_work$address() {
        return LAPACKE_zspcon_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zspcon_work(int matrix_layout, char uplo, int n, const _Complex double *ap, const int *ipiv, double anorm, double *rcond, _Complex double *work)
     * }
     */
    public static int LAPACKE_zspcon_work(int matrix_layout, byte uplo, int n, MemorySegment ap, MemorySegment ipiv, double anorm, MemorySegment rcond, MemorySegment work) {
        var mh$ = LAPACKE_zspcon_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zspcon_work", matrix_layout, uplo, n, ap, ipiv, anorm, rcond, work);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, ap, ipiv, anorm, rcond, work);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sspev_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_sspev_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sspev_work(int matrix_layout, char jobz, char uplo, int n, float *ap, float *w, float *z, int ldz, float *work)
     * }
     */
    public static FunctionDescriptor LAPACKE_sspev_work$descriptor() {
        return LAPACKE_sspev_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sspev_work(int matrix_layout, char jobz, char uplo, int n, float *ap, float *w, float *z, int ldz, float *work)
     * }
     */
    public static MethodHandle LAPACKE_sspev_work$handle() {
        return LAPACKE_sspev_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sspev_work(int matrix_layout, char jobz, char uplo, int n, float *ap, float *w, float *z, int ldz, float *work)
     * }
     */
    public static MemorySegment LAPACKE_sspev_work$address() {
        return LAPACKE_sspev_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sspev_work(int matrix_layout, char jobz, char uplo, int n, float *ap, float *w, float *z, int ldz, float *work)
     * }
     */
    public static int LAPACKE_sspev_work(int matrix_layout, byte jobz, byte uplo, int n, MemorySegment ap, MemorySegment w, MemorySegment z, int ldz, MemorySegment work) {
        var mh$ = LAPACKE_sspev_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sspev_work", matrix_layout, jobz, uplo, n, ap, w, z, ldz, work);
            }
            return (int)mh$.invokeExact(matrix_layout, jobz, uplo, n, ap, w, z, ldz, work);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dspev_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dspev_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dspev_work(int matrix_layout, char jobz, char uplo, int n, double *ap, double *w, double *z, int ldz, double *work)
     * }
     */
    public static FunctionDescriptor LAPACKE_dspev_work$descriptor() {
        return LAPACKE_dspev_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dspev_work(int matrix_layout, char jobz, char uplo, int n, double *ap, double *w, double *z, int ldz, double *work)
     * }
     */
    public static MethodHandle LAPACKE_dspev_work$handle() {
        return LAPACKE_dspev_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dspev_work(int matrix_layout, char jobz, char uplo, int n, double *ap, double *w, double *z, int ldz, double *work)
     * }
     */
    public static MemorySegment LAPACKE_dspev_work$address() {
        return LAPACKE_dspev_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dspev_work(int matrix_layout, char jobz, char uplo, int n, double *ap, double *w, double *z, int ldz, double *work)
     * }
     */
    public static int LAPACKE_dspev_work(int matrix_layout, byte jobz, byte uplo, int n, MemorySegment ap, MemorySegment w, MemorySegment z, int ldz, MemorySegment work) {
        var mh$ = LAPACKE_dspev_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dspev_work", matrix_layout, jobz, uplo, n, ap, w, z, ldz, work);
            }
            return (int)mh$.invokeExact(matrix_layout, jobz, uplo, n, ap, w, z, ldz, work);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sspevd_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_sspevd_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sspevd_work(int matrix_layout, char jobz, char uplo, int n, float *ap, float *w, float *z, int ldz, float *work, int lwork, int *iwork, int liwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_sspevd_work$descriptor() {
        return LAPACKE_sspevd_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sspevd_work(int matrix_layout, char jobz, char uplo, int n, float *ap, float *w, float *z, int ldz, float *work, int lwork, int *iwork, int liwork)
     * }
     */
    public static MethodHandle LAPACKE_sspevd_work$handle() {
        return LAPACKE_sspevd_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sspevd_work(int matrix_layout, char jobz, char uplo, int n, float *ap, float *w, float *z, int ldz, float *work, int lwork, int *iwork, int liwork)
     * }
     */
    public static MemorySegment LAPACKE_sspevd_work$address() {
        return LAPACKE_sspevd_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sspevd_work(int matrix_layout, char jobz, char uplo, int n, float *ap, float *w, float *z, int ldz, float *work, int lwork, int *iwork, int liwork)
     * }
     */
    public static int LAPACKE_sspevd_work(int matrix_layout, byte jobz, byte uplo, int n, MemorySegment ap, MemorySegment w, MemorySegment z, int ldz, MemorySegment work, int lwork, MemorySegment iwork, int liwork) {
        var mh$ = LAPACKE_sspevd_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sspevd_work", matrix_layout, jobz, uplo, n, ap, w, z, ldz, work, lwork, iwork, liwork);
            }
            return (int)mh$.invokeExact(matrix_layout, jobz, uplo, n, ap, w, z, ldz, work, lwork, iwork, liwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dspevd_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dspevd_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dspevd_work(int matrix_layout, char jobz, char uplo, int n, double *ap, double *w, double *z, int ldz, double *work, int lwork, int *iwork, int liwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_dspevd_work$descriptor() {
        return LAPACKE_dspevd_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dspevd_work(int matrix_layout, char jobz, char uplo, int n, double *ap, double *w, double *z, int ldz, double *work, int lwork, int *iwork, int liwork)
     * }
     */
    public static MethodHandle LAPACKE_dspevd_work$handle() {
        return LAPACKE_dspevd_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dspevd_work(int matrix_layout, char jobz, char uplo, int n, double *ap, double *w, double *z, int ldz, double *work, int lwork, int *iwork, int liwork)
     * }
     */
    public static MemorySegment LAPACKE_dspevd_work$address() {
        return LAPACKE_dspevd_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dspevd_work(int matrix_layout, char jobz, char uplo, int n, double *ap, double *w, double *z, int ldz, double *work, int lwork, int *iwork, int liwork)
     * }
     */
    public static int LAPACKE_dspevd_work(int matrix_layout, byte jobz, byte uplo, int n, MemorySegment ap, MemorySegment w, MemorySegment z, int ldz, MemorySegment work, int lwork, MemorySegment iwork, int liwork) {
        var mh$ = LAPACKE_dspevd_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dspevd_work", matrix_layout, jobz, uplo, n, ap, w, z, ldz, work, lwork, iwork, liwork);
            }
            return (int)mh$.invokeExact(matrix_layout, jobz, uplo, n, ap, w, z, ldz, work, lwork, iwork, liwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sspevx_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_FLOAT,
            lapacke_h.C_FLOAT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_FLOAT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_sspevx_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sspevx_work(int matrix_layout, char jobz, char range, char uplo, int n, float *ap, float vl, float vu, int il, int iu, float abstol, int *m, float *w, float *z, int ldz, float *work, int *iwork, int *ifail)
     * }
     */
    public static FunctionDescriptor LAPACKE_sspevx_work$descriptor() {
        return LAPACKE_sspevx_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sspevx_work(int matrix_layout, char jobz, char range, char uplo, int n, float *ap, float vl, float vu, int il, int iu, float abstol, int *m, float *w, float *z, int ldz, float *work, int *iwork, int *ifail)
     * }
     */
    public static MethodHandle LAPACKE_sspevx_work$handle() {
        return LAPACKE_sspevx_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sspevx_work(int matrix_layout, char jobz, char range, char uplo, int n, float *ap, float vl, float vu, int il, int iu, float abstol, int *m, float *w, float *z, int ldz, float *work, int *iwork, int *ifail)
     * }
     */
    public static MemorySegment LAPACKE_sspevx_work$address() {
        return LAPACKE_sspevx_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sspevx_work(int matrix_layout, char jobz, char range, char uplo, int n, float *ap, float vl, float vu, int il, int iu, float abstol, int *m, float *w, float *z, int ldz, float *work, int *iwork, int *ifail)
     * }
     */
    public static int LAPACKE_sspevx_work(int matrix_layout, byte jobz, byte range, byte uplo, int n, MemorySegment ap, float vl, float vu, int il, int iu, float abstol, MemorySegment m, MemorySegment w, MemorySegment z, int ldz, MemorySegment work, MemorySegment iwork, MemorySegment ifail) {
        var mh$ = LAPACKE_sspevx_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sspevx_work", matrix_layout, jobz, range, uplo, n, ap, vl, vu, il, iu, abstol, m, w, z, ldz, work, iwork, ifail);
            }
            return (int)mh$.invokeExact(matrix_layout, jobz, range, uplo, n, ap, vl, vu, il, iu, abstol, m, w, z, ldz, work, iwork, ifail);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dspevx_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_DOUBLE,
            lapacke_h.C_DOUBLE,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_DOUBLE,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dspevx_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dspevx_work(int matrix_layout, char jobz, char range, char uplo, int n, double *ap, double vl, double vu, int il, int iu, double abstol, int *m, double *w, double *z, int ldz, double *work, int *iwork, int *ifail)
     * }
     */
    public static FunctionDescriptor LAPACKE_dspevx_work$descriptor() {
        return LAPACKE_dspevx_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dspevx_work(int matrix_layout, char jobz, char range, char uplo, int n, double *ap, double vl, double vu, int il, int iu, double abstol, int *m, double *w, double *z, int ldz, double *work, int *iwork, int *ifail)
     * }
     */
    public static MethodHandle LAPACKE_dspevx_work$handle() {
        return LAPACKE_dspevx_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dspevx_work(int matrix_layout, char jobz, char range, char uplo, int n, double *ap, double vl, double vu, int il, int iu, double abstol, int *m, double *w, double *z, int ldz, double *work, int *iwork, int *ifail)
     * }
     */
    public static MemorySegment LAPACKE_dspevx_work$address() {
        return LAPACKE_dspevx_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dspevx_work(int matrix_layout, char jobz, char range, char uplo, int n, double *ap, double vl, double vu, int il, int iu, double abstol, int *m, double *w, double *z, int ldz, double *work, int *iwork, int *ifail)
     * }
     */
    public static int LAPACKE_dspevx_work(int matrix_layout, byte jobz, byte range, byte uplo, int n, MemorySegment ap, double vl, double vu, int il, int iu, double abstol, MemorySegment m, MemorySegment w, MemorySegment z, int ldz, MemorySegment work, MemorySegment iwork, MemorySegment ifail) {
        var mh$ = LAPACKE_dspevx_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dspevx_work", matrix_layout, jobz, range, uplo, n, ap, vl, vu, il, iu, abstol, m, w, z, ldz, work, iwork, ifail);
            }
            return (int)mh$.invokeExact(matrix_layout, jobz, range, uplo, n, ap, vl, vu, il, iu, abstol, m, w, z, ldz, work, iwork, ifail);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sspgst_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_sspgst_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sspgst_work(int matrix_layout, int itype, char uplo, int n, float *ap, const float *bp)
     * }
     */
    public static FunctionDescriptor LAPACKE_sspgst_work$descriptor() {
        return LAPACKE_sspgst_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sspgst_work(int matrix_layout, int itype, char uplo, int n, float *ap, const float *bp)
     * }
     */
    public static MethodHandle LAPACKE_sspgst_work$handle() {
        return LAPACKE_sspgst_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sspgst_work(int matrix_layout, int itype, char uplo, int n, float *ap, const float *bp)
     * }
     */
    public static MemorySegment LAPACKE_sspgst_work$address() {
        return LAPACKE_sspgst_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sspgst_work(int matrix_layout, int itype, char uplo, int n, float *ap, const float *bp)
     * }
     */
    public static int LAPACKE_sspgst_work(int matrix_layout, int itype, byte uplo, int n, MemorySegment ap, MemorySegment bp) {
        var mh$ = LAPACKE_sspgst_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sspgst_work", matrix_layout, itype, uplo, n, ap, bp);
            }
            return (int)mh$.invokeExact(matrix_layout, itype, uplo, n, ap, bp);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dspgst_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dspgst_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dspgst_work(int matrix_layout, int itype, char uplo, int n, double *ap, const double *bp)
     * }
     */
    public static FunctionDescriptor LAPACKE_dspgst_work$descriptor() {
        return LAPACKE_dspgst_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dspgst_work(int matrix_layout, int itype, char uplo, int n, double *ap, const double *bp)
     * }
     */
    public static MethodHandle LAPACKE_dspgst_work$handle() {
        return LAPACKE_dspgst_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dspgst_work(int matrix_layout, int itype, char uplo, int n, double *ap, const double *bp)
     * }
     */
    public static MemorySegment LAPACKE_dspgst_work$address() {
        return LAPACKE_dspgst_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dspgst_work(int matrix_layout, int itype, char uplo, int n, double *ap, const double *bp)
     * }
     */
    public static int LAPACKE_dspgst_work(int matrix_layout, int itype, byte uplo, int n, MemorySegment ap, MemorySegment bp) {
        var mh$ = LAPACKE_dspgst_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dspgst_work", matrix_layout, itype, uplo, n, ap, bp);
            }
            return (int)mh$.invokeExact(matrix_layout, itype, uplo, n, ap, bp);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sspgv_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_sspgv_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sspgv_work(int matrix_layout, int itype, char jobz, char uplo, int n, float *ap, float *bp, float *w, float *z, int ldz, float *work)
     * }
     */
    public static FunctionDescriptor LAPACKE_sspgv_work$descriptor() {
        return LAPACKE_sspgv_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sspgv_work(int matrix_layout, int itype, char jobz, char uplo, int n, float *ap, float *bp, float *w, float *z, int ldz, float *work)
     * }
     */
    public static MethodHandle LAPACKE_sspgv_work$handle() {
        return LAPACKE_sspgv_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sspgv_work(int matrix_layout, int itype, char jobz, char uplo, int n, float *ap, float *bp, float *w, float *z, int ldz, float *work)
     * }
     */
    public static MemorySegment LAPACKE_sspgv_work$address() {
        return LAPACKE_sspgv_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sspgv_work(int matrix_layout, int itype, char jobz, char uplo, int n, float *ap, float *bp, float *w, float *z, int ldz, float *work)
     * }
     */
    public static int LAPACKE_sspgv_work(int matrix_layout, int itype, byte jobz, byte uplo, int n, MemorySegment ap, MemorySegment bp, MemorySegment w, MemorySegment z, int ldz, MemorySegment work) {
        var mh$ = LAPACKE_sspgv_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sspgv_work", matrix_layout, itype, jobz, uplo, n, ap, bp, w, z, ldz, work);
            }
            return (int)mh$.invokeExact(matrix_layout, itype, jobz, uplo, n, ap, bp, w, z, ldz, work);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dspgv_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dspgv_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dspgv_work(int matrix_layout, int itype, char jobz, char uplo, int n, double *ap, double *bp, double *w, double *z, int ldz, double *work)
     * }
     */
    public static FunctionDescriptor LAPACKE_dspgv_work$descriptor() {
        return LAPACKE_dspgv_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dspgv_work(int matrix_layout, int itype, char jobz, char uplo, int n, double *ap, double *bp, double *w, double *z, int ldz, double *work)
     * }
     */
    public static MethodHandle LAPACKE_dspgv_work$handle() {
        return LAPACKE_dspgv_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dspgv_work(int matrix_layout, int itype, char jobz, char uplo, int n, double *ap, double *bp, double *w, double *z, int ldz, double *work)
     * }
     */
    public static MemorySegment LAPACKE_dspgv_work$address() {
        return LAPACKE_dspgv_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dspgv_work(int matrix_layout, int itype, char jobz, char uplo, int n, double *ap, double *bp, double *w, double *z, int ldz, double *work)
     * }
     */
    public static int LAPACKE_dspgv_work(int matrix_layout, int itype, byte jobz, byte uplo, int n, MemorySegment ap, MemorySegment bp, MemorySegment w, MemorySegment z, int ldz, MemorySegment work) {
        var mh$ = LAPACKE_dspgv_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dspgv_work", matrix_layout, itype, jobz, uplo, n, ap, bp, w, z, ldz, work);
            }
            return (int)mh$.invokeExact(matrix_layout, itype, jobz, uplo, n, ap, bp, w, z, ldz, work);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sspgvd_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_sspgvd_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sspgvd_work(int matrix_layout, int itype, char jobz, char uplo, int n, float *ap, float *bp, float *w, float *z, int ldz, float *work, int lwork, int *iwork, int liwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_sspgvd_work$descriptor() {
        return LAPACKE_sspgvd_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sspgvd_work(int matrix_layout, int itype, char jobz, char uplo, int n, float *ap, float *bp, float *w, float *z, int ldz, float *work, int lwork, int *iwork, int liwork)
     * }
     */
    public static MethodHandle LAPACKE_sspgvd_work$handle() {
        return LAPACKE_sspgvd_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sspgvd_work(int matrix_layout, int itype, char jobz, char uplo, int n, float *ap, float *bp, float *w, float *z, int ldz, float *work, int lwork, int *iwork, int liwork)
     * }
     */
    public static MemorySegment LAPACKE_sspgvd_work$address() {
        return LAPACKE_sspgvd_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sspgvd_work(int matrix_layout, int itype, char jobz, char uplo, int n, float *ap, float *bp, float *w, float *z, int ldz, float *work, int lwork, int *iwork, int liwork)
     * }
     */
    public static int LAPACKE_sspgvd_work(int matrix_layout, int itype, byte jobz, byte uplo, int n, MemorySegment ap, MemorySegment bp, MemorySegment w, MemorySegment z, int ldz, MemorySegment work, int lwork, MemorySegment iwork, int liwork) {
        var mh$ = LAPACKE_sspgvd_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sspgvd_work", matrix_layout, itype, jobz, uplo, n, ap, bp, w, z, ldz, work, lwork, iwork, liwork);
            }
            return (int)mh$.invokeExact(matrix_layout, itype, jobz, uplo, n, ap, bp, w, z, ldz, work, lwork, iwork, liwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dspgvd_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dspgvd_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dspgvd_work(int matrix_layout, int itype, char jobz, char uplo, int n, double *ap, double *bp, double *w, double *z, int ldz, double *work, int lwork, int *iwork, int liwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_dspgvd_work$descriptor() {
        return LAPACKE_dspgvd_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dspgvd_work(int matrix_layout, int itype, char jobz, char uplo, int n, double *ap, double *bp, double *w, double *z, int ldz, double *work, int lwork, int *iwork, int liwork)
     * }
     */
    public static MethodHandle LAPACKE_dspgvd_work$handle() {
        return LAPACKE_dspgvd_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dspgvd_work(int matrix_layout, int itype, char jobz, char uplo, int n, double *ap, double *bp, double *w, double *z, int ldz, double *work, int lwork, int *iwork, int liwork)
     * }
     */
    public static MemorySegment LAPACKE_dspgvd_work$address() {
        return LAPACKE_dspgvd_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dspgvd_work(int matrix_layout, int itype, char jobz, char uplo, int n, double *ap, double *bp, double *w, double *z, int ldz, double *work, int lwork, int *iwork, int liwork)
     * }
     */
    public static int LAPACKE_dspgvd_work(int matrix_layout, int itype, byte jobz, byte uplo, int n, MemorySegment ap, MemorySegment bp, MemorySegment w, MemorySegment z, int ldz, MemorySegment work, int lwork, MemorySegment iwork, int liwork) {
        var mh$ = LAPACKE_dspgvd_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dspgvd_work", matrix_layout, itype, jobz, uplo, n, ap, bp, w, z, ldz, work, lwork, iwork, liwork);
            }
            return (int)mh$.invokeExact(matrix_layout, itype, jobz, uplo, n, ap, bp, w, z, ldz, work, lwork, iwork, liwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sspgvx_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_FLOAT,
            lapacke_h.C_FLOAT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_FLOAT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_sspgvx_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sspgvx_work(int matrix_layout, int itype, char jobz, char range, char uplo, int n, float *ap, float *bp, float vl, float vu, int il, int iu, float abstol, int *m, float *w, float *z, int ldz, float *work, int *iwork, int *ifail)
     * }
     */
    public static FunctionDescriptor LAPACKE_sspgvx_work$descriptor() {
        return LAPACKE_sspgvx_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sspgvx_work(int matrix_layout, int itype, char jobz, char range, char uplo, int n, float *ap, float *bp, float vl, float vu, int il, int iu, float abstol, int *m, float *w, float *z, int ldz, float *work, int *iwork, int *ifail)
     * }
     */
    public static MethodHandle LAPACKE_sspgvx_work$handle() {
        return LAPACKE_sspgvx_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sspgvx_work(int matrix_layout, int itype, char jobz, char range, char uplo, int n, float *ap, float *bp, float vl, float vu, int il, int iu, float abstol, int *m, float *w, float *z, int ldz, float *work, int *iwork, int *ifail)
     * }
     */
    public static MemorySegment LAPACKE_sspgvx_work$address() {
        return LAPACKE_sspgvx_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sspgvx_work(int matrix_layout, int itype, char jobz, char range, char uplo, int n, float *ap, float *bp, float vl, float vu, int il, int iu, float abstol, int *m, float *w, float *z, int ldz, float *work, int *iwork, int *ifail)
     * }
     */
    public static int LAPACKE_sspgvx_work(int matrix_layout, int itype, byte jobz, byte range, byte uplo, int n, MemorySegment ap, MemorySegment bp, float vl, float vu, int il, int iu, float abstol, MemorySegment m, MemorySegment w, MemorySegment z, int ldz, MemorySegment work, MemorySegment iwork, MemorySegment ifail) {
        var mh$ = LAPACKE_sspgvx_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sspgvx_work", matrix_layout, itype, jobz, range, uplo, n, ap, bp, vl, vu, il, iu, abstol, m, w, z, ldz, work, iwork, ifail);
            }
            return (int)mh$.invokeExact(matrix_layout, itype, jobz, range, uplo, n, ap, bp, vl, vu, il, iu, abstol, m, w, z, ldz, work, iwork, ifail);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dspgvx_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_DOUBLE,
            lapacke_h.C_DOUBLE,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_DOUBLE,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dspgvx_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dspgvx_work(int matrix_layout, int itype, char jobz, char range, char uplo, int n, double *ap, double *bp, double vl, double vu, int il, int iu, double abstol, int *m, double *w, double *z, int ldz, double *work, int *iwork, int *ifail)
     * }
     */
    public static FunctionDescriptor LAPACKE_dspgvx_work$descriptor() {
        return LAPACKE_dspgvx_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dspgvx_work(int matrix_layout, int itype, char jobz, char range, char uplo, int n, double *ap, double *bp, double vl, double vu, int il, int iu, double abstol, int *m, double *w, double *z, int ldz, double *work, int *iwork, int *ifail)
     * }
     */
    public static MethodHandle LAPACKE_dspgvx_work$handle() {
        return LAPACKE_dspgvx_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dspgvx_work(int matrix_layout, int itype, char jobz, char range, char uplo, int n, double *ap, double *bp, double vl, double vu, int il, int iu, double abstol, int *m, double *w, double *z, int ldz, double *work, int *iwork, int *ifail)
     * }
     */
    public static MemorySegment LAPACKE_dspgvx_work$address() {
        return LAPACKE_dspgvx_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dspgvx_work(int matrix_layout, int itype, char jobz, char range, char uplo, int n, double *ap, double *bp, double vl, double vu, int il, int iu, double abstol, int *m, double *w, double *z, int ldz, double *work, int *iwork, int *ifail)
     * }
     */
    public static int LAPACKE_dspgvx_work(int matrix_layout, int itype, byte jobz, byte range, byte uplo, int n, MemorySegment ap, MemorySegment bp, double vl, double vu, int il, int iu, double abstol, MemorySegment m, MemorySegment w, MemorySegment z, int ldz, MemorySegment work, MemorySegment iwork, MemorySegment ifail) {
        var mh$ = LAPACKE_dspgvx_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dspgvx_work", matrix_layout, itype, jobz, range, uplo, n, ap, bp, vl, vu, il, iu, abstol, m, w, z, ldz, work, iwork, ifail);
            }
            return (int)mh$.invokeExact(matrix_layout, itype, jobz, range, uplo, n, ap, bp, vl, vu, il, iu, abstol, m, w, z, ldz, work, iwork, ifail);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ssprfs_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_ssprfs_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ssprfs_work(int matrix_layout, char uplo, int n, int nrhs, const float *ap, const float *afp, const int *ipiv, const float *b, int ldb, float *x, int ldx, float *ferr, float *berr, float *work, int *iwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_ssprfs_work$descriptor() {
        return LAPACKE_ssprfs_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ssprfs_work(int matrix_layout, char uplo, int n, int nrhs, const float *ap, const float *afp, const int *ipiv, const float *b, int ldb, float *x, int ldx, float *ferr, float *berr, float *work, int *iwork)
     * }
     */
    public static MethodHandle LAPACKE_ssprfs_work$handle() {
        return LAPACKE_ssprfs_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ssprfs_work(int matrix_layout, char uplo, int n, int nrhs, const float *ap, const float *afp, const int *ipiv, const float *b, int ldb, float *x, int ldx, float *ferr, float *berr, float *work, int *iwork)
     * }
     */
    public static MemorySegment LAPACKE_ssprfs_work$address() {
        return LAPACKE_ssprfs_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ssprfs_work(int matrix_layout, char uplo, int n, int nrhs, const float *ap, const float *afp, const int *ipiv, const float *b, int ldb, float *x, int ldx, float *ferr, float *berr, float *work, int *iwork)
     * }
     */
    public static int LAPACKE_ssprfs_work(int matrix_layout, byte uplo, int n, int nrhs, MemorySegment ap, MemorySegment afp, MemorySegment ipiv, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment ferr, MemorySegment berr, MemorySegment work, MemorySegment iwork) {
        var mh$ = LAPACKE_ssprfs_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ssprfs_work", matrix_layout, uplo, n, nrhs, ap, afp, ipiv, b, ldb, x, ldx, ferr, berr, work, iwork);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, nrhs, ap, afp, ipiv, b, ldb, x, ldx, ferr, berr, work, iwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dsprfs_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dsprfs_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dsprfs_work(int matrix_layout, char uplo, int n, int nrhs, const double *ap, const double *afp, const int *ipiv, const double *b, int ldb, double *x, int ldx, double *ferr, double *berr, double *work, int *iwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_dsprfs_work$descriptor() {
        return LAPACKE_dsprfs_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dsprfs_work(int matrix_layout, char uplo, int n, int nrhs, const double *ap, const double *afp, const int *ipiv, const double *b, int ldb, double *x, int ldx, double *ferr, double *berr, double *work, int *iwork)
     * }
     */
    public static MethodHandle LAPACKE_dsprfs_work$handle() {
        return LAPACKE_dsprfs_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dsprfs_work(int matrix_layout, char uplo, int n, int nrhs, const double *ap, const double *afp, const int *ipiv, const double *b, int ldb, double *x, int ldx, double *ferr, double *berr, double *work, int *iwork)
     * }
     */
    public static MemorySegment LAPACKE_dsprfs_work$address() {
        return LAPACKE_dsprfs_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dsprfs_work(int matrix_layout, char uplo, int n, int nrhs, const double *ap, const double *afp, const int *ipiv, const double *b, int ldb, double *x, int ldx, double *ferr, double *berr, double *work, int *iwork)
     * }
     */
    public static int LAPACKE_dsprfs_work(int matrix_layout, byte uplo, int n, int nrhs, MemorySegment ap, MemorySegment afp, MemorySegment ipiv, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment ferr, MemorySegment berr, MemorySegment work, MemorySegment iwork) {
        var mh$ = LAPACKE_dsprfs_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dsprfs_work", matrix_layout, uplo, n, nrhs, ap, afp, ipiv, b, ldb, x, ldx, ferr, berr, work, iwork);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, nrhs, ap, afp, ipiv, b, ldb, x, ldx, ferr, berr, work, iwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_csprfs_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_csprfs_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_csprfs_work(int matrix_layout, char uplo, int n, int nrhs, const _Complex float *ap, const _Complex float *afp, const int *ipiv, const _Complex float *b, int ldb, _Complex float *x, int ldx, float *ferr, float *berr, _Complex float *work, float *rwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_csprfs_work$descriptor() {
        return LAPACKE_csprfs_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_csprfs_work(int matrix_layout, char uplo, int n, int nrhs, const _Complex float *ap, const _Complex float *afp, const int *ipiv, const _Complex float *b, int ldb, _Complex float *x, int ldx, float *ferr, float *berr, _Complex float *work, float *rwork)
     * }
     */
    public static MethodHandle LAPACKE_csprfs_work$handle() {
        return LAPACKE_csprfs_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_csprfs_work(int matrix_layout, char uplo, int n, int nrhs, const _Complex float *ap, const _Complex float *afp, const int *ipiv, const _Complex float *b, int ldb, _Complex float *x, int ldx, float *ferr, float *berr, _Complex float *work, float *rwork)
     * }
     */
    public static MemorySegment LAPACKE_csprfs_work$address() {
        return LAPACKE_csprfs_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_csprfs_work(int matrix_layout, char uplo, int n, int nrhs, const _Complex float *ap, const _Complex float *afp, const int *ipiv, const _Complex float *b, int ldb, _Complex float *x, int ldx, float *ferr, float *berr, _Complex float *work, float *rwork)
     * }
     */
    public static int LAPACKE_csprfs_work(int matrix_layout, byte uplo, int n, int nrhs, MemorySegment ap, MemorySegment afp, MemorySegment ipiv, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment ferr, MemorySegment berr, MemorySegment work, MemorySegment rwork) {
        var mh$ = LAPACKE_csprfs_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_csprfs_work", matrix_layout, uplo, n, nrhs, ap, afp, ipiv, b, ldb, x, ldx, ferr, berr, work, rwork);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, nrhs, ap, afp, ipiv, b, ldb, x, ldx, ferr, berr, work, rwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zsprfs_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zsprfs_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zsprfs_work(int matrix_layout, char uplo, int n, int nrhs, const _Complex double *ap, const _Complex double *afp, const int *ipiv, const _Complex double *b, int ldb, _Complex double *x, int ldx, double *ferr, double *berr, _Complex double *work, double *rwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_zsprfs_work$descriptor() {
        return LAPACKE_zsprfs_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zsprfs_work(int matrix_layout, char uplo, int n, int nrhs, const _Complex double *ap, const _Complex double *afp, const int *ipiv, const _Complex double *b, int ldb, _Complex double *x, int ldx, double *ferr, double *berr, _Complex double *work, double *rwork)
     * }
     */
    public static MethodHandle LAPACKE_zsprfs_work$handle() {
        return LAPACKE_zsprfs_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zsprfs_work(int matrix_layout, char uplo, int n, int nrhs, const _Complex double *ap, const _Complex double *afp, const int *ipiv, const _Complex double *b, int ldb, _Complex double *x, int ldx, double *ferr, double *berr, _Complex double *work, double *rwork)
     * }
     */
    public static MemorySegment LAPACKE_zsprfs_work$address() {
        return LAPACKE_zsprfs_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zsprfs_work(int matrix_layout, char uplo, int n, int nrhs, const _Complex double *ap, const _Complex double *afp, const int *ipiv, const _Complex double *b, int ldb, _Complex double *x, int ldx, double *ferr, double *berr, _Complex double *work, double *rwork)
     * }
     */
    public static int LAPACKE_zsprfs_work(int matrix_layout, byte uplo, int n, int nrhs, MemorySegment ap, MemorySegment afp, MemorySegment ipiv, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment ferr, MemorySegment berr, MemorySegment work, MemorySegment rwork) {
        var mh$ = LAPACKE_zsprfs_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zsprfs_work", matrix_layout, uplo, n, nrhs, ap, afp, ipiv, b, ldb, x, ldx, ferr, berr, work, rwork);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, nrhs, ap, afp, ipiv, b, ldb, x, ldx, ferr, berr, work, rwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sspsv_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_sspsv_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sspsv_work(int matrix_layout, char uplo, int n, int nrhs, float *ap, int *ipiv, float *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_sspsv_work$descriptor() {
        return LAPACKE_sspsv_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sspsv_work(int matrix_layout, char uplo, int n, int nrhs, float *ap, int *ipiv, float *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_sspsv_work$handle() {
        return LAPACKE_sspsv_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sspsv_work(int matrix_layout, char uplo, int n, int nrhs, float *ap, int *ipiv, float *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_sspsv_work$address() {
        return LAPACKE_sspsv_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sspsv_work(int matrix_layout, char uplo, int n, int nrhs, float *ap, int *ipiv, float *b, int ldb)
     * }
     */
    public static int LAPACKE_sspsv_work(int matrix_layout, byte uplo, int n, int nrhs, MemorySegment ap, MemorySegment ipiv, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_sspsv_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sspsv_work", matrix_layout, uplo, n, nrhs, ap, ipiv, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, nrhs, ap, ipiv, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dspsv_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dspsv_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dspsv_work(int matrix_layout, char uplo, int n, int nrhs, double *ap, int *ipiv, double *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_dspsv_work$descriptor() {
        return LAPACKE_dspsv_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dspsv_work(int matrix_layout, char uplo, int n, int nrhs, double *ap, int *ipiv, double *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_dspsv_work$handle() {
        return LAPACKE_dspsv_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dspsv_work(int matrix_layout, char uplo, int n, int nrhs, double *ap, int *ipiv, double *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_dspsv_work$address() {
        return LAPACKE_dspsv_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dspsv_work(int matrix_layout, char uplo, int n, int nrhs, double *ap, int *ipiv, double *b, int ldb)
     * }
     */
    public static int LAPACKE_dspsv_work(int matrix_layout, byte uplo, int n, int nrhs, MemorySegment ap, MemorySegment ipiv, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_dspsv_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dspsv_work", matrix_layout, uplo, n, nrhs, ap, ipiv, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, nrhs, ap, ipiv, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cspsv_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_cspsv_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cspsv_work(int matrix_layout, char uplo, int n, int nrhs, _Complex float *ap, int *ipiv, _Complex float *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_cspsv_work$descriptor() {
        return LAPACKE_cspsv_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cspsv_work(int matrix_layout, char uplo, int n, int nrhs, _Complex float *ap, int *ipiv, _Complex float *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_cspsv_work$handle() {
        return LAPACKE_cspsv_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cspsv_work(int matrix_layout, char uplo, int n, int nrhs, _Complex float *ap, int *ipiv, _Complex float *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_cspsv_work$address() {
        return LAPACKE_cspsv_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cspsv_work(int matrix_layout, char uplo, int n, int nrhs, _Complex float *ap, int *ipiv, _Complex float *b, int ldb)
     * }
     */
    public static int LAPACKE_cspsv_work(int matrix_layout, byte uplo, int n, int nrhs, MemorySegment ap, MemorySegment ipiv, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_cspsv_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cspsv_work", matrix_layout, uplo, n, nrhs, ap, ipiv, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, nrhs, ap, ipiv, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zspsv_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zspsv_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zspsv_work(int matrix_layout, char uplo, int n, int nrhs, _Complex double *ap, int *ipiv, _Complex double *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_zspsv_work$descriptor() {
        return LAPACKE_zspsv_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zspsv_work(int matrix_layout, char uplo, int n, int nrhs, _Complex double *ap, int *ipiv, _Complex double *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_zspsv_work$handle() {
        return LAPACKE_zspsv_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zspsv_work(int matrix_layout, char uplo, int n, int nrhs, _Complex double *ap, int *ipiv, _Complex double *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_zspsv_work$address() {
        return LAPACKE_zspsv_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zspsv_work(int matrix_layout, char uplo, int n, int nrhs, _Complex double *ap, int *ipiv, _Complex double *b, int ldb)
     * }
     */
    public static int LAPACKE_zspsv_work(int matrix_layout, byte uplo, int n, int nrhs, MemorySegment ap, MemorySegment ipiv, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_zspsv_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zspsv_work", matrix_layout, uplo, n, nrhs, ap, ipiv, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, nrhs, ap, ipiv, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sspsvx_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_sspsvx_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sspsvx_work(int matrix_layout, char fact, char uplo, int n, int nrhs, const float *ap, float *afp, int *ipiv, const float *b, int ldb, float *x, int ldx, float *rcond, float *ferr, float *berr, float *work, int *iwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_sspsvx_work$descriptor() {
        return LAPACKE_sspsvx_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sspsvx_work(int matrix_layout, char fact, char uplo, int n, int nrhs, const float *ap, float *afp, int *ipiv, const float *b, int ldb, float *x, int ldx, float *rcond, float *ferr, float *berr, float *work, int *iwork)
     * }
     */
    public static MethodHandle LAPACKE_sspsvx_work$handle() {
        return LAPACKE_sspsvx_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sspsvx_work(int matrix_layout, char fact, char uplo, int n, int nrhs, const float *ap, float *afp, int *ipiv, const float *b, int ldb, float *x, int ldx, float *rcond, float *ferr, float *berr, float *work, int *iwork)
     * }
     */
    public static MemorySegment LAPACKE_sspsvx_work$address() {
        return LAPACKE_sspsvx_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sspsvx_work(int matrix_layout, char fact, char uplo, int n, int nrhs, const float *ap, float *afp, int *ipiv, const float *b, int ldb, float *x, int ldx, float *rcond, float *ferr, float *berr, float *work, int *iwork)
     * }
     */
    public static int LAPACKE_sspsvx_work(int matrix_layout, byte fact, byte uplo, int n, int nrhs, MemorySegment ap, MemorySegment afp, MemorySegment ipiv, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment rcond, MemorySegment ferr, MemorySegment berr, MemorySegment work, MemorySegment iwork) {
        var mh$ = LAPACKE_sspsvx_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sspsvx_work", matrix_layout, fact, uplo, n, nrhs, ap, afp, ipiv, b, ldb, x, ldx, rcond, ferr, berr, work, iwork);
            }
            return (int)mh$.invokeExact(matrix_layout, fact, uplo, n, nrhs, ap, afp, ipiv, b, ldb, x, ldx, rcond, ferr, berr, work, iwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dspsvx_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dspsvx_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dspsvx_work(int matrix_layout, char fact, char uplo, int n, int nrhs, const double *ap, double *afp, int *ipiv, const double *b, int ldb, double *x, int ldx, double *rcond, double *ferr, double *berr, double *work, int *iwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_dspsvx_work$descriptor() {
        return LAPACKE_dspsvx_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dspsvx_work(int matrix_layout, char fact, char uplo, int n, int nrhs, const double *ap, double *afp, int *ipiv, const double *b, int ldb, double *x, int ldx, double *rcond, double *ferr, double *berr, double *work, int *iwork)
     * }
     */
    public static MethodHandle LAPACKE_dspsvx_work$handle() {
        return LAPACKE_dspsvx_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dspsvx_work(int matrix_layout, char fact, char uplo, int n, int nrhs, const double *ap, double *afp, int *ipiv, const double *b, int ldb, double *x, int ldx, double *rcond, double *ferr, double *berr, double *work, int *iwork)
     * }
     */
    public static MemorySegment LAPACKE_dspsvx_work$address() {
        return LAPACKE_dspsvx_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dspsvx_work(int matrix_layout, char fact, char uplo, int n, int nrhs, const double *ap, double *afp, int *ipiv, const double *b, int ldb, double *x, int ldx, double *rcond, double *ferr, double *berr, double *work, int *iwork)
     * }
     */
    public static int LAPACKE_dspsvx_work(int matrix_layout, byte fact, byte uplo, int n, int nrhs, MemorySegment ap, MemorySegment afp, MemorySegment ipiv, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment rcond, MemorySegment ferr, MemorySegment berr, MemorySegment work, MemorySegment iwork) {
        var mh$ = LAPACKE_dspsvx_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dspsvx_work", matrix_layout, fact, uplo, n, nrhs, ap, afp, ipiv, b, ldb, x, ldx, rcond, ferr, berr, work, iwork);
            }
            return (int)mh$.invokeExact(matrix_layout, fact, uplo, n, nrhs, ap, afp, ipiv, b, ldb, x, ldx, rcond, ferr, berr, work, iwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cspsvx_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_cspsvx_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cspsvx_work(int matrix_layout, char fact, char uplo, int n, int nrhs, const _Complex float *ap, _Complex float *afp, int *ipiv, const _Complex float *b, int ldb, _Complex float *x, int ldx, float *rcond, float *ferr, float *berr, _Complex float *work, float *rwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_cspsvx_work$descriptor() {
        return LAPACKE_cspsvx_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cspsvx_work(int matrix_layout, char fact, char uplo, int n, int nrhs, const _Complex float *ap, _Complex float *afp, int *ipiv, const _Complex float *b, int ldb, _Complex float *x, int ldx, float *rcond, float *ferr, float *berr, _Complex float *work, float *rwork)
     * }
     */
    public static MethodHandle LAPACKE_cspsvx_work$handle() {
        return LAPACKE_cspsvx_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cspsvx_work(int matrix_layout, char fact, char uplo, int n, int nrhs, const _Complex float *ap, _Complex float *afp, int *ipiv, const _Complex float *b, int ldb, _Complex float *x, int ldx, float *rcond, float *ferr, float *berr, _Complex float *work, float *rwork)
     * }
     */
    public static MemorySegment LAPACKE_cspsvx_work$address() {
        return LAPACKE_cspsvx_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cspsvx_work(int matrix_layout, char fact, char uplo, int n, int nrhs, const _Complex float *ap, _Complex float *afp, int *ipiv, const _Complex float *b, int ldb, _Complex float *x, int ldx, float *rcond, float *ferr, float *berr, _Complex float *work, float *rwork)
     * }
     */
    public static int LAPACKE_cspsvx_work(int matrix_layout, byte fact, byte uplo, int n, int nrhs, MemorySegment ap, MemorySegment afp, MemorySegment ipiv, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment rcond, MemorySegment ferr, MemorySegment berr, MemorySegment work, MemorySegment rwork) {
        var mh$ = LAPACKE_cspsvx_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cspsvx_work", matrix_layout, fact, uplo, n, nrhs, ap, afp, ipiv, b, ldb, x, ldx, rcond, ferr, berr, work, rwork);
            }
            return (int)mh$.invokeExact(matrix_layout, fact, uplo, n, nrhs, ap, afp, ipiv, b, ldb, x, ldx, rcond, ferr, berr, work, rwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zspsvx_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zspsvx_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zspsvx_work(int matrix_layout, char fact, char uplo, int n, int nrhs, const _Complex double *ap, _Complex double *afp, int *ipiv, const _Complex double *b, int ldb, _Complex double *x, int ldx, double *rcond, double *ferr, double *berr, _Complex double *work, double *rwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_zspsvx_work$descriptor() {
        return LAPACKE_zspsvx_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zspsvx_work(int matrix_layout, char fact, char uplo, int n, int nrhs, const _Complex double *ap, _Complex double *afp, int *ipiv, const _Complex double *b, int ldb, _Complex double *x, int ldx, double *rcond, double *ferr, double *berr, _Complex double *work, double *rwork)
     * }
     */
    public static MethodHandle LAPACKE_zspsvx_work$handle() {
        return LAPACKE_zspsvx_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zspsvx_work(int matrix_layout, char fact, char uplo, int n, int nrhs, const _Complex double *ap, _Complex double *afp, int *ipiv, const _Complex double *b, int ldb, _Complex double *x, int ldx, double *rcond, double *ferr, double *berr, _Complex double *work, double *rwork)
     * }
     */
    public static MemorySegment LAPACKE_zspsvx_work$address() {
        return LAPACKE_zspsvx_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zspsvx_work(int matrix_layout, char fact, char uplo, int n, int nrhs, const _Complex double *ap, _Complex double *afp, int *ipiv, const _Complex double *b, int ldb, _Complex double *x, int ldx, double *rcond, double *ferr, double *berr, _Complex double *work, double *rwork)
     * }
     */
    public static int LAPACKE_zspsvx_work(int matrix_layout, byte fact, byte uplo, int n, int nrhs, MemorySegment ap, MemorySegment afp, MemorySegment ipiv, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment rcond, MemorySegment ferr, MemorySegment berr, MemorySegment work, MemorySegment rwork) {
        var mh$ = LAPACKE_zspsvx_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zspsvx_work", matrix_layout, fact, uplo, n, nrhs, ap, afp, ipiv, b, ldb, x, ldx, rcond, ferr, berr, work, rwork);
            }
            return (int)mh$.invokeExact(matrix_layout, fact, uplo, n, nrhs, ap, afp, ipiv, b, ldb, x, ldx, rcond, ferr, berr, work, rwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ssptrd_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_ssptrd_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ssptrd_work(int matrix_layout, char uplo, int n, float *ap, float *d, float *e, float *tau)
     * }
     */
    public static FunctionDescriptor LAPACKE_ssptrd_work$descriptor() {
        return LAPACKE_ssptrd_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ssptrd_work(int matrix_layout, char uplo, int n, float *ap, float *d, float *e, float *tau)
     * }
     */
    public static MethodHandle LAPACKE_ssptrd_work$handle() {
        return LAPACKE_ssptrd_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ssptrd_work(int matrix_layout, char uplo, int n, float *ap, float *d, float *e, float *tau)
     * }
     */
    public static MemorySegment LAPACKE_ssptrd_work$address() {
        return LAPACKE_ssptrd_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ssptrd_work(int matrix_layout, char uplo, int n, float *ap, float *d, float *e, float *tau)
     * }
     */
    public static int LAPACKE_ssptrd_work(int matrix_layout, byte uplo, int n, MemorySegment ap, MemorySegment d, MemorySegment e, MemorySegment tau) {
        var mh$ = LAPACKE_ssptrd_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ssptrd_work", matrix_layout, uplo, n, ap, d, e, tau);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, ap, d, e, tau);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dsptrd_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dsptrd_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dsptrd_work(int matrix_layout, char uplo, int n, double *ap, double *d, double *e, double *tau)
     * }
     */
    public static FunctionDescriptor LAPACKE_dsptrd_work$descriptor() {
        return LAPACKE_dsptrd_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dsptrd_work(int matrix_layout, char uplo, int n, double *ap, double *d, double *e, double *tau)
     * }
     */
    public static MethodHandle LAPACKE_dsptrd_work$handle() {
        return LAPACKE_dsptrd_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dsptrd_work(int matrix_layout, char uplo, int n, double *ap, double *d, double *e, double *tau)
     * }
     */
    public static MemorySegment LAPACKE_dsptrd_work$address() {
        return LAPACKE_dsptrd_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dsptrd_work(int matrix_layout, char uplo, int n, double *ap, double *d, double *e, double *tau)
     * }
     */
    public static int LAPACKE_dsptrd_work(int matrix_layout, byte uplo, int n, MemorySegment ap, MemorySegment d, MemorySegment e, MemorySegment tau) {
        var mh$ = LAPACKE_dsptrd_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dsptrd_work", matrix_layout, uplo, n, ap, d, e, tau);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, ap, d, e, tau);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ssptrf_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_ssptrf_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ssptrf_work(int matrix_layout, char uplo, int n, float *ap, int *ipiv)
     * }
     */
    public static FunctionDescriptor LAPACKE_ssptrf_work$descriptor() {
        return LAPACKE_ssptrf_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ssptrf_work(int matrix_layout, char uplo, int n, float *ap, int *ipiv)
     * }
     */
    public static MethodHandle LAPACKE_ssptrf_work$handle() {
        return LAPACKE_ssptrf_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ssptrf_work(int matrix_layout, char uplo, int n, float *ap, int *ipiv)
     * }
     */
    public static MemorySegment LAPACKE_ssptrf_work$address() {
        return LAPACKE_ssptrf_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ssptrf_work(int matrix_layout, char uplo, int n, float *ap, int *ipiv)
     * }
     */
    public static int LAPACKE_ssptrf_work(int matrix_layout, byte uplo, int n, MemorySegment ap, MemorySegment ipiv) {
        var mh$ = LAPACKE_ssptrf_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ssptrf_work", matrix_layout, uplo, n, ap, ipiv);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, ap, ipiv);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dsptrf_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dsptrf_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dsptrf_work(int matrix_layout, char uplo, int n, double *ap, int *ipiv)
     * }
     */
    public static FunctionDescriptor LAPACKE_dsptrf_work$descriptor() {
        return LAPACKE_dsptrf_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dsptrf_work(int matrix_layout, char uplo, int n, double *ap, int *ipiv)
     * }
     */
    public static MethodHandle LAPACKE_dsptrf_work$handle() {
        return LAPACKE_dsptrf_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dsptrf_work(int matrix_layout, char uplo, int n, double *ap, int *ipiv)
     * }
     */
    public static MemorySegment LAPACKE_dsptrf_work$address() {
        return LAPACKE_dsptrf_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dsptrf_work(int matrix_layout, char uplo, int n, double *ap, int *ipiv)
     * }
     */
    public static int LAPACKE_dsptrf_work(int matrix_layout, byte uplo, int n, MemorySegment ap, MemorySegment ipiv) {
        var mh$ = LAPACKE_dsptrf_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dsptrf_work", matrix_layout, uplo, n, ap, ipiv);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, ap, ipiv);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_csptrf_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_csptrf_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_csptrf_work(int matrix_layout, char uplo, int n, _Complex float *ap, int *ipiv)
     * }
     */
    public static FunctionDescriptor LAPACKE_csptrf_work$descriptor() {
        return LAPACKE_csptrf_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_csptrf_work(int matrix_layout, char uplo, int n, _Complex float *ap, int *ipiv)
     * }
     */
    public static MethodHandle LAPACKE_csptrf_work$handle() {
        return LAPACKE_csptrf_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_csptrf_work(int matrix_layout, char uplo, int n, _Complex float *ap, int *ipiv)
     * }
     */
    public static MemorySegment LAPACKE_csptrf_work$address() {
        return LAPACKE_csptrf_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_csptrf_work(int matrix_layout, char uplo, int n, _Complex float *ap, int *ipiv)
     * }
     */
    public static int LAPACKE_csptrf_work(int matrix_layout, byte uplo, int n, MemorySegment ap, MemorySegment ipiv) {
        var mh$ = LAPACKE_csptrf_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_csptrf_work", matrix_layout, uplo, n, ap, ipiv);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, ap, ipiv);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zsptrf_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zsptrf_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zsptrf_work(int matrix_layout, char uplo, int n, _Complex double *ap, int *ipiv)
     * }
     */
    public static FunctionDescriptor LAPACKE_zsptrf_work$descriptor() {
        return LAPACKE_zsptrf_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zsptrf_work(int matrix_layout, char uplo, int n, _Complex double *ap, int *ipiv)
     * }
     */
    public static MethodHandle LAPACKE_zsptrf_work$handle() {
        return LAPACKE_zsptrf_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zsptrf_work(int matrix_layout, char uplo, int n, _Complex double *ap, int *ipiv)
     * }
     */
    public static MemorySegment LAPACKE_zsptrf_work$address() {
        return LAPACKE_zsptrf_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zsptrf_work(int matrix_layout, char uplo, int n, _Complex double *ap, int *ipiv)
     * }
     */
    public static int LAPACKE_zsptrf_work(int matrix_layout, byte uplo, int n, MemorySegment ap, MemorySegment ipiv) {
        var mh$ = LAPACKE_zsptrf_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zsptrf_work", matrix_layout, uplo, n, ap, ipiv);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, ap, ipiv);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ssptri_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_ssptri_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ssptri_work(int matrix_layout, char uplo, int n, float *ap, const int *ipiv, float *work)
     * }
     */
    public static FunctionDescriptor LAPACKE_ssptri_work$descriptor() {
        return LAPACKE_ssptri_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ssptri_work(int matrix_layout, char uplo, int n, float *ap, const int *ipiv, float *work)
     * }
     */
    public static MethodHandle LAPACKE_ssptri_work$handle() {
        return LAPACKE_ssptri_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ssptri_work(int matrix_layout, char uplo, int n, float *ap, const int *ipiv, float *work)
     * }
     */
    public static MemorySegment LAPACKE_ssptri_work$address() {
        return LAPACKE_ssptri_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ssptri_work(int matrix_layout, char uplo, int n, float *ap, const int *ipiv, float *work)
     * }
     */
    public static int LAPACKE_ssptri_work(int matrix_layout, byte uplo, int n, MemorySegment ap, MemorySegment ipiv, MemorySegment work) {
        var mh$ = LAPACKE_ssptri_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ssptri_work", matrix_layout, uplo, n, ap, ipiv, work);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, ap, ipiv, work);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dsptri_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dsptri_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dsptri_work(int matrix_layout, char uplo, int n, double *ap, const int *ipiv, double *work)
     * }
     */
    public static FunctionDescriptor LAPACKE_dsptri_work$descriptor() {
        return LAPACKE_dsptri_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dsptri_work(int matrix_layout, char uplo, int n, double *ap, const int *ipiv, double *work)
     * }
     */
    public static MethodHandle LAPACKE_dsptri_work$handle() {
        return LAPACKE_dsptri_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dsptri_work(int matrix_layout, char uplo, int n, double *ap, const int *ipiv, double *work)
     * }
     */
    public static MemorySegment LAPACKE_dsptri_work$address() {
        return LAPACKE_dsptri_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dsptri_work(int matrix_layout, char uplo, int n, double *ap, const int *ipiv, double *work)
     * }
     */
    public static int LAPACKE_dsptri_work(int matrix_layout, byte uplo, int n, MemorySegment ap, MemorySegment ipiv, MemorySegment work) {
        var mh$ = LAPACKE_dsptri_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dsptri_work", matrix_layout, uplo, n, ap, ipiv, work);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, ap, ipiv, work);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_csptri_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_csptri_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_csptri_work(int matrix_layout, char uplo, int n, _Complex float *ap, const int *ipiv, _Complex float *work)
     * }
     */
    public static FunctionDescriptor LAPACKE_csptri_work$descriptor() {
        return LAPACKE_csptri_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_csptri_work(int matrix_layout, char uplo, int n, _Complex float *ap, const int *ipiv, _Complex float *work)
     * }
     */
    public static MethodHandle LAPACKE_csptri_work$handle() {
        return LAPACKE_csptri_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_csptri_work(int matrix_layout, char uplo, int n, _Complex float *ap, const int *ipiv, _Complex float *work)
     * }
     */
    public static MemorySegment LAPACKE_csptri_work$address() {
        return LAPACKE_csptri_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_csptri_work(int matrix_layout, char uplo, int n, _Complex float *ap, const int *ipiv, _Complex float *work)
     * }
     */
    public static int LAPACKE_csptri_work(int matrix_layout, byte uplo, int n, MemorySegment ap, MemorySegment ipiv, MemorySegment work) {
        var mh$ = LAPACKE_csptri_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_csptri_work", matrix_layout, uplo, n, ap, ipiv, work);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, ap, ipiv, work);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zsptri_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zsptri_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zsptri_work(int matrix_layout, char uplo, int n, _Complex double *ap, const int *ipiv, _Complex double *work)
     * }
     */
    public static FunctionDescriptor LAPACKE_zsptri_work$descriptor() {
        return LAPACKE_zsptri_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zsptri_work(int matrix_layout, char uplo, int n, _Complex double *ap, const int *ipiv, _Complex double *work)
     * }
     */
    public static MethodHandle LAPACKE_zsptri_work$handle() {
        return LAPACKE_zsptri_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zsptri_work(int matrix_layout, char uplo, int n, _Complex double *ap, const int *ipiv, _Complex double *work)
     * }
     */
    public static MemorySegment LAPACKE_zsptri_work$address() {
        return LAPACKE_zsptri_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zsptri_work(int matrix_layout, char uplo, int n, _Complex double *ap, const int *ipiv, _Complex double *work)
     * }
     */
    public static int LAPACKE_zsptri_work(int matrix_layout, byte uplo, int n, MemorySegment ap, MemorySegment ipiv, MemorySegment work) {
        var mh$ = LAPACKE_zsptri_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zsptri_work", matrix_layout, uplo, n, ap, ipiv, work);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, ap, ipiv, work);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ssptrs_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_ssptrs_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ssptrs_work(int matrix_layout, char uplo, int n, int nrhs, const float *ap, const int *ipiv, float *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_ssptrs_work$descriptor() {
        return LAPACKE_ssptrs_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ssptrs_work(int matrix_layout, char uplo, int n, int nrhs, const float *ap, const int *ipiv, float *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_ssptrs_work$handle() {
        return LAPACKE_ssptrs_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ssptrs_work(int matrix_layout, char uplo, int n, int nrhs, const float *ap, const int *ipiv, float *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_ssptrs_work$address() {
        return LAPACKE_ssptrs_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ssptrs_work(int matrix_layout, char uplo, int n, int nrhs, const float *ap, const int *ipiv, float *b, int ldb)
     * }
     */
    public static int LAPACKE_ssptrs_work(int matrix_layout, byte uplo, int n, int nrhs, MemorySegment ap, MemorySegment ipiv, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_ssptrs_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ssptrs_work", matrix_layout, uplo, n, nrhs, ap, ipiv, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, nrhs, ap, ipiv, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dsptrs_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dsptrs_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dsptrs_work(int matrix_layout, char uplo, int n, int nrhs, const double *ap, const int *ipiv, double *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_dsptrs_work$descriptor() {
        return LAPACKE_dsptrs_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dsptrs_work(int matrix_layout, char uplo, int n, int nrhs, const double *ap, const int *ipiv, double *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_dsptrs_work$handle() {
        return LAPACKE_dsptrs_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dsptrs_work(int matrix_layout, char uplo, int n, int nrhs, const double *ap, const int *ipiv, double *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_dsptrs_work$address() {
        return LAPACKE_dsptrs_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dsptrs_work(int matrix_layout, char uplo, int n, int nrhs, const double *ap, const int *ipiv, double *b, int ldb)
     * }
     */
    public static int LAPACKE_dsptrs_work(int matrix_layout, byte uplo, int n, int nrhs, MemorySegment ap, MemorySegment ipiv, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_dsptrs_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dsptrs_work", matrix_layout, uplo, n, nrhs, ap, ipiv, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, nrhs, ap, ipiv, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_csptrs_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_csptrs_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_csptrs_work(int matrix_layout, char uplo, int n, int nrhs, const _Complex float *ap, const int *ipiv, _Complex float *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_csptrs_work$descriptor() {
        return LAPACKE_csptrs_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_csptrs_work(int matrix_layout, char uplo, int n, int nrhs, const _Complex float *ap, const int *ipiv, _Complex float *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_csptrs_work$handle() {
        return LAPACKE_csptrs_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_csptrs_work(int matrix_layout, char uplo, int n, int nrhs, const _Complex float *ap, const int *ipiv, _Complex float *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_csptrs_work$address() {
        return LAPACKE_csptrs_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_csptrs_work(int matrix_layout, char uplo, int n, int nrhs, const _Complex float *ap, const int *ipiv, _Complex float *b, int ldb)
     * }
     */
    public static int LAPACKE_csptrs_work(int matrix_layout, byte uplo, int n, int nrhs, MemorySegment ap, MemorySegment ipiv, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_csptrs_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_csptrs_work", matrix_layout, uplo, n, nrhs, ap, ipiv, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, nrhs, ap, ipiv, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zsptrs_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zsptrs_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zsptrs_work(int matrix_layout, char uplo, int n, int nrhs, const _Complex double *ap, const int *ipiv, _Complex double *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_zsptrs_work$descriptor() {
        return LAPACKE_zsptrs_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zsptrs_work(int matrix_layout, char uplo, int n, int nrhs, const _Complex double *ap, const int *ipiv, _Complex double *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_zsptrs_work$handle() {
        return LAPACKE_zsptrs_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zsptrs_work(int matrix_layout, char uplo, int n, int nrhs, const _Complex double *ap, const int *ipiv, _Complex double *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_zsptrs_work$address() {
        return LAPACKE_zsptrs_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zsptrs_work(int matrix_layout, char uplo, int n, int nrhs, const _Complex double *ap, const int *ipiv, _Complex double *b, int ldb)
     * }
     */
    public static int LAPACKE_zsptrs_work(int matrix_layout, byte uplo, int n, int nrhs, MemorySegment ap, MemorySegment ipiv, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_zsptrs_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zsptrs_work", matrix_layout, uplo, n, nrhs, ap, ipiv, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, nrhs, ap, ipiv, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sstebz_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_FLOAT,
            lapacke_h.C_FLOAT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_FLOAT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_sstebz_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sstebz_work(char range, char order, int n, float vl, float vu, int il, int iu, float abstol, const float *d, const float *e, int *m, int *nsplit, float *w, int *iblock, int *isplit, float *work, int *iwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_sstebz_work$descriptor() {
        return LAPACKE_sstebz_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sstebz_work(char range, char order, int n, float vl, float vu, int il, int iu, float abstol, const float *d, const float *e, int *m, int *nsplit, float *w, int *iblock, int *isplit, float *work, int *iwork)
     * }
     */
    public static MethodHandle LAPACKE_sstebz_work$handle() {
        return LAPACKE_sstebz_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sstebz_work(char range, char order, int n, float vl, float vu, int il, int iu, float abstol, const float *d, const float *e, int *m, int *nsplit, float *w, int *iblock, int *isplit, float *work, int *iwork)
     * }
     */
    public static MemorySegment LAPACKE_sstebz_work$address() {
        return LAPACKE_sstebz_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sstebz_work(char range, char order, int n, float vl, float vu, int il, int iu, float abstol, const float *d, const float *e, int *m, int *nsplit, float *w, int *iblock, int *isplit, float *work, int *iwork)
     * }
     */
    public static int LAPACKE_sstebz_work(byte range, byte order, int n, float vl, float vu, int il, int iu, float abstol, MemorySegment d, MemorySegment e, MemorySegment m, MemorySegment nsplit, MemorySegment w, MemorySegment iblock, MemorySegment isplit, MemorySegment work, MemorySegment iwork) {
        var mh$ = LAPACKE_sstebz_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sstebz_work", range, order, n, vl, vu, il, iu, abstol, d, e, m, nsplit, w, iblock, isplit, work, iwork);
            }
            return (int)mh$.invokeExact(range, order, n, vl, vu, il, iu, abstol, d, e, m, nsplit, w, iblock, isplit, work, iwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dstebz_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_DOUBLE,
            lapacke_h.C_DOUBLE,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_DOUBLE,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dstebz_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dstebz_work(char range, char order, int n, double vl, double vu, int il, int iu, double abstol, const double *d, const double *e, int *m, int *nsplit, double *w, int *iblock, int *isplit, double *work, int *iwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_dstebz_work$descriptor() {
        return LAPACKE_dstebz_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dstebz_work(char range, char order, int n, double vl, double vu, int il, int iu, double abstol, const double *d, const double *e, int *m, int *nsplit, double *w, int *iblock, int *isplit, double *work, int *iwork)
     * }
     */
    public static MethodHandle LAPACKE_dstebz_work$handle() {
        return LAPACKE_dstebz_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dstebz_work(char range, char order, int n, double vl, double vu, int il, int iu, double abstol, const double *d, const double *e, int *m, int *nsplit, double *w, int *iblock, int *isplit, double *work, int *iwork)
     * }
     */
    public static MemorySegment LAPACKE_dstebz_work$address() {
        return LAPACKE_dstebz_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dstebz_work(char range, char order, int n, double vl, double vu, int il, int iu, double abstol, const double *d, const double *e, int *m, int *nsplit, double *w, int *iblock, int *isplit, double *work, int *iwork)
     * }
     */
    public static int LAPACKE_dstebz_work(byte range, byte order, int n, double vl, double vu, int il, int iu, double abstol, MemorySegment d, MemorySegment e, MemorySegment m, MemorySegment nsplit, MemorySegment w, MemorySegment iblock, MemorySegment isplit, MemorySegment work, MemorySegment iwork) {
        var mh$ = LAPACKE_dstebz_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dstebz_work", range, order, n, vl, vu, il, iu, abstol, d, e, m, nsplit, w, iblock, isplit, work, iwork);
            }
            return (int)mh$.invokeExact(range, order, n, vl, vu, il, iu, abstol, d, e, m, nsplit, w, iblock, isplit, work, iwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sstedc_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_sstedc_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sstedc_work(int matrix_layout, char compz, int n, float *d, float *e, float *z, int ldz, float *work, int lwork, int *iwork, int liwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_sstedc_work$descriptor() {
        return LAPACKE_sstedc_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sstedc_work(int matrix_layout, char compz, int n, float *d, float *e, float *z, int ldz, float *work, int lwork, int *iwork, int liwork)
     * }
     */
    public static MethodHandle LAPACKE_sstedc_work$handle() {
        return LAPACKE_sstedc_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sstedc_work(int matrix_layout, char compz, int n, float *d, float *e, float *z, int ldz, float *work, int lwork, int *iwork, int liwork)
     * }
     */
    public static MemorySegment LAPACKE_sstedc_work$address() {
        return LAPACKE_sstedc_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sstedc_work(int matrix_layout, char compz, int n, float *d, float *e, float *z, int ldz, float *work, int lwork, int *iwork, int liwork)
     * }
     */
    public static int LAPACKE_sstedc_work(int matrix_layout, byte compz, int n, MemorySegment d, MemorySegment e, MemorySegment z, int ldz, MemorySegment work, int lwork, MemorySegment iwork, int liwork) {
        var mh$ = LAPACKE_sstedc_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sstedc_work", matrix_layout, compz, n, d, e, z, ldz, work, lwork, iwork, liwork);
            }
            return (int)mh$.invokeExact(matrix_layout, compz, n, d, e, z, ldz, work, lwork, iwork, liwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dstedc_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dstedc_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dstedc_work(int matrix_layout, char compz, int n, double *d, double *e, double *z, int ldz, double *work, int lwork, int *iwork, int liwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_dstedc_work$descriptor() {
        return LAPACKE_dstedc_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dstedc_work(int matrix_layout, char compz, int n, double *d, double *e, double *z, int ldz, double *work, int lwork, int *iwork, int liwork)
     * }
     */
    public static MethodHandle LAPACKE_dstedc_work$handle() {
        return LAPACKE_dstedc_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dstedc_work(int matrix_layout, char compz, int n, double *d, double *e, double *z, int ldz, double *work, int lwork, int *iwork, int liwork)
     * }
     */
    public static MemorySegment LAPACKE_dstedc_work$address() {
        return LAPACKE_dstedc_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dstedc_work(int matrix_layout, char compz, int n, double *d, double *e, double *z, int ldz, double *work, int lwork, int *iwork, int liwork)
     * }
     */
    public static int LAPACKE_dstedc_work(int matrix_layout, byte compz, int n, MemorySegment d, MemorySegment e, MemorySegment z, int ldz, MemorySegment work, int lwork, MemorySegment iwork, int liwork) {
        var mh$ = LAPACKE_dstedc_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dstedc_work", matrix_layout, compz, n, d, e, z, ldz, work, lwork, iwork, liwork);
            }
            return (int)mh$.invokeExact(matrix_layout, compz, n, d, e, z, ldz, work, lwork, iwork, liwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cstedc_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_cstedc_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cstedc_work(int matrix_layout, char compz, int n, float *d, float *e, _Complex float *z, int ldz, _Complex float *work, int lwork, float *rwork, int lrwork, int *iwork, int liwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_cstedc_work$descriptor() {
        return LAPACKE_cstedc_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cstedc_work(int matrix_layout, char compz, int n, float *d, float *e, _Complex float *z, int ldz, _Complex float *work, int lwork, float *rwork, int lrwork, int *iwork, int liwork)
     * }
     */
    public static MethodHandle LAPACKE_cstedc_work$handle() {
        return LAPACKE_cstedc_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cstedc_work(int matrix_layout, char compz, int n, float *d, float *e, _Complex float *z, int ldz, _Complex float *work, int lwork, float *rwork, int lrwork, int *iwork, int liwork)
     * }
     */
    public static MemorySegment LAPACKE_cstedc_work$address() {
        return LAPACKE_cstedc_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cstedc_work(int matrix_layout, char compz, int n, float *d, float *e, _Complex float *z, int ldz, _Complex float *work, int lwork, float *rwork, int lrwork, int *iwork, int liwork)
     * }
     */
    public static int LAPACKE_cstedc_work(int matrix_layout, byte compz, int n, MemorySegment d, MemorySegment e, MemorySegment z, int ldz, MemorySegment work, int lwork, MemorySegment rwork, int lrwork, MemorySegment iwork, int liwork) {
        var mh$ = LAPACKE_cstedc_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cstedc_work", matrix_layout, compz, n, d, e, z, ldz, work, lwork, rwork, lrwork, iwork, liwork);
            }
            return (int)mh$.invokeExact(matrix_layout, compz, n, d, e, z, ldz, work, lwork, rwork, lrwork, iwork, liwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zstedc_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zstedc_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zstedc_work(int matrix_layout, char compz, int n, double *d, double *e, _Complex double *z, int ldz, _Complex double *work, int lwork, double *rwork, int lrwork, int *iwork, int liwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_zstedc_work$descriptor() {
        return LAPACKE_zstedc_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zstedc_work(int matrix_layout, char compz, int n, double *d, double *e, _Complex double *z, int ldz, _Complex double *work, int lwork, double *rwork, int lrwork, int *iwork, int liwork)
     * }
     */
    public static MethodHandle LAPACKE_zstedc_work$handle() {
        return LAPACKE_zstedc_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zstedc_work(int matrix_layout, char compz, int n, double *d, double *e, _Complex double *z, int ldz, _Complex double *work, int lwork, double *rwork, int lrwork, int *iwork, int liwork)
     * }
     */
    public static MemorySegment LAPACKE_zstedc_work$address() {
        return LAPACKE_zstedc_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zstedc_work(int matrix_layout, char compz, int n, double *d, double *e, _Complex double *z, int ldz, _Complex double *work, int lwork, double *rwork, int lrwork, int *iwork, int liwork)
     * }
     */
    public static int LAPACKE_zstedc_work(int matrix_layout, byte compz, int n, MemorySegment d, MemorySegment e, MemorySegment z, int ldz, MemorySegment work, int lwork, MemorySegment rwork, int lrwork, MemorySegment iwork, int liwork) {
        var mh$ = LAPACKE_zstedc_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zstedc_work", matrix_layout, compz, n, d, e, z, ldz, work, lwork, rwork, lrwork, iwork, liwork);
            }
            return (int)mh$.invokeExact(matrix_layout, compz, n, d, e, z, ldz, work, lwork, rwork, lrwork, iwork, liwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sstegr_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_FLOAT,
            lapacke_h.C_FLOAT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_FLOAT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_sstegr_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sstegr_work(int matrix_layout, char jobz, char range, int n, float *d, float *e, float vl, float vu, int il, int iu, float abstol, int *m, float *w, float *z, int ldz, int *isuppz, float *work, int lwork, int *iwork, int liwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_sstegr_work$descriptor() {
        return LAPACKE_sstegr_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sstegr_work(int matrix_layout, char jobz, char range, int n, float *d, float *e, float vl, float vu, int il, int iu, float abstol, int *m, float *w, float *z, int ldz, int *isuppz, float *work, int lwork, int *iwork, int liwork)
     * }
     */
    public static MethodHandle LAPACKE_sstegr_work$handle() {
        return LAPACKE_sstegr_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sstegr_work(int matrix_layout, char jobz, char range, int n, float *d, float *e, float vl, float vu, int il, int iu, float abstol, int *m, float *w, float *z, int ldz, int *isuppz, float *work, int lwork, int *iwork, int liwork)
     * }
     */
    public static MemorySegment LAPACKE_sstegr_work$address() {
        return LAPACKE_sstegr_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sstegr_work(int matrix_layout, char jobz, char range, int n, float *d, float *e, float vl, float vu, int il, int iu, float abstol, int *m, float *w, float *z, int ldz, int *isuppz, float *work, int lwork, int *iwork, int liwork)
     * }
     */
    public static int LAPACKE_sstegr_work(int matrix_layout, byte jobz, byte range, int n, MemorySegment d, MemorySegment e, float vl, float vu, int il, int iu, float abstol, MemorySegment m, MemorySegment w, MemorySegment z, int ldz, MemorySegment isuppz, MemorySegment work, int lwork, MemorySegment iwork, int liwork) {
        var mh$ = LAPACKE_sstegr_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sstegr_work", matrix_layout, jobz, range, n, d, e, vl, vu, il, iu, abstol, m, w, z, ldz, isuppz, work, lwork, iwork, liwork);
            }
            return (int)mh$.invokeExact(matrix_layout, jobz, range, n, d, e, vl, vu, il, iu, abstol, m, w, z, ldz, isuppz, work, lwork, iwork, liwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dstegr_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_DOUBLE,
            lapacke_h.C_DOUBLE,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_DOUBLE,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dstegr_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dstegr_work(int matrix_layout, char jobz, char range, int n, double *d, double *e, double vl, double vu, int il, int iu, double abstol, int *m, double *w, double *z, int ldz, int *isuppz, double *work, int lwork, int *iwork, int liwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_dstegr_work$descriptor() {
        return LAPACKE_dstegr_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dstegr_work(int matrix_layout, char jobz, char range, int n, double *d, double *e, double vl, double vu, int il, int iu, double abstol, int *m, double *w, double *z, int ldz, int *isuppz, double *work, int lwork, int *iwork, int liwork)
     * }
     */
    public static MethodHandle LAPACKE_dstegr_work$handle() {
        return LAPACKE_dstegr_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dstegr_work(int matrix_layout, char jobz, char range, int n, double *d, double *e, double vl, double vu, int il, int iu, double abstol, int *m, double *w, double *z, int ldz, int *isuppz, double *work, int lwork, int *iwork, int liwork)
     * }
     */
    public static MemorySegment LAPACKE_dstegr_work$address() {
        return LAPACKE_dstegr_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dstegr_work(int matrix_layout, char jobz, char range, int n, double *d, double *e, double vl, double vu, int il, int iu, double abstol, int *m, double *w, double *z, int ldz, int *isuppz, double *work, int lwork, int *iwork, int liwork)
     * }
     */
    public static int LAPACKE_dstegr_work(int matrix_layout, byte jobz, byte range, int n, MemorySegment d, MemorySegment e, double vl, double vu, int il, int iu, double abstol, MemorySegment m, MemorySegment w, MemorySegment z, int ldz, MemorySegment isuppz, MemorySegment work, int lwork, MemorySegment iwork, int liwork) {
        var mh$ = LAPACKE_dstegr_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dstegr_work", matrix_layout, jobz, range, n, d, e, vl, vu, il, iu, abstol, m, w, z, ldz, isuppz, work, lwork, iwork, liwork);
            }
            return (int)mh$.invokeExact(matrix_layout, jobz, range, n, d, e, vl, vu, il, iu, abstol, m, w, z, ldz, isuppz, work, lwork, iwork, liwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cstegr_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_FLOAT,
            lapacke_h.C_FLOAT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_FLOAT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_cstegr_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cstegr_work(int matrix_layout, char jobz, char range, int n, float *d, float *e, float vl, float vu, int il, int iu, float abstol, int *m, float *w, _Complex float *z, int ldz, int *isuppz, float *work, int lwork, int *iwork, int liwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_cstegr_work$descriptor() {
        return LAPACKE_cstegr_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cstegr_work(int matrix_layout, char jobz, char range, int n, float *d, float *e, float vl, float vu, int il, int iu, float abstol, int *m, float *w, _Complex float *z, int ldz, int *isuppz, float *work, int lwork, int *iwork, int liwork)
     * }
     */
    public static MethodHandle LAPACKE_cstegr_work$handle() {
        return LAPACKE_cstegr_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cstegr_work(int matrix_layout, char jobz, char range, int n, float *d, float *e, float vl, float vu, int il, int iu, float abstol, int *m, float *w, _Complex float *z, int ldz, int *isuppz, float *work, int lwork, int *iwork, int liwork)
     * }
     */
    public static MemorySegment LAPACKE_cstegr_work$address() {
        return LAPACKE_cstegr_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cstegr_work(int matrix_layout, char jobz, char range, int n, float *d, float *e, float vl, float vu, int il, int iu, float abstol, int *m, float *w, _Complex float *z, int ldz, int *isuppz, float *work, int lwork, int *iwork, int liwork)
     * }
     */
    public static int LAPACKE_cstegr_work(int matrix_layout, byte jobz, byte range, int n, MemorySegment d, MemorySegment e, float vl, float vu, int il, int iu, float abstol, MemorySegment m, MemorySegment w, MemorySegment z, int ldz, MemorySegment isuppz, MemorySegment work, int lwork, MemorySegment iwork, int liwork) {
        var mh$ = LAPACKE_cstegr_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cstegr_work", matrix_layout, jobz, range, n, d, e, vl, vu, il, iu, abstol, m, w, z, ldz, isuppz, work, lwork, iwork, liwork);
            }
            return (int)mh$.invokeExact(matrix_layout, jobz, range, n, d, e, vl, vu, il, iu, abstol, m, w, z, ldz, isuppz, work, lwork, iwork, liwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zstegr_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_DOUBLE,
            lapacke_h.C_DOUBLE,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_DOUBLE,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zstegr_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zstegr_work(int matrix_layout, char jobz, char range, int n, double *d, double *e, double vl, double vu, int il, int iu, double abstol, int *m, double *w, _Complex double *z, int ldz, int *isuppz, double *work, int lwork, int *iwork, int liwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_zstegr_work$descriptor() {
        return LAPACKE_zstegr_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zstegr_work(int matrix_layout, char jobz, char range, int n, double *d, double *e, double vl, double vu, int il, int iu, double abstol, int *m, double *w, _Complex double *z, int ldz, int *isuppz, double *work, int lwork, int *iwork, int liwork)
     * }
     */
    public static MethodHandle LAPACKE_zstegr_work$handle() {
        return LAPACKE_zstegr_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zstegr_work(int matrix_layout, char jobz, char range, int n, double *d, double *e, double vl, double vu, int il, int iu, double abstol, int *m, double *w, _Complex double *z, int ldz, int *isuppz, double *work, int lwork, int *iwork, int liwork)
     * }
     */
    public static MemorySegment LAPACKE_zstegr_work$address() {
        return LAPACKE_zstegr_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zstegr_work(int matrix_layout, char jobz, char range, int n, double *d, double *e, double vl, double vu, int il, int iu, double abstol, int *m, double *w, _Complex double *z, int ldz, int *isuppz, double *work, int lwork, int *iwork, int liwork)
     * }
     */
    public static int LAPACKE_zstegr_work(int matrix_layout, byte jobz, byte range, int n, MemorySegment d, MemorySegment e, double vl, double vu, int il, int iu, double abstol, MemorySegment m, MemorySegment w, MemorySegment z, int ldz, MemorySegment isuppz, MemorySegment work, int lwork, MemorySegment iwork, int liwork) {
        var mh$ = LAPACKE_zstegr_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zstegr_work", matrix_layout, jobz, range, n, d, e, vl, vu, il, iu, abstol, m, w, z, ldz, isuppz, work, lwork, iwork, liwork);
            }
            return (int)mh$.invokeExact(matrix_layout, jobz, range, n, d, e, vl, vu, il, iu, abstol, m, w, z, ldz, isuppz, work, lwork, iwork, liwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sstein_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_sstein_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sstein_work(int matrix_layout, int n, const float *d, const float *e, int m, const float *w, const int *iblock, const int *isplit, float *z, int ldz, float *work, int *iwork, int *ifailv)
     * }
     */
    public static FunctionDescriptor LAPACKE_sstein_work$descriptor() {
        return LAPACKE_sstein_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sstein_work(int matrix_layout, int n, const float *d, const float *e, int m, const float *w, const int *iblock, const int *isplit, float *z, int ldz, float *work, int *iwork, int *ifailv)
     * }
     */
    public static MethodHandle LAPACKE_sstein_work$handle() {
        return LAPACKE_sstein_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sstein_work(int matrix_layout, int n, const float *d, const float *e, int m, const float *w, const int *iblock, const int *isplit, float *z, int ldz, float *work, int *iwork, int *ifailv)
     * }
     */
    public static MemorySegment LAPACKE_sstein_work$address() {
        return LAPACKE_sstein_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sstein_work(int matrix_layout, int n, const float *d, const float *e, int m, const float *w, const int *iblock, const int *isplit, float *z, int ldz, float *work, int *iwork, int *ifailv)
     * }
     */
    public static int LAPACKE_sstein_work(int matrix_layout, int n, MemorySegment d, MemorySegment e, int m, MemorySegment w, MemorySegment iblock, MemorySegment isplit, MemorySegment z, int ldz, MemorySegment work, MemorySegment iwork, MemorySegment ifailv) {
        var mh$ = LAPACKE_sstein_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sstein_work", matrix_layout, n, d, e, m, w, iblock, isplit, z, ldz, work, iwork, ifailv);
            }
            return (int)mh$.invokeExact(matrix_layout, n, d, e, m, w, iblock, isplit, z, ldz, work, iwork, ifailv);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dstein_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dstein_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dstein_work(int matrix_layout, int n, const double *d, const double *e, int m, const double *w, const int *iblock, const int *isplit, double *z, int ldz, double *work, int *iwork, int *ifailv)
     * }
     */
    public static FunctionDescriptor LAPACKE_dstein_work$descriptor() {
        return LAPACKE_dstein_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dstein_work(int matrix_layout, int n, const double *d, const double *e, int m, const double *w, const int *iblock, const int *isplit, double *z, int ldz, double *work, int *iwork, int *ifailv)
     * }
     */
    public static MethodHandle LAPACKE_dstein_work$handle() {
        return LAPACKE_dstein_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dstein_work(int matrix_layout, int n, const double *d, const double *e, int m, const double *w, const int *iblock, const int *isplit, double *z, int ldz, double *work, int *iwork, int *ifailv)
     * }
     */
    public static MemorySegment LAPACKE_dstein_work$address() {
        return LAPACKE_dstein_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dstein_work(int matrix_layout, int n, const double *d, const double *e, int m, const double *w, const int *iblock, const int *isplit, double *z, int ldz, double *work, int *iwork, int *ifailv)
     * }
     */
    public static int LAPACKE_dstein_work(int matrix_layout, int n, MemorySegment d, MemorySegment e, int m, MemorySegment w, MemorySegment iblock, MemorySegment isplit, MemorySegment z, int ldz, MemorySegment work, MemorySegment iwork, MemorySegment ifailv) {
        var mh$ = LAPACKE_dstein_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dstein_work", matrix_layout, n, d, e, m, w, iblock, isplit, z, ldz, work, iwork, ifailv);
            }
            return (int)mh$.invokeExact(matrix_layout, n, d, e, m, w, iblock, isplit, z, ldz, work, iwork, ifailv);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cstein_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_cstein_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cstein_work(int matrix_layout, int n, const float *d, const float *e, int m, const float *w, const int *iblock, const int *isplit, _Complex float *z, int ldz, float *work, int *iwork, int *ifailv)
     * }
     */
    public static FunctionDescriptor LAPACKE_cstein_work$descriptor() {
        return LAPACKE_cstein_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cstein_work(int matrix_layout, int n, const float *d, const float *e, int m, const float *w, const int *iblock, const int *isplit, _Complex float *z, int ldz, float *work, int *iwork, int *ifailv)
     * }
     */
    public static MethodHandle LAPACKE_cstein_work$handle() {
        return LAPACKE_cstein_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cstein_work(int matrix_layout, int n, const float *d, const float *e, int m, const float *w, const int *iblock, const int *isplit, _Complex float *z, int ldz, float *work, int *iwork, int *ifailv)
     * }
     */
    public static MemorySegment LAPACKE_cstein_work$address() {
        return LAPACKE_cstein_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cstein_work(int matrix_layout, int n, const float *d, const float *e, int m, const float *w, const int *iblock, const int *isplit, _Complex float *z, int ldz, float *work, int *iwork, int *ifailv)
     * }
     */
    public static int LAPACKE_cstein_work(int matrix_layout, int n, MemorySegment d, MemorySegment e, int m, MemorySegment w, MemorySegment iblock, MemorySegment isplit, MemorySegment z, int ldz, MemorySegment work, MemorySegment iwork, MemorySegment ifailv) {
        var mh$ = LAPACKE_cstein_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cstein_work", matrix_layout, n, d, e, m, w, iblock, isplit, z, ldz, work, iwork, ifailv);
            }
            return (int)mh$.invokeExact(matrix_layout, n, d, e, m, w, iblock, isplit, z, ldz, work, iwork, ifailv);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zstein_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zstein_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zstein_work(int matrix_layout, int n, const double *d, const double *e, int m, const double *w, const int *iblock, const int *isplit, _Complex double *z, int ldz, double *work, int *iwork, int *ifailv)
     * }
     */
    public static FunctionDescriptor LAPACKE_zstein_work$descriptor() {
        return LAPACKE_zstein_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zstein_work(int matrix_layout, int n, const double *d, const double *e, int m, const double *w, const int *iblock, const int *isplit, _Complex double *z, int ldz, double *work, int *iwork, int *ifailv)
     * }
     */
    public static MethodHandle LAPACKE_zstein_work$handle() {
        return LAPACKE_zstein_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zstein_work(int matrix_layout, int n, const double *d, const double *e, int m, const double *w, const int *iblock, const int *isplit, _Complex double *z, int ldz, double *work, int *iwork, int *ifailv)
     * }
     */
    public static MemorySegment LAPACKE_zstein_work$address() {
        return LAPACKE_zstein_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zstein_work(int matrix_layout, int n, const double *d, const double *e, int m, const double *w, const int *iblock, const int *isplit, _Complex double *z, int ldz, double *work, int *iwork, int *ifailv)
     * }
     */
    public static int LAPACKE_zstein_work(int matrix_layout, int n, MemorySegment d, MemorySegment e, int m, MemorySegment w, MemorySegment iblock, MemorySegment isplit, MemorySegment z, int ldz, MemorySegment work, MemorySegment iwork, MemorySegment ifailv) {
        var mh$ = LAPACKE_zstein_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zstein_work", matrix_layout, n, d, e, m, w, iblock, isplit, z, ldz, work, iwork, ifailv);
            }
            return (int)mh$.invokeExact(matrix_layout, n, d, e, m, w, iblock, isplit, z, ldz, work, iwork, ifailv);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sstemr_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_FLOAT,
            lapacke_h.C_FLOAT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_sstemr_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sstemr_work(int matrix_layout, char jobz, char range, int n, float *d, float *e, float vl, float vu, int il, int iu, int *m, float *w, float *z, int ldz, int nzc, int *isuppz, int *tryrac, float *work, int lwork, int *iwork, int liwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_sstemr_work$descriptor() {
        return LAPACKE_sstemr_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sstemr_work(int matrix_layout, char jobz, char range, int n, float *d, float *e, float vl, float vu, int il, int iu, int *m, float *w, float *z, int ldz, int nzc, int *isuppz, int *tryrac, float *work, int lwork, int *iwork, int liwork)
     * }
     */
    public static MethodHandle LAPACKE_sstemr_work$handle() {
        return LAPACKE_sstemr_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sstemr_work(int matrix_layout, char jobz, char range, int n, float *d, float *e, float vl, float vu, int il, int iu, int *m, float *w, float *z, int ldz, int nzc, int *isuppz, int *tryrac, float *work, int lwork, int *iwork, int liwork)
     * }
     */
    public static MemorySegment LAPACKE_sstemr_work$address() {
        return LAPACKE_sstemr_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sstemr_work(int matrix_layout, char jobz, char range, int n, float *d, float *e, float vl, float vu, int il, int iu, int *m, float *w, float *z, int ldz, int nzc, int *isuppz, int *tryrac, float *work, int lwork, int *iwork, int liwork)
     * }
     */
    public static int LAPACKE_sstemr_work(int matrix_layout, byte jobz, byte range, int n, MemorySegment d, MemorySegment e, float vl, float vu, int il, int iu, MemorySegment m, MemorySegment w, MemorySegment z, int ldz, int nzc, MemorySegment isuppz, MemorySegment tryrac, MemorySegment work, int lwork, MemorySegment iwork, int liwork) {
        var mh$ = LAPACKE_sstemr_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sstemr_work", matrix_layout, jobz, range, n, d, e, vl, vu, il, iu, m, w, z, ldz, nzc, isuppz, tryrac, work, lwork, iwork, liwork);
            }
            return (int)mh$.invokeExact(matrix_layout, jobz, range, n, d, e, vl, vu, il, iu, m, w, z, ldz, nzc, isuppz, tryrac, work, lwork, iwork, liwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dstemr_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_DOUBLE,
            lapacke_h.C_DOUBLE,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dstemr_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dstemr_work(int matrix_layout, char jobz, char range, int n, double *d, double *e, double vl, double vu, int il, int iu, int *m, double *w, double *z, int ldz, int nzc, int *isuppz, int *tryrac, double *work, int lwork, int *iwork, int liwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_dstemr_work$descriptor() {
        return LAPACKE_dstemr_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dstemr_work(int matrix_layout, char jobz, char range, int n, double *d, double *e, double vl, double vu, int il, int iu, int *m, double *w, double *z, int ldz, int nzc, int *isuppz, int *tryrac, double *work, int lwork, int *iwork, int liwork)
     * }
     */
    public static MethodHandle LAPACKE_dstemr_work$handle() {
        return LAPACKE_dstemr_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dstemr_work(int matrix_layout, char jobz, char range, int n, double *d, double *e, double vl, double vu, int il, int iu, int *m, double *w, double *z, int ldz, int nzc, int *isuppz, int *tryrac, double *work, int lwork, int *iwork, int liwork)
     * }
     */
    public static MemorySegment LAPACKE_dstemr_work$address() {
        return LAPACKE_dstemr_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dstemr_work(int matrix_layout, char jobz, char range, int n, double *d, double *e, double vl, double vu, int il, int iu, int *m, double *w, double *z, int ldz, int nzc, int *isuppz, int *tryrac, double *work, int lwork, int *iwork, int liwork)
     * }
     */
    public static int LAPACKE_dstemr_work(int matrix_layout, byte jobz, byte range, int n, MemorySegment d, MemorySegment e, double vl, double vu, int il, int iu, MemorySegment m, MemorySegment w, MemorySegment z, int ldz, int nzc, MemorySegment isuppz, MemorySegment tryrac, MemorySegment work, int lwork, MemorySegment iwork, int liwork) {
        var mh$ = LAPACKE_dstemr_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dstemr_work", matrix_layout, jobz, range, n, d, e, vl, vu, il, iu, m, w, z, ldz, nzc, isuppz, tryrac, work, lwork, iwork, liwork);
            }
            return (int)mh$.invokeExact(matrix_layout, jobz, range, n, d, e, vl, vu, il, iu, m, w, z, ldz, nzc, isuppz, tryrac, work, lwork, iwork, liwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cstemr_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_FLOAT,
            lapacke_h.C_FLOAT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_cstemr_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cstemr_work(int matrix_layout, char jobz, char range, int n, float *d, float *e, float vl, float vu, int il, int iu, int *m, float *w, _Complex float *z, int ldz, int nzc, int *isuppz, int *tryrac, float *work, int lwork, int *iwork, int liwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_cstemr_work$descriptor() {
        return LAPACKE_cstemr_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cstemr_work(int matrix_layout, char jobz, char range, int n, float *d, float *e, float vl, float vu, int il, int iu, int *m, float *w, _Complex float *z, int ldz, int nzc, int *isuppz, int *tryrac, float *work, int lwork, int *iwork, int liwork)
     * }
     */
    public static MethodHandle LAPACKE_cstemr_work$handle() {
        return LAPACKE_cstemr_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cstemr_work(int matrix_layout, char jobz, char range, int n, float *d, float *e, float vl, float vu, int il, int iu, int *m, float *w, _Complex float *z, int ldz, int nzc, int *isuppz, int *tryrac, float *work, int lwork, int *iwork, int liwork)
     * }
     */
    public static MemorySegment LAPACKE_cstemr_work$address() {
        return LAPACKE_cstemr_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cstemr_work(int matrix_layout, char jobz, char range, int n, float *d, float *e, float vl, float vu, int il, int iu, int *m, float *w, _Complex float *z, int ldz, int nzc, int *isuppz, int *tryrac, float *work, int lwork, int *iwork, int liwork)
     * }
     */
    public static int LAPACKE_cstemr_work(int matrix_layout, byte jobz, byte range, int n, MemorySegment d, MemorySegment e, float vl, float vu, int il, int iu, MemorySegment m, MemorySegment w, MemorySegment z, int ldz, int nzc, MemorySegment isuppz, MemorySegment tryrac, MemorySegment work, int lwork, MemorySegment iwork, int liwork) {
        var mh$ = LAPACKE_cstemr_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cstemr_work", matrix_layout, jobz, range, n, d, e, vl, vu, il, iu, m, w, z, ldz, nzc, isuppz, tryrac, work, lwork, iwork, liwork);
            }
            return (int)mh$.invokeExact(matrix_layout, jobz, range, n, d, e, vl, vu, il, iu, m, w, z, ldz, nzc, isuppz, tryrac, work, lwork, iwork, liwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zstemr_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_DOUBLE,
            lapacke_h.C_DOUBLE,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zstemr_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zstemr_work(int matrix_layout, char jobz, char range, int n, double *d, double *e, double vl, double vu, int il, int iu, int *m, double *w, _Complex double *z, int ldz, int nzc, int *isuppz, int *tryrac, double *work, int lwork, int *iwork, int liwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_zstemr_work$descriptor() {
        return LAPACKE_zstemr_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zstemr_work(int matrix_layout, char jobz, char range, int n, double *d, double *e, double vl, double vu, int il, int iu, int *m, double *w, _Complex double *z, int ldz, int nzc, int *isuppz, int *tryrac, double *work, int lwork, int *iwork, int liwork)
     * }
     */
    public static MethodHandle LAPACKE_zstemr_work$handle() {
        return LAPACKE_zstemr_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zstemr_work(int matrix_layout, char jobz, char range, int n, double *d, double *e, double vl, double vu, int il, int iu, int *m, double *w, _Complex double *z, int ldz, int nzc, int *isuppz, int *tryrac, double *work, int lwork, int *iwork, int liwork)
     * }
     */
    public static MemorySegment LAPACKE_zstemr_work$address() {
        return LAPACKE_zstemr_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zstemr_work(int matrix_layout, char jobz, char range, int n, double *d, double *e, double vl, double vu, int il, int iu, int *m, double *w, _Complex double *z, int ldz, int nzc, int *isuppz, int *tryrac, double *work, int lwork, int *iwork, int liwork)
     * }
     */
    public static int LAPACKE_zstemr_work(int matrix_layout, byte jobz, byte range, int n, MemorySegment d, MemorySegment e, double vl, double vu, int il, int iu, MemorySegment m, MemorySegment w, MemorySegment z, int ldz, int nzc, MemorySegment isuppz, MemorySegment tryrac, MemorySegment work, int lwork, MemorySegment iwork, int liwork) {
        var mh$ = LAPACKE_zstemr_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zstemr_work", matrix_layout, jobz, range, n, d, e, vl, vu, il, iu, m, w, z, ldz, nzc, isuppz, tryrac, work, lwork, iwork, liwork);
            }
            return (int)mh$.invokeExact(matrix_layout, jobz, range, n, d, e, vl, vu, il, iu, m, w, z, ldz, nzc, isuppz, tryrac, work, lwork, iwork, liwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ssteqr_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_ssteqr_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ssteqr_work(int matrix_layout, char compz, int n, float *d, float *e, float *z, int ldz, float *work)
     * }
     */
    public static FunctionDescriptor LAPACKE_ssteqr_work$descriptor() {
        return LAPACKE_ssteqr_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ssteqr_work(int matrix_layout, char compz, int n, float *d, float *e, float *z, int ldz, float *work)
     * }
     */
    public static MethodHandle LAPACKE_ssteqr_work$handle() {
        return LAPACKE_ssteqr_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ssteqr_work(int matrix_layout, char compz, int n, float *d, float *e, float *z, int ldz, float *work)
     * }
     */
    public static MemorySegment LAPACKE_ssteqr_work$address() {
        return LAPACKE_ssteqr_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ssteqr_work(int matrix_layout, char compz, int n, float *d, float *e, float *z, int ldz, float *work)
     * }
     */
    public static int LAPACKE_ssteqr_work(int matrix_layout, byte compz, int n, MemorySegment d, MemorySegment e, MemorySegment z, int ldz, MemorySegment work) {
        var mh$ = LAPACKE_ssteqr_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ssteqr_work", matrix_layout, compz, n, d, e, z, ldz, work);
            }
            return (int)mh$.invokeExact(matrix_layout, compz, n, d, e, z, ldz, work);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dsteqr_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dsteqr_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dsteqr_work(int matrix_layout, char compz, int n, double *d, double *e, double *z, int ldz, double *work)
     * }
     */
    public static FunctionDescriptor LAPACKE_dsteqr_work$descriptor() {
        return LAPACKE_dsteqr_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dsteqr_work(int matrix_layout, char compz, int n, double *d, double *e, double *z, int ldz, double *work)
     * }
     */
    public static MethodHandle LAPACKE_dsteqr_work$handle() {
        return LAPACKE_dsteqr_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dsteqr_work(int matrix_layout, char compz, int n, double *d, double *e, double *z, int ldz, double *work)
     * }
     */
    public static MemorySegment LAPACKE_dsteqr_work$address() {
        return LAPACKE_dsteqr_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dsteqr_work(int matrix_layout, char compz, int n, double *d, double *e, double *z, int ldz, double *work)
     * }
     */
    public static int LAPACKE_dsteqr_work(int matrix_layout, byte compz, int n, MemorySegment d, MemorySegment e, MemorySegment z, int ldz, MemorySegment work) {
        var mh$ = LAPACKE_dsteqr_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dsteqr_work", matrix_layout, compz, n, d, e, z, ldz, work);
            }
            return (int)mh$.invokeExact(matrix_layout, compz, n, d, e, z, ldz, work);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_csteqr_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_csteqr_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_csteqr_work(int matrix_layout, char compz, int n, float *d, float *e, _Complex float *z, int ldz, float *work)
     * }
     */
    public static FunctionDescriptor LAPACKE_csteqr_work$descriptor() {
        return LAPACKE_csteqr_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_csteqr_work(int matrix_layout, char compz, int n, float *d, float *e, _Complex float *z, int ldz, float *work)
     * }
     */
    public static MethodHandle LAPACKE_csteqr_work$handle() {
        return LAPACKE_csteqr_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_csteqr_work(int matrix_layout, char compz, int n, float *d, float *e, _Complex float *z, int ldz, float *work)
     * }
     */
    public static MemorySegment LAPACKE_csteqr_work$address() {
        return LAPACKE_csteqr_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_csteqr_work(int matrix_layout, char compz, int n, float *d, float *e, _Complex float *z, int ldz, float *work)
     * }
     */
    public static int LAPACKE_csteqr_work(int matrix_layout, byte compz, int n, MemorySegment d, MemorySegment e, MemorySegment z, int ldz, MemorySegment work) {
        var mh$ = LAPACKE_csteqr_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_csteqr_work", matrix_layout, compz, n, d, e, z, ldz, work);
            }
            return (int)mh$.invokeExact(matrix_layout, compz, n, d, e, z, ldz, work);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zsteqr_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zsteqr_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zsteqr_work(int matrix_layout, char compz, int n, double *d, double *e, _Complex double *z, int ldz, double *work)
     * }
     */
    public static FunctionDescriptor LAPACKE_zsteqr_work$descriptor() {
        return LAPACKE_zsteqr_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zsteqr_work(int matrix_layout, char compz, int n, double *d, double *e, _Complex double *z, int ldz, double *work)
     * }
     */
    public static MethodHandle LAPACKE_zsteqr_work$handle() {
        return LAPACKE_zsteqr_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zsteqr_work(int matrix_layout, char compz, int n, double *d, double *e, _Complex double *z, int ldz, double *work)
     * }
     */
    public static MemorySegment LAPACKE_zsteqr_work$address() {
        return LAPACKE_zsteqr_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zsteqr_work(int matrix_layout, char compz, int n, double *d, double *e, _Complex double *z, int ldz, double *work)
     * }
     */
    public static int LAPACKE_zsteqr_work(int matrix_layout, byte compz, int n, MemorySegment d, MemorySegment e, MemorySegment z, int ldz, MemorySegment work) {
        var mh$ = LAPACKE_zsteqr_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zsteqr_work", matrix_layout, compz, n, d, e, z, ldz, work);
            }
            return (int)mh$.invokeExact(matrix_layout, compz, n, d, e, z, ldz, work);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ssterf_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_ssterf_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ssterf_work(int n, float *d, float *e)
     * }
     */
    public static FunctionDescriptor LAPACKE_ssterf_work$descriptor() {
        return LAPACKE_ssterf_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ssterf_work(int n, float *d, float *e)
     * }
     */
    public static MethodHandle LAPACKE_ssterf_work$handle() {
        return LAPACKE_ssterf_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ssterf_work(int n, float *d, float *e)
     * }
     */
    public static MemorySegment LAPACKE_ssterf_work$address() {
        return LAPACKE_ssterf_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ssterf_work(int n, float *d, float *e)
     * }
     */
    public static int LAPACKE_ssterf_work(int n, MemorySegment d, MemorySegment e) {
        var mh$ = LAPACKE_ssterf_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ssterf_work", n, d, e);
            }
            return (int)mh$.invokeExact(n, d, e);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dsterf_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dsterf_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dsterf_work(int n, double *d, double *e)
     * }
     */
    public static FunctionDescriptor LAPACKE_dsterf_work$descriptor() {
        return LAPACKE_dsterf_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dsterf_work(int n, double *d, double *e)
     * }
     */
    public static MethodHandle LAPACKE_dsterf_work$handle() {
        return LAPACKE_dsterf_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dsterf_work(int n, double *d, double *e)
     * }
     */
    public static MemorySegment LAPACKE_dsterf_work$address() {
        return LAPACKE_dsterf_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dsterf_work(int n, double *d, double *e)
     * }
     */
    public static int LAPACKE_dsterf_work(int n, MemorySegment d, MemorySegment e) {
        var mh$ = LAPACKE_dsterf_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dsterf_work", n, d, e);
            }
            return (int)mh$.invokeExact(n, d, e);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sstev_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_sstev_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sstev_work(int matrix_layout, char jobz, int n, float *d, float *e, float *z, int ldz, float *work)
     * }
     */
    public static FunctionDescriptor LAPACKE_sstev_work$descriptor() {
        return LAPACKE_sstev_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sstev_work(int matrix_layout, char jobz, int n, float *d, float *e, float *z, int ldz, float *work)
     * }
     */
    public static MethodHandle LAPACKE_sstev_work$handle() {
        return LAPACKE_sstev_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sstev_work(int matrix_layout, char jobz, int n, float *d, float *e, float *z, int ldz, float *work)
     * }
     */
    public static MemorySegment LAPACKE_sstev_work$address() {
        return LAPACKE_sstev_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sstev_work(int matrix_layout, char jobz, int n, float *d, float *e, float *z, int ldz, float *work)
     * }
     */
    public static int LAPACKE_sstev_work(int matrix_layout, byte jobz, int n, MemorySegment d, MemorySegment e, MemorySegment z, int ldz, MemorySegment work) {
        var mh$ = LAPACKE_sstev_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sstev_work", matrix_layout, jobz, n, d, e, z, ldz, work);
            }
            return (int)mh$.invokeExact(matrix_layout, jobz, n, d, e, z, ldz, work);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dstev_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dstev_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dstev_work(int matrix_layout, char jobz, int n, double *d, double *e, double *z, int ldz, double *work)
     * }
     */
    public static FunctionDescriptor LAPACKE_dstev_work$descriptor() {
        return LAPACKE_dstev_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dstev_work(int matrix_layout, char jobz, int n, double *d, double *e, double *z, int ldz, double *work)
     * }
     */
    public static MethodHandle LAPACKE_dstev_work$handle() {
        return LAPACKE_dstev_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dstev_work(int matrix_layout, char jobz, int n, double *d, double *e, double *z, int ldz, double *work)
     * }
     */
    public static MemorySegment LAPACKE_dstev_work$address() {
        return LAPACKE_dstev_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dstev_work(int matrix_layout, char jobz, int n, double *d, double *e, double *z, int ldz, double *work)
     * }
     */
    public static int LAPACKE_dstev_work(int matrix_layout, byte jobz, int n, MemorySegment d, MemorySegment e, MemorySegment z, int ldz, MemorySegment work) {
        var mh$ = LAPACKE_dstev_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dstev_work", matrix_layout, jobz, n, d, e, z, ldz, work);
            }
            return (int)mh$.invokeExact(matrix_layout, jobz, n, d, e, z, ldz, work);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sstevd_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_sstevd_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sstevd_work(int matrix_layout, char jobz, int n, float *d, float *e, float *z, int ldz, float *work, int lwork, int *iwork, int liwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_sstevd_work$descriptor() {
        return LAPACKE_sstevd_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sstevd_work(int matrix_layout, char jobz, int n, float *d, float *e, float *z, int ldz, float *work, int lwork, int *iwork, int liwork)
     * }
     */
    public static MethodHandle LAPACKE_sstevd_work$handle() {
        return LAPACKE_sstevd_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sstevd_work(int matrix_layout, char jobz, int n, float *d, float *e, float *z, int ldz, float *work, int lwork, int *iwork, int liwork)
     * }
     */
    public static MemorySegment LAPACKE_sstevd_work$address() {
        return LAPACKE_sstevd_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sstevd_work(int matrix_layout, char jobz, int n, float *d, float *e, float *z, int ldz, float *work, int lwork, int *iwork, int liwork)
     * }
     */
    public static int LAPACKE_sstevd_work(int matrix_layout, byte jobz, int n, MemorySegment d, MemorySegment e, MemorySegment z, int ldz, MemorySegment work, int lwork, MemorySegment iwork, int liwork) {
        var mh$ = LAPACKE_sstevd_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sstevd_work", matrix_layout, jobz, n, d, e, z, ldz, work, lwork, iwork, liwork);
            }
            return (int)mh$.invokeExact(matrix_layout, jobz, n, d, e, z, ldz, work, lwork, iwork, liwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dstevd_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dstevd_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dstevd_work(int matrix_layout, char jobz, int n, double *d, double *e, double *z, int ldz, double *work, int lwork, int *iwork, int liwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_dstevd_work$descriptor() {
        return LAPACKE_dstevd_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dstevd_work(int matrix_layout, char jobz, int n, double *d, double *e, double *z, int ldz, double *work, int lwork, int *iwork, int liwork)
     * }
     */
    public static MethodHandle LAPACKE_dstevd_work$handle() {
        return LAPACKE_dstevd_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dstevd_work(int matrix_layout, char jobz, int n, double *d, double *e, double *z, int ldz, double *work, int lwork, int *iwork, int liwork)
     * }
     */
    public static MemorySegment LAPACKE_dstevd_work$address() {
        return LAPACKE_dstevd_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dstevd_work(int matrix_layout, char jobz, int n, double *d, double *e, double *z, int ldz, double *work, int lwork, int *iwork, int liwork)
     * }
     */
    public static int LAPACKE_dstevd_work(int matrix_layout, byte jobz, int n, MemorySegment d, MemorySegment e, MemorySegment z, int ldz, MemorySegment work, int lwork, MemorySegment iwork, int liwork) {
        var mh$ = LAPACKE_dstevd_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dstevd_work", matrix_layout, jobz, n, d, e, z, ldz, work, lwork, iwork, liwork);
            }
            return (int)mh$.invokeExact(matrix_layout, jobz, n, d, e, z, ldz, work, lwork, iwork, liwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sstevr_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_FLOAT,
            lapacke_h.C_FLOAT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_FLOAT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_sstevr_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sstevr_work(int matrix_layout, char jobz, char range, int n, float *d, float *e, float vl, float vu, int il, int iu, float abstol, int *m, float *w, float *z, int ldz, int *isuppz, float *work, int lwork, int *iwork, int liwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_sstevr_work$descriptor() {
        return LAPACKE_sstevr_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sstevr_work(int matrix_layout, char jobz, char range, int n, float *d, float *e, float vl, float vu, int il, int iu, float abstol, int *m, float *w, float *z, int ldz, int *isuppz, float *work, int lwork, int *iwork, int liwork)
     * }
     */
    public static MethodHandle LAPACKE_sstevr_work$handle() {
        return LAPACKE_sstevr_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sstevr_work(int matrix_layout, char jobz, char range, int n, float *d, float *e, float vl, float vu, int il, int iu, float abstol, int *m, float *w, float *z, int ldz, int *isuppz, float *work, int lwork, int *iwork, int liwork)
     * }
     */
    public static MemorySegment LAPACKE_sstevr_work$address() {
        return LAPACKE_sstevr_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sstevr_work(int matrix_layout, char jobz, char range, int n, float *d, float *e, float vl, float vu, int il, int iu, float abstol, int *m, float *w, float *z, int ldz, int *isuppz, float *work, int lwork, int *iwork, int liwork)
     * }
     */
    public static int LAPACKE_sstevr_work(int matrix_layout, byte jobz, byte range, int n, MemorySegment d, MemorySegment e, float vl, float vu, int il, int iu, float abstol, MemorySegment m, MemorySegment w, MemorySegment z, int ldz, MemorySegment isuppz, MemorySegment work, int lwork, MemorySegment iwork, int liwork) {
        var mh$ = LAPACKE_sstevr_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sstevr_work", matrix_layout, jobz, range, n, d, e, vl, vu, il, iu, abstol, m, w, z, ldz, isuppz, work, lwork, iwork, liwork);
            }
            return (int)mh$.invokeExact(matrix_layout, jobz, range, n, d, e, vl, vu, il, iu, abstol, m, w, z, ldz, isuppz, work, lwork, iwork, liwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dstevr_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_DOUBLE,
            lapacke_h.C_DOUBLE,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_DOUBLE,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dstevr_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dstevr_work(int matrix_layout, char jobz, char range, int n, double *d, double *e, double vl, double vu, int il, int iu, double abstol, int *m, double *w, double *z, int ldz, int *isuppz, double *work, int lwork, int *iwork, int liwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_dstevr_work$descriptor() {
        return LAPACKE_dstevr_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dstevr_work(int matrix_layout, char jobz, char range, int n, double *d, double *e, double vl, double vu, int il, int iu, double abstol, int *m, double *w, double *z, int ldz, int *isuppz, double *work, int lwork, int *iwork, int liwork)
     * }
     */
    public static MethodHandle LAPACKE_dstevr_work$handle() {
        return LAPACKE_dstevr_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dstevr_work(int matrix_layout, char jobz, char range, int n, double *d, double *e, double vl, double vu, int il, int iu, double abstol, int *m, double *w, double *z, int ldz, int *isuppz, double *work, int lwork, int *iwork, int liwork)
     * }
     */
    public static MemorySegment LAPACKE_dstevr_work$address() {
        return LAPACKE_dstevr_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dstevr_work(int matrix_layout, char jobz, char range, int n, double *d, double *e, double vl, double vu, int il, int iu, double abstol, int *m, double *w, double *z, int ldz, int *isuppz, double *work, int lwork, int *iwork, int liwork)
     * }
     */
    public static int LAPACKE_dstevr_work(int matrix_layout, byte jobz, byte range, int n, MemorySegment d, MemorySegment e, double vl, double vu, int il, int iu, double abstol, MemorySegment m, MemorySegment w, MemorySegment z, int ldz, MemorySegment isuppz, MemorySegment work, int lwork, MemorySegment iwork, int liwork) {
        var mh$ = LAPACKE_dstevr_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dstevr_work", matrix_layout, jobz, range, n, d, e, vl, vu, il, iu, abstol, m, w, z, ldz, isuppz, work, lwork, iwork, liwork);
            }
            return (int)mh$.invokeExact(matrix_layout, jobz, range, n, d, e, vl, vu, il, iu, abstol, m, w, z, ldz, isuppz, work, lwork, iwork, liwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sstevx_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_FLOAT,
            lapacke_h.C_FLOAT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_FLOAT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_sstevx_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sstevx_work(int matrix_layout, char jobz, char range, int n, float *d, float *e, float vl, float vu, int il, int iu, float abstol, int *m, float *w, float *z, int ldz, float *work, int *iwork, int *ifail)
     * }
     */
    public static FunctionDescriptor LAPACKE_sstevx_work$descriptor() {
        return LAPACKE_sstevx_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sstevx_work(int matrix_layout, char jobz, char range, int n, float *d, float *e, float vl, float vu, int il, int iu, float abstol, int *m, float *w, float *z, int ldz, float *work, int *iwork, int *ifail)
     * }
     */
    public static MethodHandle LAPACKE_sstevx_work$handle() {
        return LAPACKE_sstevx_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sstevx_work(int matrix_layout, char jobz, char range, int n, float *d, float *e, float vl, float vu, int il, int iu, float abstol, int *m, float *w, float *z, int ldz, float *work, int *iwork, int *ifail)
     * }
     */
    public static MemorySegment LAPACKE_sstevx_work$address() {
        return LAPACKE_sstevx_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sstevx_work(int matrix_layout, char jobz, char range, int n, float *d, float *e, float vl, float vu, int il, int iu, float abstol, int *m, float *w, float *z, int ldz, float *work, int *iwork, int *ifail)
     * }
     */
    public static int LAPACKE_sstevx_work(int matrix_layout, byte jobz, byte range, int n, MemorySegment d, MemorySegment e, float vl, float vu, int il, int iu, float abstol, MemorySegment m, MemorySegment w, MemorySegment z, int ldz, MemorySegment work, MemorySegment iwork, MemorySegment ifail) {
        var mh$ = LAPACKE_sstevx_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sstevx_work", matrix_layout, jobz, range, n, d, e, vl, vu, il, iu, abstol, m, w, z, ldz, work, iwork, ifail);
            }
            return (int)mh$.invokeExact(matrix_layout, jobz, range, n, d, e, vl, vu, il, iu, abstol, m, w, z, ldz, work, iwork, ifail);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dstevx_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_DOUBLE,
            lapacke_h.C_DOUBLE,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_DOUBLE,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dstevx_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dstevx_work(int matrix_layout, char jobz, char range, int n, double *d, double *e, double vl, double vu, int il, int iu, double abstol, int *m, double *w, double *z, int ldz, double *work, int *iwork, int *ifail)
     * }
     */
    public static FunctionDescriptor LAPACKE_dstevx_work$descriptor() {
        return LAPACKE_dstevx_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dstevx_work(int matrix_layout, char jobz, char range, int n, double *d, double *e, double vl, double vu, int il, int iu, double abstol, int *m, double *w, double *z, int ldz, double *work, int *iwork, int *ifail)
     * }
     */
    public static MethodHandle LAPACKE_dstevx_work$handle() {
        return LAPACKE_dstevx_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dstevx_work(int matrix_layout, char jobz, char range, int n, double *d, double *e, double vl, double vu, int il, int iu, double abstol, int *m, double *w, double *z, int ldz, double *work, int *iwork, int *ifail)
     * }
     */
    public static MemorySegment LAPACKE_dstevx_work$address() {
        return LAPACKE_dstevx_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dstevx_work(int matrix_layout, char jobz, char range, int n, double *d, double *e, double vl, double vu, int il, int iu, double abstol, int *m, double *w, double *z, int ldz, double *work, int *iwork, int *ifail)
     * }
     */
    public static int LAPACKE_dstevx_work(int matrix_layout, byte jobz, byte range, int n, MemorySegment d, MemorySegment e, double vl, double vu, int il, int iu, double abstol, MemorySegment m, MemorySegment w, MemorySegment z, int ldz, MemorySegment work, MemorySegment iwork, MemorySegment ifail) {
        var mh$ = LAPACKE_dstevx_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dstevx_work", matrix_layout, jobz, range, n, d, e, vl, vu, il, iu, abstol, m, w, z, ldz, work, iwork, ifail);
            }
            return (int)mh$.invokeExact(matrix_layout, jobz, range, n, d, e, vl, vu, il, iu, abstol, m, w, z, ldz, work, iwork, ifail);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ssycon_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_FLOAT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_ssycon_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ssycon_work(int matrix_layout, char uplo, int n, const float *a, int lda, const int *ipiv, float anorm, float *rcond, float *work, int *iwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_ssycon_work$descriptor() {
        return LAPACKE_ssycon_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ssycon_work(int matrix_layout, char uplo, int n, const float *a, int lda, const int *ipiv, float anorm, float *rcond, float *work, int *iwork)
     * }
     */
    public static MethodHandle LAPACKE_ssycon_work$handle() {
        return LAPACKE_ssycon_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ssycon_work(int matrix_layout, char uplo, int n, const float *a, int lda, const int *ipiv, float anorm, float *rcond, float *work, int *iwork)
     * }
     */
    public static MemorySegment LAPACKE_ssycon_work$address() {
        return LAPACKE_ssycon_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ssycon_work(int matrix_layout, char uplo, int n, const float *a, int lda, const int *ipiv, float anorm, float *rcond, float *work, int *iwork)
     * }
     */
    public static int LAPACKE_ssycon_work(int matrix_layout, byte uplo, int n, MemorySegment a, int lda, MemorySegment ipiv, float anorm, MemorySegment rcond, MemorySegment work, MemorySegment iwork) {
        var mh$ = LAPACKE_ssycon_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ssycon_work", matrix_layout, uplo, n, a, lda, ipiv, anorm, rcond, work, iwork);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, a, lda, ipiv, anorm, rcond, work, iwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dsycon_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_DOUBLE,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dsycon_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dsycon_work(int matrix_layout, char uplo, int n, const double *a, int lda, const int *ipiv, double anorm, double *rcond, double *work, int *iwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_dsycon_work$descriptor() {
        return LAPACKE_dsycon_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dsycon_work(int matrix_layout, char uplo, int n, const double *a, int lda, const int *ipiv, double anorm, double *rcond, double *work, int *iwork)
     * }
     */
    public static MethodHandle LAPACKE_dsycon_work$handle() {
        return LAPACKE_dsycon_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dsycon_work(int matrix_layout, char uplo, int n, const double *a, int lda, const int *ipiv, double anorm, double *rcond, double *work, int *iwork)
     * }
     */
    public static MemorySegment LAPACKE_dsycon_work$address() {
        return LAPACKE_dsycon_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dsycon_work(int matrix_layout, char uplo, int n, const double *a, int lda, const int *ipiv, double anorm, double *rcond, double *work, int *iwork)
     * }
     */
    public static int LAPACKE_dsycon_work(int matrix_layout, byte uplo, int n, MemorySegment a, int lda, MemorySegment ipiv, double anorm, MemorySegment rcond, MemorySegment work, MemorySegment iwork) {
        var mh$ = LAPACKE_dsycon_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dsycon_work", matrix_layout, uplo, n, a, lda, ipiv, anorm, rcond, work, iwork);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, a, lda, ipiv, anorm, rcond, work, iwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_csycon_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_FLOAT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_csycon_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_csycon_work(int matrix_layout, char uplo, int n, const _Complex float *a, int lda, const int *ipiv, float anorm, float *rcond, _Complex float *work)
     * }
     */
    public static FunctionDescriptor LAPACKE_csycon_work$descriptor() {
        return LAPACKE_csycon_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_csycon_work(int matrix_layout, char uplo, int n, const _Complex float *a, int lda, const int *ipiv, float anorm, float *rcond, _Complex float *work)
     * }
     */
    public static MethodHandle LAPACKE_csycon_work$handle() {
        return LAPACKE_csycon_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_csycon_work(int matrix_layout, char uplo, int n, const _Complex float *a, int lda, const int *ipiv, float anorm, float *rcond, _Complex float *work)
     * }
     */
    public static MemorySegment LAPACKE_csycon_work$address() {
        return LAPACKE_csycon_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_csycon_work(int matrix_layout, char uplo, int n, const _Complex float *a, int lda, const int *ipiv, float anorm, float *rcond, _Complex float *work)
     * }
     */
    public static int LAPACKE_csycon_work(int matrix_layout, byte uplo, int n, MemorySegment a, int lda, MemorySegment ipiv, float anorm, MemorySegment rcond, MemorySegment work) {
        var mh$ = LAPACKE_csycon_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_csycon_work", matrix_layout, uplo, n, a, lda, ipiv, anorm, rcond, work);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, a, lda, ipiv, anorm, rcond, work);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zsycon_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_DOUBLE,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zsycon_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zsycon_work(int matrix_layout, char uplo, int n, const _Complex double *a, int lda, const int *ipiv, double anorm, double *rcond, _Complex double *work)
     * }
     */
    public static FunctionDescriptor LAPACKE_zsycon_work$descriptor() {
        return LAPACKE_zsycon_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zsycon_work(int matrix_layout, char uplo, int n, const _Complex double *a, int lda, const int *ipiv, double anorm, double *rcond, _Complex double *work)
     * }
     */
    public static MethodHandle LAPACKE_zsycon_work$handle() {
        return LAPACKE_zsycon_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zsycon_work(int matrix_layout, char uplo, int n, const _Complex double *a, int lda, const int *ipiv, double anorm, double *rcond, _Complex double *work)
     * }
     */
    public static MemorySegment LAPACKE_zsycon_work$address() {
        return LAPACKE_zsycon_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zsycon_work(int matrix_layout, char uplo, int n, const _Complex double *a, int lda, const int *ipiv, double anorm, double *rcond, _Complex double *work)
     * }
     */
    public static int LAPACKE_zsycon_work(int matrix_layout, byte uplo, int n, MemorySegment a, int lda, MemorySegment ipiv, double anorm, MemorySegment rcond, MemorySegment work) {
        var mh$ = LAPACKE_zsycon_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zsycon_work", matrix_layout, uplo, n, a, lda, ipiv, anorm, rcond, work);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, a, lda, ipiv, anorm, rcond, work);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ssyequb_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_ssyequb_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ssyequb_work(int matrix_layout, char uplo, int n, const float *a, int lda, float *s, float *scond, float *amax, float *work)
     * }
     */
    public static FunctionDescriptor LAPACKE_ssyequb_work$descriptor() {
        return LAPACKE_ssyequb_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ssyequb_work(int matrix_layout, char uplo, int n, const float *a, int lda, float *s, float *scond, float *amax, float *work)
     * }
     */
    public static MethodHandle LAPACKE_ssyequb_work$handle() {
        return LAPACKE_ssyequb_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ssyequb_work(int matrix_layout, char uplo, int n, const float *a, int lda, float *s, float *scond, float *amax, float *work)
     * }
     */
    public static MemorySegment LAPACKE_ssyequb_work$address() {
        return LAPACKE_ssyequb_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ssyequb_work(int matrix_layout, char uplo, int n, const float *a, int lda, float *s, float *scond, float *amax, float *work)
     * }
     */
    public static int LAPACKE_ssyequb_work(int matrix_layout, byte uplo, int n, MemorySegment a, int lda, MemorySegment s, MemorySegment scond, MemorySegment amax, MemorySegment work) {
        var mh$ = LAPACKE_ssyequb_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ssyequb_work", matrix_layout, uplo, n, a, lda, s, scond, amax, work);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, a, lda, s, scond, amax, work);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dsyequb_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dsyequb_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dsyequb_work(int matrix_layout, char uplo, int n, const double *a, int lda, double *s, double *scond, double *amax, double *work)
     * }
     */
    public static FunctionDescriptor LAPACKE_dsyequb_work$descriptor() {
        return LAPACKE_dsyequb_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dsyequb_work(int matrix_layout, char uplo, int n, const double *a, int lda, double *s, double *scond, double *amax, double *work)
     * }
     */
    public static MethodHandle LAPACKE_dsyequb_work$handle() {
        return LAPACKE_dsyequb_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dsyequb_work(int matrix_layout, char uplo, int n, const double *a, int lda, double *s, double *scond, double *amax, double *work)
     * }
     */
    public static MemorySegment LAPACKE_dsyequb_work$address() {
        return LAPACKE_dsyequb_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dsyequb_work(int matrix_layout, char uplo, int n, const double *a, int lda, double *s, double *scond, double *amax, double *work)
     * }
     */
    public static int LAPACKE_dsyequb_work(int matrix_layout, byte uplo, int n, MemorySegment a, int lda, MemorySegment s, MemorySegment scond, MemorySegment amax, MemorySegment work) {
        var mh$ = LAPACKE_dsyequb_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dsyequb_work", matrix_layout, uplo, n, a, lda, s, scond, amax, work);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, a, lda, s, scond, amax, work);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_csyequb_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_csyequb_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_csyequb_work(int matrix_layout, char uplo, int n, const _Complex float *a, int lda, float *s, float *scond, float *amax, _Complex float *work)
     * }
     */
    public static FunctionDescriptor LAPACKE_csyequb_work$descriptor() {
        return LAPACKE_csyequb_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_csyequb_work(int matrix_layout, char uplo, int n, const _Complex float *a, int lda, float *s, float *scond, float *amax, _Complex float *work)
     * }
     */
    public static MethodHandle LAPACKE_csyequb_work$handle() {
        return LAPACKE_csyequb_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_csyequb_work(int matrix_layout, char uplo, int n, const _Complex float *a, int lda, float *s, float *scond, float *amax, _Complex float *work)
     * }
     */
    public static MemorySegment LAPACKE_csyequb_work$address() {
        return LAPACKE_csyequb_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_csyequb_work(int matrix_layout, char uplo, int n, const _Complex float *a, int lda, float *s, float *scond, float *amax, _Complex float *work)
     * }
     */
    public static int LAPACKE_csyequb_work(int matrix_layout, byte uplo, int n, MemorySegment a, int lda, MemorySegment s, MemorySegment scond, MemorySegment amax, MemorySegment work) {
        var mh$ = LAPACKE_csyequb_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_csyequb_work", matrix_layout, uplo, n, a, lda, s, scond, amax, work);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, a, lda, s, scond, amax, work);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zsyequb_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zsyequb_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zsyequb_work(int matrix_layout, char uplo, int n, const _Complex double *a, int lda, double *s, double *scond, double *amax, _Complex double *work)
     * }
     */
    public static FunctionDescriptor LAPACKE_zsyequb_work$descriptor() {
        return LAPACKE_zsyequb_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zsyequb_work(int matrix_layout, char uplo, int n, const _Complex double *a, int lda, double *s, double *scond, double *amax, _Complex double *work)
     * }
     */
    public static MethodHandle LAPACKE_zsyequb_work$handle() {
        return LAPACKE_zsyequb_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zsyequb_work(int matrix_layout, char uplo, int n, const _Complex double *a, int lda, double *s, double *scond, double *amax, _Complex double *work)
     * }
     */
    public static MemorySegment LAPACKE_zsyequb_work$address() {
        return LAPACKE_zsyequb_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zsyequb_work(int matrix_layout, char uplo, int n, const _Complex double *a, int lda, double *s, double *scond, double *amax, _Complex double *work)
     * }
     */
    public static int LAPACKE_zsyequb_work(int matrix_layout, byte uplo, int n, MemorySegment a, int lda, MemorySegment s, MemorySegment scond, MemorySegment amax, MemorySegment work) {
        var mh$ = LAPACKE_zsyequb_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zsyequb_work", matrix_layout, uplo, n, a, lda, s, scond, amax, work);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, a, lda, s, scond, amax, work);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ssyev_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_ssyev_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ssyev_work(int matrix_layout, char jobz, char uplo, int n, float *a, int lda, float *w, float *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_ssyev_work$descriptor() {
        return LAPACKE_ssyev_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ssyev_work(int matrix_layout, char jobz, char uplo, int n, float *a, int lda, float *w, float *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_ssyev_work$handle() {
        return LAPACKE_ssyev_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ssyev_work(int matrix_layout, char jobz, char uplo, int n, float *a, int lda, float *w, float *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_ssyev_work$address() {
        return LAPACKE_ssyev_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ssyev_work(int matrix_layout, char jobz, char uplo, int n, float *a, int lda, float *w, float *work, int lwork)
     * }
     */
    public static int LAPACKE_ssyev_work(int matrix_layout, byte jobz, byte uplo, int n, MemorySegment a, int lda, MemorySegment w, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_ssyev_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ssyev_work", matrix_layout, jobz, uplo, n, a, lda, w, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, jobz, uplo, n, a, lda, w, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dsyev_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dsyev_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dsyev_work(int matrix_layout, char jobz, char uplo, int n, double *a, int lda, double *w, double *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_dsyev_work$descriptor() {
        return LAPACKE_dsyev_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dsyev_work(int matrix_layout, char jobz, char uplo, int n, double *a, int lda, double *w, double *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_dsyev_work$handle() {
        return LAPACKE_dsyev_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dsyev_work(int matrix_layout, char jobz, char uplo, int n, double *a, int lda, double *w, double *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_dsyev_work$address() {
        return LAPACKE_dsyev_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dsyev_work(int matrix_layout, char jobz, char uplo, int n, double *a, int lda, double *w, double *work, int lwork)
     * }
     */
    public static int LAPACKE_dsyev_work(int matrix_layout, byte jobz, byte uplo, int n, MemorySegment a, int lda, MemorySegment w, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_dsyev_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dsyev_work", matrix_layout, jobz, uplo, n, a, lda, w, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, jobz, uplo, n, a, lda, w, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ssyevd_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_ssyevd_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ssyevd_work(int matrix_layout, char jobz, char uplo, int n, float *a, int lda, float *w, float *work, int lwork, int *iwork, int liwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_ssyevd_work$descriptor() {
        return LAPACKE_ssyevd_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ssyevd_work(int matrix_layout, char jobz, char uplo, int n, float *a, int lda, float *w, float *work, int lwork, int *iwork, int liwork)
     * }
     */
    public static MethodHandle LAPACKE_ssyevd_work$handle() {
        return LAPACKE_ssyevd_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ssyevd_work(int matrix_layout, char jobz, char uplo, int n, float *a, int lda, float *w, float *work, int lwork, int *iwork, int liwork)
     * }
     */
    public static MemorySegment LAPACKE_ssyevd_work$address() {
        return LAPACKE_ssyevd_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ssyevd_work(int matrix_layout, char jobz, char uplo, int n, float *a, int lda, float *w, float *work, int lwork, int *iwork, int liwork)
     * }
     */
    public static int LAPACKE_ssyevd_work(int matrix_layout, byte jobz, byte uplo, int n, MemorySegment a, int lda, MemorySegment w, MemorySegment work, int lwork, MemorySegment iwork, int liwork) {
        var mh$ = LAPACKE_ssyevd_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ssyevd_work", matrix_layout, jobz, uplo, n, a, lda, w, work, lwork, iwork, liwork);
            }
            return (int)mh$.invokeExact(matrix_layout, jobz, uplo, n, a, lda, w, work, lwork, iwork, liwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dsyevd_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dsyevd_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dsyevd_work(int matrix_layout, char jobz, char uplo, int n, double *a, int lda, double *w, double *work, int lwork, int *iwork, int liwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_dsyevd_work$descriptor() {
        return LAPACKE_dsyevd_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dsyevd_work(int matrix_layout, char jobz, char uplo, int n, double *a, int lda, double *w, double *work, int lwork, int *iwork, int liwork)
     * }
     */
    public static MethodHandle LAPACKE_dsyevd_work$handle() {
        return LAPACKE_dsyevd_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dsyevd_work(int matrix_layout, char jobz, char uplo, int n, double *a, int lda, double *w, double *work, int lwork, int *iwork, int liwork)
     * }
     */
    public static MemorySegment LAPACKE_dsyevd_work$address() {
        return LAPACKE_dsyevd_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dsyevd_work(int matrix_layout, char jobz, char uplo, int n, double *a, int lda, double *w, double *work, int lwork, int *iwork, int liwork)
     * }
     */
    public static int LAPACKE_dsyevd_work(int matrix_layout, byte jobz, byte uplo, int n, MemorySegment a, int lda, MemorySegment w, MemorySegment work, int lwork, MemorySegment iwork, int liwork) {
        var mh$ = LAPACKE_dsyevd_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dsyevd_work", matrix_layout, jobz, uplo, n, a, lda, w, work, lwork, iwork, liwork);
            }
            return (int)mh$.invokeExact(matrix_layout, jobz, uplo, n, a, lda, w, work, lwork, iwork, liwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ssyevr_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_FLOAT,
            lapacke_h.C_FLOAT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_FLOAT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_ssyevr_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ssyevr_work(int matrix_layout, char jobz, char range, char uplo, int n, float *a, int lda, float vl, float vu, int il, int iu, float abstol, int *m, float *w, float *z, int ldz, int *isuppz, float *work, int lwork, int *iwork, int liwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_ssyevr_work$descriptor() {
        return LAPACKE_ssyevr_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ssyevr_work(int matrix_layout, char jobz, char range, char uplo, int n, float *a, int lda, float vl, float vu, int il, int iu, float abstol, int *m, float *w, float *z, int ldz, int *isuppz, float *work, int lwork, int *iwork, int liwork)
     * }
     */
    public static MethodHandle LAPACKE_ssyevr_work$handle() {
        return LAPACKE_ssyevr_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ssyevr_work(int matrix_layout, char jobz, char range, char uplo, int n, float *a, int lda, float vl, float vu, int il, int iu, float abstol, int *m, float *w, float *z, int ldz, int *isuppz, float *work, int lwork, int *iwork, int liwork)
     * }
     */
    public static MemorySegment LAPACKE_ssyevr_work$address() {
        return LAPACKE_ssyevr_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ssyevr_work(int matrix_layout, char jobz, char range, char uplo, int n, float *a, int lda, float vl, float vu, int il, int iu, float abstol, int *m, float *w, float *z, int ldz, int *isuppz, float *work, int lwork, int *iwork, int liwork)
     * }
     */
    public static int LAPACKE_ssyevr_work(int matrix_layout, byte jobz, byte range, byte uplo, int n, MemorySegment a, int lda, float vl, float vu, int il, int iu, float abstol, MemorySegment m, MemorySegment w, MemorySegment z, int ldz, MemorySegment isuppz, MemorySegment work, int lwork, MemorySegment iwork, int liwork) {
        var mh$ = LAPACKE_ssyevr_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ssyevr_work", matrix_layout, jobz, range, uplo, n, a, lda, vl, vu, il, iu, abstol, m, w, z, ldz, isuppz, work, lwork, iwork, liwork);
            }
            return (int)mh$.invokeExact(matrix_layout, jobz, range, uplo, n, a, lda, vl, vu, il, iu, abstol, m, w, z, ldz, isuppz, work, lwork, iwork, liwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dsyevr_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_DOUBLE,
            lapacke_h.C_DOUBLE,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_DOUBLE,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dsyevr_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dsyevr_work(int matrix_layout, char jobz, char range, char uplo, int n, double *a, int lda, double vl, double vu, int il, int iu, double abstol, int *m, double *w, double *z, int ldz, int *isuppz, double *work, int lwork, int *iwork, int liwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_dsyevr_work$descriptor() {
        return LAPACKE_dsyevr_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dsyevr_work(int matrix_layout, char jobz, char range, char uplo, int n, double *a, int lda, double vl, double vu, int il, int iu, double abstol, int *m, double *w, double *z, int ldz, int *isuppz, double *work, int lwork, int *iwork, int liwork)
     * }
     */
    public static MethodHandle LAPACKE_dsyevr_work$handle() {
        return LAPACKE_dsyevr_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dsyevr_work(int matrix_layout, char jobz, char range, char uplo, int n, double *a, int lda, double vl, double vu, int il, int iu, double abstol, int *m, double *w, double *z, int ldz, int *isuppz, double *work, int lwork, int *iwork, int liwork)
     * }
     */
    public static MemorySegment LAPACKE_dsyevr_work$address() {
        return LAPACKE_dsyevr_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dsyevr_work(int matrix_layout, char jobz, char range, char uplo, int n, double *a, int lda, double vl, double vu, int il, int iu, double abstol, int *m, double *w, double *z, int ldz, int *isuppz, double *work, int lwork, int *iwork, int liwork)
     * }
     */
    public static int LAPACKE_dsyevr_work(int matrix_layout, byte jobz, byte range, byte uplo, int n, MemorySegment a, int lda, double vl, double vu, int il, int iu, double abstol, MemorySegment m, MemorySegment w, MemorySegment z, int ldz, MemorySegment isuppz, MemorySegment work, int lwork, MemorySegment iwork, int liwork) {
        var mh$ = LAPACKE_dsyevr_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dsyevr_work", matrix_layout, jobz, range, uplo, n, a, lda, vl, vu, il, iu, abstol, m, w, z, ldz, isuppz, work, lwork, iwork, liwork);
            }
            return (int)mh$.invokeExact(matrix_layout, jobz, range, uplo, n, a, lda, vl, vu, il, iu, abstol, m, w, z, ldz, isuppz, work, lwork, iwork, liwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ssyevx_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_FLOAT,
            lapacke_h.C_FLOAT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_FLOAT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_ssyevx_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ssyevx_work(int matrix_layout, char jobz, char range, char uplo, int n, float *a, int lda, float vl, float vu, int il, int iu, float abstol, int *m, float *w, float *z, int ldz, float *work, int lwork, int *iwork, int *ifail)
     * }
     */
    public static FunctionDescriptor LAPACKE_ssyevx_work$descriptor() {
        return LAPACKE_ssyevx_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ssyevx_work(int matrix_layout, char jobz, char range, char uplo, int n, float *a, int lda, float vl, float vu, int il, int iu, float abstol, int *m, float *w, float *z, int ldz, float *work, int lwork, int *iwork, int *ifail)
     * }
     */
    public static MethodHandle LAPACKE_ssyevx_work$handle() {
        return LAPACKE_ssyevx_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ssyevx_work(int matrix_layout, char jobz, char range, char uplo, int n, float *a, int lda, float vl, float vu, int il, int iu, float abstol, int *m, float *w, float *z, int ldz, float *work, int lwork, int *iwork, int *ifail)
     * }
     */
    public static MemorySegment LAPACKE_ssyevx_work$address() {
        return LAPACKE_ssyevx_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ssyevx_work(int matrix_layout, char jobz, char range, char uplo, int n, float *a, int lda, float vl, float vu, int il, int iu, float abstol, int *m, float *w, float *z, int ldz, float *work, int lwork, int *iwork, int *ifail)
     * }
     */
    public static int LAPACKE_ssyevx_work(int matrix_layout, byte jobz, byte range, byte uplo, int n, MemorySegment a, int lda, float vl, float vu, int il, int iu, float abstol, MemorySegment m, MemorySegment w, MemorySegment z, int ldz, MemorySegment work, int lwork, MemorySegment iwork, MemorySegment ifail) {
        var mh$ = LAPACKE_ssyevx_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ssyevx_work", matrix_layout, jobz, range, uplo, n, a, lda, vl, vu, il, iu, abstol, m, w, z, ldz, work, lwork, iwork, ifail);
            }
            return (int)mh$.invokeExact(matrix_layout, jobz, range, uplo, n, a, lda, vl, vu, il, iu, abstol, m, w, z, ldz, work, lwork, iwork, ifail);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dsyevx_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_DOUBLE,
            lapacke_h.C_DOUBLE,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_DOUBLE,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dsyevx_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dsyevx_work(int matrix_layout, char jobz, char range, char uplo, int n, double *a, int lda, double vl, double vu, int il, int iu, double abstol, int *m, double *w, double *z, int ldz, double *work, int lwork, int *iwork, int *ifail)
     * }
     */
    public static FunctionDescriptor LAPACKE_dsyevx_work$descriptor() {
        return LAPACKE_dsyevx_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dsyevx_work(int matrix_layout, char jobz, char range, char uplo, int n, double *a, int lda, double vl, double vu, int il, int iu, double abstol, int *m, double *w, double *z, int ldz, double *work, int lwork, int *iwork, int *ifail)
     * }
     */
    public static MethodHandle LAPACKE_dsyevx_work$handle() {
        return LAPACKE_dsyevx_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dsyevx_work(int matrix_layout, char jobz, char range, char uplo, int n, double *a, int lda, double vl, double vu, int il, int iu, double abstol, int *m, double *w, double *z, int ldz, double *work, int lwork, int *iwork, int *ifail)
     * }
     */
    public static MemorySegment LAPACKE_dsyevx_work$address() {
        return LAPACKE_dsyevx_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dsyevx_work(int matrix_layout, char jobz, char range, char uplo, int n, double *a, int lda, double vl, double vu, int il, int iu, double abstol, int *m, double *w, double *z, int ldz, double *work, int lwork, int *iwork, int *ifail)
     * }
     */
    public static int LAPACKE_dsyevx_work(int matrix_layout, byte jobz, byte range, byte uplo, int n, MemorySegment a, int lda, double vl, double vu, int il, int iu, double abstol, MemorySegment m, MemorySegment w, MemorySegment z, int ldz, MemorySegment work, int lwork, MemorySegment iwork, MemorySegment ifail) {
        var mh$ = LAPACKE_dsyevx_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dsyevx_work", matrix_layout, jobz, range, uplo, n, a, lda, vl, vu, il, iu, abstol, m, w, z, ldz, work, lwork, iwork, ifail);
            }
            return (int)mh$.invokeExact(matrix_layout, jobz, range, uplo, n, a, lda, vl, vu, il, iu, abstol, m, w, z, ldz, work, lwork, iwork, ifail);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ssygst_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_ssygst_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ssygst_work(int matrix_layout, int itype, char uplo, int n, float *a, int lda, const float *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_ssygst_work$descriptor() {
        return LAPACKE_ssygst_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ssygst_work(int matrix_layout, int itype, char uplo, int n, float *a, int lda, const float *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_ssygst_work$handle() {
        return LAPACKE_ssygst_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ssygst_work(int matrix_layout, int itype, char uplo, int n, float *a, int lda, const float *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_ssygst_work$address() {
        return LAPACKE_ssygst_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ssygst_work(int matrix_layout, int itype, char uplo, int n, float *a, int lda, const float *b, int ldb)
     * }
     */
    public static int LAPACKE_ssygst_work(int matrix_layout, int itype, byte uplo, int n, MemorySegment a, int lda, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_ssygst_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ssygst_work", matrix_layout, itype, uplo, n, a, lda, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, itype, uplo, n, a, lda, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dsygst_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dsygst_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dsygst_work(int matrix_layout, int itype, char uplo, int n, double *a, int lda, const double *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_dsygst_work$descriptor() {
        return LAPACKE_dsygst_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dsygst_work(int matrix_layout, int itype, char uplo, int n, double *a, int lda, const double *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_dsygst_work$handle() {
        return LAPACKE_dsygst_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dsygst_work(int matrix_layout, int itype, char uplo, int n, double *a, int lda, const double *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_dsygst_work$address() {
        return LAPACKE_dsygst_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dsygst_work(int matrix_layout, int itype, char uplo, int n, double *a, int lda, const double *b, int ldb)
     * }
     */
    public static int LAPACKE_dsygst_work(int matrix_layout, int itype, byte uplo, int n, MemorySegment a, int lda, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_dsygst_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dsygst_work", matrix_layout, itype, uplo, n, a, lda, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, itype, uplo, n, a, lda, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ssygv_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_ssygv_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ssygv_work(int matrix_layout, int itype, char jobz, char uplo, int n, float *a, int lda, float *b, int ldb, float *w, float *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_ssygv_work$descriptor() {
        return LAPACKE_ssygv_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ssygv_work(int matrix_layout, int itype, char jobz, char uplo, int n, float *a, int lda, float *b, int ldb, float *w, float *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_ssygv_work$handle() {
        return LAPACKE_ssygv_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ssygv_work(int matrix_layout, int itype, char jobz, char uplo, int n, float *a, int lda, float *b, int ldb, float *w, float *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_ssygv_work$address() {
        return LAPACKE_ssygv_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ssygv_work(int matrix_layout, int itype, char jobz, char uplo, int n, float *a, int lda, float *b, int ldb, float *w, float *work, int lwork)
     * }
     */
    public static int LAPACKE_ssygv_work(int matrix_layout, int itype, byte jobz, byte uplo, int n, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment w, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_ssygv_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ssygv_work", matrix_layout, itype, jobz, uplo, n, a, lda, b, ldb, w, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, itype, jobz, uplo, n, a, lda, b, ldb, w, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dsygv_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dsygv_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dsygv_work(int matrix_layout, int itype, char jobz, char uplo, int n, double *a, int lda, double *b, int ldb, double *w, double *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_dsygv_work$descriptor() {
        return LAPACKE_dsygv_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dsygv_work(int matrix_layout, int itype, char jobz, char uplo, int n, double *a, int lda, double *b, int ldb, double *w, double *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_dsygv_work$handle() {
        return LAPACKE_dsygv_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dsygv_work(int matrix_layout, int itype, char jobz, char uplo, int n, double *a, int lda, double *b, int ldb, double *w, double *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_dsygv_work$address() {
        return LAPACKE_dsygv_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dsygv_work(int matrix_layout, int itype, char jobz, char uplo, int n, double *a, int lda, double *b, int ldb, double *w, double *work, int lwork)
     * }
     */
    public static int LAPACKE_dsygv_work(int matrix_layout, int itype, byte jobz, byte uplo, int n, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment w, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_dsygv_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dsygv_work", matrix_layout, itype, jobz, uplo, n, a, lda, b, ldb, w, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, itype, jobz, uplo, n, a, lda, b, ldb, w, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ssygvd_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_ssygvd_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ssygvd_work(int matrix_layout, int itype, char jobz, char uplo, int n, float *a, int lda, float *b, int ldb, float *w, float *work, int lwork, int *iwork, int liwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_ssygvd_work$descriptor() {
        return LAPACKE_ssygvd_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ssygvd_work(int matrix_layout, int itype, char jobz, char uplo, int n, float *a, int lda, float *b, int ldb, float *w, float *work, int lwork, int *iwork, int liwork)
     * }
     */
    public static MethodHandle LAPACKE_ssygvd_work$handle() {
        return LAPACKE_ssygvd_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ssygvd_work(int matrix_layout, int itype, char jobz, char uplo, int n, float *a, int lda, float *b, int ldb, float *w, float *work, int lwork, int *iwork, int liwork)
     * }
     */
    public static MemorySegment LAPACKE_ssygvd_work$address() {
        return LAPACKE_ssygvd_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ssygvd_work(int matrix_layout, int itype, char jobz, char uplo, int n, float *a, int lda, float *b, int ldb, float *w, float *work, int lwork, int *iwork, int liwork)
     * }
     */
    public static int LAPACKE_ssygvd_work(int matrix_layout, int itype, byte jobz, byte uplo, int n, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment w, MemorySegment work, int lwork, MemorySegment iwork, int liwork) {
        var mh$ = LAPACKE_ssygvd_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ssygvd_work", matrix_layout, itype, jobz, uplo, n, a, lda, b, ldb, w, work, lwork, iwork, liwork);
            }
            return (int)mh$.invokeExact(matrix_layout, itype, jobz, uplo, n, a, lda, b, ldb, w, work, lwork, iwork, liwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dsygvd_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dsygvd_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dsygvd_work(int matrix_layout, int itype, char jobz, char uplo, int n, double *a, int lda, double *b, int ldb, double *w, double *work, int lwork, int *iwork, int liwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_dsygvd_work$descriptor() {
        return LAPACKE_dsygvd_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dsygvd_work(int matrix_layout, int itype, char jobz, char uplo, int n, double *a, int lda, double *b, int ldb, double *w, double *work, int lwork, int *iwork, int liwork)
     * }
     */
    public static MethodHandle LAPACKE_dsygvd_work$handle() {
        return LAPACKE_dsygvd_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dsygvd_work(int matrix_layout, int itype, char jobz, char uplo, int n, double *a, int lda, double *b, int ldb, double *w, double *work, int lwork, int *iwork, int liwork)
     * }
     */
    public static MemorySegment LAPACKE_dsygvd_work$address() {
        return LAPACKE_dsygvd_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dsygvd_work(int matrix_layout, int itype, char jobz, char uplo, int n, double *a, int lda, double *b, int ldb, double *w, double *work, int lwork, int *iwork, int liwork)
     * }
     */
    public static int LAPACKE_dsygvd_work(int matrix_layout, int itype, byte jobz, byte uplo, int n, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment w, MemorySegment work, int lwork, MemorySegment iwork, int liwork) {
        var mh$ = LAPACKE_dsygvd_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dsygvd_work", matrix_layout, itype, jobz, uplo, n, a, lda, b, ldb, w, work, lwork, iwork, liwork);
            }
            return (int)mh$.invokeExact(matrix_layout, itype, jobz, uplo, n, a, lda, b, ldb, w, work, lwork, iwork, liwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ssygvx_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_FLOAT,
            lapacke_h.C_FLOAT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_FLOAT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_ssygvx_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ssygvx_work(int matrix_layout, int itype, char jobz, char range, char uplo, int n, float *a, int lda, float *b, int ldb, float vl, float vu, int il, int iu, float abstol, int *m, float *w, float *z, int ldz, float *work, int lwork, int *iwork, int *ifail)
     * }
     */
    public static FunctionDescriptor LAPACKE_ssygvx_work$descriptor() {
        return LAPACKE_ssygvx_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ssygvx_work(int matrix_layout, int itype, char jobz, char range, char uplo, int n, float *a, int lda, float *b, int ldb, float vl, float vu, int il, int iu, float abstol, int *m, float *w, float *z, int ldz, float *work, int lwork, int *iwork, int *ifail)
     * }
     */
    public static MethodHandle LAPACKE_ssygvx_work$handle() {
        return LAPACKE_ssygvx_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ssygvx_work(int matrix_layout, int itype, char jobz, char range, char uplo, int n, float *a, int lda, float *b, int ldb, float vl, float vu, int il, int iu, float abstol, int *m, float *w, float *z, int ldz, float *work, int lwork, int *iwork, int *ifail)
     * }
     */
    public static MemorySegment LAPACKE_ssygvx_work$address() {
        return LAPACKE_ssygvx_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ssygvx_work(int matrix_layout, int itype, char jobz, char range, char uplo, int n, float *a, int lda, float *b, int ldb, float vl, float vu, int il, int iu, float abstol, int *m, float *w, float *z, int ldz, float *work, int lwork, int *iwork, int *ifail)
     * }
     */
    public static int LAPACKE_ssygvx_work(int matrix_layout, int itype, byte jobz, byte range, byte uplo, int n, MemorySegment a, int lda, MemorySegment b, int ldb, float vl, float vu, int il, int iu, float abstol, MemorySegment m, MemorySegment w, MemorySegment z, int ldz, MemorySegment work, int lwork, MemorySegment iwork, MemorySegment ifail) {
        var mh$ = LAPACKE_ssygvx_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ssygvx_work", matrix_layout, itype, jobz, range, uplo, n, a, lda, b, ldb, vl, vu, il, iu, abstol, m, w, z, ldz, work, lwork, iwork, ifail);
            }
            return (int)mh$.invokeExact(matrix_layout, itype, jobz, range, uplo, n, a, lda, b, ldb, vl, vu, il, iu, abstol, m, w, z, ldz, work, lwork, iwork, ifail);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dsygvx_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_DOUBLE,
            lapacke_h.C_DOUBLE,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_DOUBLE,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dsygvx_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dsygvx_work(int matrix_layout, int itype, char jobz, char range, char uplo, int n, double *a, int lda, double *b, int ldb, double vl, double vu, int il, int iu, double abstol, int *m, double *w, double *z, int ldz, double *work, int lwork, int *iwork, int *ifail)
     * }
     */
    public static FunctionDescriptor LAPACKE_dsygvx_work$descriptor() {
        return LAPACKE_dsygvx_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dsygvx_work(int matrix_layout, int itype, char jobz, char range, char uplo, int n, double *a, int lda, double *b, int ldb, double vl, double vu, int il, int iu, double abstol, int *m, double *w, double *z, int ldz, double *work, int lwork, int *iwork, int *ifail)
     * }
     */
    public static MethodHandle LAPACKE_dsygvx_work$handle() {
        return LAPACKE_dsygvx_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dsygvx_work(int matrix_layout, int itype, char jobz, char range, char uplo, int n, double *a, int lda, double *b, int ldb, double vl, double vu, int il, int iu, double abstol, int *m, double *w, double *z, int ldz, double *work, int lwork, int *iwork, int *ifail)
     * }
     */
    public static MemorySegment LAPACKE_dsygvx_work$address() {
        return LAPACKE_dsygvx_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dsygvx_work(int matrix_layout, int itype, char jobz, char range, char uplo, int n, double *a, int lda, double *b, int ldb, double vl, double vu, int il, int iu, double abstol, int *m, double *w, double *z, int ldz, double *work, int lwork, int *iwork, int *ifail)
     * }
     */
    public static int LAPACKE_dsygvx_work(int matrix_layout, int itype, byte jobz, byte range, byte uplo, int n, MemorySegment a, int lda, MemorySegment b, int ldb, double vl, double vu, int il, int iu, double abstol, MemorySegment m, MemorySegment w, MemorySegment z, int ldz, MemorySegment work, int lwork, MemorySegment iwork, MemorySegment ifail) {
        var mh$ = LAPACKE_dsygvx_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dsygvx_work", matrix_layout, itype, jobz, range, uplo, n, a, lda, b, ldb, vl, vu, il, iu, abstol, m, w, z, ldz, work, lwork, iwork, ifail);
            }
            return (int)mh$.invokeExact(matrix_layout, itype, jobz, range, uplo, n, a, lda, b, ldb, vl, vu, il, iu, abstol, m, w, z, ldz, work, lwork, iwork, ifail);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ssyrfs_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_ssyrfs_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ssyrfs_work(int matrix_layout, char uplo, int n, int nrhs, const float *a, int lda, const float *af, int ldaf, const int *ipiv, const float *b, int ldb, float *x, int ldx, float *ferr, float *berr, float *work, int *iwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_ssyrfs_work$descriptor() {
        return LAPACKE_ssyrfs_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ssyrfs_work(int matrix_layout, char uplo, int n, int nrhs, const float *a, int lda, const float *af, int ldaf, const int *ipiv, const float *b, int ldb, float *x, int ldx, float *ferr, float *berr, float *work, int *iwork)
     * }
     */
    public static MethodHandle LAPACKE_ssyrfs_work$handle() {
        return LAPACKE_ssyrfs_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ssyrfs_work(int matrix_layout, char uplo, int n, int nrhs, const float *a, int lda, const float *af, int ldaf, const int *ipiv, const float *b, int ldb, float *x, int ldx, float *ferr, float *berr, float *work, int *iwork)
     * }
     */
    public static MemorySegment LAPACKE_ssyrfs_work$address() {
        return LAPACKE_ssyrfs_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ssyrfs_work(int matrix_layout, char uplo, int n, int nrhs, const float *a, int lda, const float *af, int ldaf, const int *ipiv, const float *b, int ldb, float *x, int ldx, float *ferr, float *berr, float *work, int *iwork)
     * }
     */
    public static int LAPACKE_ssyrfs_work(int matrix_layout, byte uplo, int n, int nrhs, MemorySegment a, int lda, MemorySegment af, int ldaf, MemorySegment ipiv, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment ferr, MemorySegment berr, MemorySegment work, MemorySegment iwork) {
        var mh$ = LAPACKE_ssyrfs_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ssyrfs_work", matrix_layout, uplo, n, nrhs, a, lda, af, ldaf, ipiv, b, ldb, x, ldx, ferr, berr, work, iwork);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, nrhs, a, lda, af, ldaf, ipiv, b, ldb, x, ldx, ferr, berr, work, iwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dsyrfs_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dsyrfs_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dsyrfs_work(int matrix_layout, char uplo, int n, int nrhs, const double *a, int lda, const double *af, int ldaf, const int *ipiv, const double *b, int ldb, double *x, int ldx, double *ferr, double *berr, double *work, int *iwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_dsyrfs_work$descriptor() {
        return LAPACKE_dsyrfs_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dsyrfs_work(int matrix_layout, char uplo, int n, int nrhs, const double *a, int lda, const double *af, int ldaf, const int *ipiv, const double *b, int ldb, double *x, int ldx, double *ferr, double *berr, double *work, int *iwork)
     * }
     */
    public static MethodHandle LAPACKE_dsyrfs_work$handle() {
        return LAPACKE_dsyrfs_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dsyrfs_work(int matrix_layout, char uplo, int n, int nrhs, const double *a, int lda, const double *af, int ldaf, const int *ipiv, const double *b, int ldb, double *x, int ldx, double *ferr, double *berr, double *work, int *iwork)
     * }
     */
    public static MemorySegment LAPACKE_dsyrfs_work$address() {
        return LAPACKE_dsyrfs_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dsyrfs_work(int matrix_layout, char uplo, int n, int nrhs, const double *a, int lda, const double *af, int ldaf, const int *ipiv, const double *b, int ldb, double *x, int ldx, double *ferr, double *berr, double *work, int *iwork)
     * }
     */
    public static int LAPACKE_dsyrfs_work(int matrix_layout, byte uplo, int n, int nrhs, MemorySegment a, int lda, MemorySegment af, int ldaf, MemorySegment ipiv, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment ferr, MemorySegment berr, MemorySegment work, MemorySegment iwork) {
        var mh$ = LAPACKE_dsyrfs_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dsyrfs_work", matrix_layout, uplo, n, nrhs, a, lda, af, ldaf, ipiv, b, ldb, x, ldx, ferr, berr, work, iwork);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, nrhs, a, lda, af, ldaf, ipiv, b, ldb, x, ldx, ferr, berr, work, iwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_csyrfs_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_csyrfs_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_csyrfs_work(int matrix_layout, char uplo, int n, int nrhs, const _Complex float *a, int lda, const _Complex float *af, int ldaf, const int *ipiv, const _Complex float *b, int ldb, _Complex float *x, int ldx, float *ferr, float *berr, _Complex float *work, float *rwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_csyrfs_work$descriptor() {
        return LAPACKE_csyrfs_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_csyrfs_work(int matrix_layout, char uplo, int n, int nrhs, const _Complex float *a, int lda, const _Complex float *af, int ldaf, const int *ipiv, const _Complex float *b, int ldb, _Complex float *x, int ldx, float *ferr, float *berr, _Complex float *work, float *rwork)
     * }
     */
    public static MethodHandle LAPACKE_csyrfs_work$handle() {
        return LAPACKE_csyrfs_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_csyrfs_work(int matrix_layout, char uplo, int n, int nrhs, const _Complex float *a, int lda, const _Complex float *af, int ldaf, const int *ipiv, const _Complex float *b, int ldb, _Complex float *x, int ldx, float *ferr, float *berr, _Complex float *work, float *rwork)
     * }
     */
    public static MemorySegment LAPACKE_csyrfs_work$address() {
        return LAPACKE_csyrfs_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_csyrfs_work(int matrix_layout, char uplo, int n, int nrhs, const _Complex float *a, int lda, const _Complex float *af, int ldaf, const int *ipiv, const _Complex float *b, int ldb, _Complex float *x, int ldx, float *ferr, float *berr, _Complex float *work, float *rwork)
     * }
     */
    public static int LAPACKE_csyrfs_work(int matrix_layout, byte uplo, int n, int nrhs, MemorySegment a, int lda, MemorySegment af, int ldaf, MemorySegment ipiv, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment ferr, MemorySegment berr, MemorySegment work, MemorySegment rwork) {
        var mh$ = LAPACKE_csyrfs_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_csyrfs_work", matrix_layout, uplo, n, nrhs, a, lda, af, ldaf, ipiv, b, ldb, x, ldx, ferr, berr, work, rwork);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, nrhs, a, lda, af, ldaf, ipiv, b, ldb, x, ldx, ferr, berr, work, rwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zsyrfs_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zsyrfs_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zsyrfs_work(int matrix_layout, char uplo, int n, int nrhs, const _Complex double *a, int lda, const _Complex double *af, int ldaf, const int *ipiv, const _Complex double *b, int ldb, _Complex double *x, int ldx, double *ferr, double *berr, _Complex double *work, double *rwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_zsyrfs_work$descriptor() {
        return LAPACKE_zsyrfs_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zsyrfs_work(int matrix_layout, char uplo, int n, int nrhs, const _Complex double *a, int lda, const _Complex double *af, int ldaf, const int *ipiv, const _Complex double *b, int ldb, _Complex double *x, int ldx, double *ferr, double *berr, _Complex double *work, double *rwork)
     * }
     */
    public static MethodHandle LAPACKE_zsyrfs_work$handle() {
        return LAPACKE_zsyrfs_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zsyrfs_work(int matrix_layout, char uplo, int n, int nrhs, const _Complex double *a, int lda, const _Complex double *af, int ldaf, const int *ipiv, const _Complex double *b, int ldb, _Complex double *x, int ldx, double *ferr, double *berr, _Complex double *work, double *rwork)
     * }
     */
    public static MemorySegment LAPACKE_zsyrfs_work$address() {
        return LAPACKE_zsyrfs_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zsyrfs_work(int matrix_layout, char uplo, int n, int nrhs, const _Complex double *a, int lda, const _Complex double *af, int ldaf, const int *ipiv, const _Complex double *b, int ldb, _Complex double *x, int ldx, double *ferr, double *berr, _Complex double *work, double *rwork)
     * }
     */
    public static int LAPACKE_zsyrfs_work(int matrix_layout, byte uplo, int n, int nrhs, MemorySegment a, int lda, MemorySegment af, int ldaf, MemorySegment ipiv, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment ferr, MemorySegment berr, MemorySegment work, MemorySegment rwork) {
        var mh$ = LAPACKE_zsyrfs_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zsyrfs_work", matrix_layout, uplo, n, nrhs, a, lda, af, ldaf, ipiv, b, ldb, x, ldx, ferr, berr, work, rwork);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, nrhs, a, lda, af, ldaf, ipiv, b, ldb, x, ldx, ferr, berr, work, rwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ssyrfsx_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_ssyrfsx_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ssyrfsx_work(int matrix_layout, char uplo, char equed, int n, int nrhs, const float *a, int lda, const float *af, int ldaf, const int *ipiv, const float *s, const float *b, int ldb, float *x, int ldx, float *rcond, float *berr, int n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, int nparams, float *params, float *work, int *iwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_ssyrfsx_work$descriptor() {
        return LAPACKE_ssyrfsx_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ssyrfsx_work(int matrix_layout, char uplo, char equed, int n, int nrhs, const float *a, int lda, const float *af, int ldaf, const int *ipiv, const float *s, const float *b, int ldb, float *x, int ldx, float *rcond, float *berr, int n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, int nparams, float *params, float *work, int *iwork)
     * }
     */
    public static MethodHandle LAPACKE_ssyrfsx_work$handle() {
        return LAPACKE_ssyrfsx_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ssyrfsx_work(int matrix_layout, char uplo, char equed, int n, int nrhs, const float *a, int lda, const float *af, int ldaf, const int *ipiv, const float *s, const float *b, int ldb, float *x, int ldx, float *rcond, float *berr, int n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, int nparams, float *params, float *work, int *iwork)
     * }
     */
    public static MemorySegment LAPACKE_ssyrfsx_work$address() {
        return LAPACKE_ssyrfsx_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ssyrfsx_work(int matrix_layout, char uplo, char equed, int n, int nrhs, const float *a, int lda, const float *af, int ldaf, const int *ipiv, const float *s, const float *b, int ldb, float *x, int ldx, float *rcond, float *berr, int n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, int nparams, float *params, float *work, int *iwork)
     * }
     */
    public static int LAPACKE_ssyrfsx_work(int matrix_layout, byte uplo, byte equed, int n, int nrhs, MemorySegment a, int lda, MemorySegment af, int ldaf, MemorySegment ipiv, MemorySegment s, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment rcond, MemorySegment berr, int n_err_bnds, MemorySegment err_bnds_norm, MemorySegment err_bnds_comp, int nparams, MemorySegment params, MemorySegment work, MemorySegment iwork) {
        var mh$ = LAPACKE_ssyrfsx_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ssyrfsx_work", matrix_layout, uplo, equed, n, nrhs, a, lda, af, ldaf, ipiv, s, b, ldb, x, ldx, rcond, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params, work, iwork);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, equed, n, nrhs, a, lda, af, ldaf, ipiv, s, b, ldb, x, ldx, rcond, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params, work, iwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dsyrfsx_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dsyrfsx_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dsyrfsx_work(int matrix_layout, char uplo, char equed, int n, int nrhs, const double *a, int lda, const double *af, int ldaf, const int *ipiv, const double *s, const double *b, int ldb, double *x, int ldx, double *rcond, double *berr, int n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, int nparams, double *params, double *work, int *iwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_dsyrfsx_work$descriptor() {
        return LAPACKE_dsyrfsx_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dsyrfsx_work(int matrix_layout, char uplo, char equed, int n, int nrhs, const double *a, int lda, const double *af, int ldaf, const int *ipiv, const double *s, const double *b, int ldb, double *x, int ldx, double *rcond, double *berr, int n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, int nparams, double *params, double *work, int *iwork)
     * }
     */
    public static MethodHandle LAPACKE_dsyrfsx_work$handle() {
        return LAPACKE_dsyrfsx_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dsyrfsx_work(int matrix_layout, char uplo, char equed, int n, int nrhs, const double *a, int lda, const double *af, int ldaf, const int *ipiv, const double *s, const double *b, int ldb, double *x, int ldx, double *rcond, double *berr, int n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, int nparams, double *params, double *work, int *iwork)
     * }
     */
    public static MemorySegment LAPACKE_dsyrfsx_work$address() {
        return LAPACKE_dsyrfsx_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dsyrfsx_work(int matrix_layout, char uplo, char equed, int n, int nrhs, const double *a, int lda, const double *af, int ldaf, const int *ipiv, const double *s, const double *b, int ldb, double *x, int ldx, double *rcond, double *berr, int n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, int nparams, double *params, double *work, int *iwork)
     * }
     */
    public static int LAPACKE_dsyrfsx_work(int matrix_layout, byte uplo, byte equed, int n, int nrhs, MemorySegment a, int lda, MemorySegment af, int ldaf, MemorySegment ipiv, MemorySegment s, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment rcond, MemorySegment berr, int n_err_bnds, MemorySegment err_bnds_norm, MemorySegment err_bnds_comp, int nparams, MemorySegment params, MemorySegment work, MemorySegment iwork) {
        var mh$ = LAPACKE_dsyrfsx_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dsyrfsx_work", matrix_layout, uplo, equed, n, nrhs, a, lda, af, ldaf, ipiv, s, b, ldb, x, ldx, rcond, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params, work, iwork);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, equed, n, nrhs, a, lda, af, ldaf, ipiv, s, b, ldb, x, ldx, rcond, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params, work, iwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_csyrfsx_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_csyrfsx_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_csyrfsx_work(int matrix_layout, char uplo, char equed, int n, int nrhs, const _Complex float *a, int lda, const _Complex float *af, int ldaf, const int *ipiv, const float *s, const _Complex float *b, int ldb, _Complex float *x, int ldx, float *rcond, float *berr, int n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, int nparams, float *params, _Complex float *work, float *rwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_csyrfsx_work$descriptor() {
        return LAPACKE_csyrfsx_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_csyrfsx_work(int matrix_layout, char uplo, char equed, int n, int nrhs, const _Complex float *a, int lda, const _Complex float *af, int ldaf, const int *ipiv, const float *s, const _Complex float *b, int ldb, _Complex float *x, int ldx, float *rcond, float *berr, int n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, int nparams, float *params, _Complex float *work, float *rwork)
     * }
     */
    public static MethodHandle LAPACKE_csyrfsx_work$handle() {
        return LAPACKE_csyrfsx_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_csyrfsx_work(int matrix_layout, char uplo, char equed, int n, int nrhs, const _Complex float *a, int lda, const _Complex float *af, int ldaf, const int *ipiv, const float *s, const _Complex float *b, int ldb, _Complex float *x, int ldx, float *rcond, float *berr, int n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, int nparams, float *params, _Complex float *work, float *rwork)
     * }
     */
    public static MemorySegment LAPACKE_csyrfsx_work$address() {
        return LAPACKE_csyrfsx_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_csyrfsx_work(int matrix_layout, char uplo, char equed, int n, int nrhs, const _Complex float *a, int lda, const _Complex float *af, int ldaf, const int *ipiv, const float *s, const _Complex float *b, int ldb, _Complex float *x, int ldx, float *rcond, float *berr, int n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, int nparams, float *params, _Complex float *work, float *rwork)
     * }
     */
    public static int LAPACKE_csyrfsx_work(int matrix_layout, byte uplo, byte equed, int n, int nrhs, MemorySegment a, int lda, MemorySegment af, int ldaf, MemorySegment ipiv, MemorySegment s, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment rcond, MemorySegment berr, int n_err_bnds, MemorySegment err_bnds_norm, MemorySegment err_bnds_comp, int nparams, MemorySegment params, MemorySegment work, MemorySegment rwork) {
        var mh$ = LAPACKE_csyrfsx_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_csyrfsx_work", matrix_layout, uplo, equed, n, nrhs, a, lda, af, ldaf, ipiv, s, b, ldb, x, ldx, rcond, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params, work, rwork);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, equed, n, nrhs, a, lda, af, ldaf, ipiv, s, b, ldb, x, ldx, rcond, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params, work, rwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zsyrfsx_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zsyrfsx_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zsyrfsx_work(int matrix_layout, char uplo, char equed, int n, int nrhs, const _Complex double *a, int lda, const _Complex double *af, int ldaf, const int *ipiv, const double *s, const _Complex double *b, int ldb, _Complex double *x, int ldx, double *rcond, double *berr, int n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, int nparams, double *params, _Complex double *work, double *rwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_zsyrfsx_work$descriptor() {
        return LAPACKE_zsyrfsx_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zsyrfsx_work(int matrix_layout, char uplo, char equed, int n, int nrhs, const _Complex double *a, int lda, const _Complex double *af, int ldaf, const int *ipiv, const double *s, const _Complex double *b, int ldb, _Complex double *x, int ldx, double *rcond, double *berr, int n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, int nparams, double *params, _Complex double *work, double *rwork)
     * }
     */
    public static MethodHandle LAPACKE_zsyrfsx_work$handle() {
        return LAPACKE_zsyrfsx_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zsyrfsx_work(int matrix_layout, char uplo, char equed, int n, int nrhs, const _Complex double *a, int lda, const _Complex double *af, int ldaf, const int *ipiv, const double *s, const _Complex double *b, int ldb, _Complex double *x, int ldx, double *rcond, double *berr, int n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, int nparams, double *params, _Complex double *work, double *rwork)
     * }
     */
    public static MemorySegment LAPACKE_zsyrfsx_work$address() {
        return LAPACKE_zsyrfsx_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zsyrfsx_work(int matrix_layout, char uplo, char equed, int n, int nrhs, const _Complex double *a, int lda, const _Complex double *af, int ldaf, const int *ipiv, const double *s, const _Complex double *b, int ldb, _Complex double *x, int ldx, double *rcond, double *berr, int n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, int nparams, double *params, _Complex double *work, double *rwork)
     * }
     */
    public static int LAPACKE_zsyrfsx_work(int matrix_layout, byte uplo, byte equed, int n, int nrhs, MemorySegment a, int lda, MemorySegment af, int ldaf, MemorySegment ipiv, MemorySegment s, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment rcond, MemorySegment berr, int n_err_bnds, MemorySegment err_bnds_norm, MemorySegment err_bnds_comp, int nparams, MemorySegment params, MemorySegment work, MemorySegment rwork) {
        var mh$ = LAPACKE_zsyrfsx_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zsyrfsx_work", matrix_layout, uplo, equed, n, nrhs, a, lda, af, ldaf, ipiv, s, b, ldb, x, ldx, rcond, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params, work, rwork);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, equed, n, nrhs, a, lda, af, ldaf, ipiv, s, b, ldb, x, ldx, rcond, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params, work, rwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ssysv_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_ssysv_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ssysv_work(int matrix_layout, char uplo, int n, int nrhs, float *a, int lda, int *ipiv, float *b, int ldb, float *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_ssysv_work$descriptor() {
        return LAPACKE_ssysv_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ssysv_work(int matrix_layout, char uplo, int n, int nrhs, float *a, int lda, int *ipiv, float *b, int ldb, float *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_ssysv_work$handle() {
        return LAPACKE_ssysv_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ssysv_work(int matrix_layout, char uplo, int n, int nrhs, float *a, int lda, int *ipiv, float *b, int ldb, float *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_ssysv_work$address() {
        return LAPACKE_ssysv_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ssysv_work(int matrix_layout, char uplo, int n, int nrhs, float *a, int lda, int *ipiv, float *b, int ldb, float *work, int lwork)
     * }
     */
    public static int LAPACKE_ssysv_work(int matrix_layout, byte uplo, int n, int nrhs, MemorySegment a, int lda, MemorySegment ipiv, MemorySegment b, int ldb, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_ssysv_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ssysv_work", matrix_layout, uplo, n, nrhs, a, lda, ipiv, b, ldb, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, nrhs, a, lda, ipiv, b, ldb, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dsysv_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dsysv_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dsysv_work(int matrix_layout, char uplo, int n, int nrhs, double *a, int lda, int *ipiv, double *b, int ldb, double *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_dsysv_work$descriptor() {
        return LAPACKE_dsysv_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dsysv_work(int matrix_layout, char uplo, int n, int nrhs, double *a, int lda, int *ipiv, double *b, int ldb, double *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_dsysv_work$handle() {
        return LAPACKE_dsysv_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dsysv_work(int matrix_layout, char uplo, int n, int nrhs, double *a, int lda, int *ipiv, double *b, int ldb, double *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_dsysv_work$address() {
        return LAPACKE_dsysv_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dsysv_work(int matrix_layout, char uplo, int n, int nrhs, double *a, int lda, int *ipiv, double *b, int ldb, double *work, int lwork)
     * }
     */
    public static int LAPACKE_dsysv_work(int matrix_layout, byte uplo, int n, int nrhs, MemorySegment a, int lda, MemorySegment ipiv, MemorySegment b, int ldb, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_dsysv_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dsysv_work", matrix_layout, uplo, n, nrhs, a, lda, ipiv, b, ldb, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, nrhs, a, lda, ipiv, b, ldb, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_csysv_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_csysv_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_csysv_work(int matrix_layout, char uplo, int n, int nrhs, _Complex float *a, int lda, int *ipiv, _Complex float *b, int ldb, _Complex float *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_csysv_work$descriptor() {
        return LAPACKE_csysv_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_csysv_work(int matrix_layout, char uplo, int n, int nrhs, _Complex float *a, int lda, int *ipiv, _Complex float *b, int ldb, _Complex float *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_csysv_work$handle() {
        return LAPACKE_csysv_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_csysv_work(int matrix_layout, char uplo, int n, int nrhs, _Complex float *a, int lda, int *ipiv, _Complex float *b, int ldb, _Complex float *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_csysv_work$address() {
        return LAPACKE_csysv_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_csysv_work(int matrix_layout, char uplo, int n, int nrhs, _Complex float *a, int lda, int *ipiv, _Complex float *b, int ldb, _Complex float *work, int lwork)
     * }
     */
    public static int LAPACKE_csysv_work(int matrix_layout, byte uplo, int n, int nrhs, MemorySegment a, int lda, MemorySegment ipiv, MemorySegment b, int ldb, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_csysv_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_csysv_work", matrix_layout, uplo, n, nrhs, a, lda, ipiv, b, ldb, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, nrhs, a, lda, ipiv, b, ldb, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zsysv_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zsysv_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zsysv_work(int matrix_layout, char uplo, int n, int nrhs, _Complex double *a, int lda, int *ipiv, _Complex double *b, int ldb, _Complex double *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_zsysv_work$descriptor() {
        return LAPACKE_zsysv_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zsysv_work(int matrix_layout, char uplo, int n, int nrhs, _Complex double *a, int lda, int *ipiv, _Complex double *b, int ldb, _Complex double *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_zsysv_work$handle() {
        return LAPACKE_zsysv_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zsysv_work(int matrix_layout, char uplo, int n, int nrhs, _Complex double *a, int lda, int *ipiv, _Complex double *b, int ldb, _Complex double *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_zsysv_work$address() {
        return LAPACKE_zsysv_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zsysv_work(int matrix_layout, char uplo, int n, int nrhs, _Complex double *a, int lda, int *ipiv, _Complex double *b, int ldb, _Complex double *work, int lwork)
     * }
     */
    public static int LAPACKE_zsysv_work(int matrix_layout, byte uplo, int n, int nrhs, MemorySegment a, int lda, MemorySegment ipiv, MemorySegment b, int ldb, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_zsysv_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zsysv_work", matrix_layout, uplo, n, nrhs, a, lda, ipiv, b, ldb, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, nrhs, a, lda, ipiv, b, ldb, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ssysvx_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_ssysvx_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ssysvx_work(int matrix_layout, char fact, char uplo, int n, int nrhs, const float *a, int lda, float *af, int ldaf, int *ipiv, const float *b, int ldb, float *x, int ldx, float *rcond, float *ferr, float *berr, float *work, int lwork, int *iwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_ssysvx_work$descriptor() {
        return LAPACKE_ssysvx_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ssysvx_work(int matrix_layout, char fact, char uplo, int n, int nrhs, const float *a, int lda, float *af, int ldaf, int *ipiv, const float *b, int ldb, float *x, int ldx, float *rcond, float *ferr, float *berr, float *work, int lwork, int *iwork)
     * }
     */
    public static MethodHandle LAPACKE_ssysvx_work$handle() {
        return LAPACKE_ssysvx_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ssysvx_work(int matrix_layout, char fact, char uplo, int n, int nrhs, const float *a, int lda, float *af, int ldaf, int *ipiv, const float *b, int ldb, float *x, int ldx, float *rcond, float *ferr, float *berr, float *work, int lwork, int *iwork)
     * }
     */
    public static MemorySegment LAPACKE_ssysvx_work$address() {
        return LAPACKE_ssysvx_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ssysvx_work(int matrix_layout, char fact, char uplo, int n, int nrhs, const float *a, int lda, float *af, int ldaf, int *ipiv, const float *b, int ldb, float *x, int ldx, float *rcond, float *ferr, float *berr, float *work, int lwork, int *iwork)
     * }
     */
    public static int LAPACKE_ssysvx_work(int matrix_layout, byte fact, byte uplo, int n, int nrhs, MemorySegment a, int lda, MemorySegment af, int ldaf, MemorySegment ipiv, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment rcond, MemorySegment ferr, MemorySegment berr, MemorySegment work, int lwork, MemorySegment iwork) {
        var mh$ = LAPACKE_ssysvx_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ssysvx_work", matrix_layout, fact, uplo, n, nrhs, a, lda, af, ldaf, ipiv, b, ldb, x, ldx, rcond, ferr, berr, work, lwork, iwork);
            }
            return (int)mh$.invokeExact(matrix_layout, fact, uplo, n, nrhs, a, lda, af, ldaf, ipiv, b, ldb, x, ldx, rcond, ferr, berr, work, lwork, iwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dsysvx_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dsysvx_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dsysvx_work(int matrix_layout, char fact, char uplo, int n, int nrhs, const double *a, int lda, double *af, int ldaf, int *ipiv, const double *b, int ldb, double *x, int ldx, double *rcond, double *ferr, double *berr, double *work, int lwork, int *iwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_dsysvx_work$descriptor() {
        return LAPACKE_dsysvx_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dsysvx_work(int matrix_layout, char fact, char uplo, int n, int nrhs, const double *a, int lda, double *af, int ldaf, int *ipiv, const double *b, int ldb, double *x, int ldx, double *rcond, double *ferr, double *berr, double *work, int lwork, int *iwork)
     * }
     */
    public static MethodHandle LAPACKE_dsysvx_work$handle() {
        return LAPACKE_dsysvx_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dsysvx_work(int matrix_layout, char fact, char uplo, int n, int nrhs, const double *a, int lda, double *af, int ldaf, int *ipiv, const double *b, int ldb, double *x, int ldx, double *rcond, double *ferr, double *berr, double *work, int lwork, int *iwork)
     * }
     */
    public static MemorySegment LAPACKE_dsysvx_work$address() {
        return LAPACKE_dsysvx_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dsysvx_work(int matrix_layout, char fact, char uplo, int n, int nrhs, const double *a, int lda, double *af, int ldaf, int *ipiv, const double *b, int ldb, double *x, int ldx, double *rcond, double *ferr, double *berr, double *work, int lwork, int *iwork)
     * }
     */
    public static int LAPACKE_dsysvx_work(int matrix_layout, byte fact, byte uplo, int n, int nrhs, MemorySegment a, int lda, MemorySegment af, int ldaf, MemorySegment ipiv, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment rcond, MemorySegment ferr, MemorySegment berr, MemorySegment work, int lwork, MemorySegment iwork) {
        var mh$ = LAPACKE_dsysvx_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dsysvx_work", matrix_layout, fact, uplo, n, nrhs, a, lda, af, ldaf, ipiv, b, ldb, x, ldx, rcond, ferr, berr, work, lwork, iwork);
            }
            return (int)mh$.invokeExact(matrix_layout, fact, uplo, n, nrhs, a, lda, af, ldaf, ipiv, b, ldb, x, ldx, rcond, ferr, berr, work, lwork, iwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_csysvx_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_csysvx_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_csysvx_work(int matrix_layout, char fact, char uplo, int n, int nrhs, const _Complex float *a, int lda, _Complex float *af, int ldaf, int *ipiv, const _Complex float *b, int ldb, _Complex float *x, int ldx, float *rcond, float *ferr, float *berr, _Complex float *work, int lwork, float *rwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_csysvx_work$descriptor() {
        return LAPACKE_csysvx_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_csysvx_work(int matrix_layout, char fact, char uplo, int n, int nrhs, const _Complex float *a, int lda, _Complex float *af, int ldaf, int *ipiv, const _Complex float *b, int ldb, _Complex float *x, int ldx, float *rcond, float *ferr, float *berr, _Complex float *work, int lwork, float *rwork)
     * }
     */
    public static MethodHandle LAPACKE_csysvx_work$handle() {
        return LAPACKE_csysvx_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_csysvx_work(int matrix_layout, char fact, char uplo, int n, int nrhs, const _Complex float *a, int lda, _Complex float *af, int ldaf, int *ipiv, const _Complex float *b, int ldb, _Complex float *x, int ldx, float *rcond, float *ferr, float *berr, _Complex float *work, int lwork, float *rwork)
     * }
     */
    public static MemorySegment LAPACKE_csysvx_work$address() {
        return LAPACKE_csysvx_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_csysvx_work(int matrix_layout, char fact, char uplo, int n, int nrhs, const _Complex float *a, int lda, _Complex float *af, int ldaf, int *ipiv, const _Complex float *b, int ldb, _Complex float *x, int ldx, float *rcond, float *ferr, float *berr, _Complex float *work, int lwork, float *rwork)
     * }
     */
    public static int LAPACKE_csysvx_work(int matrix_layout, byte fact, byte uplo, int n, int nrhs, MemorySegment a, int lda, MemorySegment af, int ldaf, MemorySegment ipiv, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment rcond, MemorySegment ferr, MemorySegment berr, MemorySegment work, int lwork, MemorySegment rwork) {
        var mh$ = LAPACKE_csysvx_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_csysvx_work", matrix_layout, fact, uplo, n, nrhs, a, lda, af, ldaf, ipiv, b, ldb, x, ldx, rcond, ferr, berr, work, lwork, rwork);
            }
            return (int)mh$.invokeExact(matrix_layout, fact, uplo, n, nrhs, a, lda, af, ldaf, ipiv, b, ldb, x, ldx, rcond, ferr, berr, work, lwork, rwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zsysvx_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zsysvx_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zsysvx_work(int matrix_layout, char fact, char uplo, int n, int nrhs, const _Complex double *a, int lda, _Complex double *af, int ldaf, int *ipiv, const _Complex double *b, int ldb, _Complex double *x, int ldx, double *rcond, double *ferr, double *berr, _Complex double *work, int lwork, double *rwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_zsysvx_work$descriptor() {
        return LAPACKE_zsysvx_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zsysvx_work(int matrix_layout, char fact, char uplo, int n, int nrhs, const _Complex double *a, int lda, _Complex double *af, int ldaf, int *ipiv, const _Complex double *b, int ldb, _Complex double *x, int ldx, double *rcond, double *ferr, double *berr, _Complex double *work, int lwork, double *rwork)
     * }
     */
    public static MethodHandle LAPACKE_zsysvx_work$handle() {
        return LAPACKE_zsysvx_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zsysvx_work(int matrix_layout, char fact, char uplo, int n, int nrhs, const _Complex double *a, int lda, _Complex double *af, int ldaf, int *ipiv, const _Complex double *b, int ldb, _Complex double *x, int ldx, double *rcond, double *ferr, double *berr, _Complex double *work, int lwork, double *rwork)
     * }
     */
    public static MemorySegment LAPACKE_zsysvx_work$address() {
        return LAPACKE_zsysvx_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zsysvx_work(int matrix_layout, char fact, char uplo, int n, int nrhs, const _Complex double *a, int lda, _Complex double *af, int ldaf, int *ipiv, const _Complex double *b, int ldb, _Complex double *x, int ldx, double *rcond, double *ferr, double *berr, _Complex double *work, int lwork, double *rwork)
     * }
     */
    public static int LAPACKE_zsysvx_work(int matrix_layout, byte fact, byte uplo, int n, int nrhs, MemorySegment a, int lda, MemorySegment af, int ldaf, MemorySegment ipiv, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment rcond, MemorySegment ferr, MemorySegment berr, MemorySegment work, int lwork, MemorySegment rwork) {
        var mh$ = LAPACKE_zsysvx_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zsysvx_work", matrix_layout, fact, uplo, n, nrhs, a, lda, af, ldaf, ipiv, b, ldb, x, ldx, rcond, ferr, berr, work, lwork, rwork);
            }
            return (int)mh$.invokeExact(matrix_layout, fact, uplo, n, nrhs, a, lda, af, ldaf, ipiv, b, ldb, x, ldx, rcond, ferr, berr, work, lwork, rwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ssysvxx_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_ssysvxx_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ssysvxx_work(int matrix_layout, char fact, char uplo, int n, int nrhs, float *a, int lda, float *af, int ldaf, int *ipiv, char *equed, float *s, float *b, int ldb, float *x, int ldx, float *rcond, float *rpvgrw, float *berr, int n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, int nparams, float *params, float *work, int *iwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_ssysvxx_work$descriptor() {
        return LAPACKE_ssysvxx_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ssysvxx_work(int matrix_layout, char fact, char uplo, int n, int nrhs, float *a, int lda, float *af, int ldaf, int *ipiv, char *equed, float *s, float *b, int ldb, float *x, int ldx, float *rcond, float *rpvgrw, float *berr, int n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, int nparams, float *params, float *work, int *iwork)
     * }
     */
    public static MethodHandle LAPACKE_ssysvxx_work$handle() {
        return LAPACKE_ssysvxx_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ssysvxx_work(int matrix_layout, char fact, char uplo, int n, int nrhs, float *a, int lda, float *af, int ldaf, int *ipiv, char *equed, float *s, float *b, int ldb, float *x, int ldx, float *rcond, float *rpvgrw, float *berr, int n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, int nparams, float *params, float *work, int *iwork)
     * }
     */
    public static MemorySegment LAPACKE_ssysvxx_work$address() {
        return LAPACKE_ssysvxx_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ssysvxx_work(int matrix_layout, char fact, char uplo, int n, int nrhs, float *a, int lda, float *af, int ldaf, int *ipiv, char *equed, float *s, float *b, int ldb, float *x, int ldx, float *rcond, float *rpvgrw, float *berr, int n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, int nparams, float *params, float *work, int *iwork)
     * }
     */
    public static int LAPACKE_ssysvxx_work(int matrix_layout, byte fact, byte uplo, int n, int nrhs, MemorySegment a, int lda, MemorySegment af, int ldaf, MemorySegment ipiv, MemorySegment equed, MemorySegment s, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment rcond, MemorySegment rpvgrw, MemorySegment berr, int n_err_bnds, MemorySegment err_bnds_norm, MemorySegment err_bnds_comp, int nparams, MemorySegment params, MemorySegment work, MemorySegment iwork) {
        var mh$ = LAPACKE_ssysvxx_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ssysvxx_work", matrix_layout, fact, uplo, n, nrhs, a, lda, af, ldaf, ipiv, equed, s, b, ldb, x, ldx, rcond, rpvgrw, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params, work, iwork);
            }
            return (int)mh$.invokeExact(matrix_layout, fact, uplo, n, nrhs, a, lda, af, ldaf, ipiv, equed, s, b, ldb, x, ldx, rcond, rpvgrw, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params, work, iwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dsysvxx_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dsysvxx_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dsysvxx_work(int matrix_layout, char fact, char uplo, int n, int nrhs, double *a, int lda, double *af, int ldaf, int *ipiv, char *equed, double *s, double *b, int ldb, double *x, int ldx, double *rcond, double *rpvgrw, double *berr, int n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, int nparams, double *params, double *work, int *iwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_dsysvxx_work$descriptor() {
        return LAPACKE_dsysvxx_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dsysvxx_work(int matrix_layout, char fact, char uplo, int n, int nrhs, double *a, int lda, double *af, int ldaf, int *ipiv, char *equed, double *s, double *b, int ldb, double *x, int ldx, double *rcond, double *rpvgrw, double *berr, int n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, int nparams, double *params, double *work, int *iwork)
     * }
     */
    public static MethodHandle LAPACKE_dsysvxx_work$handle() {
        return LAPACKE_dsysvxx_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dsysvxx_work(int matrix_layout, char fact, char uplo, int n, int nrhs, double *a, int lda, double *af, int ldaf, int *ipiv, char *equed, double *s, double *b, int ldb, double *x, int ldx, double *rcond, double *rpvgrw, double *berr, int n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, int nparams, double *params, double *work, int *iwork)
     * }
     */
    public static MemorySegment LAPACKE_dsysvxx_work$address() {
        return LAPACKE_dsysvxx_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dsysvxx_work(int matrix_layout, char fact, char uplo, int n, int nrhs, double *a, int lda, double *af, int ldaf, int *ipiv, char *equed, double *s, double *b, int ldb, double *x, int ldx, double *rcond, double *rpvgrw, double *berr, int n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, int nparams, double *params, double *work, int *iwork)
     * }
     */
    public static int LAPACKE_dsysvxx_work(int matrix_layout, byte fact, byte uplo, int n, int nrhs, MemorySegment a, int lda, MemorySegment af, int ldaf, MemorySegment ipiv, MemorySegment equed, MemorySegment s, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment rcond, MemorySegment rpvgrw, MemorySegment berr, int n_err_bnds, MemorySegment err_bnds_norm, MemorySegment err_bnds_comp, int nparams, MemorySegment params, MemorySegment work, MemorySegment iwork) {
        var mh$ = LAPACKE_dsysvxx_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dsysvxx_work", matrix_layout, fact, uplo, n, nrhs, a, lda, af, ldaf, ipiv, equed, s, b, ldb, x, ldx, rcond, rpvgrw, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params, work, iwork);
            }
            return (int)mh$.invokeExact(matrix_layout, fact, uplo, n, nrhs, a, lda, af, ldaf, ipiv, equed, s, b, ldb, x, ldx, rcond, rpvgrw, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params, work, iwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_csysvxx_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_csysvxx_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_csysvxx_work(int matrix_layout, char fact, char uplo, int n, int nrhs, _Complex float *a, int lda, _Complex float *af, int ldaf, int *ipiv, char *equed, float *s, _Complex float *b, int ldb, _Complex float *x, int ldx, float *rcond, float *rpvgrw, float *berr, int n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, int nparams, float *params, _Complex float *work, float *rwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_csysvxx_work$descriptor() {
        return LAPACKE_csysvxx_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_csysvxx_work(int matrix_layout, char fact, char uplo, int n, int nrhs, _Complex float *a, int lda, _Complex float *af, int ldaf, int *ipiv, char *equed, float *s, _Complex float *b, int ldb, _Complex float *x, int ldx, float *rcond, float *rpvgrw, float *berr, int n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, int nparams, float *params, _Complex float *work, float *rwork)
     * }
     */
    public static MethodHandle LAPACKE_csysvxx_work$handle() {
        return LAPACKE_csysvxx_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_csysvxx_work(int matrix_layout, char fact, char uplo, int n, int nrhs, _Complex float *a, int lda, _Complex float *af, int ldaf, int *ipiv, char *equed, float *s, _Complex float *b, int ldb, _Complex float *x, int ldx, float *rcond, float *rpvgrw, float *berr, int n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, int nparams, float *params, _Complex float *work, float *rwork)
     * }
     */
    public static MemorySegment LAPACKE_csysvxx_work$address() {
        return LAPACKE_csysvxx_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_csysvxx_work(int matrix_layout, char fact, char uplo, int n, int nrhs, _Complex float *a, int lda, _Complex float *af, int ldaf, int *ipiv, char *equed, float *s, _Complex float *b, int ldb, _Complex float *x, int ldx, float *rcond, float *rpvgrw, float *berr, int n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, int nparams, float *params, _Complex float *work, float *rwork)
     * }
     */
    public static int LAPACKE_csysvxx_work(int matrix_layout, byte fact, byte uplo, int n, int nrhs, MemorySegment a, int lda, MemorySegment af, int ldaf, MemorySegment ipiv, MemorySegment equed, MemorySegment s, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment rcond, MemorySegment rpvgrw, MemorySegment berr, int n_err_bnds, MemorySegment err_bnds_norm, MemorySegment err_bnds_comp, int nparams, MemorySegment params, MemorySegment work, MemorySegment rwork) {
        var mh$ = LAPACKE_csysvxx_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_csysvxx_work", matrix_layout, fact, uplo, n, nrhs, a, lda, af, ldaf, ipiv, equed, s, b, ldb, x, ldx, rcond, rpvgrw, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params, work, rwork);
            }
            return (int)mh$.invokeExact(matrix_layout, fact, uplo, n, nrhs, a, lda, af, ldaf, ipiv, equed, s, b, ldb, x, ldx, rcond, rpvgrw, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params, work, rwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zsysvxx_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zsysvxx_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zsysvxx_work(int matrix_layout, char fact, char uplo, int n, int nrhs, _Complex double *a, int lda, _Complex double *af, int ldaf, int *ipiv, char *equed, double *s, _Complex double *b, int ldb, _Complex double *x, int ldx, double *rcond, double *rpvgrw, double *berr, int n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, int nparams, double *params, _Complex double *work, double *rwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_zsysvxx_work$descriptor() {
        return LAPACKE_zsysvxx_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zsysvxx_work(int matrix_layout, char fact, char uplo, int n, int nrhs, _Complex double *a, int lda, _Complex double *af, int ldaf, int *ipiv, char *equed, double *s, _Complex double *b, int ldb, _Complex double *x, int ldx, double *rcond, double *rpvgrw, double *berr, int n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, int nparams, double *params, _Complex double *work, double *rwork)
     * }
     */
    public static MethodHandle LAPACKE_zsysvxx_work$handle() {
        return LAPACKE_zsysvxx_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zsysvxx_work(int matrix_layout, char fact, char uplo, int n, int nrhs, _Complex double *a, int lda, _Complex double *af, int ldaf, int *ipiv, char *equed, double *s, _Complex double *b, int ldb, _Complex double *x, int ldx, double *rcond, double *rpvgrw, double *berr, int n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, int nparams, double *params, _Complex double *work, double *rwork)
     * }
     */
    public static MemorySegment LAPACKE_zsysvxx_work$address() {
        return LAPACKE_zsysvxx_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zsysvxx_work(int matrix_layout, char fact, char uplo, int n, int nrhs, _Complex double *a, int lda, _Complex double *af, int ldaf, int *ipiv, char *equed, double *s, _Complex double *b, int ldb, _Complex double *x, int ldx, double *rcond, double *rpvgrw, double *berr, int n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, int nparams, double *params, _Complex double *work, double *rwork)
     * }
     */
    public static int LAPACKE_zsysvxx_work(int matrix_layout, byte fact, byte uplo, int n, int nrhs, MemorySegment a, int lda, MemorySegment af, int ldaf, MemorySegment ipiv, MemorySegment equed, MemorySegment s, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment rcond, MemorySegment rpvgrw, MemorySegment berr, int n_err_bnds, MemorySegment err_bnds_norm, MemorySegment err_bnds_comp, int nparams, MemorySegment params, MemorySegment work, MemorySegment rwork) {
        var mh$ = LAPACKE_zsysvxx_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zsysvxx_work", matrix_layout, fact, uplo, n, nrhs, a, lda, af, ldaf, ipiv, equed, s, b, ldb, x, ldx, rcond, rpvgrw, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params, work, rwork);
            }
            return (int)mh$.invokeExact(matrix_layout, fact, uplo, n, nrhs, a, lda, af, ldaf, ipiv, equed, s, b, ldb, x, ldx, rcond, rpvgrw, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params, work, rwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ssytrd_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_ssytrd_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ssytrd_work(int matrix_layout, char uplo, int n, float *a, int lda, float *d, float *e, float *tau, float *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_ssytrd_work$descriptor() {
        return LAPACKE_ssytrd_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ssytrd_work(int matrix_layout, char uplo, int n, float *a, int lda, float *d, float *e, float *tau, float *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_ssytrd_work$handle() {
        return LAPACKE_ssytrd_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ssytrd_work(int matrix_layout, char uplo, int n, float *a, int lda, float *d, float *e, float *tau, float *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_ssytrd_work$address() {
        return LAPACKE_ssytrd_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ssytrd_work(int matrix_layout, char uplo, int n, float *a, int lda, float *d, float *e, float *tau, float *work, int lwork)
     * }
     */
    public static int LAPACKE_ssytrd_work(int matrix_layout, byte uplo, int n, MemorySegment a, int lda, MemorySegment d, MemorySegment e, MemorySegment tau, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_ssytrd_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ssytrd_work", matrix_layout, uplo, n, a, lda, d, e, tau, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, a, lda, d, e, tau, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dsytrd_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dsytrd_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dsytrd_work(int matrix_layout, char uplo, int n, double *a, int lda, double *d, double *e, double *tau, double *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_dsytrd_work$descriptor() {
        return LAPACKE_dsytrd_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dsytrd_work(int matrix_layout, char uplo, int n, double *a, int lda, double *d, double *e, double *tau, double *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_dsytrd_work$handle() {
        return LAPACKE_dsytrd_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dsytrd_work(int matrix_layout, char uplo, int n, double *a, int lda, double *d, double *e, double *tau, double *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_dsytrd_work$address() {
        return LAPACKE_dsytrd_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dsytrd_work(int matrix_layout, char uplo, int n, double *a, int lda, double *d, double *e, double *tau, double *work, int lwork)
     * }
     */
    public static int LAPACKE_dsytrd_work(int matrix_layout, byte uplo, int n, MemorySegment a, int lda, MemorySegment d, MemorySegment e, MemorySegment tau, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_dsytrd_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dsytrd_work", matrix_layout, uplo, n, a, lda, d, e, tau, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, a, lda, d, e, tau, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ssytrf_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_ssytrf_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ssytrf_work(int matrix_layout, char uplo, int n, float *a, int lda, int *ipiv, float *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_ssytrf_work$descriptor() {
        return LAPACKE_ssytrf_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ssytrf_work(int matrix_layout, char uplo, int n, float *a, int lda, int *ipiv, float *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_ssytrf_work$handle() {
        return LAPACKE_ssytrf_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ssytrf_work(int matrix_layout, char uplo, int n, float *a, int lda, int *ipiv, float *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_ssytrf_work$address() {
        return LAPACKE_ssytrf_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ssytrf_work(int matrix_layout, char uplo, int n, float *a, int lda, int *ipiv, float *work, int lwork)
     * }
     */
    public static int LAPACKE_ssytrf_work(int matrix_layout, byte uplo, int n, MemorySegment a, int lda, MemorySegment ipiv, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_ssytrf_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ssytrf_work", matrix_layout, uplo, n, a, lda, ipiv, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, a, lda, ipiv, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dsytrf_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dsytrf_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dsytrf_work(int matrix_layout, char uplo, int n, double *a, int lda, int *ipiv, double *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_dsytrf_work$descriptor() {
        return LAPACKE_dsytrf_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dsytrf_work(int matrix_layout, char uplo, int n, double *a, int lda, int *ipiv, double *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_dsytrf_work$handle() {
        return LAPACKE_dsytrf_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dsytrf_work(int matrix_layout, char uplo, int n, double *a, int lda, int *ipiv, double *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_dsytrf_work$address() {
        return LAPACKE_dsytrf_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dsytrf_work(int matrix_layout, char uplo, int n, double *a, int lda, int *ipiv, double *work, int lwork)
     * }
     */
    public static int LAPACKE_dsytrf_work(int matrix_layout, byte uplo, int n, MemorySegment a, int lda, MemorySegment ipiv, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_dsytrf_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dsytrf_work", matrix_layout, uplo, n, a, lda, ipiv, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, a, lda, ipiv, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_csytrf_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_csytrf_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_csytrf_work(int matrix_layout, char uplo, int n, _Complex float *a, int lda, int *ipiv, _Complex float *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_csytrf_work$descriptor() {
        return LAPACKE_csytrf_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_csytrf_work(int matrix_layout, char uplo, int n, _Complex float *a, int lda, int *ipiv, _Complex float *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_csytrf_work$handle() {
        return LAPACKE_csytrf_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_csytrf_work(int matrix_layout, char uplo, int n, _Complex float *a, int lda, int *ipiv, _Complex float *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_csytrf_work$address() {
        return LAPACKE_csytrf_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_csytrf_work(int matrix_layout, char uplo, int n, _Complex float *a, int lda, int *ipiv, _Complex float *work, int lwork)
     * }
     */
    public static int LAPACKE_csytrf_work(int matrix_layout, byte uplo, int n, MemorySegment a, int lda, MemorySegment ipiv, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_csytrf_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_csytrf_work", matrix_layout, uplo, n, a, lda, ipiv, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, a, lda, ipiv, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zsytrf_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zsytrf_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zsytrf_work(int matrix_layout, char uplo, int n, _Complex double *a, int lda, int *ipiv, _Complex double *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_zsytrf_work$descriptor() {
        return LAPACKE_zsytrf_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zsytrf_work(int matrix_layout, char uplo, int n, _Complex double *a, int lda, int *ipiv, _Complex double *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_zsytrf_work$handle() {
        return LAPACKE_zsytrf_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zsytrf_work(int matrix_layout, char uplo, int n, _Complex double *a, int lda, int *ipiv, _Complex double *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_zsytrf_work$address() {
        return LAPACKE_zsytrf_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zsytrf_work(int matrix_layout, char uplo, int n, _Complex double *a, int lda, int *ipiv, _Complex double *work, int lwork)
     * }
     */
    public static int LAPACKE_zsytrf_work(int matrix_layout, byte uplo, int n, MemorySegment a, int lda, MemorySegment ipiv, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_zsytrf_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zsytrf_work", matrix_layout, uplo, n, a, lda, ipiv, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, a, lda, ipiv, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ssytri_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_ssytri_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ssytri_work(int matrix_layout, char uplo, int n, float *a, int lda, const int *ipiv, float *work)
     * }
     */
    public static FunctionDescriptor LAPACKE_ssytri_work$descriptor() {
        return LAPACKE_ssytri_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ssytri_work(int matrix_layout, char uplo, int n, float *a, int lda, const int *ipiv, float *work)
     * }
     */
    public static MethodHandle LAPACKE_ssytri_work$handle() {
        return LAPACKE_ssytri_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ssytri_work(int matrix_layout, char uplo, int n, float *a, int lda, const int *ipiv, float *work)
     * }
     */
    public static MemorySegment LAPACKE_ssytri_work$address() {
        return LAPACKE_ssytri_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ssytri_work(int matrix_layout, char uplo, int n, float *a, int lda, const int *ipiv, float *work)
     * }
     */
    public static int LAPACKE_ssytri_work(int matrix_layout, byte uplo, int n, MemorySegment a, int lda, MemorySegment ipiv, MemorySegment work) {
        var mh$ = LAPACKE_ssytri_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ssytri_work", matrix_layout, uplo, n, a, lda, ipiv, work);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, a, lda, ipiv, work);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dsytri_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dsytri_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dsytri_work(int matrix_layout, char uplo, int n, double *a, int lda, const int *ipiv, double *work)
     * }
     */
    public static FunctionDescriptor LAPACKE_dsytri_work$descriptor() {
        return LAPACKE_dsytri_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dsytri_work(int matrix_layout, char uplo, int n, double *a, int lda, const int *ipiv, double *work)
     * }
     */
    public static MethodHandle LAPACKE_dsytri_work$handle() {
        return LAPACKE_dsytri_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dsytri_work(int matrix_layout, char uplo, int n, double *a, int lda, const int *ipiv, double *work)
     * }
     */
    public static MemorySegment LAPACKE_dsytri_work$address() {
        return LAPACKE_dsytri_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dsytri_work(int matrix_layout, char uplo, int n, double *a, int lda, const int *ipiv, double *work)
     * }
     */
    public static int LAPACKE_dsytri_work(int matrix_layout, byte uplo, int n, MemorySegment a, int lda, MemorySegment ipiv, MemorySegment work) {
        var mh$ = LAPACKE_dsytri_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dsytri_work", matrix_layout, uplo, n, a, lda, ipiv, work);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, a, lda, ipiv, work);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_csytri_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_csytri_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_csytri_work(int matrix_layout, char uplo, int n, _Complex float *a, int lda, const int *ipiv, _Complex float *work)
     * }
     */
    public static FunctionDescriptor LAPACKE_csytri_work$descriptor() {
        return LAPACKE_csytri_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_csytri_work(int matrix_layout, char uplo, int n, _Complex float *a, int lda, const int *ipiv, _Complex float *work)
     * }
     */
    public static MethodHandle LAPACKE_csytri_work$handle() {
        return LAPACKE_csytri_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_csytri_work(int matrix_layout, char uplo, int n, _Complex float *a, int lda, const int *ipiv, _Complex float *work)
     * }
     */
    public static MemorySegment LAPACKE_csytri_work$address() {
        return LAPACKE_csytri_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_csytri_work(int matrix_layout, char uplo, int n, _Complex float *a, int lda, const int *ipiv, _Complex float *work)
     * }
     */
    public static int LAPACKE_csytri_work(int matrix_layout, byte uplo, int n, MemorySegment a, int lda, MemorySegment ipiv, MemorySegment work) {
        var mh$ = LAPACKE_csytri_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_csytri_work", matrix_layout, uplo, n, a, lda, ipiv, work);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, a, lda, ipiv, work);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zsytri_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zsytri_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zsytri_work(int matrix_layout, char uplo, int n, _Complex double *a, int lda, const int *ipiv, _Complex double *work)
     * }
     */
    public static FunctionDescriptor LAPACKE_zsytri_work$descriptor() {
        return LAPACKE_zsytri_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zsytri_work(int matrix_layout, char uplo, int n, _Complex double *a, int lda, const int *ipiv, _Complex double *work)
     * }
     */
    public static MethodHandle LAPACKE_zsytri_work$handle() {
        return LAPACKE_zsytri_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zsytri_work(int matrix_layout, char uplo, int n, _Complex double *a, int lda, const int *ipiv, _Complex double *work)
     * }
     */
    public static MemorySegment LAPACKE_zsytri_work$address() {
        return LAPACKE_zsytri_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zsytri_work(int matrix_layout, char uplo, int n, _Complex double *a, int lda, const int *ipiv, _Complex double *work)
     * }
     */
    public static int LAPACKE_zsytri_work(int matrix_layout, byte uplo, int n, MemorySegment a, int lda, MemorySegment ipiv, MemorySegment work) {
        var mh$ = LAPACKE_zsytri_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zsytri_work", matrix_layout, uplo, n, a, lda, ipiv, work);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, a, lda, ipiv, work);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ssytrs_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_ssytrs_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ssytrs_work(int matrix_layout, char uplo, int n, int nrhs, const float *a, int lda, const int *ipiv, float *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_ssytrs_work$descriptor() {
        return LAPACKE_ssytrs_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ssytrs_work(int matrix_layout, char uplo, int n, int nrhs, const float *a, int lda, const int *ipiv, float *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_ssytrs_work$handle() {
        return LAPACKE_ssytrs_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ssytrs_work(int matrix_layout, char uplo, int n, int nrhs, const float *a, int lda, const int *ipiv, float *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_ssytrs_work$address() {
        return LAPACKE_ssytrs_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ssytrs_work(int matrix_layout, char uplo, int n, int nrhs, const float *a, int lda, const int *ipiv, float *b, int ldb)
     * }
     */
    public static int LAPACKE_ssytrs_work(int matrix_layout, byte uplo, int n, int nrhs, MemorySegment a, int lda, MemorySegment ipiv, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_ssytrs_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ssytrs_work", matrix_layout, uplo, n, nrhs, a, lda, ipiv, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, nrhs, a, lda, ipiv, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dsytrs_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dsytrs_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dsytrs_work(int matrix_layout, char uplo, int n, int nrhs, const double *a, int lda, const int *ipiv, double *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_dsytrs_work$descriptor() {
        return LAPACKE_dsytrs_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dsytrs_work(int matrix_layout, char uplo, int n, int nrhs, const double *a, int lda, const int *ipiv, double *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_dsytrs_work$handle() {
        return LAPACKE_dsytrs_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dsytrs_work(int matrix_layout, char uplo, int n, int nrhs, const double *a, int lda, const int *ipiv, double *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_dsytrs_work$address() {
        return LAPACKE_dsytrs_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dsytrs_work(int matrix_layout, char uplo, int n, int nrhs, const double *a, int lda, const int *ipiv, double *b, int ldb)
     * }
     */
    public static int LAPACKE_dsytrs_work(int matrix_layout, byte uplo, int n, int nrhs, MemorySegment a, int lda, MemorySegment ipiv, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_dsytrs_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dsytrs_work", matrix_layout, uplo, n, nrhs, a, lda, ipiv, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, nrhs, a, lda, ipiv, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_csytrs_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_csytrs_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_csytrs_work(int matrix_layout, char uplo, int n, int nrhs, const _Complex float *a, int lda, const int *ipiv, _Complex float *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_csytrs_work$descriptor() {
        return LAPACKE_csytrs_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_csytrs_work(int matrix_layout, char uplo, int n, int nrhs, const _Complex float *a, int lda, const int *ipiv, _Complex float *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_csytrs_work$handle() {
        return LAPACKE_csytrs_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_csytrs_work(int matrix_layout, char uplo, int n, int nrhs, const _Complex float *a, int lda, const int *ipiv, _Complex float *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_csytrs_work$address() {
        return LAPACKE_csytrs_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_csytrs_work(int matrix_layout, char uplo, int n, int nrhs, const _Complex float *a, int lda, const int *ipiv, _Complex float *b, int ldb)
     * }
     */
    public static int LAPACKE_csytrs_work(int matrix_layout, byte uplo, int n, int nrhs, MemorySegment a, int lda, MemorySegment ipiv, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_csytrs_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_csytrs_work", matrix_layout, uplo, n, nrhs, a, lda, ipiv, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, nrhs, a, lda, ipiv, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zsytrs_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zsytrs_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zsytrs_work(int matrix_layout, char uplo, int n, int nrhs, const _Complex double *a, int lda, const int *ipiv, _Complex double *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_zsytrs_work$descriptor() {
        return LAPACKE_zsytrs_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zsytrs_work(int matrix_layout, char uplo, int n, int nrhs, const _Complex double *a, int lda, const int *ipiv, _Complex double *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_zsytrs_work$handle() {
        return LAPACKE_zsytrs_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zsytrs_work(int matrix_layout, char uplo, int n, int nrhs, const _Complex double *a, int lda, const int *ipiv, _Complex double *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_zsytrs_work$address() {
        return LAPACKE_zsytrs_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zsytrs_work(int matrix_layout, char uplo, int n, int nrhs, const _Complex double *a, int lda, const int *ipiv, _Complex double *b, int ldb)
     * }
     */
    public static int LAPACKE_zsytrs_work(int matrix_layout, byte uplo, int n, int nrhs, MemorySegment a, int lda, MemorySegment ipiv, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_zsytrs_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zsytrs_work", matrix_layout, uplo, n, nrhs, a, lda, ipiv, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, nrhs, a, lda, ipiv, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_stbcon_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_stbcon_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_stbcon_work(int matrix_layout, char norm, char uplo, char diag, int n, int kd, const float *ab, int ldab, float *rcond, float *work, int *iwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_stbcon_work$descriptor() {
        return LAPACKE_stbcon_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_stbcon_work(int matrix_layout, char norm, char uplo, char diag, int n, int kd, const float *ab, int ldab, float *rcond, float *work, int *iwork)
     * }
     */
    public static MethodHandle LAPACKE_stbcon_work$handle() {
        return LAPACKE_stbcon_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_stbcon_work(int matrix_layout, char norm, char uplo, char diag, int n, int kd, const float *ab, int ldab, float *rcond, float *work, int *iwork)
     * }
     */
    public static MemorySegment LAPACKE_stbcon_work$address() {
        return LAPACKE_stbcon_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_stbcon_work(int matrix_layout, char norm, char uplo, char diag, int n, int kd, const float *ab, int ldab, float *rcond, float *work, int *iwork)
     * }
     */
    public static int LAPACKE_stbcon_work(int matrix_layout, byte norm, byte uplo, byte diag, int n, int kd, MemorySegment ab, int ldab, MemorySegment rcond, MemorySegment work, MemorySegment iwork) {
        var mh$ = LAPACKE_stbcon_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_stbcon_work", matrix_layout, norm, uplo, diag, n, kd, ab, ldab, rcond, work, iwork);
            }
            return (int)mh$.invokeExact(matrix_layout, norm, uplo, diag, n, kd, ab, ldab, rcond, work, iwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dtbcon_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dtbcon_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dtbcon_work(int matrix_layout, char norm, char uplo, char diag, int n, int kd, const double *ab, int ldab, double *rcond, double *work, int *iwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_dtbcon_work$descriptor() {
        return LAPACKE_dtbcon_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dtbcon_work(int matrix_layout, char norm, char uplo, char diag, int n, int kd, const double *ab, int ldab, double *rcond, double *work, int *iwork)
     * }
     */
    public static MethodHandle LAPACKE_dtbcon_work$handle() {
        return LAPACKE_dtbcon_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dtbcon_work(int matrix_layout, char norm, char uplo, char diag, int n, int kd, const double *ab, int ldab, double *rcond, double *work, int *iwork)
     * }
     */
    public static MemorySegment LAPACKE_dtbcon_work$address() {
        return LAPACKE_dtbcon_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dtbcon_work(int matrix_layout, char norm, char uplo, char diag, int n, int kd, const double *ab, int ldab, double *rcond, double *work, int *iwork)
     * }
     */
    public static int LAPACKE_dtbcon_work(int matrix_layout, byte norm, byte uplo, byte diag, int n, int kd, MemorySegment ab, int ldab, MemorySegment rcond, MemorySegment work, MemorySegment iwork) {
        var mh$ = LAPACKE_dtbcon_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dtbcon_work", matrix_layout, norm, uplo, diag, n, kd, ab, ldab, rcond, work, iwork);
            }
            return (int)mh$.invokeExact(matrix_layout, norm, uplo, diag, n, kd, ab, ldab, rcond, work, iwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ctbcon_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_ctbcon_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ctbcon_work(int matrix_layout, char norm, char uplo, char diag, int n, int kd, const _Complex float *ab, int ldab, float *rcond, _Complex float *work, float *rwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_ctbcon_work$descriptor() {
        return LAPACKE_ctbcon_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ctbcon_work(int matrix_layout, char norm, char uplo, char diag, int n, int kd, const _Complex float *ab, int ldab, float *rcond, _Complex float *work, float *rwork)
     * }
     */
    public static MethodHandle LAPACKE_ctbcon_work$handle() {
        return LAPACKE_ctbcon_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ctbcon_work(int matrix_layout, char norm, char uplo, char diag, int n, int kd, const _Complex float *ab, int ldab, float *rcond, _Complex float *work, float *rwork)
     * }
     */
    public static MemorySegment LAPACKE_ctbcon_work$address() {
        return LAPACKE_ctbcon_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ctbcon_work(int matrix_layout, char norm, char uplo, char diag, int n, int kd, const _Complex float *ab, int ldab, float *rcond, _Complex float *work, float *rwork)
     * }
     */
    public static int LAPACKE_ctbcon_work(int matrix_layout, byte norm, byte uplo, byte diag, int n, int kd, MemorySegment ab, int ldab, MemorySegment rcond, MemorySegment work, MemorySegment rwork) {
        var mh$ = LAPACKE_ctbcon_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ctbcon_work", matrix_layout, norm, uplo, diag, n, kd, ab, ldab, rcond, work, rwork);
            }
            return (int)mh$.invokeExact(matrix_layout, norm, uplo, diag, n, kd, ab, ldab, rcond, work, rwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ztbcon_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_ztbcon_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ztbcon_work(int matrix_layout, char norm, char uplo, char diag, int n, int kd, const _Complex double *ab, int ldab, double *rcond, _Complex double *work, double *rwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_ztbcon_work$descriptor() {
        return LAPACKE_ztbcon_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ztbcon_work(int matrix_layout, char norm, char uplo, char diag, int n, int kd, const _Complex double *ab, int ldab, double *rcond, _Complex double *work, double *rwork)
     * }
     */
    public static MethodHandle LAPACKE_ztbcon_work$handle() {
        return LAPACKE_ztbcon_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ztbcon_work(int matrix_layout, char norm, char uplo, char diag, int n, int kd, const _Complex double *ab, int ldab, double *rcond, _Complex double *work, double *rwork)
     * }
     */
    public static MemorySegment LAPACKE_ztbcon_work$address() {
        return LAPACKE_ztbcon_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ztbcon_work(int matrix_layout, char norm, char uplo, char diag, int n, int kd, const _Complex double *ab, int ldab, double *rcond, _Complex double *work, double *rwork)
     * }
     */
    public static int LAPACKE_ztbcon_work(int matrix_layout, byte norm, byte uplo, byte diag, int n, int kd, MemorySegment ab, int ldab, MemorySegment rcond, MemorySegment work, MemorySegment rwork) {
        var mh$ = LAPACKE_ztbcon_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ztbcon_work", matrix_layout, norm, uplo, diag, n, kd, ab, ldab, rcond, work, rwork);
            }
            return (int)mh$.invokeExact(matrix_layout, norm, uplo, diag, n, kd, ab, ldab, rcond, work, rwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_stbrfs_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_stbrfs_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_stbrfs_work(int matrix_layout, char uplo, char trans, char diag, int n, int kd, int nrhs, const float *ab, int ldab, const float *b, int ldb, const float *x, int ldx, float *ferr, float *berr, float *work, int *iwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_stbrfs_work$descriptor() {
        return LAPACKE_stbrfs_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_stbrfs_work(int matrix_layout, char uplo, char trans, char diag, int n, int kd, int nrhs, const float *ab, int ldab, const float *b, int ldb, const float *x, int ldx, float *ferr, float *berr, float *work, int *iwork)
     * }
     */
    public static MethodHandle LAPACKE_stbrfs_work$handle() {
        return LAPACKE_stbrfs_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_stbrfs_work(int matrix_layout, char uplo, char trans, char diag, int n, int kd, int nrhs, const float *ab, int ldab, const float *b, int ldb, const float *x, int ldx, float *ferr, float *berr, float *work, int *iwork)
     * }
     */
    public static MemorySegment LAPACKE_stbrfs_work$address() {
        return LAPACKE_stbrfs_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_stbrfs_work(int matrix_layout, char uplo, char trans, char diag, int n, int kd, int nrhs, const float *ab, int ldab, const float *b, int ldb, const float *x, int ldx, float *ferr, float *berr, float *work, int *iwork)
     * }
     */
    public static int LAPACKE_stbrfs_work(int matrix_layout, byte uplo, byte trans, byte diag, int n, int kd, int nrhs, MemorySegment ab, int ldab, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment ferr, MemorySegment berr, MemorySegment work, MemorySegment iwork) {
        var mh$ = LAPACKE_stbrfs_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_stbrfs_work", matrix_layout, uplo, trans, diag, n, kd, nrhs, ab, ldab, b, ldb, x, ldx, ferr, berr, work, iwork);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, trans, diag, n, kd, nrhs, ab, ldab, b, ldb, x, ldx, ferr, berr, work, iwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dtbrfs_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dtbrfs_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dtbrfs_work(int matrix_layout, char uplo, char trans, char diag, int n, int kd, int nrhs, const double *ab, int ldab, const double *b, int ldb, const double *x, int ldx, double *ferr, double *berr, double *work, int *iwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_dtbrfs_work$descriptor() {
        return LAPACKE_dtbrfs_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dtbrfs_work(int matrix_layout, char uplo, char trans, char diag, int n, int kd, int nrhs, const double *ab, int ldab, const double *b, int ldb, const double *x, int ldx, double *ferr, double *berr, double *work, int *iwork)
     * }
     */
    public static MethodHandle LAPACKE_dtbrfs_work$handle() {
        return LAPACKE_dtbrfs_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dtbrfs_work(int matrix_layout, char uplo, char trans, char diag, int n, int kd, int nrhs, const double *ab, int ldab, const double *b, int ldb, const double *x, int ldx, double *ferr, double *berr, double *work, int *iwork)
     * }
     */
    public static MemorySegment LAPACKE_dtbrfs_work$address() {
        return LAPACKE_dtbrfs_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dtbrfs_work(int matrix_layout, char uplo, char trans, char diag, int n, int kd, int nrhs, const double *ab, int ldab, const double *b, int ldb, const double *x, int ldx, double *ferr, double *berr, double *work, int *iwork)
     * }
     */
    public static int LAPACKE_dtbrfs_work(int matrix_layout, byte uplo, byte trans, byte diag, int n, int kd, int nrhs, MemorySegment ab, int ldab, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment ferr, MemorySegment berr, MemorySegment work, MemorySegment iwork) {
        var mh$ = LAPACKE_dtbrfs_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dtbrfs_work", matrix_layout, uplo, trans, diag, n, kd, nrhs, ab, ldab, b, ldb, x, ldx, ferr, berr, work, iwork);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, trans, diag, n, kd, nrhs, ab, ldab, b, ldb, x, ldx, ferr, berr, work, iwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ctbrfs_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_ctbrfs_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ctbrfs_work(int matrix_layout, char uplo, char trans, char diag, int n, int kd, int nrhs, const _Complex float *ab, int ldab, const _Complex float *b, int ldb, const _Complex float *x, int ldx, float *ferr, float *berr, _Complex float *work, float *rwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_ctbrfs_work$descriptor() {
        return LAPACKE_ctbrfs_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ctbrfs_work(int matrix_layout, char uplo, char trans, char diag, int n, int kd, int nrhs, const _Complex float *ab, int ldab, const _Complex float *b, int ldb, const _Complex float *x, int ldx, float *ferr, float *berr, _Complex float *work, float *rwork)
     * }
     */
    public static MethodHandle LAPACKE_ctbrfs_work$handle() {
        return LAPACKE_ctbrfs_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ctbrfs_work(int matrix_layout, char uplo, char trans, char diag, int n, int kd, int nrhs, const _Complex float *ab, int ldab, const _Complex float *b, int ldb, const _Complex float *x, int ldx, float *ferr, float *berr, _Complex float *work, float *rwork)
     * }
     */
    public static MemorySegment LAPACKE_ctbrfs_work$address() {
        return LAPACKE_ctbrfs_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ctbrfs_work(int matrix_layout, char uplo, char trans, char diag, int n, int kd, int nrhs, const _Complex float *ab, int ldab, const _Complex float *b, int ldb, const _Complex float *x, int ldx, float *ferr, float *berr, _Complex float *work, float *rwork)
     * }
     */
    public static int LAPACKE_ctbrfs_work(int matrix_layout, byte uplo, byte trans, byte diag, int n, int kd, int nrhs, MemorySegment ab, int ldab, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment ferr, MemorySegment berr, MemorySegment work, MemorySegment rwork) {
        var mh$ = LAPACKE_ctbrfs_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ctbrfs_work", matrix_layout, uplo, trans, diag, n, kd, nrhs, ab, ldab, b, ldb, x, ldx, ferr, berr, work, rwork);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, trans, diag, n, kd, nrhs, ab, ldab, b, ldb, x, ldx, ferr, berr, work, rwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ztbrfs_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_ztbrfs_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ztbrfs_work(int matrix_layout, char uplo, char trans, char diag, int n, int kd, int nrhs, const _Complex double *ab, int ldab, const _Complex double *b, int ldb, const _Complex double *x, int ldx, double *ferr, double *berr, _Complex double *work, double *rwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_ztbrfs_work$descriptor() {
        return LAPACKE_ztbrfs_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ztbrfs_work(int matrix_layout, char uplo, char trans, char diag, int n, int kd, int nrhs, const _Complex double *ab, int ldab, const _Complex double *b, int ldb, const _Complex double *x, int ldx, double *ferr, double *berr, _Complex double *work, double *rwork)
     * }
     */
    public static MethodHandle LAPACKE_ztbrfs_work$handle() {
        return LAPACKE_ztbrfs_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ztbrfs_work(int matrix_layout, char uplo, char trans, char diag, int n, int kd, int nrhs, const _Complex double *ab, int ldab, const _Complex double *b, int ldb, const _Complex double *x, int ldx, double *ferr, double *berr, _Complex double *work, double *rwork)
     * }
     */
    public static MemorySegment LAPACKE_ztbrfs_work$address() {
        return LAPACKE_ztbrfs_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ztbrfs_work(int matrix_layout, char uplo, char trans, char diag, int n, int kd, int nrhs, const _Complex double *ab, int ldab, const _Complex double *b, int ldb, const _Complex double *x, int ldx, double *ferr, double *berr, _Complex double *work, double *rwork)
     * }
     */
    public static int LAPACKE_ztbrfs_work(int matrix_layout, byte uplo, byte trans, byte diag, int n, int kd, int nrhs, MemorySegment ab, int ldab, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment ferr, MemorySegment berr, MemorySegment work, MemorySegment rwork) {
        var mh$ = LAPACKE_ztbrfs_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ztbrfs_work", matrix_layout, uplo, trans, diag, n, kd, nrhs, ab, ldab, b, ldb, x, ldx, ferr, berr, work, rwork);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, trans, diag, n, kd, nrhs, ab, ldab, b, ldb, x, ldx, ferr, berr, work, rwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_stbtrs_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_stbtrs_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_stbtrs_work(int matrix_layout, char uplo, char trans, char diag, int n, int kd, int nrhs, const float *ab, int ldab, float *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_stbtrs_work$descriptor() {
        return LAPACKE_stbtrs_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_stbtrs_work(int matrix_layout, char uplo, char trans, char diag, int n, int kd, int nrhs, const float *ab, int ldab, float *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_stbtrs_work$handle() {
        return LAPACKE_stbtrs_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_stbtrs_work(int matrix_layout, char uplo, char trans, char diag, int n, int kd, int nrhs, const float *ab, int ldab, float *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_stbtrs_work$address() {
        return LAPACKE_stbtrs_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_stbtrs_work(int matrix_layout, char uplo, char trans, char diag, int n, int kd, int nrhs, const float *ab, int ldab, float *b, int ldb)
     * }
     */
    public static int LAPACKE_stbtrs_work(int matrix_layout, byte uplo, byte trans, byte diag, int n, int kd, int nrhs, MemorySegment ab, int ldab, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_stbtrs_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_stbtrs_work", matrix_layout, uplo, trans, diag, n, kd, nrhs, ab, ldab, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, trans, diag, n, kd, nrhs, ab, ldab, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dtbtrs_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dtbtrs_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dtbtrs_work(int matrix_layout, char uplo, char trans, char diag, int n, int kd, int nrhs, const double *ab, int ldab, double *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_dtbtrs_work$descriptor() {
        return LAPACKE_dtbtrs_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dtbtrs_work(int matrix_layout, char uplo, char trans, char diag, int n, int kd, int nrhs, const double *ab, int ldab, double *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_dtbtrs_work$handle() {
        return LAPACKE_dtbtrs_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dtbtrs_work(int matrix_layout, char uplo, char trans, char diag, int n, int kd, int nrhs, const double *ab, int ldab, double *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_dtbtrs_work$address() {
        return LAPACKE_dtbtrs_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dtbtrs_work(int matrix_layout, char uplo, char trans, char diag, int n, int kd, int nrhs, const double *ab, int ldab, double *b, int ldb)
     * }
     */
    public static int LAPACKE_dtbtrs_work(int matrix_layout, byte uplo, byte trans, byte diag, int n, int kd, int nrhs, MemorySegment ab, int ldab, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_dtbtrs_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dtbtrs_work", matrix_layout, uplo, trans, diag, n, kd, nrhs, ab, ldab, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, trans, diag, n, kd, nrhs, ab, ldab, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ctbtrs_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_ctbtrs_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ctbtrs_work(int matrix_layout, char uplo, char trans, char diag, int n, int kd, int nrhs, const _Complex float *ab, int ldab, _Complex float *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_ctbtrs_work$descriptor() {
        return LAPACKE_ctbtrs_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ctbtrs_work(int matrix_layout, char uplo, char trans, char diag, int n, int kd, int nrhs, const _Complex float *ab, int ldab, _Complex float *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_ctbtrs_work$handle() {
        return LAPACKE_ctbtrs_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ctbtrs_work(int matrix_layout, char uplo, char trans, char diag, int n, int kd, int nrhs, const _Complex float *ab, int ldab, _Complex float *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_ctbtrs_work$address() {
        return LAPACKE_ctbtrs_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ctbtrs_work(int matrix_layout, char uplo, char trans, char diag, int n, int kd, int nrhs, const _Complex float *ab, int ldab, _Complex float *b, int ldb)
     * }
     */
    public static int LAPACKE_ctbtrs_work(int matrix_layout, byte uplo, byte trans, byte diag, int n, int kd, int nrhs, MemorySegment ab, int ldab, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_ctbtrs_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ctbtrs_work", matrix_layout, uplo, trans, diag, n, kd, nrhs, ab, ldab, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, trans, diag, n, kd, nrhs, ab, ldab, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ztbtrs_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_ztbtrs_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ztbtrs_work(int matrix_layout, char uplo, char trans, char diag, int n, int kd, int nrhs, const _Complex double *ab, int ldab, _Complex double *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_ztbtrs_work$descriptor() {
        return LAPACKE_ztbtrs_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ztbtrs_work(int matrix_layout, char uplo, char trans, char diag, int n, int kd, int nrhs, const _Complex double *ab, int ldab, _Complex double *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_ztbtrs_work$handle() {
        return LAPACKE_ztbtrs_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ztbtrs_work(int matrix_layout, char uplo, char trans, char diag, int n, int kd, int nrhs, const _Complex double *ab, int ldab, _Complex double *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_ztbtrs_work$address() {
        return LAPACKE_ztbtrs_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ztbtrs_work(int matrix_layout, char uplo, char trans, char diag, int n, int kd, int nrhs, const _Complex double *ab, int ldab, _Complex double *b, int ldb)
     * }
     */
    public static int LAPACKE_ztbtrs_work(int matrix_layout, byte uplo, byte trans, byte diag, int n, int kd, int nrhs, MemorySegment ab, int ldab, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_ztbtrs_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ztbtrs_work", matrix_layout, uplo, trans, diag, n, kd, nrhs, ab, ldab, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, trans, diag, n, kd, nrhs, ab, ldab, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_stfsm_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_FLOAT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_stfsm_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_stfsm_work(int matrix_layout, char transr, char side, char uplo, char trans, char diag, int m, int n, float alpha, const float *a, float *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_stfsm_work$descriptor() {
        return LAPACKE_stfsm_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_stfsm_work(int matrix_layout, char transr, char side, char uplo, char trans, char diag, int m, int n, float alpha, const float *a, float *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_stfsm_work$handle() {
        return LAPACKE_stfsm_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_stfsm_work(int matrix_layout, char transr, char side, char uplo, char trans, char diag, int m, int n, float alpha, const float *a, float *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_stfsm_work$address() {
        return LAPACKE_stfsm_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_stfsm_work(int matrix_layout, char transr, char side, char uplo, char trans, char diag, int m, int n, float alpha, const float *a, float *b, int ldb)
     * }
     */
    public static int LAPACKE_stfsm_work(int matrix_layout, byte transr, byte side, byte uplo, byte trans, byte diag, int m, int n, float alpha, MemorySegment a, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_stfsm_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_stfsm_work", matrix_layout, transr, side, uplo, trans, diag, m, n, alpha, a, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, transr, side, uplo, trans, diag, m, n, alpha, a, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dtfsm_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_DOUBLE,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dtfsm_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dtfsm_work(int matrix_layout, char transr, char side, char uplo, char trans, char diag, int m, int n, double alpha, const double *a, double *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_dtfsm_work$descriptor() {
        return LAPACKE_dtfsm_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dtfsm_work(int matrix_layout, char transr, char side, char uplo, char trans, char diag, int m, int n, double alpha, const double *a, double *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_dtfsm_work$handle() {
        return LAPACKE_dtfsm_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dtfsm_work(int matrix_layout, char transr, char side, char uplo, char trans, char diag, int m, int n, double alpha, const double *a, double *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_dtfsm_work$address() {
        return LAPACKE_dtfsm_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dtfsm_work(int matrix_layout, char transr, char side, char uplo, char trans, char diag, int m, int n, double alpha, const double *a, double *b, int ldb)
     * }
     */
    public static int LAPACKE_dtfsm_work(int matrix_layout, byte transr, byte side, byte uplo, byte trans, byte diag, int m, int n, double alpha, MemorySegment a, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_dtfsm_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dtfsm_work", matrix_layout, transr, side, uplo, trans, diag, m, n, alpha, a, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, transr, side, uplo, trans, diag, m, n, alpha, a, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ctfsm_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_FLOAT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_ctfsm_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ctfsm_work(int matrix_layout, char transr, char side, char uplo, char trans, char diag, int m, int n, _Complex float alpha, const _Complex float *a, _Complex float *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_ctfsm_work$descriptor() {
        return LAPACKE_ctfsm_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ctfsm_work(int matrix_layout, char transr, char side, char uplo, char trans, char diag, int m, int n, _Complex float alpha, const _Complex float *a, _Complex float *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_ctfsm_work$handle() {
        return LAPACKE_ctfsm_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ctfsm_work(int matrix_layout, char transr, char side, char uplo, char trans, char diag, int m, int n, _Complex float alpha, const _Complex float *a, _Complex float *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_ctfsm_work$address() {
        return LAPACKE_ctfsm_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ctfsm_work(int matrix_layout, char transr, char side, char uplo, char trans, char diag, int m, int n, _Complex float alpha, const _Complex float *a, _Complex float *b, int ldb)
     * }
     */
    public static int LAPACKE_ctfsm_work(int matrix_layout, byte transr, byte side, byte uplo, byte trans, byte diag, int m, int n, float alpha, MemorySegment a, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_ctfsm_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ctfsm_work", matrix_layout, transr, side, uplo, trans, diag, m, n, alpha, a, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, transr, side, uplo, trans, diag, m, n, alpha, a, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ztfsm_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_DOUBLE,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_ztfsm_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ztfsm_work(int matrix_layout, char transr, char side, char uplo, char trans, char diag, int m, int n, _Complex double alpha, const _Complex double *a, _Complex double *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_ztfsm_work$descriptor() {
        return LAPACKE_ztfsm_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ztfsm_work(int matrix_layout, char transr, char side, char uplo, char trans, char diag, int m, int n, _Complex double alpha, const _Complex double *a, _Complex double *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_ztfsm_work$handle() {
        return LAPACKE_ztfsm_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ztfsm_work(int matrix_layout, char transr, char side, char uplo, char trans, char diag, int m, int n, _Complex double alpha, const _Complex double *a, _Complex double *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_ztfsm_work$address() {
        return LAPACKE_ztfsm_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ztfsm_work(int matrix_layout, char transr, char side, char uplo, char trans, char diag, int m, int n, _Complex double alpha, const _Complex double *a, _Complex double *b, int ldb)
     * }
     */
    public static int LAPACKE_ztfsm_work(int matrix_layout, byte transr, byte side, byte uplo, byte trans, byte diag, int m, int n, double alpha, MemorySegment a, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_ztfsm_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ztfsm_work", matrix_layout, transr, side, uplo, trans, diag, m, n, alpha, a, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, transr, side, uplo, trans, diag, m, n, alpha, a, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_stftri_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_stftri_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_stftri_work(int matrix_layout, char transr, char uplo, char diag, int n, float *a)
     * }
     */
    public static FunctionDescriptor LAPACKE_stftri_work$descriptor() {
        return LAPACKE_stftri_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_stftri_work(int matrix_layout, char transr, char uplo, char diag, int n, float *a)
     * }
     */
    public static MethodHandle LAPACKE_stftri_work$handle() {
        return LAPACKE_stftri_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_stftri_work(int matrix_layout, char transr, char uplo, char diag, int n, float *a)
     * }
     */
    public static MemorySegment LAPACKE_stftri_work$address() {
        return LAPACKE_stftri_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_stftri_work(int matrix_layout, char transr, char uplo, char diag, int n, float *a)
     * }
     */
    public static int LAPACKE_stftri_work(int matrix_layout, byte transr, byte uplo, byte diag, int n, MemorySegment a) {
        var mh$ = LAPACKE_stftri_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_stftri_work", matrix_layout, transr, uplo, diag, n, a);
            }
            return (int)mh$.invokeExact(matrix_layout, transr, uplo, diag, n, a);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dtftri_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dtftri_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dtftri_work(int matrix_layout, char transr, char uplo, char diag, int n, double *a)
     * }
     */
    public static FunctionDescriptor LAPACKE_dtftri_work$descriptor() {
        return LAPACKE_dtftri_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dtftri_work(int matrix_layout, char transr, char uplo, char diag, int n, double *a)
     * }
     */
    public static MethodHandle LAPACKE_dtftri_work$handle() {
        return LAPACKE_dtftri_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dtftri_work(int matrix_layout, char transr, char uplo, char diag, int n, double *a)
     * }
     */
    public static MemorySegment LAPACKE_dtftri_work$address() {
        return LAPACKE_dtftri_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dtftri_work(int matrix_layout, char transr, char uplo, char diag, int n, double *a)
     * }
     */
    public static int LAPACKE_dtftri_work(int matrix_layout, byte transr, byte uplo, byte diag, int n, MemorySegment a) {
        var mh$ = LAPACKE_dtftri_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dtftri_work", matrix_layout, transr, uplo, diag, n, a);
            }
            return (int)mh$.invokeExact(matrix_layout, transr, uplo, diag, n, a);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ctftri_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_ctftri_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ctftri_work(int matrix_layout, char transr, char uplo, char diag, int n, _Complex float *a)
     * }
     */
    public static FunctionDescriptor LAPACKE_ctftri_work$descriptor() {
        return LAPACKE_ctftri_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ctftri_work(int matrix_layout, char transr, char uplo, char diag, int n, _Complex float *a)
     * }
     */
    public static MethodHandle LAPACKE_ctftri_work$handle() {
        return LAPACKE_ctftri_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ctftri_work(int matrix_layout, char transr, char uplo, char diag, int n, _Complex float *a)
     * }
     */
    public static MemorySegment LAPACKE_ctftri_work$address() {
        return LAPACKE_ctftri_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ctftri_work(int matrix_layout, char transr, char uplo, char diag, int n, _Complex float *a)
     * }
     */
    public static int LAPACKE_ctftri_work(int matrix_layout, byte transr, byte uplo, byte diag, int n, MemorySegment a) {
        var mh$ = LAPACKE_ctftri_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ctftri_work", matrix_layout, transr, uplo, diag, n, a);
            }
            return (int)mh$.invokeExact(matrix_layout, transr, uplo, diag, n, a);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ztftri_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_ztftri_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ztftri_work(int matrix_layout, char transr, char uplo, char diag, int n, _Complex double *a)
     * }
     */
    public static FunctionDescriptor LAPACKE_ztftri_work$descriptor() {
        return LAPACKE_ztftri_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ztftri_work(int matrix_layout, char transr, char uplo, char diag, int n, _Complex double *a)
     * }
     */
    public static MethodHandle LAPACKE_ztftri_work$handle() {
        return LAPACKE_ztftri_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ztftri_work(int matrix_layout, char transr, char uplo, char diag, int n, _Complex double *a)
     * }
     */
    public static MemorySegment LAPACKE_ztftri_work$address() {
        return LAPACKE_ztftri_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ztftri_work(int matrix_layout, char transr, char uplo, char diag, int n, _Complex double *a)
     * }
     */
    public static int LAPACKE_ztftri_work(int matrix_layout, byte transr, byte uplo, byte diag, int n, MemorySegment a) {
        var mh$ = LAPACKE_ztftri_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ztftri_work", matrix_layout, transr, uplo, diag, n, a);
            }
            return (int)mh$.invokeExact(matrix_layout, transr, uplo, diag, n, a);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_stfttp_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_stfttp_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_stfttp_work(int matrix_layout, char transr, char uplo, int n, const float *arf, float *ap)
     * }
     */
    public static FunctionDescriptor LAPACKE_stfttp_work$descriptor() {
        return LAPACKE_stfttp_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_stfttp_work(int matrix_layout, char transr, char uplo, int n, const float *arf, float *ap)
     * }
     */
    public static MethodHandle LAPACKE_stfttp_work$handle() {
        return LAPACKE_stfttp_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_stfttp_work(int matrix_layout, char transr, char uplo, int n, const float *arf, float *ap)
     * }
     */
    public static MemorySegment LAPACKE_stfttp_work$address() {
        return LAPACKE_stfttp_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_stfttp_work(int matrix_layout, char transr, char uplo, int n, const float *arf, float *ap)
     * }
     */
    public static int LAPACKE_stfttp_work(int matrix_layout, byte transr, byte uplo, int n, MemorySegment arf, MemorySegment ap) {
        var mh$ = LAPACKE_stfttp_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_stfttp_work", matrix_layout, transr, uplo, n, arf, ap);
            }
            return (int)mh$.invokeExact(matrix_layout, transr, uplo, n, arf, ap);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dtfttp_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dtfttp_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dtfttp_work(int matrix_layout, char transr, char uplo, int n, const double *arf, double *ap)
     * }
     */
    public static FunctionDescriptor LAPACKE_dtfttp_work$descriptor() {
        return LAPACKE_dtfttp_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dtfttp_work(int matrix_layout, char transr, char uplo, int n, const double *arf, double *ap)
     * }
     */
    public static MethodHandle LAPACKE_dtfttp_work$handle() {
        return LAPACKE_dtfttp_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dtfttp_work(int matrix_layout, char transr, char uplo, int n, const double *arf, double *ap)
     * }
     */
    public static MemorySegment LAPACKE_dtfttp_work$address() {
        return LAPACKE_dtfttp_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dtfttp_work(int matrix_layout, char transr, char uplo, int n, const double *arf, double *ap)
     * }
     */
    public static int LAPACKE_dtfttp_work(int matrix_layout, byte transr, byte uplo, int n, MemorySegment arf, MemorySegment ap) {
        var mh$ = LAPACKE_dtfttp_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dtfttp_work", matrix_layout, transr, uplo, n, arf, ap);
            }
            return (int)mh$.invokeExact(matrix_layout, transr, uplo, n, arf, ap);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ctfttp_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_ctfttp_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ctfttp_work(int matrix_layout, char transr, char uplo, int n, const _Complex float *arf, _Complex float *ap)
     * }
     */
    public static FunctionDescriptor LAPACKE_ctfttp_work$descriptor() {
        return LAPACKE_ctfttp_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ctfttp_work(int matrix_layout, char transr, char uplo, int n, const _Complex float *arf, _Complex float *ap)
     * }
     */
    public static MethodHandle LAPACKE_ctfttp_work$handle() {
        return LAPACKE_ctfttp_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ctfttp_work(int matrix_layout, char transr, char uplo, int n, const _Complex float *arf, _Complex float *ap)
     * }
     */
    public static MemorySegment LAPACKE_ctfttp_work$address() {
        return LAPACKE_ctfttp_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ctfttp_work(int matrix_layout, char transr, char uplo, int n, const _Complex float *arf, _Complex float *ap)
     * }
     */
    public static int LAPACKE_ctfttp_work(int matrix_layout, byte transr, byte uplo, int n, MemorySegment arf, MemorySegment ap) {
        var mh$ = LAPACKE_ctfttp_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ctfttp_work", matrix_layout, transr, uplo, n, arf, ap);
            }
            return (int)mh$.invokeExact(matrix_layout, transr, uplo, n, arf, ap);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ztfttp_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_ztfttp_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ztfttp_work(int matrix_layout, char transr, char uplo, int n, const _Complex double *arf, _Complex double *ap)
     * }
     */
    public static FunctionDescriptor LAPACKE_ztfttp_work$descriptor() {
        return LAPACKE_ztfttp_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ztfttp_work(int matrix_layout, char transr, char uplo, int n, const _Complex double *arf, _Complex double *ap)
     * }
     */
    public static MethodHandle LAPACKE_ztfttp_work$handle() {
        return LAPACKE_ztfttp_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ztfttp_work(int matrix_layout, char transr, char uplo, int n, const _Complex double *arf, _Complex double *ap)
     * }
     */
    public static MemorySegment LAPACKE_ztfttp_work$address() {
        return LAPACKE_ztfttp_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ztfttp_work(int matrix_layout, char transr, char uplo, int n, const _Complex double *arf, _Complex double *ap)
     * }
     */
    public static int LAPACKE_ztfttp_work(int matrix_layout, byte transr, byte uplo, int n, MemorySegment arf, MemorySegment ap) {
        var mh$ = LAPACKE_ztfttp_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ztfttp_work", matrix_layout, transr, uplo, n, arf, ap);
            }
            return (int)mh$.invokeExact(matrix_layout, transr, uplo, n, arf, ap);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_stfttr_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_stfttr_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_stfttr_work(int matrix_layout, char transr, char uplo, int n, const float *arf, float *a, int lda)
     * }
     */
    public static FunctionDescriptor LAPACKE_stfttr_work$descriptor() {
        return LAPACKE_stfttr_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_stfttr_work(int matrix_layout, char transr, char uplo, int n, const float *arf, float *a, int lda)
     * }
     */
    public static MethodHandle LAPACKE_stfttr_work$handle() {
        return LAPACKE_stfttr_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_stfttr_work(int matrix_layout, char transr, char uplo, int n, const float *arf, float *a, int lda)
     * }
     */
    public static MemorySegment LAPACKE_stfttr_work$address() {
        return LAPACKE_stfttr_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_stfttr_work(int matrix_layout, char transr, char uplo, int n, const float *arf, float *a, int lda)
     * }
     */
    public static int LAPACKE_stfttr_work(int matrix_layout, byte transr, byte uplo, int n, MemorySegment arf, MemorySegment a, int lda) {
        var mh$ = LAPACKE_stfttr_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_stfttr_work", matrix_layout, transr, uplo, n, arf, a, lda);
            }
            return (int)mh$.invokeExact(matrix_layout, transr, uplo, n, arf, a, lda);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dtfttr_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dtfttr_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dtfttr_work(int matrix_layout, char transr, char uplo, int n, const double *arf, double *a, int lda)
     * }
     */
    public static FunctionDescriptor LAPACKE_dtfttr_work$descriptor() {
        return LAPACKE_dtfttr_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dtfttr_work(int matrix_layout, char transr, char uplo, int n, const double *arf, double *a, int lda)
     * }
     */
    public static MethodHandle LAPACKE_dtfttr_work$handle() {
        return LAPACKE_dtfttr_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dtfttr_work(int matrix_layout, char transr, char uplo, int n, const double *arf, double *a, int lda)
     * }
     */
    public static MemorySegment LAPACKE_dtfttr_work$address() {
        return LAPACKE_dtfttr_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dtfttr_work(int matrix_layout, char transr, char uplo, int n, const double *arf, double *a, int lda)
     * }
     */
    public static int LAPACKE_dtfttr_work(int matrix_layout, byte transr, byte uplo, int n, MemorySegment arf, MemorySegment a, int lda) {
        var mh$ = LAPACKE_dtfttr_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dtfttr_work", matrix_layout, transr, uplo, n, arf, a, lda);
            }
            return (int)mh$.invokeExact(matrix_layout, transr, uplo, n, arf, a, lda);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ctfttr_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_ctfttr_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ctfttr_work(int matrix_layout, char transr, char uplo, int n, const _Complex float *arf, _Complex float *a, int lda)
     * }
     */
    public static FunctionDescriptor LAPACKE_ctfttr_work$descriptor() {
        return LAPACKE_ctfttr_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ctfttr_work(int matrix_layout, char transr, char uplo, int n, const _Complex float *arf, _Complex float *a, int lda)
     * }
     */
    public static MethodHandle LAPACKE_ctfttr_work$handle() {
        return LAPACKE_ctfttr_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ctfttr_work(int matrix_layout, char transr, char uplo, int n, const _Complex float *arf, _Complex float *a, int lda)
     * }
     */
    public static MemorySegment LAPACKE_ctfttr_work$address() {
        return LAPACKE_ctfttr_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ctfttr_work(int matrix_layout, char transr, char uplo, int n, const _Complex float *arf, _Complex float *a, int lda)
     * }
     */
    public static int LAPACKE_ctfttr_work(int matrix_layout, byte transr, byte uplo, int n, MemorySegment arf, MemorySegment a, int lda) {
        var mh$ = LAPACKE_ctfttr_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ctfttr_work", matrix_layout, transr, uplo, n, arf, a, lda);
            }
            return (int)mh$.invokeExact(matrix_layout, transr, uplo, n, arf, a, lda);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ztfttr_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_ztfttr_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ztfttr_work(int matrix_layout, char transr, char uplo, int n, const _Complex double *arf, _Complex double *a, int lda)
     * }
     */
    public static FunctionDescriptor LAPACKE_ztfttr_work$descriptor() {
        return LAPACKE_ztfttr_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ztfttr_work(int matrix_layout, char transr, char uplo, int n, const _Complex double *arf, _Complex double *a, int lda)
     * }
     */
    public static MethodHandle LAPACKE_ztfttr_work$handle() {
        return LAPACKE_ztfttr_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ztfttr_work(int matrix_layout, char transr, char uplo, int n, const _Complex double *arf, _Complex double *a, int lda)
     * }
     */
    public static MemorySegment LAPACKE_ztfttr_work$address() {
        return LAPACKE_ztfttr_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ztfttr_work(int matrix_layout, char transr, char uplo, int n, const _Complex double *arf, _Complex double *a, int lda)
     * }
     */
    public static int LAPACKE_ztfttr_work(int matrix_layout, byte transr, byte uplo, int n, MemorySegment arf, MemorySegment a, int lda) {
        var mh$ = LAPACKE_ztfttr_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ztfttr_work", matrix_layout, transr, uplo, n, arf, a, lda);
            }
            return (int)mh$.invokeExact(matrix_layout, transr, uplo, n, arf, a, lda);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_stgevc_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_stgevc_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_stgevc_work(int matrix_layout, char side, char howmny, const int *select, int n, const float *s, int lds, const float *p, int ldp, float *vl, int ldvl, float *vr, int ldvr, int mm, int *m, float *work)
     * }
     */
    public static FunctionDescriptor LAPACKE_stgevc_work$descriptor() {
        return LAPACKE_stgevc_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_stgevc_work(int matrix_layout, char side, char howmny, const int *select, int n, const float *s, int lds, const float *p, int ldp, float *vl, int ldvl, float *vr, int ldvr, int mm, int *m, float *work)
     * }
     */
    public static MethodHandle LAPACKE_stgevc_work$handle() {
        return LAPACKE_stgevc_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_stgevc_work(int matrix_layout, char side, char howmny, const int *select, int n, const float *s, int lds, const float *p, int ldp, float *vl, int ldvl, float *vr, int ldvr, int mm, int *m, float *work)
     * }
     */
    public static MemorySegment LAPACKE_stgevc_work$address() {
        return LAPACKE_stgevc_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_stgevc_work(int matrix_layout, char side, char howmny, const int *select, int n, const float *s, int lds, const float *p, int ldp, float *vl, int ldvl, float *vr, int ldvr, int mm, int *m, float *work)
     * }
     */
    public static int LAPACKE_stgevc_work(int matrix_layout, byte side, byte howmny, MemorySegment select, int n, MemorySegment s, int lds, MemorySegment p, int ldp, MemorySegment vl, int ldvl, MemorySegment vr, int ldvr, int mm, MemorySegment m, MemorySegment work) {
        var mh$ = LAPACKE_stgevc_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_stgevc_work", matrix_layout, side, howmny, select, n, s, lds, p, ldp, vl, ldvl, vr, ldvr, mm, m, work);
            }
            return (int)mh$.invokeExact(matrix_layout, side, howmny, select, n, s, lds, p, ldp, vl, ldvl, vr, ldvr, mm, m, work);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dtgevc_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dtgevc_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dtgevc_work(int matrix_layout, char side, char howmny, const int *select, int n, const double *s, int lds, const double *p, int ldp, double *vl, int ldvl, double *vr, int ldvr, int mm, int *m, double *work)
     * }
     */
    public static FunctionDescriptor LAPACKE_dtgevc_work$descriptor() {
        return LAPACKE_dtgevc_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dtgevc_work(int matrix_layout, char side, char howmny, const int *select, int n, const double *s, int lds, const double *p, int ldp, double *vl, int ldvl, double *vr, int ldvr, int mm, int *m, double *work)
     * }
     */
    public static MethodHandle LAPACKE_dtgevc_work$handle() {
        return LAPACKE_dtgevc_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dtgevc_work(int matrix_layout, char side, char howmny, const int *select, int n, const double *s, int lds, const double *p, int ldp, double *vl, int ldvl, double *vr, int ldvr, int mm, int *m, double *work)
     * }
     */
    public static MemorySegment LAPACKE_dtgevc_work$address() {
        return LAPACKE_dtgevc_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dtgevc_work(int matrix_layout, char side, char howmny, const int *select, int n, const double *s, int lds, const double *p, int ldp, double *vl, int ldvl, double *vr, int ldvr, int mm, int *m, double *work)
     * }
     */
    public static int LAPACKE_dtgevc_work(int matrix_layout, byte side, byte howmny, MemorySegment select, int n, MemorySegment s, int lds, MemorySegment p, int ldp, MemorySegment vl, int ldvl, MemorySegment vr, int ldvr, int mm, MemorySegment m, MemorySegment work) {
        var mh$ = LAPACKE_dtgevc_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dtgevc_work", matrix_layout, side, howmny, select, n, s, lds, p, ldp, vl, ldvl, vr, ldvr, mm, m, work);
            }
            return (int)mh$.invokeExact(matrix_layout, side, howmny, select, n, s, lds, p, ldp, vl, ldvl, vr, ldvr, mm, m, work);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ctgevc_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_ctgevc_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ctgevc_work(int matrix_layout, char side, char howmny, const int *select, int n, const _Complex float *s, int lds, const _Complex float *p, int ldp, _Complex float *vl, int ldvl, _Complex float *vr, int ldvr, int mm, int *m, _Complex float *work, float *rwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_ctgevc_work$descriptor() {
        return LAPACKE_ctgevc_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ctgevc_work(int matrix_layout, char side, char howmny, const int *select, int n, const _Complex float *s, int lds, const _Complex float *p, int ldp, _Complex float *vl, int ldvl, _Complex float *vr, int ldvr, int mm, int *m, _Complex float *work, float *rwork)
     * }
     */
    public static MethodHandle LAPACKE_ctgevc_work$handle() {
        return LAPACKE_ctgevc_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ctgevc_work(int matrix_layout, char side, char howmny, const int *select, int n, const _Complex float *s, int lds, const _Complex float *p, int ldp, _Complex float *vl, int ldvl, _Complex float *vr, int ldvr, int mm, int *m, _Complex float *work, float *rwork)
     * }
     */
    public static MemorySegment LAPACKE_ctgevc_work$address() {
        return LAPACKE_ctgevc_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ctgevc_work(int matrix_layout, char side, char howmny, const int *select, int n, const _Complex float *s, int lds, const _Complex float *p, int ldp, _Complex float *vl, int ldvl, _Complex float *vr, int ldvr, int mm, int *m, _Complex float *work, float *rwork)
     * }
     */
    public static int LAPACKE_ctgevc_work(int matrix_layout, byte side, byte howmny, MemorySegment select, int n, MemorySegment s, int lds, MemorySegment p, int ldp, MemorySegment vl, int ldvl, MemorySegment vr, int ldvr, int mm, MemorySegment m, MemorySegment work, MemorySegment rwork) {
        var mh$ = LAPACKE_ctgevc_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ctgevc_work", matrix_layout, side, howmny, select, n, s, lds, p, ldp, vl, ldvl, vr, ldvr, mm, m, work, rwork);
            }
            return (int)mh$.invokeExact(matrix_layout, side, howmny, select, n, s, lds, p, ldp, vl, ldvl, vr, ldvr, mm, m, work, rwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ztgevc_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_ztgevc_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ztgevc_work(int matrix_layout, char side, char howmny, const int *select, int n, const _Complex double *s, int lds, const _Complex double *p, int ldp, _Complex double *vl, int ldvl, _Complex double *vr, int ldvr, int mm, int *m, _Complex double *work, double *rwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_ztgevc_work$descriptor() {
        return LAPACKE_ztgevc_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ztgevc_work(int matrix_layout, char side, char howmny, const int *select, int n, const _Complex double *s, int lds, const _Complex double *p, int ldp, _Complex double *vl, int ldvl, _Complex double *vr, int ldvr, int mm, int *m, _Complex double *work, double *rwork)
     * }
     */
    public static MethodHandle LAPACKE_ztgevc_work$handle() {
        return LAPACKE_ztgevc_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ztgevc_work(int matrix_layout, char side, char howmny, const int *select, int n, const _Complex double *s, int lds, const _Complex double *p, int ldp, _Complex double *vl, int ldvl, _Complex double *vr, int ldvr, int mm, int *m, _Complex double *work, double *rwork)
     * }
     */
    public static MemorySegment LAPACKE_ztgevc_work$address() {
        return LAPACKE_ztgevc_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ztgevc_work(int matrix_layout, char side, char howmny, const int *select, int n, const _Complex double *s, int lds, const _Complex double *p, int ldp, _Complex double *vl, int ldvl, _Complex double *vr, int ldvr, int mm, int *m, _Complex double *work, double *rwork)
     * }
     */
    public static int LAPACKE_ztgevc_work(int matrix_layout, byte side, byte howmny, MemorySegment select, int n, MemorySegment s, int lds, MemorySegment p, int ldp, MemorySegment vl, int ldvl, MemorySegment vr, int ldvr, int mm, MemorySegment m, MemorySegment work, MemorySegment rwork) {
        var mh$ = LAPACKE_ztgevc_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ztgevc_work", matrix_layout, side, howmny, select, n, s, lds, p, ldp, vl, ldvl, vr, ldvr, mm, m, work, rwork);
            }
            return (int)mh$.invokeExact(matrix_layout, side, howmny, select, n, s, lds, p, ldp, vl, ldvl, vr, ldvr, mm, m, work, rwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_stgexc_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_stgexc_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_stgexc_work(int matrix_layout, int wantq, int wantz, int n, float *a, int lda, float *b, int ldb, float *q, int ldq, float *z, int ldz, int *ifst, int *ilst, float *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_stgexc_work$descriptor() {
        return LAPACKE_stgexc_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_stgexc_work(int matrix_layout, int wantq, int wantz, int n, float *a, int lda, float *b, int ldb, float *q, int ldq, float *z, int ldz, int *ifst, int *ilst, float *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_stgexc_work$handle() {
        return LAPACKE_stgexc_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_stgexc_work(int matrix_layout, int wantq, int wantz, int n, float *a, int lda, float *b, int ldb, float *q, int ldq, float *z, int ldz, int *ifst, int *ilst, float *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_stgexc_work$address() {
        return LAPACKE_stgexc_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_stgexc_work(int matrix_layout, int wantq, int wantz, int n, float *a, int lda, float *b, int ldb, float *q, int ldq, float *z, int ldz, int *ifst, int *ilst, float *work, int lwork)
     * }
     */
    public static int LAPACKE_stgexc_work(int matrix_layout, int wantq, int wantz, int n, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment q, int ldq, MemorySegment z, int ldz, MemorySegment ifst, MemorySegment ilst, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_stgexc_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_stgexc_work", matrix_layout, wantq, wantz, n, a, lda, b, ldb, q, ldq, z, ldz, ifst, ilst, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, wantq, wantz, n, a, lda, b, ldb, q, ldq, z, ldz, ifst, ilst, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dtgexc_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dtgexc_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dtgexc_work(int matrix_layout, int wantq, int wantz, int n, double *a, int lda, double *b, int ldb, double *q, int ldq, double *z, int ldz, int *ifst, int *ilst, double *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_dtgexc_work$descriptor() {
        return LAPACKE_dtgexc_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dtgexc_work(int matrix_layout, int wantq, int wantz, int n, double *a, int lda, double *b, int ldb, double *q, int ldq, double *z, int ldz, int *ifst, int *ilst, double *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_dtgexc_work$handle() {
        return LAPACKE_dtgexc_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dtgexc_work(int matrix_layout, int wantq, int wantz, int n, double *a, int lda, double *b, int ldb, double *q, int ldq, double *z, int ldz, int *ifst, int *ilst, double *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_dtgexc_work$address() {
        return LAPACKE_dtgexc_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dtgexc_work(int matrix_layout, int wantq, int wantz, int n, double *a, int lda, double *b, int ldb, double *q, int ldq, double *z, int ldz, int *ifst, int *ilst, double *work, int lwork)
     * }
     */
    public static int LAPACKE_dtgexc_work(int matrix_layout, int wantq, int wantz, int n, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment q, int ldq, MemorySegment z, int ldz, MemorySegment ifst, MemorySegment ilst, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_dtgexc_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dtgexc_work", matrix_layout, wantq, wantz, n, a, lda, b, ldb, q, ldq, z, ldz, ifst, ilst, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, wantq, wantz, n, a, lda, b, ldb, q, ldq, z, ldz, ifst, ilst, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ctgexc_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_ctgexc_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ctgexc_work(int matrix_layout, int wantq, int wantz, int n, _Complex float *a, int lda, _Complex float *b, int ldb, _Complex float *q, int ldq, _Complex float *z, int ldz, int ifst, int ilst)
     * }
     */
    public static FunctionDescriptor LAPACKE_ctgexc_work$descriptor() {
        return LAPACKE_ctgexc_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ctgexc_work(int matrix_layout, int wantq, int wantz, int n, _Complex float *a, int lda, _Complex float *b, int ldb, _Complex float *q, int ldq, _Complex float *z, int ldz, int ifst, int ilst)
     * }
     */
    public static MethodHandle LAPACKE_ctgexc_work$handle() {
        return LAPACKE_ctgexc_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ctgexc_work(int matrix_layout, int wantq, int wantz, int n, _Complex float *a, int lda, _Complex float *b, int ldb, _Complex float *q, int ldq, _Complex float *z, int ldz, int ifst, int ilst)
     * }
     */
    public static MemorySegment LAPACKE_ctgexc_work$address() {
        return LAPACKE_ctgexc_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ctgexc_work(int matrix_layout, int wantq, int wantz, int n, _Complex float *a, int lda, _Complex float *b, int ldb, _Complex float *q, int ldq, _Complex float *z, int ldz, int ifst, int ilst)
     * }
     */
    public static int LAPACKE_ctgexc_work(int matrix_layout, int wantq, int wantz, int n, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment q, int ldq, MemorySegment z, int ldz, int ifst, int ilst) {
        var mh$ = LAPACKE_ctgexc_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ctgexc_work", matrix_layout, wantq, wantz, n, a, lda, b, ldb, q, ldq, z, ldz, ifst, ilst);
            }
            return (int)mh$.invokeExact(matrix_layout, wantq, wantz, n, a, lda, b, ldb, q, ldq, z, ldz, ifst, ilst);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ztgexc_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_ztgexc_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ztgexc_work(int matrix_layout, int wantq, int wantz, int n, _Complex double *a, int lda, _Complex double *b, int ldb, _Complex double *q, int ldq, _Complex double *z, int ldz, int ifst, int ilst)
     * }
     */
    public static FunctionDescriptor LAPACKE_ztgexc_work$descriptor() {
        return LAPACKE_ztgexc_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ztgexc_work(int matrix_layout, int wantq, int wantz, int n, _Complex double *a, int lda, _Complex double *b, int ldb, _Complex double *q, int ldq, _Complex double *z, int ldz, int ifst, int ilst)
     * }
     */
    public static MethodHandle LAPACKE_ztgexc_work$handle() {
        return LAPACKE_ztgexc_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ztgexc_work(int matrix_layout, int wantq, int wantz, int n, _Complex double *a, int lda, _Complex double *b, int ldb, _Complex double *q, int ldq, _Complex double *z, int ldz, int ifst, int ilst)
     * }
     */
    public static MemorySegment LAPACKE_ztgexc_work$address() {
        return LAPACKE_ztgexc_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ztgexc_work(int matrix_layout, int wantq, int wantz, int n, _Complex double *a, int lda, _Complex double *b, int ldb, _Complex double *q, int ldq, _Complex double *z, int ldz, int ifst, int ilst)
     * }
     */
    public static int LAPACKE_ztgexc_work(int matrix_layout, int wantq, int wantz, int n, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment q, int ldq, MemorySegment z, int ldz, int ifst, int ilst) {
        var mh$ = LAPACKE_ztgexc_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ztgexc_work", matrix_layout, wantq, wantz, n, a, lda, b, ldb, q, ldq, z, ldz, ifst, ilst);
            }
            return (int)mh$.invokeExact(matrix_layout, wantq, wantz, n, a, lda, b, ldb, q, ldq, z, ldz, ifst, ilst);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_stgsen_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_stgsen_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_stgsen_work(int matrix_layout, int ijob, int wantq, int wantz, const int *select, int n, float *a, int lda, float *b, int ldb, float *alphar, float *alphai, float *beta, float *q, int ldq, float *z, int ldz, int *m, float *pl, float *pr, float *dif, float *work, int lwork, int *iwork, int liwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_stgsen_work$descriptor() {
        return LAPACKE_stgsen_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_stgsen_work(int matrix_layout, int ijob, int wantq, int wantz, const int *select, int n, float *a, int lda, float *b, int ldb, float *alphar, float *alphai, float *beta, float *q, int ldq, float *z, int ldz, int *m, float *pl, float *pr, float *dif, float *work, int lwork, int *iwork, int liwork)
     * }
     */
    public static MethodHandle LAPACKE_stgsen_work$handle() {
        return LAPACKE_stgsen_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_stgsen_work(int matrix_layout, int ijob, int wantq, int wantz, const int *select, int n, float *a, int lda, float *b, int ldb, float *alphar, float *alphai, float *beta, float *q, int ldq, float *z, int ldz, int *m, float *pl, float *pr, float *dif, float *work, int lwork, int *iwork, int liwork)
     * }
     */
    public static MemorySegment LAPACKE_stgsen_work$address() {
        return LAPACKE_stgsen_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_stgsen_work(int matrix_layout, int ijob, int wantq, int wantz, const int *select, int n, float *a, int lda, float *b, int ldb, float *alphar, float *alphai, float *beta, float *q, int ldq, float *z, int ldz, int *m, float *pl, float *pr, float *dif, float *work, int lwork, int *iwork, int liwork)
     * }
     */
    public static int LAPACKE_stgsen_work(int matrix_layout, int ijob, int wantq, int wantz, MemorySegment select, int n, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment alphar, MemorySegment alphai, MemorySegment beta, MemorySegment q, int ldq, MemorySegment z, int ldz, MemorySegment m, MemorySegment pl, MemorySegment pr, MemorySegment dif, MemorySegment work, int lwork, MemorySegment iwork, int liwork) {
        var mh$ = LAPACKE_stgsen_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_stgsen_work", matrix_layout, ijob, wantq, wantz, select, n, a, lda, b, ldb, alphar, alphai, beta, q, ldq, z, ldz, m, pl, pr, dif, work, lwork, iwork, liwork);
            }
            return (int)mh$.invokeExact(matrix_layout, ijob, wantq, wantz, select, n, a, lda, b, ldb, alphar, alphai, beta, q, ldq, z, ldz, m, pl, pr, dif, work, lwork, iwork, liwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dtgsen_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dtgsen_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dtgsen_work(int matrix_layout, int ijob, int wantq, int wantz, const int *select, int n, double *a, int lda, double *b, int ldb, double *alphar, double *alphai, double *beta, double *q, int ldq, double *z, int ldz, int *m, double *pl, double *pr, double *dif, double *work, int lwork, int *iwork, int liwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_dtgsen_work$descriptor() {
        return LAPACKE_dtgsen_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dtgsen_work(int matrix_layout, int ijob, int wantq, int wantz, const int *select, int n, double *a, int lda, double *b, int ldb, double *alphar, double *alphai, double *beta, double *q, int ldq, double *z, int ldz, int *m, double *pl, double *pr, double *dif, double *work, int lwork, int *iwork, int liwork)
     * }
     */
    public static MethodHandle LAPACKE_dtgsen_work$handle() {
        return LAPACKE_dtgsen_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dtgsen_work(int matrix_layout, int ijob, int wantq, int wantz, const int *select, int n, double *a, int lda, double *b, int ldb, double *alphar, double *alphai, double *beta, double *q, int ldq, double *z, int ldz, int *m, double *pl, double *pr, double *dif, double *work, int lwork, int *iwork, int liwork)
     * }
     */
    public static MemorySegment LAPACKE_dtgsen_work$address() {
        return LAPACKE_dtgsen_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dtgsen_work(int matrix_layout, int ijob, int wantq, int wantz, const int *select, int n, double *a, int lda, double *b, int ldb, double *alphar, double *alphai, double *beta, double *q, int ldq, double *z, int ldz, int *m, double *pl, double *pr, double *dif, double *work, int lwork, int *iwork, int liwork)
     * }
     */
    public static int LAPACKE_dtgsen_work(int matrix_layout, int ijob, int wantq, int wantz, MemorySegment select, int n, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment alphar, MemorySegment alphai, MemorySegment beta, MemorySegment q, int ldq, MemorySegment z, int ldz, MemorySegment m, MemorySegment pl, MemorySegment pr, MemorySegment dif, MemorySegment work, int lwork, MemorySegment iwork, int liwork) {
        var mh$ = LAPACKE_dtgsen_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dtgsen_work", matrix_layout, ijob, wantq, wantz, select, n, a, lda, b, ldb, alphar, alphai, beta, q, ldq, z, ldz, m, pl, pr, dif, work, lwork, iwork, liwork);
            }
            return (int)mh$.invokeExact(matrix_layout, ijob, wantq, wantz, select, n, a, lda, b, ldb, alphar, alphai, beta, q, ldq, z, ldz, m, pl, pr, dif, work, lwork, iwork, liwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ctgsen_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_ctgsen_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ctgsen_work(int matrix_layout, int ijob, int wantq, int wantz, const int *select, int n, _Complex float *a, int lda, _Complex float *b, int ldb, _Complex float *alpha, _Complex float *beta, _Complex float *q, int ldq, _Complex float *z, int ldz, int *m, float *pl, float *pr, float *dif, _Complex float *work, int lwork, int *iwork, int liwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_ctgsen_work$descriptor() {
        return LAPACKE_ctgsen_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ctgsen_work(int matrix_layout, int ijob, int wantq, int wantz, const int *select, int n, _Complex float *a, int lda, _Complex float *b, int ldb, _Complex float *alpha, _Complex float *beta, _Complex float *q, int ldq, _Complex float *z, int ldz, int *m, float *pl, float *pr, float *dif, _Complex float *work, int lwork, int *iwork, int liwork)
     * }
     */
    public static MethodHandle LAPACKE_ctgsen_work$handle() {
        return LAPACKE_ctgsen_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ctgsen_work(int matrix_layout, int ijob, int wantq, int wantz, const int *select, int n, _Complex float *a, int lda, _Complex float *b, int ldb, _Complex float *alpha, _Complex float *beta, _Complex float *q, int ldq, _Complex float *z, int ldz, int *m, float *pl, float *pr, float *dif, _Complex float *work, int lwork, int *iwork, int liwork)
     * }
     */
    public static MemorySegment LAPACKE_ctgsen_work$address() {
        return LAPACKE_ctgsen_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ctgsen_work(int matrix_layout, int ijob, int wantq, int wantz, const int *select, int n, _Complex float *a, int lda, _Complex float *b, int ldb, _Complex float *alpha, _Complex float *beta, _Complex float *q, int ldq, _Complex float *z, int ldz, int *m, float *pl, float *pr, float *dif, _Complex float *work, int lwork, int *iwork, int liwork)
     * }
     */
    public static int LAPACKE_ctgsen_work(int matrix_layout, int ijob, int wantq, int wantz, MemorySegment select, int n, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment alpha, MemorySegment beta, MemorySegment q, int ldq, MemorySegment z, int ldz, MemorySegment m, MemorySegment pl, MemorySegment pr, MemorySegment dif, MemorySegment work, int lwork, MemorySegment iwork, int liwork) {
        var mh$ = LAPACKE_ctgsen_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ctgsen_work", matrix_layout, ijob, wantq, wantz, select, n, a, lda, b, ldb, alpha, beta, q, ldq, z, ldz, m, pl, pr, dif, work, lwork, iwork, liwork);
            }
            return (int)mh$.invokeExact(matrix_layout, ijob, wantq, wantz, select, n, a, lda, b, ldb, alpha, beta, q, ldq, z, ldz, m, pl, pr, dif, work, lwork, iwork, liwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ztgsen_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_ztgsen_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ztgsen_work(int matrix_layout, int ijob, int wantq, int wantz, const int *select, int n, _Complex double *a, int lda, _Complex double *b, int ldb, _Complex double *alpha, _Complex double *beta, _Complex double *q, int ldq, _Complex double *z, int ldz, int *m, double *pl, double *pr, double *dif, _Complex double *work, int lwork, int *iwork, int liwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_ztgsen_work$descriptor() {
        return LAPACKE_ztgsen_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ztgsen_work(int matrix_layout, int ijob, int wantq, int wantz, const int *select, int n, _Complex double *a, int lda, _Complex double *b, int ldb, _Complex double *alpha, _Complex double *beta, _Complex double *q, int ldq, _Complex double *z, int ldz, int *m, double *pl, double *pr, double *dif, _Complex double *work, int lwork, int *iwork, int liwork)
     * }
     */
    public static MethodHandle LAPACKE_ztgsen_work$handle() {
        return LAPACKE_ztgsen_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ztgsen_work(int matrix_layout, int ijob, int wantq, int wantz, const int *select, int n, _Complex double *a, int lda, _Complex double *b, int ldb, _Complex double *alpha, _Complex double *beta, _Complex double *q, int ldq, _Complex double *z, int ldz, int *m, double *pl, double *pr, double *dif, _Complex double *work, int lwork, int *iwork, int liwork)
     * }
     */
    public static MemorySegment LAPACKE_ztgsen_work$address() {
        return LAPACKE_ztgsen_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ztgsen_work(int matrix_layout, int ijob, int wantq, int wantz, const int *select, int n, _Complex double *a, int lda, _Complex double *b, int ldb, _Complex double *alpha, _Complex double *beta, _Complex double *q, int ldq, _Complex double *z, int ldz, int *m, double *pl, double *pr, double *dif, _Complex double *work, int lwork, int *iwork, int liwork)
     * }
     */
    public static int LAPACKE_ztgsen_work(int matrix_layout, int ijob, int wantq, int wantz, MemorySegment select, int n, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment alpha, MemorySegment beta, MemorySegment q, int ldq, MemorySegment z, int ldz, MemorySegment m, MemorySegment pl, MemorySegment pr, MemorySegment dif, MemorySegment work, int lwork, MemorySegment iwork, int liwork) {
        var mh$ = LAPACKE_ztgsen_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ztgsen_work", matrix_layout, ijob, wantq, wantz, select, n, a, lda, b, ldb, alpha, beta, q, ldq, z, ldz, m, pl, pr, dif, work, lwork, iwork, liwork);
            }
            return (int)mh$.invokeExact(matrix_layout, ijob, wantq, wantz, select, n, a, lda, b, ldb, alpha, beta, q, ldq, z, ldz, m, pl, pr, dif, work, lwork, iwork, liwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_stgsja_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_FLOAT,
            lapacke_h.C_FLOAT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_stgsja_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_stgsja_work(int matrix_layout, char jobu, char jobv, char jobq, int m, int p, int n, int k, int l, float *a, int lda, float *b, int ldb, float tola, float tolb, float *alpha, float *beta, float *u, int ldu, float *v, int ldv, float *q, int ldq, float *work, int *ncycle)
     * }
     */
    public static FunctionDescriptor LAPACKE_stgsja_work$descriptor() {
        return LAPACKE_stgsja_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_stgsja_work(int matrix_layout, char jobu, char jobv, char jobq, int m, int p, int n, int k, int l, float *a, int lda, float *b, int ldb, float tola, float tolb, float *alpha, float *beta, float *u, int ldu, float *v, int ldv, float *q, int ldq, float *work, int *ncycle)
     * }
     */
    public static MethodHandle LAPACKE_stgsja_work$handle() {
        return LAPACKE_stgsja_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_stgsja_work(int matrix_layout, char jobu, char jobv, char jobq, int m, int p, int n, int k, int l, float *a, int lda, float *b, int ldb, float tola, float tolb, float *alpha, float *beta, float *u, int ldu, float *v, int ldv, float *q, int ldq, float *work, int *ncycle)
     * }
     */
    public static MemorySegment LAPACKE_stgsja_work$address() {
        return LAPACKE_stgsja_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_stgsja_work(int matrix_layout, char jobu, char jobv, char jobq, int m, int p, int n, int k, int l, float *a, int lda, float *b, int ldb, float tola, float tolb, float *alpha, float *beta, float *u, int ldu, float *v, int ldv, float *q, int ldq, float *work, int *ncycle)
     * }
     */
    public static int LAPACKE_stgsja_work(int matrix_layout, byte jobu, byte jobv, byte jobq, int m, int p, int n, int k, int l, MemorySegment a, int lda, MemorySegment b, int ldb, float tola, float tolb, MemorySegment alpha, MemorySegment beta, MemorySegment u, int ldu, MemorySegment v, int ldv, MemorySegment q, int ldq, MemorySegment work, MemorySegment ncycle) {
        var mh$ = LAPACKE_stgsja_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_stgsja_work", matrix_layout, jobu, jobv, jobq, m, p, n, k, l, a, lda, b, ldb, tola, tolb, alpha, beta, u, ldu, v, ldv, q, ldq, work, ncycle);
            }
            return (int)mh$.invokeExact(matrix_layout, jobu, jobv, jobq, m, p, n, k, l, a, lda, b, ldb, tola, tolb, alpha, beta, u, ldu, v, ldv, q, ldq, work, ncycle);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dtgsja_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_DOUBLE,
            lapacke_h.C_DOUBLE,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dtgsja_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dtgsja_work(int matrix_layout, char jobu, char jobv, char jobq, int m, int p, int n, int k, int l, double *a, int lda, double *b, int ldb, double tola, double tolb, double *alpha, double *beta, double *u, int ldu, double *v, int ldv, double *q, int ldq, double *work, int *ncycle)
     * }
     */
    public static FunctionDescriptor LAPACKE_dtgsja_work$descriptor() {
        return LAPACKE_dtgsja_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dtgsja_work(int matrix_layout, char jobu, char jobv, char jobq, int m, int p, int n, int k, int l, double *a, int lda, double *b, int ldb, double tola, double tolb, double *alpha, double *beta, double *u, int ldu, double *v, int ldv, double *q, int ldq, double *work, int *ncycle)
     * }
     */
    public static MethodHandle LAPACKE_dtgsja_work$handle() {
        return LAPACKE_dtgsja_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dtgsja_work(int matrix_layout, char jobu, char jobv, char jobq, int m, int p, int n, int k, int l, double *a, int lda, double *b, int ldb, double tola, double tolb, double *alpha, double *beta, double *u, int ldu, double *v, int ldv, double *q, int ldq, double *work, int *ncycle)
     * }
     */
    public static MemorySegment LAPACKE_dtgsja_work$address() {
        return LAPACKE_dtgsja_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dtgsja_work(int matrix_layout, char jobu, char jobv, char jobq, int m, int p, int n, int k, int l, double *a, int lda, double *b, int ldb, double tola, double tolb, double *alpha, double *beta, double *u, int ldu, double *v, int ldv, double *q, int ldq, double *work, int *ncycle)
     * }
     */
    public static int LAPACKE_dtgsja_work(int matrix_layout, byte jobu, byte jobv, byte jobq, int m, int p, int n, int k, int l, MemorySegment a, int lda, MemorySegment b, int ldb, double tola, double tolb, MemorySegment alpha, MemorySegment beta, MemorySegment u, int ldu, MemorySegment v, int ldv, MemorySegment q, int ldq, MemorySegment work, MemorySegment ncycle) {
        var mh$ = LAPACKE_dtgsja_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dtgsja_work", matrix_layout, jobu, jobv, jobq, m, p, n, k, l, a, lda, b, ldb, tola, tolb, alpha, beta, u, ldu, v, ldv, q, ldq, work, ncycle);
            }
            return (int)mh$.invokeExact(matrix_layout, jobu, jobv, jobq, m, p, n, k, l, a, lda, b, ldb, tola, tolb, alpha, beta, u, ldu, v, ldv, q, ldq, work, ncycle);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ctgsja_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_FLOAT,
            lapacke_h.C_FLOAT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_ctgsja_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ctgsja_work(int matrix_layout, char jobu, char jobv, char jobq, int m, int p, int n, int k, int l, _Complex float *a, int lda, _Complex float *b, int ldb, float tola, float tolb, float *alpha, float *beta, _Complex float *u, int ldu, _Complex float *v, int ldv, _Complex float *q, int ldq, _Complex float *work, int *ncycle)
     * }
     */
    public static FunctionDescriptor LAPACKE_ctgsja_work$descriptor() {
        return LAPACKE_ctgsja_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ctgsja_work(int matrix_layout, char jobu, char jobv, char jobq, int m, int p, int n, int k, int l, _Complex float *a, int lda, _Complex float *b, int ldb, float tola, float tolb, float *alpha, float *beta, _Complex float *u, int ldu, _Complex float *v, int ldv, _Complex float *q, int ldq, _Complex float *work, int *ncycle)
     * }
     */
    public static MethodHandle LAPACKE_ctgsja_work$handle() {
        return LAPACKE_ctgsja_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ctgsja_work(int matrix_layout, char jobu, char jobv, char jobq, int m, int p, int n, int k, int l, _Complex float *a, int lda, _Complex float *b, int ldb, float tola, float tolb, float *alpha, float *beta, _Complex float *u, int ldu, _Complex float *v, int ldv, _Complex float *q, int ldq, _Complex float *work, int *ncycle)
     * }
     */
    public static MemorySegment LAPACKE_ctgsja_work$address() {
        return LAPACKE_ctgsja_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ctgsja_work(int matrix_layout, char jobu, char jobv, char jobq, int m, int p, int n, int k, int l, _Complex float *a, int lda, _Complex float *b, int ldb, float tola, float tolb, float *alpha, float *beta, _Complex float *u, int ldu, _Complex float *v, int ldv, _Complex float *q, int ldq, _Complex float *work, int *ncycle)
     * }
     */
    public static int LAPACKE_ctgsja_work(int matrix_layout, byte jobu, byte jobv, byte jobq, int m, int p, int n, int k, int l, MemorySegment a, int lda, MemorySegment b, int ldb, float tola, float tolb, MemorySegment alpha, MemorySegment beta, MemorySegment u, int ldu, MemorySegment v, int ldv, MemorySegment q, int ldq, MemorySegment work, MemorySegment ncycle) {
        var mh$ = LAPACKE_ctgsja_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ctgsja_work", matrix_layout, jobu, jobv, jobq, m, p, n, k, l, a, lda, b, ldb, tola, tolb, alpha, beta, u, ldu, v, ldv, q, ldq, work, ncycle);
            }
            return (int)mh$.invokeExact(matrix_layout, jobu, jobv, jobq, m, p, n, k, l, a, lda, b, ldb, tola, tolb, alpha, beta, u, ldu, v, ldv, q, ldq, work, ncycle);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ztgsja_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_DOUBLE,
            lapacke_h.C_DOUBLE,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_ztgsja_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ztgsja_work(int matrix_layout, char jobu, char jobv, char jobq, int m, int p, int n, int k, int l, _Complex double *a, int lda, _Complex double *b, int ldb, double tola, double tolb, double *alpha, double *beta, _Complex double *u, int ldu, _Complex double *v, int ldv, _Complex double *q, int ldq, _Complex double *work, int *ncycle)
     * }
     */
    public static FunctionDescriptor LAPACKE_ztgsja_work$descriptor() {
        return LAPACKE_ztgsja_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ztgsja_work(int matrix_layout, char jobu, char jobv, char jobq, int m, int p, int n, int k, int l, _Complex double *a, int lda, _Complex double *b, int ldb, double tola, double tolb, double *alpha, double *beta, _Complex double *u, int ldu, _Complex double *v, int ldv, _Complex double *q, int ldq, _Complex double *work, int *ncycle)
     * }
     */
    public static MethodHandle LAPACKE_ztgsja_work$handle() {
        return LAPACKE_ztgsja_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ztgsja_work(int matrix_layout, char jobu, char jobv, char jobq, int m, int p, int n, int k, int l, _Complex double *a, int lda, _Complex double *b, int ldb, double tola, double tolb, double *alpha, double *beta, _Complex double *u, int ldu, _Complex double *v, int ldv, _Complex double *q, int ldq, _Complex double *work, int *ncycle)
     * }
     */
    public static MemorySegment LAPACKE_ztgsja_work$address() {
        return LAPACKE_ztgsja_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ztgsja_work(int matrix_layout, char jobu, char jobv, char jobq, int m, int p, int n, int k, int l, _Complex double *a, int lda, _Complex double *b, int ldb, double tola, double tolb, double *alpha, double *beta, _Complex double *u, int ldu, _Complex double *v, int ldv, _Complex double *q, int ldq, _Complex double *work, int *ncycle)
     * }
     */
    public static int LAPACKE_ztgsja_work(int matrix_layout, byte jobu, byte jobv, byte jobq, int m, int p, int n, int k, int l, MemorySegment a, int lda, MemorySegment b, int ldb, double tola, double tolb, MemorySegment alpha, MemorySegment beta, MemorySegment u, int ldu, MemorySegment v, int ldv, MemorySegment q, int ldq, MemorySegment work, MemorySegment ncycle) {
        var mh$ = LAPACKE_ztgsja_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ztgsja_work", matrix_layout, jobu, jobv, jobq, m, p, n, k, l, a, lda, b, ldb, tola, tolb, alpha, beta, u, ldu, v, ldv, q, ldq, work, ncycle);
            }
            return (int)mh$.invokeExact(matrix_layout, jobu, jobv, jobq, m, p, n, k, l, a, lda, b, ldb, tola, tolb, alpha, beta, u, ldu, v, ldv, q, ldq, work, ncycle);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_stgsna_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_stgsna_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_stgsna_work(int matrix_layout, char job, char howmny, const int *select, int n, const float *a, int lda, const float *b, int ldb, const float *vl, int ldvl, const float *vr, int ldvr, float *s, float *dif, int mm, int *m, float *work, int lwork, int *iwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_stgsna_work$descriptor() {
        return LAPACKE_stgsna_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_stgsna_work(int matrix_layout, char job, char howmny, const int *select, int n, const float *a, int lda, const float *b, int ldb, const float *vl, int ldvl, const float *vr, int ldvr, float *s, float *dif, int mm, int *m, float *work, int lwork, int *iwork)
     * }
     */
    public static MethodHandle LAPACKE_stgsna_work$handle() {
        return LAPACKE_stgsna_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_stgsna_work(int matrix_layout, char job, char howmny, const int *select, int n, const float *a, int lda, const float *b, int ldb, const float *vl, int ldvl, const float *vr, int ldvr, float *s, float *dif, int mm, int *m, float *work, int lwork, int *iwork)
     * }
     */
    public static MemorySegment LAPACKE_stgsna_work$address() {
        return LAPACKE_stgsna_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_stgsna_work(int matrix_layout, char job, char howmny, const int *select, int n, const float *a, int lda, const float *b, int ldb, const float *vl, int ldvl, const float *vr, int ldvr, float *s, float *dif, int mm, int *m, float *work, int lwork, int *iwork)
     * }
     */
    public static int LAPACKE_stgsna_work(int matrix_layout, byte job, byte howmny, MemorySegment select, int n, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment vl, int ldvl, MemorySegment vr, int ldvr, MemorySegment s, MemorySegment dif, int mm, MemorySegment m, MemorySegment work, int lwork, MemorySegment iwork) {
        var mh$ = LAPACKE_stgsna_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_stgsna_work", matrix_layout, job, howmny, select, n, a, lda, b, ldb, vl, ldvl, vr, ldvr, s, dif, mm, m, work, lwork, iwork);
            }
            return (int)mh$.invokeExact(matrix_layout, job, howmny, select, n, a, lda, b, ldb, vl, ldvl, vr, ldvr, s, dif, mm, m, work, lwork, iwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dtgsna_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dtgsna_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dtgsna_work(int matrix_layout, char job, char howmny, const int *select, int n, const double *a, int lda, const double *b, int ldb, const double *vl, int ldvl, const double *vr, int ldvr, double *s, double *dif, int mm, int *m, double *work, int lwork, int *iwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_dtgsna_work$descriptor() {
        return LAPACKE_dtgsna_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dtgsna_work(int matrix_layout, char job, char howmny, const int *select, int n, const double *a, int lda, const double *b, int ldb, const double *vl, int ldvl, const double *vr, int ldvr, double *s, double *dif, int mm, int *m, double *work, int lwork, int *iwork)
     * }
     */
    public static MethodHandle LAPACKE_dtgsna_work$handle() {
        return LAPACKE_dtgsna_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dtgsna_work(int matrix_layout, char job, char howmny, const int *select, int n, const double *a, int lda, const double *b, int ldb, const double *vl, int ldvl, const double *vr, int ldvr, double *s, double *dif, int mm, int *m, double *work, int lwork, int *iwork)
     * }
     */
    public static MemorySegment LAPACKE_dtgsna_work$address() {
        return LAPACKE_dtgsna_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dtgsna_work(int matrix_layout, char job, char howmny, const int *select, int n, const double *a, int lda, const double *b, int ldb, const double *vl, int ldvl, const double *vr, int ldvr, double *s, double *dif, int mm, int *m, double *work, int lwork, int *iwork)
     * }
     */
    public static int LAPACKE_dtgsna_work(int matrix_layout, byte job, byte howmny, MemorySegment select, int n, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment vl, int ldvl, MemorySegment vr, int ldvr, MemorySegment s, MemorySegment dif, int mm, MemorySegment m, MemorySegment work, int lwork, MemorySegment iwork) {
        var mh$ = LAPACKE_dtgsna_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dtgsna_work", matrix_layout, job, howmny, select, n, a, lda, b, ldb, vl, ldvl, vr, ldvr, s, dif, mm, m, work, lwork, iwork);
            }
            return (int)mh$.invokeExact(matrix_layout, job, howmny, select, n, a, lda, b, ldb, vl, ldvl, vr, ldvr, s, dif, mm, m, work, lwork, iwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ctgsna_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_ctgsna_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ctgsna_work(int matrix_layout, char job, char howmny, const int *select, int n, const _Complex float *a, int lda, const _Complex float *b, int ldb, const _Complex float *vl, int ldvl, const _Complex float *vr, int ldvr, float *s, float *dif, int mm, int *m, _Complex float *work, int lwork, int *iwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_ctgsna_work$descriptor() {
        return LAPACKE_ctgsna_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ctgsna_work(int matrix_layout, char job, char howmny, const int *select, int n, const _Complex float *a, int lda, const _Complex float *b, int ldb, const _Complex float *vl, int ldvl, const _Complex float *vr, int ldvr, float *s, float *dif, int mm, int *m, _Complex float *work, int lwork, int *iwork)
     * }
     */
    public static MethodHandle LAPACKE_ctgsna_work$handle() {
        return LAPACKE_ctgsna_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ctgsna_work(int matrix_layout, char job, char howmny, const int *select, int n, const _Complex float *a, int lda, const _Complex float *b, int ldb, const _Complex float *vl, int ldvl, const _Complex float *vr, int ldvr, float *s, float *dif, int mm, int *m, _Complex float *work, int lwork, int *iwork)
     * }
     */
    public static MemorySegment LAPACKE_ctgsna_work$address() {
        return LAPACKE_ctgsna_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ctgsna_work(int matrix_layout, char job, char howmny, const int *select, int n, const _Complex float *a, int lda, const _Complex float *b, int ldb, const _Complex float *vl, int ldvl, const _Complex float *vr, int ldvr, float *s, float *dif, int mm, int *m, _Complex float *work, int lwork, int *iwork)
     * }
     */
    public static int LAPACKE_ctgsna_work(int matrix_layout, byte job, byte howmny, MemorySegment select, int n, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment vl, int ldvl, MemorySegment vr, int ldvr, MemorySegment s, MemorySegment dif, int mm, MemorySegment m, MemorySegment work, int lwork, MemorySegment iwork) {
        var mh$ = LAPACKE_ctgsna_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ctgsna_work", matrix_layout, job, howmny, select, n, a, lda, b, ldb, vl, ldvl, vr, ldvr, s, dif, mm, m, work, lwork, iwork);
            }
            return (int)mh$.invokeExact(matrix_layout, job, howmny, select, n, a, lda, b, ldb, vl, ldvl, vr, ldvr, s, dif, mm, m, work, lwork, iwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ztgsna_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_ztgsna_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ztgsna_work(int matrix_layout, char job, char howmny, const int *select, int n, const _Complex double *a, int lda, const _Complex double *b, int ldb, const _Complex double *vl, int ldvl, const _Complex double *vr, int ldvr, double *s, double *dif, int mm, int *m, _Complex double *work, int lwork, int *iwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_ztgsna_work$descriptor() {
        return LAPACKE_ztgsna_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ztgsna_work(int matrix_layout, char job, char howmny, const int *select, int n, const _Complex double *a, int lda, const _Complex double *b, int ldb, const _Complex double *vl, int ldvl, const _Complex double *vr, int ldvr, double *s, double *dif, int mm, int *m, _Complex double *work, int lwork, int *iwork)
     * }
     */
    public static MethodHandle LAPACKE_ztgsna_work$handle() {
        return LAPACKE_ztgsna_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ztgsna_work(int matrix_layout, char job, char howmny, const int *select, int n, const _Complex double *a, int lda, const _Complex double *b, int ldb, const _Complex double *vl, int ldvl, const _Complex double *vr, int ldvr, double *s, double *dif, int mm, int *m, _Complex double *work, int lwork, int *iwork)
     * }
     */
    public static MemorySegment LAPACKE_ztgsna_work$address() {
        return LAPACKE_ztgsna_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ztgsna_work(int matrix_layout, char job, char howmny, const int *select, int n, const _Complex double *a, int lda, const _Complex double *b, int ldb, const _Complex double *vl, int ldvl, const _Complex double *vr, int ldvr, double *s, double *dif, int mm, int *m, _Complex double *work, int lwork, int *iwork)
     * }
     */
    public static int LAPACKE_ztgsna_work(int matrix_layout, byte job, byte howmny, MemorySegment select, int n, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment vl, int ldvl, MemorySegment vr, int ldvr, MemorySegment s, MemorySegment dif, int mm, MemorySegment m, MemorySegment work, int lwork, MemorySegment iwork) {
        var mh$ = LAPACKE_ztgsna_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ztgsna_work", matrix_layout, job, howmny, select, n, a, lda, b, ldb, vl, ldvl, vr, ldvr, s, dif, mm, m, work, lwork, iwork);
            }
            return (int)mh$.invokeExact(matrix_layout, job, howmny, select, n, a, lda, b, ldb, vl, ldvl, vr, ldvr, s, dif, mm, m, work, lwork, iwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_stgsyl_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_stgsyl_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_stgsyl_work(int matrix_layout, char trans, int ijob, int m, int n, const float *a, int lda, const float *b, int ldb, float *c, int ldc, const float *d, int ldd, const float *e, int lde, float *f, int ldf, float *scale, float *dif, float *work, int lwork, int *iwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_stgsyl_work$descriptor() {
        return LAPACKE_stgsyl_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_stgsyl_work(int matrix_layout, char trans, int ijob, int m, int n, const float *a, int lda, const float *b, int ldb, float *c, int ldc, const float *d, int ldd, const float *e, int lde, float *f, int ldf, float *scale, float *dif, float *work, int lwork, int *iwork)
     * }
     */
    public static MethodHandle LAPACKE_stgsyl_work$handle() {
        return LAPACKE_stgsyl_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_stgsyl_work(int matrix_layout, char trans, int ijob, int m, int n, const float *a, int lda, const float *b, int ldb, float *c, int ldc, const float *d, int ldd, const float *e, int lde, float *f, int ldf, float *scale, float *dif, float *work, int lwork, int *iwork)
     * }
     */
    public static MemorySegment LAPACKE_stgsyl_work$address() {
        return LAPACKE_stgsyl_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_stgsyl_work(int matrix_layout, char trans, int ijob, int m, int n, const float *a, int lda, const float *b, int ldb, float *c, int ldc, const float *d, int ldd, const float *e, int lde, float *f, int ldf, float *scale, float *dif, float *work, int lwork, int *iwork)
     * }
     */
    public static int LAPACKE_stgsyl_work(int matrix_layout, byte trans, int ijob, int m, int n, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment c, int ldc, MemorySegment d, int ldd, MemorySegment e, int lde, MemorySegment f, int ldf, MemorySegment scale, MemorySegment dif, MemorySegment work, int lwork, MemorySegment iwork) {
        var mh$ = LAPACKE_stgsyl_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_stgsyl_work", matrix_layout, trans, ijob, m, n, a, lda, b, ldb, c, ldc, d, ldd, e, lde, f, ldf, scale, dif, work, lwork, iwork);
            }
            return (int)mh$.invokeExact(matrix_layout, trans, ijob, m, n, a, lda, b, ldb, c, ldc, d, ldd, e, lde, f, ldf, scale, dif, work, lwork, iwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dtgsyl_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dtgsyl_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dtgsyl_work(int matrix_layout, char trans, int ijob, int m, int n, const double *a, int lda, const double *b, int ldb, double *c, int ldc, const double *d, int ldd, const double *e, int lde, double *f, int ldf, double *scale, double *dif, double *work, int lwork, int *iwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_dtgsyl_work$descriptor() {
        return LAPACKE_dtgsyl_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dtgsyl_work(int matrix_layout, char trans, int ijob, int m, int n, const double *a, int lda, const double *b, int ldb, double *c, int ldc, const double *d, int ldd, const double *e, int lde, double *f, int ldf, double *scale, double *dif, double *work, int lwork, int *iwork)
     * }
     */
    public static MethodHandle LAPACKE_dtgsyl_work$handle() {
        return LAPACKE_dtgsyl_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dtgsyl_work(int matrix_layout, char trans, int ijob, int m, int n, const double *a, int lda, const double *b, int ldb, double *c, int ldc, const double *d, int ldd, const double *e, int lde, double *f, int ldf, double *scale, double *dif, double *work, int lwork, int *iwork)
     * }
     */
    public static MemorySegment LAPACKE_dtgsyl_work$address() {
        return LAPACKE_dtgsyl_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dtgsyl_work(int matrix_layout, char trans, int ijob, int m, int n, const double *a, int lda, const double *b, int ldb, double *c, int ldc, const double *d, int ldd, const double *e, int lde, double *f, int ldf, double *scale, double *dif, double *work, int lwork, int *iwork)
     * }
     */
    public static int LAPACKE_dtgsyl_work(int matrix_layout, byte trans, int ijob, int m, int n, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment c, int ldc, MemorySegment d, int ldd, MemorySegment e, int lde, MemorySegment f, int ldf, MemorySegment scale, MemorySegment dif, MemorySegment work, int lwork, MemorySegment iwork) {
        var mh$ = LAPACKE_dtgsyl_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dtgsyl_work", matrix_layout, trans, ijob, m, n, a, lda, b, ldb, c, ldc, d, ldd, e, lde, f, ldf, scale, dif, work, lwork, iwork);
            }
            return (int)mh$.invokeExact(matrix_layout, trans, ijob, m, n, a, lda, b, ldb, c, ldc, d, ldd, e, lde, f, ldf, scale, dif, work, lwork, iwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ctgsyl_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_ctgsyl_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ctgsyl_work(int matrix_layout, char trans, int ijob, int m, int n, const _Complex float *a, int lda, const _Complex float *b, int ldb, _Complex float *c, int ldc, const _Complex float *d, int ldd, const _Complex float *e, int lde, _Complex float *f, int ldf, float *scale, float *dif, _Complex float *work, int lwork, int *iwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_ctgsyl_work$descriptor() {
        return LAPACKE_ctgsyl_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ctgsyl_work(int matrix_layout, char trans, int ijob, int m, int n, const _Complex float *a, int lda, const _Complex float *b, int ldb, _Complex float *c, int ldc, const _Complex float *d, int ldd, const _Complex float *e, int lde, _Complex float *f, int ldf, float *scale, float *dif, _Complex float *work, int lwork, int *iwork)
     * }
     */
    public static MethodHandle LAPACKE_ctgsyl_work$handle() {
        return LAPACKE_ctgsyl_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ctgsyl_work(int matrix_layout, char trans, int ijob, int m, int n, const _Complex float *a, int lda, const _Complex float *b, int ldb, _Complex float *c, int ldc, const _Complex float *d, int ldd, const _Complex float *e, int lde, _Complex float *f, int ldf, float *scale, float *dif, _Complex float *work, int lwork, int *iwork)
     * }
     */
    public static MemorySegment LAPACKE_ctgsyl_work$address() {
        return LAPACKE_ctgsyl_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ctgsyl_work(int matrix_layout, char trans, int ijob, int m, int n, const _Complex float *a, int lda, const _Complex float *b, int ldb, _Complex float *c, int ldc, const _Complex float *d, int ldd, const _Complex float *e, int lde, _Complex float *f, int ldf, float *scale, float *dif, _Complex float *work, int lwork, int *iwork)
     * }
     */
    public static int LAPACKE_ctgsyl_work(int matrix_layout, byte trans, int ijob, int m, int n, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment c, int ldc, MemorySegment d, int ldd, MemorySegment e, int lde, MemorySegment f, int ldf, MemorySegment scale, MemorySegment dif, MemorySegment work, int lwork, MemorySegment iwork) {
        var mh$ = LAPACKE_ctgsyl_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ctgsyl_work", matrix_layout, trans, ijob, m, n, a, lda, b, ldb, c, ldc, d, ldd, e, lde, f, ldf, scale, dif, work, lwork, iwork);
            }
            return (int)mh$.invokeExact(matrix_layout, trans, ijob, m, n, a, lda, b, ldb, c, ldc, d, ldd, e, lde, f, ldf, scale, dif, work, lwork, iwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ztgsyl_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_ztgsyl_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ztgsyl_work(int matrix_layout, char trans, int ijob, int m, int n, const _Complex double *a, int lda, const _Complex double *b, int ldb, _Complex double *c, int ldc, const _Complex double *d, int ldd, const _Complex double *e, int lde, _Complex double *f, int ldf, double *scale, double *dif, _Complex double *work, int lwork, int *iwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_ztgsyl_work$descriptor() {
        return LAPACKE_ztgsyl_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ztgsyl_work(int matrix_layout, char trans, int ijob, int m, int n, const _Complex double *a, int lda, const _Complex double *b, int ldb, _Complex double *c, int ldc, const _Complex double *d, int ldd, const _Complex double *e, int lde, _Complex double *f, int ldf, double *scale, double *dif, _Complex double *work, int lwork, int *iwork)
     * }
     */
    public static MethodHandle LAPACKE_ztgsyl_work$handle() {
        return LAPACKE_ztgsyl_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ztgsyl_work(int matrix_layout, char trans, int ijob, int m, int n, const _Complex double *a, int lda, const _Complex double *b, int ldb, _Complex double *c, int ldc, const _Complex double *d, int ldd, const _Complex double *e, int lde, _Complex double *f, int ldf, double *scale, double *dif, _Complex double *work, int lwork, int *iwork)
     * }
     */
    public static MemorySegment LAPACKE_ztgsyl_work$address() {
        return LAPACKE_ztgsyl_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ztgsyl_work(int matrix_layout, char trans, int ijob, int m, int n, const _Complex double *a, int lda, const _Complex double *b, int ldb, _Complex double *c, int ldc, const _Complex double *d, int ldd, const _Complex double *e, int lde, _Complex double *f, int ldf, double *scale, double *dif, _Complex double *work, int lwork, int *iwork)
     * }
     */
    public static int LAPACKE_ztgsyl_work(int matrix_layout, byte trans, int ijob, int m, int n, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment c, int ldc, MemorySegment d, int ldd, MemorySegment e, int lde, MemorySegment f, int ldf, MemorySegment scale, MemorySegment dif, MemorySegment work, int lwork, MemorySegment iwork) {
        var mh$ = LAPACKE_ztgsyl_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ztgsyl_work", matrix_layout, trans, ijob, m, n, a, lda, b, ldb, c, ldc, d, ldd, e, lde, f, ldf, scale, dif, work, lwork, iwork);
            }
            return (int)mh$.invokeExact(matrix_layout, trans, ijob, m, n, a, lda, b, ldb, c, ldc, d, ldd, e, lde, f, ldf, scale, dif, work, lwork, iwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_stpcon_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_stpcon_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_stpcon_work(int matrix_layout, char norm, char uplo, char diag, int n, const float *ap, float *rcond, float *work, int *iwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_stpcon_work$descriptor() {
        return LAPACKE_stpcon_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_stpcon_work(int matrix_layout, char norm, char uplo, char diag, int n, const float *ap, float *rcond, float *work, int *iwork)
     * }
     */
    public static MethodHandle LAPACKE_stpcon_work$handle() {
        return LAPACKE_stpcon_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_stpcon_work(int matrix_layout, char norm, char uplo, char diag, int n, const float *ap, float *rcond, float *work, int *iwork)
     * }
     */
    public static MemorySegment LAPACKE_stpcon_work$address() {
        return LAPACKE_stpcon_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_stpcon_work(int matrix_layout, char norm, char uplo, char diag, int n, const float *ap, float *rcond, float *work, int *iwork)
     * }
     */
    public static int LAPACKE_stpcon_work(int matrix_layout, byte norm, byte uplo, byte diag, int n, MemorySegment ap, MemorySegment rcond, MemorySegment work, MemorySegment iwork) {
        var mh$ = LAPACKE_stpcon_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_stpcon_work", matrix_layout, norm, uplo, diag, n, ap, rcond, work, iwork);
            }
            return (int)mh$.invokeExact(matrix_layout, norm, uplo, diag, n, ap, rcond, work, iwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dtpcon_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dtpcon_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dtpcon_work(int matrix_layout, char norm, char uplo, char diag, int n, const double *ap, double *rcond, double *work, int *iwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_dtpcon_work$descriptor() {
        return LAPACKE_dtpcon_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dtpcon_work(int matrix_layout, char norm, char uplo, char diag, int n, const double *ap, double *rcond, double *work, int *iwork)
     * }
     */
    public static MethodHandle LAPACKE_dtpcon_work$handle() {
        return LAPACKE_dtpcon_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dtpcon_work(int matrix_layout, char norm, char uplo, char diag, int n, const double *ap, double *rcond, double *work, int *iwork)
     * }
     */
    public static MemorySegment LAPACKE_dtpcon_work$address() {
        return LAPACKE_dtpcon_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dtpcon_work(int matrix_layout, char norm, char uplo, char diag, int n, const double *ap, double *rcond, double *work, int *iwork)
     * }
     */
    public static int LAPACKE_dtpcon_work(int matrix_layout, byte norm, byte uplo, byte diag, int n, MemorySegment ap, MemorySegment rcond, MemorySegment work, MemorySegment iwork) {
        var mh$ = LAPACKE_dtpcon_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dtpcon_work", matrix_layout, norm, uplo, diag, n, ap, rcond, work, iwork);
            }
            return (int)mh$.invokeExact(matrix_layout, norm, uplo, diag, n, ap, rcond, work, iwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ctpcon_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_ctpcon_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ctpcon_work(int matrix_layout, char norm, char uplo, char diag, int n, const _Complex float *ap, float *rcond, _Complex float *work, float *rwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_ctpcon_work$descriptor() {
        return LAPACKE_ctpcon_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ctpcon_work(int matrix_layout, char norm, char uplo, char diag, int n, const _Complex float *ap, float *rcond, _Complex float *work, float *rwork)
     * }
     */
    public static MethodHandle LAPACKE_ctpcon_work$handle() {
        return LAPACKE_ctpcon_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ctpcon_work(int matrix_layout, char norm, char uplo, char diag, int n, const _Complex float *ap, float *rcond, _Complex float *work, float *rwork)
     * }
     */
    public static MemorySegment LAPACKE_ctpcon_work$address() {
        return LAPACKE_ctpcon_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ctpcon_work(int matrix_layout, char norm, char uplo, char diag, int n, const _Complex float *ap, float *rcond, _Complex float *work, float *rwork)
     * }
     */
    public static int LAPACKE_ctpcon_work(int matrix_layout, byte norm, byte uplo, byte diag, int n, MemorySegment ap, MemorySegment rcond, MemorySegment work, MemorySegment rwork) {
        var mh$ = LAPACKE_ctpcon_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ctpcon_work", matrix_layout, norm, uplo, diag, n, ap, rcond, work, rwork);
            }
            return (int)mh$.invokeExact(matrix_layout, norm, uplo, diag, n, ap, rcond, work, rwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ztpcon_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_ztpcon_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ztpcon_work(int matrix_layout, char norm, char uplo, char diag, int n, const _Complex double *ap, double *rcond, _Complex double *work, double *rwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_ztpcon_work$descriptor() {
        return LAPACKE_ztpcon_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ztpcon_work(int matrix_layout, char norm, char uplo, char diag, int n, const _Complex double *ap, double *rcond, _Complex double *work, double *rwork)
     * }
     */
    public static MethodHandle LAPACKE_ztpcon_work$handle() {
        return LAPACKE_ztpcon_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ztpcon_work(int matrix_layout, char norm, char uplo, char diag, int n, const _Complex double *ap, double *rcond, _Complex double *work, double *rwork)
     * }
     */
    public static MemorySegment LAPACKE_ztpcon_work$address() {
        return LAPACKE_ztpcon_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ztpcon_work(int matrix_layout, char norm, char uplo, char diag, int n, const _Complex double *ap, double *rcond, _Complex double *work, double *rwork)
     * }
     */
    public static int LAPACKE_ztpcon_work(int matrix_layout, byte norm, byte uplo, byte diag, int n, MemorySegment ap, MemorySegment rcond, MemorySegment work, MemorySegment rwork) {
        var mh$ = LAPACKE_ztpcon_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ztpcon_work", matrix_layout, norm, uplo, diag, n, ap, rcond, work, rwork);
            }
            return (int)mh$.invokeExact(matrix_layout, norm, uplo, diag, n, ap, rcond, work, rwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_stprfs_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_stprfs_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_stprfs_work(int matrix_layout, char uplo, char trans, char diag, int n, int nrhs, const float *ap, const float *b, int ldb, const float *x, int ldx, float *ferr, float *berr, float *work, int *iwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_stprfs_work$descriptor() {
        return LAPACKE_stprfs_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_stprfs_work(int matrix_layout, char uplo, char trans, char diag, int n, int nrhs, const float *ap, const float *b, int ldb, const float *x, int ldx, float *ferr, float *berr, float *work, int *iwork)
     * }
     */
    public static MethodHandle LAPACKE_stprfs_work$handle() {
        return LAPACKE_stprfs_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_stprfs_work(int matrix_layout, char uplo, char trans, char diag, int n, int nrhs, const float *ap, const float *b, int ldb, const float *x, int ldx, float *ferr, float *berr, float *work, int *iwork)
     * }
     */
    public static MemorySegment LAPACKE_stprfs_work$address() {
        return LAPACKE_stprfs_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_stprfs_work(int matrix_layout, char uplo, char trans, char diag, int n, int nrhs, const float *ap, const float *b, int ldb, const float *x, int ldx, float *ferr, float *berr, float *work, int *iwork)
     * }
     */
    public static int LAPACKE_stprfs_work(int matrix_layout, byte uplo, byte trans, byte diag, int n, int nrhs, MemorySegment ap, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment ferr, MemorySegment berr, MemorySegment work, MemorySegment iwork) {
        var mh$ = LAPACKE_stprfs_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_stprfs_work", matrix_layout, uplo, trans, diag, n, nrhs, ap, b, ldb, x, ldx, ferr, berr, work, iwork);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, trans, diag, n, nrhs, ap, b, ldb, x, ldx, ferr, berr, work, iwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dtprfs_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dtprfs_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dtprfs_work(int matrix_layout, char uplo, char trans, char diag, int n, int nrhs, const double *ap, const double *b, int ldb, const double *x, int ldx, double *ferr, double *berr, double *work, int *iwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_dtprfs_work$descriptor() {
        return LAPACKE_dtprfs_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dtprfs_work(int matrix_layout, char uplo, char trans, char diag, int n, int nrhs, const double *ap, const double *b, int ldb, const double *x, int ldx, double *ferr, double *berr, double *work, int *iwork)
     * }
     */
    public static MethodHandle LAPACKE_dtprfs_work$handle() {
        return LAPACKE_dtprfs_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dtprfs_work(int matrix_layout, char uplo, char trans, char diag, int n, int nrhs, const double *ap, const double *b, int ldb, const double *x, int ldx, double *ferr, double *berr, double *work, int *iwork)
     * }
     */
    public static MemorySegment LAPACKE_dtprfs_work$address() {
        return LAPACKE_dtprfs_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dtprfs_work(int matrix_layout, char uplo, char trans, char diag, int n, int nrhs, const double *ap, const double *b, int ldb, const double *x, int ldx, double *ferr, double *berr, double *work, int *iwork)
     * }
     */
    public static int LAPACKE_dtprfs_work(int matrix_layout, byte uplo, byte trans, byte diag, int n, int nrhs, MemorySegment ap, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment ferr, MemorySegment berr, MemorySegment work, MemorySegment iwork) {
        var mh$ = LAPACKE_dtprfs_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dtprfs_work", matrix_layout, uplo, trans, diag, n, nrhs, ap, b, ldb, x, ldx, ferr, berr, work, iwork);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, trans, diag, n, nrhs, ap, b, ldb, x, ldx, ferr, berr, work, iwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ctprfs_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_ctprfs_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ctprfs_work(int matrix_layout, char uplo, char trans, char diag, int n, int nrhs, const _Complex float *ap, const _Complex float *b, int ldb, const _Complex float *x, int ldx, float *ferr, float *berr, _Complex float *work, float *rwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_ctprfs_work$descriptor() {
        return LAPACKE_ctprfs_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ctprfs_work(int matrix_layout, char uplo, char trans, char diag, int n, int nrhs, const _Complex float *ap, const _Complex float *b, int ldb, const _Complex float *x, int ldx, float *ferr, float *berr, _Complex float *work, float *rwork)
     * }
     */
    public static MethodHandle LAPACKE_ctprfs_work$handle() {
        return LAPACKE_ctprfs_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ctprfs_work(int matrix_layout, char uplo, char trans, char diag, int n, int nrhs, const _Complex float *ap, const _Complex float *b, int ldb, const _Complex float *x, int ldx, float *ferr, float *berr, _Complex float *work, float *rwork)
     * }
     */
    public static MemorySegment LAPACKE_ctprfs_work$address() {
        return LAPACKE_ctprfs_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ctprfs_work(int matrix_layout, char uplo, char trans, char diag, int n, int nrhs, const _Complex float *ap, const _Complex float *b, int ldb, const _Complex float *x, int ldx, float *ferr, float *berr, _Complex float *work, float *rwork)
     * }
     */
    public static int LAPACKE_ctprfs_work(int matrix_layout, byte uplo, byte trans, byte diag, int n, int nrhs, MemorySegment ap, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment ferr, MemorySegment berr, MemorySegment work, MemorySegment rwork) {
        var mh$ = LAPACKE_ctprfs_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ctprfs_work", matrix_layout, uplo, trans, diag, n, nrhs, ap, b, ldb, x, ldx, ferr, berr, work, rwork);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, trans, diag, n, nrhs, ap, b, ldb, x, ldx, ferr, berr, work, rwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ztprfs_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_ztprfs_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ztprfs_work(int matrix_layout, char uplo, char trans, char diag, int n, int nrhs, const _Complex double *ap, const _Complex double *b, int ldb, const _Complex double *x, int ldx, double *ferr, double *berr, _Complex double *work, double *rwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_ztprfs_work$descriptor() {
        return LAPACKE_ztprfs_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ztprfs_work(int matrix_layout, char uplo, char trans, char diag, int n, int nrhs, const _Complex double *ap, const _Complex double *b, int ldb, const _Complex double *x, int ldx, double *ferr, double *berr, _Complex double *work, double *rwork)
     * }
     */
    public static MethodHandle LAPACKE_ztprfs_work$handle() {
        return LAPACKE_ztprfs_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ztprfs_work(int matrix_layout, char uplo, char trans, char diag, int n, int nrhs, const _Complex double *ap, const _Complex double *b, int ldb, const _Complex double *x, int ldx, double *ferr, double *berr, _Complex double *work, double *rwork)
     * }
     */
    public static MemorySegment LAPACKE_ztprfs_work$address() {
        return LAPACKE_ztprfs_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ztprfs_work(int matrix_layout, char uplo, char trans, char diag, int n, int nrhs, const _Complex double *ap, const _Complex double *b, int ldb, const _Complex double *x, int ldx, double *ferr, double *berr, _Complex double *work, double *rwork)
     * }
     */
    public static int LAPACKE_ztprfs_work(int matrix_layout, byte uplo, byte trans, byte diag, int n, int nrhs, MemorySegment ap, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment ferr, MemorySegment berr, MemorySegment work, MemorySegment rwork) {
        var mh$ = LAPACKE_ztprfs_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ztprfs_work", matrix_layout, uplo, trans, diag, n, nrhs, ap, b, ldb, x, ldx, ferr, berr, work, rwork);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, trans, diag, n, nrhs, ap, b, ldb, x, ldx, ferr, berr, work, rwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_stptri_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_stptri_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_stptri_work(int matrix_layout, char uplo, char diag, int n, float *ap)
     * }
     */
    public static FunctionDescriptor LAPACKE_stptri_work$descriptor() {
        return LAPACKE_stptri_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_stptri_work(int matrix_layout, char uplo, char diag, int n, float *ap)
     * }
     */
    public static MethodHandle LAPACKE_stptri_work$handle() {
        return LAPACKE_stptri_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_stptri_work(int matrix_layout, char uplo, char diag, int n, float *ap)
     * }
     */
    public static MemorySegment LAPACKE_stptri_work$address() {
        return LAPACKE_stptri_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_stptri_work(int matrix_layout, char uplo, char diag, int n, float *ap)
     * }
     */
    public static int LAPACKE_stptri_work(int matrix_layout, byte uplo, byte diag, int n, MemorySegment ap) {
        var mh$ = LAPACKE_stptri_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_stptri_work", matrix_layout, uplo, diag, n, ap);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, diag, n, ap);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dtptri_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dtptri_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dtptri_work(int matrix_layout, char uplo, char diag, int n, double *ap)
     * }
     */
    public static FunctionDescriptor LAPACKE_dtptri_work$descriptor() {
        return LAPACKE_dtptri_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dtptri_work(int matrix_layout, char uplo, char diag, int n, double *ap)
     * }
     */
    public static MethodHandle LAPACKE_dtptri_work$handle() {
        return LAPACKE_dtptri_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dtptri_work(int matrix_layout, char uplo, char diag, int n, double *ap)
     * }
     */
    public static MemorySegment LAPACKE_dtptri_work$address() {
        return LAPACKE_dtptri_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dtptri_work(int matrix_layout, char uplo, char diag, int n, double *ap)
     * }
     */
    public static int LAPACKE_dtptri_work(int matrix_layout, byte uplo, byte diag, int n, MemorySegment ap) {
        var mh$ = LAPACKE_dtptri_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dtptri_work", matrix_layout, uplo, diag, n, ap);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, diag, n, ap);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ctptri_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_ctptri_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ctptri_work(int matrix_layout, char uplo, char diag, int n, _Complex float *ap)
     * }
     */
    public static FunctionDescriptor LAPACKE_ctptri_work$descriptor() {
        return LAPACKE_ctptri_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ctptri_work(int matrix_layout, char uplo, char diag, int n, _Complex float *ap)
     * }
     */
    public static MethodHandle LAPACKE_ctptri_work$handle() {
        return LAPACKE_ctptri_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ctptri_work(int matrix_layout, char uplo, char diag, int n, _Complex float *ap)
     * }
     */
    public static MemorySegment LAPACKE_ctptri_work$address() {
        return LAPACKE_ctptri_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ctptri_work(int matrix_layout, char uplo, char diag, int n, _Complex float *ap)
     * }
     */
    public static int LAPACKE_ctptri_work(int matrix_layout, byte uplo, byte diag, int n, MemorySegment ap) {
        var mh$ = LAPACKE_ctptri_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ctptri_work", matrix_layout, uplo, diag, n, ap);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, diag, n, ap);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ztptri_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_ztptri_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ztptri_work(int matrix_layout, char uplo, char diag, int n, _Complex double *ap)
     * }
     */
    public static FunctionDescriptor LAPACKE_ztptri_work$descriptor() {
        return LAPACKE_ztptri_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ztptri_work(int matrix_layout, char uplo, char diag, int n, _Complex double *ap)
     * }
     */
    public static MethodHandle LAPACKE_ztptri_work$handle() {
        return LAPACKE_ztptri_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ztptri_work(int matrix_layout, char uplo, char diag, int n, _Complex double *ap)
     * }
     */
    public static MemorySegment LAPACKE_ztptri_work$address() {
        return LAPACKE_ztptri_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ztptri_work(int matrix_layout, char uplo, char diag, int n, _Complex double *ap)
     * }
     */
    public static int LAPACKE_ztptri_work(int matrix_layout, byte uplo, byte diag, int n, MemorySegment ap) {
        var mh$ = LAPACKE_ztptri_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ztptri_work", matrix_layout, uplo, diag, n, ap);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, diag, n, ap);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_stptrs_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_stptrs_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_stptrs_work(int matrix_layout, char uplo, char trans, char diag, int n, int nrhs, const float *ap, float *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_stptrs_work$descriptor() {
        return LAPACKE_stptrs_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_stptrs_work(int matrix_layout, char uplo, char trans, char diag, int n, int nrhs, const float *ap, float *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_stptrs_work$handle() {
        return LAPACKE_stptrs_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_stptrs_work(int matrix_layout, char uplo, char trans, char diag, int n, int nrhs, const float *ap, float *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_stptrs_work$address() {
        return LAPACKE_stptrs_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_stptrs_work(int matrix_layout, char uplo, char trans, char diag, int n, int nrhs, const float *ap, float *b, int ldb)
     * }
     */
    public static int LAPACKE_stptrs_work(int matrix_layout, byte uplo, byte trans, byte diag, int n, int nrhs, MemorySegment ap, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_stptrs_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_stptrs_work", matrix_layout, uplo, trans, diag, n, nrhs, ap, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, trans, diag, n, nrhs, ap, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dtptrs_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dtptrs_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dtptrs_work(int matrix_layout, char uplo, char trans, char diag, int n, int nrhs, const double *ap, double *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_dtptrs_work$descriptor() {
        return LAPACKE_dtptrs_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dtptrs_work(int matrix_layout, char uplo, char trans, char diag, int n, int nrhs, const double *ap, double *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_dtptrs_work$handle() {
        return LAPACKE_dtptrs_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dtptrs_work(int matrix_layout, char uplo, char trans, char diag, int n, int nrhs, const double *ap, double *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_dtptrs_work$address() {
        return LAPACKE_dtptrs_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dtptrs_work(int matrix_layout, char uplo, char trans, char diag, int n, int nrhs, const double *ap, double *b, int ldb)
     * }
     */
    public static int LAPACKE_dtptrs_work(int matrix_layout, byte uplo, byte trans, byte diag, int n, int nrhs, MemorySegment ap, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_dtptrs_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dtptrs_work", matrix_layout, uplo, trans, diag, n, nrhs, ap, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, trans, diag, n, nrhs, ap, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ctptrs_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_ctptrs_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ctptrs_work(int matrix_layout, char uplo, char trans, char diag, int n, int nrhs, const _Complex float *ap, _Complex float *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_ctptrs_work$descriptor() {
        return LAPACKE_ctptrs_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ctptrs_work(int matrix_layout, char uplo, char trans, char diag, int n, int nrhs, const _Complex float *ap, _Complex float *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_ctptrs_work$handle() {
        return LAPACKE_ctptrs_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ctptrs_work(int matrix_layout, char uplo, char trans, char diag, int n, int nrhs, const _Complex float *ap, _Complex float *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_ctptrs_work$address() {
        return LAPACKE_ctptrs_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ctptrs_work(int matrix_layout, char uplo, char trans, char diag, int n, int nrhs, const _Complex float *ap, _Complex float *b, int ldb)
     * }
     */
    public static int LAPACKE_ctptrs_work(int matrix_layout, byte uplo, byte trans, byte diag, int n, int nrhs, MemorySegment ap, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_ctptrs_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ctptrs_work", matrix_layout, uplo, trans, diag, n, nrhs, ap, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, trans, diag, n, nrhs, ap, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ztptrs_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_ztptrs_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ztptrs_work(int matrix_layout, char uplo, char trans, char diag, int n, int nrhs, const _Complex double *ap, _Complex double *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_ztptrs_work$descriptor() {
        return LAPACKE_ztptrs_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ztptrs_work(int matrix_layout, char uplo, char trans, char diag, int n, int nrhs, const _Complex double *ap, _Complex double *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_ztptrs_work$handle() {
        return LAPACKE_ztptrs_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ztptrs_work(int matrix_layout, char uplo, char trans, char diag, int n, int nrhs, const _Complex double *ap, _Complex double *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_ztptrs_work$address() {
        return LAPACKE_ztptrs_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ztptrs_work(int matrix_layout, char uplo, char trans, char diag, int n, int nrhs, const _Complex double *ap, _Complex double *b, int ldb)
     * }
     */
    public static int LAPACKE_ztptrs_work(int matrix_layout, byte uplo, byte trans, byte diag, int n, int nrhs, MemorySegment ap, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_ztptrs_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ztptrs_work", matrix_layout, uplo, trans, diag, n, nrhs, ap, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, trans, diag, n, nrhs, ap, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_stpttf_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_stpttf_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_stpttf_work(int matrix_layout, char transr, char uplo, int n, const float *ap, float *arf)
     * }
     */
    public static FunctionDescriptor LAPACKE_stpttf_work$descriptor() {
        return LAPACKE_stpttf_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_stpttf_work(int matrix_layout, char transr, char uplo, int n, const float *ap, float *arf)
     * }
     */
    public static MethodHandle LAPACKE_stpttf_work$handle() {
        return LAPACKE_stpttf_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_stpttf_work(int matrix_layout, char transr, char uplo, int n, const float *ap, float *arf)
     * }
     */
    public static MemorySegment LAPACKE_stpttf_work$address() {
        return LAPACKE_stpttf_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_stpttf_work(int matrix_layout, char transr, char uplo, int n, const float *ap, float *arf)
     * }
     */
    public static int LAPACKE_stpttf_work(int matrix_layout, byte transr, byte uplo, int n, MemorySegment ap, MemorySegment arf) {
        var mh$ = LAPACKE_stpttf_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_stpttf_work", matrix_layout, transr, uplo, n, ap, arf);
            }
            return (int)mh$.invokeExact(matrix_layout, transr, uplo, n, ap, arf);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dtpttf_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dtpttf_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dtpttf_work(int matrix_layout, char transr, char uplo, int n, const double *ap, double *arf)
     * }
     */
    public static FunctionDescriptor LAPACKE_dtpttf_work$descriptor() {
        return LAPACKE_dtpttf_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dtpttf_work(int matrix_layout, char transr, char uplo, int n, const double *ap, double *arf)
     * }
     */
    public static MethodHandle LAPACKE_dtpttf_work$handle() {
        return LAPACKE_dtpttf_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dtpttf_work(int matrix_layout, char transr, char uplo, int n, const double *ap, double *arf)
     * }
     */
    public static MemorySegment LAPACKE_dtpttf_work$address() {
        return LAPACKE_dtpttf_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dtpttf_work(int matrix_layout, char transr, char uplo, int n, const double *ap, double *arf)
     * }
     */
    public static int LAPACKE_dtpttf_work(int matrix_layout, byte transr, byte uplo, int n, MemorySegment ap, MemorySegment arf) {
        var mh$ = LAPACKE_dtpttf_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dtpttf_work", matrix_layout, transr, uplo, n, ap, arf);
            }
            return (int)mh$.invokeExact(matrix_layout, transr, uplo, n, ap, arf);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ctpttf_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_ctpttf_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ctpttf_work(int matrix_layout, char transr, char uplo, int n, const _Complex float *ap, _Complex float *arf)
     * }
     */
    public static FunctionDescriptor LAPACKE_ctpttf_work$descriptor() {
        return LAPACKE_ctpttf_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ctpttf_work(int matrix_layout, char transr, char uplo, int n, const _Complex float *ap, _Complex float *arf)
     * }
     */
    public static MethodHandle LAPACKE_ctpttf_work$handle() {
        return LAPACKE_ctpttf_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ctpttf_work(int matrix_layout, char transr, char uplo, int n, const _Complex float *ap, _Complex float *arf)
     * }
     */
    public static MemorySegment LAPACKE_ctpttf_work$address() {
        return LAPACKE_ctpttf_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ctpttf_work(int matrix_layout, char transr, char uplo, int n, const _Complex float *ap, _Complex float *arf)
     * }
     */
    public static int LAPACKE_ctpttf_work(int matrix_layout, byte transr, byte uplo, int n, MemorySegment ap, MemorySegment arf) {
        var mh$ = LAPACKE_ctpttf_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ctpttf_work", matrix_layout, transr, uplo, n, ap, arf);
            }
            return (int)mh$.invokeExact(matrix_layout, transr, uplo, n, ap, arf);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ztpttf_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_ztpttf_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ztpttf_work(int matrix_layout, char transr, char uplo, int n, const _Complex double *ap, _Complex double *arf)
     * }
     */
    public static FunctionDescriptor LAPACKE_ztpttf_work$descriptor() {
        return LAPACKE_ztpttf_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ztpttf_work(int matrix_layout, char transr, char uplo, int n, const _Complex double *ap, _Complex double *arf)
     * }
     */
    public static MethodHandle LAPACKE_ztpttf_work$handle() {
        return LAPACKE_ztpttf_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ztpttf_work(int matrix_layout, char transr, char uplo, int n, const _Complex double *ap, _Complex double *arf)
     * }
     */
    public static MemorySegment LAPACKE_ztpttf_work$address() {
        return LAPACKE_ztpttf_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ztpttf_work(int matrix_layout, char transr, char uplo, int n, const _Complex double *ap, _Complex double *arf)
     * }
     */
    public static int LAPACKE_ztpttf_work(int matrix_layout, byte transr, byte uplo, int n, MemorySegment ap, MemorySegment arf) {
        var mh$ = LAPACKE_ztpttf_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ztpttf_work", matrix_layout, transr, uplo, n, ap, arf);
            }
            return (int)mh$.invokeExact(matrix_layout, transr, uplo, n, ap, arf);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_stpttr_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_stpttr_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_stpttr_work(int matrix_layout, char uplo, int n, const float *ap, float *a, int lda)
     * }
     */
    public static FunctionDescriptor LAPACKE_stpttr_work$descriptor() {
        return LAPACKE_stpttr_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_stpttr_work(int matrix_layout, char uplo, int n, const float *ap, float *a, int lda)
     * }
     */
    public static MethodHandle LAPACKE_stpttr_work$handle() {
        return LAPACKE_stpttr_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_stpttr_work(int matrix_layout, char uplo, int n, const float *ap, float *a, int lda)
     * }
     */
    public static MemorySegment LAPACKE_stpttr_work$address() {
        return LAPACKE_stpttr_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_stpttr_work(int matrix_layout, char uplo, int n, const float *ap, float *a, int lda)
     * }
     */
    public static int LAPACKE_stpttr_work(int matrix_layout, byte uplo, int n, MemorySegment ap, MemorySegment a, int lda) {
        var mh$ = LAPACKE_stpttr_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_stpttr_work", matrix_layout, uplo, n, ap, a, lda);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, ap, a, lda);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dtpttr_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dtpttr_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dtpttr_work(int matrix_layout, char uplo, int n, const double *ap, double *a, int lda)
     * }
     */
    public static FunctionDescriptor LAPACKE_dtpttr_work$descriptor() {
        return LAPACKE_dtpttr_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dtpttr_work(int matrix_layout, char uplo, int n, const double *ap, double *a, int lda)
     * }
     */
    public static MethodHandle LAPACKE_dtpttr_work$handle() {
        return LAPACKE_dtpttr_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dtpttr_work(int matrix_layout, char uplo, int n, const double *ap, double *a, int lda)
     * }
     */
    public static MemorySegment LAPACKE_dtpttr_work$address() {
        return LAPACKE_dtpttr_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dtpttr_work(int matrix_layout, char uplo, int n, const double *ap, double *a, int lda)
     * }
     */
    public static int LAPACKE_dtpttr_work(int matrix_layout, byte uplo, int n, MemorySegment ap, MemorySegment a, int lda) {
        var mh$ = LAPACKE_dtpttr_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dtpttr_work", matrix_layout, uplo, n, ap, a, lda);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, ap, a, lda);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ctpttr_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_ctpttr_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ctpttr_work(int matrix_layout, char uplo, int n, const _Complex float *ap, _Complex float *a, int lda)
     * }
     */
    public static FunctionDescriptor LAPACKE_ctpttr_work$descriptor() {
        return LAPACKE_ctpttr_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ctpttr_work(int matrix_layout, char uplo, int n, const _Complex float *ap, _Complex float *a, int lda)
     * }
     */
    public static MethodHandle LAPACKE_ctpttr_work$handle() {
        return LAPACKE_ctpttr_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ctpttr_work(int matrix_layout, char uplo, int n, const _Complex float *ap, _Complex float *a, int lda)
     * }
     */
    public static MemorySegment LAPACKE_ctpttr_work$address() {
        return LAPACKE_ctpttr_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ctpttr_work(int matrix_layout, char uplo, int n, const _Complex float *ap, _Complex float *a, int lda)
     * }
     */
    public static int LAPACKE_ctpttr_work(int matrix_layout, byte uplo, int n, MemorySegment ap, MemorySegment a, int lda) {
        var mh$ = LAPACKE_ctpttr_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ctpttr_work", matrix_layout, uplo, n, ap, a, lda);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, ap, a, lda);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ztpttr_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_ztpttr_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ztpttr_work(int matrix_layout, char uplo, int n, const _Complex double *ap, _Complex double *a, int lda)
     * }
     */
    public static FunctionDescriptor LAPACKE_ztpttr_work$descriptor() {
        return LAPACKE_ztpttr_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ztpttr_work(int matrix_layout, char uplo, int n, const _Complex double *ap, _Complex double *a, int lda)
     * }
     */
    public static MethodHandle LAPACKE_ztpttr_work$handle() {
        return LAPACKE_ztpttr_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ztpttr_work(int matrix_layout, char uplo, int n, const _Complex double *ap, _Complex double *a, int lda)
     * }
     */
    public static MemorySegment LAPACKE_ztpttr_work$address() {
        return LAPACKE_ztpttr_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ztpttr_work(int matrix_layout, char uplo, int n, const _Complex double *ap, _Complex double *a, int lda)
     * }
     */
    public static int LAPACKE_ztpttr_work(int matrix_layout, byte uplo, int n, MemorySegment ap, MemorySegment a, int lda) {
        var mh$ = LAPACKE_ztpttr_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ztpttr_work", matrix_layout, uplo, n, ap, a, lda);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, ap, a, lda);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_strcon_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_strcon_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_strcon_work(int matrix_layout, char norm, char uplo, char diag, int n, const float *a, int lda, float *rcond, float *work, int *iwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_strcon_work$descriptor() {
        return LAPACKE_strcon_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_strcon_work(int matrix_layout, char norm, char uplo, char diag, int n, const float *a, int lda, float *rcond, float *work, int *iwork)
     * }
     */
    public static MethodHandle LAPACKE_strcon_work$handle() {
        return LAPACKE_strcon_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_strcon_work(int matrix_layout, char norm, char uplo, char diag, int n, const float *a, int lda, float *rcond, float *work, int *iwork)
     * }
     */
    public static MemorySegment LAPACKE_strcon_work$address() {
        return LAPACKE_strcon_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_strcon_work(int matrix_layout, char norm, char uplo, char diag, int n, const float *a, int lda, float *rcond, float *work, int *iwork)
     * }
     */
    public static int LAPACKE_strcon_work(int matrix_layout, byte norm, byte uplo, byte diag, int n, MemorySegment a, int lda, MemorySegment rcond, MemorySegment work, MemorySegment iwork) {
        var mh$ = LAPACKE_strcon_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_strcon_work", matrix_layout, norm, uplo, diag, n, a, lda, rcond, work, iwork);
            }
            return (int)mh$.invokeExact(matrix_layout, norm, uplo, diag, n, a, lda, rcond, work, iwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dtrcon_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dtrcon_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dtrcon_work(int matrix_layout, char norm, char uplo, char diag, int n, const double *a, int lda, double *rcond, double *work, int *iwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_dtrcon_work$descriptor() {
        return LAPACKE_dtrcon_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dtrcon_work(int matrix_layout, char norm, char uplo, char diag, int n, const double *a, int lda, double *rcond, double *work, int *iwork)
     * }
     */
    public static MethodHandle LAPACKE_dtrcon_work$handle() {
        return LAPACKE_dtrcon_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dtrcon_work(int matrix_layout, char norm, char uplo, char diag, int n, const double *a, int lda, double *rcond, double *work, int *iwork)
     * }
     */
    public static MemorySegment LAPACKE_dtrcon_work$address() {
        return LAPACKE_dtrcon_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dtrcon_work(int matrix_layout, char norm, char uplo, char diag, int n, const double *a, int lda, double *rcond, double *work, int *iwork)
     * }
     */
    public static int LAPACKE_dtrcon_work(int matrix_layout, byte norm, byte uplo, byte diag, int n, MemorySegment a, int lda, MemorySegment rcond, MemorySegment work, MemorySegment iwork) {
        var mh$ = LAPACKE_dtrcon_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dtrcon_work", matrix_layout, norm, uplo, diag, n, a, lda, rcond, work, iwork);
            }
            return (int)mh$.invokeExact(matrix_layout, norm, uplo, diag, n, a, lda, rcond, work, iwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ctrcon_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_ctrcon_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ctrcon_work(int matrix_layout, char norm, char uplo, char diag, int n, const _Complex float *a, int lda, float *rcond, _Complex float *work, float *rwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_ctrcon_work$descriptor() {
        return LAPACKE_ctrcon_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ctrcon_work(int matrix_layout, char norm, char uplo, char diag, int n, const _Complex float *a, int lda, float *rcond, _Complex float *work, float *rwork)
     * }
     */
    public static MethodHandle LAPACKE_ctrcon_work$handle() {
        return LAPACKE_ctrcon_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ctrcon_work(int matrix_layout, char norm, char uplo, char diag, int n, const _Complex float *a, int lda, float *rcond, _Complex float *work, float *rwork)
     * }
     */
    public static MemorySegment LAPACKE_ctrcon_work$address() {
        return LAPACKE_ctrcon_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ctrcon_work(int matrix_layout, char norm, char uplo, char diag, int n, const _Complex float *a, int lda, float *rcond, _Complex float *work, float *rwork)
     * }
     */
    public static int LAPACKE_ctrcon_work(int matrix_layout, byte norm, byte uplo, byte diag, int n, MemorySegment a, int lda, MemorySegment rcond, MemorySegment work, MemorySegment rwork) {
        var mh$ = LAPACKE_ctrcon_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ctrcon_work", matrix_layout, norm, uplo, diag, n, a, lda, rcond, work, rwork);
            }
            return (int)mh$.invokeExact(matrix_layout, norm, uplo, diag, n, a, lda, rcond, work, rwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ztrcon_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_ztrcon_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ztrcon_work(int matrix_layout, char norm, char uplo, char diag, int n, const _Complex double *a, int lda, double *rcond, _Complex double *work, double *rwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_ztrcon_work$descriptor() {
        return LAPACKE_ztrcon_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ztrcon_work(int matrix_layout, char norm, char uplo, char diag, int n, const _Complex double *a, int lda, double *rcond, _Complex double *work, double *rwork)
     * }
     */
    public static MethodHandle LAPACKE_ztrcon_work$handle() {
        return LAPACKE_ztrcon_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ztrcon_work(int matrix_layout, char norm, char uplo, char diag, int n, const _Complex double *a, int lda, double *rcond, _Complex double *work, double *rwork)
     * }
     */
    public static MemorySegment LAPACKE_ztrcon_work$address() {
        return LAPACKE_ztrcon_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ztrcon_work(int matrix_layout, char norm, char uplo, char diag, int n, const _Complex double *a, int lda, double *rcond, _Complex double *work, double *rwork)
     * }
     */
    public static int LAPACKE_ztrcon_work(int matrix_layout, byte norm, byte uplo, byte diag, int n, MemorySegment a, int lda, MemorySegment rcond, MemorySegment work, MemorySegment rwork) {
        var mh$ = LAPACKE_ztrcon_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ztrcon_work", matrix_layout, norm, uplo, diag, n, a, lda, rcond, work, rwork);
            }
            return (int)mh$.invokeExact(matrix_layout, norm, uplo, diag, n, a, lda, rcond, work, rwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_strevc_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_strevc_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_strevc_work(int matrix_layout, char side, char howmny, int *select, int n, const float *t, int ldt, float *vl, int ldvl, float *vr, int ldvr, int mm, int *m, float *work)
     * }
     */
    public static FunctionDescriptor LAPACKE_strevc_work$descriptor() {
        return LAPACKE_strevc_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_strevc_work(int matrix_layout, char side, char howmny, int *select, int n, const float *t, int ldt, float *vl, int ldvl, float *vr, int ldvr, int mm, int *m, float *work)
     * }
     */
    public static MethodHandle LAPACKE_strevc_work$handle() {
        return LAPACKE_strevc_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_strevc_work(int matrix_layout, char side, char howmny, int *select, int n, const float *t, int ldt, float *vl, int ldvl, float *vr, int ldvr, int mm, int *m, float *work)
     * }
     */
    public static MemorySegment LAPACKE_strevc_work$address() {
        return LAPACKE_strevc_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_strevc_work(int matrix_layout, char side, char howmny, int *select, int n, const float *t, int ldt, float *vl, int ldvl, float *vr, int ldvr, int mm, int *m, float *work)
     * }
     */
    public static int LAPACKE_strevc_work(int matrix_layout, byte side, byte howmny, MemorySegment select, int n, MemorySegment t, int ldt, MemorySegment vl, int ldvl, MemorySegment vr, int ldvr, int mm, MemorySegment m, MemorySegment work) {
        var mh$ = LAPACKE_strevc_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_strevc_work", matrix_layout, side, howmny, select, n, t, ldt, vl, ldvl, vr, ldvr, mm, m, work);
            }
            return (int)mh$.invokeExact(matrix_layout, side, howmny, select, n, t, ldt, vl, ldvl, vr, ldvr, mm, m, work);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dtrevc_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dtrevc_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dtrevc_work(int matrix_layout, char side, char howmny, int *select, int n, const double *t, int ldt, double *vl, int ldvl, double *vr, int ldvr, int mm, int *m, double *work)
     * }
     */
    public static FunctionDescriptor LAPACKE_dtrevc_work$descriptor() {
        return LAPACKE_dtrevc_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dtrevc_work(int matrix_layout, char side, char howmny, int *select, int n, const double *t, int ldt, double *vl, int ldvl, double *vr, int ldvr, int mm, int *m, double *work)
     * }
     */
    public static MethodHandle LAPACKE_dtrevc_work$handle() {
        return LAPACKE_dtrevc_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dtrevc_work(int matrix_layout, char side, char howmny, int *select, int n, const double *t, int ldt, double *vl, int ldvl, double *vr, int ldvr, int mm, int *m, double *work)
     * }
     */
    public static MemorySegment LAPACKE_dtrevc_work$address() {
        return LAPACKE_dtrevc_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dtrevc_work(int matrix_layout, char side, char howmny, int *select, int n, const double *t, int ldt, double *vl, int ldvl, double *vr, int ldvr, int mm, int *m, double *work)
     * }
     */
    public static int LAPACKE_dtrevc_work(int matrix_layout, byte side, byte howmny, MemorySegment select, int n, MemorySegment t, int ldt, MemorySegment vl, int ldvl, MemorySegment vr, int ldvr, int mm, MemorySegment m, MemorySegment work) {
        var mh$ = LAPACKE_dtrevc_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dtrevc_work", matrix_layout, side, howmny, select, n, t, ldt, vl, ldvl, vr, ldvr, mm, m, work);
            }
            return (int)mh$.invokeExact(matrix_layout, side, howmny, select, n, t, ldt, vl, ldvl, vr, ldvr, mm, m, work);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ctrevc_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_ctrevc_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ctrevc_work(int matrix_layout, char side, char howmny, const int *select, int n, _Complex float *t, int ldt, _Complex float *vl, int ldvl, _Complex float *vr, int ldvr, int mm, int *m, _Complex float *work, float *rwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_ctrevc_work$descriptor() {
        return LAPACKE_ctrevc_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ctrevc_work(int matrix_layout, char side, char howmny, const int *select, int n, _Complex float *t, int ldt, _Complex float *vl, int ldvl, _Complex float *vr, int ldvr, int mm, int *m, _Complex float *work, float *rwork)
     * }
     */
    public static MethodHandle LAPACKE_ctrevc_work$handle() {
        return LAPACKE_ctrevc_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ctrevc_work(int matrix_layout, char side, char howmny, const int *select, int n, _Complex float *t, int ldt, _Complex float *vl, int ldvl, _Complex float *vr, int ldvr, int mm, int *m, _Complex float *work, float *rwork)
     * }
     */
    public static MemorySegment LAPACKE_ctrevc_work$address() {
        return LAPACKE_ctrevc_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ctrevc_work(int matrix_layout, char side, char howmny, const int *select, int n, _Complex float *t, int ldt, _Complex float *vl, int ldvl, _Complex float *vr, int ldvr, int mm, int *m, _Complex float *work, float *rwork)
     * }
     */
    public static int LAPACKE_ctrevc_work(int matrix_layout, byte side, byte howmny, MemorySegment select, int n, MemorySegment t, int ldt, MemorySegment vl, int ldvl, MemorySegment vr, int ldvr, int mm, MemorySegment m, MemorySegment work, MemorySegment rwork) {
        var mh$ = LAPACKE_ctrevc_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ctrevc_work", matrix_layout, side, howmny, select, n, t, ldt, vl, ldvl, vr, ldvr, mm, m, work, rwork);
            }
            return (int)mh$.invokeExact(matrix_layout, side, howmny, select, n, t, ldt, vl, ldvl, vr, ldvr, mm, m, work, rwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ztrevc_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_ztrevc_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ztrevc_work(int matrix_layout, char side, char howmny, const int *select, int n, _Complex double *t, int ldt, _Complex double *vl, int ldvl, _Complex double *vr, int ldvr, int mm, int *m, _Complex double *work, double *rwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_ztrevc_work$descriptor() {
        return LAPACKE_ztrevc_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ztrevc_work(int matrix_layout, char side, char howmny, const int *select, int n, _Complex double *t, int ldt, _Complex double *vl, int ldvl, _Complex double *vr, int ldvr, int mm, int *m, _Complex double *work, double *rwork)
     * }
     */
    public static MethodHandle LAPACKE_ztrevc_work$handle() {
        return LAPACKE_ztrevc_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ztrevc_work(int matrix_layout, char side, char howmny, const int *select, int n, _Complex double *t, int ldt, _Complex double *vl, int ldvl, _Complex double *vr, int ldvr, int mm, int *m, _Complex double *work, double *rwork)
     * }
     */
    public static MemorySegment LAPACKE_ztrevc_work$address() {
        return LAPACKE_ztrevc_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ztrevc_work(int matrix_layout, char side, char howmny, const int *select, int n, _Complex double *t, int ldt, _Complex double *vl, int ldvl, _Complex double *vr, int ldvr, int mm, int *m, _Complex double *work, double *rwork)
     * }
     */
    public static int LAPACKE_ztrevc_work(int matrix_layout, byte side, byte howmny, MemorySegment select, int n, MemorySegment t, int ldt, MemorySegment vl, int ldvl, MemorySegment vr, int ldvr, int mm, MemorySegment m, MemorySegment work, MemorySegment rwork) {
        var mh$ = LAPACKE_ztrevc_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ztrevc_work", matrix_layout, side, howmny, select, n, t, ldt, vl, ldvl, vr, ldvr, mm, m, work, rwork);
            }
            return (int)mh$.invokeExact(matrix_layout, side, howmny, select, n, t, ldt, vl, ldvl, vr, ldvr, mm, m, work, rwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_strexc_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_strexc_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_strexc_work(int matrix_layout, char compq, int n, float *t, int ldt, float *q, int ldq, int *ifst, int *ilst, float *work)
     * }
     */
    public static FunctionDescriptor LAPACKE_strexc_work$descriptor() {
        return LAPACKE_strexc_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_strexc_work(int matrix_layout, char compq, int n, float *t, int ldt, float *q, int ldq, int *ifst, int *ilst, float *work)
     * }
     */
    public static MethodHandle LAPACKE_strexc_work$handle() {
        return LAPACKE_strexc_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_strexc_work(int matrix_layout, char compq, int n, float *t, int ldt, float *q, int ldq, int *ifst, int *ilst, float *work)
     * }
     */
    public static MemorySegment LAPACKE_strexc_work$address() {
        return LAPACKE_strexc_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_strexc_work(int matrix_layout, char compq, int n, float *t, int ldt, float *q, int ldq, int *ifst, int *ilst, float *work)
     * }
     */
    public static int LAPACKE_strexc_work(int matrix_layout, byte compq, int n, MemorySegment t, int ldt, MemorySegment q, int ldq, MemorySegment ifst, MemorySegment ilst, MemorySegment work) {
        var mh$ = LAPACKE_strexc_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_strexc_work", matrix_layout, compq, n, t, ldt, q, ldq, ifst, ilst, work);
            }
            return (int)mh$.invokeExact(matrix_layout, compq, n, t, ldt, q, ldq, ifst, ilst, work);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dtrexc_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dtrexc_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dtrexc_work(int matrix_layout, char compq, int n, double *t, int ldt, double *q, int ldq, int *ifst, int *ilst, double *work)
     * }
     */
    public static FunctionDescriptor LAPACKE_dtrexc_work$descriptor() {
        return LAPACKE_dtrexc_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dtrexc_work(int matrix_layout, char compq, int n, double *t, int ldt, double *q, int ldq, int *ifst, int *ilst, double *work)
     * }
     */
    public static MethodHandle LAPACKE_dtrexc_work$handle() {
        return LAPACKE_dtrexc_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dtrexc_work(int matrix_layout, char compq, int n, double *t, int ldt, double *q, int ldq, int *ifst, int *ilst, double *work)
     * }
     */
    public static MemorySegment LAPACKE_dtrexc_work$address() {
        return LAPACKE_dtrexc_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dtrexc_work(int matrix_layout, char compq, int n, double *t, int ldt, double *q, int ldq, int *ifst, int *ilst, double *work)
     * }
     */
    public static int LAPACKE_dtrexc_work(int matrix_layout, byte compq, int n, MemorySegment t, int ldt, MemorySegment q, int ldq, MemorySegment ifst, MemorySegment ilst, MemorySegment work) {
        var mh$ = LAPACKE_dtrexc_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dtrexc_work", matrix_layout, compq, n, t, ldt, q, ldq, ifst, ilst, work);
            }
            return (int)mh$.invokeExact(matrix_layout, compq, n, t, ldt, q, ldq, ifst, ilst, work);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ctrexc_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_ctrexc_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ctrexc_work(int matrix_layout, char compq, int n, _Complex float *t, int ldt, _Complex float *q, int ldq, int ifst, int ilst)
     * }
     */
    public static FunctionDescriptor LAPACKE_ctrexc_work$descriptor() {
        return LAPACKE_ctrexc_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ctrexc_work(int matrix_layout, char compq, int n, _Complex float *t, int ldt, _Complex float *q, int ldq, int ifst, int ilst)
     * }
     */
    public static MethodHandle LAPACKE_ctrexc_work$handle() {
        return LAPACKE_ctrexc_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ctrexc_work(int matrix_layout, char compq, int n, _Complex float *t, int ldt, _Complex float *q, int ldq, int ifst, int ilst)
     * }
     */
    public static MemorySegment LAPACKE_ctrexc_work$address() {
        return LAPACKE_ctrexc_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ctrexc_work(int matrix_layout, char compq, int n, _Complex float *t, int ldt, _Complex float *q, int ldq, int ifst, int ilst)
     * }
     */
    public static int LAPACKE_ctrexc_work(int matrix_layout, byte compq, int n, MemorySegment t, int ldt, MemorySegment q, int ldq, int ifst, int ilst) {
        var mh$ = LAPACKE_ctrexc_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ctrexc_work", matrix_layout, compq, n, t, ldt, q, ldq, ifst, ilst);
            }
            return (int)mh$.invokeExact(matrix_layout, compq, n, t, ldt, q, ldq, ifst, ilst);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ztrexc_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_ztrexc_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ztrexc_work(int matrix_layout, char compq, int n, _Complex double *t, int ldt, _Complex double *q, int ldq, int ifst, int ilst)
     * }
     */
    public static FunctionDescriptor LAPACKE_ztrexc_work$descriptor() {
        return LAPACKE_ztrexc_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ztrexc_work(int matrix_layout, char compq, int n, _Complex double *t, int ldt, _Complex double *q, int ldq, int ifst, int ilst)
     * }
     */
    public static MethodHandle LAPACKE_ztrexc_work$handle() {
        return LAPACKE_ztrexc_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ztrexc_work(int matrix_layout, char compq, int n, _Complex double *t, int ldt, _Complex double *q, int ldq, int ifst, int ilst)
     * }
     */
    public static MemorySegment LAPACKE_ztrexc_work$address() {
        return LAPACKE_ztrexc_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ztrexc_work(int matrix_layout, char compq, int n, _Complex double *t, int ldt, _Complex double *q, int ldq, int ifst, int ilst)
     * }
     */
    public static int LAPACKE_ztrexc_work(int matrix_layout, byte compq, int n, MemorySegment t, int ldt, MemorySegment q, int ldq, int ifst, int ilst) {
        var mh$ = LAPACKE_ztrexc_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ztrexc_work", matrix_layout, compq, n, t, ldt, q, ldq, ifst, ilst);
            }
            return (int)mh$.invokeExact(matrix_layout, compq, n, t, ldt, q, ldq, ifst, ilst);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_strrfs_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_strrfs_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_strrfs_work(int matrix_layout, char uplo, char trans, char diag, int n, int nrhs, const float *a, int lda, const float *b, int ldb, const float *x, int ldx, float *ferr, float *berr, float *work, int *iwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_strrfs_work$descriptor() {
        return LAPACKE_strrfs_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_strrfs_work(int matrix_layout, char uplo, char trans, char diag, int n, int nrhs, const float *a, int lda, const float *b, int ldb, const float *x, int ldx, float *ferr, float *berr, float *work, int *iwork)
     * }
     */
    public static MethodHandle LAPACKE_strrfs_work$handle() {
        return LAPACKE_strrfs_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_strrfs_work(int matrix_layout, char uplo, char trans, char diag, int n, int nrhs, const float *a, int lda, const float *b, int ldb, const float *x, int ldx, float *ferr, float *berr, float *work, int *iwork)
     * }
     */
    public static MemorySegment LAPACKE_strrfs_work$address() {
        return LAPACKE_strrfs_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_strrfs_work(int matrix_layout, char uplo, char trans, char diag, int n, int nrhs, const float *a, int lda, const float *b, int ldb, const float *x, int ldx, float *ferr, float *berr, float *work, int *iwork)
     * }
     */
    public static int LAPACKE_strrfs_work(int matrix_layout, byte uplo, byte trans, byte diag, int n, int nrhs, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment ferr, MemorySegment berr, MemorySegment work, MemorySegment iwork) {
        var mh$ = LAPACKE_strrfs_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_strrfs_work", matrix_layout, uplo, trans, diag, n, nrhs, a, lda, b, ldb, x, ldx, ferr, berr, work, iwork);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, trans, diag, n, nrhs, a, lda, b, ldb, x, ldx, ferr, berr, work, iwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dtrrfs_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dtrrfs_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dtrrfs_work(int matrix_layout, char uplo, char trans, char diag, int n, int nrhs, const double *a, int lda, const double *b, int ldb, const double *x, int ldx, double *ferr, double *berr, double *work, int *iwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_dtrrfs_work$descriptor() {
        return LAPACKE_dtrrfs_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dtrrfs_work(int matrix_layout, char uplo, char trans, char diag, int n, int nrhs, const double *a, int lda, const double *b, int ldb, const double *x, int ldx, double *ferr, double *berr, double *work, int *iwork)
     * }
     */
    public static MethodHandle LAPACKE_dtrrfs_work$handle() {
        return LAPACKE_dtrrfs_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dtrrfs_work(int matrix_layout, char uplo, char trans, char diag, int n, int nrhs, const double *a, int lda, const double *b, int ldb, const double *x, int ldx, double *ferr, double *berr, double *work, int *iwork)
     * }
     */
    public static MemorySegment LAPACKE_dtrrfs_work$address() {
        return LAPACKE_dtrrfs_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dtrrfs_work(int matrix_layout, char uplo, char trans, char diag, int n, int nrhs, const double *a, int lda, const double *b, int ldb, const double *x, int ldx, double *ferr, double *berr, double *work, int *iwork)
     * }
     */
    public static int LAPACKE_dtrrfs_work(int matrix_layout, byte uplo, byte trans, byte diag, int n, int nrhs, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment ferr, MemorySegment berr, MemorySegment work, MemorySegment iwork) {
        var mh$ = LAPACKE_dtrrfs_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dtrrfs_work", matrix_layout, uplo, trans, diag, n, nrhs, a, lda, b, ldb, x, ldx, ferr, berr, work, iwork);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, trans, diag, n, nrhs, a, lda, b, ldb, x, ldx, ferr, berr, work, iwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ctrrfs_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_ctrrfs_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ctrrfs_work(int matrix_layout, char uplo, char trans, char diag, int n, int nrhs, const _Complex float *a, int lda, const _Complex float *b, int ldb, const _Complex float *x, int ldx, float *ferr, float *berr, _Complex float *work, float *rwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_ctrrfs_work$descriptor() {
        return LAPACKE_ctrrfs_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ctrrfs_work(int matrix_layout, char uplo, char trans, char diag, int n, int nrhs, const _Complex float *a, int lda, const _Complex float *b, int ldb, const _Complex float *x, int ldx, float *ferr, float *berr, _Complex float *work, float *rwork)
     * }
     */
    public static MethodHandle LAPACKE_ctrrfs_work$handle() {
        return LAPACKE_ctrrfs_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ctrrfs_work(int matrix_layout, char uplo, char trans, char diag, int n, int nrhs, const _Complex float *a, int lda, const _Complex float *b, int ldb, const _Complex float *x, int ldx, float *ferr, float *berr, _Complex float *work, float *rwork)
     * }
     */
    public static MemorySegment LAPACKE_ctrrfs_work$address() {
        return LAPACKE_ctrrfs_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ctrrfs_work(int matrix_layout, char uplo, char trans, char diag, int n, int nrhs, const _Complex float *a, int lda, const _Complex float *b, int ldb, const _Complex float *x, int ldx, float *ferr, float *berr, _Complex float *work, float *rwork)
     * }
     */
    public static int LAPACKE_ctrrfs_work(int matrix_layout, byte uplo, byte trans, byte diag, int n, int nrhs, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment ferr, MemorySegment berr, MemorySegment work, MemorySegment rwork) {
        var mh$ = LAPACKE_ctrrfs_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ctrrfs_work", matrix_layout, uplo, trans, diag, n, nrhs, a, lda, b, ldb, x, ldx, ferr, berr, work, rwork);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, trans, diag, n, nrhs, a, lda, b, ldb, x, ldx, ferr, berr, work, rwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ztrrfs_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_ztrrfs_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ztrrfs_work(int matrix_layout, char uplo, char trans, char diag, int n, int nrhs, const _Complex double *a, int lda, const _Complex double *b, int ldb, const _Complex double *x, int ldx, double *ferr, double *berr, _Complex double *work, double *rwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_ztrrfs_work$descriptor() {
        return LAPACKE_ztrrfs_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ztrrfs_work(int matrix_layout, char uplo, char trans, char diag, int n, int nrhs, const _Complex double *a, int lda, const _Complex double *b, int ldb, const _Complex double *x, int ldx, double *ferr, double *berr, _Complex double *work, double *rwork)
     * }
     */
    public static MethodHandle LAPACKE_ztrrfs_work$handle() {
        return LAPACKE_ztrrfs_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ztrrfs_work(int matrix_layout, char uplo, char trans, char diag, int n, int nrhs, const _Complex double *a, int lda, const _Complex double *b, int ldb, const _Complex double *x, int ldx, double *ferr, double *berr, _Complex double *work, double *rwork)
     * }
     */
    public static MemorySegment LAPACKE_ztrrfs_work$address() {
        return LAPACKE_ztrrfs_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ztrrfs_work(int matrix_layout, char uplo, char trans, char diag, int n, int nrhs, const _Complex double *a, int lda, const _Complex double *b, int ldb, const _Complex double *x, int ldx, double *ferr, double *berr, _Complex double *work, double *rwork)
     * }
     */
    public static int LAPACKE_ztrrfs_work(int matrix_layout, byte uplo, byte trans, byte diag, int n, int nrhs, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment ferr, MemorySegment berr, MemorySegment work, MemorySegment rwork) {
        var mh$ = LAPACKE_ztrrfs_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ztrrfs_work", matrix_layout, uplo, trans, diag, n, nrhs, a, lda, b, ldb, x, ldx, ferr, berr, work, rwork);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, trans, diag, n, nrhs, a, lda, b, ldb, x, ldx, ferr, berr, work, rwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_strsen_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_strsen_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_strsen_work(int matrix_layout, char job, char compq, const int *select, int n, float *t, int ldt, float *q, int ldq, float *wr, float *wi, int *m, float *s, float *sep, float *work, int lwork, int *iwork, int liwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_strsen_work$descriptor() {
        return LAPACKE_strsen_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_strsen_work(int matrix_layout, char job, char compq, const int *select, int n, float *t, int ldt, float *q, int ldq, float *wr, float *wi, int *m, float *s, float *sep, float *work, int lwork, int *iwork, int liwork)
     * }
     */
    public static MethodHandle LAPACKE_strsen_work$handle() {
        return LAPACKE_strsen_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_strsen_work(int matrix_layout, char job, char compq, const int *select, int n, float *t, int ldt, float *q, int ldq, float *wr, float *wi, int *m, float *s, float *sep, float *work, int lwork, int *iwork, int liwork)
     * }
     */
    public static MemorySegment LAPACKE_strsen_work$address() {
        return LAPACKE_strsen_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_strsen_work(int matrix_layout, char job, char compq, const int *select, int n, float *t, int ldt, float *q, int ldq, float *wr, float *wi, int *m, float *s, float *sep, float *work, int lwork, int *iwork, int liwork)
     * }
     */
    public static int LAPACKE_strsen_work(int matrix_layout, byte job, byte compq, MemorySegment select, int n, MemorySegment t, int ldt, MemorySegment q, int ldq, MemorySegment wr, MemorySegment wi, MemorySegment m, MemorySegment s, MemorySegment sep, MemorySegment work, int lwork, MemorySegment iwork, int liwork) {
        var mh$ = LAPACKE_strsen_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_strsen_work", matrix_layout, job, compq, select, n, t, ldt, q, ldq, wr, wi, m, s, sep, work, lwork, iwork, liwork);
            }
            return (int)mh$.invokeExact(matrix_layout, job, compq, select, n, t, ldt, q, ldq, wr, wi, m, s, sep, work, lwork, iwork, liwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dtrsen_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dtrsen_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dtrsen_work(int matrix_layout, char job, char compq, const int *select, int n, double *t, int ldt, double *q, int ldq, double *wr, double *wi, int *m, double *s, double *sep, double *work, int lwork, int *iwork, int liwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_dtrsen_work$descriptor() {
        return LAPACKE_dtrsen_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dtrsen_work(int matrix_layout, char job, char compq, const int *select, int n, double *t, int ldt, double *q, int ldq, double *wr, double *wi, int *m, double *s, double *sep, double *work, int lwork, int *iwork, int liwork)
     * }
     */
    public static MethodHandle LAPACKE_dtrsen_work$handle() {
        return LAPACKE_dtrsen_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dtrsen_work(int matrix_layout, char job, char compq, const int *select, int n, double *t, int ldt, double *q, int ldq, double *wr, double *wi, int *m, double *s, double *sep, double *work, int lwork, int *iwork, int liwork)
     * }
     */
    public static MemorySegment LAPACKE_dtrsen_work$address() {
        return LAPACKE_dtrsen_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dtrsen_work(int matrix_layout, char job, char compq, const int *select, int n, double *t, int ldt, double *q, int ldq, double *wr, double *wi, int *m, double *s, double *sep, double *work, int lwork, int *iwork, int liwork)
     * }
     */
    public static int LAPACKE_dtrsen_work(int matrix_layout, byte job, byte compq, MemorySegment select, int n, MemorySegment t, int ldt, MemorySegment q, int ldq, MemorySegment wr, MemorySegment wi, MemorySegment m, MemorySegment s, MemorySegment sep, MemorySegment work, int lwork, MemorySegment iwork, int liwork) {
        var mh$ = LAPACKE_dtrsen_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dtrsen_work", matrix_layout, job, compq, select, n, t, ldt, q, ldq, wr, wi, m, s, sep, work, lwork, iwork, liwork);
            }
            return (int)mh$.invokeExact(matrix_layout, job, compq, select, n, t, ldt, q, ldq, wr, wi, m, s, sep, work, lwork, iwork, liwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ctrsen_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_ctrsen_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ctrsen_work(int matrix_layout, char job, char compq, const int *select, int n, _Complex float *t, int ldt, _Complex float *q, int ldq, _Complex float *w, int *m, float *s, float *sep, _Complex float *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_ctrsen_work$descriptor() {
        return LAPACKE_ctrsen_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ctrsen_work(int matrix_layout, char job, char compq, const int *select, int n, _Complex float *t, int ldt, _Complex float *q, int ldq, _Complex float *w, int *m, float *s, float *sep, _Complex float *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_ctrsen_work$handle() {
        return LAPACKE_ctrsen_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ctrsen_work(int matrix_layout, char job, char compq, const int *select, int n, _Complex float *t, int ldt, _Complex float *q, int ldq, _Complex float *w, int *m, float *s, float *sep, _Complex float *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_ctrsen_work$address() {
        return LAPACKE_ctrsen_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ctrsen_work(int matrix_layout, char job, char compq, const int *select, int n, _Complex float *t, int ldt, _Complex float *q, int ldq, _Complex float *w, int *m, float *s, float *sep, _Complex float *work, int lwork)
     * }
     */
    public static int LAPACKE_ctrsen_work(int matrix_layout, byte job, byte compq, MemorySegment select, int n, MemorySegment t, int ldt, MemorySegment q, int ldq, MemorySegment w, MemorySegment m, MemorySegment s, MemorySegment sep, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_ctrsen_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ctrsen_work", matrix_layout, job, compq, select, n, t, ldt, q, ldq, w, m, s, sep, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, job, compq, select, n, t, ldt, q, ldq, w, m, s, sep, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ztrsen_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_ztrsen_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ztrsen_work(int matrix_layout, char job, char compq, const int *select, int n, _Complex double *t, int ldt, _Complex double *q, int ldq, _Complex double *w, int *m, double *s, double *sep, _Complex double *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_ztrsen_work$descriptor() {
        return LAPACKE_ztrsen_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ztrsen_work(int matrix_layout, char job, char compq, const int *select, int n, _Complex double *t, int ldt, _Complex double *q, int ldq, _Complex double *w, int *m, double *s, double *sep, _Complex double *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_ztrsen_work$handle() {
        return LAPACKE_ztrsen_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ztrsen_work(int matrix_layout, char job, char compq, const int *select, int n, _Complex double *t, int ldt, _Complex double *q, int ldq, _Complex double *w, int *m, double *s, double *sep, _Complex double *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_ztrsen_work$address() {
        return LAPACKE_ztrsen_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ztrsen_work(int matrix_layout, char job, char compq, const int *select, int n, _Complex double *t, int ldt, _Complex double *q, int ldq, _Complex double *w, int *m, double *s, double *sep, _Complex double *work, int lwork)
     * }
     */
    public static int LAPACKE_ztrsen_work(int matrix_layout, byte job, byte compq, MemorySegment select, int n, MemorySegment t, int ldt, MemorySegment q, int ldq, MemorySegment w, MemorySegment m, MemorySegment s, MemorySegment sep, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_ztrsen_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ztrsen_work", matrix_layout, job, compq, select, n, t, ldt, q, ldq, w, m, s, sep, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, job, compq, select, n, t, ldt, q, ldq, w, m, s, sep, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_strsna_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_strsna_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_strsna_work(int matrix_layout, char job, char howmny, const int *select, int n, const float *t, int ldt, const float *vl, int ldvl, const float *vr, int ldvr, float *s, float *sep, int mm, int *m, float *work, int ldwork, int *iwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_strsna_work$descriptor() {
        return LAPACKE_strsna_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_strsna_work(int matrix_layout, char job, char howmny, const int *select, int n, const float *t, int ldt, const float *vl, int ldvl, const float *vr, int ldvr, float *s, float *sep, int mm, int *m, float *work, int ldwork, int *iwork)
     * }
     */
    public static MethodHandle LAPACKE_strsna_work$handle() {
        return LAPACKE_strsna_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_strsna_work(int matrix_layout, char job, char howmny, const int *select, int n, const float *t, int ldt, const float *vl, int ldvl, const float *vr, int ldvr, float *s, float *sep, int mm, int *m, float *work, int ldwork, int *iwork)
     * }
     */
    public static MemorySegment LAPACKE_strsna_work$address() {
        return LAPACKE_strsna_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_strsna_work(int matrix_layout, char job, char howmny, const int *select, int n, const float *t, int ldt, const float *vl, int ldvl, const float *vr, int ldvr, float *s, float *sep, int mm, int *m, float *work, int ldwork, int *iwork)
     * }
     */
    public static int LAPACKE_strsna_work(int matrix_layout, byte job, byte howmny, MemorySegment select, int n, MemorySegment t, int ldt, MemorySegment vl, int ldvl, MemorySegment vr, int ldvr, MemorySegment s, MemorySegment sep, int mm, MemorySegment m, MemorySegment work, int ldwork, MemorySegment iwork) {
        var mh$ = LAPACKE_strsna_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_strsna_work", matrix_layout, job, howmny, select, n, t, ldt, vl, ldvl, vr, ldvr, s, sep, mm, m, work, ldwork, iwork);
            }
            return (int)mh$.invokeExact(matrix_layout, job, howmny, select, n, t, ldt, vl, ldvl, vr, ldvr, s, sep, mm, m, work, ldwork, iwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dtrsna_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dtrsna_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dtrsna_work(int matrix_layout, char job, char howmny, const int *select, int n, const double *t, int ldt, const double *vl, int ldvl, const double *vr, int ldvr, double *s, double *sep, int mm, int *m, double *work, int ldwork, int *iwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_dtrsna_work$descriptor() {
        return LAPACKE_dtrsna_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dtrsna_work(int matrix_layout, char job, char howmny, const int *select, int n, const double *t, int ldt, const double *vl, int ldvl, const double *vr, int ldvr, double *s, double *sep, int mm, int *m, double *work, int ldwork, int *iwork)
     * }
     */
    public static MethodHandle LAPACKE_dtrsna_work$handle() {
        return LAPACKE_dtrsna_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dtrsna_work(int matrix_layout, char job, char howmny, const int *select, int n, const double *t, int ldt, const double *vl, int ldvl, const double *vr, int ldvr, double *s, double *sep, int mm, int *m, double *work, int ldwork, int *iwork)
     * }
     */
    public static MemorySegment LAPACKE_dtrsna_work$address() {
        return LAPACKE_dtrsna_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dtrsna_work(int matrix_layout, char job, char howmny, const int *select, int n, const double *t, int ldt, const double *vl, int ldvl, const double *vr, int ldvr, double *s, double *sep, int mm, int *m, double *work, int ldwork, int *iwork)
     * }
     */
    public static int LAPACKE_dtrsna_work(int matrix_layout, byte job, byte howmny, MemorySegment select, int n, MemorySegment t, int ldt, MemorySegment vl, int ldvl, MemorySegment vr, int ldvr, MemorySegment s, MemorySegment sep, int mm, MemorySegment m, MemorySegment work, int ldwork, MemorySegment iwork) {
        var mh$ = LAPACKE_dtrsna_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dtrsna_work", matrix_layout, job, howmny, select, n, t, ldt, vl, ldvl, vr, ldvr, s, sep, mm, m, work, ldwork, iwork);
            }
            return (int)mh$.invokeExact(matrix_layout, job, howmny, select, n, t, ldt, vl, ldvl, vr, ldvr, s, sep, mm, m, work, ldwork, iwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ctrsna_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_ctrsna_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ctrsna_work(int matrix_layout, char job, char howmny, const int *select, int n, const _Complex float *t, int ldt, const _Complex float *vl, int ldvl, const _Complex float *vr, int ldvr, float *s, float *sep, int mm, int *m, _Complex float *work, int ldwork, float *rwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_ctrsna_work$descriptor() {
        return LAPACKE_ctrsna_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ctrsna_work(int matrix_layout, char job, char howmny, const int *select, int n, const _Complex float *t, int ldt, const _Complex float *vl, int ldvl, const _Complex float *vr, int ldvr, float *s, float *sep, int mm, int *m, _Complex float *work, int ldwork, float *rwork)
     * }
     */
    public static MethodHandle LAPACKE_ctrsna_work$handle() {
        return LAPACKE_ctrsna_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ctrsna_work(int matrix_layout, char job, char howmny, const int *select, int n, const _Complex float *t, int ldt, const _Complex float *vl, int ldvl, const _Complex float *vr, int ldvr, float *s, float *sep, int mm, int *m, _Complex float *work, int ldwork, float *rwork)
     * }
     */
    public static MemorySegment LAPACKE_ctrsna_work$address() {
        return LAPACKE_ctrsna_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ctrsna_work(int matrix_layout, char job, char howmny, const int *select, int n, const _Complex float *t, int ldt, const _Complex float *vl, int ldvl, const _Complex float *vr, int ldvr, float *s, float *sep, int mm, int *m, _Complex float *work, int ldwork, float *rwork)
     * }
     */
    public static int LAPACKE_ctrsna_work(int matrix_layout, byte job, byte howmny, MemorySegment select, int n, MemorySegment t, int ldt, MemorySegment vl, int ldvl, MemorySegment vr, int ldvr, MemorySegment s, MemorySegment sep, int mm, MemorySegment m, MemorySegment work, int ldwork, MemorySegment rwork) {
        var mh$ = LAPACKE_ctrsna_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ctrsna_work", matrix_layout, job, howmny, select, n, t, ldt, vl, ldvl, vr, ldvr, s, sep, mm, m, work, ldwork, rwork);
            }
            return (int)mh$.invokeExact(matrix_layout, job, howmny, select, n, t, ldt, vl, ldvl, vr, ldvr, s, sep, mm, m, work, ldwork, rwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ztrsna_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_ztrsna_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ztrsna_work(int matrix_layout, char job, char howmny, const int *select, int n, const _Complex double *t, int ldt, const _Complex double *vl, int ldvl, const _Complex double *vr, int ldvr, double *s, double *sep, int mm, int *m, _Complex double *work, int ldwork, double *rwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_ztrsna_work$descriptor() {
        return LAPACKE_ztrsna_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ztrsna_work(int matrix_layout, char job, char howmny, const int *select, int n, const _Complex double *t, int ldt, const _Complex double *vl, int ldvl, const _Complex double *vr, int ldvr, double *s, double *sep, int mm, int *m, _Complex double *work, int ldwork, double *rwork)
     * }
     */
    public static MethodHandle LAPACKE_ztrsna_work$handle() {
        return LAPACKE_ztrsna_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ztrsna_work(int matrix_layout, char job, char howmny, const int *select, int n, const _Complex double *t, int ldt, const _Complex double *vl, int ldvl, const _Complex double *vr, int ldvr, double *s, double *sep, int mm, int *m, _Complex double *work, int ldwork, double *rwork)
     * }
     */
    public static MemorySegment LAPACKE_ztrsna_work$address() {
        return LAPACKE_ztrsna_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ztrsna_work(int matrix_layout, char job, char howmny, const int *select, int n, const _Complex double *t, int ldt, const _Complex double *vl, int ldvl, const _Complex double *vr, int ldvr, double *s, double *sep, int mm, int *m, _Complex double *work, int ldwork, double *rwork)
     * }
     */
    public static int LAPACKE_ztrsna_work(int matrix_layout, byte job, byte howmny, MemorySegment select, int n, MemorySegment t, int ldt, MemorySegment vl, int ldvl, MemorySegment vr, int ldvr, MemorySegment s, MemorySegment sep, int mm, MemorySegment m, MemorySegment work, int ldwork, MemorySegment rwork) {
        var mh$ = LAPACKE_ztrsna_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ztrsna_work", matrix_layout, job, howmny, select, n, t, ldt, vl, ldvl, vr, ldvr, s, sep, mm, m, work, ldwork, rwork);
            }
            return (int)mh$.invokeExact(matrix_layout, job, howmny, select, n, t, ldt, vl, ldvl, vr, ldvr, s, sep, mm, m, work, ldwork, rwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_strsyl_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_strsyl_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_strsyl_work(int matrix_layout, char trana, char tranb, int isgn, int m, int n, const float *a, int lda, const float *b, int ldb, float *c, int ldc, float *scale)
     * }
     */
    public static FunctionDescriptor LAPACKE_strsyl_work$descriptor() {
        return LAPACKE_strsyl_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_strsyl_work(int matrix_layout, char trana, char tranb, int isgn, int m, int n, const float *a, int lda, const float *b, int ldb, float *c, int ldc, float *scale)
     * }
     */
    public static MethodHandle LAPACKE_strsyl_work$handle() {
        return LAPACKE_strsyl_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_strsyl_work(int matrix_layout, char trana, char tranb, int isgn, int m, int n, const float *a, int lda, const float *b, int ldb, float *c, int ldc, float *scale)
     * }
     */
    public static MemorySegment LAPACKE_strsyl_work$address() {
        return LAPACKE_strsyl_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_strsyl_work(int matrix_layout, char trana, char tranb, int isgn, int m, int n, const float *a, int lda, const float *b, int ldb, float *c, int ldc, float *scale)
     * }
     */
    public static int LAPACKE_strsyl_work(int matrix_layout, byte trana, byte tranb, int isgn, int m, int n, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment c, int ldc, MemorySegment scale) {
        var mh$ = LAPACKE_strsyl_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_strsyl_work", matrix_layout, trana, tranb, isgn, m, n, a, lda, b, ldb, c, ldc, scale);
            }
            return (int)mh$.invokeExact(matrix_layout, trana, tranb, isgn, m, n, a, lda, b, ldb, c, ldc, scale);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dtrsyl_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dtrsyl_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dtrsyl_work(int matrix_layout, char trana, char tranb, int isgn, int m, int n, const double *a, int lda, const double *b, int ldb, double *c, int ldc, double *scale)
     * }
     */
    public static FunctionDescriptor LAPACKE_dtrsyl_work$descriptor() {
        return LAPACKE_dtrsyl_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dtrsyl_work(int matrix_layout, char trana, char tranb, int isgn, int m, int n, const double *a, int lda, const double *b, int ldb, double *c, int ldc, double *scale)
     * }
     */
    public static MethodHandle LAPACKE_dtrsyl_work$handle() {
        return LAPACKE_dtrsyl_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dtrsyl_work(int matrix_layout, char trana, char tranb, int isgn, int m, int n, const double *a, int lda, const double *b, int ldb, double *c, int ldc, double *scale)
     * }
     */
    public static MemorySegment LAPACKE_dtrsyl_work$address() {
        return LAPACKE_dtrsyl_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dtrsyl_work(int matrix_layout, char trana, char tranb, int isgn, int m, int n, const double *a, int lda, const double *b, int ldb, double *c, int ldc, double *scale)
     * }
     */
    public static int LAPACKE_dtrsyl_work(int matrix_layout, byte trana, byte tranb, int isgn, int m, int n, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment c, int ldc, MemorySegment scale) {
        var mh$ = LAPACKE_dtrsyl_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dtrsyl_work", matrix_layout, trana, tranb, isgn, m, n, a, lda, b, ldb, c, ldc, scale);
            }
            return (int)mh$.invokeExact(matrix_layout, trana, tranb, isgn, m, n, a, lda, b, ldb, c, ldc, scale);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ctrsyl_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_ctrsyl_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ctrsyl_work(int matrix_layout, char trana, char tranb, int isgn, int m, int n, const _Complex float *a, int lda, const _Complex float *b, int ldb, _Complex float *c, int ldc, float *scale)
     * }
     */
    public static FunctionDescriptor LAPACKE_ctrsyl_work$descriptor() {
        return LAPACKE_ctrsyl_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ctrsyl_work(int matrix_layout, char trana, char tranb, int isgn, int m, int n, const _Complex float *a, int lda, const _Complex float *b, int ldb, _Complex float *c, int ldc, float *scale)
     * }
     */
    public static MethodHandle LAPACKE_ctrsyl_work$handle() {
        return LAPACKE_ctrsyl_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ctrsyl_work(int matrix_layout, char trana, char tranb, int isgn, int m, int n, const _Complex float *a, int lda, const _Complex float *b, int ldb, _Complex float *c, int ldc, float *scale)
     * }
     */
    public static MemorySegment LAPACKE_ctrsyl_work$address() {
        return LAPACKE_ctrsyl_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ctrsyl_work(int matrix_layout, char trana, char tranb, int isgn, int m, int n, const _Complex float *a, int lda, const _Complex float *b, int ldb, _Complex float *c, int ldc, float *scale)
     * }
     */
    public static int LAPACKE_ctrsyl_work(int matrix_layout, byte trana, byte tranb, int isgn, int m, int n, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment c, int ldc, MemorySegment scale) {
        var mh$ = LAPACKE_ctrsyl_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ctrsyl_work", matrix_layout, trana, tranb, isgn, m, n, a, lda, b, ldb, c, ldc, scale);
            }
            return (int)mh$.invokeExact(matrix_layout, trana, tranb, isgn, m, n, a, lda, b, ldb, c, ldc, scale);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ztrsyl_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_ztrsyl_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ztrsyl_work(int matrix_layout, char trana, char tranb, int isgn, int m, int n, const _Complex double *a, int lda, const _Complex double *b, int ldb, _Complex double *c, int ldc, double *scale)
     * }
     */
    public static FunctionDescriptor LAPACKE_ztrsyl_work$descriptor() {
        return LAPACKE_ztrsyl_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ztrsyl_work(int matrix_layout, char trana, char tranb, int isgn, int m, int n, const _Complex double *a, int lda, const _Complex double *b, int ldb, _Complex double *c, int ldc, double *scale)
     * }
     */
    public static MethodHandle LAPACKE_ztrsyl_work$handle() {
        return LAPACKE_ztrsyl_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ztrsyl_work(int matrix_layout, char trana, char tranb, int isgn, int m, int n, const _Complex double *a, int lda, const _Complex double *b, int ldb, _Complex double *c, int ldc, double *scale)
     * }
     */
    public static MemorySegment LAPACKE_ztrsyl_work$address() {
        return LAPACKE_ztrsyl_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ztrsyl_work(int matrix_layout, char trana, char tranb, int isgn, int m, int n, const _Complex double *a, int lda, const _Complex double *b, int ldb, _Complex double *c, int ldc, double *scale)
     * }
     */
    public static int LAPACKE_ztrsyl_work(int matrix_layout, byte trana, byte tranb, int isgn, int m, int n, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment c, int ldc, MemorySegment scale) {
        var mh$ = LAPACKE_ztrsyl_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ztrsyl_work", matrix_layout, trana, tranb, isgn, m, n, a, lda, b, ldb, c, ldc, scale);
            }
            return (int)mh$.invokeExact(matrix_layout, trana, tranb, isgn, m, n, a, lda, b, ldb, c, ldc, scale);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_strtri_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_strtri_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_strtri_work(int matrix_layout, char uplo, char diag, int n, float *a, int lda)
     * }
     */
    public static FunctionDescriptor LAPACKE_strtri_work$descriptor() {
        return LAPACKE_strtri_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_strtri_work(int matrix_layout, char uplo, char diag, int n, float *a, int lda)
     * }
     */
    public static MethodHandle LAPACKE_strtri_work$handle() {
        return LAPACKE_strtri_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_strtri_work(int matrix_layout, char uplo, char diag, int n, float *a, int lda)
     * }
     */
    public static MemorySegment LAPACKE_strtri_work$address() {
        return LAPACKE_strtri_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_strtri_work(int matrix_layout, char uplo, char diag, int n, float *a, int lda)
     * }
     */
    public static int LAPACKE_strtri_work(int matrix_layout, byte uplo, byte diag, int n, MemorySegment a, int lda) {
        var mh$ = LAPACKE_strtri_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_strtri_work", matrix_layout, uplo, diag, n, a, lda);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, diag, n, a, lda);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dtrtri_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dtrtri_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dtrtri_work(int matrix_layout, char uplo, char diag, int n, double *a, int lda)
     * }
     */
    public static FunctionDescriptor LAPACKE_dtrtri_work$descriptor() {
        return LAPACKE_dtrtri_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dtrtri_work(int matrix_layout, char uplo, char diag, int n, double *a, int lda)
     * }
     */
    public static MethodHandle LAPACKE_dtrtri_work$handle() {
        return LAPACKE_dtrtri_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dtrtri_work(int matrix_layout, char uplo, char diag, int n, double *a, int lda)
     * }
     */
    public static MemorySegment LAPACKE_dtrtri_work$address() {
        return LAPACKE_dtrtri_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dtrtri_work(int matrix_layout, char uplo, char diag, int n, double *a, int lda)
     * }
     */
    public static int LAPACKE_dtrtri_work(int matrix_layout, byte uplo, byte diag, int n, MemorySegment a, int lda) {
        var mh$ = LAPACKE_dtrtri_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dtrtri_work", matrix_layout, uplo, diag, n, a, lda);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, diag, n, a, lda);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ctrtri_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_ctrtri_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ctrtri_work(int matrix_layout, char uplo, char diag, int n, _Complex float *a, int lda)
     * }
     */
    public static FunctionDescriptor LAPACKE_ctrtri_work$descriptor() {
        return LAPACKE_ctrtri_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ctrtri_work(int matrix_layout, char uplo, char diag, int n, _Complex float *a, int lda)
     * }
     */
    public static MethodHandle LAPACKE_ctrtri_work$handle() {
        return LAPACKE_ctrtri_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ctrtri_work(int matrix_layout, char uplo, char diag, int n, _Complex float *a, int lda)
     * }
     */
    public static MemorySegment LAPACKE_ctrtri_work$address() {
        return LAPACKE_ctrtri_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ctrtri_work(int matrix_layout, char uplo, char diag, int n, _Complex float *a, int lda)
     * }
     */
    public static int LAPACKE_ctrtri_work(int matrix_layout, byte uplo, byte diag, int n, MemorySegment a, int lda) {
        var mh$ = LAPACKE_ctrtri_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ctrtri_work", matrix_layout, uplo, diag, n, a, lda);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, diag, n, a, lda);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ztrtri_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_ztrtri_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ztrtri_work(int matrix_layout, char uplo, char diag, int n, _Complex double *a, int lda)
     * }
     */
    public static FunctionDescriptor LAPACKE_ztrtri_work$descriptor() {
        return LAPACKE_ztrtri_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ztrtri_work(int matrix_layout, char uplo, char diag, int n, _Complex double *a, int lda)
     * }
     */
    public static MethodHandle LAPACKE_ztrtri_work$handle() {
        return LAPACKE_ztrtri_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ztrtri_work(int matrix_layout, char uplo, char diag, int n, _Complex double *a, int lda)
     * }
     */
    public static MemorySegment LAPACKE_ztrtri_work$address() {
        return LAPACKE_ztrtri_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ztrtri_work(int matrix_layout, char uplo, char diag, int n, _Complex double *a, int lda)
     * }
     */
    public static int LAPACKE_ztrtri_work(int matrix_layout, byte uplo, byte diag, int n, MemorySegment a, int lda) {
        var mh$ = LAPACKE_ztrtri_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ztrtri_work", matrix_layout, uplo, diag, n, a, lda);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, diag, n, a, lda);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_strtrs_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_strtrs_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_strtrs_work(int matrix_layout, char uplo, char trans, char diag, int n, int nrhs, const float *a, int lda, float *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_strtrs_work$descriptor() {
        return LAPACKE_strtrs_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_strtrs_work(int matrix_layout, char uplo, char trans, char diag, int n, int nrhs, const float *a, int lda, float *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_strtrs_work$handle() {
        return LAPACKE_strtrs_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_strtrs_work(int matrix_layout, char uplo, char trans, char diag, int n, int nrhs, const float *a, int lda, float *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_strtrs_work$address() {
        return LAPACKE_strtrs_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_strtrs_work(int matrix_layout, char uplo, char trans, char diag, int n, int nrhs, const float *a, int lda, float *b, int ldb)
     * }
     */
    public static int LAPACKE_strtrs_work(int matrix_layout, byte uplo, byte trans, byte diag, int n, int nrhs, MemorySegment a, int lda, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_strtrs_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_strtrs_work", matrix_layout, uplo, trans, diag, n, nrhs, a, lda, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, trans, diag, n, nrhs, a, lda, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dtrtrs_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dtrtrs_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dtrtrs_work(int matrix_layout, char uplo, char trans, char diag, int n, int nrhs, const double *a, int lda, double *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_dtrtrs_work$descriptor() {
        return LAPACKE_dtrtrs_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dtrtrs_work(int matrix_layout, char uplo, char trans, char diag, int n, int nrhs, const double *a, int lda, double *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_dtrtrs_work$handle() {
        return LAPACKE_dtrtrs_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dtrtrs_work(int matrix_layout, char uplo, char trans, char diag, int n, int nrhs, const double *a, int lda, double *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_dtrtrs_work$address() {
        return LAPACKE_dtrtrs_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dtrtrs_work(int matrix_layout, char uplo, char trans, char diag, int n, int nrhs, const double *a, int lda, double *b, int ldb)
     * }
     */
    public static int LAPACKE_dtrtrs_work(int matrix_layout, byte uplo, byte trans, byte diag, int n, int nrhs, MemorySegment a, int lda, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_dtrtrs_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dtrtrs_work", matrix_layout, uplo, trans, diag, n, nrhs, a, lda, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, trans, diag, n, nrhs, a, lda, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ctrtrs_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_ctrtrs_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ctrtrs_work(int matrix_layout, char uplo, char trans, char diag, int n, int nrhs, const _Complex float *a, int lda, _Complex float *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_ctrtrs_work$descriptor() {
        return LAPACKE_ctrtrs_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ctrtrs_work(int matrix_layout, char uplo, char trans, char diag, int n, int nrhs, const _Complex float *a, int lda, _Complex float *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_ctrtrs_work$handle() {
        return LAPACKE_ctrtrs_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ctrtrs_work(int matrix_layout, char uplo, char trans, char diag, int n, int nrhs, const _Complex float *a, int lda, _Complex float *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_ctrtrs_work$address() {
        return LAPACKE_ctrtrs_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ctrtrs_work(int matrix_layout, char uplo, char trans, char diag, int n, int nrhs, const _Complex float *a, int lda, _Complex float *b, int ldb)
     * }
     */
    public static int LAPACKE_ctrtrs_work(int matrix_layout, byte uplo, byte trans, byte diag, int n, int nrhs, MemorySegment a, int lda, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_ctrtrs_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ctrtrs_work", matrix_layout, uplo, trans, diag, n, nrhs, a, lda, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, trans, diag, n, nrhs, a, lda, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ztrtrs_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_ztrtrs_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ztrtrs_work(int matrix_layout, char uplo, char trans, char diag, int n, int nrhs, const _Complex double *a, int lda, _Complex double *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_ztrtrs_work$descriptor() {
        return LAPACKE_ztrtrs_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ztrtrs_work(int matrix_layout, char uplo, char trans, char diag, int n, int nrhs, const _Complex double *a, int lda, _Complex double *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_ztrtrs_work$handle() {
        return LAPACKE_ztrtrs_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ztrtrs_work(int matrix_layout, char uplo, char trans, char diag, int n, int nrhs, const _Complex double *a, int lda, _Complex double *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_ztrtrs_work$address() {
        return LAPACKE_ztrtrs_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ztrtrs_work(int matrix_layout, char uplo, char trans, char diag, int n, int nrhs, const _Complex double *a, int lda, _Complex double *b, int ldb)
     * }
     */
    public static int LAPACKE_ztrtrs_work(int matrix_layout, byte uplo, byte trans, byte diag, int n, int nrhs, MemorySegment a, int lda, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_ztrtrs_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ztrtrs_work", matrix_layout, uplo, trans, diag, n, nrhs, a, lda, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, trans, diag, n, nrhs, a, lda, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_strttf_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_strttf_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_strttf_work(int matrix_layout, char transr, char uplo, int n, const float *a, int lda, float *arf)
     * }
     */
    public static FunctionDescriptor LAPACKE_strttf_work$descriptor() {
        return LAPACKE_strttf_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_strttf_work(int matrix_layout, char transr, char uplo, int n, const float *a, int lda, float *arf)
     * }
     */
    public static MethodHandle LAPACKE_strttf_work$handle() {
        return LAPACKE_strttf_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_strttf_work(int matrix_layout, char transr, char uplo, int n, const float *a, int lda, float *arf)
     * }
     */
    public static MemorySegment LAPACKE_strttf_work$address() {
        return LAPACKE_strttf_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_strttf_work(int matrix_layout, char transr, char uplo, int n, const float *a, int lda, float *arf)
     * }
     */
    public static int LAPACKE_strttf_work(int matrix_layout, byte transr, byte uplo, int n, MemorySegment a, int lda, MemorySegment arf) {
        var mh$ = LAPACKE_strttf_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_strttf_work", matrix_layout, transr, uplo, n, a, lda, arf);
            }
            return (int)mh$.invokeExact(matrix_layout, transr, uplo, n, a, lda, arf);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dtrttf_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dtrttf_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dtrttf_work(int matrix_layout, char transr, char uplo, int n, const double *a, int lda, double *arf)
     * }
     */
    public static FunctionDescriptor LAPACKE_dtrttf_work$descriptor() {
        return LAPACKE_dtrttf_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dtrttf_work(int matrix_layout, char transr, char uplo, int n, const double *a, int lda, double *arf)
     * }
     */
    public static MethodHandle LAPACKE_dtrttf_work$handle() {
        return LAPACKE_dtrttf_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dtrttf_work(int matrix_layout, char transr, char uplo, int n, const double *a, int lda, double *arf)
     * }
     */
    public static MemorySegment LAPACKE_dtrttf_work$address() {
        return LAPACKE_dtrttf_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dtrttf_work(int matrix_layout, char transr, char uplo, int n, const double *a, int lda, double *arf)
     * }
     */
    public static int LAPACKE_dtrttf_work(int matrix_layout, byte transr, byte uplo, int n, MemorySegment a, int lda, MemorySegment arf) {
        var mh$ = LAPACKE_dtrttf_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dtrttf_work", matrix_layout, transr, uplo, n, a, lda, arf);
            }
            return (int)mh$.invokeExact(matrix_layout, transr, uplo, n, a, lda, arf);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ctrttf_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_ctrttf_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ctrttf_work(int matrix_layout, char transr, char uplo, int n, const _Complex float *a, int lda, _Complex float *arf)
     * }
     */
    public static FunctionDescriptor LAPACKE_ctrttf_work$descriptor() {
        return LAPACKE_ctrttf_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ctrttf_work(int matrix_layout, char transr, char uplo, int n, const _Complex float *a, int lda, _Complex float *arf)
     * }
     */
    public static MethodHandle LAPACKE_ctrttf_work$handle() {
        return LAPACKE_ctrttf_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ctrttf_work(int matrix_layout, char transr, char uplo, int n, const _Complex float *a, int lda, _Complex float *arf)
     * }
     */
    public static MemorySegment LAPACKE_ctrttf_work$address() {
        return LAPACKE_ctrttf_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ctrttf_work(int matrix_layout, char transr, char uplo, int n, const _Complex float *a, int lda, _Complex float *arf)
     * }
     */
    public static int LAPACKE_ctrttf_work(int matrix_layout, byte transr, byte uplo, int n, MemorySegment a, int lda, MemorySegment arf) {
        var mh$ = LAPACKE_ctrttf_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ctrttf_work", matrix_layout, transr, uplo, n, a, lda, arf);
            }
            return (int)mh$.invokeExact(matrix_layout, transr, uplo, n, a, lda, arf);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ztrttf_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_ztrttf_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ztrttf_work(int matrix_layout, char transr, char uplo, int n, const _Complex double *a, int lda, _Complex double *arf)
     * }
     */
    public static FunctionDescriptor LAPACKE_ztrttf_work$descriptor() {
        return LAPACKE_ztrttf_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ztrttf_work(int matrix_layout, char transr, char uplo, int n, const _Complex double *a, int lda, _Complex double *arf)
     * }
     */
    public static MethodHandle LAPACKE_ztrttf_work$handle() {
        return LAPACKE_ztrttf_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ztrttf_work(int matrix_layout, char transr, char uplo, int n, const _Complex double *a, int lda, _Complex double *arf)
     * }
     */
    public static MemorySegment LAPACKE_ztrttf_work$address() {
        return LAPACKE_ztrttf_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ztrttf_work(int matrix_layout, char transr, char uplo, int n, const _Complex double *a, int lda, _Complex double *arf)
     * }
     */
    public static int LAPACKE_ztrttf_work(int matrix_layout, byte transr, byte uplo, int n, MemorySegment a, int lda, MemorySegment arf) {
        var mh$ = LAPACKE_ztrttf_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ztrttf_work", matrix_layout, transr, uplo, n, a, lda, arf);
            }
            return (int)mh$.invokeExact(matrix_layout, transr, uplo, n, a, lda, arf);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_strttp_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_strttp_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_strttp_work(int matrix_layout, char uplo, int n, const float *a, int lda, float *ap)
     * }
     */
    public static FunctionDescriptor LAPACKE_strttp_work$descriptor() {
        return LAPACKE_strttp_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_strttp_work(int matrix_layout, char uplo, int n, const float *a, int lda, float *ap)
     * }
     */
    public static MethodHandle LAPACKE_strttp_work$handle() {
        return LAPACKE_strttp_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_strttp_work(int matrix_layout, char uplo, int n, const float *a, int lda, float *ap)
     * }
     */
    public static MemorySegment LAPACKE_strttp_work$address() {
        return LAPACKE_strttp_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_strttp_work(int matrix_layout, char uplo, int n, const float *a, int lda, float *ap)
     * }
     */
    public static int LAPACKE_strttp_work(int matrix_layout, byte uplo, int n, MemorySegment a, int lda, MemorySegment ap) {
        var mh$ = LAPACKE_strttp_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_strttp_work", matrix_layout, uplo, n, a, lda, ap);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, a, lda, ap);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dtrttp_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dtrttp_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dtrttp_work(int matrix_layout, char uplo, int n, const double *a, int lda, double *ap)
     * }
     */
    public static FunctionDescriptor LAPACKE_dtrttp_work$descriptor() {
        return LAPACKE_dtrttp_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dtrttp_work(int matrix_layout, char uplo, int n, const double *a, int lda, double *ap)
     * }
     */
    public static MethodHandle LAPACKE_dtrttp_work$handle() {
        return LAPACKE_dtrttp_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dtrttp_work(int matrix_layout, char uplo, int n, const double *a, int lda, double *ap)
     * }
     */
    public static MemorySegment LAPACKE_dtrttp_work$address() {
        return LAPACKE_dtrttp_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dtrttp_work(int matrix_layout, char uplo, int n, const double *a, int lda, double *ap)
     * }
     */
    public static int LAPACKE_dtrttp_work(int matrix_layout, byte uplo, int n, MemorySegment a, int lda, MemorySegment ap) {
        var mh$ = LAPACKE_dtrttp_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dtrttp_work", matrix_layout, uplo, n, a, lda, ap);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, a, lda, ap);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ctrttp_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_ctrttp_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ctrttp_work(int matrix_layout, char uplo, int n, const _Complex float *a, int lda, _Complex float *ap)
     * }
     */
    public static FunctionDescriptor LAPACKE_ctrttp_work$descriptor() {
        return LAPACKE_ctrttp_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ctrttp_work(int matrix_layout, char uplo, int n, const _Complex float *a, int lda, _Complex float *ap)
     * }
     */
    public static MethodHandle LAPACKE_ctrttp_work$handle() {
        return LAPACKE_ctrttp_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ctrttp_work(int matrix_layout, char uplo, int n, const _Complex float *a, int lda, _Complex float *ap)
     * }
     */
    public static MemorySegment LAPACKE_ctrttp_work$address() {
        return LAPACKE_ctrttp_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ctrttp_work(int matrix_layout, char uplo, int n, const _Complex float *a, int lda, _Complex float *ap)
     * }
     */
    public static int LAPACKE_ctrttp_work(int matrix_layout, byte uplo, int n, MemorySegment a, int lda, MemorySegment ap) {
        var mh$ = LAPACKE_ctrttp_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ctrttp_work", matrix_layout, uplo, n, a, lda, ap);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, a, lda, ap);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ztrttp_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_ztrttp_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ztrttp_work(int matrix_layout, char uplo, int n, const _Complex double *a, int lda, _Complex double *ap)
     * }
     */
    public static FunctionDescriptor LAPACKE_ztrttp_work$descriptor() {
        return LAPACKE_ztrttp_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ztrttp_work(int matrix_layout, char uplo, int n, const _Complex double *a, int lda, _Complex double *ap)
     * }
     */
    public static MethodHandle LAPACKE_ztrttp_work$handle() {
        return LAPACKE_ztrttp_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ztrttp_work(int matrix_layout, char uplo, int n, const _Complex double *a, int lda, _Complex double *ap)
     * }
     */
    public static MemorySegment LAPACKE_ztrttp_work$address() {
        return LAPACKE_ztrttp_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ztrttp_work(int matrix_layout, char uplo, int n, const _Complex double *a, int lda, _Complex double *ap)
     * }
     */
    public static int LAPACKE_ztrttp_work(int matrix_layout, byte uplo, int n, MemorySegment a, int lda, MemorySegment ap) {
        var mh$ = LAPACKE_ztrttp_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ztrttp_work", matrix_layout, uplo, n, a, lda, ap);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, a, lda, ap);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_stzrzf_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_stzrzf_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_stzrzf_work(int matrix_layout, int m, int n, float *a, int lda, float *tau, float *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_stzrzf_work$descriptor() {
        return LAPACKE_stzrzf_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_stzrzf_work(int matrix_layout, int m, int n, float *a, int lda, float *tau, float *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_stzrzf_work$handle() {
        return LAPACKE_stzrzf_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_stzrzf_work(int matrix_layout, int m, int n, float *a, int lda, float *tau, float *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_stzrzf_work$address() {
        return LAPACKE_stzrzf_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_stzrzf_work(int matrix_layout, int m, int n, float *a, int lda, float *tau, float *work, int lwork)
     * }
     */
    public static int LAPACKE_stzrzf_work(int matrix_layout, int m, int n, MemorySegment a, int lda, MemorySegment tau, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_stzrzf_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_stzrzf_work", matrix_layout, m, n, a, lda, tau, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, a, lda, tau, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dtzrzf_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dtzrzf_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dtzrzf_work(int matrix_layout, int m, int n, double *a, int lda, double *tau, double *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_dtzrzf_work$descriptor() {
        return LAPACKE_dtzrzf_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dtzrzf_work(int matrix_layout, int m, int n, double *a, int lda, double *tau, double *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_dtzrzf_work$handle() {
        return LAPACKE_dtzrzf_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dtzrzf_work(int matrix_layout, int m, int n, double *a, int lda, double *tau, double *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_dtzrzf_work$address() {
        return LAPACKE_dtzrzf_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dtzrzf_work(int matrix_layout, int m, int n, double *a, int lda, double *tau, double *work, int lwork)
     * }
     */
    public static int LAPACKE_dtzrzf_work(int matrix_layout, int m, int n, MemorySegment a, int lda, MemorySegment tau, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_dtzrzf_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dtzrzf_work", matrix_layout, m, n, a, lda, tau, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, a, lda, tau, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ctzrzf_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_ctzrzf_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ctzrzf_work(int matrix_layout, int m, int n, _Complex float *a, int lda, _Complex float *tau, _Complex float *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_ctzrzf_work$descriptor() {
        return LAPACKE_ctzrzf_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ctzrzf_work(int matrix_layout, int m, int n, _Complex float *a, int lda, _Complex float *tau, _Complex float *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_ctzrzf_work$handle() {
        return LAPACKE_ctzrzf_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ctzrzf_work(int matrix_layout, int m, int n, _Complex float *a, int lda, _Complex float *tau, _Complex float *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_ctzrzf_work$address() {
        return LAPACKE_ctzrzf_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ctzrzf_work(int matrix_layout, int m, int n, _Complex float *a, int lda, _Complex float *tau, _Complex float *work, int lwork)
     * }
     */
    public static int LAPACKE_ctzrzf_work(int matrix_layout, int m, int n, MemorySegment a, int lda, MemorySegment tau, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_ctzrzf_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ctzrzf_work", matrix_layout, m, n, a, lda, tau, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, a, lda, tau, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ztzrzf_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_ztzrzf_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ztzrzf_work(int matrix_layout, int m, int n, _Complex double *a, int lda, _Complex double *tau, _Complex double *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_ztzrzf_work$descriptor() {
        return LAPACKE_ztzrzf_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ztzrzf_work(int matrix_layout, int m, int n, _Complex double *a, int lda, _Complex double *tau, _Complex double *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_ztzrzf_work$handle() {
        return LAPACKE_ztzrzf_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ztzrzf_work(int matrix_layout, int m, int n, _Complex double *a, int lda, _Complex double *tau, _Complex double *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_ztzrzf_work$address() {
        return LAPACKE_ztzrzf_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ztzrzf_work(int matrix_layout, int m, int n, _Complex double *a, int lda, _Complex double *tau, _Complex double *work, int lwork)
     * }
     */
    public static int LAPACKE_ztzrzf_work(int matrix_layout, int m, int n, MemorySegment a, int lda, MemorySegment tau, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_ztzrzf_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ztzrzf_work", matrix_layout, m, n, a, lda, tau, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, a, lda, tau, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cungbr_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_cungbr_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cungbr_work(int matrix_layout, char vect, int m, int n, int k, _Complex float *a, int lda, const _Complex float *tau, _Complex float *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_cungbr_work$descriptor() {
        return LAPACKE_cungbr_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cungbr_work(int matrix_layout, char vect, int m, int n, int k, _Complex float *a, int lda, const _Complex float *tau, _Complex float *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_cungbr_work$handle() {
        return LAPACKE_cungbr_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cungbr_work(int matrix_layout, char vect, int m, int n, int k, _Complex float *a, int lda, const _Complex float *tau, _Complex float *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_cungbr_work$address() {
        return LAPACKE_cungbr_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cungbr_work(int matrix_layout, char vect, int m, int n, int k, _Complex float *a, int lda, const _Complex float *tau, _Complex float *work, int lwork)
     * }
     */
    public static int LAPACKE_cungbr_work(int matrix_layout, byte vect, int m, int n, int k, MemorySegment a, int lda, MemorySegment tau, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_cungbr_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cungbr_work", matrix_layout, vect, m, n, k, a, lda, tau, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, vect, m, n, k, a, lda, tau, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zungbr_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zungbr_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zungbr_work(int matrix_layout, char vect, int m, int n, int k, _Complex double *a, int lda, const _Complex double *tau, _Complex double *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_zungbr_work$descriptor() {
        return LAPACKE_zungbr_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zungbr_work(int matrix_layout, char vect, int m, int n, int k, _Complex double *a, int lda, const _Complex double *tau, _Complex double *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_zungbr_work$handle() {
        return LAPACKE_zungbr_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zungbr_work(int matrix_layout, char vect, int m, int n, int k, _Complex double *a, int lda, const _Complex double *tau, _Complex double *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_zungbr_work$address() {
        return LAPACKE_zungbr_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zungbr_work(int matrix_layout, char vect, int m, int n, int k, _Complex double *a, int lda, const _Complex double *tau, _Complex double *work, int lwork)
     * }
     */
    public static int LAPACKE_zungbr_work(int matrix_layout, byte vect, int m, int n, int k, MemorySegment a, int lda, MemorySegment tau, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_zungbr_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zungbr_work", matrix_layout, vect, m, n, k, a, lda, tau, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, vect, m, n, k, a, lda, tau, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cunghr_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_cunghr_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cunghr_work(int matrix_layout, int n, int ilo, int ihi, _Complex float *a, int lda, const _Complex float *tau, _Complex float *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_cunghr_work$descriptor() {
        return LAPACKE_cunghr_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cunghr_work(int matrix_layout, int n, int ilo, int ihi, _Complex float *a, int lda, const _Complex float *tau, _Complex float *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_cunghr_work$handle() {
        return LAPACKE_cunghr_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cunghr_work(int matrix_layout, int n, int ilo, int ihi, _Complex float *a, int lda, const _Complex float *tau, _Complex float *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_cunghr_work$address() {
        return LAPACKE_cunghr_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cunghr_work(int matrix_layout, int n, int ilo, int ihi, _Complex float *a, int lda, const _Complex float *tau, _Complex float *work, int lwork)
     * }
     */
    public static int LAPACKE_cunghr_work(int matrix_layout, int n, int ilo, int ihi, MemorySegment a, int lda, MemorySegment tau, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_cunghr_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cunghr_work", matrix_layout, n, ilo, ihi, a, lda, tau, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, n, ilo, ihi, a, lda, tau, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zunghr_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zunghr_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zunghr_work(int matrix_layout, int n, int ilo, int ihi, _Complex double *a, int lda, const _Complex double *tau, _Complex double *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_zunghr_work$descriptor() {
        return LAPACKE_zunghr_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zunghr_work(int matrix_layout, int n, int ilo, int ihi, _Complex double *a, int lda, const _Complex double *tau, _Complex double *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_zunghr_work$handle() {
        return LAPACKE_zunghr_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zunghr_work(int matrix_layout, int n, int ilo, int ihi, _Complex double *a, int lda, const _Complex double *tau, _Complex double *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_zunghr_work$address() {
        return LAPACKE_zunghr_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zunghr_work(int matrix_layout, int n, int ilo, int ihi, _Complex double *a, int lda, const _Complex double *tau, _Complex double *work, int lwork)
     * }
     */
    public static int LAPACKE_zunghr_work(int matrix_layout, int n, int ilo, int ihi, MemorySegment a, int lda, MemorySegment tau, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_zunghr_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zunghr_work", matrix_layout, n, ilo, ihi, a, lda, tau, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, n, ilo, ihi, a, lda, tau, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cunglq_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_cunglq_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cunglq_work(int matrix_layout, int m, int n, int k, _Complex float *a, int lda, const _Complex float *tau, _Complex float *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_cunglq_work$descriptor() {
        return LAPACKE_cunglq_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cunglq_work(int matrix_layout, int m, int n, int k, _Complex float *a, int lda, const _Complex float *tau, _Complex float *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_cunglq_work$handle() {
        return LAPACKE_cunglq_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cunglq_work(int matrix_layout, int m, int n, int k, _Complex float *a, int lda, const _Complex float *tau, _Complex float *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_cunglq_work$address() {
        return LAPACKE_cunglq_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cunglq_work(int matrix_layout, int m, int n, int k, _Complex float *a, int lda, const _Complex float *tau, _Complex float *work, int lwork)
     * }
     */
    public static int LAPACKE_cunglq_work(int matrix_layout, int m, int n, int k, MemorySegment a, int lda, MemorySegment tau, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_cunglq_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cunglq_work", matrix_layout, m, n, k, a, lda, tau, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, k, a, lda, tau, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zunglq_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zunglq_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zunglq_work(int matrix_layout, int m, int n, int k, _Complex double *a, int lda, const _Complex double *tau, _Complex double *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_zunglq_work$descriptor() {
        return LAPACKE_zunglq_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zunglq_work(int matrix_layout, int m, int n, int k, _Complex double *a, int lda, const _Complex double *tau, _Complex double *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_zunglq_work$handle() {
        return LAPACKE_zunglq_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zunglq_work(int matrix_layout, int m, int n, int k, _Complex double *a, int lda, const _Complex double *tau, _Complex double *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_zunglq_work$address() {
        return LAPACKE_zunglq_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zunglq_work(int matrix_layout, int m, int n, int k, _Complex double *a, int lda, const _Complex double *tau, _Complex double *work, int lwork)
     * }
     */
    public static int LAPACKE_zunglq_work(int matrix_layout, int m, int n, int k, MemorySegment a, int lda, MemorySegment tau, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_zunglq_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zunglq_work", matrix_layout, m, n, k, a, lda, tau, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, k, a, lda, tau, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cungql_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_cungql_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cungql_work(int matrix_layout, int m, int n, int k, _Complex float *a, int lda, const _Complex float *tau, _Complex float *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_cungql_work$descriptor() {
        return LAPACKE_cungql_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cungql_work(int matrix_layout, int m, int n, int k, _Complex float *a, int lda, const _Complex float *tau, _Complex float *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_cungql_work$handle() {
        return LAPACKE_cungql_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cungql_work(int matrix_layout, int m, int n, int k, _Complex float *a, int lda, const _Complex float *tau, _Complex float *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_cungql_work$address() {
        return LAPACKE_cungql_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cungql_work(int matrix_layout, int m, int n, int k, _Complex float *a, int lda, const _Complex float *tau, _Complex float *work, int lwork)
     * }
     */
    public static int LAPACKE_cungql_work(int matrix_layout, int m, int n, int k, MemorySegment a, int lda, MemorySegment tau, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_cungql_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cungql_work", matrix_layout, m, n, k, a, lda, tau, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, k, a, lda, tau, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zungql_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zungql_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zungql_work(int matrix_layout, int m, int n, int k, _Complex double *a, int lda, const _Complex double *tau, _Complex double *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_zungql_work$descriptor() {
        return LAPACKE_zungql_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zungql_work(int matrix_layout, int m, int n, int k, _Complex double *a, int lda, const _Complex double *tau, _Complex double *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_zungql_work$handle() {
        return LAPACKE_zungql_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zungql_work(int matrix_layout, int m, int n, int k, _Complex double *a, int lda, const _Complex double *tau, _Complex double *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_zungql_work$address() {
        return LAPACKE_zungql_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zungql_work(int matrix_layout, int m, int n, int k, _Complex double *a, int lda, const _Complex double *tau, _Complex double *work, int lwork)
     * }
     */
    public static int LAPACKE_zungql_work(int matrix_layout, int m, int n, int k, MemorySegment a, int lda, MemorySegment tau, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_zungql_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zungql_work", matrix_layout, m, n, k, a, lda, tau, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, k, a, lda, tau, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cungqr_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_cungqr_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cungqr_work(int matrix_layout, int m, int n, int k, _Complex float *a, int lda, const _Complex float *tau, _Complex float *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_cungqr_work$descriptor() {
        return LAPACKE_cungqr_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cungqr_work(int matrix_layout, int m, int n, int k, _Complex float *a, int lda, const _Complex float *tau, _Complex float *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_cungqr_work$handle() {
        return LAPACKE_cungqr_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cungqr_work(int matrix_layout, int m, int n, int k, _Complex float *a, int lda, const _Complex float *tau, _Complex float *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_cungqr_work$address() {
        return LAPACKE_cungqr_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cungqr_work(int matrix_layout, int m, int n, int k, _Complex float *a, int lda, const _Complex float *tau, _Complex float *work, int lwork)
     * }
     */
    public static int LAPACKE_cungqr_work(int matrix_layout, int m, int n, int k, MemorySegment a, int lda, MemorySegment tau, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_cungqr_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cungqr_work", matrix_layout, m, n, k, a, lda, tau, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, k, a, lda, tau, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zungqr_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zungqr_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zungqr_work(int matrix_layout, int m, int n, int k, _Complex double *a, int lda, const _Complex double *tau, _Complex double *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_zungqr_work$descriptor() {
        return LAPACKE_zungqr_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zungqr_work(int matrix_layout, int m, int n, int k, _Complex double *a, int lda, const _Complex double *tau, _Complex double *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_zungqr_work$handle() {
        return LAPACKE_zungqr_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zungqr_work(int matrix_layout, int m, int n, int k, _Complex double *a, int lda, const _Complex double *tau, _Complex double *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_zungqr_work$address() {
        return LAPACKE_zungqr_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zungqr_work(int matrix_layout, int m, int n, int k, _Complex double *a, int lda, const _Complex double *tau, _Complex double *work, int lwork)
     * }
     */
    public static int LAPACKE_zungqr_work(int matrix_layout, int m, int n, int k, MemorySegment a, int lda, MemorySegment tau, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_zungqr_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zungqr_work", matrix_layout, m, n, k, a, lda, tau, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, k, a, lda, tau, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cungrq_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_cungrq_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cungrq_work(int matrix_layout, int m, int n, int k, _Complex float *a, int lda, const _Complex float *tau, _Complex float *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_cungrq_work$descriptor() {
        return LAPACKE_cungrq_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cungrq_work(int matrix_layout, int m, int n, int k, _Complex float *a, int lda, const _Complex float *tau, _Complex float *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_cungrq_work$handle() {
        return LAPACKE_cungrq_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cungrq_work(int matrix_layout, int m, int n, int k, _Complex float *a, int lda, const _Complex float *tau, _Complex float *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_cungrq_work$address() {
        return LAPACKE_cungrq_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cungrq_work(int matrix_layout, int m, int n, int k, _Complex float *a, int lda, const _Complex float *tau, _Complex float *work, int lwork)
     * }
     */
    public static int LAPACKE_cungrq_work(int matrix_layout, int m, int n, int k, MemorySegment a, int lda, MemorySegment tau, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_cungrq_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cungrq_work", matrix_layout, m, n, k, a, lda, tau, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, k, a, lda, tau, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zungrq_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zungrq_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zungrq_work(int matrix_layout, int m, int n, int k, _Complex double *a, int lda, const _Complex double *tau, _Complex double *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_zungrq_work$descriptor() {
        return LAPACKE_zungrq_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zungrq_work(int matrix_layout, int m, int n, int k, _Complex double *a, int lda, const _Complex double *tau, _Complex double *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_zungrq_work$handle() {
        return LAPACKE_zungrq_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zungrq_work(int matrix_layout, int m, int n, int k, _Complex double *a, int lda, const _Complex double *tau, _Complex double *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_zungrq_work$address() {
        return LAPACKE_zungrq_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zungrq_work(int matrix_layout, int m, int n, int k, _Complex double *a, int lda, const _Complex double *tau, _Complex double *work, int lwork)
     * }
     */
    public static int LAPACKE_zungrq_work(int matrix_layout, int m, int n, int k, MemorySegment a, int lda, MemorySegment tau, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_zungrq_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zungrq_work", matrix_layout, m, n, k, a, lda, tau, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, k, a, lda, tau, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cungtr_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_cungtr_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cungtr_work(int matrix_layout, char uplo, int n, _Complex float *a, int lda, const _Complex float *tau, _Complex float *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_cungtr_work$descriptor() {
        return LAPACKE_cungtr_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cungtr_work(int matrix_layout, char uplo, int n, _Complex float *a, int lda, const _Complex float *tau, _Complex float *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_cungtr_work$handle() {
        return LAPACKE_cungtr_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cungtr_work(int matrix_layout, char uplo, int n, _Complex float *a, int lda, const _Complex float *tau, _Complex float *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_cungtr_work$address() {
        return LAPACKE_cungtr_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cungtr_work(int matrix_layout, char uplo, int n, _Complex float *a, int lda, const _Complex float *tau, _Complex float *work, int lwork)
     * }
     */
    public static int LAPACKE_cungtr_work(int matrix_layout, byte uplo, int n, MemorySegment a, int lda, MemorySegment tau, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_cungtr_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cungtr_work", matrix_layout, uplo, n, a, lda, tau, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, a, lda, tau, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zungtr_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zungtr_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zungtr_work(int matrix_layout, char uplo, int n, _Complex double *a, int lda, const _Complex double *tau, _Complex double *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_zungtr_work$descriptor() {
        return LAPACKE_zungtr_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zungtr_work(int matrix_layout, char uplo, int n, _Complex double *a, int lda, const _Complex double *tau, _Complex double *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_zungtr_work$handle() {
        return LAPACKE_zungtr_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zungtr_work(int matrix_layout, char uplo, int n, _Complex double *a, int lda, const _Complex double *tau, _Complex double *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_zungtr_work$address() {
        return LAPACKE_zungtr_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zungtr_work(int matrix_layout, char uplo, int n, _Complex double *a, int lda, const _Complex double *tau, _Complex double *work, int lwork)
     * }
     */
    public static int LAPACKE_zungtr_work(int matrix_layout, byte uplo, int n, MemorySegment a, int lda, MemorySegment tau, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_zungtr_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zungtr_work", matrix_layout, uplo, n, a, lda, tau, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, a, lda, tau, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cungtsqr_row_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_cungtsqr_row_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cungtsqr_row_work(int matrix_layout, int m, int n, int mb, int nb, _Complex float *a, int lda, const _Complex float *t, int ldt, _Complex float *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_cungtsqr_row_work$descriptor() {
        return LAPACKE_cungtsqr_row_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cungtsqr_row_work(int matrix_layout, int m, int n, int mb, int nb, _Complex float *a, int lda, const _Complex float *t, int ldt, _Complex float *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_cungtsqr_row_work$handle() {
        return LAPACKE_cungtsqr_row_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cungtsqr_row_work(int matrix_layout, int m, int n, int mb, int nb, _Complex float *a, int lda, const _Complex float *t, int ldt, _Complex float *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_cungtsqr_row_work$address() {
        return LAPACKE_cungtsqr_row_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cungtsqr_row_work(int matrix_layout, int m, int n, int mb, int nb, _Complex float *a, int lda, const _Complex float *t, int ldt, _Complex float *work, int lwork)
     * }
     */
    public static int LAPACKE_cungtsqr_row_work(int matrix_layout, int m, int n, int mb, int nb, MemorySegment a, int lda, MemorySegment t, int ldt, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_cungtsqr_row_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cungtsqr_row_work", matrix_layout, m, n, mb, nb, a, lda, t, ldt, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, mb, nb, a, lda, t, ldt, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zungtsqr_row_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zungtsqr_row_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zungtsqr_row_work(int matrix_layout, int m, int n, int mb, int nb, _Complex double *a, int lda, const _Complex double *t, int ldt, _Complex double *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_zungtsqr_row_work$descriptor() {
        return LAPACKE_zungtsqr_row_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zungtsqr_row_work(int matrix_layout, int m, int n, int mb, int nb, _Complex double *a, int lda, const _Complex double *t, int ldt, _Complex double *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_zungtsqr_row_work$handle() {
        return LAPACKE_zungtsqr_row_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zungtsqr_row_work(int matrix_layout, int m, int n, int mb, int nb, _Complex double *a, int lda, const _Complex double *t, int ldt, _Complex double *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_zungtsqr_row_work$address() {
        return LAPACKE_zungtsqr_row_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zungtsqr_row_work(int matrix_layout, int m, int n, int mb, int nb, _Complex double *a, int lda, const _Complex double *t, int ldt, _Complex double *work, int lwork)
     * }
     */
    public static int LAPACKE_zungtsqr_row_work(int matrix_layout, int m, int n, int mb, int nb, MemorySegment a, int lda, MemorySegment t, int ldt, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_zungtsqr_row_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zungtsqr_row_work", matrix_layout, m, n, mb, nb, a, lda, t, ldt, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, mb, nb, a, lda, t, ldt, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cunmbr_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_cunmbr_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cunmbr_work(int matrix_layout, char vect, char side, char trans, int m, int n, int k, const _Complex float *a, int lda, const _Complex float *tau, _Complex float *c, int ldc, _Complex float *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_cunmbr_work$descriptor() {
        return LAPACKE_cunmbr_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cunmbr_work(int matrix_layout, char vect, char side, char trans, int m, int n, int k, const _Complex float *a, int lda, const _Complex float *tau, _Complex float *c, int ldc, _Complex float *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_cunmbr_work$handle() {
        return LAPACKE_cunmbr_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cunmbr_work(int matrix_layout, char vect, char side, char trans, int m, int n, int k, const _Complex float *a, int lda, const _Complex float *tau, _Complex float *c, int ldc, _Complex float *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_cunmbr_work$address() {
        return LAPACKE_cunmbr_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cunmbr_work(int matrix_layout, char vect, char side, char trans, int m, int n, int k, const _Complex float *a, int lda, const _Complex float *tau, _Complex float *c, int ldc, _Complex float *work, int lwork)
     * }
     */
    public static int LAPACKE_cunmbr_work(int matrix_layout, byte vect, byte side, byte trans, int m, int n, int k, MemorySegment a, int lda, MemorySegment tau, MemorySegment c, int ldc, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_cunmbr_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cunmbr_work", matrix_layout, vect, side, trans, m, n, k, a, lda, tau, c, ldc, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, vect, side, trans, m, n, k, a, lda, tau, c, ldc, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zunmbr_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zunmbr_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zunmbr_work(int matrix_layout, char vect, char side, char trans, int m, int n, int k, const _Complex double *a, int lda, const _Complex double *tau, _Complex double *c, int ldc, _Complex double *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_zunmbr_work$descriptor() {
        return LAPACKE_zunmbr_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zunmbr_work(int matrix_layout, char vect, char side, char trans, int m, int n, int k, const _Complex double *a, int lda, const _Complex double *tau, _Complex double *c, int ldc, _Complex double *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_zunmbr_work$handle() {
        return LAPACKE_zunmbr_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zunmbr_work(int matrix_layout, char vect, char side, char trans, int m, int n, int k, const _Complex double *a, int lda, const _Complex double *tau, _Complex double *c, int ldc, _Complex double *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_zunmbr_work$address() {
        return LAPACKE_zunmbr_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zunmbr_work(int matrix_layout, char vect, char side, char trans, int m, int n, int k, const _Complex double *a, int lda, const _Complex double *tau, _Complex double *c, int ldc, _Complex double *work, int lwork)
     * }
     */
    public static int LAPACKE_zunmbr_work(int matrix_layout, byte vect, byte side, byte trans, int m, int n, int k, MemorySegment a, int lda, MemorySegment tau, MemorySegment c, int ldc, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_zunmbr_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zunmbr_work", matrix_layout, vect, side, trans, m, n, k, a, lda, tau, c, ldc, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, vect, side, trans, m, n, k, a, lda, tau, c, ldc, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cunmhr_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_cunmhr_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cunmhr_work(int matrix_layout, char side, char trans, int m, int n, int ilo, int ihi, const _Complex float *a, int lda, const _Complex float *tau, _Complex float *c, int ldc, _Complex float *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_cunmhr_work$descriptor() {
        return LAPACKE_cunmhr_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cunmhr_work(int matrix_layout, char side, char trans, int m, int n, int ilo, int ihi, const _Complex float *a, int lda, const _Complex float *tau, _Complex float *c, int ldc, _Complex float *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_cunmhr_work$handle() {
        return LAPACKE_cunmhr_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cunmhr_work(int matrix_layout, char side, char trans, int m, int n, int ilo, int ihi, const _Complex float *a, int lda, const _Complex float *tau, _Complex float *c, int ldc, _Complex float *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_cunmhr_work$address() {
        return LAPACKE_cunmhr_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cunmhr_work(int matrix_layout, char side, char trans, int m, int n, int ilo, int ihi, const _Complex float *a, int lda, const _Complex float *tau, _Complex float *c, int ldc, _Complex float *work, int lwork)
     * }
     */
    public static int LAPACKE_cunmhr_work(int matrix_layout, byte side, byte trans, int m, int n, int ilo, int ihi, MemorySegment a, int lda, MemorySegment tau, MemorySegment c, int ldc, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_cunmhr_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cunmhr_work", matrix_layout, side, trans, m, n, ilo, ihi, a, lda, tau, c, ldc, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, side, trans, m, n, ilo, ihi, a, lda, tau, c, ldc, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zunmhr_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zunmhr_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zunmhr_work(int matrix_layout, char side, char trans, int m, int n, int ilo, int ihi, const _Complex double *a, int lda, const _Complex double *tau, _Complex double *c, int ldc, _Complex double *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_zunmhr_work$descriptor() {
        return LAPACKE_zunmhr_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zunmhr_work(int matrix_layout, char side, char trans, int m, int n, int ilo, int ihi, const _Complex double *a, int lda, const _Complex double *tau, _Complex double *c, int ldc, _Complex double *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_zunmhr_work$handle() {
        return LAPACKE_zunmhr_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zunmhr_work(int matrix_layout, char side, char trans, int m, int n, int ilo, int ihi, const _Complex double *a, int lda, const _Complex double *tau, _Complex double *c, int ldc, _Complex double *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_zunmhr_work$address() {
        return LAPACKE_zunmhr_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zunmhr_work(int matrix_layout, char side, char trans, int m, int n, int ilo, int ihi, const _Complex double *a, int lda, const _Complex double *tau, _Complex double *c, int ldc, _Complex double *work, int lwork)
     * }
     */
    public static int LAPACKE_zunmhr_work(int matrix_layout, byte side, byte trans, int m, int n, int ilo, int ihi, MemorySegment a, int lda, MemorySegment tau, MemorySegment c, int ldc, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_zunmhr_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zunmhr_work", matrix_layout, side, trans, m, n, ilo, ihi, a, lda, tau, c, ldc, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, side, trans, m, n, ilo, ihi, a, lda, tau, c, ldc, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cunmlq_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_cunmlq_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cunmlq_work(int matrix_layout, char side, char trans, int m, int n, int k, const _Complex float *a, int lda, const _Complex float *tau, _Complex float *c, int ldc, _Complex float *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_cunmlq_work$descriptor() {
        return LAPACKE_cunmlq_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cunmlq_work(int matrix_layout, char side, char trans, int m, int n, int k, const _Complex float *a, int lda, const _Complex float *tau, _Complex float *c, int ldc, _Complex float *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_cunmlq_work$handle() {
        return LAPACKE_cunmlq_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cunmlq_work(int matrix_layout, char side, char trans, int m, int n, int k, const _Complex float *a, int lda, const _Complex float *tau, _Complex float *c, int ldc, _Complex float *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_cunmlq_work$address() {
        return LAPACKE_cunmlq_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cunmlq_work(int matrix_layout, char side, char trans, int m, int n, int k, const _Complex float *a, int lda, const _Complex float *tau, _Complex float *c, int ldc, _Complex float *work, int lwork)
     * }
     */
    public static int LAPACKE_cunmlq_work(int matrix_layout, byte side, byte trans, int m, int n, int k, MemorySegment a, int lda, MemorySegment tau, MemorySegment c, int ldc, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_cunmlq_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cunmlq_work", matrix_layout, side, trans, m, n, k, a, lda, tau, c, ldc, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, side, trans, m, n, k, a, lda, tau, c, ldc, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zunmlq_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zunmlq_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zunmlq_work(int matrix_layout, char side, char trans, int m, int n, int k, const _Complex double *a, int lda, const _Complex double *tau, _Complex double *c, int ldc, _Complex double *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_zunmlq_work$descriptor() {
        return LAPACKE_zunmlq_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zunmlq_work(int matrix_layout, char side, char trans, int m, int n, int k, const _Complex double *a, int lda, const _Complex double *tau, _Complex double *c, int ldc, _Complex double *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_zunmlq_work$handle() {
        return LAPACKE_zunmlq_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zunmlq_work(int matrix_layout, char side, char trans, int m, int n, int k, const _Complex double *a, int lda, const _Complex double *tau, _Complex double *c, int ldc, _Complex double *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_zunmlq_work$address() {
        return LAPACKE_zunmlq_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zunmlq_work(int matrix_layout, char side, char trans, int m, int n, int k, const _Complex double *a, int lda, const _Complex double *tau, _Complex double *c, int ldc, _Complex double *work, int lwork)
     * }
     */
    public static int LAPACKE_zunmlq_work(int matrix_layout, byte side, byte trans, int m, int n, int k, MemorySegment a, int lda, MemorySegment tau, MemorySegment c, int ldc, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_zunmlq_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zunmlq_work", matrix_layout, side, trans, m, n, k, a, lda, tau, c, ldc, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, side, trans, m, n, k, a, lda, tau, c, ldc, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cunmql_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_cunmql_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cunmql_work(int matrix_layout, char side, char trans, int m, int n, int k, const _Complex float *a, int lda, const _Complex float *tau, _Complex float *c, int ldc, _Complex float *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_cunmql_work$descriptor() {
        return LAPACKE_cunmql_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cunmql_work(int matrix_layout, char side, char trans, int m, int n, int k, const _Complex float *a, int lda, const _Complex float *tau, _Complex float *c, int ldc, _Complex float *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_cunmql_work$handle() {
        return LAPACKE_cunmql_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cunmql_work(int matrix_layout, char side, char trans, int m, int n, int k, const _Complex float *a, int lda, const _Complex float *tau, _Complex float *c, int ldc, _Complex float *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_cunmql_work$address() {
        return LAPACKE_cunmql_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cunmql_work(int matrix_layout, char side, char trans, int m, int n, int k, const _Complex float *a, int lda, const _Complex float *tau, _Complex float *c, int ldc, _Complex float *work, int lwork)
     * }
     */
    public static int LAPACKE_cunmql_work(int matrix_layout, byte side, byte trans, int m, int n, int k, MemorySegment a, int lda, MemorySegment tau, MemorySegment c, int ldc, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_cunmql_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cunmql_work", matrix_layout, side, trans, m, n, k, a, lda, tau, c, ldc, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, side, trans, m, n, k, a, lda, tau, c, ldc, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zunmql_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zunmql_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zunmql_work(int matrix_layout, char side, char trans, int m, int n, int k, const _Complex double *a, int lda, const _Complex double *tau, _Complex double *c, int ldc, _Complex double *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_zunmql_work$descriptor() {
        return LAPACKE_zunmql_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zunmql_work(int matrix_layout, char side, char trans, int m, int n, int k, const _Complex double *a, int lda, const _Complex double *tau, _Complex double *c, int ldc, _Complex double *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_zunmql_work$handle() {
        return LAPACKE_zunmql_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zunmql_work(int matrix_layout, char side, char trans, int m, int n, int k, const _Complex double *a, int lda, const _Complex double *tau, _Complex double *c, int ldc, _Complex double *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_zunmql_work$address() {
        return LAPACKE_zunmql_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zunmql_work(int matrix_layout, char side, char trans, int m, int n, int k, const _Complex double *a, int lda, const _Complex double *tau, _Complex double *c, int ldc, _Complex double *work, int lwork)
     * }
     */
    public static int LAPACKE_zunmql_work(int matrix_layout, byte side, byte trans, int m, int n, int k, MemorySegment a, int lda, MemorySegment tau, MemorySegment c, int ldc, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_zunmql_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zunmql_work", matrix_layout, side, trans, m, n, k, a, lda, tau, c, ldc, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, side, trans, m, n, k, a, lda, tau, c, ldc, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cunmqr_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_cunmqr_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cunmqr_work(int matrix_layout, char side, char trans, int m, int n, int k, const _Complex float *a, int lda, const _Complex float *tau, _Complex float *c, int ldc, _Complex float *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_cunmqr_work$descriptor() {
        return LAPACKE_cunmqr_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cunmqr_work(int matrix_layout, char side, char trans, int m, int n, int k, const _Complex float *a, int lda, const _Complex float *tau, _Complex float *c, int ldc, _Complex float *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_cunmqr_work$handle() {
        return LAPACKE_cunmqr_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cunmqr_work(int matrix_layout, char side, char trans, int m, int n, int k, const _Complex float *a, int lda, const _Complex float *tau, _Complex float *c, int ldc, _Complex float *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_cunmqr_work$address() {
        return LAPACKE_cunmqr_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cunmqr_work(int matrix_layout, char side, char trans, int m, int n, int k, const _Complex float *a, int lda, const _Complex float *tau, _Complex float *c, int ldc, _Complex float *work, int lwork)
     * }
     */
    public static int LAPACKE_cunmqr_work(int matrix_layout, byte side, byte trans, int m, int n, int k, MemorySegment a, int lda, MemorySegment tau, MemorySegment c, int ldc, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_cunmqr_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cunmqr_work", matrix_layout, side, trans, m, n, k, a, lda, tau, c, ldc, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, side, trans, m, n, k, a, lda, tau, c, ldc, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zunmqr_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zunmqr_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zunmqr_work(int matrix_layout, char side, char trans, int m, int n, int k, const _Complex double *a, int lda, const _Complex double *tau, _Complex double *c, int ldc, _Complex double *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_zunmqr_work$descriptor() {
        return LAPACKE_zunmqr_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zunmqr_work(int matrix_layout, char side, char trans, int m, int n, int k, const _Complex double *a, int lda, const _Complex double *tau, _Complex double *c, int ldc, _Complex double *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_zunmqr_work$handle() {
        return LAPACKE_zunmqr_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zunmqr_work(int matrix_layout, char side, char trans, int m, int n, int k, const _Complex double *a, int lda, const _Complex double *tau, _Complex double *c, int ldc, _Complex double *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_zunmqr_work$address() {
        return LAPACKE_zunmqr_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zunmqr_work(int matrix_layout, char side, char trans, int m, int n, int k, const _Complex double *a, int lda, const _Complex double *tau, _Complex double *c, int ldc, _Complex double *work, int lwork)
     * }
     */
    public static int LAPACKE_zunmqr_work(int matrix_layout, byte side, byte trans, int m, int n, int k, MemorySegment a, int lda, MemorySegment tau, MemorySegment c, int ldc, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_zunmqr_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zunmqr_work", matrix_layout, side, trans, m, n, k, a, lda, tau, c, ldc, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, side, trans, m, n, k, a, lda, tau, c, ldc, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cunmrq_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_cunmrq_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cunmrq_work(int matrix_layout, char side, char trans, int m, int n, int k, const _Complex float *a, int lda, const _Complex float *tau, _Complex float *c, int ldc, _Complex float *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_cunmrq_work$descriptor() {
        return LAPACKE_cunmrq_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cunmrq_work(int matrix_layout, char side, char trans, int m, int n, int k, const _Complex float *a, int lda, const _Complex float *tau, _Complex float *c, int ldc, _Complex float *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_cunmrq_work$handle() {
        return LAPACKE_cunmrq_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cunmrq_work(int matrix_layout, char side, char trans, int m, int n, int k, const _Complex float *a, int lda, const _Complex float *tau, _Complex float *c, int ldc, _Complex float *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_cunmrq_work$address() {
        return LAPACKE_cunmrq_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cunmrq_work(int matrix_layout, char side, char trans, int m, int n, int k, const _Complex float *a, int lda, const _Complex float *tau, _Complex float *c, int ldc, _Complex float *work, int lwork)
     * }
     */
    public static int LAPACKE_cunmrq_work(int matrix_layout, byte side, byte trans, int m, int n, int k, MemorySegment a, int lda, MemorySegment tau, MemorySegment c, int ldc, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_cunmrq_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cunmrq_work", matrix_layout, side, trans, m, n, k, a, lda, tau, c, ldc, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, side, trans, m, n, k, a, lda, tau, c, ldc, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zunmrq_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zunmrq_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zunmrq_work(int matrix_layout, char side, char trans, int m, int n, int k, const _Complex double *a, int lda, const _Complex double *tau, _Complex double *c, int ldc, _Complex double *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_zunmrq_work$descriptor() {
        return LAPACKE_zunmrq_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zunmrq_work(int matrix_layout, char side, char trans, int m, int n, int k, const _Complex double *a, int lda, const _Complex double *tau, _Complex double *c, int ldc, _Complex double *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_zunmrq_work$handle() {
        return LAPACKE_zunmrq_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zunmrq_work(int matrix_layout, char side, char trans, int m, int n, int k, const _Complex double *a, int lda, const _Complex double *tau, _Complex double *c, int ldc, _Complex double *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_zunmrq_work$address() {
        return LAPACKE_zunmrq_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zunmrq_work(int matrix_layout, char side, char trans, int m, int n, int k, const _Complex double *a, int lda, const _Complex double *tau, _Complex double *c, int ldc, _Complex double *work, int lwork)
     * }
     */
    public static int LAPACKE_zunmrq_work(int matrix_layout, byte side, byte trans, int m, int n, int k, MemorySegment a, int lda, MemorySegment tau, MemorySegment c, int ldc, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_zunmrq_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zunmrq_work", matrix_layout, side, trans, m, n, k, a, lda, tau, c, ldc, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, side, trans, m, n, k, a, lda, tau, c, ldc, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cunmrz_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_cunmrz_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cunmrz_work(int matrix_layout, char side, char trans, int m, int n, int k, int l, const _Complex float *a, int lda, const _Complex float *tau, _Complex float *c, int ldc, _Complex float *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_cunmrz_work$descriptor() {
        return LAPACKE_cunmrz_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cunmrz_work(int matrix_layout, char side, char trans, int m, int n, int k, int l, const _Complex float *a, int lda, const _Complex float *tau, _Complex float *c, int ldc, _Complex float *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_cunmrz_work$handle() {
        return LAPACKE_cunmrz_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cunmrz_work(int matrix_layout, char side, char trans, int m, int n, int k, int l, const _Complex float *a, int lda, const _Complex float *tau, _Complex float *c, int ldc, _Complex float *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_cunmrz_work$address() {
        return LAPACKE_cunmrz_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cunmrz_work(int matrix_layout, char side, char trans, int m, int n, int k, int l, const _Complex float *a, int lda, const _Complex float *tau, _Complex float *c, int ldc, _Complex float *work, int lwork)
     * }
     */
    public static int LAPACKE_cunmrz_work(int matrix_layout, byte side, byte trans, int m, int n, int k, int l, MemorySegment a, int lda, MemorySegment tau, MemorySegment c, int ldc, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_cunmrz_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cunmrz_work", matrix_layout, side, trans, m, n, k, l, a, lda, tau, c, ldc, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, side, trans, m, n, k, l, a, lda, tau, c, ldc, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zunmrz_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zunmrz_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zunmrz_work(int matrix_layout, char side, char trans, int m, int n, int k, int l, const _Complex double *a, int lda, const _Complex double *tau, _Complex double *c, int ldc, _Complex double *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_zunmrz_work$descriptor() {
        return LAPACKE_zunmrz_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zunmrz_work(int matrix_layout, char side, char trans, int m, int n, int k, int l, const _Complex double *a, int lda, const _Complex double *tau, _Complex double *c, int ldc, _Complex double *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_zunmrz_work$handle() {
        return LAPACKE_zunmrz_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zunmrz_work(int matrix_layout, char side, char trans, int m, int n, int k, int l, const _Complex double *a, int lda, const _Complex double *tau, _Complex double *c, int ldc, _Complex double *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_zunmrz_work$address() {
        return LAPACKE_zunmrz_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zunmrz_work(int matrix_layout, char side, char trans, int m, int n, int k, int l, const _Complex double *a, int lda, const _Complex double *tau, _Complex double *c, int ldc, _Complex double *work, int lwork)
     * }
     */
    public static int LAPACKE_zunmrz_work(int matrix_layout, byte side, byte trans, int m, int n, int k, int l, MemorySegment a, int lda, MemorySegment tau, MemorySegment c, int ldc, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_zunmrz_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zunmrz_work", matrix_layout, side, trans, m, n, k, l, a, lda, tau, c, ldc, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, side, trans, m, n, k, l, a, lda, tau, c, ldc, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cunmtr_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_cunmtr_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cunmtr_work(int matrix_layout, char side, char uplo, char trans, int m, int n, const _Complex float *a, int lda, const _Complex float *tau, _Complex float *c, int ldc, _Complex float *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_cunmtr_work$descriptor() {
        return LAPACKE_cunmtr_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cunmtr_work(int matrix_layout, char side, char uplo, char trans, int m, int n, const _Complex float *a, int lda, const _Complex float *tau, _Complex float *c, int ldc, _Complex float *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_cunmtr_work$handle() {
        return LAPACKE_cunmtr_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cunmtr_work(int matrix_layout, char side, char uplo, char trans, int m, int n, const _Complex float *a, int lda, const _Complex float *tau, _Complex float *c, int ldc, _Complex float *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_cunmtr_work$address() {
        return LAPACKE_cunmtr_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cunmtr_work(int matrix_layout, char side, char uplo, char trans, int m, int n, const _Complex float *a, int lda, const _Complex float *tau, _Complex float *c, int ldc, _Complex float *work, int lwork)
     * }
     */
    public static int LAPACKE_cunmtr_work(int matrix_layout, byte side, byte uplo, byte trans, int m, int n, MemorySegment a, int lda, MemorySegment tau, MemorySegment c, int ldc, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_cunmtr_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cunmtr_work", matrix_layout, side, uplo, trans, m, n, a, lda, tau, c, ldc, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, side, uplo, trans, m, n, a, lda, tau, c, ldc, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zunmtr_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zunmtr_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zunmtr_work(int matrix_layout, char side, char uplo, char trans, int m, int n, const _Complex double *a, int lda, const _Complex double *tau, _Complex double *c, int ldc, _Complex double *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_zunmtr_work$descriptor() {
        return LAPACKE_zunmtr_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zunmtr_work(int matrix_layout, char side, char uplo, char trans, int m, int n, const _Complex double *a, int lda, const _Complex double *tau, _Complex double *c, int ldc, _Complex double *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_zunmtr_work$handle() {
        return LAPACKE_zunmtr_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zunmtr_work(int matrix_layout, char side, char uplo, char trans, int m, int n, const _Complex double *a, int lda, const _Complex double *tau, _Complex double *c, int ldc, _Complex double *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_zunmtr_work$address() {
        return LAPACKE_zunmtr_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zunmtr_work(int matrix_layout, char side, char uplo, char trans, int m, int n, const _Complex double *a, int lda, const _Complex double *tau, _Complex double *c, int ldc, _Complex double *work, int lwork)
     * }
     */
    public static int LAPACKE_zunmtr_work(int matrix_layout, byte side, byte uplo, byte trans, int m, int n, MemorySegment a, int lda, MemorySegment tau, MemorySegment c, int ldc, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_zunmtr_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zunmtr_work", matrix_layout, side, uplo, trans, m, n, a, lda, tau, c, ldc, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, side, uplo, trans, m, n, a, lda, tau, c, ldc, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cupgtr_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_cupgtr_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cupgtr_work(int matrix_layout, char uplo, int n, const _Complex float *ap, const _Complex float *tau, _Complex float *q, int ldq, _Complex float *work)
     * }
     */
    public static FunctionDescriptor LAPACKE_cupgtr_work$descriptor() {
        return LAPACKE_cupgtr_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cupgtr_work(int matrix_layout, char uplo, int n, const _Complex float *ap, const _Complex float *tau, _Complex float *q, int ldq, _Complex float *work)
     * }
     */
    public static MethodHandle LAPACKE_cupgtr_work$handle() {
        return LAPACKE_cupgtr_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cupgtr_work(int matrix_layout, char uplo, int n, const _Complex float *ap, const _Complex float *tau, _Complex float *q, int ldq, _Complex float *work)
     * }
     */
    public static MemorySegment LAPACKE_cupgtr_work$address() {
        return LAPACKE_cupgtr_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cupgtr_work(int matrix_layout, char uplo, int n, const _Complex float *ap, const _Complex float *tau, _Complex float *q, int ldq, _Complex float *work)
     * }
     */
    public static int LAPACKE_cupgtr_work(int matrix_layout, byte uplo, int n, MemorySegment ap, MemorySegment tau, MemorySegment q, int ldq, MemorySegment work) {
        var mh$ = LAPACKE_cupgtr_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cupgtr_work", matrix_layout, uplo, n, ap, tau, q, ldq, work);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, ap, tau, q, ldq, work);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zupgtr_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zupgtr_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zupgtr_work(int matrix_layout, char uplo, int n, const _Complex double *ap, const _Complex double *tau, _Complex double *q, int ldq, _Complex double *work)
     * }
     */
    public static FunctionDescriptor LAPACKE_zupgtr_work$descriptor() {
        return LAPACKE_zupgtr_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zupgtr_work(int matrix_layout, char uplo, int n, const _Complex double *ap, const _Complex double *tau, _Complex double *q, int ldq, _Complex double *work)
     * }
     */
    public static MethodHandle LAPACKE_zupgtr_work$handle() {
        return LAPACKE_zupgtr_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zupgtr_work(int matrix_layout, char uplo, int n, const _Complex double *ap, const _Complex double *tau, _Complex double *q, int ldq, _Complex double *work)
     * }
     */
    public static MemorySegment LAPACKE_zupgtr_work$address() {
        return LAPACKE_zupgtr_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zupgtr_work(int matrix_layout, char uplo, int n, const _Complex double *ap, const _Complex double *tau, _Complex double *q, int ldq, _Complex double *work)
     * }
     */
    public static int LAPACKE_zupgtr_work(int matrix_layout, byte uplo, int n, MemorySegment ap, MemorySegment tau, MemorySegment q, int ldq, MemorySegment work) {
        var mh$ = LAPACKE_zupgtr_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zupgtr_work", matrix_layout, uplo, n, ap, tau, q, ldq, work);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, ap, tau, q, ldq, work);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cupmtr_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_cupmtr_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cupmtr_work(int matrix_layout, char side, char uplo, char trans, int m, int n, const _Complex float *ap, const _Complex float *tau, _Complex float *c, int ldc, _Complex float *work)
     * }
     */
    public static FunctionDescriptor LAPACKE_cupmtr_work$descriptor() {
        return LAPACKE_cupmtr_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cupmtr_work(int matrix_layout, char side, char uplo, char trans, int m, int n, const _Complex float *ap, const _Complex float *tau, _Complex float *c, int ldc, _Complex float *work)
     * }
     */
    public static MethodHandle LAPACKE_cupmtr_work$handle() {
        return LAPACKE_cupmtr_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cupmtr_work(int matrix_layout, char side, char uplo, char trans, int m, int n, const _Complex float *ap, const _Complex float *tau, _Complex float *c, int ldc, _Complex float *work)
     * }
     */
    public static MemorySegment LAPACKE_cupmtr_work$address() {
        return LAPACKE_cupmtr_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cupmtr_work(int matrix_layout, char side, char uplo, char trans, int m, int n, const _Complex float *ap, const _Complex float *tau, _Complex float *c, int ldc, _Complex float *work)
     * }
     */
    public static int LAPACKE_cupmtr_work(int matrix_layout, byte side, byte uplo, byte trans, int m, int n, MemorySegment ap, MemorySegment tau, MemorySegment c, int ldc, MemorySegment work) {
        var mh$ = LAPACKE_cupmtr_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cupmtr_work", matrix_layout, side, uplo, trans, m, n, ap, tau, c, ldc, work);
            }
            return (int)mh$.invokeExact(matrix_layout, side, uplo, trans, m, n, ap, tau, c, ldc, work);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zupmtr_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zupmtr_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zupmtr_work(int matrix_layout, char side, char uplo, char trans, int m, int n, const _Complex double *ap, const _Complex double *tau, _Complex double *c, int ldc, _Complex double *work)
     * }
     */
    public static FunctionDescriptor LAPACKE_zupmtr_work$descriptor() {
        return LAPACKE_zupmtr_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zupmtr_work(int matrix_layout, char side, char uplo, char trans, int m, int n, const _Complex double *ap, const _Complex double *tau, _Complex double *c, int ldc, _Complex double *work)
     * }
     */
    public static MethodHandle LAPACKE_zupmtr_work$handle() {
        return LAPACKE_zupmtr_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zupmtr_work(int matrix_layout, char side, char uplo, char trans, int m, int n, const _Complex double *ap, const _Complex double *tau, _Complex double *c, int ldc, _Complex double *work)
     * }
     */
    public static MemorySegment LAPACKE_zupmtr_work$address() {
        return LAPACKE_zupmtr_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zupmtr_work(int matrix_layout, char side, char uplo, char trans, int m, int n, const _Complex double *ap, const _Complex double *tau, _Complex double *c, int ldc, _Complex double *work)
     * }
     */
    public static int LAPACKE_zupmtr_work(int matrix_layout, byte side, byte uplo, byte trans, int m, int n, MemorySegment ap, MemorySegment tau, MemorySegment c, int ldc, MemorySegment work) {
        var mh$ = LAPACKE_zupmtr_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zupmtr_work", matrix_layout, side, uplo, trans, m, n, ap, tau, c, ldc, work);
            }
            return (int)mh$.invokeExact(matrix_layout, side, uplo, trans, m, n, ap, tau, c, ldc, work);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_claghe {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_claghe");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_claghe(int matrix_layout, int n, int k, const float *d, _Complex float *a, int lda, int *iseed)
     * }
     */
    public static FunctionDescriptor LAPACKE_claghe$descriptor() {
        return LAPACKE_claghe.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_claghe(int matrix_layout, int n, int k, const float *d, _Complex float *a, int lda, int *iseed)
     * }
     */
    public static MethodHandle LAPACKE_claghe$handle() {
        return LAPACKE_claghe.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_claghe(int matrix_layout, int n, int k, const float *d, _Complex float *a, int lda, int *iseed)
     * }
     */
    public static MemorySegment LAPACKE_claghe$address() {
        return LAPACKE_claghe.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_claghe(int matrix_layout, int n, int k, const float *d, _Complex float *a, int lda, int *iseed)
     * }
     */
    public static int LAPACKE_claghe(int matrix_layout, int n, int k, MemorySegment d, MemorySegment a, int lda, MemorySegment iseed) {
        var mh$ = LAPACKE_claghe.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_claghe", matrix_layout, n, k, d, a, lda, iseed);
            }
            return (int)mh$.invokeExact(matrix_layout, n, k, d, a, lda, iseed);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zlaghe {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zlaghe");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zlaghe(int matrix_layout, int n, int k, const double *d, _Complex double *a, int lda, int *iseed)
     * }
     */
    public static FunctionDescriptor LAPACKE_zlaghe$descriptor() {
        return LAPACKE_zlaghe.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zlaghe(int matrix_layout, int n, int k, const double *d, _Complex double *a, int lda, int *iseed)
     * }
     */
    public static MethodHandle LAPACKE_zlaghe$handle() {
        return LAPACKE_zlaghe.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zlaghe(int matrix_layout, int n, int k, const double *d, _Complex double *a, int lda, int *iseed)
     * }
     */
    public static MemorySegment LAPACKE_zlaghe$address() {
        return LAPACKE_zlaghe.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zlaghe(int matrix_layout, int n, int k, const double *d, _Complex double *a, int lda, int *iseed)
     * }
     */
    public static int LAPACKE_zlaghe(int matrix_layout, int n, int k, MemorySegment d, MemorySegment a, int lda, MemorySegment iseed) {
        var mh$ = LAPACKE_zlaghe.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zlaghe", matrix_layout, n, k, d, a, lda, iseed);
            }
            return (int)mh$.invokeExact(matrix_layout, n, k, d, a, lda, iseed);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_slagsy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_slagsy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_slagsy(int matrix_layout, int n, int k, const float *d, float *a, int lda, int *iseed)
     * }
     */
    public static FunctionDescriptor LAPACKE_slagsy$descriptor() {
        return LAPACKE_slagsy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_slagsy(int matrix_layout, int n, int k, const float *d, float *a, int lda, int *iseed)
     * }
     */
    public static MethodHandle LAPACKE_slagsy$handle() {
        return LAPACKE_slagsy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_slagsy(int matrix_layout, int n, int k, const float *d, float *a, int lda, int *iseed)
     * }
     */
    public static MemorySegment LAPACKE_slagsy$address() {
        return LAPACKE_slagsy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_slagsy(int matrix_layout, int n, int k, const float *d, float *a, int lda, int *iseed)
     * }
     */
    public static int LAPACKE_slagsy(int matrix_layout, int n, int k, MemorySegment d, MemorySegment a, int lda, MemorySegment iseed) {
        var mh$ = LAPACKE_slagsy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_slagsy", matrix_layout, n, k, d, a, lda, iseed);
            }
            return (int)mh$.invokeExact(matrix_layout, n, k, d, a, lda, iseed);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dlagsy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dlagsy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dlagsy(int matrix_layout, int n, int k, const double *d, double *a, int lda, int *iseed)
     * }
     */
    public static FunctionDescriptor LAPACKE_dlagsy$descriptor() {
        return LAPACKE_dlagsy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dlagsy(int matrix_layout, int n, int k, const double *d, double *a, int lda, int *iseed)
     * }
     */
    public static MethodHandle LAPACKE_dlagsy$handle() {
        return LAPACKE_dlagsy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dlagsy(int matrix_layout, int n, int k, const double *d, double *a, int lda, int *iseed)
     * }
     */
    public static MemorySegment LAPACKE_dlagsy$address() {
        return LAPACKE_dlagsy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dlagsy(int matrix_layout, int n, int k, const double *d, double *a, int lda, int *iseed)
     * }
     */
    public static int LAPACKE_dlagsy(int matrix_layout, int n, int k, MemorySegment d, MemorySegment a, int lda, MemorySegment iseed) {
        var mh$ = LAPACKE_dlagsy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dlagsy", matrix_layout, n, k, d, a, lda, iseed);
            }
            return (int)mh$.invokeExact(matrix_layout, n, k, d, a, lda, iseed);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_clagsy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_clagsy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_clagsy(int matrix_layout, int n, int k, const float *d, _Complex float *a, int lda, int *iseed)
     * }
     */
    public static FunctionDescriptor LAPACKE_clagsy$descriptor() {
        return LAPACKE_clagsy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_clagsy(int matrix_layout, int n, int k, const float *d, _Complex float *a, int lda, int *iseed)
     * }
     */
    public static MethodHandle LAPACKE_clagsy$handle() {
        return LAPACKE_clagsy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_clagsy(int matrix_layout, int n, int k, const float *d, _Complex float *a, int lda, int *iseed)
     * }
     */
    public static MemorySegment LAPACKE_clagsy$address() {
        return LAPACKE_clagsy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_clagsy(int matrix_layout, int n, int k, const float *d, _Complex float *a, int lda, int *iseed)
     * }
     */
    public static int LAPACKE_clagsy(int matrix_layout, int n, int k, MemorySegment d, MemorySegment a, int lda, MemorySegment iseed) {
        var mh$ = LAPACKE_clagsy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_clagsy", matrix_layout, n, k, d, a, lda, iseed);
            }
            return (int)mh$.invokeExact(matrix_layout, n, k, d, a, lda, iseed);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zlagsy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zlagsy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zlagsy(int matrix_layout, int n, int k, const double *d, _Complex double *a, int lda, int *iseed)
     * }
     */
    public static FunctionDescriptor LAPACKE_zlagsy$descriptor() {
        return LAPACKE_zlagsy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zlagsy(int matrix_layout, int n, int k, const double *d, _Complex double *a, int lda, int *iseed)
     * }
     */
    public static MethodHandle LAPACKE_zlagsy$handle() {
        return LAPACKE_zlagsy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zlagsy(int matrix_layout, int n, int k, const double *d, _Complex double *a, int lda, int *iseed)
     * }
     */
    public static MemorySegment LAPACKE_zlagsy$address() {
        return LAPACKE_zlagsy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zlagsy(int matrix_layout, int n, int k, const double *d, _Complex double *a, int lda, int *iseed)
     * }
     */
    public static int LAPACKE_zlagsy(int matrix_layout, int n, int k, MemorySegment d, MemorySegment a, int lda, MemorySegment iseed) {
        var mh$ = LAPACKE_zlagsy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zlagsy", matrix_layout, n, k, d, a, lda, iseed);
            }
            return (int)mh$.invokeExact(matrix_layout, n, k, d, a, lda, iseed);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_slapmr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_slapmr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_slapmr(int matrix_layout, int forwrd, int m, int n, float *x, int ldx, int *k)
     * }
     */
    public static FunctionDescriptor LAPACKE_slapmr$descriptor() {
        return LAPACKE_slapmr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_slapmr(int matrix_layout, int forwrd, int m, int n, float *x, int ldx, int *k)
     * }
     */
    public static MethodHandle LAPACKE_slapmr$handle() {
        return LAPACKE_slapmr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_slapmr(int matrix_layout, int forwrd, int m, int n, float *x, int ldx, int *k)
     * }
     */
    public static MemorySegment LAPACKE_slapmr$address() {
        return LAPACKE_slapmr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_slapmr(int matrix_layout, int forwrd, int m, int n, float *x, int ldx, int *k)
     * }
     */
    public static int LAPACKE_slapmr(int matrix_layout, int forwrd, int m, int n, MemorySegment x, int ldx, MemorySegment k) {
        var mh$ = LAPACKE_slapmr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_slapmr", matrix_layout, forwrd, m, n, x, ldx, k);
            }
            return (int)mh$.invokeExact(matrix_layout, forwrd, m, n, x, ldx, k);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dlapmr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dlapmr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dlapmr(int matrix_layout, int forwrd, int m, int n, double *x, int ldx, int *k)
     * }
     */
    public static FunctionDescriptor LAPACKE_dlapmr$descriptor() {
        return LAPACKE_dlapmr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dlapmr(int matrix_layout, int forwrd, int m, int n, double *x, int ldx, int *k)
     * }
     */
    public static MethodHandle LAPACKE_dlapmr$handle() {
        return LAPACKE_dlapmr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dlapmr(int matrix_layout, int forwrd, int m, int n, double *x, int ldx, int *k)
     * }
     */
    public static MemorySegment LAPACKE_dlapmr$address() {
        return LAPACKE_dlapmr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dlapmr(int matrix_layout, int forwrd, int m, int n, double *x, int ldx, int *k)
     * }
     */
    public static int LAPACKE_dlapmr(int matrix_layout, int forwrd, int m, int n, MemorySegment x, int ldx, MemorySegment k) {
        var mh$ = LAPACKE_dlapmr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dlapmr", matrix_layout, forwrd, m, n, x, ldx, k);
            }
            return (int)mh$.invokeExact(matrix_layout, forwrd, m, n, x, ldx, k);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_clapmr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_clapmr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_clapmr(int matrix_layout, int forwrd, int m, int n, _Complex float *x, int ldx, int *k)
     * }
     */
    public static FunctionDescriptor LAPACKE_clapmr$descriptor() {
        return LAPACKE_clapmr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_clapmr(int matrix_layout, int forwrd, int m, int n, _Complex float *x, int ldx, int *k)
     * }
     */
    public static MethodHandle LAPACKE_clapmr$handle() {
        return LAPACKE_clapmr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_clapmr(int matrix_layout, int forwrd, int m, int n, _Complex float *x, int ldx, int *k)
     * }
     */
    public static MemorySegment LAPACKE_clapmr$address() {
        return LAPACKE_clapmr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_clapmr(int matrix_layout, int forwrd, int m, int n, _Complex float *x, int ldx, int *k)
     * }
     */
    public static int LAPACKE_clapmr(int matrix_layout, int forwrd, int m, int n, MemorySegment x, int ldx, MemorySegment k) {
        var mh$ = LAPACKE_clapmr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_clapmr", matrix_layout, forwrd, m, n, x, ldx, k);
            }
            return (int)mh$.invokeExact(matrix_layout, forwrd, m, n, x, ldx, k);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zlapmr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zlapmr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zlapmr(int matrix_layout, int forwrd, int m, int n, _Complex double *x, int ldx, int *k)
     * }
     */
    public static FunctionDescriptor LAPACKE_zlapmr$descriptor() {
        return LAPACKE_zlapmr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zlapmr(int matrix_layout, int forwrd, int m, int n, _Complex double *x, int ldx, int *k)
     * }
     */
    public static MethodHandle LAPACKE_zlapmr$handle() {
        return LAPACKE_zlapmr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zlapmr(int matrix_layout, int forwrd, int m, int n, _Complex double *x, int ldx, int *k)
     * }
     */
    public static MemorySegment LAPACKE_zlapmr$address() {
        return LAPACKE_zlapmr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zlapmr(int matrix_layout, int forwrd, int m, int n, _Complex double *x, int ldx, int *k)
     * }
     */
    public static int LAPACKE_zlapmr(int matrix_layout, int forwrd, int m, int n, MemorySegment x, int ldx, MemorySegment k) {
        var mh$ = LAPACKE_zlapmr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zlapmr", matrix_layout, forwrd, m, n, x, ldx, k);
            }
            return (int)mh$.invokeExact(matrix_layout, forwrd, m, n, x, ldx, k);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_slapmt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_slapmt");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_slapmt(int matrix_layout, int forwrd, int m, int n, float *x, int ldx, int *k)
     * }
     */
    public static FunctionDescriptor LAPACKE_slapmt$descriptor() {
        return LAPACKE_slapmt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_slapmt(int matrix_layout, int forwrd, int m, int n, float *x, int ldx, int *k)
     * }
     */
    public static MethodHandle LAPACKE_slapmt$handle() {
        return LAPACKE_slapmt.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_slapmt(int matrix_layout, int forwrd, int m, int n, float *x, int ldx, int *k)
     * }
     */
    public static MemorySegment LAPACKE_slapmt$address() {
        return LAPACKE_slapmt.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_slapmt(int matrix_layout, int forwrd, int m, int n, float *x, int ldx, int *k)
     * }
     */
    public static int LAPACKE_slapmt(int matrix_layout, int forwrd, int m, int n, MemorySegment x, int ldx, MemorySegment k) {
        var mh$ = LAPACKE_slapmt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_slapmt", matrix_layout, forwrd, m, n, x, ldx, k);
            }
            return (int)mh$.invokeExact(matrix_layout, forwrd, m, n, x, ldx, k);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dlapmt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dlapmt");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dlapmt(int matrix_layout, int forwrd, int m, int n, double *x, int ldx, int *k)
     * }
     */
    public static FunctionDescriptor LAPACKE_dlapmt$descriptor() {
        return LAPACKE_dlapmt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dlapmt(int matrix_layout, int forwrd, int m, int n, double *x, int ldx, int *k)
     * }
     */
    public static MethodHandle LAPACKE_dlapmt$handle() {
        return LAPACKE_dlapmt.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dlapmt(int matrix_layout, int forwrd, int m, int n, double *x, int ldx, int *k)
     * }
     */
    public static MemorySegment LAPACKE_dlapmt$address() {
        return LAPACKE_dlapmt.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dlapmt(int matrix_layout, int forwrd, int m, int n, double *x, int ldx, int *k)
     * }
     */
    public static int LAPACKE_dlapmt(int matrix_layout, int forwrd, int m, int n, MemorySegment x, int ldx, MemorySegment k) {
        var mh$ = LAPACKE_dlapmt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dlapmt", matrix_layout, forwrd, m, n, x, ldx, k);
            }
            return (int)mh$.invokeExact(matrix_layout, forwrd, m, n, x, ldx, k);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_clapmt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_clapmt");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_clapmt(int matrix_layout, int forwrd, int m, int n, _Complex float *x, int ldx, int *k)
     * }
     */
    public static FunctionDescriptor LAPACKE_clapmt$descriptor() {
        return LAPACKE_clapmt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_clapmt(int matrix_layout, int forwrd, int m, int n, _Complex float *x, int ldx, int *k)
     * }
     */
    public static MethodHandle LAPACKE_clapmt$handle() {
        return LAPACKE_clapmt.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_clapmt(int matrix_layout, int forwrd, int m, int n, _Complex float *x, int ldx, int *k)
     * }
     */
    public static MemorySegment LAPACKE_clapmt$address() {
        return LAPACKE_clapmt.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_clapmt(int matrix_layout, int forwrd, int m, int n, _Complex float *x, int ldx, int *k)
     * }
     */
    public static int LAPACKE_clapmt(int matrix_layout, int forwrd, int m, int n, MemorySegment x, int ldx, MemorySegment k) {
        var mh$ = LAPACKE_clapmt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_clapmt", matrix_layout, forwrd, m, n, x, ldx, k);
            }
            return (int)mh$.invokeExact(matrix_layout, forwrd, m, n, x, ldx, k);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zlapmt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zlapmt");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zlapmt(int matrix_layout, int forwrd, int m, int n, _Complex double *x, int ldx, int *k)
     * }
     */
    public static FunctionDescriptor LAPACKE_zlapmt$descriptor() {
        return LAPACKE_zlapmt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zlapmt(int matrix_layout, int forwrd, int m, int n, _Complex double *x, int ldx, int *k)
     * }
     */
    public static MethodHandle LAPACKE_zlapmt$handle() {
        return LAPACKE_zlapmt.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zlapmt(int matrix_layout, int forwrd, int m, int n, _Complex double *x, int ldx, int *k)
     * }
     */
    public static MemorySegment LAPACKE_zlapmt$address() {
        return LAPACKE_zlapmt.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zlapmt(int matrix_layout, int forwrd, int m, int n, _Complex double *x, int ldx, int *k)
     * }
     */
    public static int LAPACKE_zlapmt(int matrix_layout, int forwrd, int m, int n, MemorySegment x, int ldx, MemorySegment k) {
        var mh$ = LAPACKE_zlapmt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zlapmt", matrix_layout, forwrd, m, n, x, ldx, k);
            }
            return (int)mh$.invokeExact(matrix_layout, forwrd, m, n, x, ldx, k);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_slapy2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_FLOAT,
            lapacke_h.C_FLOAT,
            lapacke_h.C_FLOAT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_slapy2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float LAPACKE_slapy2(float x, float y)
     * }
     */
    public static FunctionDescriptor LAPACKE_slapy2$descriptor() {
        return LAPACKE_slapy2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float LAPACKE_slapy2(float x, float y)
     * }
     */
    public static MethodHandle LAPACKE_slapy2$handle() {
        return LAPACKE_slapy2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float LAPACKE_slapy2(float x, float y)
     * }
     */
    public static MemorySegment LAPACKE_slapy2$address() {
        return LAPACKE_slapy2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float LAPACKE_slapy2(float x, float y)
     * }
     */
    public static float LAPACKE_slapy2(float x, float y) {
        var mh$ = LAPACKE_slapy2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_slapy2", x, y);
            }
            return (float)mh$.invokeExact(x, y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dlapy2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_DOUBLE,
            lapacke_h.C_DOUBLE,
            lapacke_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dlapy2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double LAPACKE_dlapy2(double x, double y)
     * }
     */
    public static FunctionDescriptor LAPACKE_dlapy2$descriptor() {
        return LAPACKE_dlapy2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double LAPACKE_dlapy2(double x, double y)
     * }
     */
    public static MethodHandle LAPACKE_dlapy2$handle() {
        return LAPACKE_dlapy2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double LAPACKE_dlapy2(double x, double y)
     * }
     */
    public static MemorySegment LAPACKE_dlapy2$address() {
        return LAPACKE_dlapy2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double LAPACKE_dlapy2(double x, double y)
     * }
     */
    public static double LAPACKE_dlapy2(double x, double y) {
        var mh$ = LAPACKE_dlapy2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dlapy2", x, y);
            }
            return (double)mh$.invokeExact(x, y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_slapy3 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_FLOAT,
            lapacke_h.C_FLOAT,
            lapacke_h.C_FLOAT,
            lapacke_h.C_FLOAT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_slapy3");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float LAPACKE_slapy3(float x, float y, float z)
     * }
     */
    public static FunctionDescriptor LAPACKE_slapy3$descriptor() {
        return LAPACKE_slapy3.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float LAPACKE_slapy3(float x, float y, float z)
     * }
     */
    public static MethodHandle LAPACKE_slapy3$handle() {
        return LAPACKE_slapy3.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float LAPACKE_slapy3(float x, float y, float z)
     * }
     */
    public static MemorySegment LAPACKE_slapy3$address() {
        return LAPACKE_slapy3.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float LAPACKE_slapy3(float x, float y, float z)
     * }
     */
    public static float LAPACKE_slapy3(float x, float y, float z) {
        var mh$ = LAPACKE_slapy3.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_slapy3", x, y, z);
            }
            return (float)mh$.invokeExact(x, y, z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dlapy3 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_DOUBLE,
            lapacke_h.C_DOUBLE,
            lapacke_h.C_DOUBLE,
            lapacke_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dlapy3");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double LAPACKE_dlapy3(double x, double y, double z)
     * }
     */
    public static FunctionDescriptor LAPACKE_dlapy3$descriptor() {
        return LAPACKE_dlapy3.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double LAPACKE_dlapy3(double x, double y, double z)
     * }
     */
    public static MethodHandle LAPACKE_dlapy3$handle() {
        return LAPACKE_dlapy3.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double LAPACKE_dlapy3(double x, double y, double z)
     * }
     */
    public static MemorySegment LAPACKE_dlapy3$address() {
        return LAPACKE_dlapy3.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double LAPACKE_dlapy3(double x, double y, double z)
     * }
     */
    public static double LAPACKE_dlapy3(double x, double y, double z) {
        var mh$ = LAPACKE_dlapy3.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dlapy3", x, y, z);
            }
            return (double)mh$.invokeExact(x, y, z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_slartgp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_FLOAT,
            lapacke_h.C_FLOAT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_slartgp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_slartgp(float f, float g, float *cs, float *sn, float *r)
     * }
     */
    public static FunctionDescriptor LAPACKE_slartgp$descriptor() {
        return LAPACKE_slartgp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_slartgp(float f, float g, float *cs, float *sn, float *r)
     * }
     */
    public static MethodHandle LAPACKE_slartgp$handle() {
        return LAPACKE_slartgp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_slartgp(float f, float g, float *cs, float *sn, float *r)
     * }
     */
    public static MemorySegment LAPACKE_slartgp$address() {
        return LAPACKE_slartgp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_slartgp(float f, float g, float *cs, float *sn, float *r)
     * }
     */
    public static int LAPACKE_slartgp(float f, float g, MemorySegment cs, MemorySegment sn, MemorySegment r) {
        var mh$ = LAPACKE_slartgp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_slartgp", f, g, cs, sn, r);
            }
            return (int)mh$.invokeExact(f, g, cs, sn, r);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dlartgp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_DOUBLE,
            lapacke_h.C_DOUBLE,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dlartgp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dlartgp(double f, double g, double *cs, double *sn, double *r)
     * }
     */
    public static FunctionDescriptor LAPACKE_dlartgp$descriptor() {
        return LAPACKE_dlartgp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dlartgp(double f, double g, double *cs, double *sn, double *r)
     * }
     */
    public static MethodHandle LAPACKE_dlartgp$handle() {
        return LAPACKE_dlartgp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dlartgp(double f, double g, double *cs, double *sn, double *r)
     * }
     */
    public static MemorySegment LAPACKE_dlartgp$address() {
        return LAPACKE_dlartgp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dlartgp(double f, double g, double *cs, double *sn, double *r)
     * }
     */
    public static int LAPACKE_dlartgp(double f, double g, MemorySegment cs, MemorySegment sn, MemorySegment r) {
        var mh$ = LAPACKE_dlartgp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dlartgp", f, g, cs, sn, r);
            }
            return (int)mh$.invokeExact(f, g, cs, sn, r);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_slartgs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_FLOAT,
            lapacke_h.C_FLOAT,
            lapacke_h.C_FLOAT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_slartgs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_slartgs(float x, float y, float sigma, float *cs, float *sn)
     * }
     */
    public static FunctionDescriptor LAPACKE_slartgs$descriptor() {
        return LAPACKE_slartgs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_slartgs(float x, float y, float sigma, float *cs, float *sn)
     * }
     */
    public static MethodHandle LAPACKE_slartgs$handle() {
        return LAPACKE_slartgs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_slartgs(float x, float y, float sigma, float *cs, float *sn)
     * }
     */
    public static MemorySegment LAPACKE_slartgs$address() {
        return LAPACKE_slartgs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_slartgs(float x, float y, float sigma, float *cs, float *sn)
     * }
     */
    public static int LAPACKE_slartgs(float x, float y, float sigma, MemorySegment cs, MemorySegment sn) {
        var mh$ = LAPACKE_slartgs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_slartgs", x, y, sigma, cs, sn);
            }
            return (int)mh$.invokeExact(x, y, sigma, cs, sn);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dlartgs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_DOUBLE,
            lapacke_h.C_DOUBLE,
            lapacke_h.C_DOUBLE,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dlartgs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dlartgs(double x, double y, double sigma, double *cs, double *sn)
     * }
     */
    public static FunctionDescriptor LAPACKE_dlartgs$descriptor() {
        return LAPACKE_dlartgs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dlartgs(double x, double y, double sigma, double *cs, double *sn)
     * }
     */
    public static MethodHandle LAPACKE_dlartgs$handle() {
        return LAPACKE_dlartgs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dlartgs(double x, double y, double sigma, double *cs, double *sn)
     * }
     */
    public static MemorySegment LAPACKE_dlartgs$address() {
        return LAPACKE_dlartgs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dlartgs(double x, double y, double sigma, double *cs, double *sn)
     * }
     */
    public static int LAPACKE_dlartgs(double x, double y, double sigma, MemorySegment cs, MemorySegment sn) {
        var mh$ = LAPACKE_dlartgs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dlartgs", x, y, sigma, cs, sn);
            }
            return (int)mh$.invokeExact(x, y, sigma, cs, sn);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cbbcsd {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_cbbcsd");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cbbcsd(int matrix_layout, char jobu1, char jobu2, char jobv1t, char jobv2t, char trans, int m, int p, int q, float *theta, float *phi, _Complex float *u1, int ldu1, _Complex float *u2, int ldu2, _Complex float *v1t, int ldv1t, _Complex float *v2t, int ldv2t, float *b11d, float *b11e, float *b12d, float *b12e, float *b21d, float *b21e, float *b22d, float *b22e)
     * }
     */
    public static FunctionDescriptor LAPACKE_cbbcsd$descriptor() {
        return LAPACKE_cbbcsd.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cbbcsd(int matrix_layout, char jobu1, char jobu2, char jobv1t, char jobv2t, char trans, int m, int p, int q, float *theta, float *phi, _Complex float *u1, int ldu1, _Complex float *u2, int ldu2, _Complex float *v1t, int ldv1t, _Complex float *v2t, int ldv2t, float *b11d, float *b11e, float *b12d, float *b12e, float *b21d, float *b21e, float *b22d, float *b22e)
     * }
     */
    public static MethodHandle LAPACKE_cbbcsd$handle() {
        return LAPACKE_cbbcsd.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cbbcsd(int matrix_layout, char jobu1, char jobu2, char jobv1t, char jobv2t, char trans, int m, int p, int q, float *theta, float *phi, _Complex float *u1, int ldu1, _Complex float *u2, int ldu2, _Complex float *v1t, int ldv1t, _Complex float *v2t, int ldv2t, float *b11d, float *b11e, float *b12d, float *b12e, float *b21d, float *b21e, float *b22d, float *b22e)
     * }
     */
    public static MemorySegment LAPACKE_cbbcsd$address() {
        return LAPACKE_cbbcsd.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cbbcsd(int matrix_layout, char jobu1, char jobu2, char jobv1t, char jobv2t, char trans, int m, int p, int q, float *theta, float *phi, _Complex float *u1, int ldu1, _Complex float *u2, int ldu2, _Complex float *v1t, int ldv1t, _Complex float *v2t, int ldv2t, float *b11d, float *b11e, float *b12d, float *b12e, float *b21d, float *b21e, float *b22d, float *b22e)
     * }
     */
    public static int LAPACKE_cbbcsd(int matrix_layout, byte jobu1, byte jobu2, byte jobv1t, byte jobv2t, byte trans, int m, int p, int q, MemorySegment theta, MemorySegment phi, MemorySegment u1, int ldu1, MemorySegment u2, int ldu2, MemorySegment v1t, int ldv1t, MemorySegment v2t, int ldv2t, MemorySegment b11d, MemorySegment b11e, MemorySegment b12d, MemorySegment b12e, MemorySegment b21d, MemorySegment b21e, MemorySegment b22d, MemorySegment b22e) {
        var mh$ = LAPACKE_cbbcsd.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cbbcsd", matrix_layout, jobu1, jobu2, jobv1t, jobv2t, trans, m, p, q, theta, phi, u1, ldu1, u2, ldu2, v1t, ldv1t, v2t, ldv2t, b11d, b11e, b12d, b12e, b21d, b21e, b22d, b22e);
            }
            return (int)mh$.invokeExact(matrix_layout, jobu1, jobu2, jobv1t, jobv2t, trans, m, p, q, theta, phi, u1, ldu1, u2, ldu2, v1t, ldv1t, v2t, ldv2t, b11d, b11e, b12d, b12e, b21d, b21e, b22d, b22e);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cbbcsd_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_cbbcsd_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cbbcsd_work(int matrix_layout, char jobu1, char jobu2, char jobv1t, char jobv2t, char trans, int m, int p, int q, float *theta, float *phi, _Complex float *u1, int ldu1, _Complex float *u2, int ldu2, _Complex float *v1t, int ldv1t, _Complex float *v2t, int ldv2t, float *b11d, float *b11e, float *b12d, float *b12e, float *b21d, float *b21e, float *b22d, float *b22e, float *rwork, int lrwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_cbbcsd_work$descriptor() {
        return LAPACKE_cbbcsd_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cbbcsd_work(int matrix_layout, char jobu1, char jobu2, char jobv1t, char jobv2t, char trans, int m, int p, int q, float *theta, float *phi, _Complex float *u1, int ldu1, _Complex float *u2, int ldu2, _Complex float *v1t, int ldv1t, _Complex float *v2t, int ldv2t, float *b11d, float *b11e, float *b12d, float *b12e, float *b21d, float *b21e, float *b22d, float *b22e, float *rwork, int lrwork)
     * }
     */
    public static MethodHandle LAPACKE_cbbcsd_work$handle() {
        return LAPACKE_cbbcsd_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cbbcsd_work(int matrix_layout, char jobu1, char jobu2, char jobv1t, char jobv2t, char trans, int m, int p, int q, float *theta, float *phi, _Complex float *u1, int ldu1, _Complex float *u2, int ldu2, _Complex float *v1t, int ldv1t, _Complex float *v2t, int ldv2t, float *b11d, float *b11e, float *b12d, float *b12e, float *b21d, float *b21e, float *b22d, float *b22e, float *rwork, int lrwork)
     * }
     */
    public static MemorySegment LAPACKE_cbbcsd_work$address() {
        return LAPACKE_cbbcsd_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cbbcsd_work(int matrix_layout, char jobu1, char jobu2, char jobv1t, char jobv2t, char trans, int m, int p, int q, float *theta, float *phi, _Complex float *u1, int ldu1, _Complex float *u2, int ldu2, _Complex float *v1t, int ldv1t, _Complex float *v2t, int ldv2t, float *b11d, float *b11e, float *b12d, float *b12e, float *b21d, float *b21e, float *b22d, float *b22e, float *rwork, int lrwork)
     * }
     */
    public static int LAPACKE_cbbcsd_work(int matrix_layout, byte jobu1, byte jobu2, byte jobv1t, byte jobv2t, byte trans, int m, int p, int q, MemorySegment theta, MemorySegment phi, MemorySegment u1, int ldu1, MemorySegment u2, int ldu2, MemorySegment v1t, int ldv1t, MemorySegment v2t, int ldv2t, MemorySegment b11d, MemorySegment b11e, MemorySegment b12d, MemorySegment b12e, MemorySegment b21d, MemorySegment b21e, MemorySegment b22d, MemorySegment b22e, MemorySegment rwork, int lrwork) {
        var mh$ = LAPACKE_cbbcsd_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cbbcsd_work", matrix_layout, jobu1, jobu2, jobv1t, jobv2t, trans, m, p, q, theta, phi, u1, ldu1, u2, ldu2, v1t, ldv1t, v2t, ldv2t, b11d, b11e, b12d, b12e, b21d, b21e, b22d, b22e, rwork, lrwork);
            }
            return (int)mh$.invokeExact(matrix_layout, jobu1, jobu2, jobv1t, jobv2t, trans, m, p, q, theta, phi, u1, ldu1, u2, ldu2, v1t, ldv1t, v2t, ldv2t, b11d, b11e, b12d, b12e, b21d, b21e, b22d, b22e, rwork, lrwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cheswapr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_cheswapr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cheswapr(int matrix_layout, char uplo, int n, _Complex float *a, int lda, int i1, int i2)
     * }
     */
    public static FunctionDescriptor LAPACKE_cheswapr$descriptor() {
        return LAPACKE_cheswapr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cheswapr(int matrix_layout, char uplo, int n, _Complex float *a, int lda, int i1, int i2)
     * }
     */
    public static MethodHandle LAPACKE_cheswapr$handle() {
        return LAPACKE_cheswapr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cheswapr(int matrix_layout, char uplo, int n, _Complex float *a, int lda, int i1, int i2)
     * }
     */
    public static MemorySegment LAPACKE_cheswapr$address() {
        return LAPACKE_cheswapr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cheswapr(int matrix_layout, char uplo, int n, _Complex float *a, int lda, int i1, int i2)
     * }
     */
    public static int LAPACKE_cheswapr(int matrix_layout, byte uplo, int n, MemorySegment a, int lda, int i1, int i2) {
        var mh$ = LAPACKE_cheswapr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cheswapr", matrix_layout, uplo, n, a, lda, i1, i2);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, a, lda, i1, i2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cheswapr_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_cheswapr_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cheswapr_work(int matrix_layout, char uplo, int n, _Complex float *a, int lda, int i1, int i2)
     * }
     */
    public static FunctionDescriptor LAPACKE_cheswapr_work$descriptor() {
        return LAPACKE_cheswapr_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cheswapr_work(int matrix_layout, char uplo, int n, _Complex float *a, int lda, int i1, int i2)
     * }
     */
    public static MethodHandle LAPACKE_cheswapr_work$handle() {
        return LAPACKE_cheswapr_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cheswapr_work(int matrix_layout, char uplo, int n, _Complex float *a, int lda, int i1, int i2)
     * }
     */
    public static MemorySegment LAPACKE_cheswapr_work$address() {
        return LAPACKE_cheswapr_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cheswapr_work(int matrix_layout, char uplo, int n, _Complex float *a, int lda, int i1, int i2)
     * }
     */
    public static int LAPACKE_cheswapr_work(int matrix_layout, byte uplo, int n, MemorySegment a, int lda, int i1, int i2) {
        var mh$ = LAPACKE_cheswapr_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cheswapr_work", matrix_layout, uplo, n, a, lda, i1, i2);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, a, lda, i1, i2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_chetri2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_chetri2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_chetri2(int matrix_layout, char uplo, int n, _Complex float *a, int lda, const int *ipiv)
     * }
     */
    public static FunctionDescriptor LAPACKE_chetri2$descriptor() {
        return LAPACKE_chetri2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_chetri2(int matrix_layout, char uplo, int n, _Complex float *a, int lda, const int *ipiv)
     * }
     */
    public static MethodHandle LAPACKE_chetri2$handle() {
        return LAPACKE_chetri2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_chetri2(int matrix_layout, char uplo, int n, _Complex float *a, int lda, const int *ipiv)
     * }
     */
    public static MemorySegment LAPACKE_chetri2$address() {
        return LAPACKE_chetri2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_chetri2(int matrix_layout, char uplo, int n, _Complex float *a, int lda, const int *ipiv)
     * }
     */
    public static int LAPACKE_chetri2(int matrix_layout, byte uplo, int n, MemorySegment a, int lda, MemorySegment ipiv) {
        var mh$ = LAPACKE_chetri2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_chetri2", matrix_layout, uplo, n, a, lda, ipiv);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, a, lda, ipiv);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_chetri2_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_chetri2_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_chetri2_work(int matrix_layout, char uplo, int n, _Complex float *a, int lda, const int *ipiv, _Complex float *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_chetri2_work$descriptor() {
        return LAPACKE_chetri2_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_chetri2_work(int matrix_layout, char uplo, int n, _Complex float *a, int lda, const int *ipiv, _Complex float *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_chetri2_work$handle() {
        return LAPACKE_chetri2_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_chetri2_work(int matrix_layout, char uplo, int n, _Complex float *a, int lda, const int *ipiv, _Complex float *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_chetri2_work$address() {
        return LAPACKE_chetri2_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_chetri2_work(int matrix_layout, char uplo, int n, _Complex float *a, int lda, const int *ipiv, _Complex float *work, int lwork)
     * }
     */
    public static int LAPACKE_chetri2_work(int matrix_layout, byte uplo, int n, MemorySegment a, int lda, MemorySegment ipiv, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_chetri2_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_chetri2_work", matrix_layout, uplo, n, a, lda, ipiv, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, a, lda, ipiv, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_chetri2x {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_chetri2x");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_chetri2x(int matrix_layout, char uplo, int n, _Complex float *a, int lda, const int *ipiv, int nb)
     * }
     */
    public static FunctionDescriptor LAPACKE_chetri2x$descriptor() {
        return LAPACKE_chetri2x.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_chetri2x(int matrix_layout, char uplo, int n, _Complex float *a, int lda, const int *ipiv, int nb)
     * }
     */
    public static MethodHandle LAPACKE_chetri2x$handle() {
        return LAPACKE_chetri2x.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_chetri2x(int matrix_layout, char uplo, int n, _Complex float *a, int lda, const int *ipiv, int nb)
     * }
     */
    public static MemorySegment LAPACKE_chetri2x$address() {
        return LAPACKE_chetri2x.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_chetri2x(int matrix_layout, char uplo, int n, _Complex float *a, int lda, const int *ipiv, int nb)
     * }
     */
    public static int LAPACKE_chetri2x(int matrix_layout, byte uplo, int n, MemorySegment a, int lda, MemorySegment ipiv, int nb) {
        var mh$ = LAPACKE_chetri2x.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_chetri2x", matrix_layout, uplo, n, a, lda, ipiv, nb);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, a, lda, ipiv, nb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_chetri2x_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_chetri2x_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_chetri2x_work(int matrix_layout, char uplo, int n, _Complex float *a, int lda, const int *ipiv, _Complex float *work, int nb)
     * }
     */
    public static FunctionDescriptor LAPACKE_chetri2x_work$descriptor() {
        return LAPACKE_chetri2x_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_chetri2x_work(int matrix_layout, char uplo, int n, _Complex float *a, int lda, const int *ipiv, _Complex float *work, int nb)
     * }
     */
    public static MethodHandle LAPACKE_chetri2x_work$handle() {
        return LAPACKE_chetri2x_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_chetri2x_work(int matrix_layout, char uplo, int n, _Complex float *a, int lda, const int *ipiv, _Complex float *work, int nb)
     * }
     */
    public static MemorySegment LAPACKE_chetri2x_work$address() {
        return LAPACKE_chetri2x_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_chetri2x_work(int matrix_layout, char uplo, int n, _Complex float *a, int lda, const int *ipiv, _Complex float *work, int nb)
     * }
     */
    public static int LAPACKE_chetri2x_work(int matrix_layout, byte uplo, int n, MemorySegment a, int lda, MemorySegment ipiv, MemorySegment work, int nb) {
        var mh$ = LAPACKE_chetri2x_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_chetri2x_work", matrix_layout, uplo, n, a, lda, ipiv, work, nb);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, a, lda, ipiv, work, nb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_chetrs2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_chetrs2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_chetrs2(int matrix_layout, char uplo, int n, int nrhs, const _Complex float *a, int lda, const int *ipiv, _Complex float *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_chetrs2$descriptor() {
        return LAPACKE_chetrs2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_chetrs2(int matrix_layout, char uplo, int n, int nrhs, const _Complex float *a, int lda, const int *ipiv, _Complex float *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_chetrs2$handle() {
        return LAPACKE_chetrs2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_chetrs2(int matrix_layout, char uplo, int n, int nrhs, const _Complex float *a, int lda, const int *ipiv, _Complex float *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_chetrs2$address() {
        return LAPACKE_chetrs2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_chetrs2(int matrix_layout, char uplo, int n, int nrhs, const _Complex float *a, int lda, const int *ipiv, _Complex float *b, int ldb)
     * }
     */
    public static int LAPACKE_chetrs2(int matrix_layout, byte uplo, int n, int nrhs, MemorySegment a, int lda, MemorySegment ipiv, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_chetrs2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_chetrs2", matrix_layout, uplo, n, nrhs, a, lda, ipiv, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, nrhs, a, lda, ipiv, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_chetrs2_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_chetrs2_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_chetrs2_work(int matrix_layout, char uplo, int n, int nrhs, const _Complex float *a, int lda, const int *ipiv, _Complex float *b, int ldb, _Complex float *work)
     * }
     */
    public static FunctionDescriptor LAPACKE_chetrs2_work$descriptor() {
        return LAPACKE_chetrs2_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_chetrs2_work(int matrix_layout, char uplo, int n, int nrhs, const _Complex float *a, int lda, const int *ipiv, _Complex float *b, int ldb, _Complex float *work)
     * }
     */
    public static MethodHandle LAPACKE_chetrs2_work$handle() {
        return LAPACKE_chetrs2_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_chetrs2_work(int matrix_layout, char uplo, int n, int nrhs, const _Complex float *a, int lda, const int *ipiv, _Complex float *b, int ldb, _Complex float *work)
     * }
     */
    public static MemorySegment LAPACKE_chetrs2_work$address() {
        return LAPACKE_chetrs2_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_chetrs2_work(int matrix_layout, char uplo, int n, int nrhs, const _Complex float *a, int lda, const int *ipiv, _Complex float *b, int ldb, _Complex float *work)
     * }
     */
    public static int LAPACKE_chetrs2_work(int matrix_layout, byte uplo, int n, int nrhs, MemorySegment a, int lda, MemorySegment ipiv, MemorySegment b, int ldb, MemorySegment work) {
        var mh$ = LAPACKE_chetrs2_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_chetrs2_work", matrix_layout, uplo, n, nrhs, a, lda, ipiv, b, ldb, work);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, nrhs, a, lda, ipiv, b, ldb, work);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_csyconv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_csyconv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_csyconv(int matrix_layout, char uplo, char way, int n, _Complex float *a, int lda, const int *ipiv, _Complex float *e)
     * }
     */
    public static FunctionDescriptor LAPACKE_csyconv$descriptor() {
        return LAPACKE_csyconv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_csyconv(int matrix_layout, char uplo, char way, int n, _Complex float *a, int lda, const int *ipiv, _Complex float *e)
     * }
     */
    public static MethodHandle LAPACKE_csyconv$handle() {
        return LAPACKE_csyconv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_csyconv(int matrix_layout, char uplo, char way, int n, _Complex float *a, int lda, const int *ipiv, _Complex float *e)
     * }
     */
    public static MemorySegment LAPACKE_csyconv$address() {
        return LAPACKE_csyconv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_csyconv(int matrix_layout, char uplo, char way, int n, _Complex float *a, int lda, const int *ipiv, _Complex float *e)
     * }
     */
    public static int LAPACKE_csyconv(int matrix_layout, byte uplo, byte way, int n, MemorySegment a, int lda, MemorySegment ipiv, MemorySegment e) {
        var mh$ = LAPACKE_csyconv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_csyconv", matrix_layout, uplo, way, n, a, lda, ipiv, e);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, way, n, a, lda, ipiv, e);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_csyconv_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_csyconv_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_csyconv_work(int matrix_layout, char uplo, char way, int n, _Complex float *a, int lda, const int *ipiv, _Complex float *e)
     * }
     */
    public static FunctionDescriptor LAPACKE_csyconv_work$descriptor() {
        return LAPACKE_csyconv_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_csyconv_work(int matrix_layout, char uplo, char way, int n, _Complex float *a, int lda, const int *ipiv, _Complex float *e)
     * }
     */
    public static MethodHandle LAPACKE_csyconv_work$handle() {
        return LAPACKE_csyconv_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_csyconv_work(int matrix_layout, char uplo, char way, int n, _Complex float *a, int lda, const int *ipiv, _Complex float *e)
     * }
     */
    public static MemorySegment LAPACKE_csyconv_work$address() {
        return LAPACKE_csyconv_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_csyconv_work(int matrix_layout, char uplo, char way, int n, _Complex float *a, int lda, const int *ipiv, _Complex float *e)
     * }
     */
    public static int LAPACKE_csyconv_work(int matrix_layout, byte uplo, byte way, int n, MemorySegment a, int lda, MemorySegment ipiv, MemorySegment e) {
        var mh$ = LAPACKE_csyconv_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_csyconv_work", matrix_layout, uplo, way, n, a, lda, ipiv, e);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, way, n, a, lda, ipiv, e);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_csyswapr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_csyswapr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_csyswapr(int matrix_layout, char uplo, int n, _Complex float *a, int lda, int i1, int i2)
     * }
     */
    public static FunctionDescriptor LAPACKE_csyswapr$descriptor() {
        return LAPACKE_csyswapr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_csyswapr(int matrix_layout, char uplo, int n, _Complex float *a, int lda, int i1, int i2)
     * }
     */
    public static MethodHandle LAPACKE_csyswapr$handle() {
        return LAPACKE_csyswapr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_csyswapr(int matrix_layout, char uplo, int n, _Complex float *a, int lda, int i1, int i2)
     * }
     */
    public static MemorySegment LAPACKE_csyswapr$address() {
        return LAPACKE_csyswapr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_csyswapr(int matrix_layout, char uplo, int n, _Complex float *a, int lda, int i1, int i2)
     * }
     */
    public static int LAPACKE_csyswapr(int matrix_layout, byte uplo, int n, MemorySegment a, int lda, int i1, int i2) {
        var mh$ = LAPACKE_csyswapr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_csyswapr", matrix_layout, uplo, n, a, lda, i1, i2);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, a, lda, i1, i2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_csyswapr_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_csyswapr_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_csyswapr_work(int matrix_layout, char uplo, int n, _Complex float *a, int lda, int i1, int i2)
     * }
     */
    public static FunctionDescriptor LAPACKE_csyswapr_work$descriptor() {
        return LAPACKE_csyswapr_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_csyswapr_work(int matrix_layout, char uplo, int n, _Complex float *a, int lda, int i1, int i2)
     * }
     */
    public static MethodHandle LAPACKE_csyswapr_work$handle() {
        return LAPACKE_csyswapr_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_csyswapr_work(int matrix_layout, char uplo, int n, _Complex float *a, int lda, int i1, int i2)
     * }
     */
    public static MemorySegment LAPACKE_csyswapr_work$address() {
        return LAPACKE_csyswapr_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_csyswapr_work(int matrix_layout, char uplo, int n, _Complex float *a, int lda, int i1, int i2)
     * }
     */
    public static int LAPACKE_csyswapr_work(int matrix_layout, byte uplo, int n, MemorySegment a, int lda, int i1, int i2) {
        var mh$ = LAPACKE_csyswapr_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_csyswapr_work", matrix_layout, uplo, n, a, lda, i1, i2);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, a, lda, i1, i2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_csytri2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_csytri2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_csytri2(int matrix_layout, char uplo, int n, _Complex float *a, int lda, const int *ipiv)
     * }
     */
    public static FunctionDescriptor LAPACKE_csytri2$descriptor() {
        return LAPACKE_csytri2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_csytri2(int matrix_layout, char uplo, int n, _Complex float *a, int lda, const int *ipiv)
     * }
     */
    public static MethodHandle LAPACKE_csytri2$handle() {
        return LAPACKE_csytri2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_csytri2(int matrix_layout, char uplo, int n, _Complex float *a, int lda, const int *ipiv)
     * }
     */
    public static MemorySegment LAPACKE_csytri2$address() {
        return LAPACKE_csytri2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_csytri2(int matrix_layout, char uplo, int n, _Complex float *a, int lda, const int *ipiv)
     * }
     */
    public static int LAPACKE_csytri2(int matrix_layout, byte uplo, int n, MemorySegment a, int lda, MemorySegment ipiv) {
        var mh$ = LAPACKE_csytri2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_csytri2", matrix_layout, uplo, n, a, lda, ipiv);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, a, lda, ipiv);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_csytri2_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_csytri2_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_csytri2_work(int matrix_layout, char uplo, int n, _Complex float *a, int lda, const int *ipiv, _Complex float *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_csytri2_work$descriptor() {
        return LAPACKE_csytri2_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_csytri2_work(int matrix_layout, char uplo, int n, _Complex float *a, int lda, const int *ipiv, _Complex float *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_csytri2_work$handle() {
        return LAPACKE_csytri2_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_csytri2_work(int matrix_layout, char uplo, int n, _Complex float *a, int lda, const int *ipiv, _Complex float *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_csytri2_work$address() {
        return LAPACKE_csytri2_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_csytri2_work(int matrix_layout, char uplo, int n, _Complex float *a, int lda, const int *ipiv, _Complex float *work, int lwork)
     * }
     */
    public static int LAPACKE_csytri2_work(int matrix_layout, byte uplo, int n, MemorySegment a, int lda, MemorySegment ipiv, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_csytri2_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_csytri2_work", matrix_layout, uplo, n, a, lda, ipiv, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, a, lda, ipiv, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_csytri2x {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_csytri2x");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_csytri2x(int matrix_layout, char uplo, int n, _Complex float *a, int lda, const int *ipiv, int nb)
     * }
     */
    public static FunctionDescriptor LAPACKE_csytri2x$descriptor() {
        return LAPACKE_csytri2x.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_csytri2x(int matrix_layout, char uplo, int n, _Complex float *a, int lda, const int *ipiv, int nb)
     * }
     */
    public static MethodHandle LAPACKE_csytri2x$handle() {
        return LAPACKE_csytri2x.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_csytri2x(int matrix_layout, char uplo, int n, _Complex float *a, int lda, const int *ipiv, int nb)
     * }
     */
    public static MemorySegment LAPACKE_csytri2x$address() {
        return LAPACKE_csytri2x.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_csytri2x(int matrix_layout, char uplo, int n, _Complex float *a, int lda, const int *ipiv, int nb)
     * }
     */
    public static int LAPACKE_csytri2x(int matrix_layout, byte uplo, int n, MemorySegment a, int lda, MemorySegment ipiv, int nb) {
        var mh$ = LAPACKE_csytri2x.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_csytri2x", matrix_layout, uplo, n, a, lda, ipiv, nb);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, a, lda, ipiv, nb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_csytri2x_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_csytri2x_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_csytri2x_work(int matrix_layout, char uplo, int n, _Complex float *a, int lda, const int *ipiv, _Complex float *work, int nb)
     * }
     */
    public static FunctionDescriptor LAPACKE_csytri2x_work$descriptor() {
        return LAPACKE_csytri2x_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_csytri2x_work(int matrix_layout, char uplo, int n, _Complex float *a, int lda, const int *ipiv, _Complex float *work, int nb)
     * }
     */
    public static MethodHandle LAPACKE_csytri2x_work$handle() {
        return LAPACKE_csytri2x_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_csytri2x_work(int matrix_layout, char uplo, int n, _Complex float *a, int lda, const int *ipiv, _Complex float *work, int nb)
     * }
     */
    public static MemorySegment LAPACKE_csytri2x_work$address() {
        return LAPACKE_csytri2x_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_csytri2x_work(int matrix_layout, char uplo, int n, _Complex float *a, int lda, const int *ipiv, _Complex float *work, int nb)
     * }
     */
    public static int LAPACKE_csytri2x_work(int matrix_layout, byte uplo, int n, MemorySegment a, int lda, MemorySegment ipiv, MemorySegment work, int nb) {
        var mh$ = LAPACKE_csytri2x_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_csytri2x_work", matrix_layout, uplo, n, a, lda, ipiv, work, nb);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, a, lda, ipiv, work, nb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_csytrs2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_csytrs2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_csytrs2(int matrix_layout, char uplo, int n, int nrhs, const _Complex float *a, int lda, const int *ipiv, _Complex float *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_csytrs2$descriptor() {
        return LAPACKE_csytrs2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_csytrs2(int matrix_layout, char uplo, int n, int nrhs, const _Complex float *a, int lda, const int *ipiv, _Complex float *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_csytrs2$handle() {
        return LAPACKE_csytrs2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_csytrs2(int matrix_layout, char uplo, int n, int nrhs, const _Complex float *a, int lda, const int *ipiv, _Complex float *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_csytrs2$address() {
        return LAPACKE_csytrs2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_csytrs2(int matrix_layout, char uplo, int n, int nrhs, const _Complex float *a, int lda, const int *ipiv, _Complex float *b, int ldb)
     * }
     */
    public static int LAPACKE_csytrs2(int matrix_layout, byte uplo, int n, int nrhs, MemorySegment a, int lda, MemorySegment ipiv, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_csytrs2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_csytrs2", matrix_layout, uplo, n, nrhs, a, lda, ipiv, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, nrhs, a, lda, ipiv, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_csytrs2_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_csytrs2_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_csytrs2_work(int matrix_layout, char uplo, int n, int nrhs, const _Complex float *a, int lda, const int *ipiv, _Complex float *b, int ldb, _Complex float *work)
     * }
     */
    public static FunctionDescriptor LAPACKE_csytrs2_work$descriptor() {
        return LAPACKE_csytrs2_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_csytrs2_work(int matrix_layout, char uplo, int n, int nrhs, const _Complex float *a, int lda, const int *ipiv, _Complex float *b, int ldb, _Complex float *work)
     * }
     */
    public static MethodHandle LAPACKE_csytrs2_work$handle() {
        return LAPACKE_csytrs2_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_csytrs2_work(int matrix_layout, char uplo, int n, int nrhs, const _Complex float *a, int lda, const int *ipiv, _Complex float *b, int ldb, _Complex float *work)
     * }
     */
    public static MemorySegment LAPACKE_csytrs2_work$address() {
        return LAPACKE_csytrs2_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_csytrs2_work(int matrix_layout, char uplo, int n, int nrhs, const _Complex float *a, int lda, const int *ipiv, _Complex float *b, int ldb, _Complex float *work)
     * }
     */
    public static int LAPACKE_csytrs2_work(int matrix_layout, byte uplo, int n, int nrhs, MemorySegment a, int lda, MemorySegment ipiv, MemorySegment b, int ldb, MemorySegment work) {
        var mh$ = LAPACKE_csytrs2_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_csytrs2_work", matrix_layout, uplo, n, nrhs, a, lda, ipiv, b, ldb, work);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, nrhs, a, lda, ipiv, b, ldb, work);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cunbdb {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_cunbdb");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cunbdb(int matrix_layout, char trans, char signs, int m, int p, int q, _Complex float *x11, int ldx11, _Complex float *x12, int ldx12, _Complex float *x21, int ldx21, _Complex float *x22, int ldx22, float *theta, float *phi, _Complex float *taup1, _Complex float *taup2, _Complex float *tauq1, _Complex float *tauq2)
     * }
     */
    public static FunctionDescriptor LAPACKE_cunbdb$descriptor() {
        return LAPACKE_cunbdb.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cunbdb(int matrix_layout, char trans, char signs, int m, int p, int q, _Complex float *x11, int ldx11, _Complex float *x12, int ldx12, _Complex float *x21, int ldx21, _Complex float *x22, int ldx22, float *theta, float *phi, _Complex float *taup1, _Complex float *taup2, _Complex float *tauq1, _Complex float *tauq2)
     * }
     */
    public static MethodHandle LAPACKE_cunbdb$handle() {
        return LAPACKE_cunbdb.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cunbdb(int matrix_layout, char trans, char signs, int m, int p, int q, _Complex float *x11, int ldx11, _Complex float *x12, int ldx12, _Complex float *x21, int ldx21, _Complex float *x22, int ldx22, float *theta, float *phi, _Complex float *taup1, _Complex float *taup2, _Complex float *tauq1, _Complex float *tauq2)
     * }
     */
    public static MemorySegment LAPACKE_cunbdb$address() {
        return LAPACKE_cunbdb.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cunbdb(int matrix_layout, char trans, char signs, int m, int p, int q, _Complex float *x11, int ldx11, _Complex float *x12, int ldx12, _Complex float *x21, int ldx21, _Complex float *x22, int ldx22, float *theta, float *phi, _Complex float *taup1, _Complex float *taup2, _Complex float *tauq1, _Complex float *tauq2)
     * }
     */
    public static int LAPACKE_cunbdb(int matrix_layout, byte trans, byte signs, int m, int p, int q, MemorySegment x11, int ldx11, MemorySegment x12, int ldx12, MemorySegment x21, int ldx21, MemorySegment x22, int ldx22, MemorySegment theta, MemorySegment phi, MemorySegment taup1, MemorySegment taup2, MemorySegment tauq1, MemorySegment tauq2) {
        var mh$ = LAPACKE_cunbdb.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cunbdb", matrix_layout, trans, signs, m, p, q, x11, ldx11, x12, ldx12, x21, ldx21, x22, ldx22, theta, phi, taup1, taup2, tauq1, tauq2);
            }
            return (int)mh$.invokeExact(matrix_layout, trans, signs, m, p, q, x11, ldx11, x12, ldx12, x21, ldx21, x22, ldx22, theta, phi, taup1, taup2, tauq1, tauq2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cunbdb_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_cunbdb_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cunbdb_work(int matrix_layout, char trans, char signs, int m, int p, int q, _Complex float *x11, int ldx11, _Complex float *x12, int ldx12, _Complex float *x21, int ldx21, _Complex float *x22, int ldx22, float *theta, float *phi, _Complex float *taup1, _Complex float *taup2, _Complex float *tauq1, _Complex float *tauq2, _Complex float *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_cunbdb_work$descriptor() {
        return LAPACKE_cunbdb_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cunbdb_work(int matrix_layout, char trans, char signs, int m, int p, int q, _Complex float *x11, int ldx11, _Complex float *x12, int ldx12, _Complex float *x21, int ldx21, _Complex float *x22, int ldx22, float *theta, float *phi, _Complex float *taup1, _Complex float *taup2, _Complex float *tauq1, _Complex float *tauq2, _Complex float *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_cunbdb_work$handle() {
        return LAPACKE_cunbdb_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cunbdb_work(int matrix_layout, char trans, char signs, int m, int p, int q, _Complex float *x11, int ldx11, _Complex float *x12, int ldx12, _Complex float *x21, int ldx21, _Complex float *x22, int ldx22, float *theta, float *phi, _Complex float *taup1, _Complex float *taup2, _Complex float *tauq1, _Complex float *tauq2, _Complex float *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_cunbdb_work$address() {
        return LAPACKE_cunbdb_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cunbdb_work(int matrix_layout, char trans, char signs, int m, int p, int q, _Complex float *x11, int ldx11, _Complex float *x12, int ldx12, _Complex float *x21, int ldx21, _Complex float *x22, int ldx22, float *theta, float *phi, _Complex float *taup1, _Complex float *taup2, _Complex float *tauq1, _Complex float *tauq2, _Complex float *work, int lwork)
     * }
     */
    public static int LAPACKE_cunbdb_work(int matrix_layout, byte trans, byte signs, int m, int p, int q, MemorySegment x11, int ldx11, MemorySegment x12, int ldx12, MemorySegment x21, int ldx21, MemorySegment x22, int ldx22, MemorySegment theta, MemorySegment phi, MemorySegment taup1, MemorySegment taup2, MemorySegment tauq1, MemorySegment tauq2, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_cunbdb_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cunbdb_work", matrix_layout, trans, signs, m, p, q, x11, ldx11, x12, ldx12, x21, ldx21, x22, ldx22, theta, phi, taup1, taup2, tauq1, tauq2, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, trans, signs, m, p, q, x11, ldx11, x12, ldx12, x21, ldx21, x22, ldx22, theta, phi, taup1, taup2, tauq1, tauq2, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cuncsd {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_cuncsd");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cuncsd(int matrix_layout, char jobu1, char jobu2, char jobv1t, char jobv2t, char trans, char signs, int m, int p, int q, _Complex float *x11, int ldx11, _Complex float *x12, int ldx12, _Complex float *x21, int ldx21, _Complex float *x22, int ldx22, float *theta, _Complex float *u1, int ldu1, _Complex float *u2, int ldu2, _Complex float *v1t, int ldv1t, _Complex float *v2t, int ldv2t)
     * }
     */
    public static FunctionDescriptor LAPACKE_cuncsd$descriptor() {
        return LAPACKE_cuncsd.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cuncsd(int matrix_layout, char jobu1, char jobu2, char jobv1t, char jobv2t, char trans, char signs, int m, int p, int q, _Complex float *x11, int ldx11, _Complex float *x12, int ldx12, _Complex float *x21, int ldx21, _Complex float *x22, int ldx22, float *theta, _Complex float *u1, int ldu1, _Complex float *u2, int ldu2, _Complex float *v1t, int ldv1t, _Complex float *v2t, int ldv2t)
     * }
     */
    public static MethodHandle LAPACKE_cuncsd$handle() {
        return LAPACKE_cuncsd.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cuncsd(int matrix_layout, char jobu1, char jobu2, char jobv1t, char jobv2t, char trans, char signs, int m, int p, int q, _Complex float *x11, int ldx11, _Complex float *x12, int ldx12, _Complex float *x21, int ldx21, _Complex float *x22, int ldx22, float *theta, _Complex float *u1, int ldu1, _Complex float *u2, int ldu2, _Complex float *v1t, int ldv1t, _Complex float *v2t, int ldv2t)
     * }
     */
    public static MemorySegment LAPACKE_cuncsd$address() {
        return LAPACKE_cuncsd.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cuncsd(int matrix_layout, char jobu1, char jobu2, char jobv1t, char jobv2t, char trans, char signs, int m, int p, int q, _Complex float *x11, int ldx11, _Complex float *x12, int ldx12, _Complex float *x21, int ldx21, _Complex float *x22, int ldx22, float *theta, _Complex float *u1, int ldu1, _Complex float *u2, int ldu2, _Complex float *v1t, int ldv1t, _Complex float *v2t, int ldv2t)
     * }
     */
    public static int LAPACKE_cuncsd(int matrix_layout, byte jobu1, byte jobu2, byte jobv1t, byte jobv2t, byte trans, byte signs, int m, int p, int q, MemorySegment x11, int ldx11, MemorySegment x12, int ldx12, MemorySegment x21, int ldx21, MemorySegment x22, int ldx22, MemorySegment theta, MemorySegment u1, int ldu1, MemorySegment u2, int ldu2, MemorySegment v1t, int ldv1t, MemorySegment v2t, int ldv2t) {
        var mh$ = LAPACKE_cuncsd.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cuncsd", matrix_layout, jobu1, jobu2, jobv1t, jobv2t, trans, signs, m, p, q, x11, ldx11, x12, ldx12, x21, ldx21, x22, ldx22, theta, u1, ldu1, u2, ldu2, v1t, ldv1t, v2t, ldv2t);
            }
            return (int)mh$.invokeExact(matrix_layout, jobu1, jobu2, jobv1t, jobv2t, trans, signs, m, p, q, x11, ldx11, x12, ldx12, x21, ldx21, x22, ldx22, theta, u1, ldu1, u2, ldu2, v1t, ldv1t, v2t, ldv2t);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cuncsd_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_cuncsd_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cuncsd_work(int matrix_layout, char jobu1, char jobu2, char jobv1t, char jobv2t, char trans, char signs, int m, int p, int q, _Complex float *x11, int ldx11, _Complex float *x12, int ldx12, _Complex float *x21, int ldx21, _Complex float *x22, int ldx22, float *theta, _Complex float *u1, int ldu1, _Complex float *u2, int ldu2, _Complex float *v1t, int ldv1t, _Complex float *v2t, int ldv2t, _Complex float *work, int lwork, float *rwork, int lrwork, int *iwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_cuncsd_work$descriptor() {
        return LAPACKE_cuncsd_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cuncsd_work(int matrix_layout, char jobu1, char jobu2, char jobv1t, char jobv2t, char trans, char signs, int m, int p, int q, _Complex float *x11, int ldx11, _Complex float *x12, int ldx12, _Complex float *x21, int ldx21, _Complex float *x22, int ldx22, float *theta, _Complex float *u1, int ldu1, _Complex float *u2, int ldu2, _Complex float *v1t, int ldv1t, _Complex float *v2t, int ldv2t, _Complex float *work, int lwork, float *rwork, int lrwork, int *iwork)
     * }
     */
    public static MethodHandle LAPACKE_cuncsd_work$handle() {
        return LAPACKE_cuncsd_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cuncsd_work(int matrix_layout, char jobu1, char jobu2, char jobv1t, char jobv2t, char trans, char signs, int m, int p, int q, _Complex float *x11, int ldx11, _Complex float *x12, int ldx12, _Complex float *x21, int ldx21, _Complex float *x22, int ldx22, float *theta, _Complex float *u1, int ldu1, _Complex float *u2, int ldu2, _Complex float *v1t, int ldv1t, _Complex float *v2t, int ldv2t, _Complex float *work, int lwork, float *rwork, int lrwork, int *iwork)
     * }
     */
    public static MemorySegment LAPACKE_cuncsd_work$address() {
        return LAPACKE_cuncsd_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cuncsd_work(int matrix_layout, char jobu1, char jobu2, char jobv1t, char jobv2t, char trans, char signs, int m, int p, int q, _Complex float *x11, int ldx11, _Complex float *x12, int ldx12, _Complex float *x21, int ldx21, _Complex float *x22, int ldx22, float *theta, _Complex float *u1, int ldu1, _Complex float *u2, int ldu2, _Complex float *v1t, int ldv1t, _Complex float *v2t, int ldv2t, _Complex float *work, int lwork, float *rwork, int lrwork, int *iwork)
     * }
     */
    public static int LAPACKE_cuncsd_work(int matrix_layout, byte jobu1, byte jobu2, byte jobv1t, byte jobv2t, byte trans, byte signs, int m, int p, int q, MemorySegment x11, int ldx11, MemorySegment x12, int ldx12, MemorySegment x21, int ldx21, MemorySegment x22, int ldx22, MemorySegment theta, MemorySegment u1, int ldu1, MemorySegment u2, int ldu2, MemorySegment v1t, int ldv1t, MemorySegment v2t, int ldv2t, MemorySegment work, int lwork, MemorySegment rwork, int lrwork, MemorySegment iwork) {
        var mh$ = LAPACKE_cuncsd_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cuncsd_work", matrix_layout, jobu1, jobu2, jobv1t, jobv2t, trans, signs, m, p, q, x11, ldx11, x12, ldx12, x21, ldx21, x22, ldx22, theta, u1, ldu1, u2, ldu2, v1t, ldv1t, v2t, ldv2t, work, lwork, rwork, lrwork, iwork);
            }
            return (int)mh$.invokeExact(matrix_layout, jobu1, jobu2, jobv1t, jobv2t, trans, signs, m, p, q, x11, ldx11, x12, ldx12, x21, ldx21, x22, ldx22, theta, u1, ldu1, u2, ldu2, v1t, ldv1t, v2t, ldv2t, work, lwork, rwork, lrwork, iwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cuncsd2by1 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_cuncsd2by1");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cuncsd2by1(int matrix_layout, char jobu1, char jobu2, char jobv1t, int m, int p, int q, _Complex float *x11, int ldx11, _Complex float *x21, int ldx21, float *theta, _Complex float *u1, int ldu1, _Complex float *u2, int ldu2, _Complex float *v1t, int ldv1t)
     * }
     */
    public static FunctionDescriptor LAPACKE_cuncsd2by1$descriptor() {
        return LAPACKE_cuncsd2by1.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cuncsd2by1(int matrix_layout, char jobu1, char jobu2, char jobv1t, int m, int p, int q, _Complex float *x11, int ldx11, _Complex float *x21, int ldx21, float *theta, _Complex float *u1, int ldu1, _Complex float *u2, int ldu2, _Complex float *v1t, int ldv1t)
     * }
     */
    public static MethodHandle LAPACKE_cuncsd2by1$handle() {
        return LAPACKE_cuncsd2by1.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cuncsd2by1(int matrix_layout, char jobu1, char jobu2, char jobv1t, int m, int p, int q, _Complex float *x11, int ldx11, _Complex float *x21, int ldx21, float *theta, _Complex float *u1, int ldu1, _Complex float *u2, int ldu2, _Complex float *v1t, int ldv1t)
     * }
     */
    public static MemorySegment LAPACKE_cuncsd2by1$address() {
        return LAPACKE_cuncsd2by1.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cuncsd2by1(int matrix_layout, char jobu1, char jobu2, char jobv1t, int m, int p, int q, _Complex float *x11, int ldx11, _Complex float *x21, int ldx21, float *theta, _Complex float *u1, int ldu1, _Complex float *u2, int ldu2, _Complex float *v1t, int ldv1t)
     * }
     */
    public static int LAPACKE_cuncsd2by1(int matrix_layout, byte jobu1, byte jobu2, byte jobv1t, int m, int p, int q, MemorySegment x11, int ldx11, MemorySegment x21, int ldx21, MemorySegment theta, MemorySegment u1, int ldu1, MemorySegment u2, int ldu2, MemorySegment v1t, int ldv1t) {
        var mh$ = LAPACKE_cuncsd2by1.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cuncsd2by1", matrix_layout, jobu1, jobu2, jobv1t, m, p, q, x11, ldx11, x21, ldx21, theta, u1, ldu1, u2, ldu2, v1t, ldv1t);
            }
            return (int)mh$.invokeExact(matrix_layout, jobu1, jobu2, jobv1t, m, p, q, x11, ldx11, x21, ldx21, theta, u1, ldu1, u2, ldu2, v1t, ldv1t);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cuncsd2by1_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_cuncsd2by1_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cuncsd2by1_work(int matrix_layout, char jobu1, char jobu2, char jobv1t, int m, int p, int q, _Complex float *x11, int ldx11, _Complex float *x21, int ldx21, float *theta, _Complex float *u1, int ldu1, _Complex float *u2, int ldu2, _Complex float *v1t, int ldv1t, _Complex float *work, int lwork, float *rwork, int lrwork, int *iwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_cuncsd2by1_work$descriptor() {
        return LAPACKE_cuncsd2by1_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cuncsd2by1_work(int matrix_layout, char jobu1, char jobu2, char jobv1t, int m, int p, int q, _Complex float *x11, int ldx11, _Complex float *x21, int ldx21, float *theta, _Complex float *u1, int ldu1, _Complex float *u2, int ldu2, _Complex float *v1t, int ldv1t, _Complex float *work, int lwork, float *rwork, int lrwork, int *iwork)
     * }
     */
    public static MethodHandle LAPACKE_cuncsd2by1_work$handle() {
        return LAPACKE_cuncsd2by1_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cuncsd2by1_work(int matrix_layout, char jobu1, char jobu2, char jobv1t, int m, int p, int q, _Complex float *x11, int ldx11, _Complex float *x21, int ldx21, float *theta, _Complex float *u1, int ldu1, _Complex float *u2, int ldu2, _Complex float *v1t, int ldv1t, _Complex float *work, int lwork, float *rwork, int lrwork, int *iwork)
     * }
     */
    public static MemorySegment LAPACKE_cuncsd2by1_work$address() {
        return LAPACKE_cuncsd2by1_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cuncsd2by1_work(int matrix_layout, char jobu1, char jobu2, char jobv1t, int m, int p, int q, _Complex float *x11, int ldx11, _Complex float *x21, int ldx21, float *theta, _Complex float *u1, int ldu1, _Complex float *u2, int ldu2, _Complex float *v1t, int ldv1t, _Complex float *work, int lwork, float *rwork, int lrwork, int *iwork)
     * }
     */
    public static int LAPACKE_cuncsd2by1_work(int matrix_layout, byte jobu1, byte jobu2, byte jobv1t, int m, int p, int q, MemorySegment x11, int ldx11, MemorySegment x21, int ldx21, MemorySegment theta, MemorySegment u1, int ldu1, MemorySegment u2, int ldu2, MemorySegment v1t, int ldv1t, MemorySegment work, int lwork, MemorySegment rwork, int lrwork, MemorySegment iwork) {
        var mh$ = LAPACKE_cuncsd2by1_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cuncsd2by1_work", matrix_layout, jobu1, jobu2, jobv1t, m, p, q, x11, ldx11, x21, ldx21, theta, u1, ldu1, u2, ldu2, v1t, ldv1t, work, lwork, rwork, lrwork, iwork);
            }
            return (int)mh$.invokeExact(matrix_layout, jobu1, jobu2, jobv1t, m, p, q, x11, ldx11, x21, ldx21, theta, u1, ldu1, u2, ldu2, v1t, ldv1t, work, lwork, rwork, lrwork, iwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dbbcsd {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dbbcsd");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dbbcsd(int matrix_layout, char jobu1, char jobu2, char jobv1t, char jobv2t, char trans, int m, int p, int q, double *theta, double *phi, double *u1, int ldu1, double *u2, int ldu2, double *v1t, int ldv1t, double *v2t, int ldv2t, double *b11d, double *b11e, double *b12d, double *b12e, double *b21d, double *b21e, double *b22d, double *b22e)
     * }
     */
    public static FunctionDescriptor LAPACKE_dbbcsd$descriptor() {
        return LAPACKE_dbbcsd.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dbbcsd(int matrix_layout, char jobu1, char jobu2, char jobv1t, char jobv2t, char trans, int m, int p, int q, double *theta, double *phi, double *u1, int ldu1, double *u2, int ldu2, double *v1t, int ldv1t, double *v2t, int ldv2t, double *b11d, double *b11e, double *b12d, double *b12e, double *b21d, double *b21e, double *b22d, double *b22e)
     * }
     */
    public static MethodHandle LAPACKE_dbbcsd$handle() {
        return LAPACKE_dbbcsd.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dbbcsd(int matrix_layout, char jobu1, char jobu2, char jobv1t, char jobv2t, char trans, int m, int p, int q, double *theta, double *phi, double *u1, int ldu1, double *u2, int ldu2, double *v1t, int ldv1t, double *v2t, int ldv2t, double *b11d, double *b11e, double *b12d, double *b12e, double *b21d, double *b21e, double *b22d, double *b22e)
     * }
     */
    public static MemorySegment LAPACKE_dbbcsd$address() {
        return LAPACKE_dbbcsd.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dbbcsd(int matrix_layout, char jobu1, char jobu2, char jobv1t, char jobv2t, char trans, int m, int p, int q, double *theta, double *phi, double *u1, int ldu1, double *u2, int ldu2, double *v1t, int ldv1t, double *v2t, int ldv2t, double *b11d, double *b11e, double *b12d, double *b12e, double *b21d, double *b21e, double *b22d, double *b22e)
     * }
     */
    public static int LAPACKE_dbbcsd(int matrix_layout, byte jobu1, byte jobu2, byte jobv1t, byte jobv2t, byte trans, int m, int p, int q, MemorySegment theta, MemorySegment phi, MemorySegment u1, int ldu1, MemorySegment u2, int ldu2, MemorySegment v1t, int ldv1t, MemorySegment v2t, int ldv2t, MemorySegment b11d, MemorySegment b11e, MemorySegment b12d, MemorySegment b12e, MemorySegment b21d, MemorySegment b21e, MemorySegment b22d, MemorySegment b22e) {
        var mh$ = LAPACKE_dbbcsd.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dbbcsd", matrix_layout, jobu1, jobu2, jobv1t, jobv2t, trans, m, p, q, theta, phi, u1, ldu1, u2, ldu2, v1t, ldv1t, v2t, ldv2t, b11d, b11e, b12d, b12e, b21d, b21e, b22d, b22e);
            }
            return (int)mh$.invokeExact(matrix_layout, jobu1, jobu2, jobv1t, jobv2t, trans, m, p, q, theta, phi, u1, ldu1, u2, ldu2, v1t, ldv1t, v2t, ldv2t, b11d, b11e, b12d, b12e, b21d, b21e, b22d, b22e);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dbbcsd_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dbbcsd_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dbbcsd_work(int matrix_layout, char jobu1, char jobu2, char jobv1t, char jobv2t, char trans, int m, int p, int q, double *theta, double *phi, double *u1, int ldu1, double *u2, int ldu2, double *v1t, int ldv1t, double *v2t, int ldv2t, double *b11d, double *b11e, double *b12d, double *b12e, double *b21d, double *b21e, double *b22d, double *b22e, double *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_dbbcsd_work$descriptor() {
        return LAPACKE_dbbcsd_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dbbcsd_work(int matrix_layout, char jobu1, char jobu2, char jobv1t, char jobv2t, char trans, int m, int p, int q, double *theta, double *phi, double *u1, int ldu1, double *u2, int ldu2, double *v1t, int ldv1t, double *v2t, int ldv2t, double *b11d, double *b11e, double *b12d, double *b12e, double *b21d, double *b21e, double *b22d, double *b22e, double *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_dbbcsd_work$handle() {
        return LAPACKE_dbbcsd_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dbbcsd_work(int matrix_layout, char jobu1, char jobu2, char jobv1t, char jobv2t, char trans, int m, int p, int q, double *theta, double *phi, double *u1, int ldu1, double *u2, int ldu2, double *v1t, int ldv1t, double *v2t, int ldv2t, double *b11d, double *b11e, double *b12d, double *b12e, double *b21d, double *b21e, double *b22d, double *b22e, double *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_dbbcsd_work$address() {
        return LAPACKE_dbbcsd_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dbbcsd_work(int matrix_layout, char jobu1, char jobu2, char jobv1t, char jobv2t, char trans, int m, int p, int q, double *theta, double *phi, double *u1, int ldu1, double *u2, int ldu2, double *v1t, int ldv1t, double *v2t, int ldv2t, double *b11d, double *b11e, double *b12d, double *b12e, double *b21d, double *b21e, double *b22d, double *b22e, double *work, int lwork)
     * }
     */
    public static int LAPACKE_dbbcsd_work(int matrix_layout, byte jobu1, byte jobu2, byte jobv1t, byte jobv2t, byte trans, int m, int p, int q, MemorySegment theta, MemorySegment phi, MemorySegment u1, int ldu1, MemorySegment u2, int ldu2, MemorySegment v1t, int ldv1t, MemorySegment v2t, int ldv2t, MemorySegment b11d, MemorySegment b11e, MemorySegment b12d, MemorySegment b12e, MemorySegment b21d, MemorySegment b21e, MemorySegment b22d, MemorySegment b22e, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_dbbcsd_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dbbcsd_work", matrix_layout, jobu1, jobu2, jobv1t, jobv2t, trans, m, p, q, theta, phi, u1, ldu1, u2, ldu2, v1t, ldv1t, v2t, ldv2t, b11d, b11e, b12d, b12e, b21d, b21e, b22d, b22e, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, jobu1, jobu2, jobv1t, jobv2t, trans, m, p, q, theta, phi, u1, ldu1, u2, ldu2, v1t, ldv1t, v2t, ldv2t, b11d, b11e, b12d, b12e, b21d, b21e, b22d, b22e, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dorbdb {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dorbdb");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dorbdb(int matrix_layout, char trans, char signs, int m, int p, int q, double *x11, int ldx11, double *x12, int ldx12, double *x21, int ldx21, double *x22, int ldx22, double *theta, double *phi, double *taup1, double *taup2, double *tauq1, double *tauq2)
     * }
     */
    public static FunctionDescriptor LAPACKE_dorbdb$descriptor() {
        return LAPACKE_dorbdb.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dorbdb(int matrix_layout, char trans, char signs, int m, int p, int q, double *x11, int ldx11, double *x12, int ldx12, double *x21, int ldx21, double *x22, int ldx22, double *theta, double *phi, double *taup1, double *taup2, double *tauq1, double *tauq2)
     * }
     */
    public static MethodHandle LAPACKE_dorbdb$handle() {
        return LAPACKE_dorbdb.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dorbdb(int matrix_layout, char trans, char signs, int m, int p, int q, double *x11, int ldx11, double *x12, int ldx12, double *x21, int ldx21, double *x22, int ldx22, double *theta, double *phi, double *taup1, double *taup2, double *tauq1, double *tauq2)
     * }
     */
    public static MemorySegment LAPACKE_dorbdb$address() {
        return LAPACKE_dorbdb.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dorbdb(int matrix_layout, char trans, char signs, int m, int p, int q, double *x11, int ldx11, double *x12, int ldx12, double *x21, int ldx21, double *x22, int ldx22, double *theta, double *phi, double *taup1, double *taup2, double *tauq1, double *tauq2)
     * }
     */
    public static int LAPACKE_dorbdb(int matrix_layout, byte trans, byte signs, int m, int p, int q, MemorySegment x11, int ldx11, MemorySegment x12, int ldx12, MemorySegment x21, int ldx21, MemorySegment x22, int ldx22, MemorySegment theta, MemorySegment phi, MemorySegment taup1, MemorySegment taup2, MemorySegment tauq1, MemorySegment tauq2) {
        var mh$ = LAPACKE_dorbdb.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dorbdb", matrix_layout, trans, signs, m, p, q, x11, ldx11, x12, ldx12, x21, ldx21, x22, ldx22, theta, phi, taup1, taup2, tauq1, tauq2);
            }
            return (int)mh$.invokeExact(matrix_layout, trans, signs, m, p, q, x11, ldx11, x12, ldx12, x21, ldx21, x22, ldx22, theta, phi, taup1, taup2, tauq1, tauq2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dorbdb_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dorbdb_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dorbdb_work(int matrix_layout, char trans, char signs, int m, int p, int q, double *x11, int ldx11, double *x12, int ldx12, double *x21, int ldx21, double *x22, int ldx22, double *theta, double *phi, double *taup1, double *taup2, double *tauq1, double *tauq2, double *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_dorbdb_work$descriptor() {
        return LAPACKE_dorbdb_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dorbdb_work(int matrix_layout, char trans, char signs, int m, int p, int q, double *x11, int ldx11, double *x12, int ldx12, double *x21, int ldx21, double *x22, int ldx22, double *theta, double *phi, double *taup1, double *taup2, double *tauq1, double *tauq2, double *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_dorbdb_work$handle() {
        return LAPACKE_dorbdb_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dorbdb_work(int matrix_layout, char trans, char signs, int m, int p, int q, double *x11, int ldx11, double *x12, int ldx12, double *x21, int ldx21, double *x22, int ldx22, double *theta, double *phi, double *taup1, double *taup2, double *tauq1, double *tauq2, double *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_dorbdb_work$address() {
        return LAPACKE_dorbdb_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dorbdb_work(int matrix_layout, char trans, char signs, int m, int p, int q, double *x11, int ldx11, double *x12, int ldx12, double *x21, int ldx21, double *x22, int ldx22, double *theta, double *phi, double *taup1, double *taup2, double *tauq1, double *tauq2, double *work, int lwork)
     * }
     */
    public static int LAPACKE_dorbdb_work(int matrix_layout, byte trans, byte signs, int m, int p, int q, MemorySegment x11, int ldx11, MemorySegment x12, int ldx12, MemorySegment x21, int ldx21, MemorySegment x22, int ldx22, MemorySegment theta, MemorySegment phi, MemorySegment taup1, MemorySegment taup2, MemorySegment tauq1, MemorySegment tauq2, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_dorbdb_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dorbdb_work", matrix_layout, trans, signs, m, p, q, x11, ldx11, x12, ldx12, x21, ldx21, x22, ldx22, theta, phi, taup1, taup2, tauq1, tauq2, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, trans, signs, m, p, q, x11, ldx11, x12, ldx12, x21, ldx21, x22, ldx22, theta, phi, taup1, taup2, tauq1, tauq2, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dorcsd {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dorcsd");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dorcsd(int matrix_layout, char jobu1, char jobu2, char jobv1t, char jobv2t, char trans, char signs, int m, int p, int q, double *x11, int ldx11, double *x12, int ldx12, double *x21, int ldx21, double *x22, int ldx22, double *theta, double *u1, int ldu1, double *u2, int ldu2, double *v1t, int ldv1t, double *v2t, int ldv2t)
     * }
     */
    public static FunctionDescriptor LAPACKE_dorcsd$descriptor() {
        return LAPACKE_dorcsd.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dorcsd(int matrix_layout, char jobu1, char jobu2, char jobv1t, char jobv2t, char trans, char signs, int m, int p, int q, double *x11, int ldx11, double *x12, int ldx12, double *x21, int ldx21, double *x22, int ldx22, double *theta, double *u1, int ldu1, double *u2, int ldu2, double *v1t, int ldv1t, double *v2t, int ldv2t)
     * }
     */
    public static MethodHandle LAPACKE_dorcsd$handle() {
        return LAPACKE_dorcsd.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dorcsd(int matrix_layout, char jobu1, char jobu2, char jobv1t, char jobv2t, char trans, char signs, int m, int p, int q, double *x11, int ldx11, double *x12, int ldx12, double *x21, int ldx21, double *x22, int ldx22, double *theta, double *u1, int ldu1, double *u2, int ldu2, double *v1t, int ldv1t, double *v2t, int ldv2t)
     * }
     */
    public static MemorySegment LAPACKE_dorcsd$address() {
        return LAPACKE_dorcsd.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dorcsd(int matrix_layout, char jobu1, char jobu2, char jobv1t, char jobv2t, char trans, char signs, int m, int p, int q, double *x11, int ldx11, double *x12, int ldx12, double *x21, int ldx21, double *x22, int ldx22, double *theta, double *u1, int ldu1, double *u2, int ldu2, double *v1t, int ldv1t, double *v2t, int ldv2t)
     * }
     */
    public static int LAPACKE_dorcsd(int matrix_layout, byte jobu1, byte jobu2, byte jobv1t, byte jobv2t, byte trans, byte signs, int m, int p, int q, MemorySegment x11, int ldx11, MemorySegment x12, int ldx12, MemorySegment x21, int ldx21, MemorySegment x22, int ldx22, MemorySegment theta, MemorySegment u1, int ldu1, MemorySegment u2, int ldu2, MemorySegment v1t, int ldv1t, MemorySegment v2t, int ldv2t) {
        var mh$ = LAPACKE_dorcsd.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dorcsd", matrix_layout, jobu1, jobu2, jobv1t, jobv2t, trans, signs, m, p, q, x11, ldx11, x12, ldx12, x21, ldx21, x22, ldx22, theta, u1, ldu1, u2, ldu2, v1t, ldv1t, v2t, ldv2t);
            }
            return (int)mh$.invokeExact(matrix_layout, jobu1, jobu2, jobv1t, jobv2t, trans, signs, m, p, q, x11, ldx11, x12, ldx12, x21, ldx21, x22, ldx22, theta, u1, ldu1, u2, ldu2, v1t, ldv1t, v2t, ldv2t);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dorcsd_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dorcsd_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dorcsd_work(int matrix_layout, char jobu1, char jobu2, char jobv1t, char jobv2t, char trans, char signs, int m, int p, int q, double *x11, int ldx11, double *x12, int ldx12, double *x21, int ldx21, double *x22, int ldx22, double *theta, double *u1, int ldu1, double *u2, int ldu2, double *v1t, int ldv1t, double *v2t, int ldv2t, double *work, int lwork, int *iwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_dorcsd_work$descriptor() {
        return LAPACKE_dorcsd_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dorcsd_work(int matrix_layout, char jobu1, char jobu2, char jobv1t, char jobv2t, char trans, char signs, int m, int p, int q, double *x11, int ldx11, double *x12, int ldx12, double *x21, int ldx21, double *x22, int ldx22, double *theta, double *u1, int ldu1, double *u2, int ldu2, double *v1t, int ldv1t, double *v2t, int ldv2t, double *work, int lwork, int *iwork)
     * }
     */
    public static MethodHandle LAPACKE_dorcsd_work$handle() {
        return LAPACKE_dorcsd_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dorcsd_work(int matrix_layout, char jobu1, char jobu2, char jobv1t, char jobv2t, char trans, char signs, int m, int p, int q, double *x11, int ldx11, double *x12, int ldx12, double *x21, int ldx21, double *x22, int ldx22, double *theta, double *u1, int ldu1, double *u2, int ldu2, double *v1t, int ldv1t, double *v2t, int ldv2t, double *work, int lwork, int *iwork)
     * }
     */
    public static MemorySegment LAPACKE_dorcsd_work$address() {
        return LAPACKE_dorcsd_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dorcsd_work(int matrix_layout, char jobu1, char jobu2, char jobv1t, char jobv2t, char trans, char signs, int m, int p, int q, double *x11, int ldx11, double *x12, int ldx12, double *x21, int ldx21, double *x22, int ldx22, double *theta, double *u1, int ldu1, double *u2, int ldu2, double *v1t, int ldv1t, double *v2t, int ldv2t, double *work, int lwork, int *iwork)
     * }
     */
    public static int LAPACKE_dorcsd_work(int matrix_layout, byte jobu1, byte jobu2, byte jobv1t, byte jobv2t, byte trans, byte signs, int m, int p, int q, MemorySegment x11, int ldx11, MemorySegment x12, int ldx12, MemorySegment x21, int ldx21, MemorySegment x22, int ldx22, MemorySegment theta, MemorySegment u1, int ldu1, MemorySegment u2, int ldu2, MemorySegment v1t, int ldv1t, MemorySegment v2t, int ldv2t, MemorySegment work, int lwork, MemorySegment iwork) {
        var mh$ = LAPACKE_dorcsd_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dorcsd_work", matrix_layout, jobu1, jobu2, jobv1t, jobv2t, trans, signs, m, p, q, x11, ldx11, x12, ldx12, x21, ldx21, x22, ldx22, theta, u1, ldu1, u2, ldu2, v1t, ldv1t, v2t, ldv2t, work, lwork, iwork);
            }
            return (int)mh$.invokeExact(matrix_layout, jobu1, jobu2, jobv1t, jobv2t, trans, signs, m, p, q, x11, ldx11, x12, ldx12, x21, ldx21, x22, ldx22, theta, u1, ldu1, u2, ldu2, v1t, ldv1t, v2t, ldv2t, work, lwork, iwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dorcsd2by1 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dorcsd2by1");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dorcsd2by1(int matrix_layout, char jobu1, char jobu2, char jobv1t, int m, int p, int q, double *x11, int ldx11, double *x21, int ldx21, double *theta, double *u1, int ldu1, double *u2, int ldu2, double *v1t, int ldv1t)
     * }
     */
    public static FunctionDescriptor LAPACKE_dorcsd2by1$descriptor() {
        return LAPACKE_dorcsd2by1.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dorcsd2by1(int matrix_layout, char jobu1, char jobu2, char jobv1t, int m, int p, int q, double *x11, int ldx11, double *x21, int ldx21, double *theta, double *u1, int ldu1, double *u2, int ldu2, double *v1t, int ldv1t)
     * }
     */
    public static MethodHandle LAPACKE_dorcsd2by1$handle() {
        return LAPACKE_dorcsd2by1.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dorcsd2by1(int matrix_layout, char jobu1, char jobu2, char jobv1t, int m, int p, int q, double *x11, int ldx11, double *x21, int ldx21, double *theta, double *u1, int ldu1, double *u2, int ldu2, double *v1t, int ldv1t)
     * }
     */
    public static MemorySegment LAPACKE_dorcsd2by1$address() {
        return LAPACKE_dorcsd2by1.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dorcsd2by1(int matrix_layout, char jobu1, char jobu2, char jobv1t, int m, int p, int q, double *x11, int ldx11, double *x21, int ldx21, double *theta, double *u1, int ldu1, double *u2, int ldu2, double *v1t, int ldv1t)
     * }
     */
    public static int LAPACKE_dorcsd2by1(int matrix_layout, byte jobu1, byte jobu2, byte jobv1t, int m, int p, int q, MemorySegment x11, int ldx11, MemorySegment x21, int ldx21, MemorySegment theta, MemorySegment u1, int ldu1, MemorySegment u2, int ldu2, MemorySegment v1t, int ldv1t) {
        var mh$ = LAPACKE_dorcsd2by1.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dorcsd2by1", matrix_layout, jobu1, jobu2, jobv1t, m, p, q, x11, ldx11, x21, ldx21, theta, u1, ldu1, u2, ldu2, v1t, ldv1t);
            }
            return (int)mh$.invokeExact(matrix_layout, jobu1, jobu2, jobv1t, m, p, q, x11, ldx11, x21, ldx21, theta, u1, ldu1, u2, ldu2, v1t, ldv1t);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dorcsd2by1_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dorcsd2by1_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dorcsd2by1_work(int matrix_layout, char jobu1, char jobu2, char jobv1t, int m, int p, int q, double *x11, int ldx11, double *x21, int ldx21, double *theta, double *u1, int ldu1, double *u2, int ldu2, double *v1t, int ldv1t, double *work, int lwork, int *iwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_dorcsd2by1_work$descriptor() {
        return LAPACKE_dorcsd2by1_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dorcsd2by1_work(int matrix_layout, char jobu1, char jobu2, char jobv1t, int m, int p, int q, double *x11, int ldx11, double *x21, int ldx21, double *theta, double *u1, int ldu1, double *u2, int ldu2, double *v1t, int ldv1t, double *work, int lwork, int *iwork)
     * }
     */
    public static MethodHandle LAPACKE_dorcsd2by1_work$handle() {
        return LAPACKE_dorcsd2by1_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dorcsd2by1_work(int matrix_layout, char jobu1, char jobu2, char jobv1t, int m, int p, int q, double *x11, int ldx11, double *x21, int ldx21, double *theta, double *u1, int ldu1, double *u2, int ldu2, double *v1t, int ldv1t, double *work, int lwork, int *iwork)
     * }
     */
    public static MemorySegment LAPACKE_dorcsd2by1_work$address() {
        return LAPACKE_dorcsd2by1_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dorcsd2by1_work(int matrix_layout, char jobu1, char jobu2, char jobv1t, int m, int p, int q, double *x11, int ldx11, double *x21, int ldx21, double *theta, double *u1, int ldu1, double *u2, int ldu2, double *v1t, int ldv1t, double *work, int lwork, int *iwork)
     * }
     */
    public static int LAPACKE_dorcsd2by1_work(int matrix_layout, byte jobu1, byte jobu2, byte jobv1t, int m, int p, int q, MemorySegment x11, int ldx11, MemorySegment x21, int ldx21, MemorySegment theta, MemorySegment u1, int ldu1, MemorySegment u2, int ldu2, MemorySegment v1t, int ldv1t, MemorySegment work, int lwork, MemorySegment iwork) {
        var mh$ = LAPACKE_dorcsd2by1_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dorcsd2by1_work", matrix_layout, jobu1, jobu2, jobv1t, m, p, q, x11, ldx11, x21, ldx21, theta, u1, ldu1, u2, ldu2, v1t, ldv1t, work, lwork, iwork);
            }
            return (int)mh$.invokeExact(matrix_layout, jobu1, jobu2, jobv1t, m, p, q, x11, ldx11, x21, ldx21, theta, u1, ldu1, u2, ldu2, v1t, ldv1t, work, lwork, iwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dsyconv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dsyconv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dsyconv(int matrix_layout, char uplo, char way, int n, double *a, int lda, const int *ipiv, double *e)
     * }
     */
    public static FunctionDescriptor LAPACKE_dsyconv$descriptor() {
        return LAPACKE_dsyconv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dsyconv(int matrix_layout, char uplo, char way, int n, double *a, int lda, const int *ipiv, double *e)
     * }
     */
    public static MethodHandle LAPACKE_dsyconv$handle() {
        return LAPACKE_dsyconv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dsyconv(int matrix_layout, char uplo, char way, int n, double *a, int lda, const int *ipiv, double *e)
     * }
     */
    public static MemorySegment LAPACKE_dsyconv$address() {
        return LAPACKE_dsyconv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dsyconv(int matrix_layout, char uplo, char way, int n, double *a, int lda, const int *ipiv, double *e)
     * }
     */
    public static int LAPACKE_dsyconv(int matrix_layout, byte uplo, byte way, int n, MemorySegment a, int lda, MemorySegment ipiv, MemorySegment e) {
        var mh$ = LAPACKE_dsyconv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dsyconv", matrix_layout, uplo, way, n, a, lda, ipiv, e);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, way, n, a, lda, ipiv, e);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dsyconv_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dsyconv_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dsyconv_work(int matrix_layout, char uplo, char way, int n, double *a, int lda, const int *ipiv, double *e)
     * }
     */
    public static FunctionDescriptor LAPACKE_dsyconv_work$descriptor() {
        return LAPACKE_dsyconv_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dsyconv_work(int matrix_layout, char uplo, char way, int n, double *a, int lda, const int *ipiv, double *e)
     * }
     */
    public static MethodHandle LAPACKE_dsyconv_work$handle() {
        return LAPACKE_dsyconv_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dsyconv_work(int matrix_layout, char uplo, char way, int n, double *a, int lda, const int *ipiv, double *e)
     * }
     */
    public static MemorySegment LAPACKE_dsyconv_work$address() {
        return LAPACKE_dsyconv_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dsyconv_work(int matrix_layout, char uplo, char way, int n, double *a, int lda, const int *ipiv, double *e)
     * }
     */
    public static int LAPACKE_dsyconv_work(int matrix_layout, byte uplo, byte way, int n, MemorySegment a, int lda, MemorySegment ipiv, MemorySegment e) {
        var mh$ = LAPACKE_dsyconv_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dsyconv_work", matrix_layout, uplo, way, n, a, lda, ipiv, e);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, way, n, a, lda, ipiv, e);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dsyswapr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dsyswapr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dsyswapr(int matrix_layout, char uplo, int n, double *a, int lda, int i1, int i2)
     * }
     */
    public static FunctionDescriptor LAPACKE_dsyswapr$descriptor() {
        return LAPACKE_dsyswapr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dsyswapr(int matrix_layout, char uplo, int n, double *a, int lda, int i1, int i2)
     * }
     */
    public static MethodHandle LAPACKE_dsyswapr$handle() {
        return LAPACKE_dsyswapr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dsyswapr(int matrix_layout, char uplo, int n, double *a, int lda, int i1, int i2)
     * }
     */
    public static MemorySegment LAPACKE_dsyswapr$address() {
        return LAPACKE_dsyswapr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dsyswapr(int matrix_layout, char uplo, int n, double *a, int lda, int i1, int i2)
     * }
     */
    public static int LAPACKE_dsyswapr(int matrix_layout, byte uplo, int n, MemorySegment a, int lda, int i1, int i2) {
        var mh$ = LAPACKE_dsyswapr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dsyswapr", matrix_layout, uplo, n, a, lda, i1, i2);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, a, lda, i1, i2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dsyswapr_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dsyswapr_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dsyswapr_work(int matrix_layout, char uplo, int n, double *a, int lda, int i1, int i2)
     * }
     */
    public static FunctionDescriptor LAPACKE_dsyswapr_work$descriptor() {
        return LAPACKE_dsyswapr_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dsyswapr_work(int matrix_layout, char uplo, int n, double *a, int lda, int i1, int i2)
     * }
     */
    public static MethodHandle LAPACKE_dsyswapr_work$handle() {
        return LAPACKE_dsyswapr_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dsyswapr_work(int matrix_layout, char uplo, int n, double *a, int lda, int i1, int i2)
     * }
     */
    public static MemorySegment LAPACKE_dsyswapr_work$address() {
        return LAPACKE_dsyswapr_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dsyswapr_work(int matrix_layout, char uplo, int n, double *a, int lda, int i1, int i2)
     * }
     */
    public static int LAPACKE_dsyswapr_work(int matrix_layout, byte uplo, int n, MemorySegment a, int lda, int i1, int i2) {
        var mh$ = LAPACKE_dsyswapr_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dsyswapr_work", matrix_layout, uplo, n, a, lda, i1, i2);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, a, lda, i1, i2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dsytri2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dsytri2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dsytri2(int matrix_layout, char uplo, int n, double *a, int lda, const int *ipiv)
     * }
     */
    public static FunctionDescriptor LAPACKE_dsytri2$descriptor() {
        return LAPACKE_dsytri2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dsytri2(int matrix_layout, char uplo, int n, double *a, int lda, const int *ipiv)
     * }
     */
    public static MethodHandle LAPACKE_dsytri2$handle() {
        return LAPACKE_dsytri2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dsytri2(int matrix_layout, char uplo, int n, double *a, int lda, const int *ipiv)
     * }
     */
    public static MemorySegment LAPACKE_dsytri2$address() {
        return LAPACKE_dsytri2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dsytri2(int matrix_layout, char uplo, int n, double *a, int lda, const int *ipiv)
     * }
     */
    public static int LAPACKE_dsytri2(int matrix_layout, byte uplo, int n, MemorySegment a, int lda, MemorySegment ipiv) {
        var mh$ = LAPACKE_dsytri2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dsytri2", matrix_layout, uplo, n, a, lda, ipiv);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, a, lda, ipiv);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dsytri2_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dsytri2_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dsytri2_work(int matrix_layout, char uplo, int n, double *a, int lda, const int *ipiv, double *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_dsytri2_work$descriptor() {
        return LAPACKE_dsytri2_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dsytri2_work(int matrix_layout, char uplo, int n, double *a, int lda, const int *ipiv, double *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_dsytri2_work$handle() {
        return LAPACKE_dsytri2_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dsytri2_work(int matrix_layout, char uplo, int n, double *a, int lda, const int *ipiv, double *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_dsytri2_work$address() {
        return LAPACKE_dsytri2_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dsytri2_work(int matrix_layout, char uplo, int n, double *a, int lda, const int *ipiv, double *work, int lwork)
     * }
     */
    public static int LAPACKE_dsytri2_work(int matrix_layout, byte uplo, int n, MemorySegment a, int lda, MemorySegment ipiv, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_dsytri2_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dsytri2_work", matrix_layout, uplo, n, a, lda, ipiv, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, a, lda, ipiv, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dsytri2x {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dsytri2x");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dsytri2x(int matrix_layout, char uplo, int n, double *a, int lda, const int *ipiv, int nb)
     * }
     */
    public static FunctionDescriptor LAPACKE_dsytri2x$descriptor() {
        return LAPACKE_dsytri2x.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dsytri2x(int matrix_layout, char uplo, int n, double *a, int lda, const int *ipiv, int nb)
     * }
     */
    public static MethodHandle LAPACKE_dsytri2x$handle() {
        return LAPACKE_dsytri2x.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dsytri2x(int matrix_layout, char uplo, int n, double *a, int lda, const int *ipiv, int nb)
     * }
     */
    public static MemorySegment LAPACKE_dsytri2x$address() {
        return LAPACKE_dsytri2x.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dsytri2x(int matrix_layout, char uplo, int n, double *a, int lda, const int *ipiv, int nb)
     * }
     */
    public static int LAPACKE_dsytri2x(int matrix_layout, byte uplo, int n, MemorySegment a, int lda, MemorySegment ipiv, int nb) {
        var mh$ = LAPACKE_dsytri2x.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dsytri2x", matrix_layout, uplo, n, a, lda, ipiv, nb);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, a, lda, ipiv, nb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dsytri2x_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dsytri2x_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dsytri2x_work(int matrix_layout, char uplo, int n, double *a, int lda, const int *ipiv, double *work, int nb)
     * }
     */
    public static FunctionDescriptor LAPACKE_dsytri2x_work$descriptor() {
        return LAPACKE_dsytri2x_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dsytri2x_work(int matrix_layout, char uplo, int n, double *a, int lda, const int *ipiv, double *work, int nb)
     * }
     */
    public static MethodHandle LAPACKE_dsytri2x_work$handle() {
        return LAPACKE_dsytri2x_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dsytri2x_work(int matrix_layout, char uplo, int n, double *a, int lda, const int *ipiv, double *work, int nb)
     * }
     */
    public static MemorySegment LAPACKE_dsytri2x_work$address() {
        return LAPACKE_dsytri2x_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dsytri2x_work(int matrix_layout, char uplo, int n, double *a, int lda, const int *ipiv, double *work, int nb)
     * }
     */
    public static int LAPACKE_dsytri2x_work(int matrix_layout, byte uplo, int n, MemorySegment a, int lda, MemorySegment ipiv, MemorySegment work, int nb) {
        var mh$ = LAPACKE_dsytri2x_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dsytri2x_work", matrix_layout, uplo, n, a, lda, ipiv, work, nb);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, a, lda, ipiv, work, nb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dsytrs2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dsytrs2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dsytrs2(int matrix_layout, char uplo, int n, int nrhs, const double *a, int lda, const int *ipiv, double *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_dsytrs2$descriptor() {
        return LAPACKE_dsytrs2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dsytrs2(int matrix_layout, char uplo, int n, int nrhs, const double *a, int lda, const int *ipiv, double *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_dsytrs2$handle() {
        return LAPACKE_dsytrs2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dsytrs2(int matrix_layout, char uplo, int n, int nrhs, const double *a, int lda, const int *ipiv, double *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_dsytrs2$address() {
        return LAPACKE_dsytrs2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dsytrs2(int matrix_layout, char uplo, int n, int nrhs, const double *a, int lda, const int *ipiv, double *b, int ldb)
     * }
     */
    public static int LAPACKE_dsytrs2(int matrix_layout, byte uplo, int n, int nrhs, MemorySegment a, int lda, MemorySegment ipiv, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_dsytrs2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dsytrs2", matrix_layout, uplo, n, nrhs, a, lda, ipiv, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, nrhs, a, lda, ipiv, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dsytrs2_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dsytrs2_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dsytrs2_work(int matrix_layout, char uplo, int n, int nrhs, const double *a, int lda, const int *ipiv, double *b, int ldb, double *work)
     * }
     */
    public static FunctionDescriptor LAPACKE_dsytrs2_work$descriptor() {
        return LAPACKE_dsytrs2_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dsytrs2_work(int matrix_layout, char uplo, int n, int nrhs, const double *a, int lda, const int *ipiv, double *b, int ldb, double *work)
     * }
     */
    public static MethodHandle LAPACKE_dsytrs2_work$handle() {
        return LAPACKE_dsytrs2_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dsytrs2_work(int matrix_layout, char uplo, int n, int nrhs, const double *a, int lda, const int *ipiv, double *b, int ldb, double *work)
     * }
     */
    public static MemorySegment LAPACKE_dsytrs2_work$address() {
        return LAPACKE_dsytrs2_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dsytrs2_work(int matrix_layout, char uplo, int n, int nrhs, const double *a, int lda, const int *ipiv, double *b, int ldb, double *work)
     * }
     */
    public static int LAPACKE_dsytrs2_work(int matrix_layout, byte uplo, int n, int nrhs, MemorySegment a, int lda, MemorySegment ipiv, MemorySegment b, int ldb, MemorySegment work) {
        var mh$ = LAPACKE_dsytrs2_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dsytrs2_work", matrix_layout, uplo, n, nrhs, a, lda, ipiv, b, ldb, work);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, nrhs, a, lda, ipiv, b, ldb, work);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sbbcsd {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_sbbcsd");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sbbcsd(int matrix_layout, char jobu1, char jobu2, char jobv1t, char jobv2t, char trans, int m, int p, int q, float *theta, float *phi, float *u1, int ldu1, float *u2, int ldu2, float *v1t, int ldv1t, float *v2t, int ldv2t, float *b11d, float *b11e, float *b12d, float *b12e, float *b21d, float *b21e, float *b22d, float *b22e)
     * }
     */
    public static FunctionDescriptor LAPACKE_sbbcsd$descriptor() {
        return LAPACKE_sbbcsd.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sbbcsd(int matrix_layout, char jobu1, char jobu2, char jobv1t, char jobv2t, char trans, int m, int p, int q, float *theta, float *phi, float *u1, int ldu1, float *u2, int ldu2, float *v1t, int ldv1t, float *v2t, int ldv2t, float *b11d, float *b11e, float *b12d, float *b12e, float *b21d, float *b21e, float *b22d, float *b22e)
     * }
     */
    public static MethodHandle LAPACKE_sbbcsd$handle() {
        return LAPACKE_sbbcsd.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sbbcsd(int matrix_layout, char jobu1, char jobu2, char jobv1t, char jobv2t, char trans, int m, int p, int q, float *theta, float *phi, float *u1, int ldu1, float *u2, int ldu2, float *v1t, int ldv1t, float *v2t, int ldv2t, float *b11d, float *b11e, float *b12d, float *b12e, float *b21d, float *b21e, float *b22d, float *b22e)
     * }
     */
    public static MemorySegment LAPACKE_sbbcsd$address() {
        return LAPACKE_sbbcsd.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sbbcsd(int matrix_layout, char jobu1, char jobu2, char jobv1t, char jobv2t, char trans, int m, int p, int q, float *theta, float *phi, float *u1, int ldu1, float *u2, int ldu2, float *v1t, int ldv1t, float *v2t, int ldv2t, float *b11d, float *b11e, float *b12d, float *b12e, float *b21d, float *b21e, float *b22d, float *b22e)
     * }
     */
    public static int LAPACKE_sbbcsd(int matrix_layout, byte jobu1, byte jobu2, byte jobv1t, byte jobv2t, byte trans, int m, int p, int q, MemorySegment theta, MemorySegment phi, MemorySegment u1, int ldu1, MemorySegment u2, int ldu2, MemorySegment v1t, int ldv1t, MemorySegment v2t, int ldv2t, MemorySegment b11d, MemorySegment b11e, MemorySegment b12d, MemorySegment b12e, MemorySegment b21d, MemorySegment b21e, MemorySegment b22d, MemorySegment b22e) {
        var mh$ = LAPACKE_sbbcsd.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sbbcsd", matrix_layout, jobu1, jobu2, jobv1t, jobv2t, trans, m, p, q, theta, phi, u1, ldu1, u2, ldu2, v1t, ldv1t, v2t, ldv2t, b11d, b11e, b12d, b12e, b21d, b21e, b22d, b22e);
            }
            return (int)mh$.invokeExact(matrix_layout, jobu1, jobu2, jobv1t, jobv2t, trans, m, p, q, theta, phi, u1, ldu1, u2, ldu2, v1t, ldv1t, v2t, ldv2t, b11d, b11e, b12d, b12e, b21d, b21e, b22d, b22e);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sbbcsd_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_sbbcsd_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sbbcsd_work(int matrix_layout, char jobu1, char jobu2, char jobv1t, char jobv2t, char trans, int m, int p, int q, float *theta, float *phi, float *u1, int ldu1, float *u2, int ldu2, float *v1t, int ldv1t, float *v2t, int ldv2t, float *b11d, float *b11e, float *b12d, float *b12e, float *b21d, float *b21e, float *b22d, float *b22e, float *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_sbbcsd_work$descriptor() {
        return LAPACKE_sbbcsd_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sbbcsd_work(int matrix_layout, char jobu1, char jobu2, char jobv1t, char jobv2t, char trans, int m, int p, int q, float *theta, float *phi, float *u1, int ldu1, float *u2, int ldu2, float *v1t, int ldv1t, float *v2t, int ldv2t, float *b11d, float *b11e, float *b12d, float *b12e, float *b21d, float *b21e, float *b22d, float *b22e, float *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_sbbcsd_work$handle() {
        return LAPACKE_sbbcsd_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sbbcsd_work(int matrix_layout, char jobu1, char jobu2, char jobv1t, char jobv2t, char trans, int m, int p, int q, float *theta, float *phi, float *u1, int ldu1, float *u2, int ldu2, float *v1t, int ldv1t, float *v2t, int ldv2t, float *b11d, float *b11e, float *b12d, float *b12e, float *b21d, float *b21e, float *b22d, float *b22e, float *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_sbbcsd_work$address() {
        return LAPACKE_sbbcsd_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sbbcsd_work(int matrix_layout, char jobu1, char jobu2, char jobv1t, char jobv2t, char trans, int m, int p, int q, float *theta, float *phi, float *u1, int ldu1, float *u2, int ldu2, float *v1t, int ldv1t, float *v2t, int ldv2t, float *b11d, float *b11e, float *b12d, float *b12e, float *b21d, float *b21e, float *b22d, float *b22e, float *work, int lwork)
     * }
     */
    public static int LAPACKE_sbbcsd_work(int matrix_layout, byte jobu1, byte jobu2, byte jobv1t, byte jobv2t, byte trans, int m, int p, int q, MemorySegment theta, MemorySegment phi, MemorySegment u1, int ldu1, MemorySegment u2, int ldu2, MemorySegment v1t, int ldv1t, MemorySegment v2t, int ldv2t, MemorySegment b11d, MemorySegment b11e, MemorySegment b12d, MemorySegment b12e, MemorySegment b21d, MemorySegment b21e, MemorySegment b22d, MemorySegment b22e, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_sbbcsd_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sbbcsd_work", matrix_layout, jobu1, jobu2, jobv1t, jobv2t, trans, m, p, q, theta, phi, u1, ldu1, u2, ldu2, v1t, ldv1t, v2t, ldv2t, b11d, b11e, b12d, b12e, b21d, b21e, b22d, b22e, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, jobu1, jobu2, jobv1t, jobv2t, trans, m, p, q, theta, phi, u1, ldu1, u2, ldu2, v1t, ldv1t, v2t, ldv2t, b11d, b11e, b12d, b12e, b21d, b21e, b22d, b22e, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sorbdb {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_sorbdb");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sorbdb(int matrix_layout, char trans, char signs, int m, int p, int q, float *x11, int ldx11, float *x12, int ldx12, float *x21, int ldx21, float *x22, int ldx22, float *theta, float *phi, float *taup1, float *taup2, float *tauq1, float *tauq2)
     * }
     */
    public static FunctionDescriptor LAPACKE_sorbdb$descriptor() {
        return LAPACKE_sorbdb.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sorbdb(int matrix_layout, char trans, char signs, int m, int p, int q, float *x11, int ldx11, float *x12, int ldx12, float *x21, int ldx21, float *x22, int ldx22, float *theta, float *phi, float *taup1, float *taup2, float *tauq1, float *tauq2)
     * }
     */
    public static MethodHandle LAPACKE_sorbdb$handle() {
        return LAPACKE_sorbdb.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sorbdb(int matrix_layout, char trans, char signs, int m, int p, int q, float *x11, int ldx11, float *x12, int ldx12, float *x21, int ldx21, float *x22, int ldx22, float *theta, float *phi, float *taup1, float *taup2, float *tauq1, float *tauq2)
     * }
     */
    public static MemorySegment LAPACKE_sorbdb$address() {
        return LAPACKE_sorbdb.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sorbdb(int matrix_layout, char trans, char signs, int m, int p, int q, float *x11, int ldx11, float *x12, int ldx12, float *x21, int ldx21, float *x22, int ldx22, float *theta, float *phi, float *taup1, float *taup2, float *tauq1, float *tauq2)
     * }
     */
    public static int LAPACKE_sorbdb(int matrix_layout, byte trans, byte signs, int m, int p, int q, MemorySegment x11, int ldx11, MemorySegment x12, int ldx12, MemorySegment x21, int ldx21, MemorySegment x22, int ldx22, MemorySegment theta, MemorySegment phi, MemorySegment taup1, MemorySegment taup2, MemorySegment tauq1, MemorySegment tauq2) {
        var mh$ = LAPACKE_sorbdb.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sorbdb", matrix_layout, trans, signs, m, p, q, x11, ldx11, x12, ldx12, x21, ldx21, x22, ldx22, theta, phi, taup1, taup2, tauq1, tauq2);
            }
            return (int)mh$.invokeExact(matrix_layout, trans, signs, m, p, q, x11, ldx11, x12, ldx12, x21, ldx21, x22, ldx22, theta, phi, taup1, taup2, tauq1, tauq2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sorbdb_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_sorbdb_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sorbdb_work(int matrix_layout, char trans, char signs, int m, int p, int q, float *x11, int ldx11, float *x12, int ldx12, float *x21, int ldx21, float *x22, int ldx22, float *theta, float *phi, float *taup1, float *taup2, float *tauq1, float *tauq2, float *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_sorbdb_work$descriptor() {
        return LAPACKE_sorbdb_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sorbdb_work(int matrix_layout, char trans, char signs, int m, int p, int q, float *x11, int ldx11, float *x12, int ldx12, float *x21, int ldx21, float *x22, int ldx22, float *theta, float *phi, float *taup1, float *taup2, float *tauq1, float *tauq2, float *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_sorbdb_work$handle() {
        return LAPACKE_sorbdb_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sorbdb_work(int matrix_layout, char trans, char signs, int m, int p, int q, float *x11, int ldx11, float *x12, int ldx12, float *x21, int ldx21, float *x22, int ldx22, float *theta, float *phi, float *taup1, float *taup2, float *tauq1, float *tauq2, float *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_sorbdb_work$address() {
        return LAPACKE_sorbdb_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sorbdb_work(int matrix_layout, char trans, char signs, int m, int p, int q, float *x11, int ldx11, float *x12, int ldx12, float *x21, int ldx21, float *x22, int ldx22, float *theta, float *phi, float *taup1, float *taup2, float *tauq1, float *tauq2, float *work, int lwork)
     * }
     */
    public static int LAPACKE_sorbdb_work(int matrix_layout, byte trans, byte signs, int m, int p, int q, MemorySegment x11, int ldx11, MemorySegment x12, int ldx12, MemorySegment x21, int ldx21, MemorySegment x22, int ldx22, MemorySegment theta, MemorySegment phi, MemorySegment taup1, MemorySegment taup2, MemorySegment tauq1, MemorySegment tauq2, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_sorbdb_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sorbdb_work", matrix_layout, trans, signs, m, p, q, x11, ldx11, x12, ldx12, x21, ldx21, x22, ldx22, theta, phi, taup1, taup2, tauq1, tauq2, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, trans, signs, m, p, q, x11, ldx11, x12, ldx12, x21, ldx21, x22, ldx22, theta, phi, taup1, taup2, tauq1, tauq2, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sorcsd {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_sorcsd");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sorcsd(int matrix_layout, char jobu1, char jobu2, char jobv1t, char jobv2t, char trans, char signs, int m, int p, int q, float *x11, int ldx11, float *x12, int ldx12, float *x21, int ldx21, float *x22, int ldx22, float *theta, float *u1, int ldu1, float *u2, int ldu2, float *v1t, int ldv1t, float *v2t, int ldv2t)
     * }
     */
    public static FunctionDescriptor LAPACKE_sorcsd$descriptor() {
        return LAPACKE_sorcsd.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sorcsd(int matrix_layout, char jobu1, char jobu2, char jobv1t, char jobv2t, char trans, char signs, int m, int p, int q, float *x11, int ldx11, float *x12, int ldx12, float *x21, int ldx21, float *x22, int ldx22, float *theta, float *u1, int ldu1, float *u2, int ldu2, float *v1t, int ldv1t, float *v2t, int ldv2t)
     * }
     */
    public static MethodHandle LAPACKE_sorcsd$handle() {
        return LAPACKE_sorcsd.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sorcsd(int matrix_layout, char jobu1, char jobu2, char jobv1t, char jobv2t, char trans, char signs, int m, int p, int q, float *x11, int ldx11, float *x12, int ldx12, float *x21, int ldx21, float *x22, int ldx22, float *theta, float *u1, int ldu1, float *u2, int ldu2, float *v1t, int ldv1t, float *v2t, int ldv2t)
     * }
     */
    public static MemorySegment LAPACKE_sorcsd$address() {
        return LAPACKE_sorcsd.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sorcsd(int matrix_layout, char jobu1, char jobu2, char jobv1t, char jobv2t, char trans, char signs, int m, int p, int q, float *x11, int ldx11, float *x12, int ldx12, float *x21, int ldx21, float *x22, int ldx22, float *theta, float *u1, int ldu1, float *u2, int ldu2, float *v1t, int ldv1t, float *v2t, int ldv2t)
     * }
     */
    public static int LAPACKE_sorcsd(int matrix_layout, byte jobu1, byte jobu2, byte jobv1t, byte jobv2t, byte trans, byte signs, int m, int p, int q, MemorySegment x11, int ldx11, MemorySegment x12, int ldx12, MemorySegment x21, int ldx21, MemorySegment x22, int ldx22, MemorySegment theta, MemorySegment u1, int ldu1, MemorySegment u2, int ldu2, MemorySegment v1t, int ldv1t, MemorySegment v2t, int ldv2t) {
        var mh$ = LAPACKE_sorcsd.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sorcsd", matrix_layout, jobu1, jobu2, jobv1t, jobv2t, trans, signs, m, p, q, x11, ldx11, x12, ldx12, x21, ldx21, x22, ldx22, theta, u1, ldu1, u2, ldu2, v1t, ldv1t, v2t, ldv2t);
            }
            return (int)mh$.invokeExact(matrix_layout, jobu1, jobu2, jobv1t, jobv2t, trans, signs, m, p, q, x11, ldx11, x12, ldx12, x21, ldx21, x22, ldx22, theta, u1, ldu1, u2, ldu2, v1t, ldv1t, v2t, ldv2t);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sorcsd_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_sorcsd_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sorcsd_work(int matrix_layout, char jobu1, char jobu2, char jobv1t, char jobv2t, char trans, char signs, int m, int p, int q, float *x11, int ldx11, float *x12, int ldx12, float *x21, int ldx21, float *x22, int ldx22, float *theta, float *u1, int ldu1, float *u2, int ldu2, float *v1t, int ldv1t, float *v2t, int ldv2t, float *work, int lwork, int *iwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_sorcsd_work$descriptor() {
        return LAPACKE_sorcsd_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sorcsd_work(int matrix_layout, char jobu1, char jobu2, char jobv1t, char jobv2t, char trans, char signs, int m, int p, int q, float *x11, int ldx11, float *x12, int ldx12, float *x21, int ldx21, float *x22, int ldx22, float *theta, float *u1, int ldu1, float *u2, int ldu2, float *v1t, int ldv1t, float *v2t, int ldv2t, float *work, int lwork, int *iwork)
     * }
     */
    public static MethodHandle LAPACKE_sorcsd_work$handle() {
        return LAPACKE_sorcsd_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sorcsd_work(int matrix_layout, char jobu1, char jobu2, char jobv1t, char jobv2t, char trans, char signs, int m, int p, int q, float *x11, int ldx11, float *x12, int ldx12, float *x21, int ldx21, float *x22, int ldx22, float *theta, float *u1, int ldu1, float *u2, int ldu2, float *v1t, int ldv1t, float *v2t, int ldv2t, float *work, int lwork, int *iwork)
     * }
     */
    public static MemorySegment LAPACKE_sorcsd_work$address() {
        return LAPACKE_sorcsd_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sorcsd_work(int matrix_layout, char jobu1, char jobu2, char jobv1t, char jobv2t, char trans, char signs, int m, int p, int q, float *x11, int ldx11, float *x12, int ldx12, float *x21, int ldx21, float *x22, int ldx22, float *theta, float *u1, int ldu1, float *u2, int ldu2, float *v1t, int ldv1t, float *v2t, int ldv2t, float *work, int lwork, int *iwork)
     * }
     */
    public static int LAPACKE_sorcsd_work(int matrix_layout, byte jobu1, byte jobu2, byte jobv1t, byte jobv2t, byte trans, byte signs, int m, int p, int q, MemorySegment x11, int ldx11, MemorySegment x12, int ldx12, MemorySegment x21, int ldx21, MemorySegment x22, int ldx22, MemorySegment theta, MemorySegment u1, int ldu1, MemorySegment u2, int ldu2, MemorySegment v1t, int ldv1t, MemorySegment v2t, int ldv2t, MemorySegment work, int lwork, MemorySegment iwork) {
        var mh$ = LAPACKE_sorcsd_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sorcsd_work", matrix_layout, jobu1, jobu2, jobv1t, jobv2t, trans, signs, m, p, q, x11, ldx11, x12, ldx12, x21, ldx21, x22, ldx22, theta, u1, ldu1, u2, ldu2, v1t, ldv1t, v2t, ldv2t, work, lwork, iwork);
            }
            return (int)mh$.invokeExact(matrix_layout, jobu1, jobu2, jobv1t, jobv2t, trans, signs, m, p, q, x11, ldx11, x12, ldx12, x21, ldx21, x22, ldx22, theta, u1, ldu1, u2, ldu2, v1t, ldv1t, v2t, ldv2t, work, lwork, iwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sorcsd2by1 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_sorcsd2by1");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sorcsd2by1(int matrix_layout, char jobu1, char jobu2, char jobv1t, int m, int p, int q, float *x11, int ldx11, float *x21, int ldx21, float *theta, float *u1, int ldu1, float *u2, int ldu2, float *v1t, int ldv1t)
     * }
     */
    public static FunctionDescriptor LAPACKE_sorcsd2by1$descriptor() {
        return LAPACKE_sorcsd2by1.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sorcsd2by1(int matrix_layout, char jobu1, char jobu2, char jobv1t, int m, int p, int q, float *x11, int ldx11, float *x21, int ldx21, float *theta, float *u1, int ldu1, float *u2, int ldu2, float *v1t, int ldv1t)
     * }
     */
    public static MethodHandle LAPACKE_sorcsd2by1$handle() {
        return LAPACKE_sorcsd2by1.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sorcsd2by1(int matrix_layout, char jobu1, char jobu2, char jobv1t, int m, int p, int q, float *x11, int ldx11, float *x21, int ldx21, float *theta, float *u1, int ldu1, float *u2, int ldu2, float *v1t, int ldv1t)
     * }
     */
    public static MemorySegment LAPACKE_sorcsd2by1$address() {
        return LAPACKE_sorcsd2by1.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sorcsd2by1(int matrix_layout, char jobu1, char jobu2, char jobv1t, int m, int p, int q, float *x11, int ldx11, float *x21, int ldx21, float *theta, float *u1, int ldu1, float *u2, int ldu2, float *v1t, int ldv1t)
     * }
     */
    public static int LAPACKE_sorcsd2by1(int matrix_layout, byte jobu1, byte jobu2, byte jobv1t, int m, int p, int q, MemorySegment x11, int ldx11, MemorySegment x21, int ldx21, MemorySegment theta, MemorySegment u1, int ldu1, MemorySegment u2, int ldu2, MemorySegment v1t, int ldv1t) {
        var mh$ = LAPACKE_sorcsd2by1.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sorcsd2by1", matrix_layout, jobu1, jobu2, jobv1t, m, p, q, x11, ldx11, x21, ldx21, theta, u1, ldu1, u2, ldu2, v1t, ldv1t);
            }
            return (int)mh$.invokeExact(matrix_layout, jobu1, jobu2, jobv1t, m, p, q, x11, ldx11, x21, ldx21, theta, u1, ldu1, u2, ldu2, v1t, ldv1t);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sorcsd2by1_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_sorcsd2by1_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sorcsd2by1_work(int matrix_layout, char jobu1, char jobu2, char jobv1t, int m, int p, int q, float *x11, int ldx11, float *x21, int ldx21, float *theta, float *u1, int ldu1, float *u2, int ldu2, float *v1t, int ldv1t, float *work, int lwork, int *iwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_sorcsd2by1_work$descriptor() {
        return LAPACKE_sorcsd2by1_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sorcsd2by1_work(int matrix_layout, char jobu1, char jobu2, char jobv1t, int m, int p, int q, float *x11, int ldx11, float *x21, int ldx21, float *theta, float *u1, int ldu1, float *u2, int ldu2, float *v1t, int ldv1t, float *work, int lwork, int *iwork)
     * }
     */
    public static MethodHandle LAPACKE_sorcsd2by1_work$handle() {
        return LAPACKE_sorcsd2by1_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sorcsd2by1_work(int matrix_layout, char jobu1, char jobu2, char jobv1t, int m, int p, int q, float *x11, int ldx11, float *x21, int ldx21, float *theta, float *u1, int ldu1, float *u2, int ldu2, float *v1t, int ldv1t, float *work, int lwork, int *iwork)
     * }
     */
    public static MemorySegment LAPACKE_sorcsd2by1_work$address() {
        return LAPACKE_sorcsd2by1_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sorcsd2by1_work(int matrix_layout, char jobu1, char jobu2, char jobv1t, int m, int p, int q, float *x11, int ldx11, float *x21, int ldx21, float *theta, float *u1, int ldu1, float *u2, int ldu2, float *v1t, int ldv1t, float *work, int lwork, int *iwork)
     * }
     */
    public static int LAPACKE_sorcsd2by1_work(int matrix_layout, byte jobu1, byte jobu2, byte jobv1t, int m, int p, int q, MemorySegment x11, int ldx11, MemorySegment x21, int ldx21, MemorySegment theta, MemorySegment u1, int ldu1, MemorySegment u2, int ldu2, MemorySegment v1t, int ldv1t, MemorySegment work, int lwork, MemorySegment iwork) {
        var mh$ = LAPACKE_sorcsd2by1_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sorcsd2by1_work", matrix_layout, jobu1, jobu2, jobv1t, m, p, q, x11, ldx11, x21, ldx21, theta, u1, ldu1, u2, ldu2, v1t, ldv1t, work, lwork, iwork);
            }
            return (int)mh$.invokeExact(matrix_layout, jobu1, jobu2, jobv1t, m, p, q, x11, ldx11, x21, ldx21, theta, u1, ldu1, u2, ldu2, v1t, ldv1t, work, lwork, iwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ssyconv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_ssyconv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ssyconv(int matrix_layout, char uplo, char way, int n, float *a, int lda, const int *ipiv, float *e)
     * }
     */
    public static FunctionDescriptor LAPACKE_ssyconv$descriptor() {
        return LAPACKE_ssyconv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ssyconv(int matrix_layout, char uplo, char way, int n, float *a, int lda, const int *ipiv, float *e)
     * }
     */
    public static MethodHandle LAPACKE_ssyconv$handle() {
        return LAPACKE_ssyconv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ssyconv(int matrix_layout, char uplo, char way, int n, float *a, int lda, const int *ipiv, float *e)
     * }
     */
    public static MemorySegment LAPACKE_ssyconv$address() {
        return LAPACKE_ssyconv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ssyconv(int matrix_layout, char uplo, char way, int n, float *a, int lda, const int *ipiv, float *e)
     * }
     */
    public static int LAPACKE_ssyconv(int matrix_layout, byte uplo, byte way, int n, MemorySegment a, int lda, MemorySegment ipiv, MemorySegment e) {
        var mh$ = LAPACKE_ssyconv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ssyconv", matrix_layout, uplo, way, n, a, lda, ipiv, e);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, way, n, a, lda, ipiv, e);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ssyconv_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_ssyconv_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ssyconv_work(int matrix_layout, char uplo, char way, int n, float *a, int lda, const int *ipiv, float *e)
     * }
     */
    public static FunctionDescriptor LAPACKE_ssyconv_work$descriptor() {
        return LAPACKE_ssyconv_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ssyconv_work(int matrix_layout, char uplo, char way, int n, float *a, int lda, const int *ipiv, float *e)
     * }
     */
    public static MethodHandle LAPACKE_ssyconv_work$handle() {
        return LAPACKE_ssyconv_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ssyconv_work(int matrix_layout, char uplo, char way, int n, float *a, int lda, const int *ipiv, float *e)
     * }
     */
    public static MemorySegment LAPACKE_ssyconv_work$address() {
        return LAPACKE_ssyconv_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ssyconv_work(int matrix_layout, char uplo, char way, int n, float *a, int lda, const int *ipiv, float *e)
     * }
     */
    public static int LAPACKE_ssyconv_work(int matrix_layout, byte uplo, byte way, int n, MemorySegment a, int lda, MemorySegment ipiv, MemorySegment e) {
        var mh$ = LAPACKE_ssyconv_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ssyconv_work", matrix_layout, uplo, way, n, a, lda, ipiv, e);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, way, n, a, lda, ipiv, e);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ssyswapr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_ssyswapr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ssyswapr(int matrix_layout, char uplo, int n, float *a, int lda, int i1, int i2)
     * }
     */
    public static FunctionDescriptor LAPACKE_ssyswapr$descriptor() {
        return LAPACKE_ssyswapr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ssyswapr(int matrix_layout, char uplo, int n, float *a, int lda, int i1, int i2)
     * }
     */
    public static MethodHandle LAPACKE_ssyswapr$handle() {
        return LAPACKE_ssyswapr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ssyswapr(int matrix_layout, char uplo, int n, float *a, int lda, int i1, int i2)
     * }
     */
    public static MemorySegment LAPACKE_ssyswapr$address() {
        return LAPACKE_ssyswapr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ssyswapr(int matrix_layout, char uplo, int n, float *a, int lda, int i1, int i2)
     * }
     */
    public static int LAPACKE_ssyswapr(int matrix_layout, byte uplo, int n, MemorySegment a, int lda, int i1, int i2) {
        var mh$ = LAPACKE_ssyswapr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ssyswapr", matrix_layout, uplo, n, a, lda, i1, i2);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, a, lda, i1, i2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ssyswapr_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_ssyswapr_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ssyswapr_work(int matrix_layout, char uplo, int n, float *a, int lda, int i1, int i2)
     * }
     */
    public static FunctionDescriptor LAPACKE_ssyswapr_work$descriptor() {
        return LAPACKE_ssyswapr_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ssyswapr_work(int matrix_layout, char uplo, int n, float *a, int lda, int i1, int i2)
     * }
     */
    public static MethodHandle LAPACKE_ssyswapr_work$handle() {
        return LAPACKE_ssyswapr_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ssyswapr_work(int matrix_layout, char uplo, int n, float *a, int lda, int i1, int i2)
     * }
     */
    public static MemorySegment LAPACKE_ssyswapr_work$address() {
        return LAPACKE_ssyswapr_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ssyswapr_work(int matrix_layout, char uplo, int n, float *a, int lda, int i1, int i2)
     * }
     */
    public static int LAPACKE_ssyswapr_work(int matrix_layout, byte uplo, int n, MemorySegment a, int lda, int i1, int i2) {
        var mh$ = LAPACKE_ssyswapr_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ssyswapr_work", matrix_layout, uplo, n, a, lda, i1, i2);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, a, lda, i1, i2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ssytri2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_ssytri2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ssytri2(int matrix_layout, char uplo, int n, float *a, int lda, const int *ipiv)
     * }
     */
    public static FunctionDescriptor LAPACKE_ssytri2$descriptor() {
        return LAPACKE_ssytri2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ssytri2(int matrix_layout, char uplo, int n, float *a, int lda, const int *ipiv)
     * }
     */
    public static MethodHandle LAPACKE_ssytri2$handle() {
        return LAPACKE_ssytri2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ssytri2(int matrix_layout, char uplo, int n, float *a, int lda, const int *ipiv)
     * }
     */
    public static MemorySegment LAPACKE_ssytri2$address() {
        return LAPACKE_ssytri2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ssytri2(int matrix_layout, char uplo, int n, float *a, int lda, const int *ipiv)
     * }
     */
    public static int LAPACKE_ssytri2(int matrix_layout, byte uplo, int n, MemorySegment a, int lda, MemorySegment ipiv) {
        var mh$ = LAPACKE_ssytri2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ssytri2", matrix_layout, uplo, n, a, lda, ipiv);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, a, lda, ipiv);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ssytri2_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_ssytri2_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ssytri2_work(int matrix_layout, char uplo, int n, float *a, int lda, const int *ipiv, float *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_ssytri2_work$descriptor() {
        return LAPACKE_ssytri2_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ssytri2_work(int matrix_layout, char uplo, int n, float *a, int lda, const int *ipiv, float *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_ssytri2_work$handle() {
        return LAPACKE_ssytri2_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ssytri2_work(int matrix_layout, char uplo, int n, float *a, int lda, const int *ipiv, float *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_ssytri2_work$address() {
        return LAPACKE_ssytri2_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ssytri2_work(int matrix_layout, char uplo, int n, float *a, int lda, const int *ipiv, float *work, int lwork)
     * }
     */
    public static int LAPACKE_ssytri2_work(int matrix_layout, byte uplo, int n, MemorySegment a, int lda, MemorySegment ipiv, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_ssytri2_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ssytri2_work", matrix_layout, uplo, n, a, lda, ipiv, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, a, lda, ipiv, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ssytri2x {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_ssytri2x");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ssytri2x(int matrix_layout, char uplo, int n, float *a, int lda, const int *ipiv, int nb)
     * }
     */
    public static FunctionDescriptor LAPACKE_ssytri2x$descriptor() {
        return LAPACKE_ssytri2x.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ssytri2x(int matrix_layout, char uplo, int n, float *a, int lda, const int *ipiv, int nb)
     * }
     */
    public static MethodHandle LAPACKE_ssytri2x$handle() {
        return LAPACKE_ssytri2x.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ssytri2x(int matrix_layout, char uplo, int n, float *a, int lda, const int *ipiv, int nb)
     * }
     */
    public static MemorySegment LAPACKE_ssytri2x$address() {
        return LAPACKE_ssytri2x.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ssytri2x(int matrix_layout, char uplo, int n, float *a, int lda, const int *ipiv, int nb)
     * }
     */
    public static int LAPACKE_ssytri2x(int matrix_layout, byte uplo, int n, MemorySegment a, int lda, MemorySegment ipiv, int nb) {
        var mh$ = LAPACKE_ssytri2x.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ssytri2x", matrix_layout, uplo, n, a, lda, ipiv, nb);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, a, lda, ipiv, nb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ssytri2x_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_ssytri2x_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ssytri2x_work(int matrix_layout, char uplo, int n, float *a, int lda, const int *ipiv, float *work, int nb)
     * }
     */
    public static FunctionDescriptor LAPACKE_ssytri2x_work$descriptor() {
        return LAPACKE_ssytri2x_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ssytri2x_work(int matrix_layout, char uplo, int n, float *a, int lda, const int *ipiv, float *work, int nb)
     * }
     */
    public static MethodHandle LAPACKE_ssytri2x_work$handle() {
        return LAPACKE_ssytri2x_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ssytri2x_work(int matrix_layout, char uplo, int n, float *a, int lda, const int *ipiv, float *work, int nb)
     * }
     */
    public static MemorySegment LAPACKE_ssytri2x_work$address() {
        return LAPACKE_ssytri2x_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ssytri2x_work(int matrix_layout, char uplo, int n, float *a, int lda, const int *ipiv, float *work, int nb)
     * }
     */
    public static int LAPACKE_ssytri2x_work(int matrix_layout, byte uplo, int n, MemorySegment a, int lda, MemorySegment ipiv, MemorySegment work, int nb) {
        var mh$ = LAPACKE_ssytri2x_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ssytri2x_work", matrix_layout, uplo, n, a, lda, ipiv, work, nb);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, a, lda, ipiv, work, nb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ssytrs2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_ssytrs2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ssytrs2(int matrix_layout, char uplo, int n, int nrhs, const float *a, int lda, const int *ipiv, float *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_ssytrs2$descriptor() {
        return LAPACKE_ssytrs2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ssytrs2(int matrix_layout, char uplo, int n, int nrhs, const float *a, int lda, const int *ipiv, float *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_ssytrs2$handle() {
        return LAPACKE_ssytrs2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ssytrs2(int matrix_layout, char uplo, int n, int nrhs, const float *a, int lda, const int *ipiv, float *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_ssytrs2$address() {
        return LAPACKE_ssytrs2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ssytrs2(int matrix_layout, char uplo, int n, int nrhs, const float *a, int lda, const int *ipiv, float *b, int ldb)
     * }
     */
    public static int LAPACKE_ssytrs2(int matrix_layout, byte uplo, int n, int nrhs, MemorySegment a, int lda, MemorySegment ipiv, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_ssytrs2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ssytrs2", matrix_layout, uplo, n, nrhs, a, lda, ipiv, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, nrhs, a, lda, ipiv, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ssytrs2_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_ssytrs2_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ssytrs2_work(int matrix_layout, char uplo, int n, int nrhs, const float *a, int lda, const int *ipiv, float *b, int ldb, float *work)
     * }
     */
    public static FunctionDescriptor LAPACKE_ssytrs2_work$descriptor() {
        return LAPACKE_ssytrs2_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ssytrs2_work(int matrix_layout, char uplo, int n, int nrhs, const float *a, int lda, const int *ipiv, float *b, int ldb, float *work)
     * }
     */
    public static MethodHandle LAPACKE_ssytrs2_work$handle() {
        return LAPACKE_ssytrs2_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ssytrs2_work(int matrix_layout, char uplo, int n, int nrhs, const float *a, int lda, const int *ipiv, float *b, int ldb, float *work)
     * }
     */
    public static MemorySegment LAPACKE_ssytrs2_work$address() {
        return LAPACKE_ssytrs2_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ssytrs2_work(int matrix_layout, char uplo, int n, int nrhs, const float *a, int lda, const int *ipiv, float *b, int ldb, float *work)
     * }
     */
    public static int LAPACKE_ssytrs2_work(int matrix_layout, byte uplo, int n, int nrhs, MemorySegment a, int lda, MemorySegment ipiv, MemorySegment b, int ldb, MemorySegment work) {
        var mh$ = LAPACKE_ssytrs2_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ssytrs2_work", matrix_layout, uplo, n, nrhs, a, lda, ipiv, b, ldb, work);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, nrhs, a, lda, ipiv, b, ldb, work);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zbbcsd {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zbbcsd");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zbbcsd(int matrix_layout, char jobu1, char jobu2, char jobv1t, char jobv2t, char trans, int m, int p, int q, double *theta, double *phi, _Complex double *u1, int ldu1, _Complex double *u2, int ldu2, _Complex double *v1t, int ldv1t, _Complex double *v2t, int ldv2t, double *b11d, double *b11e, double *b12d, double *b12e, double *b21d, double *b21e, double *b22d, double *b22e)
     * }
     */
    public static FunctionDescriptor LAPACKE_zbbcsd$descriptor() {
        return LAPACKE_zbbcsd.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zbbcsd(int matrix_layout, char jobu1, char jobu2, char jobv1t, char jobv2t, char trans, int m, int p, int q, double *theta, double *phi, _Complex double *u1, int ldu1, _Complex double *u2, int ldu2, _Complex double *v1t, int ldv1t, _Complex double *v2t, int ldv2t, double *b11d, double *b11e, double *b12d, double *b12e, double *b21d, double *b21e, double *b22d, double *b22e)
     * }
     */
    public static MethodHandle LAPACKE_zbbcsd$handle() {
        return LAPACKE_zbbcsd.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zbbcsd(int matrix_layout, char jobu1, char jobu2, char jobv1t, char jobv2t, char trans, int m, int p, int q, double *theta, double *phi, _Complex double *u1, int ldu1, _Complex double *u2, int ldu2, _Complex double *v1t, int ldv1t, _Complex double *v2t, int ldv2t, double *b11d, double *b11e, double *b12d, double *b12e, double *b21d, double *b21e, double *b22d, double *b22e)
     * }
     */
    public static MemorySegment LAPACKE_zbbcsd$address() {
        return LAPACKE_zbbcsd.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zbbcsd(int matrix_layout, char jobu1, char jobu2, char jobv1t, char jobv2t, char trans, int m, int p, int q, double *theta, double *phi, _Complex double *u1, int ldu1, _Complex double *u2, int ldu2, _Complex double *v1t, int ldv1t, _Complex double *v2t, int ldv2t, double *b11d, double *b11e, double *b12d, double *b12e, double *b21d, double *b21e, double *b22d, double *b22e)
     * }
     */
    public static int LAPACKE_zbbcsd(int matrix_layout, byte jobu1, byte jobu2, byte jobv1t, byte jobv2t, byte trans, int m, int p, int q, MemorySegment theta, MemorySegment phi, MemorySegment u1, int ldu1, MemorySegment u2, int ldu2, MemorySegment v1t, int ldv1t, MemorySegment v2t, int ldv2t, MemorySegment b11d, MemorySegment b11e, MemorySegment b12d, MemorySegment b12e, MemorySegment b21d, MemorySegment b21e, MemorySegment b22d, MemorySegment b22e) {
        var mh$ = LAPACKE_zbbcsd.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zbbcsd", matrix_layout, jobu1, jobu2, jobv1t, jobv2t, trans, m, p, q, theta, phi, u1, ldu1, u2, ldu2, v1t, ldv1t, v2t, ldv2t, b11d, b11e, b12d, b12e, b21d, b21e, b22d, b22e);
            }
            return (int)mh$.invokeExact(matrix_layout, jobu1, jobu2, jobv1t, jobv2t, trans, m, p, q, theta, phi, u1, ldu1, u2, ldu2, v1t, ldv1t, v2t, ldv2t, b11d, b11e, b12d, b12e, b21d, b21e, b22d, b22e);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zbbcsd_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zbbcsd_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zbbcsd_work(int matrix_layout, char jobu1, char jobu2, char jobv1t, char jobv2t, char trans, int m, int p, int q, double *theta, double *phi, _Complex double *u1, int ldu1, _Complex double *u2, int ldu2, _Complex double *v1t, int ldv1t, _Complex double *v2t, int ldv2t, double *b11d, double *b11e, double *b12d, double *b12e, double *b21d, double *b21e, double *b22d, double *b22e, double *rwork, int lrwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_zbbcsd_work$descriptor() {
        return LAPACKE_zbbcsd_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zbbcsd_work(int matrix_layout, char jobu1, char jobu2, char jobv1t, char jobv2t, char trans, int m, int p, int q, double *theta, double *phi, _Complex double *u1, int ldu1, _Complex double *u2, int ldu2, _Complex double *v1t, int ldv1t, _Complex double *v2t, int ldv2t, double *b11d, double *b11e, double *b12d, double *b12e, double *b21d, double *b21e, double *b22d, double *b22e, double *rwork, int lrwork)
     * }
     */
    public static MethodHandle LAPACKE_zbbcsd_work$handle() {
        return LAPACKE_zbbcsd_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zbbcsd_work(int matrix_layout, char jobu1, char jobu2, char jobv1t, char jobv2t, char trans, int m, int p, int q, double *theta, double *phi, _Complex double *u1, int ldu1, _Complex double *u2, int ldu2, _Complex double *v1t, int ldv1t, _Complex double *v2t, int ldv2t, double *b11d, double *b11e, double *b12d, double *b12e, double *b21d, double *b21e, double *b22d, double *b22e, double *rwork, int lrwork)
     * }
     */
    public static MemorySegment LAPACKE_zbbcsd_work$address() {
        return LAPACKE_zbbcsd_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zbbcsd_work(int matrix_layout, char jobu1, char jobu2, char jobv1t, char jobv2t, char trans, int m, int p, int q, double *theta, double *phi, _Complex double *u1, int ldu1, _Complex double *u2, int ldu2, _Complex double *v1t, int ldv1t, _Complex double *v2t, int ldv2t, double *b11d, double *b11e, double *b12d, double *b12e, double *b21d, double *b21e, double *b22d, double *b22e, double *rwork, int lrwork)
     * }
     */
    public static int LAPACKE_zbbcsd_work(int matrix_layout, byte jobu1, byte jobu2, byte jobv1t, byte jobv2t, byte trans, int m, int p, int q, MemorySegment theta, MemorySegment phi, MemorySegment u1, int ldu1, MemorySegment u2, int ldu2, MemorySegment v1t, int ldv1t, MemorySegment v2t, int ldv2t, MemorySegment b11d, MemorySegment b11e, MemorySegment b12d, MemorySegment b12e, MemorySegment b21d, MemorySegment b21e, MemorySegment b22d, MemorySegment b22e, MemorySegment rwork, int lrwork) {
        var mh$ = LAPACKE_zbbcsd_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zbbcsd_work", matrix_layout, jobu1, jobu2, jobv1t, jobv2t, trans, m, p, q, theta, phi, u1, ldu1, u2, ldu2, v1t, ldv1t, v2t, ldv2t, b11d, b11e, b12d, b12e, b21d, b21e, b22d, b22e, rwork, lrwork);
            }
            return (int)mh$.invokeExact(matrix_layout, jobu1, jobu2, jobv1t, jobv2t, trans, m, p, q, theta, phi, u1, ldu1, u2, ldu2, v1t, ldv1t, v2t, ldv2t, b11d, b11e, b12d, b12e, b21d, b21e, b22d, b22e, rwork, lrwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zheswapr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zheswapr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zheswapr(int matrix_layout, char uplo, int n, _Complex double *a, int lda, int i1, int i2)
     * }
     */
    public static FunctionDescriptor LAPACKE_zheswapr$descriptor() {
        return LAPACKE_zheswapr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zheswapr(int matrix_layout, char uplo, int n, _Complex double *a, int lda, int i1, int i2)
     * }
     */
    public static MethodHandle LAPACKE_zheswapr$handle() {
        return LAPACKE_zheswapr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zheswapr(int matrix_layout, char uplo, int n, _Complex double *a, int lda, int i1, int i2)
     * }
     */
    public static MemorySegment LAPACKE_zheswapr$address() {
        return LAPACKE_zheswapr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zheswapr(int matrix_layout, char uplo, int n, _Complex double *a, int lda, int i1, int i2)
     * }
     */
    public static int LAPACKE_zheswapr(int matrix_layout, byte uplo, int n, MemorySegment a, int lda, int i1, int i2) {
        var mh$ = LAPACKE_zheswapr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zheswapr", matrix_layout, uplo, n, a, lda, i1, i2);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, a, lda, i1, i2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zheswapr_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zheswapr_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zheswapr_work(int matrix_layout, char uplo, int n, _Complex double *a, int lda, int i1, int i2)
     * }
     */
    public static FunctionDescriptor LAPACKE_zheswapr_work$descriptor() {
        return LAPACKE_zheswapr_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zheswapr_work(int matrix_layout, char uplo, int n, _Complex double *a, int lda, int i1, int i2)
     * }
     */
    public static MethodHandle LAPACKE_zheswapr_work$handle() {
        return LAPACKE_zheswapr_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zheswapr_work(int matrix_layout, char uplo, int n, _Complex double *a, int lda, int i1, int i2)
     * }
     */
    public static MemorySegment LAPACKE_zheswapr_work$address() {
        return LAPACKE_zheswapr_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zheswapr_work(int matrix_layout, char uplo, int n, _Complex double *a, int lda, int i1, int i2)
     * }
     */
    public static int LAPACKE_zheswapr_work(int matrix_layout, byte uplo, int n, MemorySegment a, int lda, int i1, int i2) {
        var mh$ = LAPACKE_zheswapr_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zheswapr_work", matrix_layout, uplo, n, a, lda, i1, i2);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, a, lda, i1, i2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zhetri2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zhetri2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zhetri2(int matrix_layout, char uplo, int n, _Complex double *a, int lda, const int *ipiv)
     * }
     */
    public static FunctionDescriptor LAPACKE_zhetri2$descriptor() {
        return LAPACKE_zhetri2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zhetri2(int matrix_layout, char uplo, int n, _Complex double *a, int lda, const int *ipiv)
     * }
     */
    public static MethodHandle LAPACKE_zhetri2$handle() {
        return LAPACKE_zhetri2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zhetri2(int matrix_layout, char uplo, int n, _Complex double *a, int lda, const int *ipiv)
     * }
     */
    public static MemorySegment LAPACKE_zhetri2$address() {
        return LAPACKE_zhetri2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zhetri2(int matrix_layout, char uplo, int n, _Complex double *a, int lda, const int *ipiv)
     * }
     */
    public static int LAPACKE_zhetri2(int matrix_layout, byte uplo, int n, MemorySegment a, int lda, MemorySegment ipiv) {
        var mh$ = LAPACKE_zhetri2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zhetri2", matrix_layout, uplo, n, a, lda, ipiv);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, a, lda, ipiv);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zhetri2_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zhetri2_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zhetri2_work(int matrix_layout, char uplo, int n, _Complex double *a, int lda, const int *ipiv, _Complex double *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_zhetri2_work$descriptor() {
        return LAPACKE_zhetri2_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zhetri2_work(int matrix_layout, char uplo, int n, _Complex double *a, int lda, const int *ipiv, _Complex double *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_zhetri2_work$handle() {
        return LAPACKE_zhetri2_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zhetri2_work(int matrix_layout, char uplo, int n, _Complex double *a, int lda, const int *ipiv, _Complex double *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_zhetri2_work$address() {
        return LAPACKE_zhetri2_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zhetri2_work(int matrix_layout, char uplo, int n, _Complex double *a, int lda, const int *ipiv, _Complex double *work, int lwork)
     * }
     */
    public static int LAPACKE_zhetri2_work(int matrix_layout, byte uplo, int n, MemorySegment a, int lda, MemorySegment ipiv, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_zhetri2_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zhetri2_work", matrix_layout, uplo, n, a, lda, ipiv, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, a, lda, ipiv, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zhetri2x {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zhetri2x");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zhetri2x(int matrix_layout, char uplo, int n, _Complex double *a, int lda, const int *ipiv, int nb)
     * }
     */
    public static FunctionDescriptor LAPACKE_zhetri2x$descriptor() {
        return LAPACKE_zhetri2x.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zhetri2x(int matrix_layout, char uplo, int n, _Complex double *a, int lda, const int *ipiv, int nb)
     * }
     */
    public static MethodHandle LAPACKE_zhetri2x$handle() {
        return LAPACKE_zhetri2x.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zhetri2x(int matrix_layout, char uplo, int n, _Complex double *a, int lda, const int *ipiv, int nb)
     * }
     */
    public static MemorySegment LAPACKE_zhetri2x$address() {
        return LAPACKE_zhetri2x.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zhetri2x(int matrix_layout, char uplo, int n, _Complex double *a, int lda, const int *ipiv, int nb)
     * }
     */
    public static int LAPACKE_zhetri2x(int matrix_layout, byte uplo, int n, MemorySegment a, int lda, MemorySegment ipiv, int nb) {
        var mh$ = LAPACKE_zhetri2x.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zhetri2x", matrix_layout, uplo, n, a, lda, ipiv, nb);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, a, lda, ipiv, nb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zhetri2x_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zhetri2x_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zhetri2x_work(int matrix_layout, char uplo, int n, _Complex double *a, int lda, const int *ipiv, _Complex double *work, int nb)
     * }
     */
    public static FunctionDescriptor LAPACKE_zhetri2x_work$descriptor() {
        return LAPACKE_zhetri2x_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zhetri2x_work(int matrix_layout, char uplo, int n, _Complex double *a, int lda, const int *ipiv, _Complex double *work, int nb)
     * }
     */
    public static MethodHandle LAPACKE_zhetri2x_work$handle() {
        return LAPACKE_zhetri2x_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zhetri2x_work(int matrix_layout, char uplo, int n, _Complex double *a, int lda, const int *ipiv, _Complex double *work, int nb)
     * }
     */
    public static MemorySegment LAPACKE_zhetri2x_work$address() {
        return LAPACKE_zhetri2x_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zhetri2x_work(int matrix_layout, char uplo, int n, _Complex double *a, int lda, const int *ipiv, _Complex double *work, int nb)
     * }
     */
    public static int LAPACKE_zhetri2x_work(int matrix_layout, byte uplo, int n, MemorySegment a, int lda, MemorySegment ipiv, MemorySegment work, int nb) {
        var mh$ = LAPACKE_zhetri2x_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zhetri2x_work", matrix_layout, uplo, n, a, lda, ipiv, work, nb);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, a, lda, ipiv, work, nb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zhetrs2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zhetrs2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zhetrs2(int matrix_layout, char uplo, int n, int nrhs, const _Complex double *a, int lda, const int *ipiv, _Complex double *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_zhetrs2$descriptor() {
        return LAPACKE_zhetrs2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zhetrs2(int matrix_layout, char uplo, int n, int nrhs, const _Complex double *a, int lda, const int *ipiv, _Complex double *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_zhetrs2$handle() {
        return LAPACKE_zhetrs2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zhetrs2(int matrix_layout, char uplo, int n, int nrhs, const _Complex double *a, int lda, const int *ipiv, _Complex double *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_zhetrs2$address() {
        return LAPACKE_zhetrs2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zhetrs2(int matrix_layout, char uplo, int n, int nrhs, const _Complex double *a, int lda, const int *ipiv, _Complex double *b, int ldb)
     * }
     */
    public static int LAPACKE_zhetrs2(int matrix_layout, byte uplo, int n, int nrhs, MemorySegment a, int lda, MemorySegment ipiv, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_zhetrs2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zhetrs2", matrix_layout, uplo, n, nrhs, a, lda, ipiv, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, nrhs, a, lda, ipiv, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zhetrs2_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zhetrs2_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zhetrs2_work(int matrix_layout, char uplo, int n, int nrhs, const _Complex double *a, int lda, const int *ipiv, _Complex double *b, int ldb, _Complex double *work)
     * }
     */
    public static FunctionDescriptor LAPACKE_zhetrs2_work$descriptor() {
        return LAPACKE_zhetrs2_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zhetrs2_work(int matrix_layout, char uplo, int n, int nrhs, const _Complex double *a, int lda, const int *ipiv, _Complex double *b, int ldb, _Complex double *work)
     * }
     */
    public static MethodHandle LAPACKE_zhetrs2_work$handle() {
        return LAPACKE_zhetrs2_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zhetrs2_work(int matrix_layout, char uplo, int n, int nrhs, const _Complex double *a, int lda, const int *ipiv, _Complex double *b, int ldb, _Complex double *work)
     * }
     */
    public static MemorySegment LAPACKE_zhetrs2_work$address() {
        return LAPACKE_zhetrs2_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zhetrs2_work(int matrix_layout, char uplo, int n, int nrhs, const _Complex double *a, int lda, const int *ipiv, _Complex double *b, int ldb, _Complex double *work)
     * }
     */
    public static int LAPACKE_zhetrs2_work(int matrix_layout, byte uplo, int n, int nrhs, MemorySegment a, int lda, MemorySegment ipiv, MemorySegment b, int ldb, MemorySegment work) {
        var mh$ = LAPACKE_zhetrs2_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zhetrs2_work", matrix_layout, uplo, n, nrhs, a, lda, ipiv, b, ldb, work);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, nrhs, a, lda, ipiv, b, ldb, work);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zsyconv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zsyconv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zsyconv(int matrix_layout, char uplo, char way, int n, _Complex double *a, int lda, const int *ipiv, _Complex double *e)
     * }
     */
    public static FunctionDescriptor LAPACKE_zsyconv$descriptor() {
        return LAPACKE_zsyconv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zsyconv(int matrix_layout, char uplo, char way, int n, _Complex double *a, int lda, const int *ipiv, _Complex double *e)
     * }
     */
    public static MethodHandle LAPACKE_zsyconv$handle() {
        return LAPACKE_zsyconv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zsyconv(int matrix_layout, char uplo, char way, int n, _Complex double *a, int lda, const int *ipiv, _Complex double *e)
     * }
     */
    public static MemorySegment LAPACKE_zsyconv$address() {
        return LAPACKE_zsyconv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zsyconv(int matrix_layout, char uplo, char way, int n, _Complex double *a, int lda, const int *ipiv, _Complex double *e)
     * }
     */
    public static int LAPACKE_zsyconv(int matrix_layout, byte uplo, byte way, int n, MemorySegment a, int lda, MemorySegment ipiv, MemorySegment e) {
        var mh$ = LAPACKE_zsyconv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zsyconv", matrix_layout, uplo, way, n, a, lda, ipiv, e);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, way, n, a, lda, ipiv, e);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zsyconv_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zsyconv_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zsyconv_work(int matrix_layout, char uplo, char way, int n, _Complex double *a, int lda, const int *ipiv, _Complex double *e)
     * }
     */
    public static FunctionDescriptor LAPACKE_zsyconv_work$descriptor() {
        return LAPACKE_zsyconv_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zsyconv_work(int matrix_layout, char uplo, char way, int n, _Complex double *a, int lda, const int *ipiv, _Complex double *e)
     * }
     */
    public static MethodHandle LAPACKE_zsyconv_work$handle() {
        return LAPACKE_zsyconv_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zsyconv_work(int matrix_layout, char uplo, char way, int n, _Complex double *a, int lda, const int *ipiv, _Complex double *e)
     * }
     */
    public static MemorySegment LAPACKE_zsyconv_work$address() {
        return LAPACKE_zsyconv_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zsyconv_work(int matrix_layout, char uplo, char way, int n, _Complex double *a, int lda, const int *ipiv, _Complex double *e)
     * }
     */
    public static int LAPACKE_zsyconv_work(int matrix_layout, byte uplo, byte way, int n, MemorySegment a, int lda, MemorySegment ipiv, MemorySegment e) {
        var mh$ = LAPACKE_zsyconv_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zsyconv_work", matrix_layout, uplo, way, n, a, lda, ipiv, e);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, way, n, a, lda, ipiv, e);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zsyswapr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zsyswapr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zsyswapr(int matrix_layout, char uplo, int n, _Complex double *a, int lda, int i1, int i2)
     * }
     */
    public static FunctionDescriptor LAPACKE_zsyswapr$descriptor() {
        return LAPACKE_zsyswapr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zsyswapr(int matrix_layout, char uplo, int n, _Complex double *a, int lda, int i1, int i2)
     * }
     */
    public static MethodHandle LAPACKE_zsyswapr$handle() {
        return LAPACKE_zsyswapr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zsyswapr(int matrix_layout, char uplo, int n, _Complex double *a, int lda, int i1, int i2)
     * }
     */
    public static MemorySegment LAPACKE_zsyswapr$address() {
        return LAPACKE_zsyswapr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zsyswapr(int matrix_layout, char uplo, int n, _Complex double *a, int lda, int i1, int i2)
     * }
     */
    public static int LAPACKE_zsyswapr(int matrix_layout, byte uplo, int n, MemorySegment a, int lda, int i1, int i2) {
        var mh$ = LAPACKE_zsyswapr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zsyswapr", matrix_layout, uplo, n, a, lda, i1, i2);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, a, lda, i1, i2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zsyswapr_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zsyswapr_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zsyswapr_work(int matrix_layout, char uplo, int n, _Complex double *a, int lda, int i1, int i2)
     * }
     */
    public static FunctionDescriptor LAPACKE_zsyswapr_work$descriptor() {
        return LAPACKE_zsyswapr_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zsyswapr_work(int matrix_layout, char uplo, int n, _Complex double *a, int lda, int i1, int i2)
     * }
     */
    public static MethodHandle LAPACKE_zsyswapr_work$handle() {
        return LAPACKE_zsyswapr_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zsyswapr_work(int matrix_layout, char uplo, int n, _Complex double *a, int lda, int i1, int i2)
     * }
     */
    public static MemorySegment LAPACKE_zsyswapr_work$address() {
        return LAPACKE_zsyswapr_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zsyswapr_work(int matrix_layout, char uplo, int n, _Complex double *a, int lda, int i1, int i2)
     * }
     */
    public static int LAPACKE_zsyswapr_work(int matrix_layout, byte uplo, int n, MemorySegment a, int lda, int i1, int i2) {
        var mh$ = LAPACKE_zsyswapr_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zsyswapr_work", matrix_layout, uplo, n, a, lda, i1, i2);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, a, lda, i1, i2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zsytri2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zsytri2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zsytri2(int matrix_layout, char uplo, int n, _Complex double *a, int lda, const int *ipiv)
     * }
     */
    public static FunctionDescriptor LAPACKE_zsytri2$descriptor() {
        return LAPACKE_zsytri2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zsytri2(int matrix_layout, char uplo, int n, _Complex double *a, int lda, const int *ipiv)
     * }
     */
    public static MethodHandle LAPACKE_zsytri2$handle() {
        return LAPACKE_zsytri2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zsytri2(int matrix_layout, char uplo, int n, _Complex double *a, int lda, const int *ipiv)
     * }
     */
    public static MemorySegment LAPACKE_zsytri2$address() {
        return LAPACKE_zsytri2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zsytri2(int matrix_layout, char uplo, int n, _Complex double *a, int lda, const int *ipiv)
     * }
     */
    public static int LAPACKE_zsytri2(int matrix_layout, byte uplo, int n, MemorySegment a, int lda, MemorySegment ipiv) {
        var mh$ = LAPACKE_zsytri2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zsytri2", matrix_layout, uplo, n, a, lda, ipiv);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, a, lda, ipiv);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zsytri2_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zsytri2_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zsytri2_work(int matrix_layout, char uplo, int n, _Complex double *a, int lda, const int *ipiv, _Complex double *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_zsytri2_work$descriptor() {
        return LAPACKE_zsytri2_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zsytri2_work(int matrix_layout, char uplo, int n, _Complex double *a, int lda, const int *ipiv, _Complex double *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_zsytri2_work$handle() {
        return LAPACKE_zsytri2_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zsytri2_work(int matrix_layout, char uplo, int n, _Complex double *a, int lda, const int *ipiv, _Complex double *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_zsytri2_work$address() {
        return LAPACKE_zsytri2_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zsytri2_work(int matrix_layout, char uplo, int n, _Complex double *a, int lda, const int *ipiv, _Complex double *work, int lwork)
     * }
     */
    public static int LAPACKE_zsytri2_work(int matrix_layout, byte uplo, int n, MemorySegment a, int lda, MemorySegment ipiv, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_zsytri2_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zsytri2_work", matrix_layout, uplo, n, a, lda, ipiv, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, a, lda, ipiv, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zsytri2x {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zsytri2x");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zsytri2x(int matrix_layout, char uplo, int n, _Complex double *a, int lda, const int *ipiv, int nb)
     * }
     */
    public static FunctionDescriptor LAPACKE_zsytri2x$descriptor() {
        return LAPACKE_zsytri2x.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zsytri2x(int matrix_layout, char uplo, int n, _Complex double *a, int lda, const int *ipiv, int nb)
     * }
     */
    public static MethodHandle LAPACKE_zsytri2x$handle() {
        return LAPACKE_zsytri2x.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zsytri2x(int matrix_layout, char uplo, int n, _Complex double *a, int lda, const int *ipiv, int nb)
     * }
     */
    public static MemorySegment LAPACKE_zsytri2x$address() {
        return LAPACKE_zsytri2x.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zsytri2x(int matrix_layout, char uplo, int n, _Complex double *a, int lda, const int *ipiv, int nb)
     * }
     */
    public static int LAPACKE_zsytri2x(int matrix_layout, byte uplo, int n, MemorySegment a, int lda, MemorySegment ipiv, int nb) {
        var mh$ = LAPACKE_zsytri2x.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zsytri2x", matrix_layout, uplo, n, a, lda, ipiv, nb);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, a, lda, ipiv, nb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zsytri2x_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zsytri2x_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zsytri2x_work(int matrix_layout, char uplo, int n, _Complex double *a, int lda, const int *ipiv, _Complex double *work, int nb)
     * }
     */
    public static FunctionDescriptor LAPACKE_zsytri2x_work$descriptor() {
        return LAPACKE_zsytri2x_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zsytri2x_work(int matrix_layout, char uplo, int n, _Complex double *a, int lda, const int *ipiv, _Complex double *work, int nb)
     * }
     */
    public static MethodHandle LAPACKE_zsytri2x_work$handle() {
        return LAPACKE_zsytri2x_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zsytri2x_work(int matrix_layout, char uplo, int n, _Complex double *a, int lda, const int *ipiv, _Complex double *work, int nb)
     * }
     */
    public static MemorySegment LAPACKE_zsytri2x_work$address() {
        return LAPACKE_zsytri2x_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zsytri2x_work(int matrix_layout, char uplo, int n, _Complex double *a, int lda, const int *ipiv, _Complex double *work, int nb)
     * }
     */
    public static int LAPACKE_zsytri2x_work(int matrix_layout, byte uplo, int n, MemorySegment a, int lda, MemorySegment ipiv, MemorySegment work, int nb) {
        var mh$ = LAPACKE_zsytri2x_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zsytri2x_work", matrix_layout, uplo, n, a, lda, ipiv, work, nb);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, a, lda, ipiv, work, nb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zsytrs2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zsytrs2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zsytrs2(int matrix_layout, char uplo, int n, int nrhs, const _Complex double *a, int lda, const int *ipiv, _Complex double *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_zsytrs2$descriptor() {
        return LAPACKE_zsytrs2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zsytrs2(int matrix_layout, char uplo, int n, int nrhs, const _Complex double *a, int lda, const int *ipiv, _Complex double *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_zsytrs2$handle() {
        return LAPACKE_zsytrs2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zsytrs2(int matrix_layout, char uplo, int n, int nrhs, const _Complex double *a, int lda, const int *ipiv, _Complex double *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_zsytrs2$address() {
        return LAPACKE_zsytrs2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zsytrs2(int matrix_layout, char uplo, int n, int nrhs, const _Complex double *a, int lda, const int *ipiv, _Complex double *b, int ldb)
     * }
     */
    public static int LAPACKE_zsytrs2(int matrix_layout, byte uplo, int n, int nrhs, MemorySegment a, int lda, MemorySegment ipiv, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_zsytrs2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zsytrs2", matrix_layout, uplo, n, nrhs, a, lda, ipiv, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, nrhs, a, lda, ipiv, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zsytrs2_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zsytrs2_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zsytrs2_work(int matrix_layout, char uplo, int n, int nrhs, const _Complex double *a, int lda, const int *ipiv, _Complex double *b, int ldb, _Complex double *work)
     * }
     */
    public static FunctionDescriptor LAPACKE_zsytrs2_work$descriptor() {
        return LAPACKE_zsytrs2_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zsytrs2_work(int matrix_layout, char uplo, int n, int nrhs, const _Complex double *a, int lda, const int *ipiv, _Complex double *b, int ldb, _Complex double *work)
     * }
     */
    public static MethodHandle LAPACKE_zsytrs2_work$handle() {
        return LAPACKE_zsytrs2_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zsytrs2_work(int matrix_layout, char uplo, int n, int nrhs, const _Complex double *a, int lda, const int *ipiv, _Complex double *b, int ldb, _Complex double *work)
     * }
     */
    public static MemorySegment LAPACKE_zsytrs2_work$address() {
        return LAPACKE_zsytrs2_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zsytrs2_work(int matrix_layout, char uplo, int n, int nrhs, const _Complex double *a, int lda, const int *ipiv, _Complex double *b, int ldb, _Complex double *work)
     * }
     */
    public static int LAPACKE_zsytrs2_work(int matrix_layout, byte uplo, int n, int nrhs, MemorySegment a, int lda, MemorySegment ipiv, MemorySegment b, int ldb, MemorySegment work) {
        var mh$ = LAPACKE_zsytrs2_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zsytrs2_work", matrix_layout, uplo, n, nrhs, a, lda, ipiv, b, ldb, work);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, nrhs, a, lda, ipiv, b, ldb, work);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zunbdb {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zunbdb");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zunbdb(int matrix_layout, char trans, char signs, int m, int p, int q, _Complex double *x11, int ldx11, _Complex double *x12, int ldx12, _Complex double *x21, int ldx21, _Complex double *x22, int ldx22, double *theta, double *phi, _Complex double *taup1, _Complex double *taup2, _Complex double *tauq1, _Complex double *tauq2)
     * }
     */
    public static FunctionDescriptor LAPACKE_zunbdb$descriptor() {
        return LAPACKE_zunbdb.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zunbdb(int matrix_layout, char trans, char signs, int m, int p, int q, _Complex double *x11, int ldx11, _Complex double *x12, int ldx12, _Complex double *x21, int ldx21, _Complex double *x22, int ldx22, double *theta, double *phi, _Complex double *taup1, _Complex double *taup2, _Complex double *tauq1, _Complex double *tauq2)
     * }
     */
    public static MethodHandle LAPACKE_zunbdb$handle() {
        return LAPACKE_zunbdb.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zunbdb(int matrix_layout, char trans, char signs, int m, int p, int q, _Complex double *x11, int ldx11, _Complex double *x12, int ldx12, _Complex double *x21, int ldx21, _Complex double *x22, int ldx22, double *theta, double *phi, _Complex double *taup1, _Complex double *taup2, _Complex double *tauq1, _Complex double *tauq2)
     * }
     */
    public static MemorySegment LAPACKE_zunbdb$address() {
        return LAPACKE_zunbdb.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zunbdb(int matrix_layout, char trans, char signs, int m, int p, int q, _Complex double *x11, int ldx11, _Complex double *x12, int ldx12, _Complex double *x21, int ldx21, _Complex double *x22, int ldx22, double *theta, double *phi, _Complex double *taup1, _Complex double *taup2, _Complex double *tauq1, _Complex double *tauq2)
     * }
     */
    public static int LAPACKE_zunbdb(int matrix_layout, byte trans, byte signs, int m, int p, int q, MemorySegment x11, int ldx11, MemorySegment x12, int ldx12, MemorySegment x21, int ldx21, MemorySegment x22, int ldx22, MemorySegment theta, MemorySegment phi, MemorySegment taup1, MemorySegment taup2, MemorySegment tauq1, MemorySegment tauq2) {
        var mh$ = LAPACKE_zunbdb.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zunbdb", matrix_layout, trans, signs, m, p, q, x11, ldx11, x12, ldx12, x21, ldx21, x22, ldx22, theta, phi, taup1, taup2, tauq1, tauq2);
            }
            return (int)mh$.invokeExact(matrix_layout, trans, signs, m, p, q, x11, ldx11, x12, ldx12, x21, ldx21, x22, ldx22, theta, phi, taup1, taup2, tauq1, tauq2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zunbdb_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zunbdb_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zunbdb_work(int matrix_layout, char trans, char signs, int m, int p, int q, _Complex double *x11, int ldx11, _Complex double *x12, int ldx12, _Complex double *x21, int ldx21, _Complex double *x22, int ldx22, double *theta, double *phi, _Complex double *taup1, _Complex double *taup2, _Complex double *tauq1, _Complex double *tauq2, _Complex double *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_zunbdb_work$descriptor() {
        return LAPACKE_zunbdb_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zunbdb_work(int matrix_layout, char trans, char signs, int m, int p, int q, _Complex double *x11, int ldx11, _Complex double *x12, int ldx12, _Complex double *x21, int ldx21, _Complex double *x22, int ldx22, double *theta, double *phi, _Complex double *taup1, _Complex double *taup2, _Complex double *tauq1, _Complex double *tauq2, _Complex double *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_zunbdb_work$handle() {
        return LAPACKE_zunbdb_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zunbdb_work(int matrix_layout, char trans, char signs, int m, int p, int q, _Complex double *x11, int ldx11, _Complex double *x12, int ldx12, _Complex double *x21, int ldx21, _Complex double *x22, int ldx22, double *theta, double *phi, _Complex double *taup1, _Complex double *taup2, _Complex double *tauq1, _Complex double *tauq2, _Complex double *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_zunbdb_work$address() {
        return LAPACKE_zunbdb_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zunbdb_work(int matrix_layout, char trans, char signs, int m, int p, int q, _Complex double *x11, int ldx11, _Complex double *x12, int ldx12, _Complex double *x21, int ldx21, _Complex double *x22, int ldx22, double *theta, double *phi, _Complex double *taup1, _Complex double *taup2, _Complex double *tauq1, _Complex double *tauq2, _Complex double *work, int lwork)
     * }
     */
    public static int LAPACKE_zunbdb_work(int matrix_layout, byte trans, byte signs, int m, int p, int q, MemorySegment x11, int ldx11, MemorySegment x12, int ldx12, MemorySegment x21, int ldx21, MemorySegment x22, int ldx22, MemorySegment theta, MemorySegment phi, MemorySegment taup1, MemorySegment taup2, MemorySegment tauq1, MemorySegment tauq2, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_zunbdb_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zunbdb_work", matrix_layout, trans, signs, m, p, q, x11, ldx11, x12, ldx12, x21, ldx21, x22, ldx22, theta, phi, taup1, taup2, tauq1, tauq2, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, trans, signs, m, p, q, x11, ldx11, x12, ldx12, x21, ldx21, x22, ldx22, theta, phi, taup1, taup2, tauq1, tauq2, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zuncsd {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zuncsd");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zuncsd(int matrix_layout, char jobu1, char jobu2, char jobv1t, char jobv2t, char trans, char signs, int m, int p, int q, _Complex double *x11, int ldx11, _Complex double *x12, int ldx12, _Complex double *x21, int ldx21, _Complex double *x22, int ldx22, double *theta, _Complex double *u1, int ldu1, _Complex double *u2, int ldu2, _Complex double *v1t, int ldv1t, _Complex double *v2t, int ldv2t)
     * }
     */
    public static FunctionDescriptor LAPACKE_zuncsd$descriptor() {
        return LAPACKE_zuncsd.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zuncsd(int matrix_layout, char jobu1, char jobu2, char jobv1t, char jobv2t, char trans, char signs, int m, int p, int q, _Complex double *x11, int ldx11, _Complex double *x12, int ldx12, _Complex double *x21, int ldx21, _Complex double *x22, int ldx22, double *theta, _Complex double *u1, int ldu1, _Complex double *u2, int ldu2, _Complex double *v1t, int ldv1t, _Complex double *v2t, int ldv2t)
     * }
     */
    public static MethodHandle LAPACKE_zuncsd$handle() {
        return LAPACKE_zuncsd.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zuncsd(int matrix_layout, char jobu1, char jobu2, char jobv1t, char jobv2t, char trans, char signs, int m, int p, int q, _Complex double *x11, int ldx11, _Complex double *x12, int ldx12, _Complex double *x21, int ldx21, _Complex double *x22, int ldx22, double *theta, _Complex double *u1, int ldu1, _Complex double *u2, int ldu2, _Complex double *v1t, int ldv1t, _Complex double *v2t, int ldv2t)
     * }
     */
    public static MemorySegment LAPACKE_zuncsd$address() {
        return LAPACKE_zuncsd.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zuncsd(int matrix_layout, char jobu1, char jobu2, char jobv1t, char jobv2t, char trans, char signs, int m, int p, int q, _Complex double *x11, int ldx11, _Complex double *x12, int ldx12, _Complex double *x21, int ldx21, _Complex double *x22, int ldx22, double *theta, _Complex double *u1, int ldu1, _Complex double *u2, int ldu2, _Complex double *v1t, int ldv1t, _Complex double *v2t, int ldv2t)
     * }
     */
    public static int LAPACKE_zuncsd(int matrix_layout, byte jobu1, byte jobu2, byte jobv1t, byte jobv2t, byte trans, byte signs, int m, int p, int q, MemorySegment x11, int ldx11, MemorySegment x12, int ldx12, MemorySegment x21, int ldx21, MemorySegment x22, int ldx22, MemorySegment theta, MemorySegment u1, int ldu1, MemorySegment u2, int ldu2, MemorySegment v1t, int ldv1t, MemorySegment v2t, int ldv2t) {
        var mh$ = LAPACKE_zuncsd.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zuncsd", matrix_layout, jobu1, jobu2, jobv1t, jobv2t, trans, signs, m, p, q, x11, ldx11, x12, ldx12, x21, ldx21, x22, ldx22, theta, u1, ldu1, u2, ldu2, v1t, ldv1t, v2t, ldv2t);
            }
            return (int)mh$.invokeExact(matrix_layout, jobu1, jobu2, jobv1t, jobv2t, trans, signs, m, p, q, x11, ldx11, x12, ldx12, x21, ldx21, x22, ldx22, theta, u1, ldu1, u2, ldu2, v1t, ldv1t, v2t, ldv2t);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zuncsd_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zuncsd_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zuncsd_work(int matrix_layout, char jobu1, char jobu2, char jobv1t, char jobv2t, char trans, char signs, int m, int p, int q, _Complex double *x11, int ldx11, _Complex double *x12, int ldx12, _Complex double *x21, int ldx21, _Complex double *x22, int ldx22, double *theta, _Complex double *u1, int ldu1, _Complex double *u2, int ldu2, _Complex double *v1t, int ldv1t, _Complex double *v2t, int ldv2t, _Complex double *work, int lwork, double *rwork, int lrwork, int *iwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_zuncsd_work$descriptor() {
        return LAPACKE_zuncsd_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zuncsd_work(int matrix_layout, char jobu1, char jobu2, char jobv1t, char jobv2t, char trans, char signs, int m, int p, int q, _Complex double *x11, int ldx11, _Complex double *x12, int ldx12, _Complex double *x21, int ldx21, _Complex double *x22, int ldx22, double *theta, _Complex double *u1, int ldu1, _Complex double *u2, int ldu2, _Complex double *v1t, int ldv1t, _Complex double *v2t, int ldv2t, _Complex double *work, int lwork, double *rwork, int lrwork, int *iwork)
     * }
     */
    public static MethodHandle LAPACKE_zuncsd_work$handle() {
        return LAPACKE_zuncsd_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zuncsd_work(int matrix_layout, char jobu1, char jobu2, char jobv1t, char jobv2t, char trans, char signs, int m, int p, int q, _Complex double *x11, int ldx11, _Complex double *x12, int ldx12, _Complex double *x21, int ldx21, _Complex double *x22, int ldx22, double *theta, _Complex double *u1, int ldu1, _Complex double *u2, int ldu2, _Complex double *v1t, int ldv1t, _Complex double *v2t, int ldv2t, _Complex double *work, int lwork, double *rwork, int lrwork, int *iwork)
     * }
     */
    public static MemorySegment LAPACKE_zuncsd_work$address() {
        return LAPACKE_zuncsd_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zuncsd_work(int matrix_layout, char jobu1, char jobu2, char jobv1t, char jobv2t, char trans, char signs, int m, int p, int q, _Complex double *x11, int ldx11, _Complex double *x12, int ldx12, _Complex double *x21, int ldx21, _Complex double *x22, int ldx22, double *theta, _Complex double *u1, int ldu1, _Complex double *u2, int ldu2, _Complex double *v1t, int ldv1t, _Complex double *v2t, int ldv2t, _Complex double *work, int lwork, double *rwork, int lrwork, int *iwork)
     * }
     */
    public static int LAPACKE_zuncsd_work(int matrix_layout, byte jobu1, byte jobu2, byte jobv1t, byte jobv2t, byte trans, byte signs, int m, int p, int q, MemorySegment x11, int ldx11, MemorySegment x12, int ldx12, MemorySegment x21, int ldx21, MemorySegment x22, int ldx22, MemorySegment theta, MemorySegment u1, int ldu1, MemorySegment u2, int ldu2, MemorySegment v1t, int ldv1t, MemorySegment v2t, int ldv2t, MemorySegment work, int lwork, MemorySegment rwork, int lrwork, MemorySegment iwork) {
        var mh$ = LAPACKE_zuncsd_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zuncsd_work", matrix_layout, jobu1, jobu2, jobv1t, jobv2t, trans, signs, m, p, q, x11, ldx11, x12, ldx12, x21, ldx21, x22, ldx22, theta, u1, ldu1, u2, ldu2, v1t, ldv1t, v2t, ldv2t, work, lwork, rwork, lrwork, iwork);
            }
            return (int)mh$.invokeExact(matrix_layout, jobu1, jobu2, jobv1t, jobv2t, trans, signs, m, p, q, x11, ldx11, x12, ldx12, x21, ldx21, x22, ldx22, theta, u1, ldu1, u2, ldu2, v1t, ldv1t, v2t, ldv2t, work, lwork, rwork, lrwork, iwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zuncsd2by1 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zuncsd2by1");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zuncsd2by1(int matrix_layout, char jobu1, char jobu2, char jobv1t, int m, int p, int q, _Complex double *x11, int ldx11, _Complex double *x21, int ldx21, double *theta, _Complex double *u1, int ldu1, _Complex double *u2, int ldu2, _Complex double *v1t, int ldv1t)
     * }
     */
    public static FunctionDescriptor LAPACKE_zuncsd2by1$descriptor() {
        return LAPACKE_zuncsd2by1.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zuncsd2by1(int matrix_layout, char jobu1, char jobu2, char jobv1t, int m, int p, int q, _Complex double *x11, int ldx11, _Complex double *x21, int ldx21, double *theta, _Complex double *u1, int ldu1, _Complex double *u2, int ldu2, _Complex double *v1t, int ldv1t)
     * }
     */
    public static MethodHandle LAPACKE_zuncsd2by1$handle() {
        return LAPACKE_zuncsd2by1.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zuncsd2by1(int matrix_layout, char jobu1, char jobu2, char jobv1t, int m, int p, int q, _Complex double *x11, int ldx11, _Complex double *x21, int ldx21, double *theta, _Complex double *u1, int ldu1, _Complex double *u2, int ldu2, _Complex double *v1t, int ldv1t)
     * }
     */
    public static MemorySegment LAPACKE_zuncsd2by1$address() {
        return LAPACKE_zuncsd2by1.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zuncsd2by1(int matrix_layout, char jobu1, char jobu2, char jobv1t, int m, int p, int q, _Complex double *x11, int ldx11, _Complex double *x21, int ldx21, double *theta, _Complex double *u1, int ldu1, _Complex double *u2, int ldu2, _Complex double *v1t, int ldv1t)
     * }
     */
    public static int LAPACKE_zuncsd2by1(int matrix_layout, byte jobu1, byte jobu2, byte jobv1t, int m, int p, int q, MemorySegment x11, int ldx11, MemorySegment x21, int ldx21, MemorySegment theta, MemorySegment u1, int ldu1, MemorySegment u2, int ldu2, MemorySegment v1t, int ldv1t) {
        var mh$ = LAPACKE_zuncsd2by1.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zuncsd2by1", matrix_layout, jobu1, jobu2, jobv1t, m, p, q, x11, ldx11, x21, ldx21, theta, u1, ldu1, u2, ldu2, v1t, ldv1t);
            }
            return (int)mh$.invokeExact(matrix_layout, jobu1, jobu2, jobv1t, m, p, q, x11, ldx11, x21, ldx21, theta, u1, ldu1, u2, ldu2, v1t, ldv1t);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zuncsd2by1_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zuncsd2by1_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zuncsd2by1_work(int matrix_layout, char jobu1, char jobu2, char jobv1t, int m, int p, int q, _Complex double *x11, int ldx11, _Complex double *x21, int ldx21, double *theta, _Complex double *u1, int ldu1, _Complex double *u2, int ldu2, _Complex double *v1t, int ldv1t, _Complex double *work, int lwork, double *rwork, int lrwork, int *iwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_zuncsd2by1_work$descriptor() {
        return LAPACKE_zuncsd2by1_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zuncsd2by1_work(int matrix_layout, char jobu1, char jobu2, char jobv1t, int m, int p, int q, _Complex double *x11, int ldx11, _Complex double *x21, int ldx21, double *theta, _Complex double *u1, int ldu1, _Complex double *u2, int ldu2, _Complex double *v1t, int ldv1t, _Complex double *work, int lwork, double *rwork, int lrwork, int *iwork)
     * }
     */
    public static MethodHandle LAPACKE_zuncsd2by1_work$handle() {
        return LAPACKE_zuncsd2by1_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zuncsd2by1_work(int matrix_layout, char jobu1, char jobu2, char jobv1t, int m, int p, int q, _Complex double *x11, int ldx11, _Complex double *x21, int ldx21, double *theta, _Complex double *u1, int ldu1, _Complex double *u2, int ldu2, _Complex double *v1t, int ldv1t, _Complex double *work, int lwork, double *rwork, int lrwork, int *iwork)
     * }
     */
    public static MemorySegment LAPACKE_zuncsd2by1_work$address() {
        return LAPACKE_zuncsd2by1_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zuncsd2by1_work(int matrix_layout, char jobu1, char jobu2, char jobv1t, int m, int p, int q, _Complex double *x11, int ldx11, _Complex double *x21, int ldx21, double *theta, _Complex double *u1, int ldu1, _Complex double *u2, int ldu2, _Complex double *v1t, int ldv1t, _Complex double *work, int lwork, double *rwork, int lrwork, int *iwork)
     * }
     */
    public static int LAPACKE_zuncsd2by1_work(int matrix_layout, byte jobu1, byte jobu2, byte jobv1t, int m, int p, int q, MemorySegment x11, int ldx11, MemorySegment x21, int ldx21, MemorySegment theta, MemorySegment u1, int ldu1, MemorySegment u2, int ldu2, MemorySegment v1t, int ldv1t, MemorySegment work, int lwork, MemorySegment rwork, int lrwork, MemorySegment iwork) {
        var mh$ = LAPACKE_zuncsd2by1_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zuncsd2by1_work", matrix_layout, jobu1, jobu2, jobv1t, m, p, q, x11, ldx11, x21, ldx21, theta, u1, ldu1, u2, ldu2, v1t, ldv1t, work, lwork, rwork, lrwork, iwork);
            }
            return (int)mh$.invokeExact(matrix_layout, jobu1, jobu2, jobv1t, m, p, q, x11, ldx11, x21, ldx21, theta, u1, ldu1, u2, ldu2, v1t, ldv1t, work, lwork, rwork, lrwork, iwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sgemqrt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_sgemqrt");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sgemqrt(int matrix_layout, char side, char trans, int m, int n, int k, int nb, const float *v, int ldv, const float *t, int ldt, float *c, int ldc)
     * }
     */
    public static FunctionDescriptor LAPACKE_sgemqrt$descriptor() {
        return LAPACKE_sgemqrt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sgemqrt(int matrix_layout, char side, char trans, int m, int n, int k, int nb, const float *v, int ldv, const float *t, int ldt, float *c, int ldc)
     * }
     */
    public static MethodHandle LAPACKE_sgemqrt$handle() {
        return LAPACKE_sgemqrt.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sgemqrt(int matrix_layout, char side, char trans, int m, int n, int k, int nb, const float *v, int ldv, const float *t, int ldt, float *c, int ldc)
     * }
     */
    public static MemorySegment LAPACKE_sgemqrt$address() {
        return LAPACKE_sgemqrt.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sgemqrt(int matrix_layout, char side, char trans, int m, int n, int k, int nb, const float *v, int ldv, const float *t, int ldt, float *c, int ldc)
     * }
     */
    public static int LAPACKE_sgemqrt(int matrix_layout, byte side, byte trans, int m, int n, int k, int nb, MemorySegment v, int ldv, MemorySegment t, int ldt, MemorySegment c, int ldc) {
        var mh$ = LAPACKE_sgemqrt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sgemqrt", matrix_layout, side, trans, m, n, k, nb, v, ldv, t, ldt, c, ldc);
            }
            return (int)mh$.invokeExact(matrix_layout, side, trans, m, n, k, nb, v, ldv, t, ldt, c, ldc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dgemqrt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dgemqrt");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dgemqrt(int matrix_layout, char side, char trans, int m, int n, int k, int nb, const double *v, int ldv, const double *t, int ldt, double *c, int ldc)
     * }
     */
    public static FunctionDescriptor LAPACKE_dgemqrt$descriptor() {
        return LAPACKE_dgemqrt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dgemqrt(int matrix_layout, char side, char trans, int m, int n, int k, int nb, const double *v, int ldv, const double *t, int ldt, double *c, int ldc)
     * }
     */
    public static MethodHandle LAPACKE_dgemqrt$handle() {
        return LAPACKE_dgemqrt.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dgemqrt(int matrix_layout, char side, char trans, int m, int n, int k, int nb, const double *v, int ldv, const double *t, int ldt, double *c, int ldc)
     * }
     */
    public static MemorySegment LAPACKE_dgemqrt$address() {
        return LAPACKE_dgemqrt.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dgemqrt(int matrix_layout, char side, char trans, int m, int n, int k, int nb, const double *v, int ldv, const double *t, int ldt, double *c, int ldc)
     * }
     */
    public static int LAPACKE_dgemqrt(int matrix_layout, byte side, byte trans, int m, int n, int k, int nb, MemorySegment v, int ldv, MemorySegment t, int ldt, MemorySegment c, int ldc) {
        var mh$ = LAPACKE_dgemqrt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dgemqrt", matrix_layout, side, trans, m, n, k, nb, v, ldv, t, ldt, c, ldc);
            }
            return (int)mh$.invokeExact(matrix_layout, side, trans, m, n, k, nb, v, ldv, t, ldt, c, ldc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cgemqrt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_cgemqrt");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cgemqrt(int matrix_layout, char side, char trans, int m, int n, int k, int nb, const _Complex float *v, int ldv, const _Complex float *t, int ldt, _Complex float *c, int ldc)
     * }
     */
    public static FunctionDescriptor LAPACKE_cgemqrt$descriptor() {
        return LAPACKE_cgemqrt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cgemqrt(int matrix_layout, char side, char trans, int m, int n, int k, int nb, const _Complex float *v, int ldv, const _Complex float *t, int ldt, _Complex float *c, int ldc)
     * }
     */
    public static MethodHandle LAPACKE_cgemqrt$handle() {
        return LAPACKE_cgemqrt.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cgemqrt(int matrix_layout, char side, char trans, int m, int n, int k, int nb, const _Complex float *v, int ldv, const _Complex float *t, int ldt, _Complex float *c, int ldc)
     * }
     */
    public static MemorySegment LAPACKE_cgemqrt$address() {
        return LAPACKE_cgemqrt.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cgemqrt(int matrix_layout, char side, char trans, int m, int n, int k, int nb, const _Complex float *v, int ldv, const _Complex float *t, int ldt, _Complex float *c, int ldc)
     * }
     */
    public static int LAPACKE_cgemqrt(int matrix_layout, byte side, byte trans, int m, int n, int k, int nb, MemorySegment v, int ldv, MemorySegment t, int ldt, MemorySegment c, int ldc) {
        var mh$ = LAPACKE_cgemqrt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cgemqrt", matrix_layout, side, trans, m, n, k, nb, v, ldv, t, ldt, c, ldc);
            }
            return (int)mh$.invokeExact(matrix_layout, side, trans, m, n, k, nb, v, ldv, t, ldt, c, ldc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zgemqrt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zgemqrt");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zgemqrt(int matrix_layout, char side, char trans, int m, int n, int k, int nb, const _Complex double *v, int ldv, const _Complex double *t, int ldt, _Complex double *c, int ldc)
     * }
     */
    public static FunctionDescriptor LAPACKE_zgemqrt$descriptor() {
        return LAPACKE_zgemqrt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zgemqrt(int matrix_layout, char side, char trans, int m, int n, int k, int nb, const _Complex double *v, int ldv, const _Complex double *t, int ldt, _Complex double *c, int ldc)
     * }
     */
    public static MethodHandle LAPACKE_zgemqrt$handle() {
        return LAPACKE_zgemqrt.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zgemqrt(int matrix_layout, char side, char trans, int m, int n, int k, int nb, const _Complex double *v, int ldv, const _Complex double *t, int ldt, _Complex double *c, int ldc)
     * }
     */
    public static MemorySegment LAPACKE_zgemqrt$address() {
        return LAPACKE_zgemqrt.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zgemqrt(int matrix_layout, char side, char trans, int m, int n, int k, int nb, const _Complex double *v, int ldv, const _Complex double *t, int ldt, _Complex double *c, int ldc)
     * }
     */
    public static int LAPACKE_zgemqrt(int matrix_layout, byte side, byte trans, int m, int n, int k, int nb, MemorySegment v, int ldv, MemorySegment t, int ldt, MemorySegment c, int ldc) {
        var mh$ = LAPACKE_zgemqrt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zgemqrt", matrix_layout, side, trans, m, n, k, nb, v, ldv, t, ldt, c, ldc);
            }
            return (int)mh$.invokeExact(matrix_layout, side, trans, m, n, k, nb, v, ldv, t, ldt, c, ldc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sgeqrt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_sgeqrt");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sgeqrt(int matrix_layout, int m, int n, int nb, float *a, int lda, float *t, int ldt)
     * }
     */
    public static FunctionDescriptor LAPACKE_sgeqrt$descriptor() {
        return LAPACKE_sgeqrt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sgeqrt(int matrix_layout, int m, int n, int nb, float *a, int lda, float *t, int ldt)
     * }
     */
    public static MethodHandle LAPACKE_sgeqrt$handle() {
        return LAPACKE_sgeqrt.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sgeqrt(int matrix_layout, int m, int n, int nb, float *a, int lda, float *t, int ldt)
     * }
     */
    public static MemorySegment LAPACKE_sgeqrt$address() {
        return LAPACKE_sgeqrt.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sgeqrt(int matrix_layout, int m, int n, int nb, float *a, int lda, float *t, int ldt)
     * }
     */
    public static int LAPACKE_sgeqrt(int matrix_layout, int m, int n, int nb, MemorySegment a, int lda, MemorySegment t, int ldt) {
        var mh$ = LAPACKE_sgeqrt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sgeqrt", matrix_layout, m, n, nb, a, lda, t, ldt);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, nb, a, lda, t, ldt);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dgeqrt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dgeqrt");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dgeqrt(int matrix_layout, int m, int n, int nb, double *a, int lda, double *t, int ldt)
     * }
     */
    public static FunctionDescriptor LAPACKE_dgeqrt$descriptor() {
        return LAPACKE_dgeqrt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dgeqrt(int matrix_layout, int m, int n, int nb, double *a, int lda, double *t, int ldt)
     * }
     */
    public static MethodHandle LAPACKE_dgeqrt$handle() {
        return LAPACKE_dgeqrt.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dgeqrt(int matrix_layout, int m, int n, int nb, double *a, int lda, double *t, int ldt)
     * }
     */
    public static MemorySegment LAPACKE_dgeqrt$address() {
        return LAPACKE_dgeqrt.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dgeqrt(int matrix_layout, int m, int n, int nb, double *a, int lda, double *t, int ldt)
     * }
     */
    public static int LAPACKE_dgeqrt(int matrix_layout, int m, int n, int nb, MemorySegment a, int lda, MemorySegment t, int ldt) {
        var mh$ = LAPACKE_dgeqrt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dgeqrt", matrix_layout, m, n, nb, a, lda, t, ldt);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, nb, a, lda, t, ldt);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cgeqrt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_cgeqrt");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cgeqrt(int matrix_layout, int m, int n, int nb, _Complex float *a, int lda, _Complex float *t, int ldt)
     * }
     */
    public static FunctionDescriptor LAPACKE_cgeqrt$descriptor() {
        return LAPACKE_cgeqrt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cgeqrt(int matrix_layout, int m, int n, int nb, _Complex float *a, int lda, _Complex float *t, int ldt)
     * }
     */
    public static MethodHandle LAPACKE_cgeqrt$handle() {
        return LAPACKE_cgeqrt.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cgeqrt(int matrix_layout, int m, int n, int nb, _Complex float *a, int lda, _Complex float *t, int ldt)
     * }
     */
    public static MemorySegment LAPACKE_cgeqrt$address() {
        return LAPACKE_cgeqrt.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cgeqrt(int matrix_layout, int m, int n, int nb, _Complex float *a, int lda, _Complex float *t, int ldt)
     * }
     */
    public static int LAPACKE_cgeqrt(int matrix_layout, int m, int n, int nb, MemorySegment a, int lda, MemorySegment t, int ldt) {
        var mh$ = LAPACKE_cgeqrt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cgeqrt", matrix_layout, m, n, nb, a, lda, t, ldt);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, nb, a, lda, t, ldt);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zgeqrt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zgeqrt");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zgeqrt(int matrix_layout, int m, int n, int nb, _Complex double *a, int lda, _Complex double *t, int ldt)
     * }
     */
    public static FunctionDescriptor LAPACKE_zgeqrt$descriptor() {
        return LAPACKE_zgeqrt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zgeqrt(int matrix_layout, int m, int n, int nb, _Complex double *a, int lda, _Complex double *t, int ldt)
     * }
     */
    public static MethodHandle LAPACKE_zgeqrt$handle() {
        return LAPACKE_zgeqrt.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zgeqrt(int matrix_layout, int m, int n, int nb, _Complex double *a, int lda, _Complex double *t, int ldt)
     * }
     */
    public static MemorySegment LAPACKE_zgeqrt$address() {
        return LAPACKE_zgeqrt.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zgeqrt(int matrix_layout, int m, int n, int nb, _Complex double *a, int lda, _Complex double *t, int ldt)
     * }
     */
    public static int LAPACKE_zgeqrt(int matrix_layout, int m, int n, int nb, MemorySegment a, int lda, MemorySegment t, int ldt) {
        var mh$ = LAPACKE_zgeqrt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zgeqrt", matrix_layout, m, n, nb, a, lda, t, ldt);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, nb, a, lda, t, ldt);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sgeqrt2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_sgeqrt2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sgeqrt2(int matrix_layout, int m, int n, float *a, int lda, float *t, int ldt)
     * }
     */
    public static FunctionDescriptor LAPACKE_sgeqrt2$descriptor() {
        return LAPACKE_sgeqrt2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sgeqrt2(int matrix_layout, int m, int n, float *a, int lda, float *t, int ldt)
     * }
     */
    public static MethodHandle LAPACKE_sgeqrt2$handle() {
        return LAPACKE_sgeqrt2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sgeqrt2(int matrix_layout, int m, int n, float *a, int lda, float *t, int ldt)
     * }
     */
    public static MemorySegment LAPACKE_sgeqrt2$address() {
        return LAPACKE_sgeqrt2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sgeqrt2(int matrix_layout, int m, int n, float *a, int lda, float *t, int ldt)
     * }
     */
    public static int LAPACKE_sgeqrt2(int matrix_layout, int m, int n, MemorySegment a, int lda, MemorySegment t, int ldt) {
        var mh$ = LAPACKE_sgeqrt2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sgeqrt2", matrix_layout, m, n, a, lda, t, ldt);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, a, lda, t, ldt);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dgeqrt2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dgeqrt2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dgeqrt2(int matrix_layout, int m, int n, double *a, int lda, double *t, int ldt)
     * }
     */
    public static FunctionDescriptor LAPACKE_dgeqrt2$descriptor() {
        return LAPACKE_dgeqrt2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dgeqrt2(int matrix_layout, int m, int n, double *a, int lda, double *t, int ldt)
     * }
     */
    public static MethodHandle LAPACKE_dgeqrt2$handle() {
        return LAPACKE_dgeqrt2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dgeqrt2(int matrix_layout, int m, int n, double *a, int lda, double *t, int ldt)
     * }
     */
    public static MemorySegment LAPACKE_dgeqrt2$address() {
        return LAPACKE_dgeqrt2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dgeqrt2(int matrix_layout, int m, int n, double *a, int lda, double *t, int ldt)
     * }
     */
    public static int LAPACKE_dgeqrt2(int matrix_layout, int m, int n, MemorySegment a, int lda, MemorySegment t, int ldt) {
        var mh$ = LAPACKE_dgeqrt2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dgeqrt2", matrix_layout, m, n, a, lda, t, ldt);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, a, lda, t, ldt);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cgeqrt2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_cgeqrt2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cgeqrt2(int matrix_layout, int m, int n, _Complex float *a, int lda, _Complex float *t, int ldt)
     * }
     */
    public static FunctionDescriptor LAPACKE_cgeqrt2$descriptor() {
        return LAPACKE_cgeqrt2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cgeqrt2(int matrix_layout, int m, int n, _Complex float *a, int lda, _Complex float *t, int ldt)
     * }
     */
    public static MethodHandle LAPACKE_cgeqrt2$handle() {
        return LAPACKE_cgeqrt2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cgeqrt2(int matrix_layout, int m, int n, _Complex float *a, int lda, _Complex float *t, int ldt)
     * }
     */
    public static MemorySegment LAPACKE_cgeqrt2$address() {
        return LAPACKE_cgeqrt2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cgeqrt2(int matrix_layout, int m, int n, _Complex float *a, int lda, _Complex float *t, int ldt)
     * }
     */
    public static int LAPACKE_cgeqrt2(int matrix_layout, int m, int n, MemorySegment a, int lda, MemorySegment t, int ldt) {
        var mh$ = LAPACKE_cgeqrt2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cgeqrt2", matrix_layout, m, n, a, lda, t, ldt);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, a, lda, t, ldt);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zgeqrt2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zgeqrt2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zgeqrt2(int matrix_layout, int m, int n, _Complex double *a, int lda, _Complex double *t, int ldt)
     * }
     */
    public static FunctionDescriptor LAPACKE_zgeqrt2$descriptor() {
        return LAPACKE_zgeqrt2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zgeqrt2(int matrix_layout, int m, int n, _Complex double *a, int lda, _Complex double *t, int ldt)
     * }
     */
    public static MethodHandle LAPACKE_zgeqrt2$handle() {
        return LAPACKE_zgeqrt2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zgeqrt2(int matrix_layout, int m, int n, _Complex double *a, int lda, _Complex double *t, int ldt)
     * }
     */
    public static MemorySegment LAPACKE_zgeqrt2$address() {
        return LAPACKE_zgeqrt2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zgeqrt2(int matrix_layout, int m, int n, _Complex double *a, int lda, _Complex double *t, int ldt)
     * }
     */
    public static int LAPACKE_zgeqrt2(int matrix_layout, int m, int n, MemorySegment a, int lda, MemorySegment t, int ldt) {
        var mh$ = LAPACKE_zgeqrt2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zgeqrt2", matrix_layout, m, n, a, lda, t, ldt);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, a, lda, t, ldt);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sgeqrt3 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_sgeqrt3");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sgeqrt3(int matrix_layout, int m, int n, float *a, int lda, float *t, int ldt)
     * }
     */
    public static FunctionDescriptor LAPACKE_sgeqrt3$descriptor() {
        return LAPACKE_sgeqrt3.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sgeqrt3(int matrix_layout, int m, int n, float *a, int lda, float *t, int ldt)
     * }
     */
    public static MethodHandle LAPACKE_sgeqrt3$handle() {
        return LAPACKE_sgeqrt3.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sgeqrt3(int matrix_layout, int m, int n, float *a, int lda, float *t, int ldt)
     * }
     */
    public static MemorySegment LAPACKE_sgeqrt3$address() {
        return LAPACKE_sgeqrt3.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sgeqrt3(int matrix_layout, int m, int n, float *a, int lda, float *t, int ldt)
     * }
     */
    public static int LAPACKE_sgeqrt3(int matrix_layout, int m, int n, MemorySegment a, int lda, MemorySegment t, int ldt) {
        var mh$ = LAPACKE_sgeqrt3.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sgeqrt3", matrix_layout, m, n, a, lda, t, ldt);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, a, lda, t, ldt);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dgeqrt3 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dgeqrt3");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dgeqrt3(int matrix_layout, int m, int n, double *a, int lda, double *t, int ldt)
     * }
     */
    public static FunctionDescriptor LAPACKE_dgeqrt3$descriptor() {
        return LAPACKE_dgeqrt3.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dgeqrt3(int matrix_layout, int m, int n, double *a, int lda, double *t, int ldt)
     * }
     */
    public static MethodHandle LAPACKE_dgeqrt3$handle() {
        return LAPACKE_dgeqrt3.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dgeqrt3(int matrix_layout, int m, int n, double *a, int lda, double *t, int ldt)
     * }
     */
    public static MemorySegment LAPACKE_dgeqrt3$address() {
        return LAPACKE_dgeqrt3.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dgeqrt3(int matrix_layout, int m, int n, double *a, int lda, double *t, int ldt)
     * }
     */
    public static int LAPACKE_dgeqrt3(int matrix_layout, int m, int n, MemorySegment a, int lda, MemorySegment t, int ldt) {
        var mh$ = LAPACKE_dgeqrt3.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dgeqrt3", matrix_layout, m, n, a, lda, t, ldt);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, a, lda, t, ldt);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cgeqrt3 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_cgeqrt3");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cgeqrt3(int matrix_layout, int m, int n, _Complex float *a, int lda, _Complex float *t, int ldt)
     * }
     */
    public static FunctionDescriptor LAPACKE_cgeqrt3$descriptor() {
        return LAPACKE_cgeqrt3.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cgeqrt3(int matrix_layout, int m, int n, _Complex float *a, int lda, _Complex float *t, int ldt)
     * }
     */
    public static MethodHandle LAPACKE_cgeqrt3$handle() {
        return LAPACKE_cgeqrt3.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cgeqrt3(int matrix_layout, int m, int n, _Complex float *a, int lda, _Complex float *t, int ldt)
     * }
     */
    public static MemorySegment LAPACKE_cgeqrt3$address() {
        return LAPACKE_cgeqrt3.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cgeqrt3(int matrix_layout, int m, int n, _Complex float *a, int lda, _Complex float *t, int ldt)
     * }
     */
    public static int LAPACKE_cgeqrt3(int matrix_layout, int m, int n, MemorySegment a, int lda, MemorySegment t, int ldt) {
        var mh$ = LAPACKE_cgeqrt3.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cgeqrt3", matrix_layout, m, n, a, lda, t, ldt);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, a, lda, t, ldt);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zgeqrt3 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zgeqrt3");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zgeqrt3(int matrix_layout, int m, int n, _Complex double *a, int lda, _Complex double *t, int ldt)
     * }
     */
    public static FunctionDescriptor LAPACKE_zgeqrt3$descriptor() {
        return LAPACKE_zgeqrt3.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zgeqrt3(int matrix_layout, int m, int n, _Complex double *a, int lda, _Complex double *t, int ldt)
     * }
     */
    public static MethodHandle LAPACKE_zgeqrt3$handle() {
        return LAPACKE_zgeqrt3.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zgeqrt3(int matrix_layout, int m, int n, _Complex double *a, int lda, _Complex double *t, int ldt)
     * }
     */
    public static MemorySegment LAPACKE_zgeqrt3$address() {
        return LAPACKE_zgeqrt3.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zgeqrt3(int matrix_layout, int m, int n, _Complex double *a, int lda, _Complex double *t, int ldt)
     * }
     */
    public static int LAPACKE_zgeqrt3(int matrix_layout, int m, int n, MemorySegment a, int lda, MemorySegment t, int ldt) {
        var mh$ = LAPACKE_zgeqrt3.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zgeqrt3", matrix_layout, m, n, a, lda, t, ldt);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, a, lda, t, ldt);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_stpmqrt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_stpmqrt");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_stpmqrt(int matrix_layout, char side, char trans, int m, int n, int k, int l, int nb, const float *v, int ldv, const float *t, int ldt, float *a, int lda, float *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_stpmqrt$descriptor() {
        return LAPACKE_stpmqrt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_stpmqrt(int matrix_layout, char side, char trans, int m, int n, int k, int l, int nb, const float *v, int ldv, const float *t, int ldt, float *a, int lda, float *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_stpmqrt$handle() {
        return LAPACKE_stpmqrt.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_stpmqrt(int matrix_layout, char side, char trans, int m, int n, int k, int l, int nb, const float *v, int ldv, const float *t, int ldt, float *a, int lda, float *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_stpmqrt$address() {
        return LAPACKE_stpmqrt.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_stpmqrt(int matrix_layout, char side, char trans, int m, int n, int k, int l, int nb, const float *v, int ldv, const float *t, int ldt, float *a, int lda, float *b, int ldb)
     * }
     */
    public static int LAPACKE_stpmqrt(int matrix_layout, byte side, byte trans, int m, int n, int k, int l, int nb, MemorySegment v, int ldv, MemorySegment t, int ldt, MemorySegment a, int lda, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_stpmqrt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_stpmqrt", matrix_layout, side, trans, m, n, k, l, nb, v, ldv, t, ldt, a, lda, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, side, trans, m, n, k, l, nb, v, ldv, t, ldt, a, lda, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dtpmqrt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dtpmqrt");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dtpmqrt(int matrix_layout, char side, char trans, int m, int n, int k, int l, int nb, const double *v, int ldv, const double *t, int ldt, double *a, int lda, double *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_dtpmqrt$descriptor() {
        return LAPACKE_dtpmqrt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dtpmqrt(int matrix_layout, char side, char trans, int m, int n, int k, int l, int nb, const double *v, int ldv, const double *t, int ldt, double *a, int lda, double *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_dtpmqrt$handle() {
        return LAPACKE_dtpmqrt.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dtpmqrt(int matrix_layout, char side, char trans, int m, int n, int k, int l, int nb, const double *v, int ldv, const double *t, int ldt, double *a, int lda, double *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_dtpmqrt$address() {
        return LAPACKE_dtpmqrt.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dtpmqrt(int matrix_layout, char side, char trans, int m, int n, int k, int l, int nb, const double *v, int ldv, const double *t, int ldt, double *a, int lda, double *b, int ldb)
     * }
     */
    public static int LAPACKE_dtpmqrt(int matrix_layout, byte side, byte trans, int m, int n, int k, int l, int nb, MemorySegment v, int ldv, MemorySegment t, int ldt, MemorySegment a, int lda, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_dtpmqrt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dtpmqrt", matrix_layout, side, trans, m, n, k, l, nb, v, ldv, t, ldt, a, lda, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, side, trans, m, n, k, l, nb, v, ldv, t, ldt, a, lda, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ctpmqrt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_ctpmqrt");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ctpmqrt(int matrix_layout, char side, char trans, int m, int n, int k, int l, int nb, const _Complex float *v, int ldv, const _Complex float *t, int ldt, _Complex float *a, int lda, _Complex float *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_ctpmqrt$descriptor() {
        return LAPACKE_ctpmqrt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ctpmqrt(int matrix_layout, char side, char trans, int m, int n, int k, int l, int nb, const _Complex float *v, int ldv, const _Complex float *t, int ldt, _Complex float *a, int lda, _Complex float *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_ctpmqrt$handle() {
        return LAPACKE_ctpmqrt.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ctpmqrt(int matrix_layout, char side, char trans, int m, int n, int k, int l, int nb, const _Complex float *v, int ldv, const _Complex float *t, int ldt, _Complex float *a, int lda, _Complex float *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_ctpmqrt$address() {
        return LAPACKE_ctpmqrt.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ctpmqrt(int matrix_layout, char side, char trans, int m, int n, int k, int l, int nb, const _Complex float *v, int ldv, const _Complex float *t, int ldt, _Complex float *a, int lda, _Complex float *b, int ldb)
     * }
     */
    public static int LAPACKE_ctpmqrt(int matrix_layout, byte side, byte trans, int m, int n, int k, int l, int nb, MemorySegment v, int ldv, MemorySegment t, int ldt, MemorySegment a, int lda, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_ctpmqrt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ctpmqrt", matrix_layout, side, trans, m, n, k, l, nb, v, ldv, t, ldt, a, lda, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, side, trans, m, n, k, l, nb, v, ldv, t, ldt, a, lda, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ztpmqrt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_ztpmqrt");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ztpmqrt(int matrix_layout, char side, char trans, int m, int n, int k, int l, int nb, const _Complex double *v, int ldv, const _Complex double *t, int ldt, _Complex double *a, int lda, _Complex double *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_ztpmqrt$descriptor() {
        return LAPACKE_ztpmqrt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ztpmqrt(int matrix_layout, char side, char trans, int m, int n, int k, int l, int nb, const _Complex double *v, int ldv, const _Complex double *t, int ldt, _Complex double *a, int lda, _Complex double *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_ztpmqrt$handle() {
        return LAPACKE_ztpmqrt.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ztpmqrt(int matrix_layout, char side, char trans, int m, int n, int k, int l, int nb, const _Complex double *v, int ldv, const _Complex double *t, int ldt, _Complex double *a, int lda, _Complex double *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_ztpmqrt$address() {
        return LAPACKE_ztpmqrt.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ztpmqrt(int matrix_layout, char side, char trans, int m, int n, int k, int l, int nb, const _Complex double *v, int ldv, const _Complex double *t, int ldt, _Complex double *a, int lda, _Complex double *b, int ldb)
     * }
     */
    public static int LAPACKE_ztpmqrt(int matrix_layout, byte side, byte trans, int m, int n, int k, int l, int nb, MemorySegment v, int ldv, MemorySegment t, int ldt, MemorySegment a, int lda, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_ztpmqrt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ztpmqrt", matrix_layout, side, trans, m, n, k, l, nb, v, ldv, t, ldt, a, lda, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, side, trans, m, n, k, l, nb, v, ldv, t, ldt, a, lda, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_stpqrt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_stpqrt");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_stpqrt(int matrix_layout, int m, int n, int l, int nb, float *a, int lda, float *b, int ldb, float *t, int ldt)
     * }
     */
    public static FunctionDescriptor LAPACKE_stpqrt$descriptor() {
        return LAPACKE_stpqrt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_stpqrt(int matrix_layout, int m, int n, int l, int nb, float *a, int lda, float *b, int ldb, float *t, int ldt)
     * }
     */
    public static MethodHandle LAPACKE_stpqrt$handle() {
        return LAPACKE_stpqrt.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_stpqrt(int matrix_layout, int m, int n, int l, int nb, float *a, int lda, float *b, int ldb, float *t, int ldt)
     * }
     */
    public static MemorySegment LAPACKE_stpqrt$address() {
        return LAPACKE_stpqrt.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_stpqrt(int matrix_layout, int m, int n, int l, int nb, float *a, int lda, float *b, int ldb, float *t, int ldt)
     * }
     */
    public static int LAPACKE_stpqrt(int matrix_layout, int m, int n, int l, int nb, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment t, int ldt) {
        var mh$ = LAPACKE_stpqrt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_stpqrt", matrix_layout, m, n, l, nb, a, lda, b, ldb, t, ldt);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, l, nb, a, lda, b, ldb, t, ldt);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dtpqrt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dtpqrt");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dtpqrt(int matrix_layout, int m, int n, int l, int nb, double *a, int lda, double *b, int ldb, double *t, int ldt)
     * }
     */
    public static FunctionDescriptor LAPACKE_dtpqrt$descriptor() {
        return LAPACKE_dtpqrt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dtpqrt(int matrix_layout, int m, int n, int l, int nb, double *a, int lda, double *b, int ldb, double *t, int ldt)
     * }
     */
    public static MethodHandle LAPACKE_dtpqrt$handle() {
        return LAPACKE_dtpqrt.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dtpqrt(int matrix_layout, int m, int n, int l, int nb, double *a, int lda, double *b, int ldb, double *t, int ldt)
     * }
     */
    public static MemorySegment LAPACKE_dtpqrt$address() {
        return LAPACKE_dtpqrt.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dtpqrt(int matrix_layout, int m, int n, int l, int nb, double *a, int lda, double *b, int ldb, double *t, int ldt)
     * }
     */
    public static int LAPACKE_dtpqrt(int matrix_layout, int m, int n, int l, int nb, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment t, int ldt) {
        var mh$ = LAPACKE_dtpqrt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dtpqrt", matrix_layout, m, n, l, nb, a, lda, b, ldb, t, ldt);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, l, nb, a, lda, b, ldb, t, ldt);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ctpqrt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_ctpqrt");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ctpqrt(int matrix_layout, int m, int n, int l, int nb, _Complex float *a, int lda, _Complex float *b, int ldb, _Complex float *t, int ldt)
     * }
     */
    public static FunctionDescriptor LAPACKE_ctpqrt$descriptor() {
        return LAPACKE_ctpqrt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ctpqrt(int matrix_layout, int m, int n, int l, int nb, _Complex float *a, int lda, _Complex float *b, int ldb, _Complex float *t, int ldt)
     * }
     */
    public static MethodHandle LAPACKE_ctpqrt$handle() {
        return LAPACKE_ctpqrt.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ctpqrt(int matrix_layout, int m, int n, int l, int nb, _Complex float *a, int lda, _Complex float *b, int ldb, _Complex float *t, int ldt)
     * }
     */
    public static MemorySegment LAPACKE_ctpqrt$address() {
        return LAPACKE_ctpqrt.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ctpqrt(int matrix_layout, int m, int n, int l, int nb, _Complex float *a, int lda, _Complex float *b, int ldb, _Complex float *t, int ldt)
     * }
     */
    public static int LAPACKE_ctpqrt(int matrix_layout, int m, int n, int l, int nb, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment t, int ldt) {
        var mh$ = LAPACKE_ctpqrt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ctpqrt", matrix_layout, m, n, l, nb, a, lda, b, ldb, t, ldt);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, l, nb, a, lda, b, ldb, t, ldt);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ztpqrt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_ztpqrt");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ztpqrt(int matrix_layout, int m, int n, int l, int nb, _Complex double *a, int lda, _Complex double *b, int ldb, _Complex double *t, int ldt)
     * }
     */
    public static FunctionDescriptor LAPACKE_ztpqrt$descriptor() {
        return LAPACKE_ztpqrt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ztpqrt(int matrix_layout, int m, int n, int l, int nb, _Complex double *a, int lda, _Complex double *b, int ldb, _Complex double *t, int ldt)
     * }
     */
    public static MethodHandle LAPACKE_ztpqrt$handle() {
        return LAPACKE_ztpqrt.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ztpqrt(int matrix_layout, int m, int n, int l, int nb, _Complex double *a, int lda, _Complex double *b, int ldb, _Complex double *t, int ldt)
     * }
     */
    public static MemorySegment LAPACKE_ztpqrt$address() {
        return LAPACKE_ztpqrt.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ztpqrt(int matrix_layout, int m, int n, int l, int nb, _Complex double *a, int lda, _Complex double *b, int ldb, _Complex double *t, int ldt)
     * }
     */
    public static int LAPACKE_ztpqrt(int matrix_layout, int m, int n, int l, int nb, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment t, int ldt) {
        var mh$ = LAPACKE_ztpqrt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ztpqrt", matrix_layout, m, n, l, nb, a, lda, b, ldb, t, ldt);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, l, nb, a, lda, b, ldb, t, ldt);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_stpqrt2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_stpqrt2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_stpqrt2(int matrix_layout, int m, int n, int l, float *a, int lda, float *b, int ldb, float *t, int ldt)
     * }
     */
    public static FunctionDescriptor LAPACKE_stpqrt2$descriptor() {
        return LAPACKE_stpqrt2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_stpqrt2(int matrix_layout, int m, int n, int l, float *a, int lda, float *b, int ldb, float *t, int ldt)
     * }
     */
    public static MethodHandle LAPACKE_stpqrt2$handle() {
        return LAPACKE_stpqrt2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_stpqrt2(int matrix_layout, int m, int n, int l, float *a, int lda, float *b, int ldb, float *t, int ldt)
     * }
     */
    public static MemorySegment LAPACKE_stpqrt2$address() {
        return LAPACKE_stpqrt2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_stpqrt2(int matrix_layout, int m, int n, int l, float *a, int lda, float *b, int ldb, float *t, int ldt)
     * }
     */
    public static int LAPACKE_stpqrt2(int matrix_layout, int m, int n, int l, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment t, int ldt) {
        var mh$ = LAPACKE_stpqrt2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_stpqrt2", matrix_layout, m, n, l, a, lda, b, ldb, t, ldt);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, l, a, lda, b, ldb, t, ldt);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dtpqrt2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dtpqrt2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dtpqrt2(int matrix_layout, int m, int n, int l, double *a, int lda, double *b, int ldb, double *t, int ldt)
     * }
     */
    public static FunctionDescriptor LAPACKE_dtpqrt2$descriptor() {
        return LAPACKE_dtpqrt2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dtpqrt2(int matrix_layout, int m, int n, int l, double *a, int lda, double *b, int ldb, double *t, int ldt)
     * }
     */
    public static MethodHandle LAPACKE_dtpqrt2$handle() {
        return LAPACKE_dtpqrt2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dtpqrt2(int matrix_layout, int m, int n, int l, double *a, int lda, double *b, int ldb, double *t, int ldt)
     * }
     */
    public static MemorySegment LAPACKE_dtpqrt2$address() {
        return LAPACKE_dtpqrt2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dtpqrt2(int matrix_layout, int m, int n, int l, double *a, int lda, double *b, int ldb, double *t, int ldt)
     * }
     */
    public static int LAPACKE_dtpqrt2(int matrix_layout, int m, int n, int l, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment t, int ldt) {
        var mh$ = LAPACKE_dtpqrt2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dtpqrt2", matrix_layout, m, n, l, a, lda, b, ldb, t, ldt);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, l, a, lda, b, ldb, t, ldt);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ctpqrt2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_ctpqrt2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ctpqrt2(int matrix_layout, int m, int n, int l, _Complex float *a, int lda, _Complex float *b, int ldb, _Complex float *t, int ldt)
     * }
     */
    public static FunctionDescriptor LAPACKE_ctpqrt2$descriptor() {
        return LAPACKE_ctpqrt2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ctpqrt2(int matrix_layout, int m, int n, int l, _Complex float *a, int lda, _Complex float *b, int ldb, _Complex float *t, int ldt)
     * }
     */
    public static MethodHandle LAPACKE_ctpqrt2$handle() {
        return LAPACKE_ctpqrt2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ctpqrt2(int matrix_layout, int m, int n, int l, _Complex float *a, int lda, _Complex float *b, int ldb, _Complex float *t, int ldt)
     * }
     */
    public static MemorySegment LAPACKE_ctpqrt2$address() {
        return LAPACKE_ctpqrt2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ctpqrt2(int matrix_layout, int m, int n, int l, _Complex float *a, int lda, _Complex float *b, int ldb, _Complex float *t, int ldt)
     * }
     */
    public static int LAPACKE_ctpqrt2(int matrix_layout, int m, int n, int l, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment t, int ldt) {
        var mh$ = LAPACKE_ctpqrt2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ctpqrt2", matrix_layout, m, n, l, a, lda, b, ldb, t, ldt);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, l, a, lda, b, ldb, t, ldt);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ztpqrt2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_ztpqrt2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ztpqrt2(int matrix_layout, int m, int n, int l, _Complex double *a, int lda, _Complex double *b, int ldb, _Complex double *t, int ldt)
     * }
     */
    public static FunctionDescriptor LAPACKE_ztpqrt2$descriptor() {
        return LAPACKE_ztpqrt2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ztpqrt2(int matrix_layout, int m, int n, int l, _Complex double *a, int lda, _Complex double *b, int ldb, _Complex double *t, int ldt)
     * }
     */
    public static MethodHandle LAPACKE_ztpqrt2$handle() {
        return LAPACKE_ztpqrt2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ztpqrt2(int matrix_layout, int m, int n, int l, _Complex double *a, int lda, _Complex double *b, int ldb, _Complex double *t, int ldt)
     * }
     */
    public static MemorySegment LAPACKE_ztpqrt2$address() {
        return LAPACKE_ztpqrt2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ztpqrt2(int matrix_layout, int m, int n, int l, _Complex double *a, int lda, _Complex double *b, int ldb, _Complex double *t, int ldt)
     * }
     */
    public static int LAPACKE_ztpqrt2(int matrix_layout, int m, int n, int l, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment t, int ldt) {
        var mh$ = LAPACKE_ztpqrt2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ztpqrt2", matrix_layout, m, n, l, a, lda, b, ldb, t, ldt);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, l, a, lda, b, ldb, t, ldt);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_stprfb {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_stprfb");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_stprfb(int matrix_layout, char side, char trans, char direct, char storev, int m, int n, int k, int l, const float *v, int ldv, const float *t, int ldt, float *a, int lda, float *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_stprfb$descriptor() {
        return LAPACKE_stprfb.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_stprfb(int matrix_layout, char side, char trans, char direct, char storev, int m, int n, int k, int l, const float *v, int ldv, const float *t, int ldt, float *a, int lda, float *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_stprfb$handle() {
        return LAPACKE_stprfb.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_stprfb(int matrix_layout, char side, char trans, char direct, char storev, int m, int n, int k, int l, const float *v, int ldv, const float *t, int ldt, float *a, int lda, float *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_stprfb$address() {
        return LAPACKE_stprfb.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_stprfb(int matrix_layout, char side, char trans, char direct, char storev, int m, int n, int k, int l, const float *v, int ldv, const float *t, int ldt, float *a, int lda, float *b, int ldb)
     * }
     */
    public static int LAPACKE_stprfb(int matrix_layout, byte side, byte trans, byte direct, byte storev, int m, int n, int k, int l, MemorySegment v, int ldv, MemorySegment t, int ldt, MemorySegment a, int lda, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_stprfb.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_stprfb", matrix_layout, side, trans, direct, storev, m, n, k, l, v, ldv, t, ldt, a, lda, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, side, trans, direct, storev, m, n, k, l, v, ldv, t, ldt, a, lda, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dtprfb {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dtprfb");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dtprfb(int matrix_layout, char side, char trans, char direct, char storev, int m, int n, int k, int l, const double *v, int ldv, const double *t, int ldt, double *a, int lda, double *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_dtprfb$descriptor() {
        return LAPACKE_dtprfb.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dtprfb(int matrix_layout, char side, char trans, char direct, char storev, int m, int n, int k, int l, const double *v, int ldv, const double *t, int ldt, double *a, int lda, double *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_dtprfb$handle() {
        return LAPACKE_dtprfb.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dtprfb(int matrix_layout, char side, char trans, char direct, char storev, int m, int n, int k, int l, const double *v, int ldv, const double *t, int ldt, double *a, int lda, double *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_dtprfb$address() {
        return LAPACKE_dtprfb.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dtprfb(int matrix_layout, char side, char trans, char direct, char storev, int m, int n, int k, int l, const double *v, int ldv, const double *t, int ldt, double *a, int lda, double *b, int ldb)
     * }
     */
    public static int LAPACKE_dtprfb(int matrix_layout, byte side, byte trans, byte direct, byte storev, int m, int n, int k, int l, MemorySegment v, int ldv, MemorySegment t, int ldt, MemorySegment a, int lda, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_dtprfb.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dtprfb", matrix_layout, side, trans, direct, storev, m, n, k, l, v, ldv, t, ldt, a, lda, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, side, trans, direct, storev, m, n, k, l, v, ldv, t, ldt, a, lda, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ctprfb {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_ctprfb");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ctprfb(int matrix_layout, char side, char trans, char direct, char storev, int m, int n, int k, int l, const _Complex float *v, int ldv, const _Complex float *t, int ldt, _Complex float *a, int lda, _Complex float *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_ctprfb$descriptor() {
        return LAPACKE_ctprfb.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ctprfb(int matrix_layout, char side, char trans, char direct, char storev, int m, int n, int k, int l, const _Complex float *v, int ldv, const _Complex float *t, int ldt, _Complex float *a, int lda, _Complex float *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_ctprfb$handle() {
        return LAPACKE_ctprfb.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ctprfb(int matrix_layout, char side, char trans, char direct, char storev, int m, int n, int k, int l, const _Complex float *v, int ldv, const _Complex float *t, int ldt, _Complex float *a, int lda, _Complex float *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_ctprfb$address() {
        return LAPACKE_ctprfb.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ctprfb(int matrix_layout, char side, char trans, char direct, char storev, int m, int n, int k, int l, const _Complex float *v, int ldv, const _Complex float *t, int ldt, _Complex float *a, int lda, _Complex float *b, int ldb)
     * }
     */
    public static int LAPACKE_ctprfb(int matrix_layout, byte side, byte trans, byte direct, byte storev, int m, int n, int k, int l, MemorySegment v, int ldv, MemorySegment t, int ldt, MemorySegment a, int lda, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_ctprfb.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ctprfb", matrix_layout, side, trans, direct, storev, m, n, k, l, v, ldv, t, ldt, a, lda, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, side, trans, direct, storev, m, n, k, l, v, ldv, t, ldt, a, lda, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ztprfb {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_ztprfb");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ztprfb(int matrix_layout, char side, char trans, char direct, char storev, int m, int n, int k, int l, const _Complex double *v, int ldv, const _Complex double *t, int ldt, _Complex double *a, int lda, _Complex double *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_ztprfb$descriptor() {
        return LAPACKE_ztprfb.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ztprfb(int matrix_layout, char side, char trans, char direct, char storev, int m, int n, int k, int l, const _Complex double *v, int ldv, const _Complex double *t, int ldt, _Complex double *a, int lda, _Complex double *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_ztprfb$handle() {
        return LAPACKE_ztprfb.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ztprfb(int matrix_layout, char side, char trans, char direct, char storev, int m, int n, int k, int l, const _Complex double *v, int ldv, const _Complex double *t, int ldt, _Complex double *a, int lda, _Complex double *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_ztprfb$address() {
        return LAPACKE_ztprfb.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ztprfb(int matrix_layout, char side, char trans, char direct, char storev, int m, int n, int k, int l, const _Complex double *v, int ldv, const _Complex double *t, int ldt, _Complex double *a, int lda, _Complex double *b, int ldb)
     * }
     */
    public static int LAPACKE_ztprfb(int matrix_layout, byte side, byte trans, byte direct, byte storev, int m, int n, int k, int l, MemorySegment v, int ldv, MemorySegment t, int ldt, MemorySegment a, int lda, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_ztprfb.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ztprfb", matrix_layout, side, trans, direct, storev, m, n, k, l, v, ldv, t, ldt, a, lda, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, side, trans, direct, storev, m, n, k, l, v, ldv, t, ldt, a, lda, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sgemqrt_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_sgemqrt_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sgemqrt_work(int matrix_layout, char side, char trans, int m, int n, int k, int nb, const float *v, int ldv, const float *t, int ldt, float *c, int ldc, float *work)
     * }
     */
    public static FunctionDescriptor LAPACKE_sgemqrt_work$descriptor() {
        return LAPACKE_sgemqrt_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sgemqrt_work(int matrix_layout, char side, char trans, int m, int n, int k, int nb, const float *v, int ldv, const float *t, int ldt, float *c, int ldc, float *work)
     * }
     */
    public static MethodHandle LAPACKE_sgemqrt_work$handle() {
        return LAPACKE_sgemqrt_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sgemqrt_work(int matrix_layout, char side, char trans, int m, int n, int k, int nb, const float *v, int ldv, const float *t, int ldt, float *c, int ldc, float *work)
     * }
     */
    public static MemorySegment LAPACKE_sgemqrt_work$address() {
        return LAPACKE_sgemqrt_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sgemqrt_work(int matrix_layout, char side, char trans, int m, int n, int k, int nb, const float *v, int ldv, const float *t, int ldt, float *c, int ldc, float *work)
     * }
     */
    public static int LAPACKE_sgemqrt_work(int matrix_layout, byte side, byte trans, int m, int n, int k, int nb, MemorySegment v, int ldv, MemorySegment t, int ldt, MemorySegment c, int ldc, MemorySegment work) {
        var mh$ = LAPACKE_sgemqrt_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sgemqrt_work", matrix_layout, side, trans, m, n, k, nb, v, ldv, t, ldt, c, ldc, work);
            }
            return (int)mh$.invokeExact(matrix_layout, side, trans, m, n, k, nb, v, ldv, t, ldt, c, ldc, work);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dgemqrt_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dgemqrt_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dgemqrt_work(int matrix_layout, char side, char trans, int m, int n, int k, int nb, const double *v, int ldv, const double *t, int ldt, double *c, int ldc, double *work)
     * }
     */
    public static FunctionDescriptor LAPACKE_dgemqrt_work$descriptor() {
        return LAPACKE_dgemqrt_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dgemqrt_work(int matrix_layout, char side, char trans, int m, int n, int k, int nb, const double *v, int ldv, const double *t, int ldt, double *c, int ldc, double *work)
     * }
     */
    public static MethodHandle LAPACKE_dgemqrt_work$handle() {
        return LAPACKE_dgemqrt_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dgemqrt_work(int matrix_layout, char side, char trans, int m, int n, int k, int nb, const double *v, int ldv, const double *t, int ldt, double *c, int ldc, double *work)
     * }
     */
    public static MemorySegment LAPACKE_dgemqrt_work$address() {
        return LAPACKE_dgemqrt_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dgemqrt_work(int matrix_layout, char side, char trans, int m, int n, int k, int nb, const double *v, int ldv, const double *t, int ldt, double *c, int ldc, double *work)
     * }
     */
    public static int LAPACKE_dgemqrt_work(int matrix_layout, byte side, byte trans, int m, int n, int k, int nb, MemorySegment v, int ldv, MemorySegment t, int ldt, MemorySegment c, int ldc, MemorySegment work) {
        var mh$ = LAPACKE_dgemqrt_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dgemqrt_work", matrix_layout, side, trans, m, n, k, nb, v, ldv, t, ldt, c, ldc, work);
            }
            return (int)mh$.invokeExact(matrix_layout, side, trans, m, n, k, nb, v, ldv, t, ldt, c, ldc, work);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cgemqrt_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_cgemqrt_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cgemqrt_work(int matrix_layout, char side, char trans, int m, int n, int k, int nb, const _Complex float *v, int ldv, const _Complex float *t, int ldt, _Complex float *c, int ldc, _Complex float *work)
     * }
     */
    public static FunctionDescriptor LAPACKE_cgemqrt_work$descriptor() {
        return LAPACKE_cgemqrt_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cgemqrt_work(int matrix_layout, char side, char trans, int m, int n, int k, int nb, const _Complex float *v, int ldv, const _Complex float *t, int ldt, _Complex float *c, int ldc, _Complex float *work)
     * }
     */
    public static MethodHandle LAPACKE_cgemqrt_work$handle() {
        return LAPACKE_cgemqrt_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cgemqrt_work(int matrix_layout, char side, char trans, int m, int n, int k, int nb, const _Complex float *v, int ldv, const _Complex float *t, int ldt, _Complex float *c, int ldc, _Complex float *work)
     * }
     */
    public static MemorySegment LAPACKE_cgemqrt_work$address() {
        return LAPACKE_cgemqrt_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cgemqrt_work(int matrix_layout, char side, char trans, int m, int n, int k, int nb, const _Complex float *v, int ldv, const _Complex float *t, int ldt, _Complex float *c, int ldc, _Complex float *work)
     * }
     */
    public static int LAPACKE_cgemqrt_work(int matrix_layout, byte side, byte trans, int m, int n, int k, int nb, MemorySegment v, int ldv, MemorySegment t, int ldt, MemorySegment c, int ldc, MemorySegment work) {
        var mh$ = LAPACKE_cgemqrt_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cgemqrt_work", matrix_layout, side, trans, m, n, k, nb, v, ldv, t, ldt, c, ldc, work);
            }
            return (int)mh$.invokeExact(matrix_layout, side, trans, m, n, k, nb, v, ldv, t, ldt, c, ldc, work);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zgemqrt_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zgemqrt_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zgemqrt_work(int matrix_layout, char side, char trans, int m, int n, int k, int nb, const _Complex double *v, int ldv, const _Complex double *t, int ldt, _Complex double *c, int ldc, _Complex double *work)
     * }
     */
    public static FunctionDescriptor LAPACKE_zgemqrt_work$descriptor() {
        return LAPACKE_zgemqrt_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zgemqrt_work(int matrix_layout, char side, char trans, int m, int n, int k, int nb, const _Complex double *v, int ldv, const _Complex double *t, int ldt, _Complex double *c, int ldc, _Complex double *work)
     * }
     */
    public static MethodHandle LAPACKE_zgemqrt_work$handle() {
        return LAPACKE_zgemqrt_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zgemqrt_work(int matrix_layout, char side, char trans, int m, int n, int k, int nb, const _Complex double *v, int ldv, const _Complex double *t, int ldt, _Complex double *c, int ldc, _Complex double *work)
     * }
     */
    public static MemorySegment LAPACKE_zgemqrt_work$address() {
        return LAPACKE_zgemqrt_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zgemqrt_work(int matrix_layout, char side, char trans, int m, int n, int k, int nb, const _Complex double *v, int ldv, const _Complex double *t, int ldt, _Complex double *c, int ldc, _Complex double *work)
     * }
     */
    public static int LAPACKE_zgemqrt_work(int matrix_layout, byte side, byte trans, int m, int n, int k, int nb, MemorySegment v, int ldv, MemorySegment t, int ldt, MemorySegment c, int ldc, MemorySegment work) {
        var mh$ = LAPACKE_zgemqrt_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zgemqrt_work", matrix_layout, side, trans, m, n, k, nb, v, ldv, t, ldt, c, ldc, work);
            }
            return (int)mh$.invokeExact(matrix_layout, side, trans, m, n, k, nb, v, ldv, t, ldt, c, ldc, work);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sgeqrt_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_sgeqrt_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sgeqrt_work(int matrix_layout, int m, int n, int nb, float *a, int lda, float *t, int ldt, float *work)
     * }
     */
    public static FunctionDescriptor LAPACKE_sgeqrt_work$descriptor() {
        return LAPACKE_sgeqrt_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sgeqrt_work(int matrix_layout, int m, int n, int nb, float *a, int lda, float *t, int ldt, float *work)
     * }
     */
    public static MethodHandle LAPACKE_sgeqrt_work$handle() {
        return LAPACKE_sgeqrt_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sgeqrt_work(int matrix_layout, int m, int n, int nb, float *a, int lda, float *t, int ldt, float *work)
     * }
     */
    public static MemorySegment LAPACKE_sgeqrt_work$address() {
        return LAPACKE_sgeqrt_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sgeqrt_work(int matrix_layout, int m, int n, int nb, float *a, int lda, float *t, int ldt, float *work)
     * }
     */
    public static int LAPACKE_sgeqrt_work(int matrix_layout, int m, int n, int nb, MemorySegment a, int lda, MemorySegment t, int ldt, MemorySegment work) {
        var mh$ = LAPACKE_sgeqrt_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sgeqrt_work", matrix_layout, m, n, nb, a, lda, t, ldt, work);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, nb, a, lda, t, ldt, work);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dgeqrt_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dgeqrt_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dgeqrt_work(int matrix_layout, int m, int n, int nb, double *a, int lda, double *t, int ldt, double *work)
     * }
     */
    public static FunctionDescriptor LAPACKE_dgeqrt_work$descriptor() {
        return LAPACKE_dgeqrt_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dgeqrt_work(int matrix_layout, int m, int n, int nb, double *a, int lda, double *t, int ldt, double *work)
     * }
     */
    public static MethodHandle LAPACKE_dgeqrt_work$handle() {
        return LAPACKE_dgeqrt_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dgeqrt_work(int matrix_layout, int m, int n, int nb, double *a, int lda, double *t, int ldt, double *work)
     * }
     */
    public static MemorySegment LAPACKE_dgeqrt_work$address() {
        return LAPACKE_dgeqrt_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dgeqrt_work(int matrix_layout, int m, int n, int nb, double *a, int lda, double *t, int ldt, double *work)
     * }
     */
    public static int LAPACKE_dgeqrt_work(int matrix_layout, int m, int n, int nb, MemorySegment a, int lda, MemorySegment t, int ldt, MemorySegment work) {
        var mh$ = LAPACKE_dgeqrt_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dgeqrt_work", matrix_layout, m, n, nb, a, lda, t, ldt, work);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, nb, a, lda, t, ldt, work);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cgeqrt_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_cgeqrt_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cgeqrt_work(int matrix_layout, int m, int n, int nb, _Complex float *a, int lda, _Complex float *t, int ldt, _Complex float *work)
     * }
     */
    public static FunctionDescriptor LAPACKE_cgeqrt_work$descriptor() {
        return LAPACKE_cgeqrt_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cgeqrt_work(int matrix_layout, int m, int n, int nb, _Complex float *a, int lda, _Complex float *t, int ldt, _Complex float *work)
     * }
     */
    public static MethodHandle LAPACKE_cgeqrt_work$handle() {
        return LAPACKE_cgeqrt_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cgeqrt_work(int matrix_layout, int m, int n, int nb, _Complex float *a, int lda, _Complex float *t, int ldt, _Complex float *work)
     * }
     */
    public static MemorySegment LAPACKE_cgeqrt_work$address() {
        return LAPACKE_cgeqrt_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cgeqrt_work(int matrix_layout, int m, int n, int nb, _Complex float *a, int lda, _Complex float *t, int ldt, _Complex float *work)
     * }
     */
    public static int LAPACKE_cgeqrt_work(int matrix_layout, int m, int n, int nb, MemorySegment a, int lda, MemorySegment t, int ldt, MemorySegment work) {
        var mh$ = LAPACKE_cgeqrt_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cgeqrt_work", matrix_layout, m, n, nb, a, lda, t, ldt, work);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, nb, a, lda, t, ldt, work);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zgeqrt_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zgeqrt_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zgeqrt_work(int matrix_layout, int m, int n, int nb, _Complex double *a, int lda, _Complex double *t, int ldt, _Complex double *work)
     * }
     */
    public static FunctionDescriptor LAPACKE_zgeqrt_work$descriptor() {
        return LAPACKE_zgeqrt_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zgeqrt_work(int matrix_layout, int m, int n, int nb, _Complex double *a, int lda, _Complex double *t, int ldt, _Complex double *work)
     * }
     */
    public static MethodHandle LAPACKE_zgeqrt_work$handle() {
        return LAPACKE_zgeqrt_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zgeqrt_work(int matrix_layout, int m, int n, int nb, _Complex double *a, int lda, _Complex double *t, int ldt, _Complex double *work)
     * }
     */
    public static MemorySegment LAPACKE_zgeqrt_work$address() {
        return LAPACKE_zgeqrt_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zgeqrt_work(int matrix_layout, int m, int n, int nb, _Complex double *a, int lda, _Complex double *t, int ldt, _Complex double *work)
     * }
     */
    public static int LAPACKE_zgeqrt_work(int matrix_layout, int m, int n, int nb, MemorySegment a, int lda, MemorySegment t, int ldt, MemorySegment work) {
        var mh$ = LAPACKE_zgeqrt_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zgeqrt_work", matrix_layout, m, n, nb, a, lda, t, ldt, work);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, nb, a, lda, t, ldt, work);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sgeqrt2_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_sgeqrt2_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sgeqrt2_work(int matrix_layout, int m, int n, float *a, int lda, float *t, int ldt)
     * }
     */
    public static FunctionDescriptor LAPACKE_sgeqrt2_work$descriptor() {
        return LAPACKE_sgeqrt2_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sgeqrt2_work(int matrix_layout, int m, int n, float *a, int lda, float *t, int ldt)
     * }
     */
    public static MethodHandle LAPACKE_sgeqrt2_work$handle() {
        return LAPACKE_sgeqrt2_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sgeqrt2_work(int matrix_layout, int m, int n, float *a, int lda, float *t, int ldt)
     * }
     */
    public static MemorySegment LAPACKE_sgeqrt2_work$address() {
        return LAPACKE_sgeqrt2_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sgeqrt2_work(int matrix_layout, int m, int n, float *a, int lda, float *t, int ldt)
     * }
     */
    public static int LAPACKE_sgeqrt2_work(int matrix_layout, int m, int n, MemorySegment a, int lda, MemorySegment t, int ldt) {
        var mh$ = LAPACKE_sgeqrt2_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sgeqrt2_work", matrix_layout, m, n, a, lda, t, ldt);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, a, lda, t, ldt);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dgeqrt2_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dgeqrt2_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dgeqrt2_work(int matrix_layout, int m, int n, double *a, int lda, double *t, int ldt)
     * }
     */
    public static FunctionDescriptor LAPACKE_dgeqrt2_work$descriptor() {
        return LAPACKE_dgeqrt2_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dgeqrt2_work(int matrix_layout, int m, int n, double *a, int lda, double *t, int ldt)
     * }
     */
    public static MethodHandle LAPACKE_dgeqrt2_work$handle() {
        return LAPACKE_dgeqrt2_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dgeqrt2_work(int matrix_layout, int m, int n, double *a, int lda, double *t, int ldt)
     * }
     */
    public static MemorySegment LAPACKE_dgeqrt2_work$address() {
        return LAPACKE_dgeqrt2_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dgeqrt2_work(int matrix_layout, int m, int n, double *a, int lda, double *t, int ldt)
     * }
     */
    public static int LAPACKE_dgeqrt2_work(int matrix_layout, int m, int n, MemorySegment a, int lda, MemorySegment t, int ldt) {
        var mh$ = LAPACKE_dgeqrt2_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dgeqrt2_work", matrix_layout, m, n, a, lda, t, ldt);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, a, lda, t, ldt);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cgeqrt2_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_cgeqrt2_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cgeqrt2_work(int matrix_layout, int m, int n, _Complex float *a, int lda, _Complex float *t, int ldt)
     * }
     */
    public static FunctionDescriptor LAPACKE_cgeqrt2_work$descriptor() {
        return LAPACKE_cgeqrt2_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cgeqrt2_work(int matrix_layout, int m, int n, _Complex float *a, int lda, _Complex float *t, int ldt)
     * }
     */
    public static MethodHandle LAPACKE_cgeqrt2_work$handle() {
        return LAPACKE_cgeqrt2_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cgeqrt2_work(int matrix_layout, int m, int n, _Complex float *a, int lda, _Complex float *t, int ldt)
     * }
     */
    public static MemorySegment LAPACKE_cgeqrt2_work$address() {
        return LAPACKE_cgeqrt2_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cgeqrt2_work(int matrix_layout, int m, int n, _Complex float *a, int lda, _Complex float *t, int ldt)
     * }
     */
    public static int LAPACKE_cgeqrt2_work(int matrix_layout, int m, int n, MemorySegment a, int lda, MemorySegment t, int ldt) {
        var mh$ = LAPACKE_cgeqrt2_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cgeqrt2_work", matrix_layout, m, n, a, lda, t, ldt);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, a, lda, t, ldt);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zgeqrt2_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zgeqrt2_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zgeqrt2_work(int matrix_layout, int m, int n, _Complex double *a, int lda, _Complex double *t, int ldt)
     * }
     */
    public static FunctionDescriptor LAPACKE_zgeqrt2_work$descriptor() {
        return LAPACKE_zgeqrt2_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zgeqrt2_work(int matrix_layout, int m, int n, _Complex double *a, int lda, _Complex double *t, int ldt)
     * }
     */
    public static MethodHandle LAPACKE_zgeqrt2_work$handle() {
        return LAPACKE_zgeqrt2_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zgeqrt2_work(int matrix_layout, int m, int n, _Complex double *a, int lda, _Complex double *t, int ldt)
     * }
     */
    public static MemorySegment LAPACKE_zgeqrt2_work$address() {
        return LAPACKE_zgeqrt2_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zgeqrt2_work(int matrix_layout, int m, int n, _Complex double *a, int lda, _Complex double *t, int ldt)
     * }
     */
    public static int LAPACKE_zgeqrt2_work(int matrix_layout, int m, int n, MemorySegment a, int lda, MemorySegment t, int ldt) {
        var mh$ = LAPACKE_zgeqrt2_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zgeqrt2_work", matrix_layout, m, n, a, lda, t, ldt);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, a, lda, t, ldt);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sgeqrt3_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_sgeqrt3_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sgeqrt3_work(int matrix_layout, int m, int n, float *a, int lda, float *t, int ldt)
     * }
     */
    public static FunctionDescriptor LAPACKE_sgeqrt3_work$descriptor() {
        return LAPACKE_sgeqrt3_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sgeqrt3_work(int matrix_layout, int m, int n, float *a, int lda, float *t, int ldt)
     * }
     */
    public static MethodHandle LAPACKE_sgeqrt3_work$handle() {
        return LAPACKE_sgeqrt3_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sgeqrt3_work(int matrix_layout, int m, int n, float *a, int lda, float *t, int ldt)
     * }
     */
    public static MemorySegment LAPACKE_sgeqrt3_work$address() {
        return LAPACKE_sgeqrt3_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sgeqrt3_work(int matrix_layout, int m, int n, float *a, int lda, float *t, int ldt)
     * }
     */
    public static int LAPACKE_sgeqrt3_work(int matrix_layout, int m, int n, MemorySegment a, int lda, MemorySegment t, int ldt) {
        var mh$ = LAPACKE_sgeqrt3_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sgeqrt3_work", matrix_layout, m, n, a, lda, t, ldt);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, a, lda, t, ldt);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dgeqrt3_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dgeqrt3_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dgeqrt3_work(int matrix_layout, int m, int n, double *a, int lda, double *t, int ldt)
     * }
     */
    public static FunctionDescriptor LAPACKE_dgeqrt3_work$descriptor() {
        return LAPACKE_dgeqrt3_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dgeqrt3_work(int matrix_layout, int m, int n, double *a, int lda, double *t, int ldt)
     * }
     */
    public static MethodHandle LAPACKE_dgeqrt3_work$handle() {
        return LAPACKE_dgeqrt3_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dgeqrt3_work(int matrix_layout, int m, int n, double *a, int lda, double *t, int ldt)
     * }
     */
    public static MemorySegment LAPACKE_dgeqrt3_work$address() {
        return LAPACKE_dgeqrt3_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dgeqrt3_work(int matrix_layout, int m, int n, double *a, int lda, double *t, int ldt)
     * }
     */
    public static int LAPACKE_dgeqrt3_work(int matrix_layout, int m, int n, MemorySegment a, int lda, MemorySegment t, int ldt) {
        var mh$ = LAPACKE_dgeqrt3_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dgeqrt3_work", matrix_layout, m, n, a, lda, t, ldt);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, a, lda, t, ldt);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cgeqrt3_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_cgeqrt3_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cgeqrt3_work(int matrix_layout, int m, int n, _Complex float *a, int lda, _Complex float *t, int ldt)
     * }
     */
    public static FunctionDescriptor LAPACKE_cgeqrt3_work$descriptor() {
        return LAPACKE_cgeqrt3_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cgeqrt3_work(int matrix_layout, int m, int n, _Complex float *a, int lda, _Complex float *t, int ldt)
     * }
     */
    public static MethodHandle LAPACKE_cgeqrt3_work$handle() {
        return LAPACKE_cgeqrt3_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cgeqrt3_work(int matrix_layout, int m, int n, _Complex float *a, int lda, _Complex float *t, int ldt)
     * }
     */
    public static MemorySegment LAPACKE_cgeqrt3_work$address() {
        return LAPACKE_cgeqrt3_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cgeqrt3_work(int matrix_layout, int m, int n, _Complex float *a, int lda, _Complex float *t, int ldt)
     * }
     */
    public static int LAPACKE_cgeqrt3_work(int matrix_layout, int m, int n, MemorySegment a, int lda, MemorySegment t, int ldt) {
        var mh$ = LAPACKE_cgeqrt3_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cgeqrt3_work", matrix_layout, m, n, a, lda, t, ldt);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, a, lda, t, ldt);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zgeqrt3_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zgeqrt3_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zgeqrt3_work(int matrix_layout, int m, int n, _Complex double *a, int lda, _Complex double *t, int ldt)
     * }
     */
    public static FunctionDescriptor LAPACKE_zgeqrt3_work$descriptor() {
        return LAPACKE_zgeqrt3_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zgeqrt3_work(int matrix_layout, int m, int n, _Complex double *a, int lda, _Complex double *t, int ldt)
     * }
     */
    public static MethodHandle LAPACKE_zgeqrt3_work$handle() {
        return LAPACKE_zgeqrt3_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zgeqrt3_work(int matrix_layout, int m, int n, _Complex double *a, int lda, _Complex double *t, int ldt)
     * }
     */
    public static MemorySegment LAPACKE_zgeqrt3_work$address() {
        return LAPACKE_zgeqrt3_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zgeqrt3_work(int matrix_layout, int m, int n, _Complex double *a, int lda, _Complex double *t, int ldt)
     * }
     */
    public static int LAPACKE_zgeqrt3_work(int matrix_layout, int m, int n, MemorySegment a, int lda, MemorySegment t, int ldt) {
        var mh$ = LAPACKE_zgeqrt3_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zgeqrt3_work", matrix_layout, m, n, a, lda, t, ldt);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, a, lda, t, ldt);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_stpmqrt_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_stpmqrt_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_stpmqrt_work(int matrix_layout, char side, char trans, int m, int n, int k, int l, int nb, const float *v, int ldv, const float *t, int ldt, float *a, int lda, float *b, int ldb, float *work)
     * }
     */
    public static FunctionDescriptor LAPACKE_stpmqrt_work$descriptor() {
        return LAPACKE_stpmqrt_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_stpmqrt_work(int matrix_layout, char side, char trans, int m, int n, int k, int l, int nb, const float *v, int ldv, const float *t, int ldt, float *a, int lda, float *b, int ldb, float *work)
     * }
     */
    public static MethodHandle LAPACKE_stpmqrt_work$handle() {
        return LAPACKE_stpmqrt_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_stpmqrt_work(int matrix_layout, char side, char trans, int m, int n, int k, int l, int nb, const float *v, int ldv, const float *t, int ldt, float *a, int lda, float *b, int ldb, float *work)
     * }
     */
    public static MemorySegment LAPACKE_stpmqrt_work$address() {
        return LAPACKE_stpmqrt_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_stpmqrt_work(int matrix_layout, char side, char trans, int m, int n, int k, int l, int nb, const float *v, int ldv, const float *t, int ldt, float *a, int lda, float *b, int ldb, float *work)
     * }
     */
    public static int LAPACKE_stpmqrt_work(int matrix_layout, byte side, byte trans, int m, int n, int k, int l, int nb, MemorySegment v, int ldv, MemorySegment t, int ldt, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment work) {
        var mh$ = LAPACKE_stpmqrt_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_stpmqrt_work", matrix_layout, side, trans, m, n, k, l, nb, v, ldv, t, ldt, a, lda, b, ldb, work);
            }
            return (int)mh$.invokeExact(matrix_layout, side, trans, m, n, k, l, nb, v, ldv, t, ldt, a, lda, b, ldb, work);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dtpmqrt_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dtpmqrt_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dtpmqrt_work(int matrix_layout, char side, char trans, int m, int n, int k, int l, int nb, const double *v, int ldv, const double *t, int ldt, double *a, int lda, double *b, int ldb, double *work)
     * }
     */
    public static FunctionDescriptor LAPACKE_dtpmqrt_work$descriptor() {
        return LAPACKE_dtpmqrt_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dtpmqrt_work(int matrix_layout, char side, char trans, int m, int n, int k, int l, int nb, const double *v, int ldv, const double *t, int ldt, double *a, int lda, double *b, int ldb, double *work)
     * }
     */
    public static MethodHandle LAPACKE_dtpmqrt_work$handle() {
        return LAPACKE_dtpmqrt_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dtpmqrt_work(int matrix_layout, char side, char trans, int m, int n, int k, int l, int nb, const double *v, int ldv, const double *t, int ldt, double *a, int lda, double *b, int ldb, double *work)
     * }
     */
    public static MemorySegment LAPACKE_dtpmqrt_work$address() {
        return LAPACKE_dtpmqrt_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dtpmqrt_work(int matrix_layout, char side, char trans, int m, int n, int k, int l, int nb, const double *v, int ldv, const double *t, int ldt, double *a, int lda, double *b, int ldb, double *work)
     * }
     */
    public static int LAPACKE_dtpmqrt_work(int matrix_layout, byte side, byte trans, int m, int n, int k, int l, int nb, MemorySegment v, int ldv, MemorySegment t, int ldt, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment work) {
        var mh$ = LAPACKE_dtpmqrt_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dtpmqrt_work", matrix_layout, side, trans, m, n, k, l, nb, v, ldv, t, ldt, a, lda, b, ldb, work);
            }
            return (int)mh$.invokeExact(matrix_layout, side, trans, m, n, k, l, nb, v, ldv, t, ldt, a, lda, b, ldb, work);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ctpmqrt_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_ctpmqrt_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ctpmqrt_work(int matrix_layout, char side, char trans, int m, int n, int k, int l, int nb, const _Complex float *v, int ldv, const _Complex float *t, int ldt, _Complex float *a, int lda, _Complex float *b, int ldb, _Complex float *work)
     * }
     */
    public static FunctionDescriptor LAPACKE_ctpmqrt_work$descriptor() {
        return LAPACKE_ctpmqrt_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ctpmqrt_work(int matrix_layout, char side, char trans, int m, int n, int k, int l, int nb, const _Complex float *v, int ldv, const _Complex float *t, int ldt, _Complex float *a, int lda, _Complex float *b, int ldb, _Complex float *work)
     * }
     */
    public static MethodHandle LAPACKE_ctpmqrt_work$handle() {
        return LAPACKE_ctpmqrt_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ctpmqrt_work(int matrix_layout, char side, char trans, int m, int n, int k, int l, int nb, const _Complex float *v, int ldv, const _Complex float *t, int ldt, _Complex float *a, int lda, _Complex float *b, int ldb, _Complex float *work)
     * }
     */
    public static MemorySegment LAPACKE_ctpmqrt_work$address() {
        return LAPACKE_ctpmqrt_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ctpmqrt_work(int matrix_layout, char side, char trans, int m, int n, int k, int l, int nb, const _Complex float *v, int ldv, const _Complex float *t, int ldt, _Complex float *a, int lda, _Complex float *b, int ldb, _Complex float *work)
     * }
     */
    public static int LAPACKE_ctpmqrt_work(int matrix_layout, byte side, byte trans, int m, int n, int k, int l, int nb, MemorySegment v, int ldv, MemorySegment t, int ldt, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment work) {
        var mh$ = LAPACKE_ctpmqrt_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ctpmqrt_work", matrix_layout, side, trans, m, n, k, l, nb, v, ldv, t, ldt, a, lda, b, ldb, work);
            }
            return (int)mh$.invokeExact(matrix_layout, side, trans, m, n, k, l, nb, v, ldv, t, ldt, a, lda, b, ldb, work);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ztpmqrt_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_ztpmqrt_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ztpmqrt_work(int matrix_layout, char side, char trans, int m, int n, int k, int l, int nb, const _Complex double *v, int ldv, const _Complex double *t, int ldt, _Complex double *a, int lda, _Complex double *b, int ldb, _Complex double *work)
     * }
     */
    public static FunctionDescriptor LAPACKE_ztpmqrt_work$descriptor() {
        return LAPACKE_ztpmqrt_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ztpmqrt_work(int matrix_layout, char side, char trans, int m, int n, int k, int l, int nb, const _Complex double *v, int ldv, const _Complex double *t, int ldt, _Complex double *a, int lda, _Complex double *b, int ldb, _Complex double *work)
     * }
     */
    public static MethodHandle LAPACKE_ztpmqrt_work$handle() {
        return LAPACKE_ztpmqrt_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ztpmqrt_work(int matrix_layout, char side, char trans, int m, int n, int k, int l, int nb, const _Complex double *v, int ldv, const _Complex double *t, int ldt, _Complex double *a, int lda, _Complex double *b, int ldb, _Complex double *work)
     * }
     */
    public static MemorySegment LAPACKE_ztpmqrt_work$address() {
        return LAPACKE_ztpmqrt_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ztpmqrt_work(int matrix_layout, char side, char trans, int m, int n, int k, int l, int nb, const _Complex double *v, int ldv, const _Complex double *t, int ldt, _Complex double *a, int lda, _Complex double *b, int ldb, _Complex double *work)
     * }
     */
    public static int LAPACKE_ztpmqrt_work(int matrix_layout, byte side, byte trans, int m, int n, int k, int l, int nb, MemorySegment v, int ldv, MemorySegment t, int ldt, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment work) {
        var mh$ = LAPACKE_ztpmqrt_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ztpmqrt_work", matrix_layout, side, trans, m, n, k, l, nb, v, ldv, t, ldt, a, lda, b, ldb, work);
            }
            return (int)mh$.invokeExact(matrix_layout, side, trans, m, n, k, l, nb, v, ldv, t, ldt, a, lda, b, ldb, work);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_stpqrt_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_stpqrt_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_stpqrt_work(int matrix_layout, int m, int n, int l, int nb, float *a, int lda, float *b, int ldb, float *t, int ldt, float *work)
     * }
     */
    public static FunctionDescriptor LAPACKE_stpqrt_work$descriptor() {
        return LAPACKE_stpqrt_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_stpqrt_work(int matrix_layout, int m, int n, int l, int nb, float *a, int lda, float *b, int ldb, float *t, int ldt, float *work)
     * }
     */
    public static MethodHandle LAPACKE_stpqrt_work$handle() {
        return LAPACKE_stpqrt_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_stpqrt_work(int matrix_layout, int m, int n, int l, int nb, float *a, int lda, float *b, int ldb, float *t, int ldt, float *work)
     * }
     */
    public static MemorySegment LAPACKE_stpqrt_work$address() {
        return LAPACKE_stpqrt_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_stpqrt_work(int matrix_layout, int m, int n, int l, int nb, float *a, int lda, float *b, int ldb, float *t, int ldt, float *work)
     * }
     */
    public static int LAPACKE_stpqrt_work(int matrix_layout, int m, int n, int l, int nb, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment t, int ldt, MemorySegment work) {
        var mh$ = LAPACKE_stpqrt_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_stpqrt_work", matrix_layout, m, n, l, nb, a, lda, b, ldb, t, ldt, work);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, l, nb, a, lda, b, ldb, t, ldt, work);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dtpqrt_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dtpqrt_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dtpqrt_work(int matrix_layout, int m, int n, int l, int nb, double *a, int lda, double *b, int ldb, double *t, int ldt, double *work)
     * }
     */
    public static FunctionDescriptor LAPACKE_dtpqrt_work$descriptor() {
        return LAPACKE_dtpqrt_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dtpqrt_work(int matrix_layout, int m, int n, int l, int nb, double *a, int lda, double *b, int ldb, double *t, int ldt, double *work)
     * }
     */
    public static MethodHandle LAPACKE_dtpqrt_work$handle() {
        return LAPACKE_dtpqrt_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dtpqrt_work(int matrix_layout, int m, int n, int l, int nb, double *a, int lda, double *b, int ldb, double *t, int ldt, double *work)
     * }
     */
    public static MemorySegment LAPACKE_dtpqrt_work$address() {
        return LAPACKE_dtpqrt_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dtpqrt_work(int matrix_layout, int m, int n, int l, int nb, double *a, int lda, double *b, int ldb, double *t, int ldt, double *work)
     * }
     */
    public static int LAPACKE_dtpqrt_work(int matrix_layout, int m, int n, int l, int nb, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment t, int ldt, MemorySegment work) {
        var mh$ = LAPACKE_dtpqrt_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dtpqrt_work", matrix_layout, m, n, l, nb, a, lda, b, ldb, t, ldt, work);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, l, nb, a, lda, b, ldb, t, ldt, work);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ctpqrt_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_ctpqrt_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ctpqrt_work(int matrix_layout, int m, int n, int l, int nb, _Complex float *a, int lda, _Complex float *b, int ldb, _Complex float *t, int ldt, _Complex float *work)
     * }
     */
    public static FunctionDescriptor LAPACKE_ctpqrt_work$descriptor() {
        return LAPACKE_ctpqrt_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ctpqrt_work(int matrix_layout, int m, int n, int l, int nb, _Complex float *a, int lda, _Complex float *b, int ldb, _Complex float *t, int ldt, _Complex float *work)
     * }
     */
    public static MethodHandle LAPACKE_ctpqrt_work$handle() {
        return LAPACKE_ctpqrt_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ctpqrt_work(int matrix_layout, int m, int n, int l, int nb, _Complex float *a, int lda, _Complex float *b, int ldb, _Complex float *t, int ldt, _Complex float *work)
     * }
     */
    public static MemorySegment LAPACKE_ctpqrt_work$address() {
        return LAPACKE_ctpqrt_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ctpqrt_work(int matrix_layout, int m, int n, int l, int nb, _Complex float *a, int lda, _Complex float *b, int ldb, _Complex float *t, int ldt, _Complex float *work)
     * }
     */
    public static int LAPACKE_ctpqrt_work(int matrix_layout, int m, int n, int l, int nb, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment t, int ldt, MemorySegment work) {
        var mh$ = LAPACKE_ctpqrt_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ctpqrt_work", matrix_layout, m, n, l, nb, a, lda, b, ldb, t, ldt, work);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, l, nb, a, lda, b, ldb, t, ldt, work);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ztpqrt_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_ztpqrt_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ztpqrt_work(int matrix_layout, int m, int n, int l, int nb, _Complex double *a, int lda, _Complex double *b, int ldb, _Complex double *t, int ldt, _Complex double *work)
     * }
     */
    public static FunctionDescriptor LAPACKE_ztpqrt_work$descriptor() {
        return LAPACKE_ztpqrt_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ztpqrt_work(int matrix_layout, int m, int n, int l, int nb, _Complex double *a, int lda, _Complex double *b, int ldb, _Complex double *t, int ldt, _Complex double *work)
     * }
     */
    public static MethodHandle LAPACKE_ztpqrt_work$handle() {
        return LAPACKE_ztpqrt_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ztpqrt_work(int matrix_layout, int m, int n, int l, int nb, _Complex double *a, int lda, _Complex double *b, int ldb, _Complex double *t, int ldt, _Complex double *work)
     * }
     */
    public static MemorySegment LAPACKE_ztpqrt_work$address() {
        return LAPACKE_ztpqrt_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ztpqrt_work(int matrix_layout, int m, int n, int l, int nb, _Complex double *a, int lda, _Complex double *b, int ldb, _Complex double *t, int ldt, _Complex double *work)
     * }
     */
    public static int LAPACKE_ztpqrt_work(int matrix_layout, int m, int n, int l, int nb, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment t, int ldt, MemorySegment work) {
        var mh$ = LAPACKE_ztpqrt_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ztpqrt_work", matrix_layout, m, n, l, nb, a, lda, b, ldb, t, ldt, work);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, l, nb, a, lda, b, ldb, t, ldt, work);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_stpqrt2_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_stpqrt2_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_stpqrt2_work(int matrix_layout, int m, int n, int l, float *a, int lda, float *b, int ldb, float *t, int ldt)
     * }
     */
    public static FunctionDescriptor LAPACKE_stpqrt2_work$descriptor() {
        return LAPACKE_stpqrt2_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_stpqrt2_work(int matrix_layout, int m, int n, int l, float *a, int lda, float *b, int ldb, float *t, int ldt)
     * }
     */
    public static MethodHandle LAPACKE_stpqrt2_work$handle() {
        return LAPACKE_stpqrt2_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_stpqrt2_work(int matrix_layout, int m, int n, int l, float *a, int lda, float *b, int ldb, float *t, int ldt)
     * }
     */
    public static MemorySegment LAPACKE_stpqrt2_work$address() {
        return LAPACKE_stpqrt2_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_stpqrt2_work(int matrix_layout, int m, int n, int l, float *a, int lda, float *b, int ldb, float *t, int ldt)
     * }
     */
    public static int LAPACKE_stpqrt2_work(int matrix_layout, int m, int n, int l, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment t, int ldt) {
        var mh$ = LAPACKE_stpqrt2_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_stpqrt2_work", matrix_layout, m, n, l, a, lda, b, ldb, t, ldt);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, l, a, lda, b, ldb, t, ldt);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dtpqrt2_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dtpqrt2_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dtpqrt2_work(int matrix_layout, int m, int n, int l, double *a, int lda, double *b, int ldb, double *t, int ldt)
     * }
     */
    public static FunctionDescriptor LAPACKE_dtpqrt2_work$descriptor() {
        return LAPACKE_dtpqrt2_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dtpqrt2_work(int matrix_layout, int m, int n, int l, double *a, int lda, double *b, int ldb, double *t, int ldt)
     * }
     */
    public static MethodHandle LAPACKE_dtpqrt2_work$handle() {
        return LAPACKE_dtpqrt2_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dtpqrt2_work(int matrix_layout, int m, int n, int l, double *a, int lda, double *b, int ldb, double *t, int ldt)
     * }
     */
    public static MemorySegment LAPACKE_dtpqrt2_work$address() {
        return LAPACKE_dtpqrt2_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dtpqrt2_work(int matrix_layout, int m, int n, int l, double *a, int lda, double *b, int ldb, double *t, int ldt)
     * }
     */
    public static int LAPACKE_dtpqrt2_work(int matrix_layout, int m, int n, int l, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment t, int ldt) {
        var mh$ = LAPACKE_dtpqrt2_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dtpqrt2_work", matrix_layout, m, n, l, a, lda, b, ldb, t, ldt);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, l, a, lda, b, ldb, t, ldt);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ctpqrt2_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_ctpqrt2_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ctpqrt2_work(int matrix_layout, int m, int n, int l, _Complex float *a, int lda, _Complex float *b, int ldb, _Complex float *t, int ldt)
     * }
     */
    public static FunctionDescriptor LAPACKE_ctpqrt2_work$descriptor() {
        return LAPACKE_ctpqrt2_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ctpqrt2_work(int matrix_layout, int m, int n, int l, _Complex float *a, int lda, _Complex float *b, int ldb, _Complex float *t, int ldt)
     * }
     */
    public static MethodHandle LAPACKE_ctpqrt2_work$handle() {
        return LAPACKE_ctpqrt2_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ctpqrt2_work(int matrix_layout, int m, int n, int l, _Complex float *a, int lda, _Complex float *b, int ldb, _Complex float *t, int ldt)
     * }
     */
    public static MemorySegment LAPACKE_ctpqrt2_work$address() {
        return LAPACKE_ctpqrt2_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ctpqrt2_work(int matrix_layout, int m, int n, int l, _Complex float *a, int lda, _Complex float *b, int ldb, _Complex float *t, int ldt)
     * }
     */
    public static int LAPACKE_ctpqrt2_work(int matrix_layout, int m, int n, int l, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment t, int ldt) {
        var mh$ = LAPACKE_ctpqrt2_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ctpqrt2_work", matrix_layout, m, n, l, a, lda, b, ldb, t, ldt);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, l, a, lda, b, ldb, t, ldt);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ztpqrt2_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_ztpqrt2_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ztpqrt2_work(int matrix_layout, int m, int n, int l, _Complex double *a, int lda, _Complex double *b, int ldb, _Complex double *t, int ldt)
     * }
     */
    public static FunctionDescriptor LAPACKE_ztpqrt2_work$descriptor() {
        return LAPACKE_ztpqrt2_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ztpqrt2_work(int matrix_layout, int m, int n, int l, _Complex double *a, int lda, _Complex double *b, int ldb, _Complex double *t, int ldt)
     * }
     */
    public static MethodHandle LAPACKE_ztpqrt2_work$handle() {
        return LAPACKE_ztpqrt2_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ztpqrt2_work(int matrix_layout, int m, int n, int l, _Complex double *a, int lda, _Complex double *b, int ldb, _Complex double *t, int ldt)
     * }
     */
    public static MemorySegment LAPACKE_ztpqrt2_work$address() {
        return LAPACKE_ztpqrt2_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ztpqrt2_work(int matrix_layout, int m, int n, int l, _Complex double *a, int lda, _Complex double *b, int ldb, _Complex double *t, int ldt)
     * }
     */
    public static int LAPACKE_ztpqrt2_work(int matrix_layout, int m, int n, int l, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment t, int ldt) {
        var mh$ = LAPACKE_ztpqrt2_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ztpqrt2_work", matrix_layout, m, n, l, a, lda, b, ldb, t, ldt);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, l, a, lda, b, ldb, t, ldt);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_stprfb_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_stprfb_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_stprfb_work(int matrix_layout, char side, char trans, char direct, char storev, int m, int n, int k, int l, const float *v, int ldv, const float *t, int ldt, float *a, int lda, float *b, int ldb, float *work, int ldwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_stprfb_work$descriptor() {
        return LAPACKE_stprfb_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_stprfb_work(int matrix_layout, char side, char trans, char direct, char storev, int m, int n, int k, int l, const float *v, int ldv, const float *t, int ldt, float *a, int lda, float *b, int ldb, float *work, int ldwork)
     * }
     */
    public static MethodHandle LAPACKE_stprfb_work$handle() {
        return LAPACKE_stprfb_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_stprfb_work(int matrix_layout, char side, char trans, char direct, char storev, int m, int n, int k, int l, const float *v, int ldv, const float *t, int ldt, float *a, int lda, float *b, int ldb, float *work, int ldwork)
     * }
     */
    public static MemorySegment LAPACKE_stprfb_work$address() {
        return LAPACKE_stprfb_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_stprfb_work(int matrix_layout, char side, char trans, char direct, char storev, int m, int n, int k, int l, const float *v, int ldv, const float *t, int ldt, float *a, int lda, float *b, int ldb, float *work, int ldwork)
     * }
     */
    public static int LAPACKE_stprfb_work(int matrix_layout, byte side, byte trans, byte direct, byte storev, int m, int n, int k, int l, MemorySegment v, int ldv, MemorySegment t, int ldt, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment work, int ldwork) {
        var mh$ = LAPACKE_stprfb_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_stprfb_work", matrix_layout, side, trans, direct, storev, m, n, k, l, v, ldv, t, ldt, a, lda, b, ldb, work, ldwork);
            }
            return (int)mh$.invokeExact(matrix_layout, side, trans, direct, storev, m, n, k, l, v, ldv, t, ldt, a, lda, b, ldb, work, ldwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dtprfb_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dtprfb_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dtprfb_work(int matrix_layout, char side, char trans, char direct, char storev, int m, int n, int k, int l, const double *v, int ldv, const double *t, int ldt, double *a, int lda, double *b, int ldb, double *work, int ldwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_dtprfb_work$descriptor() {
        return LAPACKE_dtprfb_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dtprfb_work(int matrix_layout, char side, char trans, char direct, char storev, int m, int n, int k, int l, const double *v, int ldv, const double *t, int ldt, double *a, int lda, double *b, int ldb, double *work, int ldwork)
     * }
     */
    public static MethodHandle LAPACKE_dtprfb_work$handle() {
        return LAPACKE_dtprfb_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dtprfb_work(int matrix_layout, char side, char trans, char direct, char storev, int m, int n, int k, int l, const double *v, int ldv, const double *t, int ldt, double *a, int lda, double *b, int ldb, double *work, int ldwork)
     * }
     */
    public static MemorySegment LAPACKE_dtprfb_work$address() {
        return LAPACKE_dtprfb_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dtprfb_work(int matrix_layout, char side, char trans, char direct, char storev, int m, int n, int k, int l, const double *v, int ldv, const double *t, int ldt, double *a, int lda, double *b, int ldb, double *work, int ldwork)
     * }
     */
    public static int LAPACKE_dtprfb_work(int matrix_layout, byte side, byte trans, byte direct, byte storev, int m, int n, int k, int l, MemorySegment v, int ldv, MemorySegment t, int ldt, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment work, int ldwork) {
        var mh$ = LAPACKE_dtprfb_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dtprfb_work", matrix_layout, side, trans, direct, storev, m, n, k, l, v, ldv, t, ldt, a, lda, b, ldb, work, ldwork);
            }
            return (int)mh$.invokeExact(matrix_layout, side, trans, direct, storev, m, n, k, l, v, ldv, t, ldt, a, lda, b, ldb, work, ldwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ctprfb_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_ctprfb_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ctprfb_work(int matrix_layout, char side, char trans, char direct, char storev, int m, int n, int k, int l, const _Complex float *v, int ldv, const _Complex float *t, int ldt, _Complex float *a, int lda, _Complex float *b, int ldb, _Complex float *work, int ldwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_ctprfb_work$descriptor() {
        return LAPACKE_ctprfb_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ctprfb_work(int matrix_layout, char side, char trans, char direct, char storev, int m, int n, int k, int l, const _Complex float *v, int ldv, const _Complex float *t, int ldt, _Complex float *a, int lda, _Complex float *b, int ldb, _Complex float *work, int ldwork)
     * }
     */
    public static MethodHandle LAPACKE_ctprfb_work$handle() {
        return LAPACKE_ctprfb_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ctprfb_work(int matrix_layout, char side, char trans, char direct, char storev, int m, int n, int k, int l, const _Complex float *v, int ldv, const _Complex float *t, int ldt, _Complex float *a, int lda, _Complex float *b, int ldb, _Complex float *work, int ldwork)
     * }
     */
    public static MemorySegment LAPACKE_ctprfb_work$address() {
        return LAPACKE_ctprfb_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ctprfb_work(int matrix_layout, char side, char trans, char direct, char storev, int m, int n, int k, int l, const _Complex float *v, int ldv, const _Complex float *t, int ldt, _Complex float *a, int lda, _Complex float *b, int ldb, _Complex float *work, int ldwork)
     * }
     */
    public static int LAPACKE_ctprfb_work(int matrix_layout, byte side, byte trans, byte direct, byte storev, int m, int n, int k, int l, MemorySegment v, int ldv, MemorySegment t, int ldt, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment work, int ldwork) {
        var mh$ = LAPACKE_ctprfb_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ctprfb_work", matrix_layout, side, trans, direct, storev, m, n, k, l, v, ldv, t, ldt, a, lda, b, ldb, work, ldwork);
            }
            return (int)mh$.invokeExact(matrix_layout, side, trans, direct, storev, m, n, k, l, v, ldv, t, ldt, a, lda, b, ldb, work, ldwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ztprfb_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_ztprfb_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ztprfb_work(int matrix_layout, char side, char trans, char direct, char storev, int m, int n, int k, int l, const _Complex double *v, int ldv, const _Complex double *t, int ldt, _Complex double *a, int lda, _Complex double *b, int ldb, _Complex double *work, int ldwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_ztprfb_work$descriptor() {
        return LAPACKE_ztprfb_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ztprfb_work(int matrix_layout, char side, char trans, char direct, char storev, int m, int n, int k, int l, const _Complex double *v, int ldv, const _Complex double *t, int ldt, _Complex double *a, int lda, _Complex double *b, int ldb, _Complex double *work, int ldwork)
     * }
     */
    public static MethodHandle LAPACKE_ztprfb_work$handle() {
        return LAPACKE_ztprfb_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ztprfb_work(int matrix_layout, char side, char trans, char direct, char storev, int m, int n, int k, int l, const _Complex double *v, int ldv, const _Complex double *t, int ldt, _Complex double *a, int lda, _Complex double *b, int ldb, _Complex double *work, int ldwork)
     * }
     */
    public static MemorySegment LAPACKE_ztprfb_work$address() {
        return LAPACKE_ztprfb_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ztprfb_work(int matrix_layout, char side, char trans, char direct, char storev, int m, int n, int k, int l, const _Complex double *v, int ldv, const _Complex double *t, int ldt, _Complex double *a, int lda, _Complex double *b, int ldb, _Complex double *work, int ldwork)
     * }
     */
    public static int LAPACKE_ztprfb_work(int matrix_layout, byte side, byte trans, byte direct, byte storev, int m, int n, int k, int l, MemorySegment v, int ldv, MemorySegment t, int ldt, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment work, int ldwork) {
        var mh$ = LAPACKE_ztprfb_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ztprfb_work", matrix_layout, side, trans, direct, storev, m, n, k, l, v, ldv, t, ldt, a, lda, b, ldb, work, ldwork);
            }
            return (int)mh$.invokeExact(matrix_layout, side, trans, direct, storev, m, n, k, l, v, ldv, t, ldt, a, lda, b, ldb, work, ldwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ssysv_rook {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_ssysv_rook");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ssysv_rook(int matrix_layout, char uplo, int n, int nrhs, float *a, int lda, int *ipiv, float *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_ssysv_rook$descriptor() {
        return LAPACKE_ssysv_rook.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ssysv_rook(int matrix_layout, char uplo, int n, int nrhs, float *a, int lda, int *ipiv, float *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_ssysv_rook$handle() {
        return LAPACKE_ssysv_rook.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ssysv_rook(int matrix_layout, char uplo, int n, int nrhs, float *a, int lda, int *ipiv, float *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_ssysv_rook$address() {
        return LAPACKE_ssysv_rook.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ssysv_rook(int matrix_layout, char uplo, int n, int nrhs, float *a, int lda, int *ipiv, float *b, int ldb)
     * }
     */
    public static int LAPACKE_ssysv_rook(int matrix_layout, byte uplo, int n, int nrhs, MemorySegment a, int lda, MemorySegment ipiv, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_ssysv_rook.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ssysv_rook", matrix_layout, uplo, n, nrhs, a, lda, ipiv, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, nrhs, a, lda, ipiv, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dsysv_rook {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dsysv_rook");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dsysv_rook(int matrix_layout, char uplo, int n, int nrhs, double *a, int lda, int *ipiv, double *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_dsysv_rook$descriptor() {
        return LAPACKE_dsysv_rook.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dsysv_rook(int matrix_layout, char uplo, int n, int nrhs, double *a, int lda, int *ipiv, double *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_dsysv_rook$handle() {
        return LAPACKE_dsysv_rook.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dsysv_rook(int matrix_layout, char uplo, int n, int nrhs, double *a, int lda, int *ipiv, double *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_dsysv_rook$address() {
        return LAPACKE_dsysv_rook.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dsysv_rook(int matrix_layout, char uplo, int n, int nrhs, double *a, int lda, int *ipiv, double *b, int ldb)
     * }
     */
    public static int LAPACKE_dsysv_rook(int matrix_layout, byte uplo, int n, int nrhs, MemorySegment a, int lda, MemorySegment ipiv, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_dsysv_rook.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dsysv_rook", matrix_layout, uplo, n, nrhs, a, lda, ipiv, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, nrhs, a, lda, ipiv, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_csysv_rook {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_csysv_rook");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_csysv_rook(int matrix_layout, char uplo, int n, int nrhs, _Complex float *a, int lda, int *ipiv, _Complex float *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_csysv_rook$descriptor() {
        return LAPACKE_csysv_rook.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_csysv_rook(int matrix_layout, char uplo, int n, int nrhs, _Complex float *a, int lda, int *ipiv, _Complex float *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_csysv_rook$handle() {
        return LAPACKE_csysv_rook.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_csysv_rook(int matrix_layout, char uplo, int n, int nrhs, _Complex float *a, int lda, int *ipiv, _Complex float *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_csysv_rook$address() {
        return LAPACKE_csysv_rook.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_csysv_rook(int matrix_layout, char uplo, int n, int nrhs, _Complex float *a, int lda, int *ipiv, _Complex float *b, int ldb)
     * }
     */
    public static int LAPACKE_csysv_rook(int matrix_layout, byte uplo, int n, int nrhs, MemorySegment a, int lda, MemorySegment ipiv, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_csysv_rook.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_csysv_rook", matrix_layout, uplo, n, nrhs, a, lda, ipiv, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, nrhs, a, lda, ipiv, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zsysv_rook {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zsysv_rook");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zsysv_rook(int matrix_layout, char uplo, int n, int nrhs, _Complex double *a, int lda, int *ipiv, _Complex double *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_zsysv_rook$descriptor() {
        return LAPACKE_zsysv_rook.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zsysv_rook(int matrix_layout, char uplo, int n, int nrhs, _Complex double *a, int lda, int *ipiv, _Complex double *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_zsysv_rook$handle() {
        return LAPACKE_zsysv_rook.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zsysv_rook(int matrix_layout, char uplo, int n, int nrhs, _Complex double *a, int lda, int *ipiv, _Complex double *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_zsysv_rook$address() {
        return LAPACKE_zsysv_rook.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zsysv_rook(int matrix_layout, char uplo, int n, int nrhs, _Complex double *a, int lda, int *ipiv, _Complex double *b, int ldb)
     * }
     */
    public static int LAPACKE_zsysv_rook(int matrix_layout, byte uplo, int n, int nrhs, MemorySegment a, int lda, MemorySegment ipiv, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_zsysv_rook.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zsysv_rook", matrix_layout, uplo, n, nrhs, a, lda, ipiv, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, nrhs, a, lda, ipiv, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ssytrf_rook {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_ssytrf_rook");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ssytrf_rook(int matrix_layout, char uplo, int n, float *a, int lda, int *ipiv)
     * }
     */
    public static FunctionDescriptor LAPACKE_ssytrf_rook$descriptor() {
        return LAPACKE_ssytrf_rook.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ssytrf_rook(int matrix_layout, char uplo, int n, float *a, int lda, int *ipiv)
     * }
     */
    public static MethodHandle LAPACKE_ssytrf_rook$handle() {
        return LAPACKE_ssytrf_rook.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ssytrf_rook(int matrix_layout, char uplo, int n, float *a, int lda, int *ipiv)
     * }
     */
    public static MemorySegment LAPACKE_ssytrf_rook$address() {
        return LAPACKE_ssytrf_rook.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ssytrf_rook(int matrix_layout, char uplo, int n, float *a, int lda, int *ipiv)
     * }
     */
    public static int LAPACKE_ssytrf_rook(int matrix_layout, byte uplo, int n, MemorySegment a, int lda, MemorySegment ipiv) {
        var mh$ = LAPACKE_ssytrf_rook.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ssytrf_rook", matrix_layout, uplo, n, a, lda, ipiv);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, a, lda, ipiv);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dsytrf_rook {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dsytrf_rook");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dsytrf_rook(int matrix_layout, char uplo, int n, double *a, int lda, int *ipiv)
     * }
     */
    public static FunctionDescriptor LAPACKE_dsytrf_rook$descriptor() {
        return LAPACKE_dsytrf_rook.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dsytrf_rook(int matrix_layout, char uplo, int n, double *a, int lda, int *ipiv)
     * }
     */
    public static MethodHandle LAPACKE_dsytrf_rook$handle() {
        return LAPACKE_dsytrf_rook.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dsytrf_rook(int matrix_layout, char uplo, int n, double *a, int lda, int *ipiv)
     * }
     */
    public static MemorySegment LAPACKE_dsytrf_rook$address() {
        return LAPACKE_dsytrf_rook.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dsytrf_rook(int matrix_layout, char uplo, int n, double *a, int lda, int *ipiv)
     * }
     */
    public static int LAPACKE_dsytrf_rook(int matrix_layout, byte uplo, int n, MemorySegment a, int lda, MemorySegment ipiv) {
        var mh$ = LAPACKE_dsytrf_rook.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dsytrf_rook", matrix_layout, uplo, n, a, lda, ipiv);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, a, lda, ipiv);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_csytrf_rook {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_csytrf_rook");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_csytrf_rook(int matrix_layout, char uplo, int n, _Complex float *a, int lda, int *ipiv)
     * }
     */
    public static FunctionDescriptor LAPACKE_csytrf_rook$descriptor() {
        return LAPACKE_csytrf_rook.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_csytrf_rook(int matrix_layout, char uplo, int n, _Complex float *a, int lda, int *ipiv)
     * }
     */
    public static MethodHandle LAPACKE_csytrf_rook$handle() {
        return LAPACKE_csytrf_rook.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_csytrf_rook(int matrix_layout, char uplo, int n, _Complex float *a, int lda, int *ipiv)
     * }
     */
    public static MemorySegment LAPACKE_csytrf_rook$address() {
        return LAPACKE_csytrf_rook.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_csytrf_rook(int matrix_layout, char uplo, int n, _Complex float *a, int lda, int *ipiv)
     * }
     */
    public static int LAPACKE_csytrf_rook(int matrix_layout, byte uplo, int n, MemorySegment a, int lda, MemorySegment ipiv) {
        var mh$ = LAPACKE_csytrf_rook.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_csytrf_rook", matrix_layout, uplo, n, a, lda, ipiv);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, a, lda, ipiv);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zsytrf_rook {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zsytrf_rook");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zsytrf_rook(int matrix_layout, char uplo, int n, _Complex double *a, int lda, int *ipiv)
     * }
     */
    public static FunctionDescriptor LAPACKE_zsytrf_rook$descriptor() {
        return LAPACKE_zsytrf_rook.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zsytrf_rook(int matrix_layout, char uplo, int n, _Complex double *a, int lda, int *ipiv)
     * }
     */
    public static MethodHandle LAPACKE_zsytrf_rook$handle() {
        return LAPACKE_zsytrf_rook.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zsytrf_rook(int matrix_layout, char uplo, int n, _Complex double *a, int lda, int *ipiv)
     * }
     */
    public static MemorySegment LAPACKE_zsytrf_rook$address() {
        return LAPACKE_zsytrf_rook.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zsytrf_rook(int matrix_layout, char uplo, int n, _Complex double *a, int lda, int *ipiv)
     * }
     */
    public static int LAPACKE_zsytrf_rook(int matrix_layout, byte uplo, int n, MemorySegment a, int lda, MemorySegment ipiv) {
        var mh$ = LAPACKE_zsytrf_rook.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zsytrf_rook", matrix_layout, uplo, n, a, lda, ipiv);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, a, lda, ipiv);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ssytrs_rook {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_ssytrs_rook");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ssytrs_rook(int matrix_layout, char uplo, int n, int nrhs, const float *a, int lda, const int *ipiv, float *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_ssytrs_rook$descriptor() {
        return LAPACKE_ssytrs_rook.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ssytrs_rook(int matrix_layout, char uplo, int n, int nrhs, const float *a, int lda, const int *ipiv, float *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_ssytrs_rook$handle() {
        return LAPACKE_ssytrs_rook.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ssytrs_rook(int matrix_layout, char uplo, int n, int nrhs, const float *a, int lda, const int *ipiv, float *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_ssytrs_rook$address() {
        return LAPACKE_ssytrs_rook.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ssytrs_rook(int matrix_layout, char uplo, int n, int nrhs, const float *a, int lda, const int *ipiv, float *b, int ldb)
     * }
     */
    public static int LAPACKE_ssytrs_rook(int matrix_layout, byte uplo, int n, int nrhs, MemorySegment a, int lda, MemorySegment ipiv, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_ssytrs_rook.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ssytrs_rook", matrix_layout, uplo, n, nrhs, a, lda, ipiv, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, nrhs, a, lda, ipiv, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dsytrs_rook {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dsytrs_rook");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dsytrs_rook(int matrix_layout, char uplo, int n, int nrhs, const double *a, int lda, const int *ipiv, double *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_dsytrs_rook$descriptor() {
        return LAPACKE_dsytrs_rook.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dsytrs_rook(int matrix_layout, char uplo, int n, int nrhs, const double *a, int lda, const int *ipiv, double *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_dsytrs_rook$handle() {
        return LAPACKE_dsytrs_rook.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dsytrs_rook(int matrix_layout, char uplo, int n, int nrhs, const double *a, int lda, const int *ipiv, double *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_dsytrs_rook$address() {
        return LAPACKE_dsytrs_rook.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dsytrs_rook(int matrix_layout, char uplo, int n, int nrhs, const double *a, int lda, const int *ipiv, double *b, int ldb)
     * }
     */
    public static int LAPACKE_dsytrs_rook(int matrix_layout, byte uplo, int n, int nrhs, MemorySegment a, int lda, MemorySegment ipiv, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_dsytrs_rook.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dsytrs_rook", matrix_layout, uplo, n, nrhs, a, lda, ipiv, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, nrhs, a, lda, ipiv, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_csytrs_rook {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_csytrs_rook");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_csytrs_rook(int matrix_layout, char uplo, int n, int nrhs, const _Complex float *a, int lda, const int *ipiv, _Complex float *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_csytrs_rook$descriptor() {
        return LAPACKE_csytrs_rook.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_csytrs_rook(int matrix_layout, char uplo, int n, int nrhs, const _Complex float *a, int lda, const int *ipiv, _Complex float *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_csytrs_rook$handle() {
        return LAPACKE_csytrs_rook.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_csytrs_rook(int matrix_layout, char uplo, int n, int nrhs, const _Complex float *a, int lda, const int *ipiv, _Complex float *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_csytrs_rook$address() {
        return LAPACKE_csytrs_rook.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_csytrs_rook(int matrix_layout, char uplo, int n, int nrhs, const _Complex float *a, int lda, const int *ipiv, _Complex float *b, int ldb)
     * }
     */
    public static int LAPACKE_csytrs_rook(int matrix_layout, byte uplo, int n, int nrhs, MemorySegment a, int lda, MemorySegment ipiv, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_csytrs_rook.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_csytrs_rook", matrix_layout, uplo, n, nrhs, a, lda, ipiv, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, nrhs, a, lda, ipiv, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zsytrs_rook {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zsytrs_rook");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zsytrs_rook(int matrix_layout, char uplo, int n, int nrhs, const _Complex double *a, int lda, const int *ipiv, _Complex double *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_zsytrs_rook$descriptor() {
        return LAPACKE_zsytrs_rook.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zsytrs_rook(int matrix_layout, char uplo, int n, int nrhs, const _Complex double *a, int lda, const int *ipiv, _Complex double *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_zsytrs_rook$handle() {
        return LAPACKE_zsytrs_rook.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zsytrs_rook(int matrix_layout, char uplo, int n, int nrhs, const _Complex double *a, int lda, const int *ipiv, _Complex double *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_zsytrs_rook$address() {
        return LAPACKE_zsytrs_rook.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zsytrs_rook(int matrix_layout, char uplo, int n, int nrhs, const _Complex double *a, int lda, const int *ipiv, _Complex double *b, int ldb)
     * }
     */
    public static int LAPACKE_zsytrs_rook(int matrix_layout, byte uplo, int n, int nrhs, MemorySegment a, int lda, MemorySegment ipiv, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_zsytrs_rook.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zsytrs_rook", matrix_layout, uplo, n, nrhs, a, lda, ipiv, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, nrhs, a, lda, ipiv, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_chetrf_rook {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_chetrf_rook");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_chetrf_rook(int matrix_layout, char uplo, int n, _Complex float *a, int lda, int *ipiv)
     * }
     */
    public static FunctionDescriptor LAPACKE_chetrf_rook$descriptor() {
        return LAPACKE_chetrf_rook.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_chetrf_rook(int matrix_layout, char uplo, int n, _Complex float *a, int lda, int *ipiv)
     * }
     */
    public static MethodHandle LAPACKE_chetrf_rook$handle() {
        return LAPACKE_chetrf_rook.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_chetrf_rook(int matrix_layout, char uplo, int n, _Complex float *a, int lda, int *ipiv)
     * }
     */
    public static MemorySegment LAPACKE_chetrf_rook$address() {
        return LAPACKE_chetrf_rook.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_chetrf_rook(int matrix_layout, char uplo, int n, _Complex float *a, int lda, int *ipiv)
     * }
     */
    public static int LAPACKE_chetrf_rook(int matrix_layout, byte uplo, int n, MemorySegment a, int lda, MemorySegment ipiv) {
        var mh$ = LAPACKE_chetrf_rook.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_chetrf_rook", matrix_layout, uplo, n, a, lda, ipiv);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, a, lda, ipiv);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zhetrf_rook {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zhetrf_rook");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zhetrf_rook(int matrix_layout, char uplo, int n, _Complex double *a, int lda, int *ipiv)
     * }
     */
    public static FunctionDescriptor LAPACKE_zhetrf_rook$descriptor() {
        return LAPACKE_zhetrf_rook.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zhetrf_rook(int matrix_layout, char uplo, int n, _Complex double *a, int lda, int *ipiv)
     * }
     */
    public static MethodHandle LAPACKE_zhetrf_rook$handle() {
        return LAPACKE_zhetrf_rook.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zhetrf_rook(int matrix_layout, char uplo, int n, _Complex double *a, int lda, int *ipiv)
     * }
     */
    public static MemorySegment LAPACKE_zhetrf_rook$address() {
        return LAPACKE_zhetrf_rook.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zhetrf_rook(int matrix_layout, char uplo, int n, _Complex double *a, int lda, int *ipiv)
     * }
     */
    public static int LAPACKE_zhetrf_rook(int matrix_layout, byte uplo, int n, MemorySegment a, int lda, MemorySegment ipiv) {
        var mh$ = LAPACKE_zhetrf_rook.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zhetrf_rook", matrix_layout, uplo, n, a, lda, ipiv);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, a, lda, ipiv);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_chetrs_rook {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_chetrs_rook");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_chetrs_rook(int matrix_layout, char uplo, int n, int nrhs, const _Complex float *a, int lda, const int *ipiv, _Complex float *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_chetrs_rook$descriptor() {
        return LAPACKE_chetrs_rook.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_chetrs_rook(int matrix_layout, char uplo, int n, int nrhs, const _Complex float *a, int lda, const int *ipiv, _Complex float *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_chetrs_rook$handle() {
        return LAPACKE_chetrs_rook.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_chetrs_rook(int matrix_layout, char uplo, int n, int nrhs, const _Complex float *a, int lda, const int *ipiv, _Complex float *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_chetrs_rook$address() {
        return LAPACKE_chetrs_rook.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_chetrs_rook(int matrix_layout, char uplo, int n, int nrhs, const _Complex float *a, int lda, const int *ipiv, _Complex float *b, int ldb)
     * }
     */
    public static int LAPACKE_chetrs_rook(int matrix_layout, byte uplo, int n, int nrhs, MemorySegment a, int lda, MemorySegment ipiv, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_chetrs_rook.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_chetrs_rook", matrix_layout, uplo, n, nrhs, a, lda, ipiv, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, nrhs, a, lda, ipiv, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zhetrs_rook {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zhetrs_rook");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zhetrs_rook(int matrix_layout, char uplo, int n, int nrhs, const _Complex double *a, int lda, const int *ipiv, _Complex double *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_zhetrs_rook$descriptor() {
        return LAPACKE_zhetrs_rook.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zhetrs_rook(int matrix_layout, char uplo, int n, int nrhs, const _Complex double *a, int lda, const int *ipiv, _Complex double *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_zhetrs_rook$handle() {
        return LAPACKE_zhetrs_rook.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zhetrs_rook(int matrix_layout, char uplo, int n, int nrhs, const _Complex double *a, int lda, const int *ipiv, _Complex double *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_zhetrs_rook$address() {
        return LAPACKE_zhetrs_rook.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zhetrs_rook(int matrix_layout, char uplo, int n, int nrhs, const _Complex double *a, int lda, const int *ipiv, _Complex double *b, int ldb)
     * }
     */
    public static int LAPACKE_zhetrs_rook(int matrix_layout, byte uplo, int n, int nrhs, MemorySegment a, int lda, MemorySegment ipiv, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_zhetrs_rook.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zhetrs_rook", matrix_layout, uplo, n, nrhs, a, lda, ipiv, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, nrhs, a, lda, ipiv, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_csyr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_FLOAT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_csyr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_csyr(int matrix_layout, char uplo, int n, _Complex float alpha, const _Complex float *x, int incx, _Complex float *a, int lda)
     * }
     */
    public static FunctionDescriptor LAPACKE_csyr$descriptor() {
        return LAPACKE_csyr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_csyr(int matrix_layout, char uplo, int n, _Complex float alpha, const _Complex float *x, int incx, _Complex float *a, int lda)
     * }
     */
    public static MethodHandle LAPACKE_csyr$handle() {
        return LAPACKE_csyr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_csyr(int matrix_layout, char uplo, int n, _Complex float alpha, const _Complex float *x, int incx, _Complex float *a, int lda)
     * }
     */
    public static MemorySegment LAPACKE_csyr$address() {
        return LAPACKE_csyr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_csyr(int matrix_layout, char uplo, int n, _Complex float alpha, const _Complex float *x, int incx, _Complex float *a, int lda)
     * }
     */
    public static int LAPACKE_csyr(int matrix_layout, byte uplo, int n, float alpha, MemorySegment x, int incx, MemorySegment a, int lda) {
        var mh$ = LAPACKE_csyr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_csyr", matrix_layout, uplo, n, alpha, x, incx, a, lda);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, alpha, x, incx, a, lda);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zsyr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_DOUBLE,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zsyr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zsyr(int matrix_layout, char uplo, int n, _Complex double alpha, const _Complex double *x, int incx, _Complex double *a, int lda)
     * }
     */
    public static FunctionDescriptor LAPACKE_zsyr$descriptor() {
        return LAPACKE_zsyr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zsyr(int matrix_layout, char uplo, int n, _Complex double alpha, const _Complex double *x, int incx, _Complex double *a, int lda)
     * }
     */
    public static MethodHandle LAPACKE_zsyr$handle() {
        return LAPACKE_zsyr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zsyr(int matrix_layout, char uplo, int n, _Complex double alpha, const _Complex double *x, int incx, _Complex double *a, int lda)
     * }
     */
    public static MemorySegment LAPACKE_zsyr$address() {
        return LAPACKE_zsyr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zsyr(int matrix_layout, char uplo, int n, _Complex double alpha, const _Complex double *x, int incx, _Complex double *a, int lda)
     * }
     */
    public static int LAPACKE_zsyr(int matrix_layout, byte uplo, int n, double alpha, MemorySegment x, int incx, MemorySegment a, int lda) {
        var mh$ = LAPACKE_zsyr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zsyr", matrix_layout, uplo, n, alpha, x, incx, a, lda);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, alpha, x, incx, a, lda);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ssysv_rook_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_ssysv_rook_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ssysv_rook_work(int matrix_layout, char uplo, int n, int nrhs, float *a, int lda, int *ipiv, float *b, int ldb, float *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_ssysv_rook_work$descriptor() {
        return LAPACKE_ssysv_rook_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ssysv_rook_work(int matrix_layout, char uplo, int n, int nrhs, float *a, int lda, int *ipiv, float *b, int ldb, float *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_ssysv_rook_work$handle() {
        return LAPACKE_ssysv_rook_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ssysv_rook_work(int matrix_layout, char uplo, int n, int nrhs, float *a, int lda, int *ipiv, float *b, int ldb, float *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_ssysv_rook_work$address() {
        return LAPACKE_ssysv_rook_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ssysv_rook_work(int matrix_layout, char uplo, int n, int nrhs, float *a, int lda, int *ipiv, float *b, int ldb, float *work, int lwork)
     * }
     */
    public static int LAPACKE_ssysv_rook_work(int matrix_layout, byte uplo, int n, int nrhs, MemorySegment a, int lda, MemorySegment ipiv, MemorySegment b, int ldb, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_ssysv_rook_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ssysv_rook_work", matrix_layout, uplo, n, nrhs, a, lda, ipiv, b, ldb, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, nrhs, a, lda, ipiv, b, ldb, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dsysv_rook_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dsysv_rook_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dsysv_rook_work(int matrix_layout, char uplo, int n, int nrhs, double *a, int lda, int *ipiv, double *b, int ldb, double *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_dsysv_rook_work$descriptor() {
        return LAPACKE_dsysv_rook_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dsysv_rook_work(int matrix_layout, char uplo, int n, int nrhs, double *a, int lda, int *ipiv, double *b, int ldb, double *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_dsysv_rook_work$handle() {
        return LAPACKE_dsysv_rook_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dsysv_rook_work(int matrix_layout, char uplo, int n, int nrhs, double *a, int lda, int *ipiv, double *b, int ldb, double *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_dsysv_rook_work$address() {
        return LAPACKE_dsysv_rook_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dsysv_rook_work(int matrix_layout, char uplo, int n, int nrhs, double *a, int lda, int *ipiv, double *b, int ldb, double *work, int lwork)
     * }
     */
    public static int LAPACKE_dsysv_rook_work(int matrix_layout, byte uplo, int n, int nrhs, MemorySegment a, int lda, MemorySegment ipiv, MemorySegment b, int ldb, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_dsysv_rook_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dsysv_rook_work", matrix_layout, uplo, n, nrhs, a, lda, ipiv, b, ldb, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, nrhs, a, lda, ipiv, b, ldb, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_csysv_rook_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_csysv_rook_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_csysv_rook_work(int matrix_layout, char uplo, int n, int nrhs, _Complex float *a, int lda, int *ipiv, _Complex float *b, int ldb, _Complex float *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_csysv_rook_work$descriptor() {
        return LAPACKE_csysv_rook_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_csysv_rook_work(int matrix_layout, char uplo, int n, int nrhs, _Complex float *a, int lda, int *ipiv, _Complex float *b, int ldb, _Complex float *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_csysv_rook_work$handle() {
        return LAPACKE_csysv_rook_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_csysv_rook_work(int matrix_layout, char uplo, int n, int nrhs, _Complex float *a, int lda, int *ipiv, _Complex float *b, int ldb, _Complex float *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_csysv_rook_work$address() {
        return LAPACKE_csysv_rook_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_csysv_rook_work(int matrix_layout, char uplo, int n, int nrhs, _Complex float *a, int lda, int *ipiv, _Complex float *b, int ldb, _Complex float *work, int lwork)
     * }
     */
    public static int LAPACKE_csysv_rook_work(int matrix_layout, byte uplo, int n, int nrhs, MemorySegment a, int lda, MemorySegment ipiv, MemorySegment b, int ldb, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_csysv_rook_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_csysv_rook_work", matrix_layout, uplo, n, nrhs, a, lda, ipiv, b, ldb, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, nrhs, a, lda, ipiv, b, ldb, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zsysv_rook_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zsysv_rook_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zsysv_rook_work(int matrix_layout, char uplo, int n, int nrhs, _Complex double *a, int lda, int *ipiv, _Complex double *b, int ldb, _Complex double *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_zsysv_rook_work$descriptor() {
        return LAPACKE_zsysv_rook_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zsysv_rook_work(int matrix_layout, char uplo, int n, int nrhs, _Complex double *a, int lda, int *ipiv, _Complex double *b, int ldb, _Complex double *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_zsysv_rook_work$handle() {
        return LAPACKE_zsysv_rook_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zsysv_rook_work(int matrix_layout, char uplo, int n, int nrhs, _Complex double *a, int lda, int *ipiv, _Complex double *b, int ldb, _Complex double *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_zsysv_rook_work$address() {
        return LAPACKE_zsysv_rook_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zsysv_rook_work(int matrix_layout, char uplo, int n, int nrhs, _Complex double *a, int lda, int *ipiv, _Complex double *b, int ldb, _Complex double *work, int lwork)
     * }
     */
    public static int LAPACKE_zsysv_rook_work(int matrix_layout, byte uplo, int n, int nrhs, MemorySegment a, int lda, MemorySegment ipiv, MemorySegment b, int ldb, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_zsysv_rook_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zsysv_rook_work", matrix_layout, uplo, n, nrhs, a, lda, ipiv, b, ldb, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, nrhs, a, lda, ipiv, b, ldb, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ssytrf_rook_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_ssytrf_rook_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ssytrf_rook_work(int matrix_layout, char uplo, int n, float *a, int lda, int *ipiv, float *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_ssytrf_rook_work$descriptor() {
        return LAPACKE_ssytrf_rook_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ssytrf_rook_work(int matrix_layout, char uplo, int n, float *a, int lda, int *ipiv, float *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_ssytrf_rook_work$handle() {
        return LAPACKE_ssytrf_rook_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ssytrf_rook_work(int matrix_layout, char uplo, int n, float *a, int lda, int *ipiv, float *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_ssytrf_rook_work$address() {
        return LAPACKE_ssytrf_rook_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ssytrf_rook_work(int matrix_layout, char uplo, int n, float *a, int lda, int *ipiv, float *work, int lwork)
     * }
     */
    public static int LAPACKE_ssytrf_rook_work(int matrix_layout, byte uplo, int n, MemorySegment a, int lda, MemorySegment ipiv, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_ssytrf_rook_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ssytrf_rook_work", matrix_layout, uplo, n, a, lda, ipiv, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, a, lda, ipiv, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dsytrf_rook_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dsytrf_rook_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dsytrf_rook_work(int matrix_layout, char uplo, int n, double *a, int lda, int *ipiv, double *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_dsytrf_rook_work$descriptor() {
        return LAPACKE_dsytrf_rook_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dsytrf_rook_work(int matrix_layout, char uplo, int n, double *a, int lda, int *ipiv, double *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_dsytrf_rook_work$handle() {
        return LAPACKE_dsytrf_rook_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dsytrf_rook_work(int matrix_layout, char uplo, int n, double *a, int lda, int *ipiv, double *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_dsytrf_rook_work$address() {
        return LAPACKE_dsytrf_rook_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dsytrf_rook_work(int matrix_layout, char uplo, int n, double *a, int lda, int *ipiv, double *work, int lwork)
     * }
     */
    public static int LAPACKE_dsytrf_rook_work(int matrix_layout, byte uplo, int n, MemorySegment a, int lda, MemorySegment ipiv, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_dsytrf_rook_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dsytrf_rook_work", matrix_layout, uplo, n, a, lda, ipiv, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, a, lda, ipiv, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_csytrf_rook_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_csytrf_rook_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_csytrf_rook_work(int matrix_layout, char uplo, int n, _Complex float *a, int lda, int *ipiv, _Complex float *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_csytrf_rook_work$descriptor() {
        return LAPACKE_csytrf_rook_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_csytrf_rook_work(int matrix_layout, char uplo, int n, _Complex float *a, int lda, int *ipiv, _Complex float *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_csytrf_rook_work$handle() {
        return LAPACKE_csytrf_rook_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_csytrf_rook_work(int matrix_layout, char uplo, int n, _Complex float *a, int lda, int *ipiv, _Complex float *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_csytrf_rook_work$address() {
        return LAPACKE_csytrf_rook_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_csytrf_rook_work(int matrix_layout, char uplo, int n, _Complex float *a, int lda, int *ipiv, _Complex float *work, int lwork)
     * }
     */
    public static int LAPACKE_csytrf_rook_work(int matrix_layout, byte uplo, int n, MemorySegment a, int lda, MemorySegment ipiv, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_csytrf_rook_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_csytrf_rook_work", matrix_layout, uplo, n, a, lda, ipiv, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, a, lda, ipiv, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zsytrf_rook_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zsytrf_rook_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zsytrf_rook_work(int matrix_layout, char uplo, int n, _Complex double *a, int lda, int *ipiv, _Complex double *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_zsytrf_rook_work$descriptor() {
        return LAPACKE_zsytrf_rook_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zsytrf_rook_work(int matrix_layout, char uplo, int n, _Complex double *a, int lda, int *ipiv, _Complex double *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_zsytrf_rook_work$handle() {
        return LAPACKE_zsytrf_rook_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zsytrf_rook_work(int matrix_layout, char uplo, int n, _Complex double *a, int lda, int *ipiv, _Complex double *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_zsytrf_rook_work$address() {
        return LAPACKE_zsytrf_rook_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zsytrf_rook_work(int matrix_layout, char uplo, int n, _Complex double *a, int lda, int *ipiv, _Complex double *work, int lwork)
     * }
     */
    public static int LAPACKE_zsytrf_rook_work(int matrix_layout, byte uplo, int n, MemorySegment a, int lda, MemorySegment ipiv, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_zsytrf_rook_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zsytrf_rook_work", matrix_layout, uplo, n, a, lda, ipiv, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, a, lda, ipiv, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ssytrs_rook_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_ssytrs_rook_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ssytrs_rook_work(int matrix_layout, char uplo, int n, int nrhs, const float *a, int lda, const int *ipiv, float *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_ssytrs_rook_work$descriptor() {
        return LAPACKE_ssytrs_rook_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ssytrs_rook_work(int matrix_layout, char uplo, int n, int nrhs, const float *a, int lda, const int *ipiv, float *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_ssytrs_rook_work$handle() {
        return LAPACKE_ssytrs_rook_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ssytrs_rook_work(int matrix_layout, char uplo, int n, int nrhs, const float *a, int lda, const int *ipiv, float *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_ssytrs_rook_work$address() {
        return LAPACKE_ssytrs_rook_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ssytrs_rook_work(int matrix_layout, char uplo, int n, int nrhs, const float *a, int lda, const int *ipiv, float *b, int ldb)
     * }
     */
    public static int LAPACKE_ssytrs_rook_work(int matrix_layout, byte uplo, int n, int nrhs, MemorySegment a, int lda, MemorySegment ipiv, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_ssytrs_rook_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ssytrs_rook_work", matrix_layout, uplo, n, nrhs, a, lda, ipiv, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, nrhs, a, lda, ipiv, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dsytrs_rook_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dsytrs_rook_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dsytrs_rook_work(int matrix_layout, char uplo, int n, int nrhs, const double *a, int lda, const int *ipiv, double *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_dsytrs_rook_work$descriptor() {
        return LAPACKE_dsytrs_rook_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dsytrs_rook_work(int matrix_layout, char uplo, int n, int nrhs, const double *a, int lda, const int *ipiv, double *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_dsytrs_rook_work$handle() {
        return LAPACKE_dsytrs_rook_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dsytrs_rook_work(int matrix_layout, char uplo, int n, int nrhs, const double *a, int lda, const int *ipiv, double *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_dsytrs_rook_work$address() {
        return LAPACKE_dsytrs_rook_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dsytrs_rook_work(int matrix_layout, char uplo, int n, int nrhs, const double *a, int lda, const int *ipiv, double *b, int ldb)
     * }
     */
    public static int LAPACKE_dsytrs_rook_work(int matrix_layout, byte uplo, int n, int nrhs, MemorySegment a, int lda, MemorySegment ipiv, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_dsytrs_rook_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dsytrs_rook_work", matrix_layout, uplo, n, nrhs, a, lda, ipiv, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, nrhs, a, lda, ipiv, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_csytrs_rook_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_csytrs_rook_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_csytrs_rook_work(int matrix_layout, char uplo, int n, int nrhs, const _Complex float *a, int lda, const int *ipiv, _Complex float *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_csytrs_rook_work$descriptor() {
        return LAPACKE_csytrs_rook_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_csytrs_rook_work(int matrix_layout, char uplo, int n, int nrhs, const _Complex float *a, int lda, const int *ipiv, _Complex float *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_csytrs_rook_work$handle() {
        return LAPACKE_csytrs_rook_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_csytrs_rook_work(int matrix_layout, char uplo, int n, int nrhs, const _Complex float *a, int lda, const int *ipiv, _Complex float *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_csytrs_rook_work$address() {
        return LAPACKE_csytrs_rook_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_csytrs_rook_work(int matrix_layout, char uplo, int n, int nrhs, const _Complex float *a, int lda, const int *ipiv, _Complex float *b, int ldb)
     * }
     */
    public static int LAPACKE_csytrs_rook_work(int matrix_layout, byte uplo, int n, int nrhs, MemorySegment a, int lda, MemorySegment ipiv, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_csytrs_rook_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_csytrs_rook_work", matrix_layout, uplo, n, nrhs, a, lda, ipiv, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, nrhs, a, lda, ipiv, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zsytrs_rook_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zsytrs_rook_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zsytrs_rook_work(int matrix_layout, char uplo, int n, int nrhs, const _Complex double *a, int lda, const int *ipiv, _Complex double *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_zsytrs_rook_work$descriptor() {
        return LAPACKE_zsytrs_rook_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zsytrs_rook_work(int matrix_layout, char uplo, int n, int nrhs, const _Complex double *a, int lda, const int *ipiv, _Complex double *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_zsytrs_rook_work$handle() {
        return LAPACKE_zsytrs_rook_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zsytrs_rook_work(int matrix_layout, char uplo, int n, int nrhs, const _Complex double *a, int lda, const int *ipiv, _Complex double *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_zsytrs_rook_work$address() {
        return LAPACKE_zsytrs_rook_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zsytrs_rook_work(int matrix_layout, char uplo, int n, int nrhs, const _Complex double *a, int lda, const int *ipiv, _Complex double *b, int ldb)
     * }
     */
    public static int LAPACKE_zsytrs_rook_work(int matrix_layout, byte uplo, int n, int nrhs, MemorySegment a, int lda, MemorySegment ipiv, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_zsytrs_rook_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zsytrs_rook_work", matrix_layout, uplo, n, nrhs, a, lda, ipiv, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, nrhs, a, lda, ipiv, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_chetrf_rook_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_chetrf_rook_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_chetrf_rook_work(int matrix_layout, char uplo, int n, _Complex float *a, int lda, int *ipiv, _Complex float *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_chetrf_rook_work$descriptor() {
        return LAPACKE_chetrf_rook_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_chetrf_rook_work(int matrix_layout, char uplo, int n, _Complex float *a, int lda, int *ipiv, _Complex float *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_chetrf_rook_work$handle() {
        return LAPACKE_chetrf_rook_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_chetrf_rook_work(int matrix_layout, char uplo, int n, _Complex float *a, int lda, int *ipiv, _Complex float *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_chetrf_rook_work$address() {
        return LAPACKE_chetrf_rook_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_chetrf_rook_work(int matrix_layout, char uplo, int n, _Complex float *a, int lda, int *ipiv, _Complex float *work, int lwork)
     * }
     */
    public static int LAPACKE_chetrf_rook_work(int matrix_layout, byte uplo, int n, MemorySegment a, int lda, MemorySegment ipiv, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_chetrf_rook_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_chetrf_rook_work", matrix_layout, uplo, n, a, lda, ipiv, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, a, lda, ipiv, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zhetrf_rook_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zhetrf_rook_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zhetrf_rook_work(int matrix_layout, char uplo, int n, _Complex double *a, int lda, int *ipiv, _Complex double *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_zhetrf_rook_work$descriptor() {
        return LAPACKE_zhetrf_rook_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zhetrf_rook_work(int matrix_layout, char uplo, int n, _Complex double *a, int lda, int *ipiv, _Complex double *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_zhetrf_rook_work$handle() {
        return LAPACKE_zhetrf_rook_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zhetrf_rook_work(int matrix_layout, char uplo, int n, _Complex double *a, int lda, int *ipiv, _Complex double *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_zhetrf_rook_work$address() {
        return LAPACKE_zhetrf_rook_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zhetrf_rook_work(int matrix_layout, char uplo, int n, _Complex double *a, int lda, int *ipiv, _Complex double *work, int lwork)
     * }
     */
    public static int LAPACKE_zhetrf_rook_work(int matrix_layout, byte uplo, int n, MemorySegment a, int lda, MemorySegment ipiv, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_zhetrf_rook_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zhetrf_rook_work", matrix_layout, uplo, n, a, lda, ipiv, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, a, lda, ipiv, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_chetrs_rook_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_chetrs_rook_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_chetrs_rook_work(int matrix_layout, char uplo, int n, int nrhs, const _Complex float *a, int lda, const int *ipiv, _Complex float *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_chetrs_rook_work$descriptor() {
        return LAPACKE_chetrs_rook_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_chetrs_rook_work(int matrix_layout, char uplo, int n, int nrhs, const _Complex float *a, int lda, const int *ipiv, _Complex float *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_chetrs_rook_work$handle() {
        return LAPACKE_chetrs_rook_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_chetrs_rook_work(int matrix_layout, char uplo, int n, int nrhs, const _Complex float *a, int lda, const int *ipiv, _Complex float *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_chetrs_rook_work$address() {
        return LAPACKE_chetrs_rook_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_chetrs_rook_work(int matrix_layout, char uplo, int n, int nrhs, const _Complex float *a, int lda, const int *ipiv, _Complex float *b, int ldb)
     * }
     */
    public static int LAPACKE_chetrs_rook_work(int matrix_layout, byte uplo, int n, int nrhs, MemorySegment a, int lda, MemorySegment ipiv, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_chetrs_rook_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_chetrs_rook_work", matrix_layout, uplo, n, nrhs, a, lda, ipiv, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, nrhs, a, lda, ipiv, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zhetrs_rook_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zhetrs_rook_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zhetrs_rook_work(int matrix_layout, char uplo, int n, int nrhs, const _Complex double *a, int lda, const int *ipiv, _Complex double *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_zhetrs_rook_work$descriptor() {
        return LAPACKE_zhetrs_rook_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zhetrs_rook_work(int matrix_layout, char uplo, int n, int nrhs, const _Complex double *a, int lda, const int *ipiv, _Complex double *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_zhetrs_rook_work$handle() {
        return LAPACKE_zhetrs_rook_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zhetrs_rook_work(int matrix_layout, char uplo, int n, int nrhs, const _Complex double *a, int lda, const int *ipiv, _Complex double *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_zhetrs_rook_work$address() {
        return LAPACKE_zhetrs_rook_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zhetrs_rook_work(int matrix_layout, char uplo, int n, int nrhs, const _Complex double *a, int lda, const int *ipiv, _Complex double *b, int ldb)
     * }
     */
    public static int LAPACKE_zhetrs_rook_work(int matrix_layout, byte uplo, int n, int nrhs, MemorySegment a, int lda, MemorySegment ipiv, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_zhetrs_rook_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zhetrs_rook_work", matrix_layout, uplo, n, nrhs, a, lda, ipiv, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, nrhs, a, lda, ipiv, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_csyr_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_FLOAT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_csyr_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_csyr_work(int matrix_layout, char uplo, int n, _Complex float alpha, const _Complex float *x, int incx, _Complex float *a, int lda)
     * }
     */
    public static FunctionDescriptor LAPACKE_csyr_work$descriptor() {
        return LAPACKE_csyr_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_csyr_work(int matrix_layout, char uplo, int n, _Complex float alpha, const _Complex float *x, int incx, _Complex float *a, int lda)
     * }
     */
    public static MethodHandle LAPACKE_csyr_work$handle() {
        return LAPACKE_csyr_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_csyr_work(int matrix_layout, char uplo, int n, _Complex float alpha, const _Complex float *x, int incx, _Complex float *a, int lda)
     * }
     */
    public static MemorySegment LAPACKE_csyr_work$address() {
        return LAPACKE_csyr_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_csyr_work(int matrix_layout, char uplo, int n, _Complex float alpha, const _Complex float *x, int incx, _Complex float *a, int lda)
     * }
     */
    public static int LAPACKE_csyr_work(int matrix_layout, byte uplo, int n, float alpha, MemorySegment x, int incx, MemorySegment a, int lda) {
        var mh$ = LAPACKE_csyr_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_csyr_work", matrix_layout, uplo, n, alpha, x, incx, a, lda);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, alpha, x, incx, a, lda);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zsyr_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_DOUBLE,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zsyr_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zsyr_work(int matrix_layout, char uplo, int n, _Complex double alpha, const _Complex double *x, int incx, _Complex double *a, int lda)
     * }
     */
    public static FunctionDescriptor LAPACKE_zsyr_work$descriptor() {
        return LAPACKE_zsyr_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zsyr_work(int matrix_layout, char uplo, int n, _Complex double alpha, const _Complex double *x, int incx, _Complex double *a, int lda)
     * }
     */
    public static MethodHandle LAPACKE_zsyr_work$handle() {
        return LAPACKE_zsyr_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zsyr_work(int matrix_layout, char uplo, int n, _Complex double alpha, const _Complex double *x, int incx, _Complex double *a, int lda)
     * }
     */
    public static MemorySegment LAPACKE_zsyr_work$address() {
        return LAPACKE_zsyr_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zsyr_work(int matrix_layout, char uplo, int n, _Complex double alpha, const _Complex double *x, int incx, _Complex double *a, int lda)
     * }
     */
    public static int LAPACKE_zsyr_work(int matrix_layout, byte uplo, int n, double alpha, MemorySegment x, int incx, MemorySegment a, int lda) {
        var mh$ = LAPACKE_zsyr_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zsyr_work", matrix_layout, uplo, n, alpha, x, incx, a, lda);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, alpha, x, incx, a, lda);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ilaver {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_ilaver");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void LAPACKE_ilaver(int *vers_major, int *vers_minor, int *vers_patch)
     * }
     */
    public static FunctionDescriptor LAPACKE_ilaver$descriptor() {
        return LAPACKE_ilaver.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void LAPACKE_ilaver(int *vers_major, int *vers_minor, int *vers_patch)
     * }
     */
    public static MethodHandle LAPACKE_ilaver$handle() {
        return LAPACKE_ilaver.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void LAPACKE_ilaver(int *vers_major, int *vers_minor, int *vers_patch)
     * }
     */
    public static MemorySegment LAPACKE_ilaver$address() {
        return LAPACKE_ilaver.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void LAPACKE_ilaver(int *vers_major, int *vers_minor, int *vers_patch)
     * }
     */
    public static void LAPACKE_ilaver(MemorySegment vers_major, MemorySegment vers_minor, MemorySegment vers_patch) {
        var mh$ = LAPACKE_ilaver.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ilaver", vers_major, vers_minor, vers_patch);
            }
            mh$.invokeExact(vers_major, vers_minor, vers_patch);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ssysv_aa {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_ssysv_aa");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ssysv_aa(int matrix_layout, char uplo, int n, int nrhs, float *a, int lda, int *ipiv, float *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_ssysv_aa$descriptor() {
        return LAPACKE_ssysv_aa.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ssysv_aa(int matrix_layout, char uplo, int n, int nrhs, float *a, int lda, int *ipiv, float *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_ssysv_aa$handle() {
        return LAPACKE_ssysv_aa.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ssysv_aa(int matrix_layout, char uplo, int n, int nrhs, float *a, int lda, int *ipiv, float *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_ssysv_aa$address() {
        return LAPACKE_ssysv_aa.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ssysv_aa(int matrix_layout, char uplo, int n, int nrhs, float *a, int lda, int *ipiv, float *b, int ldb)
     * }
     */
    public static int LAPACKE_ssysv_aa(int matrix_layout, byte uplo, int n, int nrhs, MemorySegment a, int lda, MemorySegment ipiv, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_ssysv_aa.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ssysv_aa", matrix_layout, uplo, n, nrhs, a, lda, ipiv, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, nrhs, a, lda, ipiv, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ssysv_aa_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_ssysv_aa_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ssysv_aa_work(int matrix_layout, char uplo, int n, int nrhs, float *a, int lda, int *ipiv, float *b, int ldb, float *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_ssysv_aa_work$descriptor() {
        return LAPACKE_ssysv_aa_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ssysv_aa_work(int matrix_layout, char uplo, int n, int nrhs, float *a, int lda, int *ipiv, float *b, int ldb, float *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_ssysv_aa_work$handle() {
        return LAPACKE_ssysv_aa_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ssysv_aa_work(int matrix_layout, char uplo, int n, int nrhs, float *a, int lda, int *ipiv, float *b, int ldb, float *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_ssysv_aa_work$address() {
        return LAPACKE_ssysv_aa_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ssysv_aa_work(int matrix_layout, char uplo, int n, int nrhs, float *a, int lda, int *ipiv, float *b, int ldb, float *work, int lwork)
     * }
     */
    public static int LAPACKE_ssysv_aa_work(int matrix_layout, byte uplo, int n, int nrhs, MemorySegment a, int lda, MemorySegment ipiv, MemorySegment b, int ldb, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_ssysv_aa_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ssysv_aa_work", matrix_layout, uplo, n, nrhs, a, lda, ipiv, b, ldb, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, nrhs, a, lda, ipiv, b, ldb, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dsysv_aa {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dsysv_aa");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dsysv_aa(int matrix_layout, char uplo, int n, int nrhs, double *a, int lda, int *ipiv, double *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_dsysv_aa$descriptor() {
        return LAPACKE_dsysv_aa.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dsysv_aa(int matrix_layout, char uplo, int n, int nrhs, double *a, int lda, int *ipiv, double *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_dsysv_aa$handle() {
        return LAPACKE_dsysv_aa.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dsysv_aa(int matrix_layout, char uplo, int n, int nrhs, double *a, int lda, int *ipiv, double *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_dsysv_aa$address() {
        return LAPACKE_dsysv_aa.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dsysv_aa(int matrix_layout, char uplo, int n, int nrhs, double *a, int lda, int *ipiv, double *b, int ldb)
     * }
     */
    public static int LAPACKE_dsysv_aa(int matrix_layout, byte uplo, int n, int nrhs, MemorySegment a, int lda, MemorySegment ipiv, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_dsysv_aa.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dsysv_aa", matrix_layout, uplo, n, nrhs, a, lda, ipiv, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, nrhs, a, lda, ipiv, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dsysv_aa_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dsysv_aa_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dsysv_aa_work(int matrix_layout, char uplo, int n, int nrhs, double *a, int lda, int *ipiv, double *b, int ldb, double *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_dsysv_aa_work$descriptor() {
        return LAPACKE_dsysv_aa_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dsysv_aa_work(int matrix_layout, char uplo, int n, int nrhs, double *a, int lda, int *ipiv, double *b, int ldb, double *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_dsysv_aa_work$handle() {
        return LAPACKE_dsysv_aa_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dsysv_aa_work(int matrix_layout, char uplo, int n, int nrhs, double *a, int lda, int *ipiv, double *b, int ldb, double *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_dsysv_aa_work$address() {
        return LAPACKE_dsysv_aa_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dsysv_aa_work(int matrix_layout, char uplo, int n, int nrhs, double *a, int lda, int *ipiv, double *b, int ldb, double *work, int lwork)
     * }
     */
    public static int LAPACKE_dsysv_aa_work(int matrix_layout, byte uplo, int n, int nrhs, MemorySegment a, int lda, MemorySegment ipiv, MemorySegment b, int ldb, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_dsysv_aa_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dsysv_aa_work", matrix_layout, uplo, n, nrhs, a, lda, ipiv, b, ldb, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, nrhs, a, lda, ipiv, b, ldb, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_csysv_aa {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_csysv_aa");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_csysv_aa(int matrix_layout, char uplo, int n, int nrhs, _Complex float *a, int lda, int *ipiv, _Complex float *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_csysv_aa$descriptor() {
        return LAPACKE_csysv_aa.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_csysv_aa(int matrix_layout, char uplo, int n, int nrhs, _Complex float *a, int lda, int *ipiv, _Complex float *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_csysv_aa$handle() {
        return LAPACKE_csysv_aa.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_csysv_aa(int matrix_layout, char uplo, int n, int nrhs, _Complex float *a, int lda, int *ipiv, _Complex float *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_csysv_aa$address() {
        return LAPACKE_csysv_aa.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_csysv_aa(int matrix_layout, char uplo, int n, int nrhs, _Complex float *a, int lda, int *ipiv, _Complex float *b, int ldb)
     * }
     */
    public static int LAPACKE_csysv_aa(int matrix_layout, byte uplo, int n, int nrhs, MemorySegment a, int lda, MemorySegment ipiv, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_csysv_aa.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_csysv_aa", matrix_layout, uplo, n, nrhs, a, lda, ipiv, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, nrhs, a, lda, ipiv, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_csysv_aa_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_csysv_aa_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_csysv_aa_work(int matrix_layout, char uplo, int n, int nrhs, _Complex float *a, int lda, int *ipiv, _Complex float *b, int ldb, _Complex float *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_csysv_aa_work$descriptor() {
        return LAPACKE_csysv_aa_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_csysv_aa_work(int matrix_layout, char uplo, int n, int nrhs, _Complex float *a, int lda, int *ipiv, _Complex float *b, int ldb, _Complex float *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_csysv_aa_work$handle() {
        return LAPACKE_csysv_aa_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_csysv_aa_work(int matrix_layout, char uplo, int n, int nrhs, _Complex float *a, int lda, int *ipiv, _Complex float *b, int ldb, _Complex float *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_csysv_aa_work$address() {
        return LAPACKE_csysv_aa_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_csysv_aa_work(int matrix_layout, char uplo, int n, int nrhs, _Complex float *a, int lda, int *ipiv, _Complex float *b, int ldb, _Complex float *work, int lwork)
     * }
     */
    public static int LAPACKE_csysv_aa_work(int matrix_layout, byte uplo, int n, int nrhs, MemorySegment a, int lda, MemorySegment ipiv, MemorySegment b, int ldb, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_csysv_aa_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_csysv_aa_work", matrix_layout, uplo, n, nrhs, a, lda, ipiv, b, ldb, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, nrhs, a, lda, ipiv, b, ldb, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zsysv_aa {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zsysv_aa");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zsysv_aa(int matrix_layout, char uplo, int n, int nrhs, _Complex double *a, int lda, int *ipiv, _Complex double *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_zsysv_aa$descriptor() {
        return LAPACKE_zsysv_aa.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zsysv_aa(int matrix_layout, char uplo, int n, int nrhs, _Complex double *a, int lda, int *ipiv, _Complex double *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_zsysv_aa$handle() {
        return LAPACKE_zsysv_aa.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zsysv_aa(int matrix_layout, char uplo, int n, int nrhs, _Complex double *a, int lda, int *ipiv, _Complex double *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_zsysv_aa$address() {
        return LAPACKE_zsysv_aa.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zsysv_aa(int matrix_layout, char uplo, int n, int nrhs, _Complex double *a, int lda, int *ipiv, _Complex double *b, int ldb)
     * }
     */
    public static int LAPACKE_zsysv_aa(int matrix_layout, byte uplo, int n, int nrhs, MemorySegment a, int lda, MemorySegment ipiv, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_zsysv_aa.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zsysv_aa", matrix_layout, uplo, n, nrhs, a, lda, ipiv, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, nrhs, a, lda, ipiv, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zsysv_aa_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zsysv_aa_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zsysv_aa_work(int matrix_layout, char uplo, int n, int nrhs, _Complex double *a, int lda, int *ipiv, _Complex double *b, int ldb, _Complex double *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_zsysv_aa_work$descriptor() {
        return LAPACKE_zsysv_aa_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zsysv_aa_work(int matrix_layout, char uplo, int n, int nrhs, _Complex double *a, int lda, int *ipiv, _Complex double *b, int ldb, _Complex double *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_zsysv_aa_work$handle() {
        return LAPACKE_zsysv_aa_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zsysv_aa_work(int matrix_layout, char uplo, int n, int nrhs, _Complex double *a, int lda, int *ipiv, _Complex double *b, int ldb, _Complex double *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_zsysv_aa_work$address() {
        return LAPACKE_zsysv_aa_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zsysv_aa_work(int matrix_layout, char uplo, int n, int nrhs, _Complex double *a, int lda, int *ipiv, _Complex double *b, int ldb, _Complex double *work, int lwork)
     * }
     */
    public static int LAPACKE_zsysv_aa_work(int matrix_layout, byte uplo, int n, int nrhs, MemorySegment a, int lda, MemorySegment ipiv, MemorySegment b, int ldb, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_zsysv_aa_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zsysv_aa_work", matrix_layout, uplo, n, nrhs, a, lda, ipiv, b, ldb, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, nrhs, a, lda, ipiv, b, ldb, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_chesv_aa {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_chesv_aa");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_chesv_aa(int matrix_layout, char uplo, int n, int nrhs, _Complex float *a, int lda, int *ipiv, _Complex float *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_chesv_aa$descriptor() {
        return LAPACKE_chesv_aa.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_chesv_aa(int matrix_layout, char uplo, int n, int nrhs, _Complex float *a, int lda, int *ipiv, _Complex float *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_chesv_aa$handle() {
        return LAPACKE_chesv_aa.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_chesv_aa(int matrix_layout, char uplo, int n, int nrhs, _Complex float *a, int lda, int *ipiv, _Complex float *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_chesv_aa$address() {
        return LAPACKE_chesv_aa.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_chesv_aa(int matrix_layout, char uplo, int n, int nrhs, _Complex float *a, int lda, int *ipiv, _Complex float *b, int ldb)
     * }
     */
    public static int LAPACKE_chesv_aa(int matrix_layout, byte uplo, int n, int nrhs, MemorySegment a, int lda, MemorySegment ipiv, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_chesv_aa.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_chesv_aa", matrix_layout, uplo, n, nrhs, a, lda, ipiv, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, nrhs, a, lda, ipiv, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_chesv_aa_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_chesv_aa_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_chesv_aa_work(int matrix_layout, char uplo, int n, int nrhs, _Complex float *a, int lda, int *ipiv, _Complex float *b, int ldb, _Complex float *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_chesv_aa_work$descriptor() {
        return LAPACKE_chesv_aa_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_chesv_aa_work(int matrix_layout, char uplo, int n, int nrhs, _Complex float *a, int lda, int *ipiv, _Complex float *b, int ldb, _Complex float *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_chesv_aa_work$handle() {
        return LAPACKE_chesv_aa_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_chesv_aa_work(int matrix_layout, char uplo, int n, int nrhs, _Complex float *a, int lda, int *ipiv, _Complex float *b, int ldb, _Complex float *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_chesv_aa_work$address() {
        return LAPACKE_chesv_aa_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_chesv_aa_work(int matrix_layout, char uplo, int n, int nrhs, _Complex float *a, int lda, int *ipiv, _Complex float *b, int ldb, _Complex float *work, int lwork)
     * }
     */
    public static int LAPACKE_chesv_aa_work(int matrix_layout, byte uplo, int n, int nrhs, MemorySegment a, int lda, MemorySegment ipiv, MemorySegment b, int ldb, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_chesv_aa_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_chesv_aa_work", matrix_layout, uplo, n, nrhs, a, lda, ipiv, b, ldb, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, nrhs, a, lda, ipiv, b, ldb, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zhesv_aa {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zhesv_aa");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zhesv_aa(int matrix_layout, char uplo, int n, int nrhs, _Complex double *a, int lda, int *ipiv, _Complex double *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_zhesv_aa$descriptor() {
        return LAPACKE_zhesv_aa.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zhesv_aa(int matrix_layout, char uplo, int n, int nrhs, _Complex double *a, int lda, int *ipiv, _Complex double *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_zhesv_aa$handle() {
        return LAPACKE_zhesv_aa.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zhesv_aa(int matrix_layout, char uplo, int n, int nrhs, _Complex double *a, int lda, int *ipiv, _Complex double *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_zhesv_aa$address() {
        return LAPACKE_zhesv_aa.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zhesv_aa(int matrix_layout, char uplo, int n, int nrhs, _Complex double *a, int lda, int *ipiv, _Complex double *b, int ldb)
     * }
     */
    public static int LAPACKE_zhesv_aa(int matrix_layout, byte uplo, int n, int nrhs, MemorySegment a, int lda, MemorySegment ipiv, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_zhesv_aa.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zhesv_aa", matrix_layout, uplo, n, nrhs, a, lda, ipiv, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, nrhs, a, lda, ipiv, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zhesv_aa_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zhesv_aa_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zhesv_aa_work(int matrix_layout, char uplo, int n, int nrhs, _Complex double *a, int lda, int *ipiv, _Complex double *b, int ldb, _Complex double *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_zhesv_aa_work$descriptor() {
        return LAPACKE_zhesv_aa_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zhesv_aa_work(int matrix_layout, char uplo, int n, int nrhs, _Complex double *a, int lda, int *ipiv, _Complex double *b, int ldb, _Complex double *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_zhesv_aa_work$handle() {
        return LAPACKE_zhesv_aa_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zhesv_aa_work(int matrix_layout, char uplo, int n, int nrhs, _Complex double *a, int lda, int *ipiv, _Complex double *b, int ldb, _Complex double *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_zhesv_aa_work$address() {
        return LAPACKE_zhesv_aa_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zhesv_aa_work(int matrix_layout, char uplo, int n, int nrhs, _Complex double *a, int lda, int *ipiv, _Complex double *b, int ldb, _Complex double *work, int lwork)
     * }
     */
    public static int LAPACKE_zhesv_aa_work(int matrix_layout, byte uplo, int n, int nrhs, MemorySegment a, int lda, MemorySegment ipiv, MemorySegment b, int ldb, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_zhesv_aa_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zhesv_aa_work", matrix_layout, uplo, n, nrhs, a, lda, ipiv, b, ldb, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, nrhs, a, lda, ipiv, b, ldb, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ssytrf_aa {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_ssytrf_aa");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ssytrf_aa(int matrix_layout, char uplo, int n, float *a, int lda, int *ipiv)
     * }
     */
    public static FunctionDescriptor LAPACKE_ssytrf_aa$descriptor() {
        return LAPACKE_ssytrf_aa.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ssytrf_aa(int matrix_layout, char uplo, int n, float *a, int lda, int *ipiv)
     * }
     */
    public static MethodHandle LAPACKE_ssytrf_aa$handle() {
        return LAPACKE_ssytrf_aa.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ssytrf_aa(int matrix_layout, char uplo, int n, float *a, int lda, int *ipiv)
     * }
     */
    public static MemorySegment LAPACKE_ssytrf_aa$address() {
        return LAPACKE_ssytrf_aa.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ssytrf_aa(int matrix_layout, char uplo, int n, float *a, int lda, int *ipiv)
     * }
     */
    public static int LAPACKE_ssytrf_aa(int matrix_layout, byte uplo, int n, MemorySegment a, int lda, MemorySegment ipiv) {
        var mh$ = LAPACKE_ssytrf_aa.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ssytrf_aa", matrix_layout, uplo, n, a, lda, ipiv);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, a, lda, ipiv);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dsytrf_aa {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dsytrf_aa");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dsytrf_aa(int matrix_layout, char uplo, int n, double *a, int lda, int *ipiv)
     * }
     */
    public static FunctionDescriptor LAPACKE_dsytrf_aa$descriptor() {
        return LAPACKE_dsytrf_aa.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dsytrf_aa(int matrix_layout, char uplo, int n, double *a, int lda, int *ipiv)
     * }
     */
    public static MethodHandle LAPACKE_dsytrf_aa$handle() {
        return LAPACKE_dsytrf_aa.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dsytrf_aa(int matrix_layout, char uplo, int n, double *a, int lda, int *ipiv)
     * }
     */
    public static MemorySegment LAPACKE_dsytrf_aa$address() {
        return LAPACKE_dsytrf_aa.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dsytrf_aa(int matrix_layout, char uplo, int n, double *a, int lda, int *ipiv)
     * }
     */
    public static int LAPACKE_dsytrf_aa(int matrix_layout, byte uplo, int n, MemorySegment a, int lda, MemorySegment ipiv) {
        var mh$ = LAPACKE_dsytrf_aa.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dsytrf_aa", matrix_layout, uplo, n, a, lda, ipiv);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, a, lda, ipiv);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_csytrf_aa {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_csytrf_aa");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_csytrf_aa(int matrix_layout, char uplo, int n, _Complex float *a, int lda, int *ipiv)
     * }
     */
    public static FunctionDescriptor LAPACKE_csytrf_aa$descriptor() {
        return LAPACKE_csytrf_aa.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_csytrf_aa(int matrix_layout, char uplo, int n, _Complex float *a, int lda, int *ipiv)
     * }
     */
    public static MethodHandle LAPACKE_csytrf_aa$handle() {
        return LAPACKE_csytrf_aa.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_csytrf_aa(int matrix_layout, char uplo, int n, _Complex float *a, int lda, int *ipiv)
     * }
     */
    public static MemorySegment LAPACKE_csytrf_aa$address() {
        return LAPACKE_csytrf_aa.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_csytrf_aa(int matrix_layout, char uplo, int n, _Complex float *a, int lda, int *ipiv)
     * }
     */
    public static int LAPACKE_csytrf_aa(int matrix_layout, byte uplo, int n, MemorySegment a, int lda, MemorySegment ipiv) {
        var mh$ = LAPACKE_csytrf_aa.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_csytrf_aa", matrix_layout, uplo, n, a, lda, ipiv);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, a, lda, ipiv);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zsytrf_aa {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zsytrf_aa");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zsytrf_aa(int matrix_layout, char uplo, int n, _Complex double *a, int lda, int *ipiv)
     * }
     */
    public static FunctionDescriptor LAPACKE_zsytrf_aa$descriptor() {
        return LAPACKE_zsytrf_aa.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zsytrf_aa(int matrix_layout, char uplo, int n, _Complex double *a, int lda, int *ipiv)
     * }
     */
    public static MethodHandle LAPACKE_zsytrf_aa$handle() {
        return LAPACKE_zsytrf_aa.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zsytrf_aa(int matrix_layout, char uplo, int n, _Complex double *a, int lda, int *ipiv)
     * }
     */
    public static MemorySegment LAPACKE_zsytrf_aa$address() {
        return LAPACKE_zsytrf_aa.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zsytrf_aa(int matrix_layout, char uplo, int n, _Complex double *a, int lda, int *ipiv)
     * }
     */
    public static int LAPACKE_zsytrf_aa(int matrix_layout, byte uplo, int n, MemorySegment a, int lda, MemorySegment ipiv) {
        var mh$ = LAPACKE_zsytrf_aa.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zsytrf_aa", matrix_layout, uplo, n, a, lda, ipiv);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, a, lda, ipiv);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_chetrf_aa {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_chetrf_aa");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_chetrf_aa(int matrix_layout, char uplo, int n, _Complex float *a, int lda, int *ipiv)
     * }
     */
    public static FunctionDescriptor LAPACKE_chetrf_aa$descriptor() {
        return LAPACKE_chetrf_aa.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_chetrf_aa(int matrix_layout, char uplo, int n, _Complex float *a, int lda, int *ipiv)
     * }
     */
    public static MethodHandle LAPACKE_chetrf_aa$handle() {
        return LAPACKE_chetrf_aa.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_chetrf_aa(int matrix_layout, char uplo, int n, _Complex float *a, int lda, int *ipiv)
     * }
     */
    public static MemorySegment LAPACKE_chetrf_aa$address() {
        return LAPACKE_chetrf_aa.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_chetrf_aa(int matrix_layout, char uplo, int n, _Complex float *a, int lda, int *ipiv)
     * }
     */
    public static int LAPACKE_chetrf_aa(int matrix_layout, byte uplo, int n, MemorySegment a, int lda, MemorySegment ipiv) {
        var mh$ = LAPACKE_chetrf_aa.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_chetrf_aa", matrix_layout, uplo, n, a, lda, ipiv);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, a, lda, ipiv);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zhetrf_aa {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zhetrf_aa");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zhetrf_aa(int matrix_layout, char uplo, int n, _Complex double *a, int lda, int *ipiv)
     * }
     */
    public static FunctionDescriptor LAPACKE_zhetrf_aa$descriptor() {
        return LAPACKE_zhetrf_aa.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zhetrf_aa(int matrix_layout, char uplo, int n, _Complex double *a, int lda, int *ipiv)
     * }
     */
    public static MethodHandle LAPACKE_zhetrf_aa$handle() {
        return LAPACKE_zhetrf_aa.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zhetrf_aa(int matrix_layout, char uplo, int n, _Complex double *a, int lda, int *ipiv)
     * }
     */
    public static MemorySegment LAPACKE_zhetrf_aa$address() {
        return LAPACKE_zhetrf_aa.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zhetrf_aa(int matrix_layout, char uplo, int n, _Complex double *a, int lda, int *ipiv)
     * }
     */
    public static int LAPACKE_zhetrf_aa(int matrix_layout, byte uplo, int n, MemorySegment a, int lda, MemorySegment ipiv) {
        var mh$ = LAPACKE_zhetrf_aa.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zhetrf_aa", matrix_layout, uplo, n, a, lda, ipiv);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, a, lda, ipiv);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ssytrf_aa_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_ssytrf_aa_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ssytrf_aa_work(int matrix_layout, char uplo, int n, float *a, int lda, int *ipiv, float *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_ssytrf_aa_work$descriptor() {
        return LAPACKE_ssytrf_aa_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ssytrf_aa_work(int matrix_layout, char uplo, int n, float *a, int lda, int *ipiv, float *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_ssytrf_aa_work$handle() {
        return LAPACKE_ssytrf_aa_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ssytrf_aa_work(int matrix_layout, char uplo, int n, float *a, int lda, int *ipiv, float *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_ssytrf_aa_work$address() {
        return LAPACKE_ssytrf_aa_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ssytrf_aa_work(int matrix_layout, char uplo, int n, float *a, int lda, int *ipiv, float *work, int lwork)
     * }
     */
    public static int LAPACKE_ssytrf_aa_work(int matrix_layout, byte uplo, int n, MemorySegment a, int lda, MemorySegment ipiv, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_ssytrf_aa_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ssytrf_aa_work", matrix_layout, uplo, n, a, lda, ipiv, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, a, lda, ipiv, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dsytrf_aa_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dsytrf_aa_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dsytrf_aa_work(int matrix_layout, char uplo, int n, double *a, int lda, int *ipiv, double *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_dsytrf_aa_work$descriptor() {
        return LAPACKE_dsytrf_aa_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dsytrf_aa_work(int matrix_layout, char uplo, int n, double *a, int lda, int *ipiv, double *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_dsytrf_aa_work$handle() {
        return LAPACKE_dsytrf_aa_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dsytrf_aa_work(int matrix_layout, char uplo, int n, double *a, int lda, int *ipiv, double *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_dsytrf_aa_work$address() {
        return LAPACKE_dsytrf_aa_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dsytrf_aa_work(int matrix_layout, char uplo, int n, double *a, int lda, int *ipiv, double *work, int lwork)
     * }
     */
    public static int LAPACKE_dsytrf_aa_work(int matrix_layout, byte uplo, int n, MemorySegment a, int lda, MemorySegment ipiv, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_dsytrf_aa_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dsytrf_aa_work", matrix_layout, uplo, n, a, lda, ipiv, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, a, lda, ipiv, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_csytrf_aa_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_csytrf_aa_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_csytrf_aa_work(int matrix_layout, char uplo, int n, _Complex float *a, int lda, int *ipiv, _Complex float *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_csytrf_aa_work$descriptor() {
        return LAPACKE_csytrf_aa_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_csytrf_aa_work(int matrix_layout, char uplo, int n, _Complex float *a, int lda, int *ipiv, _Complex float *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_csytrf_aa_work$handle() {
        return LAPACKE_csytrf_aa_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_csytrf_aa_work(int matrix_layout, char uplo, int n, _Complex float *a, int lda, int *ipiv, _Complex float *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_csytrf_aa_work$address() {
        return LAPACKE_csytrf_aa_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_csytrf_aa_work(int matrix_layout, char uplo, int n, _Complex float *a, int lda, int *ipiv, _Complex float *work, int lwork)
     * }
     */
    public static int LAPACKE_csytrf_aa_work(int matrix_layout, byte uplo, int n, MemorySegment a, int lda, MemorySegment ipiv, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_csytrf_aa_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_csytrf_aa_work", matrix_layout, uplo, n, a, lda, ipiv, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, a, lda, ipiv, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zsytrf_aa_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zsytrf_aa_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zsytrf_aa_work(int matrix_layout, char uplo, int n, _Complex double *a, int lda, int *ipiv, _Complex double *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_zsytrf_aa_work$descriptor() {
        return LAPACKE_zsytrf_aa_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zsytrf_aa_work(int matrix_layout, char uplo, int n, _Complex double *a, int lda, int *ipiv, _Complex double *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_zsytrf_aa_work$handle() {
        return LAPACKE_zsytrf_aa_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zsytrf_aa_work(int matrix_layout, char uplo, int n, _Complex double *a, int lda, int *ipiv, _Complex double *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_zsytrf_aa_work$address() {
        return LAPACKE_zsytrf_aa_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zsytrf_aa_work(int matrix_layout, char uplo, int n, _Complex double *a, int lda, int *ipiv, _Complex double *work, int lwork)
     * }
     */
    public static int LAPACKE_zsytrf_aa_work(int matrix_layout, byte uplo, int n, MemorySegment a, int lda, MemorySegment ipiv, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_zsytrf_aa_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zsytrf_aa_work", matrix_layout, uplo, n, a, lda, ipiv, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, a, lda, ipiv, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_chetrf_aa_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_chetrf_aa_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_chetrf_aa_work(int matrix_layout, char uplo, int n, _Complex float *a, int lda, int *ipiv, _Complex float *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_chetrf_aa_work$descriptor() {
        return LAPACKE_chetrf_aa_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_chetrf_aa_work(int matrix_layout, char uplo, int n, _Complex float *a, int lda, int *ipiv, _Complex float *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_chetrf_aa_work$handle() {
        return LAPACKE_chetrf_aa_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_chetrf_aa_work(int matrix_layout, char uplo, int n, _Complex float *a, int lda, int *ipiv, _Complex float *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_chetrf_aa_work$address() {
        return LAPACKE_chetrf_aa_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_chetrf_aa_work(int matrix_layout, char uplo, int n, _Complex float *a, int lda, int *ipiv, _Complex float *work, int lwork)
     * }
     */
    public static int LAPACKE_chetrf_aa_work(int matrix_layout, byte uplo, int n, MemorySegment a, int lda, MemorySegment ipiv, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_chetrf_aa_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_chetrf_aa_work", matrix_layout, uplo, n, a, lda, ipiv, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, a, lda, ipiv, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zhetrf_aa_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zhetrf_aa_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zhetrf_aa_work(int matrix_layout, char uplo, int n, _Complex double *a, int lda, int *ipiv, _Complex double *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_zhetrf_aa_work$descriptor() {
        return LAPACKE_zhetrf_aa_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zhetrf_aa_work(int matrix_layout, char uplo, int n, _Complex double *a, int lda, int *ipiv, _Complex double *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_zhetrf_aa_work$handle() {
        return LAPACKE_zhetrf_aa_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zhetrf_aa_work(int matrix_layout, char uplo, int n, _Complex double *a, int lda, int *ipiv, _Complex double *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_zhetrf_aa_work$address() {
        return LAPACKE_zhetrf_aa_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zhetrf_aa_work(int matrix_layout, char uplo, int n, _Complex double *a, int lda, int *ipiv, _Complex double *work, int lwork)
     * }
     */
    public static int LAPACKE_zhetrf_aa_work(int matrix_layout, byte uplo, int n, MemorySegment a, int lda, MemorySegment ipiv, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_zhetrf_aa_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zhetrf_aa_work", matrix_layout, uplo, n, a, lda, ipiv, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, a, lda, ipiv, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_csytrs_aa {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_csytrs_aa");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_csytrs_aa(int matrix_layout, char uplo, int n, int nrhs, const _Complex float *a, int lda, const int *ipiv, _Complex float *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_csytrs_aa$descriptor() {
        return LAPACKE_csytrs_aa.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_csytrs_aa(int matrix_layout, char uplo, int n, int nrhs, const _Complex float *a, int lda, const int *ipiv, _Complex float *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_csytrs_aa$handle() {
        return LAPACKE_csytrs_aa.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_csytrs_aa(int matrix_layout, char uplo, int n, int nrhs, const _Complex float *a, int lda, const int *ipiv, _Complex float *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_csytrs_aa$address() {
        return LAPACKE_csytrs_aa.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_csytrs_aa(int matrix_layout, char uplo, int n, int nrhs, const _Complex float *a, int lda, const int *ipiv, _Complex float *b, int ldb)
     * }
     */
    public static int LAPACKE_csytrs_aa(int matrix_layout, byte uplo, int n, int nrhs, MemorySegment a, int lda, MemorySegment ipiv, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_csytrs_aa.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_csytrs_aa", matrix_layout, uplo, n, nrhs, a, lda, ipiv, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, nrhs, a, lda, ipiv, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_csytrs_aa_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_csytrs_aa_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_csytrs_aa_work(int matrix_layout, char uplo, int n, int nrhs, const _Complex float *a, int lda, const int *ipiv, _Complex float *b, int ldb, _Complex float *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_csytrs_aa_work$descriptor() {
        return LAPACKE_csytrs_aa_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_csytrs_aa_work(int matrix_layout, char uplo, int n, int nrhs, const _Complex float *a, int lda, const int *ipiv, _Complex float *b, int ldb, _Complex float *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_csytrs_aa_work$handle() {
        return LAPACKE_csytrs_aa_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_csytrs_aa_work(int matrix_layout, char uplo, int n, int nrhs, const _Complex float *a, int lda, const int *ipiv, _Complex float *b, int ldb, _Complex float *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_csytrs_aa_work$address() {
        return LAPACKE_csytrs_aa_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_csytrs_aa_work(int matrix_layout, char uplo, int n, int nrhs, const _Complex float *a, int lda, const int *ipiv, _Complex float *b, int ldb, _Complex float *work, int lwork)
     * }
     */
    public static int LAPACKE_csytrs_aa_work(int matrix_layout, byte uplo, int n, int nrhs, MemorySegment a, int lda, MemorySegment ipiv, MemorySegment b, int ldb, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_csytrs_aa_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_csytrs_aa_work", matrix_layout, uplo, n, nrhs, a, lda, ipiv, b, ldb, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, nrhs, a, lda, ipiv, b, ldb, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_chetrs_aa {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_chetrs_aa");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_chetrs_aa(int matrix_layout, char uplo, int n, int nrhs, const _Complex float *a, int lda, const int *ipiv, _Complex float *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_chetrs_aa$descriptor() {
        return LAPACKE_chetrs_aa.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_chetrs_aa(int matrix_layout, char uplo, int n, int nrhs, const _Complex float *a, int lda, const int *ipiv, _Complex float *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_chetrs_aa$handle() {
        return LAPACKE_chetrs_aa.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_chetrs_aa(int matrix_layout, char uplo, int n, int nrhs, const _Complex float *a, int lda, const int *ipiv, _Complex float *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_chetrs_aa$address() {
        return LAPACKE_chetrs_aa.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_chetrs_aa(int matrix_layout, char uplo, int n, int nrhs, const _Complex float *a, int lda, const int *ipiv, _Complex float *b, int ldb)
     * }
     */
    public static int LAPACKE_chetrs_aa(int matrix_layout, byte uplo, int n, int nrhs, MemorySegment a, int lda, MemorySegment ipiv, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_chetrs_aa.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_chetrs_aa", matrix_layout, uplo, n, nrhs, a, lda, ipiv, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, nrhs, a, lda, ipiv, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_chetrs_aa_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_chetrs_aa_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_chetrs_aa_work(int matrix_layout, char uplo, int n, int nrhs, const _Complex float *a, int lda, const int *ipiv, _Complex float *b, int ldb, _Complex float *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_chetrs_aa_work$descriptor() {
        return LAPACKE_chetrs_aa_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_chetrs_aa_work(int matrix_layout, char uplo, int n, int nrhs, const _Complex float *a, int lda, const int *ipiv, _Complex float *b, int ldb, _Complex float *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_chetrs_aa_work$handle() {
        return LAPACKE_chetrs_aa_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_chetrs_aa_work(int matrix_layout, char uplo, int n, int nrhs, const _Complex float *a, int lda, const int *ipiv, _Complex float *b, int ldb, _Complex float *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_chetrs_aa_work$address() {
        return LAPACKE_chetrs_aa_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_chetrs_aa_work(int matrix_layout, char uplo, int n, int nrhs, const _Complex float *a, int lda, const int *ipiv, _Complex float *b, int ldb, _Complex float *work, int lwork)
     * }
     */
    public static int LAPACKE_chetrs_aa_work(int matrix_layout, byte uplo, int n, int nrhs, MemorySegment a, int lda, MemorySegment ipiv, MemorySegment b, int ldb, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_chetrs_aa_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_chetrs_aa_work", matrix_layout, uplo, n, nrhs, a, lda, ipiv, b, ldb, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, nrhs, a, lda, ipiv, b, ldb, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
}

